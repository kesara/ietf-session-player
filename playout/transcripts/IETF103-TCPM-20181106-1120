[
  {
    "startTime": "00:00:07",
    "text": "[Applause] so some artists stupid how is that assist you mean to us we mean it beforehand we are looking for not taker if someone want to grunt here please raise your hand "
  },
  {
    "startTime": "00:03:09",
    "text": "I\u0027m really I\u0027m really hoping not to make it funny okay shall we start people in behind across the door ok restart welcome this is seconds 40 GPM meeting and please make sure you\u0027re in the right room and this is user not well and please keep this in mind if you have some concerns you can find the same contents on the ITF webpage and thanks for volunteering note-taking baby thank you so much and media thank you so much for taking care of jabber and before we start a meeting breezily may remind when you speak up please see your name at the microphone so that note-taker can track your name and this is our agenda for today and as we have already announced we have a single agenda for today which is roster diction and the congestion control in quick and TCP and this is not the user you know discussion topic for TCP and working group but I believe this will be a useful discussion for both quick working group and this VM working group so I appreciate know Ian and Jenna for reading busy efforts thanks so much ok now I don\u0027t want to waste any more time please go ahead yeah thank you your she all right so I guess we get started thank you all for being here awesome so we don\u0027t talk about I\u0027ll make a small correction to what yo she said we are not going to talk about PCP condition control or loss detection very much but we will talk about quick loss addiction and condition control specifically we\u0027ll be talking about draft ITF quick recovery if you haven\u0027t seen it that\u0027s fine you can take a look at it after this meeting hopefully we will bring enough interest for you to do so so this "
  },
  {
    "startTime": "00:06:09",
    "text": "is I\u0027m Jenna Inger and Ian sweat is sitting right next to me and we are the editors of this draft and if you haven\u0027t seen us before or would like to see a talk to us now come say hi next slide let\u0027s say sorry so the goals of this presentation are to discuss quick loss recovery mechanisms we aren\u0027t going to really talk about condition control very much because there isn\u0027t much to talk about there it\u0027s just near Reno with apologies to you Chun who likes to call it Reno we are not going to discuss this very much but I\u0027ll talk about it just very briefly our goal here is to learn about any egregious errors or blind spots that we might have as we walk through these mechanisms if you go know that\u0027s broken then come up and and and and and say that at the mic please that\u0027s partly why we are here because we believe that eCPM has the right experts we\u0027ve gone back and forth on exactly where else we should be discussing this but this seems like the best place to do it and a goal also is to increase engagement 2tc p.m. on the loss recovery mechanism specifically in quick the quick working group deals with a lot of things loss recovery just one of them and so it hasn\u0027t gotten a lot of airtime and it hasn\u0027t gotten a lot of air time with people who understand PCP loss recovery really well so the the goal is that once we get those people up to speed what we currently have going on and quick that hopefully going into the future we\u0027ll have more engagement with those folks that\u0027s you folks next slide nan goals just for the next hour we will not redesign mechanisms here we will not really to get constants here it is not to say that we can\u0027t discuss them or we should not rathole on them be louder at holes and we would love to have them but let\u0027s have them in a different forum we can either do it on github or on the mailing list or in a later session but not this time not now and we will not really get quicks use of TCP standards we\u0027ve agreed to use RFC 62 98 in 56 81 and various other RFC\u0027s that are part of the PCB set as non normative references for quick so our goal is to do this design and build congestion control and loss recovery for quick entirely inside of this document but we use these as infinitive references so bear that in mind and all of these things like I said can be done just don\u0027t do them right now but let me not stop you from coming up to the mic and asking clarifying questions or whatever it is that you might want to ask or say but just bear this in mind as as you come to the mic and a note I will ask questions and I hope to get answers I have long runs here and if you give me a good answer or if you like your answer or whatever you say I\u0027ll throw a long in at you so you can have it all right "
  },
  {
    "startTime": "00:09:12",
    "text": "let\u0027s go on this is roughly what what we will be doing we will go over some relevant quick details that you may or may not be familiar with discuss the recovery mechanisms and discuss open questions before I\u0027m on how many people have read the draft okay this is lovely how many people have not read the draft don\u0027t feel ashamed today I think some people raise their hand twice [Laughter] yeah that\u0027s how many people have read the draft and not understood it so this is good hopefully this will be some of this will be a breeze how many people understand quick itself the quick transport protocol how many people here understand the quick transport protocol I know I\u0027m using understand very fluidly but if you think you do that\u0027s fine that\u0027s really good or bad I don\u0027t know what to think of this is this the quick I think this is the quick working group huh did I raise my hand yeah well I should probably have this man anyways hopefully there are enough tea CPM folks here too who haven\u0027t been paying addition but this also means that people have been paying attention which is great so it\u0027ll be a breeze to go through the first few slides next slide let\u0027s start with just the overview of what parts of quick are relevant next slide first off quick packet numbers quick packets have packet numbers not sequence numbers why are they called packet numbers and not sequence numbers because we didn\u0027t want to conflate the semantics of TCP sequence numbers with quicks packet numbers specifically a quick packet is a container of things those things we call frames the container the quick packet has a packet number this is a 62 bit packet number that increments generally speaking by one for every packet that is sent out there are multiple packet number spaces during connection setup and we do talk about that in the draft and we do want to have multiple loss recovery contexts for each packet number space and so on but that\u0027s in the weeds generally speaking packet number is what quick uses for everything remember that in TCP sequence sequence number talks also about delivery ordering that\u0027s what the receiver uses to order data in the packets that are received packet number in quick does not indicate delivery order we use other things for that packet number is not it so packet number is purely transmission ordering that\u0027s very helpful as you\u0027ll see soon next slide quick acknowledgments remember I told you that packets are containers they\u0027re carried things we call frames one of those things one of those frames is a quick action what\u0027s a quick act frame it\u0027s basically a frame that contains acknowledgment information about what the receiver has seen so far and also "
  },
  {
    "startTime": "00:12:14",
    "text": "what it hasn\u0027t seen so far implicitly so a quick Akram\u0027s contains these fields it carries the largest acknowledge it carries a largest acknowledged packet meaning that in this ACK frame there is a packet number that is the largest packet number that the receiver is acknowledging the second set of fields is the ACK ranges think of this as your sag blocks it\u0027s roughly that the third field is act delay this is an explicit encoding of the amount of time that the receiver was sitting on the largest act before this AG was sent let me clarify that not sitting on but the time since the largest act packet was received - when this act was sent so it\u0027s basically not only but it also encodes any pause times that might be at the receiver in particular it encodes delayed ACK delays at the receiver that\u0027s very useful we don\u0027t have to infer that at the sender anymore and the ACK frame also optionally contains not optional means it does contain three ecn accounts ECT zero is 81 and ce4 easy and stuff again we will not go into ecn stuff here because again the the Sen encoding Magnus talked about in th pwg and we are going to leave it there next slide at generation is close but slightly different than TCP s a receiver is expected to act every other packet this is similar to TCP in that every other packet is act again but we have a 25 millisecond delay that timer we say the receiver should act immediately if the received packet number is not the next expected meaning that the largest received you\u0027re expecting to receive packets are not increasing order of packet number if that\u0027s not the case then you act immediately otherwise you delay the acknowledgement similarly if you receive a congestion experienced coat point from the network then you go ahead and a comedian because you want to communicate that back to the sender as soon as possible we have a caveat for for processing more packets before sending an ACK this is particularly useful when you\u0027re in user space because the receiver might not be scheduled right now and by the time it gets scheduled multiple packets have arrived and are queued up in the kernel buffers and then the application goes and reads all of those packets you don\u0027t want to have the receiver send out acts for every two packets there it makes no sense the receiver might as well drain the entire kernel queues and then send out one ACK that acts everything that it has received so far so we want to allow for the receiver to act less frequently that\u0027s not the only case where we want to act less frequently but we will talk "
  },
  {
    "startTime": "00:15:14",
    "text": "about acting less frequently later but that is allowed in quick next slide and we\u0027ll jump soon into the recovery mechanisms and those are all timelines just you know timing diagrams so and to understand those timing diagrams I will introduce some notation here that will be useful and I\u0027ll repeat this as I show the timing diagrams just to make sure that you\u0027re all clear on what you are looking at a packet that is sent is shown with PN X that means this is a packet with packet number X and an act that is sent is shown with this notation a which implies ACK followed by X which is the largest act followed by a crane jiz if you note this particular notation for act this is very similar to sac notations with one difference X here is greater than the ik ranges when you show TCP sacs you usually so the cumulative ACK point followed by sac blocks and usually the sac and always the sag blocks are greater than the cumulative ACK point in quick what you will see is the largest act followed by a crane just so the largest actives always made larger than everything else in that block in that in that frame next slide is everything everything clear so far any questions any clarification okay good because if you\u0027ve not been paying attention so far pay attention now that\u0027s all I\u0027ll say hopefully you\u0027ll follow along so quick and easy PR trick is quite similar it\u0027s actually the same but you know you trip up on small things oh wait a second that looks different and it is so that\u0027s sort of the thing that you\u0027ll see in these mechanisms and I\u0027ll try to note them as we go so quick uses mechanisms it doesn\u0027t necessarily implement them in in this sort of distinct ways but it implements the functions of fast retransmit earlier I transmit a loss probe rtos and also implements spurious audio detection for congestion control as I said earlier quick implements new Reno there\u0027s a very small caveat that it is the largest act that ends the recovery period I won\u0027t dig into that right now but it\u0027s an important caveat remember that TCP the recovery period is ended by the cumulative act point moving past the recover point and that can often cause me a TCP to be in recovery mode for more than one round-trip time when you have multiple losses in a window in particular but with quick you will always leave recovery within a round-trip time which is really the ideal property that we want even for DC D but we can\u0027t have because sometimes you can\u0027t have nice things but in quickly can so we do next slide and now "
  },
  {
    "startTime": "00:18:17",
    "text": "we jump into recovery mechanisms we will start with the favorite of the bunch fast retransmit also known as the 3do pack mechanism so here\u0027s the first time you\u0027re gonna see the standing diagram so I\u0027ll let you take this in slightly slowly but take it in because I\u0027m not going to go slowly on the next one what do you have here on the left side left side is the sender marked as s in the receiver on the right side mark with R and time goes downwards okay so time is increasing down and you can see that the sender is sending model this is not to scale by the way for any definition of scale so the the left side is is showing you packet numbers of packets that are transmitted the right side is showing you acts that are sent back towards the sender okay I hope that\u0027s clear and obvious and that little explosion that you see there is not just for fun it\u0027s actually showing you that a packet got dropped and yes it is an explosion so the packets here are packet numbers 1 through 5 are sent from the sender and they all go towards the receiver except packet number 2 is dropped packets one packet one is receiver the receiver is not act immediately because the receiver delays the sack receives packet number 3 and goes I\u0027m gonna add this immediately and since an act back if you notice the ACK has the largest act of 3 and has an ACK range of 1 of 1 it acts 3 and 1 basically packet 4 is received again the receiver acts 4 3 \u0026 1 5 was received at the receiver acts 5 4 3 n 1 okay so 2 is not act the the sender sees that 3 missing reports three times the receiver has or 3 packets have been received marking 2 as potentially lost and after 3 do backs this is the packet threshold of 3 the sender retransmits packet number 2 so question Aquos what do you notice different about this than what you would see in a TCP fast retransmit timing diagram - is never act excellent who said that you get along in Stuart I\u0027m so sorry about that I just realized I\u0027m gonna be creating a mess for the cleaning people here I\u0027m I\u0027m sorry they are not durians yes indeed that\u0027s a good point Thank You Stuart picked it up thank you so much yes that is exactly right that is one thing there\u0027s another thing in here another longer than its take excellent Daniel Daniel said to is not "
  },
  {
    "startTime": "00:21:18",
    "text": "retransmitted it is sent as six you get a long into I\u0027m not gonna keep doing this by the way as you can see my sense of scale in this room is completely broken so I\u0027m going to stop this now sorry if you were long and come pick it up at the front this is not going very well and I can\u0027t read transfer that long didn\u0027t sorry so yes packet number six packet two is actually sent as packet six this is a pretty big difference it\u0027s a subtle point here but it\u0027s a huge difference because this shows up later so as you can see packet numbers are monotonically increasing despite the fact that six actually carries data that is retransmitted it from a packet number space it doesn\u0027t matter it simply looks at six what\u0027s that a question Mike say it\u0027ll repeat it the mike christen these are all yes yeah okay number six may or may not repeat the content of back in about two correct that\u0027s a good point okay so packet number six may in fact contain nothing from packet to in the extreme case or you may contain something for packet to and something from something else or whatever good clarification okay thank you yep so this is partly why we calling the draft detection because you don\u0027t necessarily retransmit data this is because some frames in quick that we want to detect as lost we may not retransmit and that\u0027s completely reasonable and fine this is also true for data application data which an application can cancel in quake and we want to detect them as lost but we won\u0027t retransmit them yeah that\u0027s why I was gonna add it\u0027s possible that nothing gets sent you just declare and declare lost and you\u0027re like yeah that\u0027s fine yeah but you want to know that it\u0027s lost so yeah excellent points all so that\u0027s fast retransmit for you that\u0027s mostly the same next slide this is something that you may be familiar with this is often called the fact mechanism in Linux it\u0027s a forward acknowledgement it comes from yeah it\u0027s called forward acknowledgement the idea here is that you don\u0027t need to wait for 3 ack packets to be received explicitly as long as a packet is received that acknowledges as long as an ACK is received that acknowledges it packet that is threshold distance away from a packet that you want to mark as lost mark that packet has lost specifically in this case the sender receives exactly one add that one ack acknowledges 5 4 3 \u0026 1 what this means "
  },
  {
    "startTime": "00:24:22",
    "text": "is that because packet number 5 is acknowledged immediately the sender can mark packet number 2 as lost and retransmitted if it should be retransmitted so this is called frak it\u0027s a minor modification to fastly transmit and it helps in cases where for instance app packets may be dropped on the floor the other place it helps tremendously is when you want to reduce the number of acts that are being sent from the receiver so this allows you to compress or not send as many acts as you would have otherwise to trigger a fast retransmit hi a cherry from Apple I have a quick question and if this is a rathole we shouldn\u0027t take time on it we just had a bunch of discussion about how six might not be a retransmission of to my tree transmit some of it and not others is there something in there that tells the receiver consider this to be maybe not a repeat of two but recovery from that so that it knows to go out of the duplicate ahmed where it\u0027s acting every packet no so how does the receiver know that that gap number two will never be filled in and it can stop worrying about it right so it doesn\u0027t that\u0027s a short answer the short answer is that the receiver never knows that gaps will be gaps will never get filled if because the sender is not already transferred them but we have mechanisms in place for the receiver to stop reporting them that\u0027s the more important thing here so quick by definition a receiver has to basically think about gaps as the normal case and that\u0027s how it operates which is why you want to allow for fewer acknowledgments even when there are gaps and the receiver will stop reporting some gaps after it knows that the sender has heard that at least once that\u0027s really the goal here so thank you for the question yeah that\u0027s an important in a good question in story I mean if I\u0027m gonna file an issue on that just attract because I think the text is not quite as clear about what might be optimally done I think you basically might send an immediate ad for every single incoming packet at the matheus for an entire RTT or at least it\u0027s a little bit too vague about what might happen so I think it deserves clarification it\u0027s a good one next slide so we\u0027ve added one thing as we do we\u0027ve added an optional time threshold based retransmission mechanism in quick this allows for a sender to ignore packet thresholds and wait for a certain amount of time before it declares a packet lost of course thus the the sender is expected to receive at least one ACK that indicates that a packet has not been received before it marks it as lost but that\u0027s the general idea here "
  },
  {
    "startTime": "00:27:23",
    "text": "this helps with with avoiding this this helps with reordering reordering is one of the things that trips up fast retransmit quite a bit and if your reordering is is is under a threshold of 3 that works out alright but if the reordering is greater than a threshold of 3 the packet threshold of 3 then that causes problems this is again I don\u0027t want writer on this right now specifically because this is this is the time threshold one is one of the open questions I\u0027m going to ask about this at the end and we can definitely talk about this at that point yep next slide so yeah times we showed allows reordering tolerance and packet space and you can see that there\u0027s a computation that we do based on our DD and the latest artery that you see there in that computation is the latest oddity sample that is used next slide early transmit again something we are all familiar with but with a small twist so how many of you know early transmit in TCP three people okay five people good early retransmit the the problem that early transmit sets to solve is basically what do you do so remember fast retransmit right you a sender retransmits a packet when it receives three acknowledgments that mark that packet has lost or the center with faq it\u0027s that the third packet beyond it has been acknowledged but what if they aren\u0027t there are in three packets after this packet that is lost what if there\u0027s exactly one packet that you sent after this packet you\u0027re never going to get the three packet gap or the three packet distance from the packet you\u0027re trying to retransmit or you want to detect as lost as in this case package one two and three are sent to is lost and you receive one ack that says three is acknowledged and one is acknowledged but you\u0027re never going to get an AK 4 5 which is what you want to trigger a fastly advancement so early you transmit basically what it says is we will in this case the sender knows that there\u0027s no foreign five so the sender will retransmit to based on the single report that it received from the receiver because that\u0027s all it\u0027s gonna get from the receiver there\u0027s a problem with just doing that and I\u0027m saying right now ignore the the the time that I\u0027m showing there in that slide if the sender was to retransmit for immediately on receiving that first report it makes itself vulnerable to simple packet reorderings back at twiddles in particular and so that\u0027s something that in practice happens a lot and so the Linux implementation does this implementation of this timer for TCP and so we borrowed that out of the Linux implementation and we have a timer that says if you received one just give me one second Bob if you receive one ACK then just wait for a little while and then we transmit but I just realized the "
  },
  {
    "startTime": "00:30:24",
    "text": "answer to my question I thought X was the packet number but it\u0027s a multiply yeah sorry yes so that\u0027s really the transferred for you next time and now we are going to go into the timer based mechanisms specifically TLP RTO crypto and the handshake timeouts and things but to do that we need to understand the rtt measurement mechanisms in quick so very briefly RTD is basically sixty to ninety eight there\u0027s nothing that\u0027s different about this than the standard TCP mechanisms except for one difference the RTD sample we do something to make the RTD sample cleaner so to speak so specifically remember that I talked about AG delay whether you are explicitly encodes the amount of time that it\u0027s sitting on and a packet before aking it the delay rack time or yeah we know that so we can remove it from the RTD measurement explicitly now understand that we will bring this back later because we do want to know how long we should wait how long a sender should wait but the RTD measurement is expected to be a network RTD measurement and that\u0027s the semantics here it\u0027s slightly different from the DC dr/dt measurement which is not a network RTD measurement it is a expected response time measurement basically because it includes the delay rack timer so as you can see here the oddity measurement is the time when the AK has received to the time when the packet was sent - the delay that the receiver reports in that AK the receiver also or not the receiver both endpoints also declare at the beginning of a connection the maximum that they will delay acts by this is called Max AK delay and you may be familiar with a similar max a grade a proposal for TCP that\u0027s been floating around and T CPM and that\u0027s basically used in this case in later thing but this is the max AK delay is the repeater is an endpoint sorry unilaterally declaring how long it will what\u0027s the maximum amount of time that it will wait before sending an ACK back and this informs how we do timeouts so if you look at the timeout computation the time of RTO computation is the same as for TCP as far as in sixty to ninety eight but there\u0027s an additional max AK delay remember that the RTD sample itself does not include the active a here whereas in TCP it does so the SRTP computation the smooth the RTD computation therefore in in quick does not include the AG delay and so when you\u0027re waiting for an AK from the receiver you want to compensate for that you want to wait for the AG delay because the receiver might be waiting for that period of time so we explicitly add the max delay in the RTO computation so we bring it back TLP again similar we "
  },
  {
    "startTime": "00:33:24",
    "text": "use 1.5 x sr DT this is based off of the now-defunct and expired TLT draft but we are can explicitly add the Mac side delay back in and you have mins for both of these our min audio is 200 milliseconds informed by what we\u0027ve seen in practice in Linux and the min timer for TLP is 10 milliseconds that\u0027s completely arbitrary I think but it comes from the TLP expired TLP draft and I think it was arbitrarily there well looks like such a minute has passed so you have another 30 minute thank you oh boy this is not fun I\u0027m gonna go and race through this if you have questions come to the mic when I\u0027m trying to but I won\u0027t have discussion and and and I want to leave some room for discussion later okay so RTO is basically the same as DCP but like I said eating oh sorry this is TLP my bad for people who don\u0027t know TLP I\u0027m not gonna go into the details it\u0027s it\u0027s the last packet offered of a train the last packet that\u0027s outstanding if it\u0027s lost it\u0027s useful to have a quick timer that that that fires and and send something out that\u0027s what TLP does if you know TLP this is exactly the same as TCP TLP there\u0027s no difference at all and it includes as I pointed out max actively there\u0027s one small difference in the overall mechanism next slide the TCP PLP draft which is again now defunct an expired specifies using one TLP before going to an RTO we do two TL piece because we found that this is actually helpful so we do two TL piece before we give up on doing telescopes that\u0027s what I\u0027m gonna say about this note that there\u0027s no back off here because the back office is not required next slide RTO after a TLP if all your TLPs are getting dropped in the network we need to we fall back on a an RTO timer and the RTO timer is seated as as as shown on the slide there and this is again includes explicitly includes max ACK delay and has a minimum value of 200 milliseconds according to the draft right now next slide and this brings us previous audio detection this is actually all the cute things about about the way the mechanisms work out and quick remember I told you that in quick we don\u0027t have we don\u0027t repeat packet numbers right we never repeat packet numbers now this is a bit of a pain in TCP because if you want to detect that this is where this is what leads to retransmission ambiguity and when you receive an act for a packet you don\u0027t know if the a cause for the original packet or a retransmission and so on in quick there is no such ambiguity because every packet is that back in number exactly once so in this case this is the case where there was in fact an ordeal this is the same as the previous slide the RTO fires six is sent as the retransmission let\u0027s say and then as acknowledged when the acknowledgement comes back the sender "
  },
  {
    "startTime": "00:36:25",
    "text": "looks elegant goes does his ack-ack anything that was sent before six does this agonizing newly does it act five for example or four if it does then my rtos was prettiest if it doesn\u0027t mayority or was legit so quick calls the RTO verified at the time that it receives the first stack after the RTO that is an important moment in time next slide because of what\u0027s going to be shown on the next slide if this happened where four was sent got delayed didn\u0027t get dropped in the network booked got delayed and eventually was received and then the sender retransmits five and six and then receives an act that says for exact quick calls that RTO spurious so that is the same moment in time the first act after the RTO and that moment in time quick makes a decision about the RTO event itself what this means is that quick does any changes to the congestion controller and so on at the moment where it\u0027s able to either verify or call the RTO spurious it does not collapse the condition window when the RTO happens this is again a difference from the way TCP does things TCP collapses the condition window on an RTO and then tries to reinstate it later we don\u0027t do anything until we know for sure what happened that\u0027s a difference next slide that\u0027s what this slide says basically that if we detect the packet as spurious later we do nothing nothing no changes to the congestion controller basically it\u0027s a no op but at the moment of verification if we detect the act as the RTO as valid then we apply condition control actions and there\u0027s some discussion on this going on right now but yeah that\u0027s the shape of things next slide crippled I\u0027m out this is the equivalent of the handshake timer in the syn synack timers in DCP except it\u0027s a lot more complicated and quick because it includes a crypto handshake so and we have different levels of encryption and various other things are possible there so the the general gist is that this is set aggressively this is set aggressively because we want to recover from from from losses in this early stage as quickly as we possibly can this is a critical part of the communication this is a setup we have no idea what\u0027s going on on the network but we want someone to be a bit aggressive so before any RTD samples right now 200 milliseconds is what is used and after our daily samples we use two times the s RTD for a crypto timeout this is the timer that\u0027s used for all handshake packets not just for the first one but for all of them and there are this of course exponential back-off on consequent timeouts and when the timer fires we transmit all all symmetric to packets this is still this is again one of those things which we need a little more we are discussing continue to discuss this "
  },
  {
    "startTime": "00:39:26",
    "text": "too and there\u0027s going to be some more clarity on the text here but that\u0027s what it is right now next and that\u0027s about the end of what we\u0027ve got so far go over this very quickly there are some potential improvements we are discussing and things that are open questions which we love your input or for you to be engaged in the first one is generating here ax TCP says the spec says generate an ACK once every two packets in practice there are wireless drivers and metal boxes that compress acts that drawbacks when they know that subsequent acts are going to simply replace the information and in effect the network has fewer than one act for every two packets so the question for us is given that quick will not see the sin of compression and will never see it because the acts are encrypted instead of packets what should we do as default should we do too because that\u0027s what the book says for for TCP or can we live with for should be what\u0027s the default what\u0027s a good default for us years it\u0027d be nice to have a higher number there we can live with it this of course has implications to the condition controller as well so this is a bit of an open question we right now have two on the draft but this is definitely something that we can discuss a fake question it is included will be included in version 1 what this is talking about but we are talking about bison - I\u0027m sorry anybody talking about what listen these guys will be included in version 1 oh well so this is the new version 1 okay version 1 says right now the draft says ACK every other packet the question is should we change I think he was asking kind of are we are we open to making changes or improvements that are in the next three or four slides yes in in this time for improvement I think I think the short answer is is yes but you know sooner is is better and obviously at some point yeah it\u0027s just gonna we\u0027re not gonna hold up let\u0027s put it this way we\u0027re not gonna hold up the quick drafts for for an improvement here if it\u0027s not ready and it\u0027s not obvious that it has working group consensus out there in the quick working group T CPM or both then we\u0027ll just wait until yeah I think that is so you interrupted you I was just gonna say that the people are showing up at the mic and maybe we should start should we start the discussions with these slides or should we go through the last couple of slides and then load just a couple more slides on questions should I finish the slides okay go to the next slide yes clarification yeah on that question of what would be allowed in the one is it would it be completely out the question to start talking about sender control of "
  },
  {
    "startTime": "00:42:27",
    "text": "receiver acts as opposed to just a new default no it would not be out of the question okay it\u0027ll totally be something that\u0027s within within reason okay next slide this is another one and this is sure to raise or have a lot of discussion is to remove the minority or entirely it\u0027s something I would love to do we would all love to do the argument is that we\u0027ve communicated my exact delay explicitly and we know various things and the most important thing here is that the minority on TCP it\u0027s written in six mm id8 was there too to avoid spurious audios given that the cost of a spurious RTO isn\u0027t really that high in quick there\u0027s a real question of do we care and if you don\u0027t care then it really helps a lot because it allows us to recover from our RT from from RTO level losses quickly that\u0027s a huge change so it\u0027s something that we\u0027d love to be able to do and it is a question that we\u0027ll discuss in the past we\u0027ve sort of held off on really rattling on this because we\u0027ve had to work on many other things but this is something we\u0027d love to discuss and maybe even make happen next slide there\u0027s a potential time of simplification to combine TLP and RTO if you have noticed this we thought about this in the past you would know that TLP and RTO looks very very similar to each other and again in quick we can basically make them exactly the same so the point again is that we don\u0027t have to deal with the cost of a spurious RTO very much so the question is can we combine them and make this one mechanism can you explain why the costs lower because because the cost of a spurious specifically a spurious retransmissions is lower because when you receive an acknowledgement that\u0027s when we make a conditioned control decision and if it was prettiest when you receive an ACK you know it was prettiest and you do nothing to the transition controller basically quick pool detectives previously transmitted and not have any condition control effect we can talk about this later if you want there was a slide earlier I can go back to that I think what you\u0027re saying is that the cost of RTO is when it is when you make a change to the congestion control algorithm right when you make a congestion control change that\u0027s the cost what you\u0027re saying here is that there isn\u0027t the cost because we detect that it\u0027s spurious okay so we don\u0027t actually make the change to congestion control we\u0027re not paying like the cost of the retransmit itself is the same but the constant of your modification of how you view your congestion control state is mitigated by the detection in fact we should say the impact of the RTO is lower so sort of course I mean you are sending exactly as when you bite on the line and things like that is the impact fair enough I\u0027m there\u0027s a bandwidth cost and there\u0027s a throughput cost the bandwidth cost doesn\u0027t change the throughput cost does stewardship I was "
  },
  {
    "startTime": "00:45:29",
    "text": "back say something very similar I think people talk about cost different yeah does it cost on the networking wasted capacitive is a cost in terms of the throughput of the connection dropping my other comment was about this I agree with the first point whenever I read about TLP it always just seemed to be a different fine-tuning of the time out when there\u0027s only one packet in flight and so I agree unifying those makes perfect sense thank you yeah so there is this first retransmission and detection in TCP as well right that is but the 60 to 90 does not assume that if RTO is not required right that\u0027s a problem it\u0027s like frozen cue let\u0027s take that yeah I\u0027m sorry for keeping ringing hello can you hear me yes yes several things so the TLP draft is expired but the back draft in TCP now subsumes t.o.p and that\u0027s active so about ax generation of ax right so TCP already does projects today because of things like LRO so I actually don\u0027t see a big problem in moving away from - because looks like the conditional controller as documented in the quick draft already does like appropriate by coating with ordinal limit so in terms of congestion control there\u0027s not a big problem if you\u0027re racking less frequently because they\u0027re already counting bytes and that seems fine and in terms of combining TLP and our deal implementation wise the TC implementation at least Windows already kind of uses the same time so it kind of makes logical sense they\u0027re never active together and they follow each other so it would make sense to combine them because it\u0027s more points right ask packet sent LP that is true yes it\u0027s the same timer for sure yep that\u0027s good feedback this is the last slide again questions on fast retransmit how do you how do we deal with the packet based in the time based on the time Jason was really not present in TCP standards it\u0027s there in code to some degree for the early transmit for instance but it\u0027s something that we are thinking about we folks have been experimenting with it with the time-based threshold ring in quick and so there\u0027s that\u0027s something that we are interested in considering moving forward as well and I\u0027ll end the presentation now open the floor open the floor for questions we have 12 minutes yeah super diner I was wondering when you mentioned unifying the Thea peon RTO behavior at you in that unifying the effect of the RTO verified as well or eliminating RTO verified in that case we you couldn\u0027t element the RTO verified because you want to detect "
  },
  {
    "startTime": "00:48:30",
    "text": "so so here\u0027s the way to think about it call it all retransmissions we just not do it aggressively that\u0027s all and we can do it aggressively because we are gonna do the verification later so maybe one way other way to think about it as eliminate PLP and just do or do not aggressively so the effect of an act of the TLP is different from the effect of the currently in the quick drafts the effect of Akron TLP is different from the effect of arc of an RTO which is an effective market our TLP just triggers packet threshold based loss affliction or packet time-based loss section missus RTO triggers min RTO verified and actually goes to min Seawind at the moment so I\u0027m wondering what you are thinking about in terms of unifying those two behaviors yes it does do that but it also will do packet based right I mean if you if you had if this was going to also trigger and I would agree with that step and yeah I don\u0027t gee I don\u0027t have a clear answer for that question at the moment to you know I do me like I think so what is saying is right I\u0027m trying to think about the implications on on on packet threshold based retransmission and we can definitely discuss that more but yeah I agree that this would basically have the same effect then so I think it may be a better way to phrase answers to say the move TLP and just make it out to you aggressor right I think what the reasons we want discussed this in this working group is because we think it\u0027s an area of potential improvement for both TCP and quick and I don\u0027t think either of us have if I had a clear answer I would just put it up on the slide and say oh I should do this but I don\u0027t I\u0027ve been thinking about this for like a year and a half and I\u0027m really came up with a very clear answer yeah I think we can do it but we had to try and see something you have a question Stewart Stewart chair again I have a question for the quick people and maybe the TCP people as well something that\u0027s puzzled me ever since I learned about this I know the stand you talk about the retransmission timer like TCP s is the mean round-trip time plus four times the variance and what\u0027s odd about that is that those units don\u0027t match up because the mean is at time and variance is x squared and what that means is if you\u0027re measuring it in seconds or milliseconds you get radically different answers and I always assumed that back in the 80s calculating a square root was an expensive operation on the computers at that time in today\u0027s world is that it\u0027s very better algorithm because "
  },
  {
    "startTime": "00:51:30",
    "text": "intuitively what we want to do if we assume there\u0027s some normal distribution we want the retransmission timer to be set three or four standard deviations out so that there\u0027s always a probability that we\u0027ll guess wrong but we want that probability of a spurious retransmissions to be sufficiently small it\u0027s too bad that when Jacob son is not in the room because I mean he was using violence but it\u0027s not meant violence in statistical term what was computed was a tweety average Delta between the measured average so far and the values which statistically is proportional to the standard deviation it\u0027s something like square root of two times the standard deviation on the bell curve that it\u0027s yeah I can I can point her to the reference actually this is discussed and I think the in non Jacobson\u0027s 88 paper in an appendix but there\u0027s there\u0027s a yeah exactly what Christian said okay well thank you for answering that question so it sounds like it\u0027s mathematically sound - variance is technically the wrong term yes it\u0027s on variance of the distribution but but the second point about other better algorithms absolutely there are and I think that\u0027s something for folks to try out we aren\u0027t going to standardize it because this analyzing nari√±o here for a reason right it\u0027s easy to do it\u0027s hard to figure out what what better answers and we don\u0027t want to spend time on that right now and here but I think it\u0027s a good time to after we\u0027ve gotten the first round of quick done it\u0027s a great time for folks are thinking about better algorithms for these things come on I rushed through the last few slides so you could ask questions oh no Yoshi I\u0027m sorry I didn\u0027t realize even going up to ask questions I wasn\u0027t talking to you Yoshi or to the rest of this room hello Hebron hey so question on time base last detection so I actually sent this question over to the ministers where it seems to me that it kind of subsumes packet based launch detection in the sense that the way it\u0027s documented currently if you do time based detection and FAQ and TLP then you don\u0027t really need to do er so my question was having that boolean variable in there just seems to be confusing things a little bit more what it\u0027s worth we have never implemented here in Windows TCP and we seem to be doing fine so question is can "
  },
  {
    "startTime": "00:54:31",
    "text": "you repeat that you don\u0027t do er yeah but what you do it\u0027s it\u0027s basically fact TLP and and rag to clarify do you when you do facts so you declare a packet lost if it\u0027s a three out of order or if it\u0027s over at the time reordering threshold is that correct yeah okay okay we we thought so we just want thank you for verifying and and that works yeah that\u0027s that\u0027s definitely useful that\u0027s super helpful yes that was like one thing that is very confusing the RF unite know that boolean variable that that\u0027s like you know actually it says the the default for time there\u0027s no detection is off whereas TCP seems to be going the other direction where you\u0027re saying I can do yeah so this yeah sorry gone no that\u0027s it so so you\u0027re absolutely right I think neither you nor I has been you never argue that the pool eNOS is clarifying it\u0027s actually that\u0027s why we have this question you would like to combine in fact the question was and I changed it but I shouldn\u0027t have how do you combine packet and time threshold so we don\u0027t have that boolean first because even with the boolean off you still have ER with the timer which is current kufi and so what we call time threshold based this is kind of broken there but I think yes we definitely I think this is something we\u0027d like to do in v1 is to try and figure out how to fix this so we are talking about this now and so thank you for that input Michael Mike reversal are we now on a general question suggestion session or is that is that about that slides yeah no no we\u0027ve been on that for 10 minutes still the same slide a general thing okay what\u0027s the last light what\u0027s the last one okay so not having followed quick very close they are not sure if that has maybe already been discussed but I presume that acts carry these continuously growing packet numbers as well all right so that would make it very easy it should make it very easy to do a congestion control which not so long ago Ingemar has presented as well he said that you know we may actually need something like that I think the big issue with FCC and TCP is that it\u0027s pretty hard to figure out how many acts really really were lost or were transmitted in quickly should be quite clear so that would be a simple message to tell the other side to say well you want to reduce the accurate to be adaptive in that that\u0027s a good point we yeah that\u0027s a great point actually it\u0027s something that can certainly be done but care has to be taken to not affect the condition controller on the send side of course we know that implications but yeah it\u0027s it\u0027ll certainly be an easier thing to do and quick the question is can it still be done well but yes it\u0027s certainly something worth giving a shot in "
  },
  {
    "startTime": "00:57:32",
    "text": "particular one on that I want to comment that I think put the congestion controller and the application have various reasons why they might want to change or have an input on the acknowledgment strategy so for things like for unreliable transports you you want enough information to do congestion control but you\u0027re less much less sensitive to loss recovery delays so as an example suppose anger I remember the last time don\u0027t exactly when the presentation was on rack about adaptive thresholds or AK thresholds as well I\u0027m wondering if we\u0027re planning to keep up with that and do gate I don\u0027t know whether we have the mechanisms and quick at the moment to be able to do what Rack is doing at the moment with believe they\u0027re using D socks or something I\u0027ve I it was a while ago but are we planning to do that work as well and set the quick so we aren\u0027t right now in part of this goes to the spurious detection as well I think because we actually while we do spurious RTO detection we don\u0027t do spurious fast retransmit detection and that\u0027s something that we could do it\u0027s something that maybe it\u0027s worth opening an issue about yeah we haven\u0027t discussed this but yes well we have texts and spurious retransmissions reaction now but we don\u0027t have the text on undoing a congestion window yeah right but no we don\u0027t apply this for us retransmission direction on a fast retransmit we do it on the on the I do yeah yeah okay this is yours\u0027 initiative from for so yep I have very general comment and then so at first I think you know quick starting from based on TCP and then becoming compatible with PC but especially you know thing you talk about second half of the one you know it\u0027s syncing nothing that the last one this is we there are some proposal in TCP Empire it\u0027s not even not a backing group items well so we are not running a standard feature but still quick want to utilize such kind of widget so it\u0027s seems to be quick is deviating from TCP standard and also I\u0027ve dragged to understand what does design principle quick with no congestion control recovery mechanism um so to if I understand your question correctly you\u0027re asking you\u0027re saying that yes we\u0027ve deviated from the TCP standards yes your question what do we then use as a guiding principle if it\u0027s not easy P standards right and then so what\u0027s what\u0027s aiming for quick so because you know if any a quick and TCP connection share the same bottleneck danger but how much you know quick anticipated be fair that\u0027s my question so it\u0027s the first answer to that is we\u0027ve tried to follow best practice in terms of TCP implementations we\u0027ve taken a lot of cues from the Linux TCP "
  },
  {
    "startTime": "01:00:32",
    "text": "implementation for example so the thing that\u0027s sharing the bottleneck is a real TCP implementation not the standard right so that\u0027s what we try to bring into the quick standard is what is common practice right now in TCP the the second point is that I think some of these things make a ton of sense even in TCP and they should totally be used in TCP too and pretty much everything that we\u0027ve discussed here has been present in has been proposed for TCP in some form or the other TMP is a great example there\u0027s no standard at all but implementations do it every freebsd does of the next asset these things should be sanitized these things should be done nd CPM and they should yeah at that point we won\u0027t have much differences this become standard RF e YX fame inter RSV the call right now is is standard track live secretary quick charter says that we should phase we\u0027ve ship with TCP comparable Africa the exact wording but basically we\u0027re not trying to do anything beyond what what TCP does but the question is what does Jesus we do so the but the good news is also we are we are about to freeze the - 17 drafts which are the ones that are currently open for editing in in and we tried to then only update and based on implementation experience now that in some sense the good news is that the recovery draft specifically which all of this is about hasn\u0027t actually seen a whole lot of implementation experience yet so I expect it will be relatively easy to motivate changes to that yeah also because you know creation controls and recovery is difficult but it\u0027s not actually a huge amount of code that needs to change and so I would think that we can probably get the implementers to agree that that we want to keep making the recovery draft better while we are in this freeze phase simply because so far nobody\u0027s really done much there so I think my expectation would be that although in in quickly we\u0027ll hear later that we\u0027re going to freeze everything and changes are going to be very very hard and so on I think this particular we actually do want to get it right because yeah nobody has an interest of shipping and who does she control her with quick version one that doesn\u0027t work right yeah thank you for saying that and that\u0027s a thing that\u0027s important for people who haven\u0027t been following the process and might want to engage now there\u0027s room for engagement but do it soon and because we\u0027re gonna try and close even this not too long from now but it\u0027s gonna be less aggressive than the gentle drafts Tommy Polly Apple yeah so I would agree with Forrest that we should be willing to kind of iterate and update this regarding kind of like how it relates to TCP and making sure it\u0027s compatible and in scope in that regard I think it\u0027s useful to distinguish kind of "
  },
  {
    "startTime": "01:03:34",
    "text": "like the differences of what quick has available as information and what is Hannah doing on the wire format from how it\u0027s using that information so like it certainly has more accurate signaling to get this information and so in that regard it deviates from what TCP could ever do but I think what are the ways that we can kind of look at the net result of you know what happens for the actual bytes as opposed to the signaling to see this is equivalent to TCP in terms of how it will behave if TCP had perfect information let\u0027s say I think this is one example of that MIDI I was pointing out that TCP has prettiest audio detection for example right if you were to assume a perfect world where TCP was doing that all the time then absolutely being good I think we could have the general more broader discussion of shall we remove minority Oh unfortunately some implementations don\u0027t all implement frt or some sort of spurious retransmissions please audio direction if you can assume that then maybe we could have the conversation for just those implementations that actually do spurious but yeah so I guess just in these conversations it could be useful so you define the metric by which we determine how is this compatible with TCP and have the bounds of that question so I think we shouldn\u0027t limit what you can do for quit the first version of quick I agree with that I think that\u0027s I mean you know just to extend that point I think that these are both evolving pieces work and I think they can learn from each other to the extent that quick can learn so I Pacific and learn from what we want to do and quick I think that\u0027s helpful and we want to engage there as well so meeting the tango so I have one last question so since you know this discussion seems to be very active and then we have lots of productive discussion so so we should continue the discussion on the mailing list why you want to have another kind of decision maybe this is a question for quick quality or some other ad you are suggest that we could do something like this again in the next IDF but I mean I don\u0027t think we should wait until then to have discussion but if you have discussion we definitely expect to see changes between now in in Prague and at that point I could come and do another update and do another session where we have more discussion right yeah so Laura tiger I think is actually sort of - asks here at one ask and this is what I think this session was about is please help us fix the recovery drafter we\u0027re going to ship initially with the initial set of quick documents so that is good and and as close to TCP as as we can make it but ideally no worse and ideally also not way more aggressive right so basically help us write something that the is we will not discuss in terms of you know is still TCP or not you know um the second ask I think is longer-term and I think this is also what maybe Tommy was getting at that there\u0027s a whole bunch of new information in quick that can lead to better congestion control in the future right and and that is a worthwhile thing for people to play with "
  },
  {
    "startTime": "01:06:36",
    "text": "and think about and and this I would expect initially maybe goes to ICC RG and maybe even stays in ICC RG but is this so quick opens up this this I tell people that wanna do pH easing congestion control that now\u0027s a really good time because you know you don\u0027t you\u0027re not limited by what TCP gave you that\u0027s like as 25 years of PhDs thrown at it but you have a an entire new set of much more rich information that you can play with and so I expect will get to get some pretty good proposals very soon and they need at home somewhere and and they will go beyond what TCP does and therefore need to be published somehow for us to then use them and I think I see Sergey might be that place for some of it yeah so it\u0027s it\u0027s mainly two things but one is hell let\u0027s get the quick version one recovery stuff ready so that the is she doesn\u0027t object to it and and to help us figure out how we can build better congestion control for quick in the future yeah thank you folks can\u0027t so much so much these long guns here for those of you who didn\u0027t get thrown out by me blue cheese blue sheets people who come sign the blue sheets you "
  }
]