[
  {
    "startTime": "00:00:05",
    "text": "be with myself okay thank you okay folks it's ten o'clock i see there are people standing up in the back if you all please sit down and we can get started okay thank you all if someone in the back could close the door that would cut down on the noise from the hallway please okay very good so i'm andy malice i'm chairing this session which is the joint pals mpls and detonate session and i'll be talking more about what we're doing here i'm being ably assisted today by tariq saad who's sitting up at the front table uh he he's able to take over if anything bad happens to my internet connection here at home um also i'm assisted by dave cinecrop dave's is taking the the minutes for today and in fact if if any of you would like to help take minutes that would be greatly appreciated all you have to do is go to the ietf agenda page and in the line for pals one of the icons in the right says notes for note taker if you just click on that that brings up the note taking tool and you'll notice that dave has already populated that with today's agenda and he's just adding notes after each item in the agenda as they as they come up in the meeting and you're all free to take notes there as well it's a cooperative effort and i think and i think everybody who helps on that"
  },
  {
    "startTime": "00:02:00",
    "text": "oh yes and of course this session is being recorded um as are all ietf sessions i'm sure you've all seen the note well already so i don't have to spend very much time on it it's the second day of the ietf and it hasn't changed since the previous ietf meetings either here are some meeting tips um just because this is a hybrid meeting so we have some notes here for the in-person participants for those of you who are sitting in the room uh please make sure that you sign into this session using meet echo light and if you take a look at the little diagram on the slide it shows you the icons that are to the right of the pals session what you want to do is you want to click on the meet echo light which is an icon that looks like a phone um and that will bring you up and you need to use that in order to be able to get into the queue you will not be recognized if you just stand at the microphone you actually have to get into the queue so i can see and manage the queue from here at home and i would also like to note that i have the ability to give you the if you're a speaker i have the ability to give you control of the slides and you can use that application to take control the slides to move them back and forth so if you're speaking and you would like control just ask and i'll be able to hand off control to you also i would like to point out that you that for those you who are in the in the room please keep your mask on in fact not just please it's required that you keep your masks on and it says on the slide unless actively speaking well i've been told that with the microphones that we have here at the hotel they actually pick you up very well even if you're masked as long as you speak right into the microphone so you'll so you'll probably find that you do not need to unmask when you speak at the mic as well for"
  },
  {
    "startTime": "00:04:01",
    "text": "those of you who are at home like i am please make sure your audio and video are off unless you are actively cheering as i am or you're doing a presentation um and please use a headset if you have it although um i did a mic check with christian earlier i was able to hear christian just fine so share good shape christian next so the purpose of this meeting this is a joint session for the pals mpls and networking groups it's focused on the work of the joint open design team uh for the mpls network action indicators and mpls and slurry data this is a work that's been going on for just about a year now i think and uh and it's been extremely active and uh while all of the active activity happens by email on the mpls email list we've been doing joint sessions for pals mpls and detonate while we're actively actually at the ietf meetings so the overview of today's agenda is we have one item actually for the pals working group because the you know pals this is the only meeting for pals and we have one item of work for pals which is private line emulation and signaling um then we're going to have tariq give us an open design team report to give us the status of where the work currently stands in the open design team then we're going to have a bunch of drafts for the op for the joint design team on mnia and mad requirements m a headers uh the post stack header extension and special purpose label for forwarding actions uh note that the open design teamwork is continuing it is not completed and open calls will continue post ihtf 114 all those calls are announced on the on the mpls email list so if you want to participate you really"
  },
  {
    "startTime": "00:06:01",
    "text": "need to be on the mpls email list so this is the more detailed agenda um actually um i'm not going to go into this in great detail because it's available online it's also available in the note taker tool so if you just open up to the note taker page you'll be able to see this as well so um so i'm not going to keep this open right here uh we do have some online resources that are helpful uh both today and ongoing yeah you here's the pointer to today's agenda the note-taking tool um known alternatively as ether pad code imd and hedge doc it's that url right there that's the same url you get if you go to it from the ietf agenda page we're on jabber as well the jabber is integrated with uh with meat echo so if you use the meat echo note window that's exactly the same as having your jabber application open and we should note that this is the last meeting in which we will be [Music] using jabber and we're transitioning to a new tool called zulip which will be taking jabber's place at ietf115 so you should download the zulip app for your phones and and get acquainted with zulip for for the next ietf meeting there is a wiki for the mpls open design team it's at that url right there and the wiki is where we announce all the agendas for the open design team calls all the ongoing work is documented there so if you want to participate you should be keeping track of the contents of of the wiki and finally while we're here in the room in the meeting if you have any issues with meat echo the meeting audio the thermostats in the room anything"
  },
  {
    "startTime": "00:08:01",
    "text": "like that send an email to support ietf.org they are keeping on top of that in real time and they will help you out and finally there's also a meat echo technician who is monitoring the session so if there are any meat echo issues that come up we can get right in touch with the medical guys as well and that's my final slide so i'm going to close this deck and move on to christian let me open that deck right there wait one second okay and christian would you like me to move the slides or would you like me to hand it off to you um you can if you can move the slides that would be great okay very good i'm just going to turn off my audio and video uh and i'll be handing that over to you okay thanks andy thanks everybody uh appreciate the time uh it's an honor to have the first slot in this session um i would like to introduce to the pals group the concept of private line emulation uh it has been you know i presented that already at itf 108 back then at the best working group uh and my purpose here would be to introduce you to the concept as well as give an update on the the the progress we made uh through the last couple you know actually one and a half years roughly you can can go to the next slide some of you may wonder why such a pals ish draft and a very tdm centric draft and uh you know there is something happening uh at the lower layer of the transport uh and what is actually happening is that packet switching through the innovation in silicon is becoming the most cost effective way to switch information at the electrical level what also is happening is that"
  },
  {
    "startTime": "00:10:00",
    "text": "dwm and coherent transmission technology is moving in in the form of pluggables into routers and that kind of begs the question does it make sense and this is really at the lower transport level it's not at the um you know i guess routing control plane and service level right it's more on the more boring side of the house of the network you know do we really need a tdm switching layer and predominantly that is today otn uh um or can they actually get rid of it and really let everything be packet switched or routed and when we do that of course that you know begs the question uh as a follow-up what do we do with our tdm switch services or also known as private lines let me go to the next slide um you know a lot of things can be done with pseudobuyers right and ethernet's utilizing evp and vpws is doing a great job right um the first draft part of the session is you know called uh you know ple or private languation and is about the data plane and it address it is addressing the the gap that we have that we cannot act at the bit level and be more transparent maybe because i want to be completely transparent for ethernet to also support synchro's ethernet for some special cases or maybe i want to carry fiber channel and non-ethernet technology and this draft is uh somewhat taking what has been done in the past with rfc four five five three and four structure agnostic transport over uh packet and is adopting or let's say widening the scope to higher speed interfaces like 10 gt 100 kg fiber channel of various rates or even otn or sonic sdh um again the underlay is mpls but also these days you know srv6 is a is a a suitable underlay the second draft i want to put your attention to is essentially adding the signaling pieces"
  },
  {
    "startTime": "00:12:02",
    "text": "uh into the mix and here because nowadays uh you know evpn and evpn vpws um is a more modern way of signaling pseudo-wires the idea is to have extensions to signal those tdm into or this interface specific attributes next slide now from a data plane perspective uh it's really you know uh a evolution of what has been on the setup right and uh what we are defining is two encapsulation of three encapsulation types which which are largely agnostic to any kind of you know information that's in the signal but due to the um let's say to a more optimized implementation for for carrying odu or carrying very high capacity 200 giga 400 gig interfaces uh we have defined some some alignment where in the otn case we do a od uk frame alignment and for the uh 200 gb and 400 gig we're aligning with the 10 28 bit blocks that have been defined for those ethernet technologies for the rest the proposal is really to keep things the way they are right we have an rtp header with sequencing and rtp timestamps we have a control with l and r bit um so pretty much you know kind of what we what we have done before but essentially broadening the scope of setup which really was focused around t1 e1s and the likes next slide on the control plane side um we are taking with the second draft let's say what has been done in the past and again expanding the the scope and adding a few bits and pieces in terms of tlvs to uh to signal the specifics of those new interface types that are now being"
  },
  {
    "startTime": "00:14:01",
    "text": "but to a large extent you know the i would say the approach is identical and what we are proposing is essentially to adopt bgp uh instead of ldp next slide um so so much for the introduction um as i said i'm uh i presented already iitf 108. uh since then we had uh quite a bit of progress even though i have to say that the technology may not be in fashion right um but we have um you know strong interest from operators like verizon deutsche telekom and also sienna and silence have joined us and through that and various feedback we got from the folks mentioned here we added quite a few of changes in the past and i'm not going through one by one but essentially some of the editorial changes as well as well as we got some agreement on what a default payload size could be and and things of that nature next slide um we also got some more recent feedback again thank you for everybody who's providing input and more recently we added the 10 28 bit block alignment for supporting uh very high capacity 200 gig and 400 kg this is probably a little bit more futuristic but as networks may maybe build based on 800 gig and maybe 1.6 terabit ethernet interfaces uh you know this is something that will be asked by the market as well and last but not least uh from the feedback the conclusion was that this really is something that should be addressed to pals i renamed the draft and presenting it also here now next slide so this is actually all i have um hopefully this gave you a good introduction we would appreciate more more feedback and input we have been um actively talking from cisco side to a lot of customers and we"
  },
  {
    "startTime": "00:16:00",
    "text": "have shown we have seen great interest so we really believe that this is something that is of interest not only uh you know is of interest for everybody uh and uh we would recommend or ask for uh input and feedback and potentially um adopt the draft and make this a workshop document so we can progress and make the the document complete um and finally an rfc last but not least i think recently there was a discussion about pseudo-wires and ldp and s-segment routing and uh i was wondering that potentially the signaling draft which hasn't you know had too much of progress yet could be a potential solution uh to to address some of the topics that have been discussed there and would like to to get your feedback on that one and with that thank you very much okay thank you very much christian um do we do we have any questions for christian before we move on to the joint meeting and i'm not seeing any questions so thank you very much christian and i'm going to move on to two week slides thank you andy and will you give me the control to flip yes thank you you should have control now i see it thanks perfect so my name is tariq saad and uh i was delegated to give a report on the mpls network's action network actions activities and a status update on the work that the design team has been engaged with as well as the working"
  },
  {
    "startTime": "00:18:01",
    "text": "group so let me proceed before i do that um i'm happy to take uh questions on this but if it is of nature the debatable nature or controversial uh there is a uh there's a slot that we left open towards the end of the session uh feel free to bring it up uh at that time but if it's a quick uh status update question i'm happy to take it a bit a bit of overview on the m a open design team that was initiated by the npls working group it's currently a joint activity between three working groups mpls pals and debt net the chairs from the three working groups coordinate agendas and decisions and they do meet periodically uh the open design team meeting happens every week on thursday 11 a.m eastern time uh as i mentioned the chairs are meeting also uh weekly um and it happens on tuesday we have good participation from the working groups and um usually we see around 15 to 20 participants every week there was a a review of uh documents that were active uh actively produced by the design team and members and the taxonomy of uh or the report was left on the wiki uh so people want to check that we're leaving a link to it um i'm i'm okay to take questions now or um yeah so i see someone raising their hands and let me ask andy do you want to take questions now or uh"
  },
  {
    "startTime": "00:20:00",
    "text": "i'm i'm okay by myself yeah if they're quick absolutely uh why don't you go ahead john don um could it be by mistake it could be juan dong are you there okay your hand came out okay so okay so you could drop the hand yeah okay i will i will proceed then um in terms of updates since last time we met so this is the third report indeed that we are producing to the the working group um and the updates this time include some working group documents that got adopted uh let me go through them and review the status of each uh so there was the use cases for mpls network action indicators and pls sincerity data this uh this document got adopted by the working group uh in may 2022 recently and the working group and the design team continues to refine existing use cases as well as identifying new use cases and adding them to the document we have the second document which tackles the requirements for mpls network actions and mpls ancillary data uh this document also got adopted in may 2022 and the working group and the design team are regularly uh refining this uh the requirements in the document and this usually happens either on the email list or during the weekly meeting"
  },
  {
    "startTime": "00:22:01",
    "text": "um yeah the numbering changed for some reason this should be number three uh oh one second maybe i yeah number three uh that's what i was expecting uh the third document that the the design team tackled was the framework for mpls network actions and this document got recently adopted um the name still hasn't changed but we're expecting it to change anytime but indeed the working group has decided to adopt this document during the adoption poll there were a multiple of points raised and that incited the chairs to initiate a poll we will talk a little bit about it on subsequent slides but we successfully concluded the poll and the document was adopted on july 13th as i mentioned the authors are expected to publish a new revision that includes the name change uh so the the second update i will go through is the the polls that i was talking about that uh the chairs decided to initiate uh to tackle some of the comments raised during the m a framework draft uh adoption poll um so we tried actually as a design team as well as the working group we tried to converge on some of the common streets how to tackle them during the weekly design team meeting but unfortunately that did not conclude so that the open design team chairs decided to craft two polls uh and and send it to the email list of the npls working group"
  },
  {
    "startTime": "00:24:00",
    "text": "in order to see you know a convergence and move forward so the polls were left open for almost three weeks uh to gather as many feedback as possible and uh subsequently the chairs decided uh or concluded and shared the results of the polls we will go through the results and of the consensus call on this slide and the subsequent slide the first poll that happened uh was to make sure that the framework is solution independent which makes sense but um [Music] so 80 is not so 80 means ancillary data here and not the area director so we want to make sure that the framework can convey the ancillary data inside the packet in in either multiple places as well as can be signaled in the control plane um an m a packet may carry the ancillary data in one or both places including inside the mpls stack or after the empire stack the conclusion on this poll was to support this position and we we had a recommendation for any solution draft such that if they choose the in-stack they choose the n-stack to carry ancillary data so isd stands for in-stack data if if the solution is choosing that it provides the motivation behind choosing this versus choosing post stack so the solution had to include additional motivation for selecting in-stack data the second poll uh was a call to converge on whether to"
  },
  {
    "startTime": "00:26:01",
    "text": "repurpose the existing any existing uh spl for m a um action data indicator for example an spl that was thoroughly researched was the entropy label indicator or whether we should allocate a new spl for this purpose um so the conclusion on this poll was um you know the responses showed that we have a strong consensus um that we want to allocate a new spl for m and no need to repurpose any existing spl for this purpose we also concluded that any other application other meaning none m a application that per that proposes to repurpose any existing spl will need to go through the normal working group process if they wish to do so so we do have a proposal and we we're going to go through that towards the end uh the last slide but this is the conclusion on this poll in terms of next steps uh the open design team that is tackling m a still is meeting uh weekly and uh they have uh um they have a lot still to do in terms of defining the solution we have tackled the base base or building blocks and produced multiple documents on that and the design team shares thought that it is time now to concentrate or redirect efforts towards the solution definition so i i mentioned there is a"
  },
  {
    "startTime": "00:28:01",
    "text": "review of documents that tackle or that the proposed different solutions and um you know um we went over that last time and we met in the design team and we we thought that there is resemblance in terms of some proposals and uh the chairs are encouraging um authors of such solutions that look alike to collaborate uh together and you know report back in the weekly design team on the progress of alignment we are expecting a report from the solutions authors to come back post ietf114 so that will be presented in a meeting that the design team meets on thursday so i did mention that there was a call uh or a poll to conclude on the reuse of a special purpose or repurposing of special purpose labels for different applications other than other than what it was meant to um so we did um we did agree as a working group as well as a design team that it will not be part of the m a work um we do have a draft that is proposing the use of entropy label indicator to indicate a slice id presence and any other and some other actions as well um there were other drafts that um that highlighted that such reuse is dangerous um we are i'm leaving both drafts here for um for people to check"
  },
  {
    "startTime": "00:30:00",
    "text": "um but uh the conclusion here is is that we will leave the working group process to drive the progress on such a proposal so if if we see that we will go through the regular rough consensus to see if such a proposal can progress or not so this was my last slide um on the activities as well as the status update of the design team i hope i kept um honesty here um but if anyone else from the design team wants to add or update any of what i mentioned feel free i don't see any hands being raised so thank you very much tariq and we're going to move on to matthew now um who's going to present the requirements draft thanks sandy um if you if you just wait one second let me get your slides up i'm happy for you to advance the slides okay very good that's the next question i was going to ask you very much so this is uh just a short overview of where we are with the requirements for the requirements draft for mpls network action indicators and ancillary data and since the last ietf john drake has has joined the the author list and and helped us a lot with this draft so thanks john and next slide so so this document captures or is intended to capture the key requirements for mpls network actions um that affect forwarding or other processing of the mpls packets including uh requirements on network action stub stack indicators so that's that's referred to as the the m a label"
  },
  {
    "startTime": "00:32:02",
    "text": "or the special purpose label that's used to indicate um a set of network actions um the mps network actions themselves um or indicators themselves and any ancillary data required to perform the indicated action and and this is a product of as you um of the mpls open design team and um the the requirements are largely driven from a number of proposals for additions to the mpls label stack to allow decisions about actions based on on application data and just to clarify these requirements are on protocol design so they're on on the design of the protocols that come out of this work not on implementations next slide so in in may i think we went through an adoption process um there was an individual draft um which had reached version four um and we had around 30 comments which were made on which were made on the list and were collate collated by lower and uh the process we took was to essentially adopt the the document wholesale but add the in that first new version add those comments to an appendix a which is the working group adoption comments because there are quite a lot of comments um so you'll see in the draft there's there's still an appendix containing um the the comments and uh some responses to the comments and we we uh published the draft as the working group drafters um mpls miad m a requirement zero and then subsequently corrected the name to the m a requirements um that addresses we hope um the comments in in the uh in the working group adoption and on the subsequent meeting"
  },
  {
    "startTime": "00:34:02",
    "text": "discussion um and and in the subsequent revisions so we intend to remove appendix eight shortly next slide so the main changes um we align the terminology with um the framework draft um so essentially what we what we've done between these two documents is that we have a core set of terminology defined in the in the requirements draft um and then the framework is is kind of a superset of that with any new terminology that's required outside of the requirements to describe things in the framework we've refocused the draft around network actions instead of indicators for ancillary data so we removed ancillary data indicator and replaced it with network action indicator we added a clarification of in stack versus post stack requirements that was as a result of the consensus call that eric discussed earlier so we say we have a requirement that addresses the fact that in-stack ancillary data requires strong justification um we made the distinction between a network action stub stack indicator which is the the m a label in the framework and a network action indicator itself um and this kind of distinction allows the network action indicator and or the ancillary data to be in stack or post stack um we also also clarified that a solution solution specs must support or may support user defined actions so it may support user defined actions and if they do they must explicitly reserve a user-defined range in their iana policy for any registry that they defined and we also reorganize the requirements into appropriate sections around the"
  },
  {
    "startTime": "00:36:01",
    "text": "network action sub stack indicator the network action indicators and the ancillary data and also a set of generic requirements uh next slide so the the structure that's changed since the last ietf is is the terminology um which contains new terms needed to define new objects in mpls a set of generic or general requirements which is a set of design principles that underline this work um requirements on the network action indicator sub stack um requirements on the net action indicators requirements on ancillary data and the appendix containing the working group adoption comments which we intend to remove shortly next slide so the next steps so we've we've gone through many revisions several revisions of this draft we've reviewed them line by line in the mpls open design team we're now on version two of the working group document um the append as i mentioned the appendix will be removed in the next revision um we really appreciate further review and comments posted to the mpls list or brought up in the mpls open design team meetings um but the authors believe the draft is getting pretty mature now and we hope that from a quality perspective it's close to what you would expect from a working group last school document uh thank you okay thank you very much thank you matthew are there any questions for clarification for matthew and and i do want to remind people that we have about 40 minutes reserved for open discussion following all the presentations so if we want to have any extended discussion we can have it then and i see that lowe has his hand up so lower go ahead a question for matthew what i didn't really follow what you"
  },
  {
    "startTime": "00:38:00",
    "text": "said about uh ayan already stressed for user-defined actions uh i think user-defined actions smile allocate whatever they want in diana and that's of the problem the problem is that the probably in the standards part of the registry need some code points to be used for the user defined actions isn't that correct yeah that's that's what that's what i said um i didn't i don't mean that we i don't mean that we you allocate an individual code point for an individual uh user-defined action i mean you you reserve a range for user-defined actions okay thanks and tony is next tony go ahead matthew when can we expect the next update um well actually i just posted one on monday which is version two which is the one um i i referred to here i apologize it just missed the the cutoff um so i i posted it as soon as as it opened again on on over the weekend um okay well thank you very much matthew and we're going we're going on next to jags who's going to be talking about the m a header if you give me one second i will put his slides up okay jegs yes and would you like me to control the slides or would you rather do it yourself uh could you please control my slides that'd be awesome okay i'll do it thank you yeah so hi my name is ball x so i'm going to present uh the presenter draft"
  },
  {
    "startTime": "00:40:00",
    "text": "jags mpls mna header on behalf of our authors uh mr jags if i can interrupt you just for one second you have a lot of background noise where you are i don't know if there's anything that they can do about that uh just a minute is okay now much much better thank you much better yeah uh coming to the next slide please okay so these are the observations i'm using in the slides as well as in the rafter so i just want to put it here so that you can have a quick reference next slides please yeah so as part of this presentation uh this is my agenda which i'm going to discuss today uh the first will be the scope of our draft and then we're going to discuss on the high level solution what we took uh to achieve the uh and then next one is the network action indicator and then like uh i'm going to discuss on the in stack network action encoding format different formats um and the corresponding examples and the next one is the uh backward compatibility uh how we're gonna achieve with our solution and the advantages of our solution and finally uh the next steps uh what what we want to do uh with our draft uh next slide please uh as a part of the scope right so like um we are providing a solution for uh in stack and postdoc mna encoding format based on the uh m a requirements uh according to the draft mentioned here aligning with our mna framework uh which is mentioned here uh next slide please okay it's part of the high level solution this is a high level solution which we took to uh come up with a solution for m a uh header encoding uh"
  },
  {
    "startTime": "00:42:00",
    "text": "to extend uh to action the existing mpls header for uh mna so we need the two main things the first one is the mpls network uh action indicators so the top level uh we want to have a label to indicate the presence of uh network uh action sub stack and the next one is the a little bit more granular so we provide the slab flags to indicate the presence of in stack and post network actions the secondly like apart from the network action indicator we need we need to encode the network action um encoding so we can we should come up with a format so there's a format actually like which describes how the uh in stack and post network actions are going to be uh encoded uh next slide please okay so let's go deep dive into the uh network action presence indicator as i told you like at the top level uh we have this network action sub stack indicator see a new bspl uh will be allocated by iron for this purpose as um so this bspls tc and ttl material field will not be repurposed and then uh and then used for any encoding uh to maintain the uh backward compatibility um so uh apart from this uh we we're going to encode some flags in the next lse uh uh lse so which which is going to have granular indicators like in stack network action presence indicator so this indicates the presence of the instax network action that are encoded in the packet as shown as shown in the figure one um the instruct network actions uh can be uh two types like one is the flag based uh that doesn't require any ancillary data and another uh another one is uh the network action that requires an ancillary data so we call it as an uh opcode based uh that requires a necessary data so the next the second uh indicator the main indicator is the post"
  },
  {
    "startTime": "00:44:00",
    "text": "stack indicator uh so this indicates the presence of the uh post uh network actions that are encoded in the packet so um so by using this indicator so we can identify we can we can encode both the stack and post stack data simultaneously using the same nasi uh header uh next slide please so uh as i told you before like um uh the first one is the flag based uh in stack uh mpls network action encoding so this is this this is the india network action which doesn't need any angular data to process the specific network actions so uh here actually like um uh there are two parts one is the uh in stack network action header so these are the flags and some couple of values which uh which would which would help us to encode the uh the these stack uh network uh actions so the ini is the field you know like uh which is a detailed field which indicates the presence of the in stack uh mpls network action and then the il is the instructor data length it's a three bit uh value in the ttl field uh this uh this this indicates the total length of the in stack header encoded by the specific nasi indicator so the length is represented in the in terms of units in the unit of word this does not include the the header or the header word and the last uh last one i want to tell you that is uh ine it's an in stack uh na extension uh indicator so in in uh currently uh we can encode you know like maximum of uh um eight additional seven additional uh words apart from the base uh header so if you want to extend more than seven in the future then this flag would be used to extend uh the sub stack as well um so the second part of the second part is the flag based uh in stack uh network"
  },
  {
    "startTime": "00:46:01",
    "text": "action encoding format so here actually like um we have a flag based nai so this is actually uh the 19-bit field in the uh label field and the msp will must be always set to one to uh prevent aliasing from the uh spls um and the and this uh each each and every bit field will be uh assigned by ayana for a specific application so if application a wants an um uh uh flag based indicator so then they could they could request for ion number and then big position and then they could use that so that that's gonna dictate uh what the network action for that has to be done and there is an e bit uh which which is going to indicate that any any one of the flag based uh indicator is uh uh hub by hop um or at the um or it is end to end so if you say like any one of the uh flat flag is the uh by hop then hop i hope uh uh that this e field will be zero else actually the uh e field will be one uh so there's another field is like uh and the tc field will be repurposed to use uh to add additional data length uh this is actually two bit field uh in the ttl to indicate the length of the additional word that that are encoded to carry the additional flag based uh network indicator for example currently like we can encode a 19 19 offset fields here so if you say like uh the 20th application is coming and requesting for additional for a foreign flag based indicator then the then the adl will be set to uh one so that we can add another lse to encode the uh the flat best indicator next slide please so this is the second part of the uh in stack uh network action the encoding so this is actually opcode based so this is the kind of uh network action that needs an accelerated data to uh process the"
  },
  {
    "startTime": "00:48:00",
    "text": "network actions um so here um the the third word is going to describe like what is the uh op code and accelerate data and some of the informations i'm going to describe now so um in this uh in this in this upward approach like uh upcode approach is basically a kind of a tlv format which is successfully used in many protocols today and many asics are supporting today so here the uh the is in nai up code is the eight bit field uh this indicates the instax uh network app uh action uh opcode that that should be assigned by uh the info for a specific application the characteristics of the upgrade must be defined while the solution is uh developed and requested for the value from the inr the ancillary field are you know like the uh is 20 bits in total uh 12 bits from the uh from the label field and the eight bits from the ttl field will be used for uh to encode the uh data corresponding to the sub code and the adl uh is the additional data length and some of the applications uh might need to encode more than 40 bits of data in the answer the ancillary field so those applications can use this field to extend their uh encoding of ancillary data and uh the last one is the ebit so this is actually a end-to-end processing bit the same as the above um so if if it is uh if this specific op code has to be processed or by hop then this field should be set to zero else this will be set to one can at least move the next slide please okay so now let's see uh some of the examples so so that you know you'll have some idea like how this encoding is going to work so this for the example one is uh the pure flag flag based uh mpls network uh action uh where the uh where actually i'm encoding and um bit flag bit flag position of one the"
  },
  {
    "startTime": "00:50:00",
    "text": "application uh big question one uh is is going to send uh it's an uh it it wants it uh network actions to be uh processed in um on the different nodes uh so here so here actually the adl field will be zero because um uh we are not adding any additional uh word apart from the uh general general control encoding flags um and the end in the end as i told you before the ebit is going to be set based on the uh um whether the processing is going to be uh for this oneness end to end or it's uh hop by hop uh next slide please so this is the case you know like um i um my uh i have uh i have two applications uh needs to encode their flag based nis uh the um um the first application is uh having the bit push and one and second application is having the bit portion 20 right so the uh the the application 20 cannot uh encode their uh big position in the uh in the first flag based ni so they need to uh use the second second word to encode the um encode the uh uh bit 20. um so uh since actually we're adding one more uh word to that uh the adl field is going to be set to one so this this will help us the uh help the the hardware to identify that the flag based fields are know like uh is going to have additional word and then uh it can process easily so it'll be like a more hardware friendly uh next slide please okay so there's a third example where actually like um uh we are going to encode the plain op code based uh we don't have any flag based here so here uh in the example like we are encoding the opcode value 10 that is the application which has been assigned up code value 10 is going to carry its corresponding axillary data with it so that all the"
  },
  {
    "startTime": "00:52:01",
    "text": "all the nodes can process their network actions correspondingly um here actually like since the application 10 application of code 10 doesn't need a angular data more than 20 bits the adl field is set to zero so that indicates that uh uh you know like uh the up code type 10 has the angular answer data which is within the 20 bits offset um next slide please the fourth example is the case where uh um the the up the uh um network action is needs and uh data but uh which it needs more than 20 bits of data needs to be encoded so in this case actually like since it needs some more than 20 bit of data so we need to spill into the next word so so the adl the additional data length value will be set to one so this will indicate the hardware that uh the uh the upgrade upgrade 12 uh corresponding informations are relying in the next word as well so it can take those buffers and then process it correspondingly so this this gives a more flexibility and asic to uh process it um in an easy manner uh and also like uh um for um in in some cases right uh um the midnotes may not implement a specific uh op code so uh if if they if they if they don't uh implement those specific op quotes then actually they can uh skip those uh of course and then go to the next uh next top code right so for that uh this field could be uh very well used by the sxm so for example like if uh 12 is not uh supported by a mid note so he knows that uh um with the adl field uh one so it knows that uh the the two word has not been used and then you can skip to the third one and then start processing the next next stop code available in the uh stack so that that's what actually could be"
  },
  {
    "startTime": "00:54:01",
    "text": "very very very helpful in skipping the the unknown up codes and processing the data um similarly like uh e e will be set based on the uh you know like um end to end processing or hop i hop uh processing uh next slide please okay so here actually this is the example where uh the packet is carrying both the flag based and upgrade based um the flag base here is carrying the uh the offset one uh for the flag based and um up code 10 with angular data which is less than uh or equal to 20 20 bits has been carried here and that's what you can see here so the essence actually does not crossing their limit uh the adl is zero for the both the cases next slide please so this is actually like some um it's a multiple uh op code based and uh flag based uh informations are carried in this uh packet so here uh if you see the uh blackberry flag based nai we have uh offset one and four has been carried um as well as uh if you see the uh opcode um if you see the upcoder based uh uh nis we have we are carrying upgrade 10 and 20. uh and then like um when we see the length i l field right since actually like uh apart from the general header encoding so we are adding a two more word that's the reason i i l equal to two uh is set there so that will tell the uh asic that you know like it is it is encoding uh this my number of bytes uh next slide please okay so the this is the backward compatibility you know like uh um how the solution adopted and then what we thought about it um so when we uh uh when we introduce this mna and then if the when the header no at the head node uh needs to encode this mna into the mpls stack then it should uh it should it should depend on the mma capability so the control plane"
  },
  {
    "startTime": "00:56:01",
    "text": "needs to uh inform about the semantic capability of the end node that needs to be that needs to process the uh m m so in worst case you know like if you say like uh there's some change in the topology and that's it in that case right so uh even though the the end node is not uh aware of this mna capability since we are using the spl uh uh uh this packet uh since our spl is not is not able to process by the specific node the specific packet will be dropped in this case uh these the second comparability is like ecmp uh icmp behavior um for here actually like the the labels in the label stack does not change uh for uh for a flow so um so like you know like uh the ecmp is going to remain same for that specific flow so we are not disturbing the uh acmp flow as such um uh third one is like you know like uh so in our design we make sure that uh um any of the mid notes or legacy notes you know like it doesn't uh interpret our data for an um base spl uh spls which we already defined um the fourth one is the uh the the uh the ultimate node uh uh with the detailed propagation um behavior does not corrupt the m a stack uh that's the reason no like we skipped encoding the information in the top level um uh in the in the in the um in the bspls ttc tdl field and then we used the next next uh word to encode the uh um those um common flags encoding flags uh for the mna uh the last one is um since actually like we have opcode-based offsets to place our postac data wherever we like so this can coexist"
  },
  {
    "startTime": "00:58:00",
    "text": "with any existing uh dash or any other architectures we have um next jags we're well past time so can you skip to the conclusion yeah i'll just quickly show the next line and that is my last play okay very good yeah and it also uh one second i i see that greg and tariq have their hands up um because we're past time on this talk i'd like to reserve your comments for the general discussion time if that's fine so just keep them in mind and and uh come back then thank you okay jags yeah sure uh so yeah so this is the main advantage i just i want to highlight you know like uh our uh our architecture is more flexible since it's upcode based it can be placed anywhere in the stack and the next one is the mnen coding is extensible since it's opcode like you know we have a flash to extend the up codes even in the future um the the fourth point is very very important for our our case because uh this is actually uh hardware password friendly the length field of m a substract allows to uh easily uh skip the sub stack as i described before um and network action opcode uh the answer data and the scope and length right so the ttl tlb kind of format has been encoded here so this is this is easy for the hardware to process the data and then they can use the existing uh parser to parts of data um and the next one is that the msd efficiency so since actually we encode all these flags so the msd is sufficiently used the backward compatibility with the existing network we make sure that uh it's not disturbed and the last one is uh it's uh ecp friendly so even actually like if any anybody wants to encode the data which needs to be changed even even for the same flow that could happen uh"
  },
  {
    "startTime": "01:00:00",
    "text": "by changing by changing the information in the uh dtl field um yeah next please that's my last play yeah thanks uh thank you very much and welcome my review comments and feedbacks there are strong interests for from multiple vendors and operators on the solution and we request uh mpls working report option thank you okay so thank you very much jax and i'm going to move on to um how you wait one second let me get how you slides okay how are you clear yep we can hear you great um would would you would you like me to move the slides or would you rather do it yourself uh yeah maybe you can okay okay i'll take care of it thanks yeah it's extraordinary i'm i'm the first on-site presenter um good to see everybody again uh today i'm going to give you a quick review about update of our npr's extension header draft next slide please yeah we published the initial version in 2018 and since then it has been evolved to version zero seven today is uh uh based on the numerous discussions in the open design team and now the title is a change to ips post stack extension header to reflect or focus on in this draft is only on how we encode the uh mps network actions after the label stack and also we in this new version we align the terms with what's defined specified in the mlna requirements and framework documents and"
  },
  {
    "startTime": "01:02:00",
    "text": "we also add several new authors next slides yeah first a quick recap about what mpls extension header is about uh obviously we will need some indicators in the label stack to tell us we have extension headers after the label stack but how it's defined is out of scope of this document in this document we only specify how the extension header itself is encoded after the label stack as you can see in this figure up to the label stack we will first have a header of extension header which is basically a summary of what's what follows it tells you how many header extension headers you will have what's the total length of that and it also provides the information about the original high upper layer protocol type so this is will be useful to tell you uh with the original protocol layer 4 protocols in the packet and also it's tell you what's the next headers type and after uh this uh summary you will see a set of standard containers uh each of them is a extension header which will contain a specific network action and each container has a standard starting with a standard words tell you the next headers type and the current headers lens this is a very similar to ipv6 extension header if you are familiar familiar with that uh so with this arrangement we will support up to 15 extension headers in a single package and then if we based on the length arrangement we can support uh the maximum length of all the extent headers can be up to 1k bytes in"
  },
  {
    "startTime": "01:04:00",
    "text": "the single packet and we do allow uh you only have this header of exchange header but followed by zero extent headers so this uh can be used to indicate the type of upper layer protocol and also it supports the potential use of add and remove exchange headers on the path next slides please so we define several new next header types in this document first we want to share the code point with ip protocol numbers which means we will apply i need to apply new protocol numbers from the same same registry and the new type defined in this document is of the first one is a num which means no uh next extent header and the payload uh after this extent header this is the last one so this can be used for special packages such as the probing package the second type is unknown which means this this can only be used in elasticstation header which basically tell you okay what's a payload type is we don't know this is a compatible with the current practice in ips and the next type is a mpls means another nps label stack follows its current extension header this is a very useful for the hierarchical use cases in which you have a multi level of manufacturable stack and all the extension headers can be skipped in one step because we know the overall size of these headers so it allows us to quickly access the original up layer protocol and also we"
  },
  {
    "startTime": "01:06:01",
    "text": "explicitly support two type of extension headers end-to-end tab and help help type and we require the end-to-end type exchange headers must be located before the uh oh a bit below the hop by hop because hope high hop would not need to be processed every hop so uh you you have to put a hph type first and followed by uh and then after that you will have the end to end type so this can help us to optimize the performance and you can see each extension header is just a stand standard container and it allows to freely define newer applications in the future to put it in the extension header next slides please and we have several other companion documents uh with this one the first one is uh actually a summary of a possible method for the exchange header indicator but we we don't want progress this document further we will retire it once a standard method is chosen by the working group but you can take a look at that and it basically covers every possibilities we have discussed up to now and the second document is called npr's extension header architecture this is not a network action architecture is actually about the network the the network architecture to operate this uh mps extension header for example it describes several terms like the extension header pass"
  },
  {
    "startTime": "01:08:02",
    "text": "was this relationship with a little switching pass and we will have extension header capable and incapable nodes and how we will announce such capabilities in the network such concept is actually is common also to the in in stack network action and therefore it's possible to involve this document for the a network architecture because uh we think the concepts are covered in this document so very useful there the last complaining document is about mps extension header label stack operations uh it's a kind of uh optimized performance optimization document basically uh since the label sensor action itself can be deeply embedded in the package then if we uh we can based on the top label we can uh tell there is some actions in the package that will be useful help the node to to decide if we want to examine the label stack folder or not so the idea of that you can use some extension header uh uh forward eq equipment class label uh effect label uh to indicate that uh if one node actually uh figure out there are some there is such action labels on or not in the package so similarly this concept is also applicable to the instax network action so it's possible to involve it to be a generic method for nps networking as well next slides so this document is already pretty"
  },
  {
    "startTime": "01:10:02",
    "text": "mature after uh many repeat different regions so therefore we also request the working group to adopt this as a solution for supporting postdeck network actions in mpis and uh um well also uh we we will uh next step uh the key work is to determine actually what's the extension header indicator uh scheme we will we need to make that coherent with uh also the indicator for in in stack network actions and also as the next network we will expand the scope of other exchange header companion document to make it uh suitable for the uh mna work thank you okay thank you very much greg mursky has his hand up uh so greg what's your question um gregorsky erickson so um a little bit confused with the order of your next next steps because it appears that you are proposing adopting this document as a partial solution to mma requirements yes but it seems that as is this document does not address all m a requirement documents which adopted by the working group yeah this is a this document is about the post that encoding and i think this is an independent part uh which can be developed in parallel with a insect um with the indicator and also the instead action um i i think it will be"
  },
  {
    "startTime": "01:12:01",
    "text": "more helpful to discuss the solution that addresses all requirements that adopted by the working group not a partial solution thank you okay thank you very much how you and we're going to now move on to karidi and karidi is going to be our last set of formal slides and following kiriti we will have time for open discussion uh let me just load coity slides here okay and greedy would you like me to move the slides for you yes please okay very good and if he'd stand closer to the mic doing my checkbook yes okay thank you okay yeah thanks um so if you just stop on this slide i'm presenting i did make a big mistake of not adding tony tony's name to the author list he did help a lot so mia copper next slide please so as i mentioned tony did help uh you know restructure this and took part in a lot of discussions both internally as well as in the open design team and he is fairly active there his co-author on several drafts there next so as i said we've had many discussions on this draft within juniper between us and folks in broadcom [Music] we made a few pretty big changes in this last revision that we think will"
  },
  {
    "startTime": "01:14:01",
    "text": "really help make this easier to implement on both our own chips as well as on broadcast so the big big change is um to replace a continuation bit with length fields and i'll get into that in a second um but the the upshot of this is we're fairly confident that this can be implemented efficiently and in fact that's where we'll go next next slide so the big change that we have we would have we just have these things called continuation fields or continuation bits and essentially a continuation bit will tell you when a particular block ends so the whole fai block at some point has to end so if the fai and i'm going to call it fai for now but we should probably change the terminology so if the special purpose labels saying that there's forwarding actions here comes to the top of the stack you want to remove the whole block so to know where the block goes we'll use in continuation bits but feedback from the broadcom folks says that it's much easier to have a length field up free up front and then you say oh this whole block is 10 words just take the 10 words and throw them out so we moved from having continuation bits for uh the whole fai block for the standard in-stack data and for the user in stack data user-defined exact data so we moved everything to length fields there's not a huge difference in terms of overall number of bits needed to encode all this but the length fields allow for much easier processing so that's one big change that we made next slide um also from the point of view of the draft itself there have been a lot of"
  },
  {
    "startTime": "01:16:01",
    "text": "improvements in readability and so for example separating the description of the label stack entry which has all the flags but the flag definitions are in a different section so it reads better um so so those are the two big changes between the previous version and this version um at this point we're just you know twitting bits so we think that we're really close in terms of a technical solution next slide so um we think that the draft is ready for working group adoption we've been discussing this for over a year at this point um internally we've done a lot of fine tuning and so um so we think it's ready in addition we would like to start doing some prototypes of this um both on our chips and also you know hopefully the broadcom folks will do some on their chips and each of us has multiple types of chips so we can get a sense of how it is how easy or how hard it is to implement this on a variety of chip types to do that it would be nice to have an early allocation of a bspl for fai um so i don't know how these um i don't know how to draw a dependency diagram between the three requests here but we'll let the working group cheers work that out questions do i hear someone say ship it no questions all right thank you great thank you very much i guess or two um go for it"
  },
  {
    "startTime": "01:18:09",
    "text": "okay sure probably not changing anything technologically it's just a an update so you get to the point where it's easy to read the document side by side okay i agree and then when i look at this document i find it fairly complete on uh isd but it's much weaker on psd are you do you agree on that or is it intended so could you repeat that it's fairly complete on isd the the isd yeah yes yeah yeah you get the pretty good treatment of isd you don't agree on everything but i understand what you're saying but i think they're missing parts on the psd side agreed um so that was actually the intention this draft primarily focus on the isd part and it points to uh jeffrey's document uh and i think jeffrey and how you have combined so it's sort of like you have an ic document this is the ifc document and then you have another document that's the pse document and that's the one that how you and jeffrey are writing so yeah that is the intention i think that's fine but i also think you need to say it okay pointless pointless point is pointless probably all of those documents need to point to each other okay um no that makes sense you'll do that okay thanks so align the terminology put"
  },
  {
    "startTime": "01:20:01",
    "text": "pointers for psd okay is next in the queue tweet go ahead thank you kiriti uh um i i'm a co-author but i can't help that there are some resemblance in terms of handling in-stack actions uh in this solution as well as in the solution that jax presented earlier um so my question now as a open design team co-chair um there is a and we're trying to incite uh you know alignment between the different solutions so are there plans to uh you know see if you can converse with the other solution i have to discuss with my co-authors but i think the while the intent of the draft is similar in that they want to encode multiple actions and include data with the actions the formats are very different so at this point what i would like to do is to implement what we have here and get some feedback from what does it actually take to implement this on different kinds of hardware and um yeah and then if my courses say [Music] you know there is some some scope for alignment i'm happy to think about it but right now that's not where my focus is but it's a good question okay and lower has his hand back up uh so great when you said uh implement are you meaning some type of alpha implementation for for tests or something or are you actually going for a full product code"
  },
  {
    "startTime": "01:22:00",
    "text": "um more like alpha more you know internal implementation you know yeah so that i'm not i'm not saying we should do it but actually if we decide to do it to one of the solutions you probably should sponsor it for all of them and then make comparisons um yeah i don't have cycles for all that i hope i have cycles to do this one i know but maybe talk to grammy yeah so if others i won't want to implement theirs and then we can have some standards or not standards but some metrics by which we compare solutions that would be i think very helpful but from from our point of view we just want to see did we specify this well you know for example continuation bits versus sizes which works out better how does the hardware respond to all this how many cycles does it take so we have our hands for just doing hours because we're going to try to do it on four different types of tips questions okay how are you okay how you go ahead yeah this is not question uh but just a comment i i think it's a very good idea to actually uh compare uh the different solution proposals from the different perspective like the overheads the performance but in this sense in this design i think performance is a very critical so we have to do it carefully and on one side we can ask more asic experts to join the work to evaluate scheme and meanwhile we can also do the some kind of software based evaluation as it also can be do very quick and uh"
  },
  {
    "startTime": "01:24:01",
    "text": "give us a sense of what's uh of performance uh actually uh what's the most uh uh uh influence uh part of the to the performance yeah so um you have a good point but we're going to take it in steps so the first thing is is the proposal that we have implementable reasonably the second step is oh here's our proposal here's the metrics from our proposal if someone else were to do a different proposal then we can we agree on the metrics then we can compare them but we want to start with something right so we'll start with this proposal but but you're right eventually we can get there and say here's some common metrics and let's compare different implementations yeah so so basically there are several different type of ideas one is using the catalog uh followed by the action itself and just to use a conventional uh chain uh leg uh structure right and it's some other even combined the two together so i i think there's a great imp implication on the uh on the performance issue so it's a very uh critical to access it but travel walk around right so we want to crawl and then we'll walk and then we can maybe run right yeah thank you okay and whim is next in the queue it's not necessarily a question to kiriti but it's more of a working group question is like i think for a psd we somehow are converging uh somehow as in a single document with what why buu is presenting right at the feeling for isd we have to probably competing uh solutions i have the feeling that you want to continue with your thing from i what i was trying"
  },
  {
    "startTime": "01:26:01",
    "text": "to get to as more as a working group question is i'm hoping to converge to one solution because this is data plane and i think we should try to converts to to one thing so my question is more i first of all is that uh aligned within the working group as an objective because if you focus on your thing and someone else focus on his thing then we have like uh how do we converge on on getting towards a single most optimal solution to implement which works on i would say most hardware yeah so from my point of view i just want to know if this particular approach works is sufficient and so on and so you know independent of itf we want to do the implementation and take back learnings and then bring it back to the drop and so on um the convergence point is really important and that's a working group thing and so it would help if for example the alternative solution did a similar thing and then we could compare them you know across some metrics i don't know what the metrics would be like uh you know number of cycles it takes or something but if you want to do something that's independent of hardware but meaningful from the point of view of forwarding and then we can make i think more rational decisions about should we go forward with this or with that or are there ways to convert them because ultimately for a data plane solution we don't want to yeah the question is mainly how do we do that somehow yeah all right that's why um the working group gets a big props okay lower is next in the queue lower yeah yeah i kind of i can't answer what the working groups take on this is just now we need to discuss it a bit"
  },
  {
    "startTime": "01:28:02",
    "text": "but i'm pretty much on the same page as uh as we miss we should take decisions that relates to the standard based on how we best actually re reach to a implementable and compatible solution so i don't i don't think there is any kind of differences about that i can understand that some companies want to go ahead and pro try to test their own solution in their own environment but eventually they have to come come out and actually participate in the what the iitf or the mpls working group are doing yes of course and you know like i said we had a lot of internal discussions and some of the decisions that we made we want to validate that did we take the right uh answer to it and so i mean this will be valuable feedback to the working group as well as for ourselves and our implementation so it's it's also been a while since we started this work so you know we want to just move forward but we will bring back things to the working group uh implementation reports um again if you can agree on some metrics we can say where we score on those and that would be sort of the idea okay and turk europe on the same topic and again as a coach here um i i totally understand where you're coming from kriti and and there might be valid reasons for diverging the only thing i'm going to highlight is we owe the"
  },
  {
    "startTime": "01:30:00",
    "text": "design team as well as the working group a report of the reasons why we cannot converge and and i understand your uh your stand yeah so i don't even want to jump to that i want to start with a report of how this particular implementation worked out and what we learned from it and then we can talk about where converge i mean they can happen in parallel but i think doing the implementation would shed a lot of light but i think in parallel we should discuss are they pointed with which we can converge are the points that are pretty incompatible um what would the shape of the final solution look like again i'd have to discuss with my co-authors but you know i'm open to those okay and uh you have to get into the queue if you want to speak yeah i am having trouble uh dialing into the medical that's right okay okay go ahead if if you allow me yeah please thank you identify yourself in that case what what has been done in passing suspicion yeah is zafar ali um what has been done in past in cases like this like we mentioned this is data plane um so we have to be extremely careful in in moving forward with solution is to define metric that can compare solutions that can give feedback to the working group in terms of what is what solution works better what works whatever involved and that has been approached i've been taking many times by many working groups in making decisions like this so you probably missed it when i said we wanted to find metrics but yeah yeah so i think i mean we do want to find matrix to compare the solution and move forward thank you"
  },
  {
    "startTime": "01:32:01",
    "text": "greedy thank you sweetie before you sit down i want to point out that you you still have three slides in your deck okay um oh this is the nfr yes exactly okay sorry next slide please um this is going to be quick um the nffr nffrr draft was a standalone graph saying i want a new um code point a new special purpose label and we've changed it and said we just want a bit or whatever it turns out to be an action uh in the m a uh document uh so we've gone from asking for a uh based special purpose label to an action bit so that we can actually tell a router please don't do for the past few hours and the second part so if you go to the next slide um so in the beginning we had a lot of discussion we've incorporated all the feedback uh we bought we got brought down with this whole uh you know based special purpose labels and whether we have our own standalone or whether we incorporated something else so this is no longer an issue next slide so as we do so the problem is acknowledge people basically say we need to move forward with this or or this is a useful thing to move forward with no other alternatives have been proposed there were some feedback we incorporated that so we think this is ready for working group adoption and uh we will consider this as part of the prototype for the previous document so when we prototype the fai uh document one of the things there is a no for the"
  },
  {
    "startTime": "01:34:00",
    "text": "fast field output and we will implement that okay there's a question from kitan yeah hi ketan talaliker uh about this problem acknowledge and solution acceptable i think uh there are control plane uh based uh solutions at least for some of the use cases uh which i have started a mail thread and maybe we can discuss further so i i believe uh we should discuss that and probably also consult best uh you know where the evpn work is happening uh there's a control plane solution there and maybe same for uh perhaps spring at least those are the two that i'm aware of and yeah maybe we can follow continue on the thread we can definitely follow on the mailing list when who the co-author also has a comment i mean the the goal here was a data plane solution but when if you have a common piece um so um when is going to respond as a co-author but yeah how you can come i yeah hi this is one from juniper i aware recently um last two years ago there was another proposal for address this uh solution we when this draft was uh first published we mentioned uh in the in the talk why this solution we feel is better because it's more scalable from evpn perspective there is a different type of service and this solution will apply to different type of service then aware bundle service especially in particular if you have a 4kb then so"
  },
  {
    "startTime": "01:36:00",
    "text": "this solution just one label will address all those issues for the looping in the fr case in addition the same solution also applied for layer 3 vpn or other use cases we feel just so one solution not only applied to different type of evpn service and also to different other type of service so that's the really the benefit for this solution it's simple and that's yeah yeah thank you what she said yeah i i understood what uh what was said and uh i think uh it's best we discuss this and i would suggest maybe including the best working group perhaps uh because uh it's yeah i i i'm not saying that the best uh the individual draft is let's say all complete and all good and ready perhaps you know it can be improved so yeah we can continue the discussion okay thank you okay yeah okay i think this is a uh interesting use case because it has some unique uh features we need to consider in our mna discussion uh because in my understanding this action is actually applied on the inserted on the uh following mps label switching paths it's not starting from the edge so if you allow such kind of actions it implies in our requirement we do allow to insert or remove some certain actions on the following paths so my personal opinion is we should allow such kind of behavior this will make our this uh mma more flexible but i don't think it's a currently reflecting the requirement or architecture documents so we should"
  },
  {
    "startTime": "01:38:02",
    "text": "discuss that further okay okay any other discussion of kuwaiti's dress yes greg go ahead hi rick ruxin i i just wanted to remind that uh no forr is a part of the use cases document adopted by the working group thank you thank you okay uh how you i saw your name flash for a moment and then then um go down so i think you're probably okay okay very good so i think you're all set karini thank you very much thank you now from from this point on um let me close kuwaiti's slide and turn my own camera on okay great so from this point on we have open discussion time so if there's anything that anyone would like to bring up um regarding anything that's been discussed or anything else that's going on with the open design team now is your chance either remotely or in the room i would like to remind you if you're in the room don't just walk up to the mic please use the um the tool to get into the queue so we can manage it correctly tariq you're next uh tarik saad and my question was to dragon i i don't know if the plan was to bring back slides but i don't need that they presented ini and ine to indicate actions in the stack and"
  },
  {
    "startTime": "01:40:02",
    "text": "post the stack my question is about the order of invocation of actions are we dictating that in-stack actions should be before post-stack actions as well as within in stack how is the order dictated or is it not dependent on the order um you know what's your thought on that jegs can you answer that please oh yeah could you guys hear me yes absolutely okay so if you ask i'll just repeat the question so that uh i understood your question so we have a ini and pni so you're asking that ini is for the instructor indicator and the pns for the post stack indicator so asking like which one whether in stack or post stack is going to be the first yeah if there are multiple actions one some in the stack some host the stack how is the order dictated uh yeah that's it okay so um uh the order actually like uh um in the order like what we encode that's why you said it's more flexible like you know the application uh up code 10 and application 20 right so the 20 can come first and then can come second so it's more flexible like it's whatever the hidden things that the order should be it can encode uh that way in the instax data wise right so instagram is supposed to post track data so uh that actually like uh we haven't covered it uh probably we can uh talk to um hawaii who are you so uh who's our you know like post stack uh encoding partner so we can discuss with them and then we can come with that okay thank you looking forward to the resolution sure sure okay greg"
  },
  {
    "startTime": "01:42:00",
    "text": "you're next great go ahead greg greg nursky erickson so uh my question to kiribi um so am i understanding correct that um you intend uh to to cooperate with how you for the post-tech data encoding yes indeed um so the idea would be um i mean our implementation will focus on the in-stack piece and you know i have a bit here and can i parse it and can i get the associated data not for nffrr but maybe for the slice id and so on but there will be a bit that says there is postac data and then we'll see what it takes to implement to to reach the post act data but the post stack data format will be what's defined by how you and jeffrey so i think we can keep them relatively apart but at some point we'll see if they were together okay so um that means that you support the idea that uh encoding of instant data and poster data will be different using different encoding yeah okay interesting thanks so the in stack data you're working with 32 bits 31 bits and you know so you you probably applied different techniques and try to do things in a much more compressed way you might say i don't want to have a length field that's all implicitly either it's zero or four bytes whereas in post stack data i think you"
  },
  {
    "startTime": "01:44:00",
    "text": "have more space you're not constrained so you don't have to work in the same format that's at least my thinking now okay let's discuss it thank you okay jirong is next she are you there yes we can hear you ah okay so my first comment is about the postdeck data i think according to the previous poll result it shows that the psd is a necessary component of the mna framework and resolution and from the today's discussion it is clear that we are converging on the single solution for the psd encoding so that maybe it is a a good thing to move forward post that data encoding first the second thing is about the isd according to the poll again we think that it shows that people agree that isd may be used well there's also some concerns about to suggest to minimize the use of the isd so it seems that it would be better to define isd as an optional component so that we can allow a mechanism to carry the indicator plus the psd only and the second thing is uh if we want to minimize the use of isd as it seems the length of the isd should be constrained and the format should be easy to pass because uh we have seen the proposals to carry the isd multiple times in the level stat also we also unders the first thing is we may need to"
  },
  {
    "startTime": "01:46:01",
    "text": "consider the possible changes to the label stack operation introduced by the isd so these are the some concerns about isd design and following these considerations we have just just submitted a new draft on the encapsulation this week i will post it to the chat okay thanks okay thanks laura i have something i have haven't talked about before but it was brought up discussing order among actions here so it's a small comment do we actually think that if you look at psd for example we can actually take them in the order they are specified uh and then just go through the entire entire chain or is it like depending on act uh which actions we have uh the order could be be different i don't know if i'm not clear but i'm what i fear is that the order between if we define five different actions so we do one first and then we skip two do three and skip skip to five but if we actually decide to do number four it might be necessary to actually do that in that chain before number three so how do we handle this [Laughter] um"
  },
  {
    "startTime": "01:48:00",
    "text": "my question now is on terminology of the framework draft but coincidentally it's related to what law is asking there is a term we introduced in the frame framework is network action sub stack you know it gives the illusion is it's a stack and there is an order of uh how we push to the stack and then pop or if we want to do popping i'm not sure if we are going to allow popping of an action from the sub stack so that would be one thing to clarify uh and the stack is you know it has an order uh in nature like a nature of stack it's like there's an order of who pushed first and where that entry sits so with that uh you know placing the order of the stack be the order of invocation of the action okay uh tony you're next no i have a comment okay go ahead tarek that means that you can only do that for a homo enu set of actions either psd or isd you can't mix them at least if we can clarify within isd because the framework draft talks about uh sub stack or action network action sub stack yep okay so so the solution has its out basically a solution has to define what the order of operations for the network actions are now that could be anything deterministic you can go according to code point numbers you could go top to bottom left to right you could go right to left bottom to top whatever you want to do as long as it's deterministic and of course it has to be"
  },
  {
    "startTime": "01:50:02",
    "text": "specified in the solution document and you could do a create your own list and do it that way you could do that too it just needs to be specified so could there be in that list could that be a mix of psd and isd related action action indicators it can be anything as long as it's documented okay you told me okay how you go ahead okay yeah i i think uh for psd the only requirement we suggest is to put the hope by hope type before the end to end type because uh in on the past past note you you never need to look beyond the uh hope i hope extension headers so that's the obvious optimization other than that i don't think we should dictate any order of execution because that totally depends how you implement that in many uh platforms i i know that actually they do the header parts uh up front and then uh in actual uh factory uh for a processing pipeline they decide uh which which one to actually execute first with the order of execution so in that sense we uh we shouldn't dictate the order of actions that's my comments okay thank you john you're up next i'm john drake i'm going to say following up on what uh tony said uh it's also possible to define a composite network action which is a set of individual network actions in a specific order okay that was quick zeon"
  },
  {
    "startTime": "01:52:06",
    "text": "yes yeah i'm here in person i had a quick question if there's a case where you had both in stack and post stack i guess in parallel would there be um any performance issues with and probably order of operations kind of what we're talking about with the mna actions of you know processing post stack first and then and then in stack or maybe not doing both in parallel because that seems like there may be uh performance issues related to that thank you was that question um aimed to anybody in particular i i just it was for anybody who could answer i just a question that i thought of how how would that work and would would would there be an order of operation if you're processing pull stack and then you also had in-stack data first would you want to process in-stack first before post-stack or vice versa to me it seems like you would probably want to do the top of the stack in stack first and then post stack but that just as regarding performance i guess and what would be the best way to do that as far as performance creedy would you like to answer that i see you standing there all right um yes so the the idea of in stack data is it should be the stuff that is more critical and because it's more critical you want to put it closer to the top of stack you know cause a lower penalty or impose a lower penalty on getting to it and doing things so there's this implicit thing that anything that you put in stack is more urgent and then the post stack staff also has x and the additional thing that"
  },
  {
    "startTime": "01:54:01",
    "text": "um there will be some things that are hop by hop and some things that are end to end so post stack you would never put something that's in stack which is end to end that would be a waste of in stack space so so that's kind of the answer to your question again that in stack data will generally be more urgent and stuff you want to do first post-stack data will be generally stuff that you is more optional and some of it will definitely be pushed only to further end so it's not the hop by harvest end to end that's my view great thank you now we have five minutes left in the session and meet echo is is pretty strict about meetings ending on time so um i've locked the queue with two people left um rock cash and then how you so rakesh go ahead hi uh from cisco system so just to answer that question on the order in which the network action to be executed the jack strap has a very good solution for it which is opcode base and the end cap node can add the of course in a certain order uh it can be 24 and 10 or whatever order that end cap note desires the midpoint to perform the action that's one good feature about it the second thing is that an awkward itself can be defined as a series of flags and it has a meaning that it needs to be executed in this order so that also allows us to do the operations at midpoint without any ambiguity in a certain order so there is a lot of flexibility in the draft to help with this situation thanks okay and how are you yeah i i don't think the urgency is a criteria to put it in stack or post"
  },
  {
    "startTime": "01:56:00",
    "text": "stack because obviously some actions will require a large header overhead you simply cannot put it in stack because a size too big to put in the stack you have to put in post stack so but it might be very uh important to for that action so uh and also from the hardware design perspective you know if you do the parsing first and do the processing later actually it really doesn't matter if we put earlier in the package or later in the package so it it's totally up to the implementer to decide which action you will execute first so the urgency is no to criteria here okay thank you and tarek can you close this out sorry i didn't realize if if the queue was closed or not was it closed after me on before me it's closed now okay so you'll ask okay um okay uh i was gonna ask a question oh my goodness um i forgot anyways i'm sorry i'll i'll back out let go you can take it to the list please okay and with that i would like to close today's um pals mpls and detonate joint session i'd like to thank everyone who participated both remote and in person and we will see you all at iatf 115. thank you very much huh"
  },
  {
    "startTime": "01:58:20",
    "text": "hello i know [Music] my neighbors"
  }
]
