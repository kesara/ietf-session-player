[
  {
    "startTime": "00:00:13",
    "text": "it looks like we have two and did you did you see the main slides there too some reason it's not listed under meeting materials but if you okay uh one of the five power buttons yeah yeah we're trying to do it but since you're sharing we can't see what it is uh okay i'll take that down so you can just try yeah all right just one of you want to give us permission to try or do you see it chris no i'm waiting for one of the chairs to approve your request yep same all right now i don't see a request oh i see a grant yep cool oh there it is okay i see it technical slides got it all right i'll i'll stop sharing now but it looks good all right ben you want to kick us off well okay let's see it's uh is there a clock in the here somewhere well it's uh it's only one minute after the hour so i think we can give folks a little bit more time to to come in i'll uh we're going to continue mentioning that we will need an official minute taker before we can start the session"
  },
  {
    "startTime": "00:02:01",
    "text": "[Music] uh minute takers are are only required to note relevant and important points from the discussion a full transcript is not required or expected quick question ben yeah is this uh being is this recorded it does say recording just making sure that it is recorded i don't know that we have any control over the recording well it says it's being recorded which i think is a good thing i'm not getting against it but i want to make sure that it is being recorded made available because i'm looking at the number of participants and it's 17. yeah and it'll be good for thanks for reminding us of that uh yes so another reason you that that being a minute taker is not terribly difficult is that the full contents of the meeting are actually being recorded so the only thing we're asking for a minute taker to write down are the substantive conclusions reached by the working group in the course of discussion anybody who wants the full details can always go directly to the recording okay i think"
  },
  {
    "startTime": "00:04:00",
    "text": "that uh that people have have more or less finished trickling in so i want to remind everybody that this is an ietf session it is covered by the ietf note well that covers both things like patents and ipr related to any discussions or activity in the working group and to the code of conduct which requires us all to be professional and respectful in our communications here i'll i'll avoid trying to summarize the full details of the ietf note well but if you're not familiar with it please do familiarize yourself with it before participating in the working group as mentioned we do need a minute taker before we can begin the discussion in earnest so if anybody would like to volunteer to to record some minutes please do let us know the note taking tool is uh is right up on the top of your meet echo screen it's the fourth button from the left at the very top i believe so it's very easy to jump in and make some notes we would appreciate it jabber if you finkel uh okay okay thank you very much"
  },
  {
    "startTime": "00:06:02",
    "text": "uh thank you to matthew finkel for volunteering to take some notes anybody else who has a moment to to help out is welcome to do so in the collaborative note-taking tool if you do need to go to the microphone and don't want to or are technically unable to use the voice features in meet echo please just type your question into the chat with a request for it to be brought to the microphone and one of the chairs will handle that for you and when you are coming to the microphone please help out matthew finkel by stating your name so that so that we know who is speaking let's get started this is our proposed agenda we have 90 minutes for this session we have three presentations i think in each case we will try to take only clarifying questions during the during the presentation and then have a few minutes for a more general discussion before coming back to the next set of slides and finally an open discussion at after all of these presentations to consider how we should take action as a as a group based on the new proposals and and changes that have been brought before the working group i think we're ready to get started with our first presentation so i'm going to turn my slides off and approve chris wood for slides uh chris wood and john iengar it's all yours all right thanks um so i'm gonna talk i guess about"
  },
  {
    "startTime": "00:08:00",
    "text": "half of the architecture i'm gonna hand it over to john to do the rest uh so there's gonna be an awkward split in the middle uh so apologies for that but you know we can work through it um okay anyways uh so this whole set of presentations is the result of uh a couple of us going back to the drawing board and looking at you know what is the state of privacy pass in terms of the architecture in terms of the protocols um and how can we sort of move it forward to something that's you know feasible to implement feasible to deploy um while still satisfying uh the the use cases in the charter um and all the you know the existing like w3c considerations and whatnot um uh and upon like revisiting the architecture um we found that it didn't quite capture uh the the intent of the you know the the overall desired ecosystem and we're going to kind of lead you through our thought process that led to this new proposal the architecture document and so hopefully at the end of this it becomes clear why this new reframing of the architecture is i think more appropriate given the the scope of this particular group and what we're here to to achieve so with that said um let's jump in i'm going to motivate the architecture by just reminding everyone sort of what the interaction for privacy pass is right now so let's say you have a client and a server who are interacting with one another the client is specifically talking to the server or interacting with the server to get some particular resource on the web say an image in this particular case um but the server upon you know getting this request from the client uh decides to to challenge the client because it looks suspicious you know comes from an ip address that it doesn't trust or has a poor reputation as was the case with tor the original motivating uh use case for privacy pass"
  },
  {
    "startTime": "00:10:00",
    "text": "or whatever other reasons the server might have to challenge the client the client upon getting this challenge will solve it for some definition of solve and generate a proof based on the challenge and sort of generically using the word proof here to just talk about you know something that was done to satisfy the challenge uh that the server just sent and sends along to the server if the server's happy with this as in you know that the proof checks out for that corresponding challenge the server happily does whatever you know the client requests in this particular case um getting the picture of the doc the interesting piece of privacy pass is really this middle this middle section this challenge and proof interaction now if you go back to again the original motivating use case for privacy pass it was that the challenge was expressed in terms of a captcha you know can you solve this capture that was what the question that the the server asked the client and the client would you know engage the user to solve the capture click on buses sidewalks whatever and then the solution to the captcha which was the proof was sent from the client to the server and the server would just check that you know it was valid for that particular instance of the captcha but there's really nothing that says that the actual proof that the client sends has to be a solution to a captcha and this was the you know the key insight of privacy pass rather it could be proof that the the client had previously solved the captcha like i interacted with the server before i got some proof at that that point in time that i solved a particular captcha and so at some point in the future if i get challenged again i just re i represent that proof to to the server we're not representing present that through proof to the server and if the server trusts the particular proof um everything checks out"
  },
  {
    "startTime": "00:12:03",
    "text": "but you can generalize this a bit more it doesn't have to be a captcha that the server asks the client to solve it can be you know any type of property that the server wishes the client to attest to so capture is just one example of that it could also be you know do you have a valid account for for this particular application do you have a valid device that you're using to access this particular resource and any combination of properties really that makes sense for the server's particular application and the client upon getting asked to attest to these particular properties or this particular property can present that proof to the server and the server can check it based on you know whatever and then do whatever the client wants so let's uh now sort of break down what happens when a client attests to some particular property and then presents a proof to the server let's imagine there was a separate function for uh that the client interacted with for testing to a particular property and then kind of kind of getting proof that it did this attestation so in the interaction before the server would challenge the client to attest to some particular property client would then go talk to what we call an issuer it would do the attestation with the issuer and then the issuer would present proof of attestation the client would then relay right along happily to the server and if the server trusts this particular function this this issuance function then this is indistinguishable from the case we had before where the server was like the one doing the attestation and generating the proof and then checking the proof later on if you have this trust relationship between server and the issuance functionality"
  },
  {
    "startTime": "00:14:01",
    "text": "the the the the resulting system is effectively the same but we can decompose this even further imagine now you took the attestation piece of this and you you made it explicit and pulled it out of the issuer and so in the interaction that we had before the server would challenge the client to test some property client would do this attestation to some a tester the tester then would on behalf of the client ask for a proof and the issuer assuming that it trusts this particular tester would generate proof a tester would forward that proof to the client and then the client would present that proof to the server and so now the trust relationship sort of looks like this the server trusts the issuer to present to to generate proofs the issuer trusts the particular tester to do attestation of the client and then this this arrangement we argue is basically the same as the original you know interaction where everything was collapsed together and indeed that's what the privacy pass architecture was written or that's the way it was written it was written such that everything in red was the same box it was referred to generically as an issuer but really we can we can split out these functionalities into separate separate functions it's separate functions that exist on the same box or separate functions that are run by separate members of the ecosystem and that's that's the the the new sort of reframing that we're we're proposing for the architecture document and with that said i'm going to now uh do the awkward transition over to janna to to describe more about the different variants of this so i'm going to stop sharing and then and then be quiet well i was going to ask you if you could just continue uh sharing but that's"
  },
  {
    "startTime": "00:16:01",
    "text": "i i could but it's it's probably all right can we get to slide 14 okay there we are okay end of awkward transition thank you chris we made it as awkward as possible hopefully that woke you up from your well whatever time zone you are in um so uh continuing just left off basically um the idea the important idea here and this speaks also the question that's uh npd is asking punjab the idea here is that separating this separating these functions and we want you to think about these as functions that are that are part of the architecture anyway separating them out gives us degrees of freedom now of course the degrees of freedom are useless if you can't do something with them and we'll talk about that later but but this allows us to be allows us to instantiate multiple different variants so to speak or instantiations of privacy paths bear in mind that we don't need them all to be separate entities like for example in in the existing privacy pass architecture you could think of the issuer as uh the architecture is the first one which is like a combined origin at a certain issuer where everything is the same same entity the client speaks to the origin and the origin also happens to be the attester and the issuer at the same time so that is one instantiation of this architecture that is possible you can also have a second instantiation where you have separate origin and a combined issuer slash a tester where the client speaks to the origin and then gets a challenge and then goes off to this other entity which is the attac surplus issuer and uh uh and and gets this um uh gets the gets the proof that it takes back to the origin and finally all separate entities as well um"
  },
  {
    "startTime": "00:18:01",
    "text": "this is this is separate again separating of the architecture yes it does make it seem a bit more complex but it does give us uh benefits because we are able to do some things here that we can't otherwise do and we'll get to that in the details um but i'm going to talk about uh just architecture at the moment npd again we will we will get to that especially the rate limiting document speaks to the all separate case because that is one instantiation of the architecture that you need to be able to do um rate limiting anonymously for for clients so you will see that in the rate limited example but generally speaking we believe that the that this that the separation allows us to to to build more use cases within privacy bus so uh the protocol structure for this architecture is split into two and these are described in the architecture document the first one is the redemption protocol then the redemption protocol is simply where the client is able to redeem proof with the origin and this is a consistent uh protocol for uh for all of the use cases that we can do with this that's the goal is to sort of have one redemption protocol no matter what the use case uh so that the client origin interaction remains exactly the same the extensibility in this architecture comes from being able to have multiple issuance protocols because the issuance protocol effectively says hey i'm going to issue you a proof for a particular property that uh that the client has to attest to and that defines the issuance protocol to some extent and the particular details of that would depend on the use case so for different use cases we might have different types of issuance protocols and this is this is an exchange that we can extend we can replace it for new deployment models so again the idea here is to keep the redemption protocol the same for all use"
  },
  {
    "startTime": "00:20:00",
    "text": "cases but have different issuance protocols for different use cases stepping back uh the big picture here is that the architecture now the new proposed architecture at least uh argues that some function attests to a property that is associated with a client such as a captcha or something else the issuers are the ones that uh that look at what the address is attesting to and then they produce a proof or a token that is bound to that property and the redeemer then consumes the stroke right or the origin consumes this token that is generated by the issuer so those are the functionally those are the those are the pieces that we believe are part of uh the the architecture here so to the question of why do we want to rework the architecture i've said this in in other words already but generally speaking the high level picture here is that the current architecture tightly couples these two pieces that we're trying to separate out and separating the issuance and redemption parts allows us to have new deployment models that are uh that are that are possible now and that that we'd like to be able to build to but are not really possible with the existing privacy plus architecture um the the new issue as i said the new architecture uh leaves redemption on change leaves redemption as it is for not reduction as it is but creates a dimension protocol that remains the same for various uh uh use cases but you deal with them uh by changing the issuance protocol uh this makes attestation explicit as an architectural piece but it is only you know it is explicit as a as a instantiation as an entity only in particular deployments not in all depending on your deployment you might want to instantiate it separately or combine it as i showed earlier so finally our proposal here is to define the architecture in terms of these functional roles the uh the flexibility that this offers obviously"
  },
  {
    "startTime": "00:22:01",
    "text": "comes with some complexity in understanding the different roles but really we believe that it is it is uh separating these roles if they were hidden anyway and the degree of freedom that it offers us allows us to express some use cases in privacy paths that we weren't able to and it defines the protocols in terms of the redemption and the issuance protocols and we have a pr here that describes this architectural change that we like to merge into the architecture document that's all i've got checks do you want to do questions now we've got five more minutes left in the presentation yeah this would be a good time for any questions about the draft about sorry about this um proposed change to the draft chris should come up to the mic so hi uh not as chair uh in this new in these diagrams you you have four entities and three communication links which of these links are standardized or standards relevant and which of them are essentially by private agreement um so the hard uh uh i'm gonna understand maybe uh tommy you can jump in um the the the the protocols are standards they're all standardized like i mean all of these three entities are effectively can be separate completely separate organizations and therefore the"
  },
  {
    "startTime": "00:24:01",
    "text": "protocols between them will need to be standardized and that's that's uh in the different protocol documents that we have tommy do you want to add something sure okay um yeah i think the answer is it's a little nuanced um so then i would say between the client and the server i think you should be really standardized and i'll be talking about kind of that challenging phase i think that's kind of the most important be very because you were imagining that this is mainly a client talking to a web or some other server that it doesn't have a prior relationship with because otherwise it wouldn't need anonymous attestation validity so that one i think needs completely standardized on the other side i think it gets a little bit um more flexible depending on the situation so you know i would argue that even in the existing architecture um the actual attestation step of solving the captcha you know that part itself was not standardized um the thing that the client does to the attester to say i am legitimate and even if it is standardized i don't think that's something that's within scope for privacy pass itself we're not defining how you do captcha we're not defining how you do device association or account login or whatever else it is so there's kind of like some step in there that is unique to how the client talks to the thing that lets it get tokens and that"
  },
  {
    "startTime": "00:26:00",
    "text": "is specifically not standardized in this group um but uh you know as we will go into in the third presentation around issuance protocols the way you actually get a token you know that needs to be standardized and that's what already existed for the issuance protocol saying hey here's how you use a pop-rf or here's how you need to get a publicly verifiable token and so there's there's a bit of standardization on the issuance protocol but i think it's expected that no matter how you deploy it with the tester and issue were combined or separated there is some bit of like additional things that need to be added to the exchange that are not in the base privacy pass spec that actually prove that this is a legitimate client does that make sense that's certainly helpful thanks let's move on to the next presentation all right um was my audio still choppy i saw that in the jabber it seems to have improved okay that's that's great all right so now we're going to go into the two halves of the protocol that we talked about and i'm going to start by talking about this challenging redemption phase oh and could the chairs restart the timer actually because i'm getting the red flashing lights that i'm almost done"
  },
  {
    "startTime": "00:28:00",
    "text": "great all right so going back to that diagram this is just focusing on what is this interaction between a client and what i'm calling an origin here because i'm thinking of this in the web server context but this could be any server that the client talks to that it wants to be able to provide anonymous tokens towards and as we were just talking about with ben i think this is the key part to be nicely standardized nicely extensible because this is the case where you're talking to someone who you don't have a previous trust relationship with and as i had in the title here there are two halves of this that we think of and we're calling it challenge and redemption and the broad shapes not talking about any particular protocol here is that in a challenge the client is telling some server hey i want to do or access something and the origin is like prove that you're able to access this you know give me a token to prove that you're not a bot or to prove that you have an account or something and then the redemption phase is when the client comes back and says hey i do have a token or proof or whatever it is and the origin says great go ahead if that works or it says no that was not enough and not the um both of these are not always required so the redemption half no matter how you slice things i think is a fundamental part of any token scheme we have we actually need to spend the token um and so the token redemption is whenever the client presents a token to gain access and within privacy pass these tokens are anonymous"
  },
  {
    "startTime": "00:30:00",
    "text": "but they are essentially an anonymous way to say i did something and i got this token issued to me you should trust me and then the challenge half is optional but often is useful and some of the things that the challenge adds as value is that it allows the server to indicate in the first place that it supports tokens or privacy pass and that it wants them from a client it's an opportunity for a server or origin to indicate the types of tokens um that it wants like what you know is this publicly verifiable is it using this algorithm or not and it also can indicate who this origin trusts to issue tokens like what keys is it going to validate against and the last thing it does is that it does allow for interactive tokens and this is something that i don't believe was captured previously in the protocols but there are cases where you may not want to have a big bag of tokens that were previously cached but origin may have a higher bar and say i want you to prove right now that you're able to get a new token issued to you all right so what what was missing in the landscape we had before um because you know previously as people have been testing with privacy pass these functions have been running but the previous design really relied on the javascript apis as defined in w3c it relied on them to actually drive this challenge and redemption functionality there is an http api document that we have but it doesn't really give you the full scope here to be able to run this whole protocol"
  },
  {
    "startTime": "00:32:02",
    "text": "there wasn't any clear way that we could support new token types so previously it was only defined to do poprf but we know that the working group does want to be able to support publicly publicly verifiable tokens as well so what we're proposing here is that you know if you look at this interaction model of oh i have a challenge when a client tries to access a resource and then i want to be able to provide a token and authentication it really really fits cleanly into an http authentication method and defining that within this group we believe will allow for a really nice standard definition that could have explicit support for different types of tokens so we can have this be extensible and have it evolve and this would work cleanly with the javascript apis there would need to be some updates to actually what those javascript apis do but they could just drive http authentication very easily but it also allows us to do this in non-javascript and non-web contexts and in the discussions we've been having with people um you know beyond just web interactions there are a lot of interactions of apps or other um non-web scenarios that would really benefit from being able to use privacy pass and it also has the benefit of having something we could define within the working group that can work standalone and then also be built on by the w3c so the authors are proposing that um this work that we're defining here can essentially replace the ht http api document that we have and broaden it into this authentication method scheme um so the different features in this scheme are"
  },
  {
    "startTime": "00:34:02",
    "text": "types and these token types define what issuance protocol you want to use um and this is indicated within the challenge and the redemption phase um chris will talk later about the different types but you know essentially it'd be like oh there's the pop rf there's a publicly verifiable option etc it also can indicate the issuer name and essentially say oh this is who i trust or i can have multiple names of you can get tokens from any of these people and it can also provide hints for the keys to use to make it faster for clients to get tokens without having to fetch some config from the side and then also has allows for some optional features which we think are very useful one i already mentioned is an interactive token essentially the challenge can come with a one-time nonce so that um an origin can prove that the client was able to fetch a new token kind of in line and this can avoid certain farming attacks and then you can also just include within the elements that are assigned on the token the actual origin name and this uh can prevent cross-origin spending or attacks where you're trying to fingerprint what users have been going to or one origin draining tokens that were meant to be better used on another origin as an optional thing you can add in all right so what is this oh yeah um the other thing we want to focus on here is we believe that it's really important if we want privacy pass to be widely used and adopted throughout the web and other servers that it needs to be really really easy for origins to adopt when you look at the overall system for privacy pass you know there"
  },
  {
    "startTime": "00:36:00",
    "text": "is some complexity but i think we believe that that complexity belongs more on the side of issuance and how do clients prove what they have but on the side of just presenting a token to a origin it should be really really simple for that origin to do so that many many websites and origins can just adopt this and replace captchas or replace other things they have so as part of this the origins don't need to do any complex crypto they just need to verify tokens for publicly verifiable types like rsa blind signatures that's really really simple to do um privately verifiable tokens um do require the origin to have an issue or key or make a request to the issuer um that's what we have with the poprf but um it's not too much to do in that case but an origin can always choose to prefer the publicly verifiable type as well and interactive tokens can also mitigate some concerns that origins had around farming and double spending and tracking that state if you're using interactive tokens you're shifting the state that's required on the origin from maintaining oh here's all of the redeemed tokens that i've had and making sure that no one's double spent to instead just having a nonce uh that's associated with a single um http session with the client and you just need to remember how many nonces did i give out what were they and that can be um much much more bounded uh so the actual protocol details here we're just proposing a private token um http authentication scheme that includes a challenge and a key that goes along with the challenge the challenge is a structure that defines what token type it is so it tells you what issuance protocol to use it has a required issuer name"
  },
  {
    "startTime": "00:38:02",
    "text": "and it has an optional nonce and an optional origin name that can be covered by this so if the redemption nonce is present then you need to get a fresh token every time if it's not present you can use a cached token like you traditionally would with privacy pass today if you have an origin name present really that just is something that gets signed and so if um if the origin name is present you need a token that's specific to this origin and you can't do cross-origin spending but you can still cache it otherwise if that's missing it's just a generic token that can be used on any origin that supports cross-origin tokens and the redemption side is also very simple you just provide the token along with the scheme that includes the same token type from one of the challenges it includes a client generated nonce that's essentially makes the token unique it includes a hash of the original challenge and that's what make sure that it covers the original challenge nonce or the origin name it contains um the key id of the key that signs the token and then has an authenticator which would be a blob that's specific to the particular issuance method that can be the blind rsa signature it can be the pop or pop rf output or something else as we come up with better options into the future um and so you know as long as you're using a valid issuance protocol this does meet kind of the architectural requirement that this is unlinkable redemption you can't link any two tokens back to the same client and so overall the proposal here would be"
  },
  {
    "startTime": "00:40:00",
    "text": "to essentially adopt this document or replace the content of the existing http api document with this definition of the http auth scheme and then move any of the http interactions with issuers into an issuance protocol document because we believe that can be iterated upon or swapped out for different issuance protocols in the future and then the other piece of work we would need to do if we did this is you know update some of the w3c api interaction it doesn't necessarily need to change the api surface just what it drives to have it drive this http off method well and that's all i have on this do we have any clarifying questions joe so basically you you're between the uh kind of this redemption protocol um you still have a link there is a linkage between the issuer protocol and that you need to get a particular type of token and exactly what the client does to prove that in that opaque blob is um depends on on that what happens during issuance but the rest of the but that kind of the protocol shape is the same no matter what that's kind of the idea that that's right um and you know the idea is you know today we already have you know we've already defined p or prf we want to bring in something like rsa plan signatures for public verifiability so we need to wait to tell between those but even going forward i think there their desires to have lighter weight publicly verifiable tokens and it'd be nice to be able to use a common challenging redemption method and just have a bit to indicate oh yeah i also support this new"
  },
  {
    "startTime": "00:42:03",
    "text": "token type that can do a blind signature that's publicly verifiable we're going to support that as well and so it allows us to evolve without having to rewrite origins completely every time right thanks all right ben that's what not his chair uh so in in previous uh in previous iterations one of the questions that has come up is about the privacy implications of timing based linkability for these kinds of interactive issuance situations so my first question is what do you what do you think of that what do you think of the the concern that a uh that if an origin can tell me exactly when to request a new token that the the timing of that uh identifies the user yeah um i mean i think that certainly is that that can be a concern we've the authors have discussed that as well um generally you know that that's the type of thing that will be more mitigated for higher volume um sites essentially cases where if you have you know millions of people always getting tokens then you're not going to be able to use the timing attack there i think it kind of folds you know if i have very very few people getting tokens with the place um even if i don't have a timing attack you're probably able to guess pretty well who i am it also plays into a little bit the"
  },
  {
    "startTime": "00:44:00",
    "text": "um the interactions that we have on the issuance protocol and the role of if we do separate out a tester that a client who is coordinating within a tester let's say you know my ios device talks to a server that can do device attestation it could say hey um you know no one else is using this issue or it seems like maybe you're being fingerprinted here as opposed to saying oh yeah i know that millions of people are actually going and hitting this all the time uh you have a big enough anonymity set but yeah it's something to definitely continue discussing yeah i think that's that's interesting i you know i would point out that if you have an issuer with somewhere in the vicinity of let's say a hundred thousand active users uh you know if those users all get a fresh batch of tokens once a day then uh they have an anonymity set size of a hundred thousand but if they are in this interactive mode then they essentially are fully identifiable uh because issuance presumably takes much less than one second so uh so it depends how you do it now uh so anyway i would i would like to see certainly um some very clear analysis on that and especially from the client's perspective um you know are all these tokens do all these tokens have the same privacy implications and do we want to you know do we really write it down and do we really want to provide a so it we've talked before about for example public metadata as something that can affect the privacy uh protection value of a token but that's something that's very clear and measurable to the client so it can it can do its own accounting for whether it wants to support that algorithm for example yeah i think that we need a little bit of thought into what the client's local"
  },
  {
    "startTime": "00:46:01",
    "text": "policy is supposed to look like around these around especially this interactive question whether it can essentially budget for the amount of privacy loss that implies or whether it actually is kind of unknowable to the client yeah i i agree that that's that'd be a good thing to add into here thanks uh i also wanted to um specifically ask about the knots um is that not somehow blinded before it reaches the issuer the yes chris can talk about that a bit in the issuance protocol i think okay thanks yeah chris did you have a comment uh yeah i just um ben was asking for some analysis um but then what i what i think i just heard sort of come out of that conversation was that language around you know what the client doesn't know with respect to like how many other clients are happen to be using this issue or at what time um is something that would be good to add so uh ben i'm not sure like what analysis you had in mind um beyond sort of just noting these considerations of the interactive um protocol variants well so so i should be clear you know it's i i have i'm concerned that these interactive variants don't effectively provide significant privacy that if we consider all of the other metadata visible to the other parties that clients are actually effectively uniquely identifiable even at quite large scales i would so i would like to see on the analysis side can we you know make a convincing argument that the clients are strongly protected and and uh show the sort of scale that's required there and so and also can we talk about um about what we think clients should do to to keep themselves well"
  },
  {
    "startTime": "00:48:00",
    "text": "protected um what what can i can okay um so my my immediate reaction to that is that um this is somewhat like you know the leaky goat problem um that we we kind of face in ech like we are we are designing the protocol such that it's like cryptographically unlikable between issuance and redemption and yes if there's additional metadata that's leaked particularly around like the time stamps of these events um that you you could stitch things together after the fact um [Music] but that seems uh sort of separate or or external to the the protocol that's sort of being defined here one of the nice things about the redemption protocol that i don't recall you mentioning tommy is that the the the clients uh have some leeway in terms of when they respond to a particular challenge um in fact the hp header that comes that carries the challenge has like a max age attribute and the client can use that if it wanted to to like delay things to do all sorts of you know randomizing things i'm using air quotes but you can't see it to sort of hide the the the time stamp to some extent um or to make it less correlated with what the origin sees so um i i i don't consider this to be a deal breaker uh any more than i would consider like leakage from ip addresses to be a deal breaker for ech thanks uh that sounds like an example of something that should definitely be be documented and again analyzed in terms of like how much delay is is the recommended value how should the client just make that decision right um i i don't want i don't know if you can add recommendations here though that's kind of my point like the clients are in a position where they don't know how many other clients are interacting with a particular issue or and they don't know like what the value is i"
  },
  {
    "startTime": "00:50:00",
    "text": "think noting the considerations here is very much appropriate but trying to offer recommendations for local client policy um seems like an intractable problem to solve yeah sorry i know we're over time i just want to chime in one more answer here so i i think this is another case where [Music] the architecture thinking about a tester and issuer roles separately actually does help so not only does is it possible that you know a tester could help clients know about the scale but i think more importantly when you talk about a timing attack we need to think about you know what is the information that is vulnerable and could be used to correlate information back to the client right so you know yeah if you think about a case where i talk to my origin over tor and i'm having my ip address but i talked to the issuer and i had to reveal something to it like my actual ip address or my account or something that's more identifying then yeah that's really bad um to have that linked back but if we have deployments where the actual issuer that's handing out the tokens is you know more distanced from the client such that it never sees the client ip the client's going through it another a tester or something else even if they do have some um ability to you know guess with a small enough set that oh yes this is the same token as that other one they may not um actually learn much because the issuer may not know anything about the client um so that that's another way that clients could get some protection here and that's it"
  },
  {
    "startTime": "00:52:14",
    "text": "do uh okay thanks tommy um and thanks for the questions uh so i'm gonna now pivot over and talk about the the issuance protocol that works uh in conjunction with the redemption protocol um and it sort of complements it in a way to produce tokens that satisfy a particular challenge from the from the uh origin um so this again is the the scenario here you have the origin that interacts with the client to send a challenge and the client then on the side runs this is protocol to produce a matching token you can sort of view like the interface to the issuance protocol like so input from the origin again is just a public key that's used to verify the particular token uh so in the case of the people here if it would be the public key the case of uh like blind rsa for the publicly verifiable variant it would be the public key for binder say and then the challenge which is like this this token challenge structure that tommy was uh had on the slide earlier um and then the output from this is a just an encoded token that the client then sends back to the origin so basic issuance is really quite simple um i'm going to walk through sort of the cryptographic steps that like drive it uh this is something that was in the existing protocol document um uh or steps of this were sort of in the existing protocol document but we modified it to accommodate and integrate with the existing redemption protocol or with the proposed redemption protocol rather so anyways the first thing the client does uh upon receiving this challenge is it generates a fresh nonce of its own separately from whether or not the challenge carried a redemption hunts um and then it produces a context uh"
  },
  {
    "startTime": "00:54:00",
    "text": "string or struck context value which is effectively a hash of the challenge and then from that point on all it does is run basically the pio prf or the blind signature protocol over the pair of nods and context values so what i've written here is sort of notation that's specific to my blind signature protocol specifically using the function blind with the public key of the issuer um and uh uh but like you can you can imagine it being sort of any any sort of suitable issuance protocol that that matches that shape um where the the inputs here are nodes in context are private they remain private from the issuer during the issuance flow and the output um uh that the the client sees is a like a valid signature or an authenticator as was described earlier over this private input okay so generates a nonce computes the context and then starts the blind signature protocol as per the blind signature protocol after computes it's blind or request in this particular case sends that over to the issuer perhaps going through the tester if necessary for this particular deployment doesn't need to be though yeah sure then is an oracle for computing blind signatures over arbitrary requests so it gets in a request computes a blind signature and then immediately sends the response back to the client and the client simply finalizes the protocol to compute the authenticator um pretty straightforward very simple um and as i was saying earlier i've written this in terms of the blind signature scheme but this is uh in the basic issuance proposal that we have up uh this is also implementable as a blind signature um or as a popuf sorry"
  },
  {
    "startTime": "00:56:00",
    "text": "one of the things that we've introduced with the the new issuance protocol scheme is uh this the notion of a token protocol or an issuance protocol type um and a corresponding registry to match where the registry sort of defines the parameters of the the issuance protocol or a parameter might be whether or not it's publicly verifiable um that is you know can you verify without having an authenticator without having to interact with a particular uh issuer does it have uh support for public metadata that is input or data that is revealed necessarily to the issuer and computing its you know it's it's half of the protocol um or does it support private metadata none of the proposed schemes uh in the registry right now do support private metadata but there are some existing proposals um from folks at google for um building anonymous issuance protocols with private metadata bits individual bits um uh we could we could you know extend this registry to denote like how many bits of metadata is are supported um uh so you know bike shedding here is necessary um but but we feel like these these are sort of reasonable dimensions and reasonable parameters for issuance protocols and of course uh the size of the authenticator um because that sort of defines the the structure of the token that comes out of the other end so right now in the basic issuance pr we have uh two token or two issuance protocols sort of uh just described uh that are in line with the redemption protocol first of which is based on the popuf work from the the corresponding cfrd draft instantiated with p384 and shot 384 the this particular curve was uh chosen because we didn't want to deal with the static diffie-hellman problem uh so we just bumped up the the the curve a little bit too to address that and then we have blind rsa which addresses the publicly verifiable component of the charter um and is a"
  },
  {
    "startTime": "00:58:00",
    "text": "drop in replacement effectively for the pop ref um as described on the previous slide and we can you know certainly consider um adding new issuance protocols to this registry as needed so we could add the the html protocols to support the private metadata bits either the ones that are privately verifiable or publicly verifiable there are proposals for each and i don't know if there are cfrg drafts yet but that's all that would be needed to sort of plug in here we could also consider adding blind bls there is an existing cfrg draft for this and work is underway to add blind support to that particular environment an important note point to note here is that these issuance protocols are only two messages are one round trip between client and issuer there are constructions that are more than one round trip that require three or four messages depending on the shape um those would be compatible with the issuance protocol as or with the architecture as described like the number of round trips is not really a constraint in terms of you know the the architecture um because it's it's it's you know implementation details uh specific to the issuance protocol um so i didn't i didn't list anyone's any of those here uh because there's there's concerns around you know how you would deploy that this sort of thing um this this this type of issuance protocol with more than one round trip in a stateless way um or in a way that's safe uh that has to deal with the state that the the issuer maintains per per client um but it but it is certainly possible so there's a couple considerations um uh that i wanted to note that the first is that the existing sort of uh like i said the existing sort of issuance protocols that we specified assume that the issue were stateless so it's one round trip for issuance protocols but we could certainly move to um"
  },
  {
    "startTime": "01:00:01",
    "text": "uh protocols that support multiple round trips as necessary um nothing nothing prohibits that another thing to note is that um the the way that the issuer is uh interacted with and in particular the apis that are exposed uh by the issuer in order to interact with it are compatible with any deployment specific key consistency mechanism that would be desired for an application so you can imagine like a service that pulls down issuer keys and throws them in a log somewhere and then clients check that log whatever is appropriate for a particular use case or for an application the point is that the all the keys that the issuer might use are discoverable and via a well-known api and then you can build things on top of that that api to build consistency into the system how that is done is out of scope there is a there's an individual draft that sort of describes different ways to address key consistency in the ecosystem um but we don't think uh that's like that needs to be included in the these drafts more so that they need to accommodate uh any of these particular mechanisms if needed for a particular use case yeah ben go ahead clarify question you said uh that key consistency is out of scope are you noting that as out of scope for a particular draft or for the working group i think for the for these particular issuance protocols like the issuance protocol should not address how to deal with issuance or issuance key uh consistency rather it should enable other work to address that if as as needed so i i don't recall what the charter says in this particular topic if it says that we need to address uh key consistency that's cool we could we could certainly write a separate draft that deals with it um based on the issuance that's described here yep"
  },
  {
    "startTime": "01:02:01",
    "text": "okay um uh so uh in the architecture document we describe various uh ideal security properties that we'd like for the insurance protocol the most obvious one is this notion of unforgeability where clients you know can't just forge tokens without having interacted with the issuer um and so all the issuance protocols as specified in the registry right now support this particular property and indeed this is a requirement to go in that registry um they also require that the uh this notion of what we call issue and secrets see issuance secrecy and the description here is not the most clear but issue and secrecy basically means that any of the input that is uh provided to the to the blind signature protocol or the the issuance protocol generally is not revealed in any way to the issuer so if you recall from the diagram really we had this nonce and we had this context both of them are unconditionally secret even against an all-powerful attacker um uh who has like endless compute and endless memory whatever um and this is necessary for the privacy and particularly the unlinkability guarantees that uh we have between issuance redemption okay so the proposal that we have at hand is to basically take what was currently described in the protocol document which had bits and pieces of this so it did have you know the deep some language around how to integrate with the pop rf um it did have some you know details about how to do redemption but nothing that was you know implementable and interoperable um the proposals take is to take the the basic issuance protocol details and built upon the proposed redemption protocol and make that uh sort of the the working group document protocol document um uh and there's a number of reasons to do so uh a uh"
  },
  {
    "startTime": "01:04:01",
    "text": "it satisfies a perhaps should sort of these differently but a it satisfies uh that the two uh are two requirements in the charter that we have public and private verifiability um it does integrate cleanly with the the redemption protocol that tommy presented um and it sort of uh addresses this this question of extensibility that has been floating around for you know at least a year now i think um we were sort of tossing around different ways to address extensibility is it in like the the wire format messages that are sent between client and issuer is it like how do you how do you change the crypto and blah blah blah but the the current proposal where you wrap up all of the sort of issue and specific details under a token type and then introduce new types as necessary to uh extend the system with new or extend issuance protocol with new features uh like rate limiting as kind of we'll describe later if there's time um it's a very clean way to sort of address this with minimal complexity on the on the origin and on the issuer side specifically if you don't want to support any of these extensions you just don't implement that for that token type protocol very simple okay um before we go to the questions the working group slide i wanted to pause here and see if there's any questions okay if not uh i'll move forward then um so we uh just to kind of wrap up um there's a there's a couple uh high-level questions we have for the group um first of which you know are the we want to know if the the document proposals have presented specifically"
  },
  {
    "startTime": "01:06:00",
    "text": "for the architecture document the uh challenge and redemption protocol document and then the the basic issuance protocol document are they clear um it's the sort of scope and um does the scope make sense um uh are the uh are the abstractions right or considerations right and so on um and then second we want to know or we want to try to assess if there's consensus to move in this direction which specifically means updating the privacy pass architecture document based on the proposal at the beginning as well as the protocol document based on the the basic issuance protocol that i just walked through as well as considering adoption of the new um authentication scheme that that describes the challenge redemption protocol that tommy went through and uh so i'm gonna stop sharing and i'm gonna turn it over actually i'll keep sharing but i'll turn it over to the chairs so i think this is where discussion happens hi ben schwartz as chair i would really appreciate hearing comments on these questions from the authors of the current adopted drafts so if you're an author or if you're a co-author on a current adopted draft i would really appreciate it if you would come to the mic and give us your thoughts thanks um hopefully you can hear me yeah i think the uh restructure of the graph seems reasonable i think there's a few issues to work out like what information we put in the architecture dock like the uh interactive timing um i think moving to the http instead of the current atp api"
  },
  {
    "startTime": "01:08:00",
    "text": "method i think works well i think there's going to be some questions about like cases where you need to trigger issuance redemption in ways that you don't necessarily have that like first leg but i think that's all things we can edit within that specification overall seems reasonable thanks alex hey um yeah alex davidson brave um so personally as an author of the both the architecture and political drafts i think these proposals are clear and and also moving forward in this direction makes sense um i think the one the one concern i have is around uh as people have brought up previously these interactive challenges and and how we parameterize the privacy in the client privacy in those cases because i think it could radically alter the anonymity set sites for those clients and that's something we we tried to parametrize before um and if if it's decided that we don't want to do that then um then then that might be maybe reasonable but i think the current parameterizations we have then are kind of redundant in that case thanks alex chris uh i just wanted to say that i i support the new direction if that wasn't already obvious thank you sophia uh sofia from cloudflare um yeah i just wanted to say as well that i support the new directions and it seemed to be some really small open questions but i think we can discuss that further and yeah thank you for uh pushing forward all of this new direction"
  },
  {
    "startTime": "01:10:08",
    "text": "thank you uh it seems like we've ha all the comments we've heard have generally been positive and supportive of both updating these drafts and of adopting the new authorization draft does anybody want to provide an opinion going the other way uh okay it seems like there isn't anybody speaking against these these things um i uh i haven't had a chance to confer with my co-chair i i would like to propose the following it seems to me that the updates to the existing drafts can uh can move forward without any further review by the working group of course the contents of those drafts will will be subject to many rounds of further review before it can exit the working group and the new draft uh i think uh it's it seems to me that that the that the group needs some time to um to do a formal review for this before we do a call for adoption so i uh i don't think i don't think we're ready to um to trigger a call for adoption in this meeting but uh i think we can do that very quickly if uh if the draft is sent out to the list and people have a chance to to read it then i think a call for adoption would be appropriate uh joe what do you think i think yeah i agree"
  },
  {
    "startTime": "01:12:01",
    "text": "um the uh i think it's a fair thing to move forward with uh with the changes and hold up on the adoption of the draft until we get kind of those things a little bit more settled and and socialized in the group but i think um we're pretty uh pretty good here okay tommy all right uh yeah thank you uh so i think the order would be um because we haven't formally published the auth scheme as an id partly because it was referring to uh github prs that weren't merged so i imagine if we can merge those other pr's then i can once that's done kind of get something with the right references published send that to the list and then we can discuss and i think it sounds like the main open question that people have around that is interactive and how is that safe and when is that safe um i totally think that's what we should focus on going forward for the discussion um i want to hear to what degree people think you know fully delving into that is required before adoption or do we just kind of have a placeholder there of this is where you do it and we need to agree as a working group when it's safe thanks tommy davidskenazi davis ganazzi google um i was just had a process question for the chairs because uh i've personally read the proposal and i think it's definitely worth doing as a working group uh if"
  },
  {
    "startTime": "01:14:02",
    "text": "you're saying that we're not ready for adoption what are we looking for obviously we wouldn't decide in the room but i'm not seeing any blockers to like start the call that will trigger people to actually read it so as tommy pointed out the draft formally doesn't exist yet so there we can't actually start a call for adoption until the draft exists but i think i i think joe has more thoughts on this so i'll hand it over to him yeah and i i think also there's a little bit of an ordering dependency that we need to get the architecture draft updated before you can even update the off scheme and before you know so that the references work out and all that so i think that's kind of the the way the flow needs to be but i i could be wrong um i i would love there's a comment but i it seems like we can move forward on architecture without having all the drafts there but um i see chris in the queue i'll leave my time thanks for clarifying yeah i just want to ask a clarifying question so we can certainly merge the architecture that's fine um but uh ben also said that we could also move forward on the protocol document update um however importantly that depends on the redemption protocol document existing um uh so um in in merging that change into the protocol document sort of assumes that this this authentic this new redemption protocol uh will be a thing so um should we hold off on merging the protocol document change until there was there's been a consensus call on the authentication document or i just i'm not sure what to do does does the protocol document rely on the detai on the specific details of the"
  },
  {
    "startTime": "01:16:02",
    "text": "[Music] redemption document or is it um or is it just you you we need to have we need to say that there's this thing that's going to exist and where uh that that it's you know i mean we're going to be in a chicken and egg problem and i think i'd like to update the existing documents and like okay there's going to be some you know dependency that you know one of them is going to depend on a draft that's yet to be adopted but it seems like you could still evaluate some of the privacy protocol and you can definitely evaluate the architectural changes somewhat independently of what exactly the odd scheme is um i i think we can uh with a slight change of hand just sort of uh remove the dependency on uh in the pro the protocol document on the the redemption protocol and just say like we get this challenge uh from from space or you know from carrier pigeon whatever um that would be fine um so that would work tommy yeah i i agree with chris that we could yeah i think it'd be good to merge the protocol bits and just say maybe even just reference like for example it could be something like the mechanism described here but not normatively depend on it yet just say you know there is an issuance token type there is some challenge blob and you need to send this back somewhere but then we could always update it later to make it concrete janna i was just gonna propose that we treat at least the"
  },
  {
    "startTime": "01:18:00",
    "text": "redemption protocol on the architecture documents as one bundle so uh if you have any concerns about um dependency and so on because this is an adoption call right and ultimately unless there's a good reason to separate them out unless somebody's arguing that they ought to be separated out could we just treat it as a bundle and see where that goes first uh so to be clear are you proposing that none of these changes land until until we've had a chance to do a formal complete a formal adoption call for the authorization scheme i guess i'm suggesting that we see if there is pushback on that right like if we try to do the architecture and the um we can always split it off and say okay well we can do this piece separately if there is push back on it but it does not then we avoid the whole conversation around um dependencies and issues like that john i'd rather not try to go down the road because i mean the reason we haven't published the scheme yet is we have nothing to reference yet that's in data tracker so we'd have to come up with entirely new data tracker documents for everything all right uh joe this kind of protocol with the the attestation protocol which is um [Music] uh you know it's not specifically you know a topic of this uh you know we're not going to define the attestation protocol here but it seems like there are certain properties that it has to have be able to carry certain sorts of information and so that's something that how well have we defined that yet in the"
  },
  {
    "startTime": "01:20:01",
    "text": "architecture document chris or jenna is that uh sorry can you repeat that question we have a set of requirements for the attestation protocol no that's uh and uh we're trying to keep that as much as possible out of scope um it's a as tommy was sort of describing or john i was describing earlier um that's a that's a deployment specific uh question uh between client and trusted testers um that that will vary depending on the use case i mean but it does have the section to describe you know what in in broad strokes it does so i think right joe your point is good that it need to be clear of what the kind of minimum bar for what it does is um they can also vary depending on the specific type of issuance or deployment you're doing sometimes it's going to be higher bar and sometimes it's not going to be right okay thanks so uh in terms of of direction moving forward i want to just double check with uh with janna um do you uh do you still think a sort of two-phase uh movement here is appropriate uh or"
  },
  {
    "startTime": "01:22:03",
    "text": "uh or do you feel like we're we're probably better off trying to uh wait until until we've done a call for adoption before making any of these changes i think chris might have a plan i'm gonna let him respond okay uh sorry this is this is getting more complicated there probably needs to be so um uh here's my proposal uh we can uh we will uh with the proposals of the redemption uh the auth scheme document we'll add some text and considerations around the sort of timing attacks uh or correlation that was brought up earlier we will publish that in the data tracker it will merge the eprs outstanding against the architecture protocol documents which do cite this draft and publish new versions of both of those and then i think we can ask for an adoption call of the http authentication draft okay does anyone want to express concerns with that plan okay hearing none i think we have a path forward we have a few minutes remaining are there any other slides that the presenters wanted to cover um there are more slides um there is not enough time to go through them uh so i think we should just uh postpone that content for another time okay joe any closing thoughts not specifically i think i like this way forward and we can schedule potentially another time although i think we're getting close to the"
  },
  {
    "startTime": "01:24:03",
    "text": "um i know ietf time i guess it's still a ways away we can schedule another interim to go over additional material if that makes sense okay tommy hey um uh regarding another meeting we could probably just wait until 113 um particularly if we do the adoption call in between uh the reason i got in queue is one other thing i wanted to mention for people is that the various authors and people working on the new proposal have also been doing implementations and interop testing um so chris has a implementation i think that's open source as well on github that people could try out and test against that uses the http auth method and the issuance protocol so you can see how that looks as code i've done an implementation for [Music] ios and mac os as well that i've tested and i believe some of the others are working on that so if you're interested on trying this stuff out we can also chat on the list or in github or whatever um so just wanted to say you know we're committed to actually having running code here great okay thanks for coming everybody that concludes our meeting of the privacy pass working group we'll see you all at the next one and thank you again to matthew finkel for being our notetaker uh thanks"
  },
  {
    "startTime": "01:26:17",
    "text": "you"
  }
]
