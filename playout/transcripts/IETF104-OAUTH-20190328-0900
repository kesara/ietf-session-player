[
  {
    "startTime": "00:00:04",
    "text": "and this is supposed to be able to feel peace QPS I know about your BBS but you know it\u0027s my sister is supposed to be talking about money make you much more in understand and it\u0027s it\u0027s related but I think it doesn\u0027t really depend on yeah state court send it again it\u0027s okay yeah yes okay okay good morning everyone welcome to the second session "
  },
  {
    "startTime": "00:03:06",
    "text": "yeah Omani Mike let\u0027s go going so this is or not well um this slide covers covers our conduct and any IP no it still so so make sure to to be aware of this and if this is your first time seeing this please see sure to read it okay next so we have a job bribe Ludwick thank you for that we have note taker Tony again thank you anybody okay hey thanks thanks Tony mmm and Mark is busy okay um so here\u0027s our agenda okay okay so a we will probably shuffle this agenda during the meeting there was a request for a late request for something right five to ten minutes but to see so it will start with the with harness to talk about the author workshop update and then Aaron will talk about that browser-based app harness maybe take lift at less than 10 min 30 minutes to talk about peop m and the Torsen will talk about MPLS and I I will finish it with that a quick talk about a nested day chart so some of you attended their own security workshop and stood out last "
  },
  {
    "startTime": "00:06:07",
    "text": "week and others didn\u0027t unfortunately we had a very good event um I will give you a short summary of what we did and where you can find the material in this small so this is obviously the webpage I post I posted a link to this one to the mailing list we had record participation we actually had to close the registration in some point in time because the meeting rooms only are the meeting rooms had a limit and of course having discussions awesome makes it more difficult with hundred people we had we for the first time we organized it in a way that we had tutorials we had the regular talks we had a nun come from stylists Asian we also invited the keynote speaker the tutorials focused on two aspects formal methods or the use of formal methods in this case tamarine for protocol verification and basically was a hands-on tutorials so you can find the slides there and I I believe the slide also contains a pointer to the virtual machine so you can get the environment set up and running if you if you go into this the other one was a hands-on tutorial on the use of access control with ours in in in a sort of cloud context we then had a wide range of talks and here\u0027s the full program and since some of the participants were newer dude - also at least to this type of event we there were introductory talks as well Mike talked about open ID doesn\u0027t give a good summary about what\u0027s going on in the our security PCP and so on we also had then the unconference where participants could pick the topic that they\u0027d like particularly we we did a show of hands on who is interested in what and divided up the groups so you can those obviously worth there were no slides for those but and and what she also no notes but still so you can get an idea about people cared about and then uh the keynote speak speaker dr. John Monaco talked about cross-site scripting attacks and how to prevent them and it was a very detailed arc I would say the slides are also uploaded so they can look at it even if you know cross-site scripting attacks going through there order different mitigation techniques and the libraries that he recommends I think is a very valuable resource that did the recording of some of the talks and I\u0027ve asked him to send me the recordings and so that we can upload them but that hasn\u0027t happened yet so I hope this will be available at some point in time so you can actually get a good idea what\u0027s going on so take "
  },
  {
    "startTime": "00:09:08",
    "text": "a look at the the slice there\u0027s some some really good stuff in there okay thanks honest I think he earn ready it\u0027s perfect go ahead Thanks hi I\u0027m Erin perky I\u0027m sorry I couldn\u0027t make the security workshop last week but I\u0027m glad David was there to talk about this draft there I am yeah I want to give a quick update on the browser-based Apps recommendation that we\u0027ve been working on and kind of talk about where we\u0027re at with it and then also there\u0027s a bunch of open questions that I have on it that I want to talk about especially based on some of the recent changes to the security DCP so perfect look at that so the high-level overview of this of this draft is that it provides specific recommendations for people building browser-based apps and the definition of browser-based apps in this case is an application that is written entirely in JavaScript there\u0027s running in a browser context that does not have its own back-end since you have a back-end before it then you kind of get into a different world and you can do you know real real ooofff of provision secrets and things like that so the sort of quick overview of the points of the spec recommends is that it requires the browser-based apps do the authorization code flow with pixee and it explicitly disallows returning access tokens in the front channel which effectively is saying don\u0027t do the implicit flow and there is a point in there that says that it these apps have to use the state parameter for CSRF prevention and requiring exact match of redirect URL registration and that browser-based app should not get refresh tokens so all these things were things we talked about at the identity workshop in October and kind of brainstorm some ideas around like what do people currently recommend for these kinds of apps and this was listed we came up with and I\u0027ve you know digested that and turn it into this into this document so some of these I think are now "
  },
  {
    "startTime": "00:12:08",
    "text": "as the security BCP has been progressing some of these things I think we need to reevaluate so some of the high-level questions that I have for this draft um should so I had originally envisioned this app would be or the spec would be talking about specifically pure JavaScript apps running in a browser with no back-end component and as we\u0027ve been talking about this and progressing the document you know some people have chimed in and said well there is you know there are other architectures you are billing effectively single page apps that do have a back-end component even if it\u0027s just sort of to manage you know proxying api calls to other back-end AP is or something so one of the questions here is should this scope of this document explicitly include those and if that\u0027s the case I think Annie\u0027s little bit of restructuring of how the the document is laid out or should it be limited to just the pure JavaScript app case with so with the the recent point we brought up in the security BCP of yeah the question toastin do you want to stand up and yeah once i\u0027ve got questions alright i just threw the questions and then we can um yeah why don\u0027t we we have we have time here so why don\u0027t we just go in order I have these three and I have like four that are like really specific questions on the next page and those are the questions I want to talk about here so yeah if you want to jump in tony nedelin so are you ruling out it\u0027s hard to tell here after reading the paper and stuff if you\u0027re ruling of just pure JavaScript apps not under a browser so not under a browser yeah there\u0027s in environments devices and things that run pure Java so sure so I\u0027m trying to determine if you\u0027re ruling those out of this thing or not sure yeah this is so this is meant to be recommendations for apps running in a browser which right now mostly are written in JavaScript that is probably not always going to be true so this is not a JavaScript recommendation this is a browser-based environment recommendation so yeah I would say that like JavaScript apps that are running in non browser-based environments don\u0027t fall under this because those are just they have their own considerations like some of those might be considered native apps yeah okay thanks toast little test would come to remarks first of all we shouldn\u0027t really narrow that to only JavaScript apps you already mentioned that I mean basically we are talking about our apps that are running in a user agent in a specific specific characteristics of that environment because you don\u0027t have a direct access to for example certificates can do empty "
  },
  {
    "startTime": "00:15:09",
    "text": "or less and all that stuff it doesn\u0027t matter whether this javascript or any other language that\u0027s that\u0027s that\u0027s being used there first and second um I\u0027m not quite sure whether that really makes sense to narrow the scope down that much as you have done I mean I already commented on a comment on your draft I personally haven\u0027t seen a pure s.p.a in the wild in my professional career yeah I mean I might be the only one but from my perspective this is an academic concept as as soon as you go multi-user you saw them how need to have a shared state among your instances and if you have a shared state among you among your instances I I don\u0027t think you will directly exposed to database to the JavaScript app so we will have come some kind of some kind of back-end component if I take a look under standard environment such as spring in combination with nodes yes or something like that there are plenty of templates that you just instantiate and they give you an angular front end and a spring back end and that\u0027s a default architecture I\u0027m familiar with in our environment so I think this scope is too narrow we should broaden it up and it also gives us more architectural options how to really protect this kind of SP ice of course so thanks so my question on that is in an environment where you have a single page app front-end with a spring back-end or something like that are there enough recommendations in the existing documents that cover that deployment scenario or the things about that scenario that are unique that should be described by this document I mean obviously if you if you have a back-end then you couldn\u0027t can for example move all the off code to the backend and just tie the session why an HTTP only original restricted cookie to that particular back-end so yeah so and a lot of a lot of a lot of issues that we are talking about or going away and in particular I don\u0027t think it\u0027s a good idea to manage any kind of security relevant data in the front end because the user has access to that data and can modify it yes I agree so might so my question is is that already described by the security BCP and like the regular you know core OAuth or okay okay I misunderstood use questions sorry no it\u0027s not because the security PCP is intended to be generic as generic as possible and we haven\u0027t included any recommendations for for example SPS or native apps because we\u0027re native apps we have the native app the PCP and 4s paas yeah we have this SP a BCP so for example recommendations on the use of course although we have discussed about that so then you\u0027ll discussed about that with neo Madden from Fort Rock on the under list we haven\u0027t included that and the security PCP because it\u0027s obviously specific to apps running in the browser and we didn\u0027t want to put that all into the security PCP okay cool thanks "
  },
  {
    "startTime": "00:18:13",
    "text": "Ludwick sites relating a comment from Justin from jabber we should mention things like a stay with proxy backed apps and generally put them out of scope specifically this draft should only deal with things that see that off tokens inside the browser but we can\u0027t ignore that people follow other patterns and we want to steer them in the right direction and namely those should usually use cookies between the browser and the backend and not off in the browser Thanks okay so that\u0027s a that\u0027s the completely opposite opinion here so that that\u0027s sort of what I wanted to discuss so Justin\u0027s saying we should this document should only cover cases where the browser has the access token and is really a pure the browser is the one doing the OAuth flow so that\u0027s kind of where we\u0027re I\u0027m like where where where should we fall with this so John Bradley yubico if I understand Justin correctly and even might my opinion the I mean these apps in the browser aren\u0027t want just one thing or the other they may have a back-end but they may also be using OAuth tokens in the browser so just because the app has a back-end doesn\u0027t mean that if it\u0027s getting and using weilding auth tokens directly that this BCP shouldn\u0027t apply to it so this should apply to any app that\u0027s using OAuth directly with OAuth tokens managing those OAuth tokens in the browser yes a different pattern which Torsten is legitimately recommending is you could move all of your OAuth to your back-end but some people may choose not to do that for a number of reasons so we can say for apps that choose not to move all of their stuff to a back-end all of their OAuth calls to a back-end server this is how you protect the oh-ah functionality that you\u0027re going to keep in the single page app so this is about apps that do OAuth in the browser not not excluding apps that may have a back-end okay yeah that yeah I think that\u0027s a good distinction there and we don\u0027t want to we don\u0027t ongoing oh I have a back-end so I don\u0027t have to pay attention to all of this right great this Olaf advice even though I\u0027m actually doing oh ah having a back-end doesn\u0027t necessarily help you unless you\u0027re actually doing all of your OAuth through it Tosun again I think there are two ways to or two kinds of Olaf in the browser one or often the browser means you have an application that\u0027s heaven that hasn\u0027t a user interface that\u0027s running in the browser and is user interface amar "
  },
  {
    "startTime": "00:21:15",
    "text": "interacts with the OAuth authorization server so it somehow initiates authorization requests and it receives authorization responses how those responses are being processed doesn\u0027t matter I mean in the native PCP we don\u0027t exactly describe how the front of a native app and potentially the backend are interacting with each other and what the boundary is between them for good reasons because we don\u0027t care it\u0027s up to the software developer to design that and that\u0027s one one one way you can look into that yeah an SP a from my perspective is just another user interface for an application and the internal application architecture is a completely different thing so it has to receive an authorization request the important point and that\u0027s where it comes to the second view on Olaf in a browser is just the front end that\u0027s running in the browser also process the authorization response which is just one of two options right the user interface can just pass the code or whatever no it\u0027s it\u0027s it\u0027s supposed to be the code to the backend or it can just directly call the authorization server a read email access token those are different options right and from my perspective we should discuss both it\u0027s both Oh off in the browser right yeah thanks yeah excites again relaying just in from jabber Torsten and I don\u0027t actually disagree I think I\u0027m saying talk about it and put it into the right scope not covering it and not mentioning it not covering it and not mention it at all or two different things I think we should mention it and not cover it like what John\u0027s saying okay so so so what I\u0027m hearing is the particular architecture of your browser based app is not necessarily the important distinction here it\u0027s whether or not the browser and the job and the JavaScript or whatever code is running in the browser is at all actually involved in the Roth flow either initiating it or redeeming a code or handling an access token and that should be the scope and then we just we describe the different architectures within that okay that\u0027s that\u0027s um that is great I would and any other points on that so I do want to get to some of the other questions here I think that\u0027s very helpful though thanks for the input there okay so with the sort of the high-level scope question out of the way I wanted to get into some of the more particular details of this especially as they relate to the security BCP as that has been evolving as well so I know that one of the recent changes that was discussed this week was that the security PCP is now gonna say that pixie should be used for the CSRF "
  },
  {
    "startTime": "00:24:16",
    "text": "protection and that freeing up the state value to be used for application state alone that is not currently that\u0027s actually not allowed in this as this is written because this actually says specifically used the state for CSRF protection should this follow suit I\u0027m kind of inclined to say yes unless there\u0027s a particular reason that Java C based environment is different daang effect yes calm yes we should do that okay yeah my instinct was to just follow follow suit but I wanted to just throw it out there in case anybody else has some other information and along those tolson yes welcome as well we just haven\u0027t talked about it I\u0027ve talked about that so we haven\u0027t really come to a conclusion because that the chairs first one a send send a posting to the list to get get a failing on a sense of the working group but they they were had the trouble tremendous positive feedback so we will be gonna update security BCP but that\u0027s not in there yet but if your fellow follow suit that\u0027s perfect that\u0027s an important point I guess along along that line should we roll in the change to this with that same request goes out to the list for feedback since they\u0027re very related so I\u0027m telling you nedelin we we have lots of apps that we have to crawl through to make sure that it\u0027s not gonna break anything so it\u0027s not just a quick decision we have to we\u0027ve got 45 thousand apps or so so we\u0027ve gotta make sure they wind up in this particular space so we\u0027ll have to figure some stuff out my understanding of that of that change is not that it\u0027s going to break any existing implementations it\u0027s just saying that you can use state we don\u0027t boil them we don\u0027t know if it will break yet so I mean well well if you are using say for CSS reproduction there\u0027s no reason to change that it\u0027s just that if you are not doing it right now then you will now be compliant with it as long as you\u0027re doing pixie so yeah further to that state will continue to be opaque to the server nothing it\u0027s an option for a client to not to use pixie instead of state every application currently using state the two percent that actually correctly use state for CSRF protection will continue to work properly and the rest will continue to be broken phillips koknal zero the security PCP also talks about using favoring as 256 over what had a plain one so we must make sure that the JavaScript applications do not actually or do have the necessary resources to calculate though that\u0027s probably literally on my next fight that was all my questions Laura\u0027s perfect yeah hey and about back when AWS um you should have brought this "
  },
  {
    "startTime": "00:27:18",
    "text": "up the other day with the pixie change but if we do go forward with the change to recommend using pixie for CSRF in that state I think we will want to include some note to the effect that this does not necessarily mean that state itself should not be CSRF protected or somehow bound to the user agent or otherwise protected but that that is purely up to the implementer or the client to decide depending on what they\u0027re putting in state but I think it would be risky to imply that state does not need to be protected in this fashion so I guess how this relates to the browser-based dock question is if the security BCP is gonna go forward this plan is there anything unique to the browser-based environment that we need to mention in this or can I basically just remove all mention of state because it\u0027s already covered by the security BCP now I don\u0027t want to try and answer that in five seconds yeah sure but that\u0027s why that\u0027s why it wasn\u0027t chosen again my proposal just let us discuss through all those topics so pixie and and and and then it depicts the mode and so on come to a conclusion I\u0027m totally agree with Tony we first have to do our analysis and as Philippe pointed out we have also to check whether the chart will not a 56 mode also works for all kinds of applications so I think we have to sort it out and then we documented in the PCP and we can we can write it up in the PCP so that other app-specific ECP\u0027s can just refer to the recommendation section I think that would be the most effective efficient way to to integrate those I want to add to learn this remark I think it\u0027s good to look at their existing apps and to see how many of them comply with the recommendations we are making here but it\u0027s also as we discussed in other contexts the best current practice document is supposed to illustrate the best current practice it\u0027s not less Lia what we do today there may be actually a disconnect between what we recommend going forward as sort of a kind of a missionary at least to a certain extent not like this a fine line between sort of trying to steer the community in the right direction versus being overly ambitious unrealistic potentially so we to keep that in mind this part but if you guys look at your stuff your installed base and and see what works for you today and what complies that would obviously be very useful information so yeah along along these lines the last point here is is there anything else that\u0027s being described by the security BCD that either does work or does not work easily in a browser environment that we need to handle "
  },
  {
    "startTime": "00:30:18",
    "text": "differently er and that\u0027s to think of a question to answer right now but I thought that\u0027s kind of what I\u0027m thinking about how this document fits into the rest of the ecosystem so that\u0027s something I would like everybody else to keep in mind as we\u0027re working through this and I think we should probably have more these discussions on the list offline since they\u0027re kind of bigger questions but that\u0027s what I\u0027m looking for of like in the security PCP is it saying anything that is like too hard to you to do in a browser that we need to address differently or is it is it saying stuff that that we should make sure you do in a browser the where the security PC teammates maybe he says it\u0027s optional things like that so with the remaining time I have a couple of specific questions which I would love some feedback on from people who have experience here so let\u0027s just go through these really quick and I think this will Polly take us to the end of this segment there was a there was a in the original discussion of this back in October when we were white boarding it out at iiw I took picture the whiteboard and then it was there and I was trying to figure if this came from but there was an idea that there should be an option for browser-based apps to do hostname only white listing of the reader at URL and I had that like that\u0027s written up on the white board and I can\u0027t remember who said it or where that motivation came from because that is not exact match redirect URL matching and I don\u0027t remember why that\u0027s there but now it\u0027s in the document and I want to see if anybody has any recollection of or any experience with the deployment scenario where they\u0027re doing a browser-based app environment and matching only on the hostname of the reader at URL to sort of allow like a pseudo wildcard redirect URL that seemed that throws up red flags to me because everything else about OAuth says you should do exactly direct URL matching but there was something about the browser-based environment and JavaScript environment that suggested this was an option and I would love to remove that if that that sort of exception here if there isn\u0027t a good reason to have it says anybody off top of their head have any scenario where you would want to allow a sort of wild card match on the radar to go with matches only the host name and about back when AWS um not exactly but thinking about the problem where you often seen clients want this sort of feature is where they want to be able to get back to whatever context they were at within the app so you know in the case where you have a not necessarily a single page application that\u0027s still possible doing everything in the browser I mean usually the way we we tell people to do that is have a single redirect URL endpoint that extracts from state where "
  },
  {
    "startTime": "00:33:19",
    "text": "you\u0027re supposed to go back to that\u0027s so possible in the browser but it does mean having to push more of that logic you know into JavaScript and so we have to think about how does that work what libraries are available to support that in a secure fashion just doesn\u0027t assume I mean we have to change our guidance here but there\u0027s probably room for giving some examples or some some guidance on how do you address these issues maybe this is something that should really be in the security BCP I don\u0027t know but that I think this is an area where the specs have been a little bit weak and as far as pointing people in the right direction sites again relating Justin from jabber I don\u0027t remember someone saying that in this session but I think they\u0027re wrong I would guess that\u0027s my own editorial comment I would guess if someone said it I think they\u0027re wrong was what you wanted to say I\u0027m gonna raise Justin and they\u0027re definitely wrong but I agree with Annabel we have to give I mean again we get back to state and people misusing it or not understanding what it\u0027s for so providing advice either in the BCP the security BCP or this BCP about actually not just whacking on query parameters because they\u0027re convenient which is the way that people traditionally maintain state inoue but put put it in the in the state parameter and also discuss integrity protecting the state parameter because there are possible attacks if you allow people to start injecting state into your app interesting things that are hard to analyze may happen so there\u0027s a probably some advice that we generally want to give about state if I think about it well I mean there is I mean separate from my sign state draft I mean that might be a way to do it but we should probably generally mention that these are the the things that could go wrong with state and why you might want to integrity protect it or properly do CSRF Tosun just clarifying question you\u0027re proposing to add something about that to the security PCP yeah I think the misuse if we\u0027re gonna talk about moving CSRF into pixie there are other things that can go horribly wrong with state so we should at least mention them and mention that this getting the the user back to "
  },
  {
    "startTime": "00:36:19",
    "text": "the right point in the app is really what stage is actually supposed to be used for so we can mention that that\u0027s uh that\u0027s the way that you should do it and shouldn\u0027t just allow wildcard redirects annabelle back them again I will go step further and say we should actually think about revisiting like a sign or state as a job kind of specification instead of just punching this problem to the client actually give them a potential solution that covers as much of the basis as can be generalized I\u0027m okay with reactivating and allowing the workgroup to add whatever it wants the sign state draft I\u0027m not sure if we\u0027ve actually adopted as a working group item but there is a draft there that\u0027s been kicking around for years that some people use Daniel Fett I just like to highlight that if you use pixie then you also get some integrity protection for state if your is is trustworthy well if state is opaque to the a s so it could be modified at any other point or potentially injected so just because you\u0027re using you can\u0027t inject it because if you check the pixie verifier then the you I was not injected if you assume that to hold you I must be injected I\u0027m not assuming that the whole you are I would necessarily need to be a but let\u0027s postpone that das can inject it let\u0027s that seems like a different it doesn\u0027t again I took notes are we created issues for the security PCP we\u0027re gonna work on thank you thank you thanks um okay I - - quick quick ones so like I can mentioned earlier one question is if we\u0027re gonna require pixie is s 256 reasonable to require in a browser and are there good enough JavaScript libraries for it and/or is is there like a browser library that can do these these hashes now or do we need to allow plane in in the browser-based app scenario for a while even if it\u0027s not necessarily the best practice does anybody have experience on that front Mike Jones web crypto is pretty commonly deployed now yeah plus one to us or it is a flip spoken of zero web crypto is there widely supported the only problem is that it is promise based even for chars even for hashes so if you\u0027re gonna do anything like a pop up mode where you want to open a new window to do the authorization then sin then you might run into issues where you "
  },
  {
    "startTime": "00:39:21",
    "text": "can\u0027t open the the actual window after the promise has been resolved interesting so you need to calculate the hedge before you actually you haven\u0027t you need to have it ready at the time the user presses a button it\u0027s a it\u0027s a gotcha but it\u0027s possible it\u0027s just a yeah I think there\u0027s workarounds for that there are a lot of other problems that you run into trying to deploy a pop-up based speaking from experience trying to deploy a pop-up based both experience that I don\u0027t think it\u0027s I don\u0027t think it makes sense for us to restrict our guidance based on that particular use case great so it seems it seems I\u0027m getting a sense there\u0027s it\u0027s probably fine to to require a shock to be six hash the last question I had with the one minute left okay the last point I want to talk about was about passwords I know there\u0027s been some more talk about that lately as well the right now the browser the browser app spec does specifically say that you should either do auth code and pixie or use the password grant for JavaScript apps and I would for many reasons like to avoid recommending the password grant at all so I\u0027m wondering what we can do on that front so any any thoughts um well gonna surprise people by saying we should get rid of the password grant especially in browsers the one plot possible justification for the password grant is oh but what if I don\u0027t have a browser I think that argument really doesn\u0027t hold up when it\u0027s a browser based app the ya know that the argument I hear is they they is that people don\u0027t want to deal with the redirect loop or you know pop-ups or that kind of thing so Zuba sites for justin again he wants us to burn it to Austin +1 to both and I also would like to add there also functional reason why I think the password grant is just legislature that iw know federated identity you know if two-factor authentication so this discussion typically is much too limited so we should get rid of it so in the as the Burnet get rid of it option does that mean the browser-based app should not mention it or explicitly say don\u0027t do it toast Ligon as you have seen this is one of the of the open issues we will be working on in security PCP so if this if the SP a BCP just follows the recommendation of the security BCP i "
  },
  {
    "startTime": "00:42:21",
    "text": "think once we discourage use of the password grant you no longer need to to really mention that unless you really want to but i don\u0027t see a real need for that Anabelle back when again this correct this might be able to go further than the security BCP in that the use case that was mentioned the rationale behind password the password grant is wanting to avoid redirects and whatnot there are other ways to do that if you\u0027re already in a browser environment that normally we would recommend against things like embedded iframes that if you are going to accept this curity world of collecting passwords on this other set the site then the concerns around embedding an iframe there embedding your your sign-in experience in an iframe on that page don\u0027t really register like if you\u0027re accepting one you\u0027re gonna accept the other so it\u0027s really at that point no reason to need to have the password grant so even if even if the security BCP says not recommended we might consider a must not here thanks for the benefit of Tony I don\u0027t know how it was a lot of discussion you want to summarize briefly what you took away from diverse discussion here for these questions and for yet yeah for a future update yeah so um I\u0027m gonna let me go back here try to summarize what we just talked about so I know what I\u0027m walking away with the scope of this document will be any app running in a browser in a browser base with browser based execution that is involved in the OAuth flow whether or not it has a back-end component at all yeah both cases will cover both cases and will mention both explicitly as different deployment scenarios and I think I\u0027m gonna have to reorganize how this document is laid out in order to better present that as the scope but I can deal with that later the we are gonna continue talking about the pixi issue in the security PCP context I\u0027m gonna leave that alone in this document for now and then probably adjust this to match whatever this outcome of the security PCP discussion is I\u0027m not gonna change anything in this document with that right now the I think that the outcome of the of the first point here was that there\u0027s no there isn\u0027t really any valid reason to to allow exceptions to the exact match matching and redirect URLs so I\u0027m gonna "
  },
  {
    "startTime": "00:45:22",
    "text": "take out that recommendation or that suggestion from this document and just it\u0027s you have to do exact matching like every other app and s-76 is fine so I\u0027m not going to mention the algorithms here because the security visa fee already mentions that and around passwords it sounds like the the consensus here is to not allow passwords in JavaScript apps and we should probably continue that discussion on the list for a little bit but the direction we\u0027re going to move there is hopefully to explicitly disallow passwords house we grant from JavaScript apps even if the security BCP doesn\u0027t necessarily go that far with that recommendation that it like every anything else I forgot great thank you thank you very much what was a great discussion okay okay honest with me Opie keep it fairly short test yes so I shipped a draft update before the IDF meeting or six and actually I was working with Mike yesterday to fold in some of the comments were posted to the list by Jim\u0027s my manga and had a version oh seven published too to summarize so we had the BOP talked usage for HTTP specified in OS working group but the coop based version or potentially for other IOT related security protocols in age working group we had a lot of back and forth which luckily came to an end in terms of aligning it - thanks a lot big for that so but of course they can be combined both of them can be combined this world so you can use the HTTP based interface to each to obtain a access token in a aw in a CWT format then pass it along on some co-op based protocol as well um that\u0027s good so we had in in this document OS working group document we separated out with an earlier version we separated out the functionality of requesting and "
  },
  {
    "startTime": "00:48:24",
    "text": "obtaining that pop based information and in everything related to the DoCoMo\u0027s in this document but the resource indicator aspect were separated out into a separate document that you I\u0027m sure you recall the discussion the document is currently in the is G so that\u0027s that\u0027s great Luke has written another document the azores parameters which describe the parameter encoding for in coop for the parameters that are also listed in here so that\u0027s that\u0027s pretty good there\u0027s one thing I wanted to point out which is also in the latest version included in the reference that we actually have in absolutely awry in the resource indicator on sort of in the resource barometer and a logical name in the audience barometer which are separated out in two different documents so I included their preference because that was created some coefficient and Elizabeth when I posted the version right before the IDF meeting which was really only an update to take some of the most recent developments into account and I then got this review so a couple of copy and paste errors which we fixed and a couple of additional notes we added so this was fixed with version or seven so I think where we are with this document right now is um I think it\u0027s ready for working group last call unless you think anybody has any disagreement just in just one question why we\u0027re working we\u0027re working on the depop draft that you\u0027re gonna gonna get to know in this session I realize that deep up just indicates the public key or sense the public key that it wants to bind to token to to the ass without any proof of possession that\u0027s correct that\u0027s one that\u0027s what we talked about that depo does it but not not completing distribution that\u0027s this I mean this is this is about working but the key to the bureau right it should allow that option to it actually should allow posts options because we rely on it should what that means both options to just send the public key from the client to the AES and to be habit included in the in the access token is that what you asked no I\u0027m asking for a proof of possession so the client also demonstrates that it has control or possession of the private key corresponding of the public key in it once the access tokens will be bound to yeah we unlike we identify that it\u0027s is a need for deep op yeah "
  },
  {
    "startTime": "00:51:25",
    "text": "my question is have you analyzed the security implications because someone could potentially inject the public key or something like that and and just make the access token to be bound to a completely different key pair so have you analyzed the security implications I mean we could also simplify depop if it turns out yeah there\u0027s an even out we didn\u0027t for the OS case for the eight of us case but we probably should dig this up and double check it make sure that it\u0027s actually correct ludwig cites as himself in ace will require public keys or yeah public keys that proof of procession for a public key that the client requests the yes to include in a token and honestly i would like to hear a very good scenario for where we would want not to do that and off because why should we let someone inject the public key in a token when we don\u0027t know whether he\u0027s in control of it or not well how do we how do we do that in ace in ace we require the secure connection between the client and the yes to use that public key it\u0027s science client authentication so basically if you do like the detail s with the raw public key you should use the key that you\u0027re planning to ask the AES to include in you know double check that because I don\u0027t think there\u0027s text in there which says that the key that you include in the token is actually the key that you used in for client authentication to the a s so it sounds like we need to do a review that there may be some implicit assumptions in ace that may not have been carried over into a walk in looking at this over the last week Torsten and and the rest of us feel strongly that in order to register a key to be used as proof of possession you must demonstrate that you actually control the private key is part of that message exchange so did that and as Torsten points out that isn\u0027t actually a requirement at pop key distribution then Caidic first john thank you for saying that but totally agree I came up to the mic because of this comment about the public key that you\u0027re using in the DTLS handshake being expected to be the key that is in the token and that seems kind of questionable from the cryptographic standpoint in terms of using the same key in different scenarios well but also later from the communication to the resource server the even if if MPLS when we find the token we have the key that we use in in TLS it\u0027s the one that is bound to the token so in that sense that would follow a very much a similar pattern used already "
  },
  {
    "startTime": "00:54:27",
    "text": "in other documents but probably we have no I don\u0027t think that we discussed this you know we should probably look into it and talk about moral illness I\u0027m toasting um yeah that\u0027s the way the M TLS works and we also had a discussion in Bangkok whether we would like to add in other parameter and allow the client to request token binding to a different public key and we decided to not go that way because I don\u0027t typically used to say it it opens a can of worms and the convinced ants so we are relying on the under under on the proof of possession that\u0027s being provided by the client authentication I think that would make sense for pop P I forgot the name key distribution as well yeah okay so John Bradley again so the so I understand Benjamin\u0027s concern and agree with it so if your so it depends on the proof method that you\u0027re using to the resource if the proof method is perhaps signing an object but you\u0027re proving possession over mutual TLS then those are kind of two different uses of the key and would be considered different in my mind to the in the mutual TLS draft were using mutual TLS client authentication to establish the key and to prove the key so in that\u0027s kind of a special case where you\u0027re guaranteed not to have different different uses of the same same key but in a more generalized case if I was wanting to do TLS to the token endpoint but have a different signing key then arguably I may want to have different protections because there are different security concerns around I protect a TLS key versus a signing key they might be in completely different infrastructure etc and it might be a really bad idea to reuse the same key well we can analyze it because we have the Dameron model for for the for this sort of scenario so I would look what but that makes any difference ludovic sites relaying Justin from jabber again this draft is only a half solution it doesn\u0027t do us any good without a presentation mechanism like HTTP signing off that this group has never had an appetite for apart from Mike\u0027s recent review thanks for that I disagree now if the mechanisms developed in ace it\u0027s actually this is a model that we have now in one of our products and about backman AWS um I think requiring "
  },
  {
    "startTime": "00:57:28",
    "text": "proof of possession makes sense I argue strongly against coupling that to the TLS layer one of the knocks against mutual TLS and some scenarios using that for a client authentication or even TLS token binding is the fact that it blurs the layer boundaries and that turns out to be quite complicated in distributed systems and non-trivial cloud environments where you potentially got very disparate systems involved in each of those layers and sharing keys across both of them is complicated to say the least and potentially inadvisable I\u0027d say if we don\u0027t have a strong reason for requiring implementers to cross that boundary then then we should stay away from that so I I hear that a couple of investigations we have to do perform an analysis to see I think some of that feedback feedback into account so we do that just to clarify there\u0027s like there seems like there\u0027s two different concerns one is the security implications of using that key in multiple ways the other is the technical challenges for deployment and implementation in some scenario Ludwik sites but they I seem to understand that we all agreed that a proof of procession for a key that you\u0027re requesting to use as a pop key is a good idea or is anyone disagreeing with that we still wanted to sort of it sounds like a gut feeling I think we can still do a formal analysis of this right so I think that as a matter of first principles proving that you control the private key for a public key that you\u0027re registering is a good idea to be part of an atomic transaction whether you prove that where it gets gray is if you\u0027re using TLS to prove possession of the private key that you then intend to use at some other application layer etc that you Annabelle and other people\u0027s minds that\u0027s where it gets a bit slippery using what a proof from one layer at a different layer so that\u0027s what we need to look at it\u0027s not that we don\u0027t want it and we don\u0027t I think everyone thinks that yes providing a proof is important perhaps required it\u0027s how the debate is around how you provide that proof and whether or not work the boundaries but I still think it\u0027s um we should go more to a mode of where we actually have some hard data to back up our arguments rather than gut feelings on what is seems good or not I\u0027m well known for going with that feelings but I "
  },
  {
    "startTime": "01:00:28",
    "text": "understand your argument just to finesse what I think I heard Roman Jenaya is it sounds like we want to do the pop the question is do we have confidence in the proposed kind of approach and there were kind of some Pope\u0027s and hey let\u0027s kind of talk about where I have some concerns with my confidence in that Dave Robin I understand the security implications of saying that I want you to sign it with that guy\u0027s public key but I don\u0027t control that public key however that is a legitimate scenario of where that thing is deeply embedded device and I am a sophisticated device and I\u0027m getting access tokens on his behalf but I don\u0027t actually control any of the credentials that he has I don\u0027t control these private key I need you to make a token and give it to him I need to give it to it because I have a back channel to him and you don\u0027t so there\u0027s no introspection possibility anyway it\u0027s just it\u0027s a scenario but I don\u0027t want to completely discount that I have some sort of big sophisticated thing that\u0027s that\u0027s getting access tokens on behalf of deeply embedded products and jamming them down in there and I can\u0027t prove that I have is private key but I need you to bind it to his public key toast just as a reflection if you\u0027ve got it if you got a back-channel sorry if you\u0027ve got a back channel to this not so sophisticated device it could also create a proof of possession for you for actually sending the authorization request so it\u0027s not really precluded if just as an idea right what I would like to say is that as an observation in M TLS and also token binding we always enforce the client to really demonstrate proof of possession before the binder k2 meter feels like a design pattern or design principle and my feeling is we should follow that principle except we a really good reason to have more flexibility I was arguing draw boards yeah let\u0027s let\u0027s build into this flexibility into em TLS because that would allow in exactly this kind of scenario that someone gets a token for someone else but you really need to understand the security implications so quick comment on your statement there it might be that the back channel is not readily available you might I mean if you want to do a proof of possession you need to kind of knowns from the AAS and if your back channel involves going to the device and plugging into it or something then that\u0027s not a good option just clarification you store it you walk to it you plug in and you send it comment from Justin isn\u0027t that enabling and man-in-the-middle that we can\u0027t "
  },
  {
    "startTime": "01:03:28",
    "text": "prove and do we want to do that Anabelle again i kind of to that point i think we want to consider what use cases we\u0027re trying to optimize for here i think the the the one just described is that there\u0027s a you know a valid use case there but it\u0027s also nuanced enough and has enough unique characteristics that it may be worth treating that separately in tackling that that scenario separately from the more general case where this we can make some sort narrower assumptions I agree entirely with drawing like helmets this is an ace issue this is you know deeply embedded offline you can\u0027t go get the proof of possession because my back channel is not up you know it\u0027s I got it yesterday I\u0027m getting the token today I\u0027m going to give it tomorrow so but that that\u0027s an ace issue I think so okay so in any case I\u0027m good feedback so a little bit of homework to do in this case so I guess that answer the question mark here after the working class part good good discussion thanks Torsten you drive thank you very much so good morning again Joslin yes come get the pleasure an honor to present the current status of MPLS on behalf of Brian Kemp Oh Brian you\u0027re supposed to enjoy your holiday right now all right once what has what is what is MTL is all about I mean we\u0027ve heard about MPLS in Indy and the comment in the last couple of minutes I\u0027m TLS is a mechanism that utilizes TLS client authentication for two different use cases one is the authentication of the client or boards das and the second one is to use the key materia to bind the issued tokens to the private key that\u0027s being used for the TLS connection on the client side so basically it\u0027s an alternative to token binding and something we will see later on all right uh what happened since Bangkok first of all there was an ad review and there was a discussion mainly around subject alternative names to be "
  },
  {
    "startTime": "01:06:30",
    "text": "included in the PGI mode and a discussion about how we make sure that for example s pas or yeah applications that run in the browser don\u0027t really collide with the way our client certificates are being managed or are being exposed in the user agent so let me go into the details as requested by Acker Brian included a abstract protocol description into the introduction of the document to make reviewers or to make it easier for reviewers to understand what we are doing in MPLS there were also new meta data edit so now it\u0027s possible for a client to register more than the subject DN to being identified based on the data in the certificate so there are a couple of new options one of them is the email address one is the IP address one is the URI that\u0027s based on a request being done by a representative of a let me put it that way a micro service management framework so it\u0027s more being meant to use in that kind of environment and then as I mentioned there was a discussion about MPLS and browser based apps I think Philippe raised that raised that question thanks a lot for that because as he pointed out when you want to use MPLS in a browser-based application it will be experiencing the sometimes really awkward user experience that the user applies when the Wendy when the TLS enable end point asks the user to present certificates our recommendation for MTL is to set up the token endpoint for example in a mode that optionally supports TLS client authentication so the client may decide whether it\u0027s gonna use client authentication as a method or any other method the problem is in user agents or in in that environment the the server anyway sends a first message and asks the user for the certificates and in native apps and other apps this is just suppressed whereas in a browser this typically will pop up a dialog asking the user in some circumstances what certificate to use for that particular connection and it\u0027s really bad because the certificates we\u0027re gonna use for EM TLS are device application bound certificates that have nothing to do with the user identity so the user is not really aware of the existence of those certificates and that\u0027s okay so since there is no way to control that from within the app the solution being proposed and also documented right now in the draft is that the AAS can maintain one set of TLS and points that are configured to support client authentication so they are empty LS ready "
  },
  {
    "startTime": "01:09:32",
    "text": "and another set of endpoints that do not require any kind of a TLS client authentication so any client that\u0027s not MPLS aware just uses the a as metadata obtains all the end points and and works as normal and all MTL as a where clients can use the alternative endpoints to actually pick up the process the questions being discussed on the list was more how we actually represent this kind of metadata and there were two options being proposed one was a completely alternative AAS metadata file and the other one was to include a section into the stone of metadata file called I think mmm TLS endpoint aliases and just add those endpoints to that section that are relevant for MPLS so for example the token endpoint potentially introspection and revocation Oh Mike I oh okay okay yeah and there\u0027s one where some editorial changes so for example the explanation of the confirmation introspection registration went to the I and our conservation and then there is a clarification type of a change or one could also see that as a functional extension the draft know describes how for public lines are MPLS can be used to send the constraint refresh tokens as a mechanism for replay protection for those kind of tokens so we now have four public lines that do not really authenticate or das the ability using MTL as two similar constraints access tokens as well as refresh tokens which greatly increases security for this kind of clients then there is a new privacy conservation section discussing the implications of the way certificates are being handled in a TLS up to version 1.2 because in that case the public key certificate is sent in the clear so the implications regarding privacy is now also discussed in the document and there is some more text about hash algorithm agility in the security conservation section the rest includes are more or less editorial changes including removing a bit of the influence of my mother tongue let\u0027s see ah the German influence all right yeah that\u0027s about it so Brian plans to also add some little explanation or more explanation about "
  },
  {
    "startTime": "01:12:32",
    "text": "the way refresh tokens are being handled indirectly for confidential clients and then we hopefully can move that draft forward any questions comments hey Annabel I\u0027ve been waiting for you Annabel Backman AWS so I want to talk about the metadata for the MPLS endpoints um a couple of points a lot of stuff I brought up on list but I want to share it with the people who are here firstly I think the example yeah that one I believe that violates RFC 84 14 the authorization server metadata spec because that spec says regarding where was it I had it up here regarding the token endpoint off methods supported that it is optional a JSON array containing a list of client authentication methods supported by this token endpoint in the context of the spec that means the token endpoint listed in the token endpoint property we are this is suggesting a change in the interpretation of that value to where it now means a client authentication method list of client authentication methods supported either by the token endpoint or the token endpoint under MPLS endpoint aliases so that\u0027s that sounds to me like a potentially breaking change and if we\u0027re going to make that change we should at least be deliberate about doing so so so for my understanding it might be right um I think you should be waiting til Mike arrives again so you can comment on that more deeply I think the assumption is that the MTA less aware client first looks up the authentication method see there is a TLS client authentication support and then looks for the M TLS and pound aliases I think we could cope with the issue just raised by just having a copy of there or a redundant token end point of methods supported in DRM TLS let\u0027s call it metadata and have those elements added there to this to this particular economy I think that that should be feasible because in the end it\u0027s it\u0027s the same way as the alternative made today that would work right what you would look for the alternative metadata and then if that does not access you will fall would fall back so it\u0027s it\u0027s now the logic is quite the same I think when it was that first step that led me down the path of going hey let\u0027s just make this a separate document because that way we we don\u0027t have to worry about other issues like this that may come up in the future as "
  },
  {
    "startTime": "01:15:33",
    "text": "there are further iterations on what goes into the authorization server metadata as like every single new spec that comes along practically as introducing new properties there which gets to one of the other concerns I had which is around are we requiring now that every spec that introduces a new endpoint property also has to define that under MPLS endpoint aliases it looks like the language in MPLS right now is kind Fuzzy\u0027s around that and is sort of saying well anything that\u0027s an end point property can also go under em TLS end point aliases and maybe that\u0027s come out adds enough flexibility there that we don\u0027t need to expect people to be too explicit but again I just want to make sure we\u0027re being intentional about that my big concern here is that we are thinking about how this might alter ization serve our metadata and client authentication may evolve in the future and making sure we\u0027re not boxing ourselves into a corner here one thing that came to mind thinking about this or the last day or so is in TLS 1.2 and adoption I know of some cases where we had to roll out new endpoints to support TLS 1.2 because of legacy deployments that were gonna still hit those old endpoints we couldn\u0027t turn TLS 1.1 off on those that raises the question of whether or not this is really like a one-time issue with M TLS or if there\u0027s going to be other use cases we\u0027re going to have where we need to kind of fragment the endpoint space along various parameters and if we should be thinking about a broader solution for that Thank You Annabelle any comments on that what\u0027s your what\u0027s your opinion your thoughts about that Mike welcome back Annabelle just raised the issue that the syntax has shown in the example violates on the is metadata RC since the TLS of client off method is contained in the top management of methods supported although the token end point in the same in the same context does not support an TLS I can restate my objection so if you look at the text 484 14 it says that the token and point Oz method supported is a list of Awesome edits it\u0027s supported on the token endpoint that\u0027s plainly no longer the case here because now it\u0027s a list of token of auth methods supported on one of these two token endpoints so that that is a change in the semantics of that property right we should make "
  },
  {
    "startTime": "01:18:33",
    "text": "sure we\u0027re working group are comfortable with that change or if we\u0027re not then we need to think through how else do we do that it\u0027s as a further example of where this potentially goes wrong is like in this context we understand really this only applies to TLS client offs but outside of the context of this room somebody looking at this is do they understand that do they realize that okay TLS client auth is supported on this endpoint mm-hmm and everything else is supported over on that endpoint or is there a question of okay client also supported here client secrets supported there yeah ja just supported over here like how do how do they split up the elements of that list and make sense of that this is where it starts getting into a lot of room for ambiguity on the implementer side trying to decipher what this is supposed to mean I\u0027m gonna cut the mic after Mike and Mike Jones I haven\u0027t read the draft in a while but the mpls endpoint aliases list those are the ones that you are doing mutual TLS and they\u0027re in parallel parallel with the others that\u0027s the idea yes so any any traditional client just uses those that don\u0027t cause any issues and those that are a bear of em TLS use the other ones you know this this is Jason and we\u0027re doing flexible metadata I would be fine with there being a note and the definition of the TLS client AHS value to be included in the token endpoint AHS methods saying that in this case that actually applies to the MPLS endpoint alias list so you mean this would go into the MPLS draft and relates to the client authentication methods defined in this particular drug yeah okay just as long as we\u0027re clear with people what things mean I don\u0027t think there\u0027s a serious issue but thank you for Annabelle for pointing out the ambiguity +14 just being intentional and clear I think if we\u0027re comfortable making that that going that direction and let\u0027s just make it clear in the Dokken okay thank you I actually leaned towards repeating the token and point off methods inside of the MPLS block I think that would actually be clearer that mutual TLS isn\u0027t supported on the non mutual TLS end point which some people will become confused by so basically means toss near leaning towards an alternative configuration without ending to having the alternative configuration different file yeah thank you "
  },
  {
    "startTime": "01:21:38",
    "text": "okay I want to talk about the yesterday jot em so just a good background so most people probably know that a dot has it defines that the concept of an ester dot where a one jot is contained inside another dot M so there is a current limitation with that with the definition today in where the outer dot is not allowed to have their own claim set so it\u0027s only it only contains that that a insider dot so the goal is to try to extend that that scope and and allow the outer jaw to have their own clients and and that draft is just defining a new a content type in and a new a claim to contain the insider chart and here is a quick example of how would that look so and I\u0027m running quickly with this because I want to allow yet another and presentation to happen so and I think it\u0027s simple enough to maybe quickly talk about this quiet and so room engineer leave the draft is actually very very simple yeah what I didn\u0027t kind of catches what\u0027s the specific motivating use cases we think about the chartering part of this yeah okay well let\u0027s say a motivation any any comments about this any concerns about this does that make sense in general okay okay good thank you give Daniel fat with yes calm first time here and yesterday I uploaded my first draft demonstrating proof of possession at the application layer so this was an idea that came up at the all security workshop last week and struck that the problem is we heard about this before so the all security BCP to recommend recommends to send a constraint tokens which absolutely makes sense but orth lacks a suitable mechanism in an SP a or let\u0027s say in a browser-based app or whatever you want to call it so we have empty LS which doesn\u0027t have a nice user "
  },
  {
    "startTime": "01:24:39",
    "text": "experience and we have token binding which lets browser support so we need a new mechanism the main goal of the new mechanism is to prevent anniversary that gets hold of nexus token to use that adversary to use that access token at some different server so for example if the adversary is a malicious resource server we don\u0027t want that resource server to be able to go to another resource server and use the access token there in this proposal we want to define a mechanism that can be combined with any client type and any client authentication method we want to follow the rough idea of the token binding approach but signatures are used only for the proof of possession for the public key itself or the product itself and also for replay detection whereas the message for message integrity we have to rely on to your les to give you a brief idea of what the current approach looks like in the auth flow we have in step C the token requests and to the stockmen requests we attach deep Alpine binding that is assigned jawed that contains a public key and also information about the request enricher disused namely the method and the path the your eye including the path and this is signed by the client using freshly chosen private key and the authorization server receives that and can uncheck that the claimed public key are that the public private key mattress can check the signature and then bind the access token to the public key presented by the client then when the client wants to use that access token that sensor so-called Depot proof which is a JWT which is again signed by the same public key and again contains information about the end point where it is used a new request for it is used and the resource server can now check that if the access token is JWT then in the access token you probably would have the public key signed by the authorization server so that the resource server can just check the topic key otherwise if you use token its introspection then the resource server would go to the authorization server and in the intro introspection response received the "
  },
  {
    "startTime": "01:27:39",
    "text": "public key which was presented by the client earlier we can also use especially for public lines the same mechanism if you want to get a fresh refresh token if you want to use the Refresh token to get a fresh access token there you would obviously also be able to attach a new proof and maybe also even find a new public key and rotate that in the process this is what the JWT looks like so very simple type is new type deep opening plus a JWT key in the header and the information about the request the method and the UI and some data for replay protection in the body so as i said i published to the draft yesterday I sent an early version around already we have I got a lot of feedback on that so a lot of points open for discussion this list is actually not complete so we need to talk about whether to transport it and had us parameters what we want to maybe include in the body as well some subjects clarifications and of course we need a thorough security review if possible also with formal analysis and then also complete the security consideration sections and some other triggers that\u0027s it John Bradley yubico so by way of sort of explanation of the origin of this we sat through some long explanations about xsrf attacks on single page applications and at the end of that we decided that we should just completely eliminate browsers because they\u0027re an attack vector I agree short of that the finding the you know binding tokens to the browser instance doesn\u0027t solve all problems because an attacker can still take over your JavaScript act and wield the tokens inside of the user agent but not allowing the the attacker to exfiltrate those tokens cuts down a bunch of things that forcing them to use them inside the same user agent gives you more options more ability to detect something horrible has happened so in order to come up with a way of not exfiltrating the observation was made that yes we do have web crypto now and you can create keys that are non exportable in the browser so this was a "
  },
  {
    "startTime": "01:30:39",
    "text": "mechanism of essentially we have Justin\u0027s HTTP signing draft we had Nats j-pop draft this is cutting all of the stuff that wasn\u0027t absolutely required out of the proof mechanisms now we can private we\u0027re probably going to have a long discussion about yes I want to add back signing header signing the header signing the body and various other things and those are all debates that that we can have going forward this is the sort of minimal subset that one would need to meet the basic use case there\u0027s nothing that would stop us from adding back all those canonicalization options in the access to in the proof for the access token but this also we\u0027re also focusing on not forcing people to do pre flights by requiring use of a header so there\u0027s a bunch of things when you\u0027re doing cores that have to be taken into account so you can double the amount of calls that a single page application has to make we\u0027re trying to avoid doing that so this is targeted but people will undoubtedly argue that we should add back a whole bunch of other stuff so ok it\u0027s not the end of the discussion in the beginning of the discussion thanks Mike Mike Jones Microsoft I think it would be useful to explain to the room because most people weren\u0027t in Stuttgart last week there\u0027s a whole bunch of different kinds of Roth applications there\u0027s native applications there\u0027s single page applications there\u0027s web applications etc which of those is this mechanism applicable to so I see if mainly fault browser-based certification is that the moment so I don\u0027t know whether other people can come up with other use cases where we really need such a mechanism and can\u0027t use a better mechanism I can see us so rather based applications that\u0027s the main okay and I know that people want and/or need proof of possession mechanism for web-based applications will this work or will it not it so I need that the work group like the chairs is already here so we\u0027re out of time here we\u0027ll have to take it offline okay thank you everyone can we get the blue "
  },
  {
    "startTime": "01:33:43",
    "text": "sheets please "
  }
]