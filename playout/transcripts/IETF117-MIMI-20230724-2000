[
  {
    "startTime": "00:00:34",
    "text": "Good. I got 1 Alright, folks. We're gonna get started as it's just past the hour. So this is mimi, more instant messaging interoperability, the first two sessions this week at ITS. We have quite a lot to discuss here, so we're just gonna buzz through the chair slides to get to the meet today. zversed Good. The note well. So please be aware of the intellectual property. policies of ATF as well as the mask policy, which given Local regulations means you don't have to. Okay. Onto the agenda. So today, we're gonna start with a discussion of some of the open requirements items. First off, we're gonna have Richard talk us through the questions of is there is an owning provider, and do we need 1, Mimi?"
  },
  {
    "startTime": "00:02:01",
    "text": "Then we're gonna discuss whether client to server interactions not to be confused with either client to client or server to server. are in scope for Mimi, then Rowan's gonna lightness on design requirements for transport service. then we have a couple of decks on the linearized matrix and then meaning delivery service. drafts. Alright. So that's today. Then on Wednesday, we'll cover all this in more detail, and they'll more links to more slides and drafts by then, We're gonna cover some more requirements that aren't essential to the transport discussion. and we'll take a look at some draft about user discovery. And last thing to cover before we get in is we just wanna shout out these great stickers that somebody made. We don't know who, if you if you choose to remain anonymous, so much the better. But, like, thank you. These are really cool. Your heart Yeah. I know. There's sneaker netted around. We don't know. ma'am. Okay. So if you did make them, I don't know, come say hi to us chairs, and then we'll Thank you. Yeah. Seriously. So before we move on, agenda bash, did anybody have anything to bring up, Sounds like no. So, Richard, Oh, good point. We do still need a notetaker for the session. Do we have any volunteers? Remember to sign on the And, yes, please sign the blue sheet Not Thank you. 8 year Alright. Alright. With that, let me bring up your slides. So welcome, everybody. I my name is Richard Barnes. I'll be your designated neutral"
  },
  {
    "startTime": "00:04:00",
    "text": "topic introducer discussion, a kicker offer today. which Sherry has asked me to do this presentation after the two questions were set. So You'll get a little bit of what was on the agenda and a little bit of my interpretation. And please please let me know if I'm not quite shouting into the mic loud enough. I'll try harder. Okay. How about now? Great. Cool. thing doesn't appear to be moving it. So, Tim, can you drive Yep. Next slide, please. So, hopefully, the next three slides will be Motherhood and Apple Pie, we will all agree on what is on these slides, because they were just trying to What I understood to be you know, truisms that we've all agreed on so far. So to establish a baseline for what we'll then talk about, what we'll then disagree about later. hopefully agree. So next next slide, please. by the way, we should probably write an architecture graph at some point. Happy to collaborate that on that other folks are interested. So this is to kind of describe the the overall logical structure of a Mimi conversation. So the room and and Some of these will over the terminology here will overlap with individual proposal, some of them are matrix y terms, some of them are DSC terms, some of them are other things. please understand them all as abstract things, you know, trying to capture general intent, not what it means in a specific proposal. So the idea is that a room has things happening in it, it had can have messages being sent. It can have changes to state, things like that. There's because MLS is involved, there's a need for some sequencing, so I've drawn these as a sequence of events here. that's kind of the logical the room is the logical grouping, the logical construct. It is realized by a series of participating servers that represents different providers that are participating in this"
  },
  {
    "startTime": "00:06:02",
    "text": "in this conversation. And, ultimately, there are clients that represent users in these interactions. so far so good. Everyone agreed. Is this looking familiar to everybody? I'm seeing some nods k. Good. Good. Next slide. Let's see if we can keep going on on the agreement. So it's trying to capture, like, overall what the protocol stack looks like. So, you know, the bottom layer here kind of aligns to the the entities we had on the last slide, we have clients on the end servers on the middle. trying to capture here that the transport pretty much captures the server to server inter How do the servers who are interacting and creating a room create the room together, you know, realize that logical interaction. and acknowledging that there are some provider domains off to the side, where there may be, you know, unspecified interactions servers and clients that are not the business of the IETF, not the business that you may be working Now above that transport layer, getting things from end to end, we have these end to end end to end security layers, Right? You can have things that are end to end authentic, so they're signed by the endpoints but not encrypted. They're visible to the servers as they transit. and you have end to end confidential information that is signed and encrypted so that the servers can't read it. And on top of all that, we have message formats that actually create the application and their functionality and say, this is know, or apply. This is an you know, I'm I'm telling telling Gro and I love Evans today. and all of that. So does this stack overall look familiar to folks look looksane Anyone anyone Sirius reservations. Thumbs up for Matthew. Thank you. Alright. Good. Next slide. Let's continue to agree. So this is this is a little sketchy here because we'll start still working this out. But the general idea that a room this this interaction framework we have has some policy attached to it. that says what can happen in in that room? What's allowed to happen? So that captures things like who is entitled to do what's Yes. those are the, you know, largest things. You know? How do you how how are someone allowed to join this room? things like that."
  },
  {
    "startTime": "00:08:00",
    "text": "So overall idea here, there is a policy attached to a room that expresses some things like this Rowan has a a good draft. It's expressing some other stuff. There's some good stuff in Matrix. But in general, there is a policy attached to a room, someone can set that policy, and someone enforces policy policy policy Good. knots. Cool. Alright. That is my setup. Next slide, please. Let's get through. So first question in the chairs asked me to talk about was this notion of an owning server. And when I looked at that on the agenda, I was a little puzzled. Next slide, please. So there's multiple notions of ownership, it seems like floating around here. So there's at the transport layer, could have you could have notion of ownership. So, you know, this server is the physical hub for the conversation. Everything that happens in the conversation every message that affects the state of the of the room, passes through this server. Yeah. And you could have that be a pure support level construct and a thing that something that could do that, you know, just as a pure fan out, not aware of any of the the logical state. So this this hub notion, I wanted to call it, one possibility for what we mean by ownership. on the kind of next level up, is, you know, if you're in that hub role, and you're seeing all the events, you can apply filters to this. expenses to to enforce policy. So when you get a message, you could check and access controls. hey. It's the user that sent this message allowed to send this message, but the user tries to kick someone out, are they allowed to kick someone else? You could be a a policy enforcer when you're in that especially when you're in that hub role. And then the 3rd quote notion of ownership is policy controls you actually own? Can you dictate the policy that applies to this room And, yeah, that you there are various levels of control you can imagine. They're restrictive version. You could also envision roles here where policy controller could set a boundary for what the poll the legal policies are, and then maybe clients or other participants in the room could specify the nuances of the policy."
  },
  {
    "startTime": "00:10:03",
    "text": "So I wanted to kind of call out this taxonomy of ownership as as something the where feedback from the room would be welcome on which of these are necessary to have as a unitary single thing in the room. We called out at the bottom here some some ways. These are non orthogonal. A lot of it comes down hub thing, you know, if you're gonna do any policy enforcement, especially You it's useful to have this hub things so you make sure the policy is always enforced If you're gonna have a policy enforcement as well, it's important that the whoever's enforcing the policy, understand the policy. and so that puts a constraint on how how you can do, you know, adapt stability and extensibility of policy languages. So there's a little bit of constraint on the policy controlled by having by virtue of having a policy course, you, of course, you're Next slide, please. Yeah. The Ecker's in the queue. Would you like to take that before you move on? Yeah. Go ahead, Edgar. Yeah. So I mean, 1st of all, I think there's another notion of owning in this case. is just responsible for storing the state associated with the mean, so in particular, mean, any room, obviously, The delivery service has to know Where did you send the message? You know, which entities are the messages? you know, to keep track of which peer services and which local And so like, the most simple, I think, notion of of of of this concept. Right? and none of these doesn't quite captured by any of these. It also seems like it'll be kind of unsatisfactory to have I'm said, you know you know send service not to any policy enforcement, for the obvious reason that I don't really want you know, even if even if I can't, you know, even if even if the message is not part of the part of the MOS group, allowing random people to send, like, all kinds of messages to, like, you know, hithereenon is not a non attractive property. Yeah. So I I guess I I mean, I think I I don't I guess I guess sorta, a, I think debating this takes on a little bit, but b, sort of wing in in favor of some policy enforcement, a minimal Yeah. And then the the question will raise"
  },
  {
    "startTime": "00:12:02",
    "text": "I think on the next slide is, you know, what's What version of ownership does this protocol need? So as so amendments to the text on, you're welcome. this is just intended to kind of lay out a few axes that were obvious to me. but but but but others welcome. Europe. Yeah. Rowan May. So I I think an important aspect of this for like, a policy enforcer would be to say, you know, it seems pretty obvious that if you were gonna send a commit that and and that one provider or one server was responsible for saying, yes. this commit of the 3 that I received simultaneously is the one that is gonna get fanned out. Fanned out. at that for me, I would put that in the policy and for sure category and not in the hub category. whereas pure message fan out, I would put in the Hub category. Okay. Yeah. That's fair. But I and then maybe that's an another access to keep in mind here. To the degree that we are dependent on MLS, without inventing some new distributed flavor of MLS, we need someone to act sequencing arbiter to dictate the sequence of at least the MLS messages. commits? Yes. Of the commits. Yeah. Yep. Okay. Let's you hit the next slide? Yeah. So this know, given that we have policy, there is underlying this question of policy control, and sure I wanna spend a whole bunch of time on this other than the last slide that This there's this question of who sets the policy for a room. There are a few different answers you can imagine to that. You could have a system where only a single owning server unilaterally sets the policy for the room. You can have a system where server other servers participating in the room can attributes to that policy. Can there's some collaborative process think there probably needs to be some way for clients to have input into the the policy for the room possibly via a server, just so you can have things like where I grant Rowan permission to be a moderator in this group."
  },
  {
    "startTime": "00:14:00",
    "text": "example, I have admin permission site, and I grant her own moderator permission. So there's this kind of unitary server, multiple servers, clients, all in the mix and so, like, there's this question I think we need to address of what sort of policy control model do we have? Who is allowed to set policies? kind of a another layer of nuance in this ownership question. Now last point here, I'll point out is, like, this client server provider thing is not totally distinct because there is this kind of provider domain where there can be off book outside of the protocol coordination, if there's enough coordination between a server and its clients, the clients could basically affect some provider policy into the room even if you had a pure client driven model. Yeah. Page 3. Maybe a simplifying Yep. In databases, you have 0 1 and many, And those are the three cases you When we're looking at things like this, If you've got a room with fifty people in, That's one sort of thing, and you don't need to buy the control, you know, distributing Management of that over 3 different servers makes very little sense. You just you know, distributing for the sake of making it more complicated. If on the other hand, you've got 10,000 people in the room. Yes. You've got 10,000 people in the room, but if you've got 10,000 people reading and writing in the same room Well, it's not gonna work. And so I think that really large rooms turn out to be a completely different kettle of fish And you probably don't need to consider them in the same way. because you're, you know, your access into the room is gonna be has to be so limited because you can't have ten thousand people talking at once. You have 10,000 people listening. And so actually when you come down to it, I don't think that you you have the requirement for multiple masters all trying to manage the same room at once."
  },
  {
    "startTime": "00:16:01",
    "text": "I I see where you're going with that, but I think an important clarification to the use case here is that the servers we're talking about are not sort of multiple replicas of the same logical data. or the servers are effectively different autonomous systems. And so they may have different opinions. about what the state of of the policy should be. And so even in a a situation where you have only 3 users, 1 per provider, and the picture I had before, like, you that may still be worth having some sort of coordination protocols so that those different opinions about what it should be can be somehow combined. at least reconcile acknowledged Again, this is setting setting up the discussion for people to have opinions, but thank you. Yes. The next slide is is Before we move on, there's Jonathan's in the queue. Sorry, Jonathan. please? I I assume we want discussion on these as we go along. Yeah. Why don't we why don't we do a kind of clarifying and elaborating discussion. Clarifying now? Yeah. Sure. Then I'll sit down. like you. Okay. Yeah. The net the next slide is the disc this discussion tier upper slide. Yeah. So the question here is, like, what do we need in terms of ownership? So, like, which of these notions of ownership do we need in the protocol? you know, do we need a physical hub server, for example? Or do we is Hub server also applying policy. And then how what's the kind of policy control model that we envision here? Is it Mainly client driven? Is it unilateral server driven, or is there some collaboration? So think that's the kind of last framing I've got. So Please take to the floor and discuss them on yourselves. Jonathan, I think you were first. Oh, okay. was like trying to get myself back in queue. Jonathan Rosenberg, 59 I think a useful litmus test to help make many of these decisions is to recognize we're not in a greenfield environment. We're dealing with existing gatekeepers who have products that do what they do, and it is not, I think, within our remit to tell them how to design or change the products that they've been shipping."
  },
  {
    "startTime": "00:18:04",
    "text": "And I think that helps educate some of the answers. What I was gonna say, for example, in the policy question is, that each of these gatekeepers has a set of policies they do today. Like, they don't support all these different room types and variations. And so there that forms a pay envelope over which, you know, hey. If if if I say, what's happened? owning this thing either. I don't support this type of thing, so no user can elect those options. They can only elect ones that are supported by my product. So it translates to a protocol, there is a boundary that's set. by the and they're not the same across these providers. And so practically, like, I don't know how to make this thing work at all. Well, yeah. Without someone owning it, they're the hub, and they are the one who dictate the envelope of the policy. that defines what it is that users can do based on the product they already have or decide to ship in the future. So that's my view on that one. Becker. Actually, next. Sorry to tell. Yes. You are. So I think I largely agree with Jonathan. Sorry? I largely grew Jonathan, I think. I don't see how this works without the as a practical matter in the real components we have without the Only tapping Alright. the the existing services being allowed to influence the policies that are applied in the room. and I don't think it practically works without them being able to actually enforce them directly rather having them enforced by, like, some somehow notifying the clients and having the clients enforce in the stuff. I don't know if this might work very And, like, if it did, we need to find some new language regarding that, which seems an income So I think it'll be, like, remarkably simple if we assume there's some designated provider in any given chat who is able to do these things, and And and then we I that's hard to phone resolve as it is. So I think, like, that's where I would where I wanna go with this. I do think of. the clients should be allowed to influence policy. You know, for instance, you could say there's a closed room and open room. So if I have the easiest version,"
  },
  {
    "startTime": "00:20:02",
    "text": "I think the more yeah. I think the the interesting question that perhaps you have to grapple with is What about people who are not the new provider on our servers? Any authority whatsoever. So a concrete example is, you know, is this you know, this is chat which is owned by provider a. and fighter b joins. and then, you know, and then then someone joins the chat from a, who b thinks is a spammer. or b thinks they're criminal or whatever, and could have any opportunity to do 22 influence that at all. suspect the answer on, regrettably, we know. because I'm not trying to design. I I don't like that anymore than you do, but I think designing I I worry about those situation we have we have Grier. Yep. you think that that can I think it's gonna be very difficult to engineer something where Beacon influence I'm sorry for in this scenario, b is the non owning provider. Yes. I think that's regrettable, but I think it's probably the way we're gonna end up. But I think that, you know, And and I guess I would finally say, I think that the what the clients can do and what the servers can do while they may have overlapping ringlets or different different categories. And we the clients want to be able to, you know, set overall policy within, as Jonathan said, the envelope. and then make specific targeted changes. Like, I invited this person to kick them out. priced, priced, priced, not be able to do other things. versus they might be able to filter messages from individual people. Yeah. So I I think that that last point is probably a useful checkpoint for folks where a a cons a concept we could establish here is that the servers establish a boundary of acceptable policies, and clients set specific policies within that that thumbs up from Jonathan, and it -- That's about what I expect. Yes. Okay. Good. whoever's taking minutes, I think that that's a good thing to record. Rowan. Rowan, I think you're up. Rowan, you're in the queue. Rowan Main. So"
  },
  {
    "startTime": "00:22:02",
    "text": "I described something similar to this in group chat, but where you have a provider says, okay, I'm willing to do rooms that do any of these things. whoever sets up a room says, These are the things that this that this room does. and then can, you know, potentially grant permissions to other users, including potentially at users that are not on a different provider if that's supported. And then In terms of the property that Ecker described, I actually don't think that's regrettable. think what's necessary is not that that the client can't influence whether, you know, a user that thinks as a spammer that b thinks as a spammer joins with a in a group hosted by a's provider, but that b knows what's going on and can decide whether to join or not. And so likewise, even even if there was no spammer involved, if a set up a group and invited b, could look at the room policy and say, You know, I'm not okay with that room policy because there's a logger involved or because there's a history you know, there's, like, 90 day of history back sends to anybody who joins, and I I don't wanna be on the record for that. for potentially unknown new joiners, whatever, for whatever reason. So I So I think that there is that there is actually a very clear set things that we can do that allow the that allow a a policy enforcing provider that is an owner in that respect. a client who is involved in setting up a group, and clients from other providers have actually a I I think we have an opportunity to enumerate a very nice set of rights for them. to"
  },
  {
    "startTime": "00:24:01",
    "text": "accept or not. the conditions of the room and pass if they're delegated to be able to affect So I think that's a really nice property. Daniel. Daniel Con Gilmore. So so I'm struggling with this a little bit because of how abstract the Policies we're talking about enforcing are. And I suspect that there will be policies that Only the room provider can enforce there may also be policies that touch on things that the room provider doesn't have access to. Policies related to things that are under encrypted cover. And if we want one totalizing vision here, don't know how we're gonna square those things with each other. So I I I feel like talking at this level of abstraction is is is is challenging. And we maybe need to, like, just parcel out the types of policies that the room provider must have access to if they're expected to enforce it versus other types of policies, that might be interior. And I one other thing I wanna keep in mind here is that as an end user, you need to be able to know who has us who has control over the policies in the room and who's enforcing them. And just to I I wanna make sure that the end user gets to see all of that. from the infrastructure level up to the to the stack. I just think that's something to keep in mind. Can I can I ask you a quick follow-up question? Isn't it the case that any policy that relies on this is something within the encrypted envelope is basically out of scope for what we're designing here because has to be between the client And It has to be, like, within the client or between the client and its own provider. That's Richard Bass."
  },
  {
    "startTime": "00:26:02",
    "text": "So, I mean, if if that's the answer then -- Not not at I'm not talking about protocol. I'm talking about actually we actually have to have access to something inside the encrypted envelope. That's what I'm saying. the policy has to act on something inside the encrypted envelope. How could it possibly be in scope for us? So if if that's the answer, then then then I mean, we're basically saying there has to be policy that is acted on not by the endpoint. Right? mean, that that's what we're saying. There's lots of policies that don't need a need this access. Right. So that's why I'm probing on this other category, which I hadn't really thought about before, which is policies that would need access something inside the encryption envelope. That's like a new that's a new thing for me anyway. So That's why I'm asking that. I mean, I mean, it seems like you know, if you have a policy that's, like, don't mention secret project. Yeah. Exactly. Right. Right. So so -- So that can only be enforced by someone who can see the contents of the conversation. clearly, that can only be enforced by someone who can see the poll the the contents of the recision. So I I think it's it's just think you could imagine providers setting that sort of policy. but a provider can enforce that policy at a certain And just talking about kind of physics, here. Not not even, like, engineering to Zitterata. Right. Does that seem correct? So I I I think That that means I think the upshot of that is that there may not be any protocol considerations for us to specify about how that's enforced. we could still potentially have some considerations about how it's it it's specified and set put in place. So so I give an example of something that might be inside the encrypted envelope? Right? So Who gets to join? the group. in terms of who is given access to the right piece of key material to join into the key the key material. Right? If the if the room policy if the room provider can influence that?"
  },
  {
    "startTime": "00:28:04",
    "text": "can change that. Then the room provider needs to have access to the the key material to be able to delve to to to open encrypted envelope. Right? So I would No. No. You can con you can have you can have membership controls without having the ability to see So because I mean -- But but to add them to the membership, Then some key material needs to be visible to the new member. Right? Yeah. It's there's public key material I can provide to the next participant. Okay. So -- Now there's some history issues, but to the first order that you can deal with. public key material. Right. So so his okay. Then then then history is an example of something that's inside the encrypted envelope. Right? So that's a that's that's just a positive. -- a server was going to Add someone to a room and give them the last 90 days of history. then the server would need to have secret key material. Right. Right. And then the service ends up being acting as though it was a member of the room. Right? anyway, if if we're if we're thinking about those things, then So, then we need to think about it as somebody who has access to the interior of the envelope. Yes. Yes. Right. So This is helping this conversation is helping me to think through what what we're talking about. It sounds to me like we don't wanna talk about the stuff that requires inside the encrypted envelope in conversation. Okay. a good yeah. That's I think we would we want some -- I'm getting I'm getting some grimaces more and although that might just be the normal resting expression. I mean, I I I think we would have a a good useful decision here if we came to a decision only dealt with policies that servers could enforce. Yeah. Message. actually I don't I don't know if In terms of the question of overt servers, should enforce from my perspective, it's a category. Yes. there's a real danger here that if the hub is the only thing that enforces policy, than the hubs from different vendors, different gatekeepers, or whoever it is, could go completely off message applying their own rules. So"
  },
  {
    "startTime": "00:30:03",
    "text": "from a user perspective, you need to be able to configure the room in a consistent way or at least bridge the semantics that your existing provider has through to a common language, which everybody then can enforce Also, if you're moving the hub around the place, due to the hub going down. or you want consistent conversations helped by different providers, which obviously is desirable. Again, you need to have a consistent rule set. However, I think it's important that all servers can also just reject whatever messages they want. based on whatever rule set in addition, and that could end up with split brains. But just from a pure anti spam perspective, a given provider has decided to block list another provider for whatever reason, even though it would be horrible for experience for the people in that conversation It's really the equivalent of an email situation. Square in on a given distribution list of some of the SMTP service can't talk to one another. then it's gonna be painful It's unusual. It's unlikely, but people should reserve the right to do that. Ruffer Robert, So, yeah, I think we also need the hub to enforce the policy to do the message sequencing as well. And to go back to the question of DKG, I think we probably when when we initially thought about that. We thought about group management policies. So, essentially, what what Rowan has been drafting up. Like, what types of groups groups do we have? Open groups, groups where you can only enter with an invitation, groups, Where I don't know. Where you have admins, where you have moderators, such as. So this kind of policy is something that can be in the clear and that can be enforced by a server."
  },
  {
    "startTime": "00:32:01",
    "text": "And what's important is that that is absolutely transparent. I think that's been said before as well. should be transparent to the server, it should be transparent to other servers. that connect in that instance, and it should be transparent to all of the clients as well. So and and it should be enforced 1st and foremost at the server level. But, ultimately, clients could also and force things if the hub goes completely rogue and doesn't stick to its own policy. Pete Resnick. So I need an example or 2. of services of Policies that the server can actually implement other than deliver or don't deliver this message that I can't that I don't have visibility into. because I I'm having Joining so open or closed, I don't even understand how a server implements that. Because if I'm I'm if I can, as a client, hand you as a client, the public key to join the room, then the the The hub can't implement stopping this from being an open room effectively. What kinds of policies can a hub actually implement or Kenny, server actually implemented. Yeah. Roan, why don't you go for go for the so someone who's actually run one of these Please answer. Hi. Rowan May, and yeah, I'd put myself in the line to kinda answer some of Daniel's questions and to try to make? these more concrete. So couple of examples. So if you have a So let let's assume for the moment that our providers are the, you know, numb the second level, the provider enforcing. And in that case, we had for in the sort of the very basic case, you want to have an membership only group where there's an administrator that"
  },
  {
    "startTime": "00:34:03",
    "text": "can can decide to add people or you have other ways to to join, like, via invitation links. So those things are supported by lots and lots of different services out there. It's a very popular model. and in this case, the the owning provider, it can hold the the it can there there are several different joining styles, but in the joining style where somebody tries to just go and join. in order for them for example, like, one of my existing a client of of an existing user who wants to go and join, they wanna do that, by virtue of the fact that the same user is already a member, that could be authorized. and they can request this thing called a groupinfo in MLS, which allows them to go and join. And so that that provider could gatekeeper this group info, on the on the basis of the policy that was defined n, you know, is sort of jointly enforced by is enforced by the provider. but the clients also get to see it. And the clients can have this thing in MLS called agreement, agreement, where everybody knows what the policy is, and it's burned into the group. And so If they see that the that that provider all of a sudden added someone, in a way that's not in accordance to the policy and the the authorization rules. They can cry foul. They can send a message to the group. They can pop a big clacks on warning signal to the to the end user. They can automatically drop out. all kinds of things. They can prevent the user from typing something at potentially incriminating. But the the point is is that there's that there are roles for everybody, but the the this case, the owning provider, can have this role"
  },
  {
    "startTime": "00:36:01",
    "text": "of having this kind of minimal enforcement Another example would be say, logging. So if let's say that I have somebody who works for a financial services company that requires logging of all conversations. And so you can have a user that's clearly identified as this is a logging you know, this is a this is a a logging bot or whatever, that's in that's in some room. And then you have somebody from an auditor that goes and joins this group and the auditor has their own logging policy, and they need their own logging bot. and everybody can agree that there are 2 logging bots in this conversation, and anybody that doesn't agree with that policy knows and doesn't, you know, can decide even before they go and join. that, ah, this is a policy. I don't agree with us. Or maybe I need to go and prompt the user because I've never seen this situation before, and I need to say, you know, hey. you want to allow this permanently for this domain? Do you wanna allow this one time, or do you wanna skipped joining. Alright. So those are some examples of policy things that we can do with this you know, level 2 policy enforcement. But most importantly, you know, just figuring out the order of who gets to gets to commit an an MLS message is also pretty fundamental, and I think that that's quite important. And I think for the number of providers that are interested in using Mimi, I think we enough. think a lot of them are going to be interested in this sort of level 2 enforcement, at the very minimum of being able to decide which commit is gets gets the turn gets a bite of the apple at a time. next. So Jonathan's up next, but before that, we still have"
  },
  {
    "startTime": "00:38:00",
    "text": "stuff Richard needs to get through as well as Ron Stack. So in the interest of time management, we're gonna close the queue in about a minute. So if you have something you'd like to say to the these questions, please join the queue now. So in in the interest of giving foot people something concrete to throw things at, I wanted to go ahead and, like, or try and articulate a a thing we would put an open up or down yes or no plus tubes. So, like, the the straw man policy for you to set your matches to is There is a single hub for distribution and sequencing for given room. For policy control, there is a single owning provider that sets the policy or the policy envelope because we had about servers and clients. The policy envelope Everyone who's involved in the room has a consistent view of the policy, And every server enforces the policy low for for whatever passes through that server. So that's a straw man, so please continue discussion. Jonathan Rosenberg 59. I I wonder if the way to think about policy is more document once enforced twice. because in essence, MLS means that end of the day, the clients are making decisions about whether to accept a commit or something like that. So the model, I think, works, and this is what I thought your draft was trying to do. I may have missed it wrong, but was trying to basically define a document format for specifying these policies. The idea is that they would be broadly understood by the server that's the hub and by the clients. The server enforces what it can, it's almost like a double check. that the clients also use this to decide what they're doing and at the MLS layer of the system. And so that almost gives you a second layer of protection. So the example is say there's a policy that says, anyone can join the room except for Roan. the server can enforce that. But then the clients can enforce it too because they happen to see a commit that tries to add Roan to the room, they would just not accept it. and that's, I think, That to me is the model that is starting to make sense. document once and forth enforce twice."
  },
  {
    "startTime": "00:40:05",
    "text": "So Phil Hanbaker. So I agree with most of what Richard said about the straw man except Well, I agree that you want to have one server. your one computer, this is making You're going to need to have multiple moderators able to make policy, And one of the reasons for that is that moderators drop out unexpectedly. And one of the things that you probably need to also think about is What is the policy 4 creating a moderator or an administrator If all the mill moderators have dropped out, that's one. And another because of the way you're doing this as gateways or whatever, What happens if I'm starting this on WhatsApp? because -- Yeah. -- you know, That's where I happen to be. and then I drop out and there's no other WhatsApp person. And Because of the way you set this up, you've got to think about that transition of the whole thing from one service to another And we're still trying to do this as gateways, not writing a proto cold, cold, cold, cold, cold, cold, cold, cold, cold, cold, I I think is an interesting choice. But I I think that raises a useful additional nuance on the what I the Straumann I put up, and that all of that was intended to be at a given time. I think we still have this notion of that it might be possible to port from one owner to another over time. So on Wednesday, I briefly speak about the portability draft. So essentially, what that means is that while We agree on having one hub doesn't mean that that's one hub forever. It It could be. shifted somewhere else. want to make sure"
  },
  {
    "startTime": "00:42:03",
    "text": "Awesome. Thank you. Last one for you, Google. I you know, Richard, I I kind of agree with with your Straumann proposal. I think it makes a lot of sense. And one thing what's really important for us to think about is Not everybody gonna be able to enforce all the policies because different messaging could have like, you know, messaging providers can have different ways of doing things or something new can come up. So having to think about what is the fallback mechanism for a lot of these policies is gonna be really important. Yeah. And and and I think that's it's an advantage of having a Transport level hub, who is also actually, actually, me add that nuance to the straw man that the the Transport hub should be the same service the same provider as the owning provider. because if we have that alignment, that guarantees that everything goes through the hub. and the hub understands the policy for the room. And so you have at least one, and then the other enforcement is just backstops of that. my my True. Yep. I I I think just to paraphrase. Like, if we have a portability mechanism, we'll need to deal sort of consistencies from the old hub to the new hub. Yep. Thanks. So Warren, Kamari, I think I largely agree with your straw man. that I think you said that clients need to be able to evaluate the policy when joining. But the thing is the policy might change over time. And so I think if the policy changes, the client needs to go to reevaluate it each and every time. there's an update to it. Yeah. I I I think what I meant when I said everyone has a consistent view is even if the policy changes over time at a given time, everyone agrees on what the policy is. yet. Yep. If we do it that way. Got nothing. Matthew Hutchison. Just wanted to plus 1 and say yes Richard Straumann, actually looks good. with the proviso from PHP also of the having you need to define who else can edit the rules in the policy. I think there might be a bug in ruins and proposal at the moment, and that only the administrator is led"
  },
  {
    "startTime": "00:44:00",
    "text": "set policy, whereas having some kind of hierarchy under that. so you can delegate and moderators can drop out, etcetera, if it's really important. Good. Okay. It sounds like the straw man is not entirely consumed by flames. So I don't know. Cheers, how do you wanna close this out? I think we should do the rest of this deck Right? Yep. Yeah. Sure. Just move on. Let's move on to the easier question. Thanks for, you know, keeping up with me through that know, abstract thing. This is a lot more concrete. next slide, please. So there's you know, we we made this picture at the at the top, that everyone nodded about, about servers being involved in a room, and vents happening in the room, updating the room, just sending messages in the room, But now when you get down to brass tacks, they gotta distribute stuff somehow. We have to have actual messages flowing between actual computers. So there's a couple of different ways you can envision arranging this. there's what I've called the client to server to server to server to client. model. It's, yeah, it's even worse than SIP. where everything is provider mediated. Right? So In this case, since we now have a hub, I I didn't know we were gonna land on that when I made the slide. Luckily, we we have a hub. And so if some non hub clients originates a mess an event, it goes up to the hub and then downs everyone else. via their servers. This is one possible protocol flow. I think it's probably what a lot of folks have in mind if you look at the chartered, this kinda here. And I think server server API is pretty clearly in scope. to Next slide, please. An alternative architecture that some folks have needed mooted is where the submission of events yes. Distribution of events still emanates from the hub out via servers, but sometimes events can get submitted by client clients connect directly to the hub across domains. This is a reaching out beyond your provider domain. to submit an event. This is the client to server to server to client model. So you lose one s"
  },
  {
    "startTime": "00:46:03",
    "text": "And the question is whether we need both of these. Next slide, please. Let's take the queue first. Oh, sure. Oh, sure. really wanting answers. Well, that's the next slide is, like, whether we do this. to Yeah. 3 with you. The the the next slide is just taking questions. to the next slide. Next slide. mean, this is just an elaborate way of saying do we need both of these? Jonathan Rosenberg, I am strongly opposed to the the bypassing the I hate your acronyms, so we wanna talk about that part. The the by bypassing the server, I think it it It's just not practically realistic. And, also, I think it it it falls in the face of authentication and authorization rules that inevitably require a relationship between the client and their provider, and there is none in those pictures. So I just I I just I don't think we should go there. Yeah. Thank you. Let me try and short circuit discussion a little. I think for most the conversations I've had with people at least, the default model seems to be the first everything is server mediated model. so let's focus maybe the discussion on whether anyone thinks the 2nd model is used are necessary retractable. or some something we should do. So, yeah, I I heard I heard a no from Jonathan on that 1. So do you want to speak in favor of the other Yeah. So I think I was one of the people who proposed that extra model. So I think the baseline has to be that if the clients connect directly to the hub, that they can satisfy all the requirements in terms of authentication and transport protocol, they speak, etcetera. so that at the end of the day, for the hub, it looks as if another server was connecting. BECAUSE, otherwise, I fully agree this this could be held in terms of authentication, etcetera. So"
  },
  {
    "startTime": "00:48:04",
    "text": "What I'm in favor of is to keep that as an open question if we can or as we look into the transport protocols and the delivery service, etcetera. But we don't close the door completely on that. as long as we have this baseline. So so, Rafael, just to clarify the model you have in mind is effectively that if if there was gonna be a way for a client to directly connect to the hub, it would basically be as a single client provider. The client would act like server Yes. It would pick the same protocol or almost the same protocol. it could authenticate in a way that is acceptable to the hub. So that the hub does not incur any additional risk by allowing clients to connect to it directly. If we cannot achieve that, then, of course, the the question doesn't make sense, but there might be a way that we can actually achieve that. And that's why I'm proposing that we keep the door open for that. Rowan May, could you please go to the previous slide? So I don't have any particular desire reason for the client to talk directly to the server. but I will observe that we could model this as That client is just a guest client on the Hub server. In other words, that is a provider, it can do whatever it wants with its clients. And so if it wants to accept clients from another provider using some simpler complicated mechanism, that's its choice. And so for what we do here, We just say we have a server to server protocol, and here's how that works. And if we later wanna to specify how to do that, we can, in the future, But we're not explicitly gonna say, like, right now, we are gonna go define this protocol from here to there."
  },
  {
    "startTime": "00:50:01",
    "text": "So that's my that's my suggestion. Well, let me just read that back to you. So you're saying that this these in inside these provider boxes. Right? That's not scope for for Mimi. We don't know what happens in there. so there could be, like, a port on that side of the the hub. that the a client from some other good man could talk to, and that wouldn't be our business. and they could do it we could do some define something later, but we A provider could do it off book to start with. it the the scope of what we're doing, you know, in in the immediate future in the in the the is we're we're going to go and do server to server. and There is This leaves the door open that somebody who wants to go do that can do that and could even potentially define that here in Mimi after we finish our milestones. Jesus. I mean, I would definitely close the door on this. I might not, like, deadbolt it, but I would, like, close the door on it. Like, we have so much to do here, and we're, like, not even like, this gray circle is, like, hard enough. So, like, I really would like not to make it any harder. and As Rowan says, like, People can make their own external arrangements. And I think Wes Martin's about to say, maybe this is some other protocol. This isn't the side that you talked to the that your provider with, but, like, like, I don't wanna even think about this for a very long time, and I certainly don't wanna, like, spend any effort like, trying to make it work and then reject it. I just wanna reject it and then come back over to you later tonight. Yeah, man, Thompson. to Rowan's point, which is not what I got up in. to say was that at that point, you've got a different client potentially. It's not the client on the the left, it's the client on the right. And that's potentially problematic in this case because working out that this is the same person is not something that I know how to do without, like, So I'm just I like, like echo. Right? I think we'd probably just pass on that one. There is a 3rd model that Richard hasn't explored. And I don't like it, but I wanna make sure that it is"
  },
  {
    "startTime": "00:52:00",
    "text": "discussed so that we can put a nail in it At least for now, because I I I it's potentially an interesting one from a performance perspective. and that is the one where the client talks to their own provider provider. the the the server for their provider. And because the state of the group is known to that provider some messages can go directly to the to the servers of all of the providers. So the potentially some palling out happens on the on the ingress. This changes the hub and spoke model, but potentially avoids an extra hop. wanna make sure that that is discussed and then put to bed because I think there's a lot of complications there. No. Matthew Hudson Matrix, where we have our tetcher on matrix today, and we're consciously not proposing it for Mimi. because Vostat has very desirable properties in a very decentralized environments where you've got network partitions, and you want to have complete sovereign and penal autonomy for all the different servers. implementation wise, it's a lot more complicated than the happens boat model that we have here. So I'm glad it wasn't me bringing it at this point, I've stopped banging that drum. Instead, we're pushing linearized matrix, which is And then when you go and simplify it down to a single server rather than having a map Personally, I think it's a great design like it and many other things, but it's possibly too complicated for the use case here. Alright. That's Hang on, Rafael. You still wanna speak? Yeah. Just one last word because, apparently, I'm only one defending it today. There were more people last time. I promise. So we have a chronologically problem in the sense that there's a very easy way to do this sort of authentication with the delivery service draft that I will present later. So right now, it's super abstract to see how this could possibly ever work in a safe way, etcetera."
  },
  {
    "startTime": "00:54:01",
    "text": "that's why I understand that people want to close the door on it. Yeah. I don't know. We can always simplify litter. Sure. I mean, Then maybe we close the door for now, and at some point. We can try and open it again if there's some consensus and once folks are confident that it can be done safely. Okay. So speaking of consensus, The two things that we wanna come to consensus on here requirements wise were owning provider sort of materialized as the straw man that presented to us earlier, the feeling I got from that, you know, the conversation in the queue there was that Everyone's on board with Straumann. Scroll in. Alright. I'm seeing nodding and no angry fist shaking. I think we can record that decision. That's very encouraging. Sorry. Go ahead, Martin. Please, please, write it down very clearly. put it in an email, send it to the mailing list and have people, like, poke at it for a little bit before -- Since since I since I made this straw man, I will commit to sending it a draft of it to the the mailing list. at this meeting. I'll I'll try and be speedy about it, Ron. Alright. And the second decision is client server, yes or no, and it sounds like at least not for now. Going, going, god. Thanks very much, Richard. we're, like, a little behind on time, but that was worthwhile. So we're gonna just keep trucking through and see how far we Okay. Hi. I'm Rowan. So I wrote 2 drafts. 1 was called transport design requirements. and the other was called the MeetMe Group Chat. And I'm gonna talk mostly about requirements in the first one?"
  },
  {
    "startTime": "00:56:00",
    "text": "Let's slide this. So I'd say transport design requirements, these are requirements on what. So they're there we could potentially have requirements on the whole system we could potentially have requirements on provider servers. we could have requirements on the abstract MLS Message delivery service, on the Mimi message transport protocol, which is we I think we decided this server to server. and on Mimi client messaging app applications or clients. So the this transport design requirements is about implications on the transport protocol, with some implications on the MLS DS. group chat is about kind of overall group chat functionality and talks more from a, like, user visible, high level policy perspective. But It the extent that this is used as input to this working group, most of this will be discussed tomorrow, but are requirements kind of on the whole system, but a a major focus there is on client authorization. Next slide, please. So in the transport design requirements, I kinda go through some of the some of the primitives that need to get sent around. from a server to another server. And the ones in bold on the the top part here, the top half. are we need to be able to do certain operations that in the context of MLS we really want to have a sort of locking or locking like kind of an action. We want some kind of exclusive exclusivity So being able to submit a commit"
  },
  {
    "startTime": "00:58:00",
    "text": "This means that if I have multiple commits that arrive near simultaneously, I want to pick 1, and one of those will be applied, and the others will get a Thank you very much. Please try again in the new epic. Likewise, if somebody goes to claim an ordinary key package, that is designed to be used once and once only. do not want to give three people the same key package by accident. And, finally, group info. Theoretically, you could give group info to people, but the purpose of getting a group info is generally to do an external join. n, n When you do that, you send a commit. And as we mentioned before, we really only want one commit to succeed, and so, therefore, giving multiple people the same group info is sort of futile. So let's not do that. We also have if we're assuming this straw man proposal that Richard Richard mentioned. have an idea of messages that are sent through say my provider, and they're going to the owning provider. Until they arrive at the owning provider, I don't really know whether have been accepted. like, if it's just an ordinary message. It's very likely that they're gonna be accepted, but it's also possible that while my message was off. on in route between between my provider and the owning provider, that someone just deleted me from the from the group, and so when it arrives, it says yeah, you're no longer a mess a member of this group. You are not allowed to send that message because you're You're not there anymore. The epic has changed, and, you know, Sorry. Have a nice day. But Finally, once those messages are sort of accepted, by the owning provider, then they need to get fanned out. So if you read Rafael's, DS drafts, This should look quite familiar. And at least we kind of, you know, Independently came to very similar, concepts of of this. not really There was"
  },
  {
    "startTime": "01:00:00",
    "text": "particularly collusion or with. maybe a little collaboration, but it's just because, like, this is kinda how you have to do it if you want MLS to work. Right. up Then I had other categories of of things that you need to do between between servers, So on the left side there, I have a categories of messages, which I call directasync messages. these are things where Like, if I want to be able to give some kind of explicit consent, I might request consent to be able to talk to to talk to Travis. And It could be that Travis is online and sees my message and says, yeah, sure. And 30 seconds later, he He grants me consent to go and send him a message. or to to set up a one on 1 group conversation. Or it could be that you know, he ignores me for a year. Or it could be that, He sees this message and then, like, blanket blanket bans me for, like, for life. then maybe, you know, besides he decides he wants to talk to me later. but but but but So so Those kind of consent messages, reporting of spam and abuse and even things like knocks, and moderation, those are all things where it's a very asynchronous kind of operation. Jumping over here. we have things which are status where we don't really care about I I could have sent status changes. I'm available, not available, available, not available. 17 times. And the only thing that people care about is the most recent Copy of that. that has a different transport properties, And then there's sort of 3 extra little things that I included in this draft that are"
  },
  {
    "startTime": "01:02:05",
    "text": "some unique properties of search and discovery, some properties of attachments, and some properties of invitation links. Next slide, please. let's hear from Jonathan first. Yep. Jonathan Rosenberg from 59 Clarifying question, are you calling these direct async because they require a user on the other side to take action. They might not be online right now. that what's in common be between all of those? No. Not necessarily. Oh. I was more thinking that these where the risk having, like, you know, doing an like, a rest style call of, you know, I'm giving a I'm giving a consent. request, I'm not going to get back an answer you know, in a necessarily a timely fashion that whether that was included or not. But isn't the only reason for that is that you're waiting for a human while wouldn't you otherwise get a timely response? It could be a human. It might not be a human, but if it was But the important thing is that you cannot be guaranteed a timely response. And so, therefore, your software needs to act assuming that is, you know, 0 to infinity is the amount of time it might take for you to get some knowledge about this. So that that's the only Okay. But I just think it's easy to understand, but I I I understand your point. Okay. Yeah. And, I mean, this is, like, a 0 you know, taxonomy here. Right? didn't expect to get it perfect. Next, Okay. So I just wanted to call out a a handful of the implications that were discussed in this document, So one of them is that provisional and fan out messages between 2 gatekeepers, could amount to millions of messages in a minute. And we really don't even with something like, you know, even with HTTP"
  },
  {
    "startTime": "01:04:03",
    "text": "HTTP 3, we're not gonna be, like, sending individual like, here's a message. Here's a message. Here's a message. Here's my oh, yeah. I got back at 202 except it. You know? I I kinda there's a there is a tendency to think in in sort of HTTP semantics. And I just wanna say, let's Let's try not to think about that. maybe you use some you know, I sent some stuff and I got back at except message, for a big blob of things. But for individual messages or events, I think we should try to avoid thinking in that in that transactional way. And and think about, sending blobs with a bunch of messages, and then Asynchronously, we get back information about what know, what happened with request that you sent provisionally or were fanned out. These are the same thing. This is the same thing. Like, like like, htp3 allows for serial multi streams. there's no meaningful difference between I sent you this, and I get an independent response, or I sent you 57 things, and then you sent me, like, with these 5 succeeded 57 things or 57100 things. No meaningful difference. I mean, Martin, it's just gonna be go ahead. Okay. Like, the whole like, I I it's, like, I'm it's, like, a boosted HTTP transaction semantics. Okay. I think it might be worth hearing from people who are you know, if there's anybody who is operating a big a big enough network, comment on that, I would certainly be curious to hear their impression. but but but but I think Jonathan 1st. from those Yeah. I mean, if you're gonna send a 1,000,000 request, send a 1,000,000 request, And if you need a response to every single one of them, then you'll get a response to every single one of them. And the batching thing,"
  },
  {
    "startTime": "01:06:02",
    "text": "particularly for things that potentially have independent, action, action, is problematic. And if you need to send a million messages per minute, and your servers aren't big enough or something like that, just put more servers on. that's usually the strategy that we use when it comes to scaling. I mean, that's that's, you know, relatively small. So should be alright. Yeah. agree with that too. At the end of the day, the semantics of the protocol require a response each individual action. we now have transport protocols. Thank you. I'm not or MDT Group. that work pretty effectively at large scale without without the traditional overhead of connect TCP and TLS connection setup. So all we're doing is inventing another layer on top of a protocol that already solves a problem. So I'm I'm not in favor of the first bullet. Thank you. So Alright. 2nd bullet is about ordering requirements. So there is a I'm making a few assumptions about the way in which in a common way in which delivery services, are would be built I'll discuss those in the next slide. I mentioned for sending commits that when we send a commit, often there is there is somebody who's added, and so if there's a corresponding welcome, we we It is I think it is extremely beneficial. and efficient to staple the welcome to the commit. And, likewise, to staple the group info or something resembling the group info, to the commit. so that so that a new joiner that wants to to use server assisted external joining, it's can get access to that in a single operation instead of having multiple round trips. at you know, and feel free to read all about it in the document and there's lots of discussion about that on the MLS mailing list, and"
  },
  {
    "startTime": "01:08:01",
    "text": "some stuff about that in also in the DS draft. Another efficiency thing that I call out is key packages. if I'm going to fetch key packages for a I want to add several people at once. and Some of them are on provider b and some are on provider c. I think that it is would be quite logical for me to be able to ask for Okay. Here is a list of users on provider b. Please give me Key packages for for one each of the clients with these properties for those users and tell me if some of them or, you know, if I can't have some of them. as a single operation rather than having to ask for each key package one at a time. You may have a similar response to number 1. Has included previous conversation. Yeah. avoid trying to bundle things together where there is no what you're looking to do is is cut down on overheads or something like that. Usually, what find we find is that it's just so much easier to be able to say, want key package for this person. I want key like, individual transactions where those have individual outcomes. bundling of those sorts of things is fine for something like Stippling related information together for the same transaction, but when you're talking about essentially separate transactions, separate requests. Please stay for a follow-up question. Yeah. at, So if I have to ask for key packages for all of your clients. just for a single user. I don't necessarily know. clients you have? Right. that's that I think that's different in that case because that's that's a single transaction. It's a request for all of the key packages for all of the clients of this person. I think that's that's fairly straightforward. When you think about the case where you're asking your provider to provide"
  },
  {
    "startTime": "01:10:00",
    "text": "to to go off and find key packages for people on different providers. No. No. No. Not on different pro providers. I don't Multiple users on the same provider. it Yeah. So now you're talking about a search effectively as as the as the outcome. That's potentially something you could do. I I think the distinction here is am I providing a list or am I providing a patterned, patterned in front of your pattern -- A list. Then there should be separate transactions. Like, I mean, like like, I just, like, wanna say, like, the model Like, it it just is it seems like the underlying Mall of HDP that is in play here is which is, like, know it used to be expensive to run HTTP transactions, but now it is cheaper than HPP transactions. It was expensive as fulfilling them. And so If you try to break if, like, taking all this stuff and gladiator like that, just means it's atomic from the perspective of the server, which means it can't fan it out. So it's actually I mean, I'll refer to somebody as a CDN expert, which I am not. But my understanding is you'd be happier if you could fan it having them all glued together, so she makes the problem worse and correlating the client request to the multiple server requests. I'm not sure I understood that one well enough. Yeah. So in the scenario where you have to do multiple things, as a as a server to to server response. Mhmm. you're in a situation where you you receive a request that says, do the following 10 things. you then have to do all of those ten things before you can answer it all. Whereas if you so if you have 10 separate requests, do this, do this, do this. You just go off and do all of those things, and the responses come back whenever come back, and there's no Latency, you don't have this headline blocking problem that we spend a lot of time trying to fix in quick. And and if you are if you're the provider that is interfacing with the client, and you need to likewise wait for all of those things to come back. before you can. Yeah. Please avoid doing those sorts of things. Try to break them down. so that every single transaction is"
  },
  {
    "startTime": "01:12:00",
    "text": "disgrate. And and I think to to echo's point before, if you're if you're talking about a search, where where you're saying please give me all the things that make these criteria. That's that's different. because you don't really know what things you're gonna come you're gonna get back. But if it's a list then those are separate transactions and and a better served as that. Okay. in a Okay. wanna we wanna hear from Thomas, and then the queue is closed so we that we can move on. this will be I just have one question around performance versus architecture. I understand why they're coming at it from their angle. but I think it ignores the performance and latency issues that might exist in real time systems. where you're not able to either manage the band with any other way back through batching it. or through managing the transactions 1. And if you've preclude batching, you can't manage it. nearly as well as you could if you included it. So Yeah. Sure. So here here's an example. I'm a sub. I'm underneath the navy. I've got a lot of stuff that got put to the satellite in back over to New York. And so in that case, performance characteristics are much better if I batch it. Otherwise, another one if I'm a a very chaotic network, a lot of things going in and out. by me having transactions that some people are paying upon, but not others Yet having one complete thing would make it a better example to have one request, one transaction. Right? So I'm just worrying I I guess my question is, is the issue here and it seems like you're you're uncomfort with it is the issue here that you can't provide the performance management you'd like if you can't send them in bulk. if I if I Yeah. So it's it's about the overall system performance. Right? which which"
  },
  {
    "startTime": "01:14:00",
    "text": "yeah, we can we can we will have vigorous discussions about in the in the bar and later. Bye. Thank you. I mean, I guess I just Maybe we start this later, but, like, I don't finish in the batching point. The way this works in h three is you just You blot all the requests over the wire. And you've said you've said you've said As fast as you're like, we go and the session will all sustain. think either of those are one thing or or is is there anything you can do first? You've said that. Yes. The last thing I wanted to bring up was joining via link. So I think this is a common model for people to join, I think we need to have at least a way. that. somebody who gets one of these things from a different provider that they can they can join successfully. So go to the next slide, I'm just going to not gonna talk to it. I'm just going to say, but These fan out and ordering requirements are listed the document, If you have any concerns about ordering or head of line blocking or any of those things, please read these carefully. And That is that is that concludes this today's thing, and I invite the next person. Thank you very Alright. Thanks, Ron. Okay. Now it's a linearized matrix. Right? everyone. As the agenda said, this is, I think, Travis Rosen and or Matthew Hodgson, and we're gonna do. And albeit not at the same time, which means it will be anore. I'm Matthew. I'm Travis. And we wanted to talk about the the Travis is mainly put together around linearized matrix, as a transport and overall framework for Mimi. I have to see next slide. And to say next large, So before we jump into what's changed"
  },
  {
    "startTime": "01:16:01",
    "text": "since IETF 116. A quick reminder of what linearized matrix is So this is a subset dialects of matrix. which, as I mentioned, on the microphone earlier, is a effectively a hub and spoke model. for Matrix, which looks to fulfill the requirements that we were just discussing. on the transport side of things. What we did for IETF 117 is to go and make it completely self contained. because previously, we're basically linked out to the matrix expert to say, hey. This is what the subset would look like. Instead, it all got put into one great big eighty page internet draft. reason for using a single monolithic one, was that was, like, guess the employee well, the implied idea at the time to expand it out to be self contained it could equally well, they'd be split into various different components But, critically, there is zero dependency on the external matrix there. loads of useful feedback from Jonathan and many others on the drafts. So thank you very much, everybody. And most interest we've been busy writing code. So we've now got 4 different interoperable actually, free and different in intrappable implementations of linearized matrix. First of all, we've got Eigen server, resin by Travis, whether it's Matrix, Hurion, which is a really simple typescript implementation. The real toy presentation. That's about 1000 lines of code from memory. which is the No. It's completely self contained for that. Then in the last couple of weeks, we've also taken synapse which is an existing matrix server and made it dual stack it can also talk linearized matrix as well as normal matrix. which has many been done by Patrick Cloak, who works the element. Now, finally, we've also got In fact, this is the right version of the slides. As no. I think this is an earlier bush."
  },
  {
    "startTime": "01:18:04",
    "text": "Yeah. This is the it's gonna be an anticlimactic version of the that There's all of the big reveals didn't happen. Because, basically, we did a hackathon as part of IETF this weekend. to go and do more interoperability and the I don't see it. The big tech gatekeeper gets revealed in that. my register comes to the microphone. Yes. So so so Matthew, it's it's very plausible that you can take a very general protocol and specialize something specific. So, like, these Synapse and Danderite ones don't see, you know, Oh, yeah. Less convincing of my mic. Oh, I totally agree. So Have you done has there been much implementation work kind of in the other direction kinda starting from nothing and building up to LM? Well, at the risk of spotting the froze because we're trying to find the right deck. The work that we did on the hack than with with the Google Android messages team who did an in independent implement most evaluating linearized matrix. This is no commitment from Google to use it or anything. It's just playing around for interoperability. and that was with 0 input from us. without using any existing matrix code base. implemented purely based on the contents of the linearized metrics draft. And we sort of looked on to see how that was working, and by the end of the act, then it was working. and you got some screenshots from that in the right portion of the deck if we can find it. Agreed for cheating with the dual stack version of Sun App speaks. We already have the objects then flying around. So we're coming from of the prior arts of the existing protocol. that's why it was important that I can server is completely effectively clean room, albeit cheating by getting Travis to write, so he's an expert. than the Google 1 is even more interested in terms of being a third party implementation. I'm gonna start filibustering live parks and recreation at this point, unless we have some slides. Sorry. It's not my fault. It's Firefox's screen sharing buttons. Okay. I can do in terms of dance or we could even just continue talking through the deck. the overall"
  },
  {
    "startTime": "01:20:03",
    "text": "Why Travis? What is the overall architecture? Imagine, if you will, on your mind's eye, a block diagram And what we've tried to do here is to really concentrate on the interoperability of Mimi. Like, mini is literally more into messaging interoperability. frankly, we're trying to go for the most boring tech pragmatic approach possible. And at the bottom, you have at least for now, a plane of HTTP REST fool APLI. Then you have an encryption layer on top which is obviously we'd be using MLS, but it's worth noting that a unique thing on linearized matrix is that it isn't a hard dependency on MLS. So for the Google interop, we've done double ratchet because that's what Android messages says today. you could remove encryption entirely if you so desire. And then on top of that, you've got payloads for actual messages where we're using metrics, event format, which exists today. And Here we are back in the room. Yes. This is much more of the slides I was expecting to be presenting. So we ended up only with 3 implementations in the hackathon. I can service. I'm doing 5 synapse, which is Richard. points out is cheating and then Android messages, which is not cheating. as an experimental showing an an existing stack, We've also had interest on the mailing list from Cloudflare. who got on the wildebeats team we're going and playing around we're doing a cloud for their workers based linearized metrics implementation. also an outfit called IAM mail breach tabs. You're based in Canada, I think. who are also looking at this. Next slide. Please. So it is a quick horrible screenshot. showing that synaps to item server implementation. You've got Element Web on the top left, talking normal matrix to synapse, on the bottom left, talking linearized matrix through the eigen server on the bottom right."
  },
  {
    "startTime": "01:22:01",
    "text": "then on the top, right, not that you can see the tool, there is the very, very, very crappy command line client to exercise a sort of fake client server API because client server is not in scope here. order to talk all the way through. The next slide's probably more exciting. Richard's in the queue. Do you wanna take that for you, move on? Guys, friendships, Okay. So here's another one. This time, showing element talking to Sun App. which then talks linearized matrix over to Android messages, and you can see Android messages there on the right hand side, at least getting messages from matrix to the Android side. think we might have got it working the other way now today. Or when I say we I mean, the team at Google, getting messages flowing the other way. again, it's a real life. version of this, and this is a couple of weeks of work. given that the draft was only published about 3 weeks ago. Oh, Ellie July. I'm the Google site. And I can say that it was about a couple of days to implement. So that's the kind of level of boring to keep it simple stupid that we've gone for. Next slide, please. This is the bot diagram I asked you to envisage earlier. So, hopefully, definitely matches what you were conjuring up in your mind's eye where you have linearized at the bottom server side, and then you've got MLS, but you could have other encryption, layers on top, and then you go up message contents on top of that. As I said, this the the silicon server implementation is dead simple. It's pragmatic. It's also proof of messaging transport given that it leverages all of the proud of the matrix, and then you just put MLS on top. linearized matrix uses group management, it says, which is provided It's linearized metrics is providing the group management, and we'll talk about about that in a minute. next slide. This should be pretty familiar, and we are talking about the amazing acronym with the CSSSSC. Architecture, he began to set proteasiums. This is bouncing off client to server to server to service client."
  },
  {
    "startTime": "01:24:04",
    "text": "with a hub and spoke very much matching, Gretchen's straw man familiar, which still not gonna complain. Next slide, please. I'm gonna hand over to Travis for the sounds of it. Alright. So room versions are what we pretty much used to define the different policies or access controls in the room They need a better name, as is mentioned at the bottom of the slide there. But the overall idea is that if you want to change anything to do with the access controls, you do what is equivalent to re in it in m MLS. So you just abandon or delete or whatever, the existing room or group, and you just create a whole new one. that allows for consistency on all of the different providers and all the different servers in the room so they know all know exactly what the ASLs are. they can't change, although they can be configured in many cases. But that's kind of the the rough idea there. questions before we move on for what that does, It's the other roof mechanism. Yeah. I'm not seeing anybody just jumping up. So next slide, please. we are in the next slot. Maybe. and time. Everybody in there should hope having some price. will take the blame meeting the slides 15 minutes before the session. There we go. Now, so events are Currently, what is used in matrix. So they are effectively JSON objects, and are just thrown around the transport. but they can change shape. they they don't need to be JSON objects. There's a lot of base 64 encoded binary in there, which would be obviously represented better with, say, binary. that overall state events track the metadata in the room. So that is"
  },
  {
    "startTime": "01:26:02",
    "text": "which users are in their not necessary clients. depending on your layering there, the room name, who is allowed to join, whether you can join without an invite, with an invite, or by asking for an invite through a knock, power levels provide the access control overall. And that is the the sort of meat of how that works, there's a slide much later on where we can go into more detail on power levels. Beya, with with the current model, MLS commits are sent as Just ROOM EVENTS OR EFFECTIVELY NON STATE EVENTS. THEY ARE Just THINGS THAT ARE AMIDED. THEY DON'T NEED TO here in order. just kind of show up there Jonathan, did you have a question clarifying this? Well, I mean, our I have a comment on the MLS integration. I don't know if you have another slide or we should hold discussion to the end. I would suggest holding until the end because we have a Alright. The second half of the deck, which might be applicable. But if I can get the next slide, please. Sorry. I'm Internet is not working, so I can't really well, again, said they don't need to be made in any particular order. of course, MLS events do need to be in order. So how does that executed. So it's the idea that the event itself, since it's a container for the transport, is not necessarily a container for the room, so the MLS commits can Sorry. commits do have to be ordered. It's the application messages which don't have to be ordered. That was the the confusing part. Sorry. see how the commits are ordered in linearized matrix. It's just a doubly linked list. so you can grow up and down in a very well, letting your way. they are the actual sort of user or application messages, those don't need to be ordered. They can just kind of go around and in any particular order. Does that let me let me try to restate what I think you just said, which is that the events themselves, not have any ordering But the inside the room event, there's there's a commit message of some kind, and that hasn't ordering. No. Okay. It's wrong. Good. So I'm glad I asked. events are rotted within a room in a double length list."
  },
  {
    "startTime": "01:28:01",
    "text": "and some events to be MLS commits. you're literally layering MLS inside the event payloads within that room. but it is ordered. That way you get your commit ordering from them. Okay. So what is the thing that is not ordered then? It's it's a delivery transport side. So the messages containing MLS commits would have to be an, obviously, strict order, but the events containing non commits, I guess, or, I guess, even non proposals. with they can arrive in any particular order, but they NER's matrix draft at the moment does keep them in strict order. Okay. I think I'm still not quite getting it, but I'll I'll I'll figure it out. I mean sorry. Yeah. It sounds like the 2 of you contradicted each other. So I mean, I heard Matthew say, all the events are ordered, and I heard Travis say, only the MLS events are ordered. So Which one is it? So in the current draft, it does keep a strict ordering, but it's mostly speaking to ROWHAN'S side for specific, like, delivery requirements and the actual ordering over the transport where things can get a little bit fuzzy depending on what you are actually sending. Basically, the events in the room promoted for sure. if you want to there isn't necessarily a strep ordering of the non commit M and S messages on top of that. I I think this is very all could trying to agree with Ron's requirements to us saying, yes, we've actually compliant with that even though linearized metrics hasn't all per room level for the next conceptual layer up, doesn't need to be able to to nonagonals scripts. Correct? Okay. Alright. Next slide, please. We'll just get as far away from this as possible. So, yeah, Events currently in linearized matrix have a whole bunch of guarantees on them, so which are duplicated by MLS, more on that later."
  },
  {
    "startTime": "01:30:01",
    "text": "potentially. So, the content hashes protect the actual modification the event in transit, since it's carrying either encrypted or unencrypted contents depending on what it is. the content hashable will prevents these intermediary servers wherever they are from actually modifying that event. reference touches, cover the event itself, including the content hash, and is also the event ID. this is primarily to ensure that If, say, over a transport you are requesting from another server or from the hub, I need this event ID, doesn't just give you It's something that is legal for the room, but arbitrarily different. the reference hash in this case, because you just calculate it based off of the payload, it's not actually in the JSON object. means that you can verify that you've received the actual event ID that you asked for. Ecker? Yes. So I I understood that last point. And this was saying I had trouble with the draft as well. But the first point. I don't understand when you say protect the event from modifications of trans speaking server. Is this merely fur? Damage, rather than malicious malice, Yeah. So if the content hash were to change or be un unverifiable on the receiving end, you just redact data in basically to say remove anything that's not important from that event before sending it off to users. which traditionally a matrix means you end up with a blank message. with MLS, you have to keep a lot of the stuff. So content hash here is of questionable value, in all honesty. That exists for scenarios where you might not be using this is Right. So the abstraction that allows different encryption as on top. But I guess I'm still confused because obviously, anybody can change the message and replace their own replace the hash as well. so I don't understand what the what it's just doing. the reference hash and the signatures cover the content hash. if you change the content hash, you're effectively changing the event ID. So, therefore, you are sending an entirely different event."
  },
  {
    "startTime": "01:32:00",
    "text": "if you modify the event. I guess, if they're messing from the slide is just about that the IDs all of the ashes of the event. So so I I I do get that part. but I guess I guess, what I'm trying to get at so I guess This partner is, like, confused by you. It's like, I understand what the signature does. But a hash is like a detail of how things are created. and And, like, in fact, there are algorithms in here, I just don't really have Not any not any internal way external way. So understand what Continental storage is in the case of reference answers. By understanding what the content hashes are doing, other than serving as an input to 1 of those 2 operations. Are there anything else? Could you rephrase the question? Sure. So like I understand. So so you say that a reference hash to hash of And, again, this may be small detail, but it's, like, covered here, and it's covered in the in the document. So I think it may be more The reference actually I understand is, like, content content addressable storage so you have, like, a hash, and you can verify thing you got, Mitchell Dash. And I understand what the signature does and that and covers the entire body of the message and you see this industry, you verify it. Right? but I don't understand what the content hash does except to act as input to one of those 2 operations. So the content hash is basically saying that when the server constructed the event because it may or may not have come from a client in the event format. instance -- Uh-huh. it is saying that the server hasn't necessarily modified that. because if you later want to redact the event or remove the important details of, let's say, you know, the room name and a em room name state event, that would if you were to remove those details signature now becomes invalid because you had to redact to actually do the signature you said the word signature again. So I'm, like, trying to understand, can you that doesn't use a word reference task or signature, which is exactly my question. Okay. The reason that the Hampons and Ashes is primarily to delete data. so that you can get rid of the human representation, but as eligible and content that you leave the hash behind"
  },
  {
    "startTime": "01:34:00",
    "text": "AND BECAUSE OTHER THINGS BE DAYS ARE GOING Just A REFERENCE ASHES cover the continent hash still have the integrity. of the history of that group. Despite having deleted the human reasonable dose I'm entirely lost. please. This is Daniel Con Gilmore. So let me just make sure that I understand this. The point of the content hash is that you want the content to be covered by the reference hash in the signature. without having to retain the content. Thank you. You better than me. that lets you audit the transport and other like, the the signatures and the reference sashes without needing people to see the content. but then it corresponds to the video you have. as a public. maybe you're looking at at at logs of the of the the messages were handled. not at what is actually in it. I don't know. I I'm that that's that's my understanding of it. if you could give an example where, like, you might take action differently on the content hashes that might be useful. maybe. So I guess the idea would be that Yeah. Like, the content hash basically just ensures that THE CONTENT ITSELF HAS NOT BEEN BOTTIFIED BECAUSE THE SICKATURE only covers be redacted or all the unimportant stuff removed. SO, YOU, AS A SURVERY, TECHONLY WITHOUT A CONTENT ASH, HAVE THE ABILITY TO change the less important, but still human readable or human affecting DETAILS OF AN EVENT So let me see if I can restate this my way. which is you have these events. which consists of some set of data. you subset the incentive data. and you can do the hunt content hash over that subset. and than signatures, cover the subset Is that so far so good? think so."
  },
  {
    "startTime": "01:36:01",
    "text": "Okay. And the reference hashes are also computer of the content hashes? agree with the entire the entire data value. Yes. The reference dash covers the content hash. Okay. So So this is, like, XML D stake where we have, like, a bunch of information, but only some of it is as authenticated. The unimportant stuff, as you say, is unauthenticated. All of it is authenticated eventually, but they important stuff. if it if it if it if it if it if it if it if it if it if it fails its own content hash, say on receipts, think it was modified or whatever. then, yeah, like, you end up Just redacted the event down to basically what the reference has precisely covers. just to stop somebody from spoofing the room history and say, hey. There is invention here. which I've synthesized on this of it was here in the linked list. and you can see that oh, wait. No. The hash doesn't match because preference hash you know, it doesn't point great confidence IT'S STOPPING PEOPLE FROM scripts in retrospect, which might may not be desirable. the final thing says, a pure MLS world. You don't need these anyway because you can So in Manila. Next slide, please. Do you wanna -- -- put something in here I mean, this is probably the most interesting bit of linearized matrix in the hands applicability, I think, in any configuration for Mimi. and that it defines the policy rule system that we would discuss right at the beginning in Richard's neutral talk through the the entire sort of landscape of Mimi. The way in which metrics does it is I think, kind of nice from a UX perspective, in that it goes and assigns a rank effectively. So everybody in the So you get a number between north and a 100 which says how senior you are. Then, separately, you define the various thresholds of what people with that rank can do."
  },
  {
    "startTime": "01:38:00",
    "text": "So they can invite people or kick them, ban them, They can say policy rules. They can speak. They can And by other people, whatever it happens to be, And so you have this kind of indirection via seniority transparency, we stole this directly from and Transserves, though, access medies, people got a number from north to a 100, from that asset from the military, but the number of bits on your lapel or whatever. and say what permissions you're allowed to do in a given context. Now the catch is you don't get full role based access control on this. You can't have a huge matrix of different responsibilities for different uses in the room, But from a peer at your ex perspective, that's not necessarily a bad thing. IN VERICALLY MAPS ON TO ALL OF THE DMA gate gatekeepers, so permission models and that exists today. only scenario where we've hit the limits of it has been bridging to Discord which does have a full role based access control model where you can go wild doing check boxes everywhere to give people different permissions to do different things. But this is now, I guess, eight years old. and it's been proven in the world. as a approach for doing this, and it also gives you natural time breaking could say different levels of moderation if you're on on the HVs, since earlier. about having moderators who needs to delegate 12 ones can basically go wild defending it. defining additional levels of seniority within the room so that you always know who owns the room at one end and metal and you can be as flexible as you like in between. Lots of people seem to get scared by this because we call it power levels. rather than ranked But I'm hoping it's a really simple idea, and it actually matches quite easily. on to normal human social backing holds it. you should call it pecking order rather than parallel. Any questions about this? I'm sorry for staying on slide, Travis. better than I did. Yeah. I have a question."
  },
  {
    "startTime": "01:40:01",
    "text": "nice question. So so in the there's this notion of, like, the default power levels, which are I think, uniform essentially. Right? So for enterprise use cases, where like, the enterprise already knows that it wants to have users that have different power levels. How does this map onto? the existing notion of defaults. I guess it depends on what type of the folk you're talking about. if you're talking about the fact that by convention, we say that somebody with a 100 as an admin some dB 50 is moderator. Sunday at 0 is a maybe, and or whatever the correct expression is for a general purpose use then those are like the default thresholds. But within a enterprise context, you can go crazy going and defining additional sort of exensible roles effectively within that order, if have a super moderates or a submoderates or a sub owner or sub administrator whatever it is, and you can do that. Okay. So the defaults are configurable. Yeah. Okay. Okay. Yeah. Done. It's awesome. Yeah. Jonathan was first. Jonathan Rosenberg 59. I wanna go back to someone. I thought I heard you say which was this works for lots of things, but not discord. This is straight. So I wanna be clear on what the potential implications of that are. it means if we selected this and this piece of tech, particular. We could not include Discord in the Mimi interconnectingness, without them changing their product, I would say that we would want to expand this probably merge it with with their own So define a our back approach, which is almost the other extreme of what we've done here. on the flipside runs 1, it's only got the concept of an app man, an app man, an app man, an app man, an app man, an app man, and no note in the user. nothing in between. See you compliance down to"
  },
  {
    "startTime": "01:42:02",
    "text": "one and a visitor and a couple of others. I think it's sex and the income in total. is still concise without the concept of seniority. Oh. Sorry. Oh, sorry. The microphone is having a moment. So, yes, basically, Rowan's model, I think, is 6 different roles in the end. it's quantised to that, but, critically, there isn't an ordering concept between them. So if you want to have a pecking order of different moderators or whatever, That's out. So my jumping ahead, I think the right thing we should do is to read the 2 together, have 3 or 4 mile back for Discord. and having a pecking order for and the more enterprise y things where VP's list. So if you're not okay. So then I hear we're not actually proposing this, then we might just all down and wait for the draft. because otherwise, you get a lot of people lining up arguing that the power level linearity doesn't work. But if you're saying you agree, then we should just move on. Yep. Okay. Richard. maybe maybe there's mood given given the prior point, but I I was gonna ask, you know, it seems like the language you use when you talk about power levels here is descriptive nouns like admin and moderator and, you know, Brigadier General. I was wondering, like but but the actual things that parallels are integers. And then, you know so I was wondering, like, why why are integers the answer here as opposed to, like, enumerated things. As long as it's not as long as it's, you know, be quantized somehow. You don't wanna talk about when we've had flights to which we did briefly. And -- I mean, as long as we have, you know, 2 non commuting operators who can have or uncertainty relations. But yeah. No. I was like, are you doing arithmetic with these numbers? Are you summing them It is -- It's just a total order. Yeah. It's just ordering. And so you could do nested set if you so wanted to to express it as long as you can compare them in size. But the reason you want that rather than text labels, is so that, yeah, in one environment, you can go enable people, brigadier, general, general,"
  },
  {
    "startTime": "01:44:01",
    "text": "2 stars, 3 stars, 4 stars, whatever. And another one, you might call them VPs. senior VPs and CVPs or whatever. And the important thing is under the hood. it maps through to a number. But, also, we've really found it to be useful from a UX. but it's just a single drop down slider thing. How powerful is this user in the room? Ralphie then, alright. Let's just show you the underlying structure picture of a massive matrix, which is, like, 50 rows long and 50 columns wide. I'm frankly surprised that Discord had managed to do that without freaking everyone out. So, obviously, there is an appetite for full blown crazy hardback. at the time, we were worried about recreating NTFS access to ACLs where people just start, you know, creating a during complete healthscape of functionality. wanted to try to keep it simple. I think they might have overstayed. long story short, very open to adding in our back too and breeding it with Rowan's one, but we're just trying describe what we have today and get the bits, which are useful elsewhere, but at least Just in terms of, like, engineering 1 out of the seems like if you had some language or you had individually enumerated capabilities, obviously, you can build our back on top of that by mapping roles down to those, but it seems like you could also build like, power levels on top of that by saying, you know, that a given power level map this in in the integration capabilities. Okay. So they're like the the atoms here are the capabilities, and it's just a question of how we aggregate them. Yep. Okay. Okay. And how you handle ambiguators is if you end up with a full matrix. If you need an ordering of some kind out of that full matrix and you have define that mapping, that linearization as it would Okay. Sorry. I've maybe maybe you just spoke to this, but I just wanna get clarity on my other facile question, which is if you end up in a situation where you have incompatibility between a system that does have the strict ordering and one that does not. like, I understand you're saying that you wanna breed these things, but presumably, like, they're they've not been bred because you have situations where you don't have this this strict rank ordering."
  },
  {
    "startTime": "01:46:04",
    "text": "So, like, what what do we do in that case? Well, it solved. by the folks at this course who let you do both. not only do they let you go well. It's in a clicky matrix thing. You can also then start dragging users up and down in priority. and have a weird hybrid of the 2. But -- That's the reading -- On the back end, effectively, you're mapping from something which has an ordering to something doesn't. like, ultimately, like, You end up you end up throwing the ordering thing out the window because the thing that doesn't have an ordering has to be supported. Right? I guess it depends on the semantics of how you've gone to linearize the the free form are back thing and how important an actual ordering is. in decentralized metrics is kind of useful because we just use it as a way to see who wins in any given punch out, whereas in an all about worlds, it's gonna have to be considered for every -- Yeah. -- parameter every dimension. but you'd still get an ordering by looking at the entire vector space sort of comparisons that you're doing. if I made any sense. I think I was first just a clarifying question. So a a higher power level has strictly more permissions than a lower one. Right? Yes. Okay. So there's no way to create, like, designated arbitrarily high power level granted exactly 1 super sensitive permission. Correct. Yeah. Thank you. That is the the big limitation on the whole thing. Hi, Rowan. I think that I think I see a escape mechanism to either add add, like, sort of arbitrary number levels to an our back system or to add roles to a number system, and think we can go take that as some homework. But I think particularly important, is for us to figure out what the we want people to be able to do both, like, discord style stuff. And we also want them to be able to work in an environment where they have basic we know"
  },
  {
    "startTime": "01:48:01",
    "text": "the policy is that you have no permissions at all other than to just send messages. And the the I think the tricky part is sort of, you know, redacting the the permission that you have that you can that you can even see that that like, those those things don't exist when you're doing, like, an iMessage direct, you know groupdeemed. Right? Right? So At at I just say, like, You've given us something to, like, chew on maybe if everybody's okay, we go to the next slide and Yeah. Sure. Yeah. If I can just add on on very brief final thing here. one of the nicer things, the six points, which you haven't called out on the slide, is that the permissions are all done by event type. So you automatically get extensibility. So if you want to say people in this room are only allowed to send this type of message or until I have to send this type of message, assuming that that type is visible outside below. on the server, which is a big f. But if it is, then you can go and basically use the event types themselves. as the light was because one of the slight weirdnesses I think in your draft currently is that special cases logging and bots and other things is just additional enums, Whereas it could be tied through to the actual underlying objects. somehow, probably not due to the envelope exposure problem. 1st That's Yeah. I I can paraphrase, I think. Brad said, yeah, something Sorry. Okay. Next slide. Please I'm shorter. So, yeah, with the with the transport, so the current draft is a bit monolithic in what it does. Ideally, it would be broken down a little bit. but the current Transport is inspired by"
  },
  {
    "startTime": "01:50:02",
    "text": "Matrix's 2014 era design. and we're actively working on a Grpc replacement just as a technology to sort of experiment with. currently it is HTTPS and JSON. Again, just to sort of baseline test what we wanted to achieve a hackathon Other alternatives include, obviously, anything more restful, web sockets, something streaming based. but it looks like Jonathan has some questions. Jonathan Roseberg. I I guess, are we GRPC, we have not generally done, I think, here in IETF. I I think it's I actually like HTTPS plus JSON. It can be compressed on the wire and all that good stuff, and it easy. Let's not let's not turn into a transport war by picking something better than HTTPS. JSON. That's my opinion. Thank you. Thank you. Fair enough. There is some precedent in IETF for at least GRPC. I can't remember the exact RFC number, but it It is out there. Is it a standard tracker, RFC? Yes. Alright. It's rfc 9232, I think. I'm Send send put it in the chat. I mean I mean, I mean, unless there's a unless there's an RSC, which specifies share and their campaign RFC, which is your which uses Grpc. We'll look it up later. literally anti free too. and it just references out to grpc.i0. And the reason is practically speaking in terms of running contests and awful lot of GRPC flying around what's the what's the status? What's what's 9232 Yeah. So -- Yeah. -- just as a as a process matter, you cannot have seniorshark RC referring to GrpcIO. So so if you wanna use Grpc, so we'll have to taste Grpc and turn it into RFC. Or -- Something. -- or something. Yeah. So, like, don't actually match up being at Grpc proper, but, like, I'm just saying, like, that's the that's our consequence of using Grpc. Okay. That's expressions. Awesome. Yeah. I mean,"
  },
  {
    "startTime": "01:52:02",
    "text": "Sorry. This is really loud. Last one I'm forwarding from Google. So, I mean, I think it I think what we wanna kinda look at instead of just kinda make it a transport war is just kinda make it what is the thing that makes the most sense from a from a trust perspective. Right? What is the thing that is most optimized? I think Jason and his CPS are great, but it's not necessarily, like, the most optimal thing for my from a scalability point of view. And so we're looking at something that that was a little kind of scale as more binary that because it's a little bit more strictly typed. that allows us to be able to you know, be able to interrupt effectively. Like, having come from an CS world where we everything is, like, SIP based, and everything is, like, loosely typed. Those interop projects have been, like, really expensive. kinda looking for something a little bit more prescriptive is hopefully gonna be a better thing. Now if if it requires kind of being able to RFC or, like, a Grpc something similar. I think that's something that is possible we can kind of explore. Yeah. There's a 2016 draft. -- years ago, then number 1 But this might be an opportunity to fix it. And, honestly, the feedback that we've had and the the big tech companies, not just Google, who we've been working with on linearized matrix. is, seriously, if you're gonna be putting 1,000,000,000 of messages billions of users, please? Can we not use HTTP and Jason Awesome. Yeah. There there are other alternatives to to Jason if if performance is a concern, One of the nice things about HDB is that you have the ability to negotiate which format you want wanna use. and one of the that it's possible for instance that you could use seaborne with some sort of data model that be expressed in either Jason or seaborne, which is an an interesting way to potentially approach this sort of thing. I don't think you have any really fancy requirements for the sorts of things that you're shuffling across these. it's probably gonna be very portable and likely very efficient in that regard."
  },
  {
    "startTime": "01:54:01",
    "text": "Agreece. Agreece. Agreece. Agreece. Agreece. Agreece. Agreece. Rafael? Yeah. Just to answer the attorneys, we've been using in MLS. And, obviously, TLS as well is the TLS codec. that's now also appearing in some of the drafts in the delivery service draft. I think, Roan, also in some of your drafts. So advantage of that is that it is strongly tight, and it's extremely compact, and it fast to serialize and deserialize as well. So it should meet some of the requirements for Grpc. and works well over HTTP channel. We've got 1 minute 8 seconds left and probably no more time for the content wars, but And my last briefly, Shanti, this one, So the elephant in the room where I think somebody referred to at the beginning, Jonathan perhaps, was where does MLS fit into this? in the honestly linearized matrix right now is layering MLS on top for encryption. It also supports double ratchet. Right? The Google one of the Google integrations is using that. for fragmentism. obviously, that represents experimental work in supporting MLS out of band for maybe Now at moment, the membership is being modeled on the service side. and membership is trapped by the server. Obviously, the use messages went encrypted. The linearized matrix authorals can be applied both client side as well as server side. or police oversight. is needed. but -- But for Rafael's and the mini d s discussion, it's really interesting to try to figure out how you can use MLS itself for the group membership and benefit from the MLS permissions. for expedience and pragmatism in this draft, We're just using plain old non encrypted matrix, effectively for managing the group membership. And the idea is that if a bad actor appears, because the server injects them into the room, then you use some device verification to"
  },
  {
    "startTime": "01:56:00",
    "text": "spot the about actors and jokes and messages in, or there's been asked to be added to the group, and, your client shouldn't be encrypting for people that it doesn't expect to encrypt to I think that might be the last slide. Is it? How are you doing on time? 4 minutes. I think we should discuss among animals. I mean, is there are there no No questions or comments, comments, comments, mean, this is probably the single biggest question for this mini. working group session for IETF as a whole. like, should MLS be layered on top of the transport, or should it be actual sort of underpinnings for all of the operations of the Broxico So I I don't have a firm opinion on that one. I'm probably not the right person to about this, but what I did here earlier was a very long series of strong arguments in favor of not having MLS be optional. And I just wanna make sure that was repeated in my -- It's it's in there. It's It's not optional one way or the other. how do we do the layering? Yeah. Questions like but I think what I what I heard earlier was that there was maybe I'm mishearing you, Matthew, was that you were suggesting that you you designed a a transport that could have MLS be optional as part of that. Now, of course, the charter requires that we deliver something with MLS but that doesn't mean that we deliver something that always does MLS potentially. I would be very much in favor of only delivering something that that only does MLS based on the discussion that I've heard thus far. that may simplify a bunch bunch of things as a result. So, I mean, it means that the whole thing would be hard coated to MLS for time and memorial. and this may well be a good thing. it to quote some indeed wise who may be signing up a microphone, It's something that one could possibly vacillate. So in terms of whether it's a horrible airing violation, whether it's a stroke of genius, have all of the security properties in one place. and in the"
  },
  {
    "startTime": "01:58:00",
    "text": "layering violation perspective, you can almost think of it as imagine a world where TCP was hardcoded to IPSec rather than ID. That's fine. think my point there would be that you do have to plan for the eventual replacement of the thing that you build in this first version, it's not gonna be perfect. And at that point, you can do a different thing at that time. But this thing, can do MLS always. So we have 2 minutes. So keep it short. Yeah. I I would like you to imagine a world, Matthew, where HTTP is stapled to PLS. which happens to be the world that we live in. And I I think that the fact that we failed to do that some earlier versions of HTTP. Like, it took us some ratcheting to get there. like, caused a lot of pain over time. So I think we've discovered that the right answer is to staple the security layer. The other interesting bit of HTTP history is that, like, the HTTP, if you scroll back in the RFC archives, like like like like HTTP explored both of these paths. There was a version of HTTP think it was called shgTV, I think. because they might be on it. that encrypted the other protected the payload, did the crypto on top of HTTP. and that's not the world we live in either today. This was -- Rafael. Rafael. Oh, no. Sorry, John. and then I'm Jonathan. That's Raphael. We're usually not confused. Jonathan Rosenberg. 59. So I'm still deciding whether I think this is genius or crazy. I mean and I I do think it's worth enumerating pros and cons of we should be realistic that has pros and cons and, like, enumerate them. The, obviously, pro, which a feature or a bug is it definitely makes it more swappable. I mean, you just like it or not. Like, you just did it in an in because because the protocols are not strongly coupled together, which is a pro and that allows this testing and some flexibility in the con is whether you stated in a document that must use MLS, you will make it easier for people to not. The there's a definite con, I think, should also, you should think about is that"
  },
  {
    "startTime": "02:00:02",
    "text": "It results in semantic duplication between messages. Mhmm. Right? And so you and that means that you what happens if the server rejects the join message at the LM layer, but but the commit message gets proper it on. Like, this gets weird, whereas the other draft, like, puts those things together. So I think we need to fully flesh out the the pros and cons. I can see why you would do this because it's the easiest way to add MLS to Matrix. It's not just that. It's also from the DMA. perspective that the timelines for folks like Google or anybody else to use this are much, much shorter we're talking May or March. That's what? Feature or bug is not obvious with this thing. precisely. There may also be room for both. like, when we were discussing No. Some superpositions of No. I think there is both room for MLS Bedrock Meaning Diaz, as Rafael is about to very cogently make a case for as well as a crappy short term pragmatic approach that people can, like, throw up a server in a thousand lines of code and use it today. And it's a bit weird from a mini working group perspective that you would have. a sort of short term pragmatic compromise solution as well as the one true platonic ideal an entirely cryptographically based messaging protocol, like, mini ds. I'd love to know within the context of the working group and IETF, and probably not in the session, but Wednesday as well. Yeah. How the hell will you square that circle? Rafael? Yeah. listen on the MLS a bit. Apparently, everybody already knows what I'm gonna say, so I won't disappoint. I think we should start with security first. because in general, you cannot just bolt on security to an existing system and then assume it's going to be secure. I've gone through the process myself at wire, essentially, we didn't have end to end encryption at the time. Added it later, it was super painful process, a lot of compromise, and just not as good as if it had been done the way around. MLS, we it took us 5 years. We have a lot of"
  },
  {
    "startTime": "02:02:01",
    "text": "have had a lot of input into that process. So that I think and I think I'm not the only one that MNS is a good starting point. and it doesn't preclude to do any of the rest of the functionality on top of it. We should start with that. So I I don't yet know what to think about the this precise technical question. but on I wanna echo Martin's point, which is, like, it'd be super important to not be possible the encryption. And, you know, less worried about what happens if it's like MLS, you know, or ZLS. whatever it is that we call them us, that'd be fine. think to Richard's point, the properties that have made it you know, hard to decouple you know, if you think about, like, sort of, you know, like, HTTP and TLS followed by WebRTC followed by quick. like, what Mesa's hearted a couple is, like, the tight integration conceptual integration between the between reading concepts. I think what I would say here is whether it's, like, above or below The important thing is that we shouldn't, like, should like, in not be designing the decoupled. We've been designing so that so that we get the maximum amount of security as Rafael is saying, if that means coupling, then that's coupling is the right answer. And the consequence will be hard hard as entitled. So we shouldn't shy away from coupling just because it seems like, oh, we might wanna be bounded I felt Oh, okay. Yeah. I don't know. Bohan Baker. Oh, kinda -- I strongly please do not couple them directly. I'm currently trying to get WebRTC to do something with Post Quantum crypto. And I can't because everything's welded to DTLS. And the only way that I can get things to happen the way that I want There would be I've done a pit post quantum key exchange, and I can't use the output of that. to get a post quantum secure WebRTC communication because of"
  },
  {
    "startTime": "02:04:00",
    "text": "the assumptions are built into the stack. So what I would say is that, yes, say that you have to encrypt The message is end to end with a symmetric key. but allow people to put in different ways of establishing that symmetric key don't weld it to one particular choice. Right? We know that, you know, MLS was based on one set of assumptions. Yep. Yep. We don't know what the crypto we're going to be using is in 10 years time because the post quantum stuff that we're using today We have available today. May not be that stuff. MLS may not be the way to do things. 6 You know, MLS never use threshold. It has a particular set of security goals baked into it, and those goals are not out of the ones that you want for every single application of end to end secure messaging. And so please don't weld it together. okay to say that you've got to have end to end. encryption, but don't insist on one true way of getting the keys. Con Conrad was next. Sorry. You -- 100. Yeah. Oh oh, jeez. Just like -- Go ahead with Conrad. Conrad. Well, I could just go ahead. Okay. Sorry. Can you hear me? Rowan. Yes. Go. Go Sorry about this. Yeah. So On the one hand, I want to, like, address this notion of, you know, decoupling or coupling I mean, in the end, both MLS is versioned, and there can be later versions of MOS at some point, whatever protocol we build billing is going to be version, hopefully, so we can have agility there, and we have can have upgrade paths there. So I don't think any of this is set in stone. And second The second thing I wanted to address is this notion of a kind of temporary solution. I'm a bit dubious, and I guess we'll"
  },
  {
    "startTime": "02:06:02",
    "text": "would have to see how this works. But if we bake MLS into into the linearized matrix draft. I'm wondering if like like if at that point, we have succeeded in doing that, we don't already have more or less a d s and then isn't that the same where the same amount of work as just you know, building the and the MLS d s in the first place. But, yeah, it's trying to look at the only thing. Yeah. So in the hackathon, we did experiment with going in picking MLS in on top of linearized matrix, and it did start to look an awful lot like Mimi DS in terms of the it's basically a convergent evolution in terms there are only so many ways. which you can actually drive MLS correctly. The question is more, do you call out to that from the bottom layer, or do you build the entire thing on MLS as the bedrock Yep. Yep. Rowan May. So I'm just gonna say, if we don't couple MLS to this version of Mimi. then we're gonna have to have a bunch of extra authorization rules about where we where we're comparing what was in the transport layer to what was in MLS, and we can no longer rely on a lot of the nice features of the agreement, agreement, inside of AMOL scripts. So for that reason alone, I'm pretty keen on doing it. MLS only. for for this version. doesn't know examples. Okay. Thank you. We'll be back on Wednesday. Mhmm. Thanks. ship Yeah. Thank you."
  }
]
