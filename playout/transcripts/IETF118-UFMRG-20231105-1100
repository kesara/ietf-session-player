[
  {
    "startTime": "00:06:55",
    "text": "I hope the ping is bearable. That it should be. So I have this TCP model here. Can Let me wait a bit. Can I should speak in this microphone, I guess? Right? So, hope it's readable on the screen. I think It is. You see here are 4 rules. You see it in line 4. 9, 14, 19. And each rule reflects that a transition is happening that some usually protocol participant is doing something. In the first rule, you see that someone is sending out the sin And this out means you just send something over an insecure network. On line 5, you see a precondition to this rule. This precondition, defines when a participant is allowed to do something. In this case, there is no precondition which means"
  },
  {
    "startTime": "00:08:00",
    "text": "we can always try to establish a new TCP connection sending out a sin in line 7, you see the effects of this rule, which is descending of the sin, and a bit of state memorization, which is here state l s weight. This label is just a user chosen name, so you could write anything you want there. And then in line 6, you see a little labor. This allows me to later refer to this rule being executed. And then in the other rules, you see the TCP 3 way handshake unfolding, right? So in the rule Cenac in line 9, you see that a participant now sieves the sin, they in sin And if they're in sin, they're out a cenac, and they also memorize some state. And then in line 14, you see the accrual now the originates participant who was waiting, receives the cynic, outs the act. And finally, in line 19, you see that, the participant is receiving act, and the protocol ends. So I put the end label here. Yeah? This model is just to show you the the rough syntax of chairman models will look always roughly like this, but more complex. So now let's go to the second important part of Cameron, namely the Lemma or the properties that we want to express our about our properties. So I wrote 2 lemmas, You see it in line 2428. The first Lemma says there exists a trace such that there is a begin and there is an end. So what I want to express here is we can actually execute the Cenac protocol. It works. And the second Lemma is called bulletproof where I say for all traces, whenever we begin, Then we also end later. Yeah. And you could now already think about whether you think that this lemma holds. What I will now do is"
  },
  {
    "startTime": "00:10:00",
    "text": "I will fire up my cell here. And and try to remember the to maximize it here. So I will go into my in the solutions folder, and I will start Tamarin. In interactive mode. In the current folder, So this is just the command to launch tamarin. Then I get a little link Here, to the GUI that Cameron has. And there you see the solutions for the other exercises well, but here's the TCP hand check model. I click on the model, and now you see things. So the important thing that that, I would like to focus your attention to in the beginning is that you have these 2 lemmas year. Right? Exactly the Lemus that I showed you earlier. There's the lemma that says things work, we can execute the TCP model, and there's the Lemma bullet proof that says whenever we start a TCP hand three way handshakes, it also finishes. And now I will ask Cameron to please prove these lemmas for me. So to say that our protocol model actually provides these properties. We have this nice little auto proof button here on the right. And if I hit it, I want you to see is that it's green on the left hand side. Oh, let me screen, which means it's true. Don't worry yet what you see on the right hand side. We'll get into that later. This means, yes, we can execute the TCP free reinshake within our protocol model. Now for the bulletproof Lemma, whenever we started 3 way handshake, we also ended. Let me try to prove it. Darmen says, no. This is not true. It can indeed happen that a TCP3 way handshake doesn't finish. And what I want you to see is that the lemma is colored in red. Yeah. Again, on the right hand side, we will go into that later. Good. Any questions, nonetheless, about this, example so far? Before I dive into more details. How do I see the not necessarily true 2nd"
  },
  {
    "startTime": "00:12:00",
    "text": "I from a gooey perspective, you see it because it's red. Yeah. Red means it's false. Okay. Any other questions? Then. Let me continue. And that's set up again. So let me explain you a bit what happens under the hood. Yeah. I showed you these rules earlier. The rule on the left hand side models that a participant starts a TCP 3 by handshakes by sending a sin and the rule on the left hand side models that the TCP 3 venture continues by receiving a CIN and sending out a CIN What do these rules actually mean beyond intuition? So one way I like to abstract how Tamarine work another kind of is like, imagine you have this box. Okay? It's in the middle here. And this box, models your global state. We are allowed to apply a rule that models some thing that our protocol participants do if we find the precondition in the box So If you start with Tamarin, the box is empty. Don't have state. Yeah. This means we are allowed to apply the syn rule because the left hand side or here the the up the upper side of the SIN rule is in the box. Nothing's in the box. We're good. So what we can then do we can add the things on the right hand side into the box. Left hand side is in the box. We allow to put the right hand side into the box. So now we have this state Alice Wade and the out sin in the box. Now some magic happens. And Tamara turns this out into an inn. worry so far why this happens. Yeah. But Tarman does it for you. Don't And now we see a Now we can also apply the Synaccrual we have the right hand side in the box, so we can take it out, We match it. To the left hand side of our right rule,"
  },
  {
    "startTime": "00:14:01",
    "text": "We take it out, and now we are allowed to put the right hand side into the box again. So we have the top weight and the outside next in the box now. Yes, please. Is it a one to one or do you have, like, can it started 3, 4 things. Just one Yeah. You can you can apply the rule how however much you want So maybe 2, I think what what you're going for his, like, terminus in general, unbounded, This means you can have arbitrary many pre parallel protocol sessions and arbitrary number of protocol participants Yeah. I did some abstractions here. To to give you an intuition for how things work. There are some subtleties that I put under the carpet. So now for some more nitty gritty details, I showed you how we can send messages that are these single quote strings. Yeah. So what are the values that we can actually use in Cameron. Terman provides 4 kinds of literals. You might say in a programming, language style. That values can be constants. That is what you just saw. Constance are strings and single quotes, they are not strings. Don't think of the you cannot concatenate them or whatever. It's just the It's just a constant value. Yeah? Then we have unguessable fresh values. These are explicitly denoted by this little tilde. And fresh values can only be learned if you explicitly learn them. So you can never guess the fresh value. You have to get it from somewhere, in order, to be able to use it somewhere else. And usually, we use fresh values to model things like symmetric keys or passwords, right, things we expect our adversary to not know unless they it got gets leaked somewhere. Then the third thing, our public value isa denoted by the little dollar and public values are As the name suggests, public, That means"
  },
  {
    "startTime": "00:16:00",
    "text": "everyone knows them Yeah. But they are not so that they can take different values, which is the different to constants. And then finally, we can combine these things through function applications. So if you have 2 constants, you can combine them in some What kind of function we will see now? That one will see soon. Yes. So so Phoenix, just for the recording, can you repeat the question? people wanna go to the mic? Oh, yes. Or or else if Probably just I think with these, Benetias. Public private keypads? So you didn't good question. Ah, sorry. Question was, how do you represent public private keypads? Good question. I will show you with one click. In general, let me just make a remark. So if you use a variable x somewhere, it can be anything of the above. Okay? So you just write in variable x, you say, well, it can be whatever. I don't know. Could be function application with the public. Most of the time, this means the adversaries are allowed to choose it. So how do you actually model things like public private key pairs, I hear you ask. Let me jump into it. Tamon comes with something that is called the equation of theory. And this is a very fancy word to say we model crypto things. Here, you see the equation of theory that models what how signatures work. M, m, First, you see 4 functions. And the functions are defined with a name and an arity. So we have to function sign. Sign takes 2 arguments. We have to function verify. Verify takes 3 arguments the function public key, which represent public keys, which takes one argument, and the function true, which takes 0 arguments. So it's kind of a constant. And we have one equation that gives these functions some cement 6"
  },
  {
    "startTime": "00:18:00",
    "text": "whenever you define a function as, you see here, Tameron interprets it or treats it like a one way hash function. So You can only Get the value of the function if you know the arguments. Basically. You need to construct it somehow. And It's an opaque thing. Yeah. Functions only get semantics through equations, and you see one equation here that models how we abstract signature verification to work. This function says If we take the verify function, and it has 3 and it gets these 3 arguments in the specific form, then verify evaluates to true. So how must these arguments look like? But the first argument is a signature, on some message m with this with the secret k a secret key SK. Then the second argument is the message that itself. And the third argument is the public key off the secret key. So we model the relation of public keys to secret keys by slapping a function on top of it and saying, now it's the public key. And usually what's then done is, like, you generate could key yourself. You have to say you cannot know it. So we just the adversary of your public key because you're nice. And with this, we already have one model of, signature very free and, in the standard model of signature verification this is all the Cameron says about it. There are people who suggested to do more with it, but this is the standard motor. Does this make sense? Are there any questions about how values and Cameron behave? Go ahead. Lives. Well, did you model true, but you didn't model m and s pay and they have different color code. It's on one thing but patient Okay. The question was the the question was, I model true, but, as the colors of MSK are different, and I didn't model these variables, what's up there. So the colors so the color of SK that's actually confusing, I just sk is the same as m, conceptually,"
  },
  {
    "startTime": "00:20:02",
    "text": "The syntax highlighting tool and the IDE just highlights SK because it's like the standard way to call a secret key. M But to your actual question, I didn't model what they are yet. That is true. And that's because we we just don't. We just say, This we have these values, MSK, And if they are in this specific relation, like expressed to these functions, we want the thing to return true. And whenever we will model honest protocol participants, they will use an unguessable fresh value as the secret key. Yeah. Yeah. But if you didn't do that. It would be triv like, if you use public values for the secret key, then it would be trivial for the adversary to forge signatures. So, but I don't do that. They they Why not, right? So the question was, why don't we write a token in front of the secret key? I'm not sure whether you're allowed to do it. Alex, are you? Yeah. So there are restrictions tamarind doesn't allow you to do it. For reasons. For theory reasons. It's, yeah, it just needs to be general variability. Yeah. I mean, there there are some sound like there are some theoretical computer science, this now it's decidable or semi decidable or, like, in the realms of this thing arguments that tell you why you are not allowed to put the turtle there, but for now, let me just say you are not Yeah. Any cost is not fresh, would be a long are not sure if this fresh the series should hold regard"
  },
  {
    "startTime": "00:22:03",
    "text": "Any more questions? Okay. Then I think Yes. I would like to Point out 2 things. That you could have seen in the TCP example, but you probably will not have picked up. So There is kind of a standard or not a standard, but it common way to model protocol rules. Which you see on the left hand side here. And it has 4 parts. On the left hand side of your rule, you do some state read. And you do a message in, And then on the right hand side, you do some state. Right? And you do a message out. Ma'am? Ended you know, you can model your rules however. You want usually in the beginning the left of of your protocol, the left hand side is empty, but I think it's if you approach the exercise that are coming, It's a good practice tool. Try to roughly follow the model. And then I talked about, functions and and values and all these things, an important thing to distinguish in tamarind models, which is difference between facts and functions, and I would love to away from the mic. But so what happens here on the memorized something is we have a variable v here, we are pattern matching kind of the f of x into that v in practice because this is how we We model things, right? On the right hand side of it will be only memorized something, which is F of x. So if we look up what we memorized here, it will be always f of x. What I want to highlight here is that we have 2 concepts here. We have facts, Fats are the outer thing, He acquired, memorized something, and we have a function in it, Facts are the things that you put in the box. Yeah. Facts are just labels for state. For partial state, functions are values. If you wanna use a value, it might you can only memorize it with an effect. It's just"
  },
  {
    "startTime": "00:24:01",
    "text": "a bit confusing because they both look the same. Right? It's a sequence of letters. With parenthesis afterwards, but there there is this distinction between facts and functions. And with that, I would like to start you solve exercises. So I have 2 exercises, or I have 3, but let's start with the first two. The first exercises, meant to be very simple. And so that you get a feeling of how the adversary works in Cameron, the second exercise is a bit more involved where you do a bit more modeling. I will look at the time, the ideas that the first half of the workshop where you work on these 2 exercises, take 2 hours, so we should be done with this Iran 2, let me point out that there's a syntax cheat sheet. It's incomplete. But in the repository, you get, like, a a rough guided by example, introduction of how rules work, how these terms work, all these kinds of things. And the documentation of Cameron, I think, is quite good, especially for research tools. So there's the Cameron book online. I can also encourage you to look at that. And, Jonathan, Alex, and me will be running around and trying to get you unstuck whenever you're stuck. So please feel encouraged to raise your hand at any point. But I'm can also take questions now if there are any do what's the question where the exercises r, Yeah. So in the agenda, you find a link to the workshop repository. And it has 3 exercises in it, and some documentation. So it's github.com/felixlinker/ tamarindashboard Good. Then happy hacking. And so if you Yeah. Let me see how does this work."
  },
  {
    "startTime": "00:26:07",
    "text": "There we go. See Live. Okay."
  },
  {
    "startTime": "00:28:26",
    "text": "Which of course. I help her with the voice information? For the full whenever you whenever you slate"
  },
  {
    "startTime": "00:30:06",
    "text": "Yeah."
  },
  {
    "startTime": "00:32:57",
    "text": "Yeah. You're"
  },
  {
    "startTime": "00:37:37",
    "text": "front."
  },
  {
    "startTime": "00:38:45",
    "text": "Members. Nice don't"
  },
  {
    "startTime": "00:41:07",
    "text": "ma'am"
  },
  {
    "startTime": "00:42:30",
    "text": "3"
  },
  {
    "startTime": "00:46:46",
    "text": "Yes. Generic, here."
  },
  {
    "startTime": "00:52:10",
    "text": "Yeah. Sway"
  },
  {
    "startTime": "00:55:19",
    "text": "Yes."
  },
  {
    "startTime": "00:58:45",
    "text": "So we saying? Worst time, Yes. Currently at the 6 at the wells. I guess No."
  },
  {
    "startTime": "01:00:06",
    "text": "That's she's kind of created and then"
  },
  {
    "startTime": "01:02:23",
    "text": "Could I grab the room's attention for a second? It's just it's just a simple, announcement So, you might run into the problem that you see in error that involves the word guardedness. If you see this error, just raise your hand. Don't worry about it for now. Yeah. We have hands. In black."
  },
  {
    "startTime": "01:06:28",
    "text": "So you just put it on I do this"
  },
  {
    "startTime": "01:08:44",
    "text": "Yeah. All traces"
  },
  {
    "startTime": "01:10:02",
    "text": "Right."
  },
  {
    "startTime": "01:15:52",
    "text": "Yeah."
  },
  {
    "startTime": "01:20:15",
    "text": "Free. Are you were you here the whole time? So"
  },
  {
    "startTime": "01:22:29",
    "text": "8 previous Yeah. So"
  },
  {
    "startTime": "01:24:21",
    "text": "No. My chances."
  },
  {
    "startTime": "01:27:18",
    "text": "What what what what Okay. Money's"
  },
  {
    "startTime": "01:28:06",
    "text": "and depressed. The the the you know, you know,"
  },
  {
    "startTime": "01:30:00",
    "text": "barrels. Can do"
  },
  {
    "startTime": "01:43:01",
    "text": "time Yeah. Exactly. So that"
  },
  {
    "startTime": "01:47:17",
    "text": "now. And"
  },
  {
    "startTime": "01:49:16",
    "text": "run."
  },
  {
    "startTime": "01:50:30",
    "text": "Is is is Yes."
  },
  {
    "startTime": "01:56:23",
    "text": "Pain"
  },
  {
    "startTime": "02:00:18",
    "text": "Yes. I would first continue maybe if you don't mind and then answer your question, but we can if it's a short question, we can isn't so Yeah. Yeah. Yes. Okay. May I grab your attention? We now had 2 hours to work on the first two exercises, and I would like to continue with the second part by me continuing, I don't want I'm not saying that I exercise 1 and 2 So far, I think I've run this exercise three times, and I have one participant who finished exercise 2. So If you did not finish exercise too, you're in very good company. Let me summarize nonetheless first. What I hope is is Mike over there, though? Yes."
  },
  {
    "startTime": "02:02:04",
    "text": "Okay. I I think I I will continue nonetheless because the slide is not so important, and I can just read the bullet points out to you. So what I wanted you to learn or what I hope you got a idea of is, how you do basic modeling in tamarin, I wanted to you to get a bit familiar with this state read message in and state right message out format. This is especially important for the second part of the exercise. In the, of the for the second exercise. And in the first exercise, you played around a bit with symbolic model, right, like how the adversary can Learn things like they learned them encrypted message if the adversary got the key, yeah, and how we can deal with these things. In in lemmas, such as the weakened secrecy lemmas. If you're interested in more, I would say the tamarind documentation, the tamarind book that is also linked in my materials is quite good. I think it gives you a lot of information on Cameron, so we can encourage you to read it. And there are many more features of Cameron that we didn't look into you today on the press a if you wanted to prove things, and you hope that things turned red or green, if you do more complex things, you often have to do manual proofs where you explore the state space. You're self, and then you do need to do manual proofs. For that, Cameron also provide, support custom, Puffer, proof, proof proof heuristics and for things, for protocols that use loops, you require things like induction. So this for a short wrap up, I would now continue to with part 2. And for part 2, I really need the things. Okay. Yeah."
  },
  {
    "startTime": "02:04:06",
    "text": "There's the help help is out the door. That there's there's health is arriving Okay. It's just on a timer. Isn't it? Okay. We're back with screens. The adventure can continue. So in the 3rd exercise, I wanted to touch a more on how you actually use Tamarin in the wild or how you might use it in the wild. Because what you looked at so far was more like, academic textbook examples. Right? I I thought you, might have gotten the vibe of that. So in the beginning, I said, what is Tamarin? And I just want to focus and let you focus you on the the the funding board. I said, Taryn is with Taryn, you can prove that a protocol model guarantee certain security properties. And oftentimes when people hear this, in the head, they make out of it if I have a tamarind proof then something is secure. But unfortunately, I think this is an understandable intuition because, especially, researchers, like, to pitch it this way, but it's not a good intuition. I think it would be more it would be better to say With Cameron, you can prove that a protocol model guarantees certain security properties under certain assumptions. The value from of Tamarind really comes from making these assumptions explicit. And this is what I want to focus on in part 2. So"
  },
  {
    "startTime": "02:06:02",
    "text": "Let me, yep, doesn't does it Okay. So specifications, right, we had the IITF. I think you all have idea of what specifications might be. Specifications, what are they here for? Well, it becomes a bit opinionated from home, but I would say specifications are designed to foster compatible implementations. Right? And they're often deliberately underspecified, and, unfortunately, for people like Alex and me security considerations are often ad hoc. So they often have this, I find them so often to match this pattern. It's a list of we did x or attack y is not possible. And I understand where that comes from that reflects the, specifications or the state of mind I think formal analysis can add value in a way to bring a structured approach to security to these specifications. Where you have a list of positive definitions of security properties, so you don't say we did x of that y is impossible. You say, what do we actually want? Like, why is it actually bad that this Why is something even in a tech And then it also gives you a list of explicit assumptions. At least ideally, m There is this, specification OAuth too. And, I took a little snapshot of the table of contents you see security considerations for OF 2, you see it's like roughly eight pages of I would argue mostly that we did x so that attack y is not possible, or you better do x so that tech wise, it's not possible. But people in the past have taken a more structured approach at security analysis in a paper called a comprehensive form of security analysis of oath. The 2.0. Was published academically. They didn't use Cameron. They used to, manual pen and paper proof approach. But the good thing is that out of this form analysis, I think"
  },
  {
    "startTime": "02:08:00",
    "text": "came the best, at least to my mind, to my knowledge, you can feel free to point out other examples. Came the best, standards approach to security that I've seen so far, which is the OAuth 2.0 security best current practice document. Unfortunately, this document also doesn't list positive security properties. At least I couldn't find them when I skimmed over it. But they do list detailed threat model and a list of things that you should to And if you do these things, they approved a certain model, that you actually get security. So you can also use chairman to do something like this. Maybe that you even don't need to right, a second document that, covers the security of your designs, but that it isn't the standard to begin with. And I would argue this, like, a 4 step approach that, at least when I approach education that I take What I start with is I implement an initial specification super rough sketch. Of my thing, yeah, off my thing, how I would expected to work In Cameron. Yes. I mean, not just in Cameron. I will also write next Sir, I mean, what I would do is I would also have a document with natural language, this initial model that I'm referencing here in step 1, that this would be in tamarind because I like to use tamarind. Yeah. And then I start thinking about, okay, What is the thing that I want to actually in, like, provide with this problem, right? What should it bring to the world. In general, this works better for if it's security critical properties, like secrecy of something. Yeah? And then in this step, it's okay if my properties are trivially true because I model the the the the system so that they are provided. Then in this third step, what I would do is, you make your model more realistic. You make your initial specification match what you think the world is more closely. And now things I"
  },
  {
    "startTime": "02:10:01",
    "text": "starting to get false here properties, at least, hopefully. And then finally, you start refining your properties, you add these explicit assumptions. So you say, okay. My message is secret unless the adversary did this or that. Then, like, this is something I expect to not hold. And then you can lay out a list of assumptions under which you were able to prove this property. And I think these assumptions are really valuable because it you focus on the borders of your formal model, like where your analysis stopped, and it allows you implement us to think about these bullets, like, how can they make sure that these assumptions actually are realistic in practice. And for this final step, would encourage you to use the Google. And I, some of you now sought already, and then I wanna go into a bit of details of about the things that Cameron shows you. So, the pictures that you get in Cameron look like this, right? And you can You can identify 3 main components. You see bubbles. Like in white, you see boxes, mostly green, make different shades of green, put this matter, and you see arrows. The boxes are applications of your protocol rules. So days, They just mean, Akia, we instantiated your rule with these and those values. The bubbles mean the adversary is doing his thing. And the arrows are dependencies. Sometimes it's time dependencies. It says this thing happen for the other. Sometimes it's This information flows from here to there. So let us let me give you an example of how you could approach something like a a proof with this, cohesive practice. In the first exercise, you looked at this lema secrecy. Right? And this lemma says whenever a message was sent, then there does not exist point in time where the adversary learned this message. When Tamarind starts proving this property,"
  },
  {
    "startTime": "02:12:02",
    "text": "it will try to create a counter example. It will try to tell you that you're wrong. Your protocol does not provide this property. Look here, I have the perfect counter example. Because in this context sample, a message was sent Your message sent who was applied. And now the adversary knows it. It's clear. Your your property is false. This counter example is incomplete. Usually, if you have an actual, like, a secure protocol, giving your assumptions. You would expect that deviates from your expectation of how the protocol should be executed. And your job as the prover now is to find the spot where this thing deviates from your expectations. In the beginning, you sometimes think, okay, everything looks fine, you know, like, Here, we just sent a message. So far, nothing went wrong. So what we could ask Tamara now is okay. Cemen, I think you cannot know this message because I designed my protocol so that you cannot learn the message. Please tell me did you get the message from And then you can, you can, on your keyboard, press like 1, 2, 3, 4, and the goo, you can click it. It says like the solve and the solve will tell you, okay. Please complete this part of the trace. Yeah? You're saying you know the message, and the, you know, the message is this white bubble at the bottom. Where do you know it from? So if you click it, You will see this. And now This is just one case. Yeah. And now, Cameron, What does it do? Okay. It's it's I Yeah. It's not too readable, but you have the same, like, at the very bottom, you see the adversary knows the message. And then you will see again that the adversary knows the message but in a different way. And then the bubble above that's depicts that the adversary decrypted it How did they decrypt it, or they just use the key? And now you would have the 1st deviation from your expectation. Right? Now you see, yeah, if history claims, they can just decrypt the message. Well,"
  },
  {
    "startTime": "02:14:00",
    "text": "We don't think This can be true. Let's go down this rabbit hole. And then you refine until you hit a contradiction. Oftentimes proving, pressing a on simple models will do the job for you. It find the the adversary actually did something there. Really cannot do sometimes it will help you to find a case that you missed. Other questions on this so far? Jonathan. Oh, yes. Go on. Just behind the pillar. So if you, want to mess around with this, there's one very key thing to know. Which is that the default in Tamarin is to make these pictures blurry, It's not your eyesight. The default is blurry pictures. And there is a flag that you can set in your command line that will make it so that can actually read the which you it's in the manual. But but but but He wants to use image format SVG. Yeah. It is blurry. Yeah. Yeah. Any other questions? Here, the officer knows the key. Yes. I mean, it's we are kind of It depends on, so the question was, does this depict that the adversary knows the key? And my answers, yes and no, depending on your definition of no's. So here, like, Tarron is kind of trying to make an argument why you're wrong, right, So it started by saying, Well, I can just I mean, I just know the message, right, and then you say, time, and you just you don't just know the message. I mean, you need to get it from somewhere. Me where you got the message from. Right? And then January says, well, I just encrypted because I have the key. Right? That's the key."
  },
  {
    "startTime": "02:16:01",
    "text": "Now you must tell Tamara, Tamara, You're cheating. Did you get the key from? Can you please tell me? And then, hopefully, Cameron will tell you Oh, yes. You're right. I actually cannot get the key. Yeah. I guess you're right. Your protocol is secure. So it pretends to know the key, right, in a in this insecure protocol model, Tameron would be able to find, like, all the steps the adversary would need to take. Actually get the key In a secure protocol, It just pretended to know the key. Ideally. Ideally. Right? Yeah. Ideally, Yes. Do 4 like, created like, a model around. You know, It's too hard. I see into this. You know, portion. Of the So Did that make sense? So, yeah, so I think the question was, do you actually analyze protocols as a whole, or do you fix on do you look at subparts? Right? And then then see, there is no right or wrong to this. I think Jonathan behind you would disagree that it is impossible to analyze the big thing because he analyzed the big thing. Of course, analyzing the big thing is more complex than it more computational power and takes more of your time, And depending on what your goal is, you might want to look at, look at, look at, look at, look at, Tanya thinks in the beginning. If your goal is Let me double check whether my assumption about the key initialization make fence, sense, it's a great thing to just look at the key initialization. Right? If your goal is to be absolutely certain that there's no attack then you better not just look at the key initialization."
  },
  {
    "startTime": "02:18:02",
    "text": "Both has its place. Yeah? So Hi. So I I think with with Tameron, you wouldn't, as your first step, say, I'm gonna build the whole thing. I'm gonna prove everything in one shot. You'd say, oh, I'm gonna prove these tiny little pieces, and they need slowly start merging them. And If you keep doing that for a really long time, eventually you have a model that proves everything. But it's it's better to just start at the pieces and, like, Lego block them together. Yes. Scale. See is so this is something we're going to talk about at, UFR MRG. Because that was if you read the news, there was the H2 reset vulnerability, well, a few weeks ago, and I I alleged. That we could have detected it if we with formal analysis. If we'd thought to look for it, but I don't think anyone did. So we're gonna talk about that. In in Wednesday afternoon. On. Goodly wait, please. Yeah. When for it How can you decide whether you're protocol or your description? So, Gerdley asked if you get an attack shown by Cameron How do you know it's an actual attack and not just the flaw in the model. And and and and"
  },
  {
    "startTime": "02:20:00",
    "text": "My the answer is assuming you could just do it. Right? You can just sit down look at the trace that Cameron gives you and try to make sense of it. And If you have made sense of it, it's your decision. If you're if it's a modeling problem or if a specification problem. Right? Could it could be even sometimes there's also just property. Right? Sometimes you look at it, and then they say, yeah. This violates my property. My model is correct. But actually, this is not an attack. Let me change my property. Yeah. So there there is no There's no recipe for that. Okay. And with that, let me close already my my second bit is, talk block and not close it in me go to the 3rd exercise and briefly introduce it, because in the 3rd exercise, I want you to analyze an actual specification and follow the methodology that I laid out earlier, and this happens in exercise 3 So before I dive into that, me just point out, a proposal for me? From me to you, I invite you to solve exercise 3. If you find it better for you to continue with exercise to be my guest. With exercise 1, right, it's another possibility, so don't feel obliged. So in this exercise, we will look at an actual implement, specification, actual and quotation marks because I simplified it because otherwise, Like, I mean, there's reasons why people publish papers on OLF too. Right? So I created an excerpt of the specification, which I try to have the as close as possible to the actual or of 2 specification, and you find it in the three folder. And the excerpt of this specification were specifies the authorization code flow. So for those who don't know what OAuth is, it is a protocol that allows you to obtain what is called access tokens to access protected resources on some server. And how do you do that? Usually, you have, like, some client application, For example, your"
  },
  {
    "startTime": "02:22:02",
    "text": "social media client. Yeah. Your, like, your binary on your computer. And this social media client wants to access your social media data for the social media provider. So what they do is stays In step 1, open the browser window with some parameters at the social media provider. This is called the authorization endpoint. Then the user logs in consents. They do the little dance. And if this stance, is satisfactory for the authorization endpoint, they will issue an access code. Send that through a redirection endpoint back to the client, and this client can then go to another server exchange this code for a token. Just as a little contextualization so that you have an mental model with which you can approach the the specification, and I think there's Ahyas. So, let's do it. Yeah. This is the exercise 3. Are there any questions that are, better answer for the whole audience And otherwise, I would invite you to continue just doing exercises. Yes, please. The tamrindashprovadot github. Io page has a list of papers and incomplete list. Of papers that use terminal. And there you can find many examples. Yep. So we on a timing question that this people want to take a break? Or Ah, yes. So regarding breaks, So I have no more slides after this. Now it's just working time. I will hang around and help you out. Again. If you wanna take breaks because, you know, just take a break. Right? You're and I'm forced to stay in this room yeah, just just take a break whenever you feel like it. I'll stay here. Yeah. Sure. I don't know what time your food downstairs is. It's"
  },
  {
    "startTime": "02:24:00",
    "text": "I don't know either. And I'll be here until 4 pm. Bank. Right? Yep. And I I define my That was No. But, you just here. 80"
  },
  {
    "startTime": "02:29:19",
    "text": "know."
  },
  {
    "startTime": "02:30:43",
    "text": "Yeah."
  },
  {
    "startTime": "02:33:32",
    "text": "So,"
  },
  {
    "startTime": "02:34:01",
    "text": "mass. Saying but it should be"
  },
  {
    "startTime": "02:36:50",
    "text": "here,"
  },
  {
    "startTime": "02:38:17",
    "text": "guys Yeah."
  },
  {
    "startTime": "02:40:18",
    "text": "And"
  },
  {
    "startTime": "02:45:33",
    "text": "as as"
  },
  {
    "startTime": "02:46:29",
    "text": "please like, it well, it's actually"
  },
  {
    "startTime": "02:48:24",
    "text": "No."
  },
  {
    "startTime": "02:55:20",
    "text": "Is Yeah. And they will send back"
  },
  {
    "startTime": "02:56:01",
    "text": "Okay. So see"
  },
  {
    "startTime": "03:00:15",
    "text": "Yeah."
  },
  {
    "startTime": "03:04:06",
    "text": "Yeah."
  },
  {
    "startTime": "03:06:32",
    "text": "66 sorry."
  },
  {
    "startTime": "03:13:43",
    "text": "Yeah. So this is the definition But you could describe this to someone"
  },
  {
    "startTime": "03:14:20",
    "text": "so what is this kind of You say if I get this firm side in public Yeah. We're Yes. Oh, like this, Yes. Function exposure, this was"
  },
  {
    "startTime": "03:16:16",
    "text": "It's, okay. And, Okay. Yes. It's it's open source and Okay. Okay? Everything you can basically"
  },
  {
    "startTime": "03:18:11",
    "text": "Oh, to lesson No. As an experience so I can really and one question that that's it. Yeah. Yes."
  },
  {
    "startTime": "03:20:43",
    "text": "Great. your solution that Is Yeah. But that's usually right. You usually state State state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state state"
  },
  {
    "startTime": "03:22:34",
    "text": "just and you make it as a variable to say after I send out this message, I will only respond with one response sort of whenever someone sends you this, one message. You're doing the same. I will make sure you saw the one on the teats,"
  },
  {
    "startTime": "03:24:06",
    "text": "so far, we So this one? Monday. Okay."
  },
  {
    "startTime": "03:29:58",
    "text": "We were we were thinking that we understood things, but then we we are right here."
  },
  {
    "startTime": "03:30:07",
    "text": "So, Eric, I knew they find it here. Hi, Taba. So if you don't have anybody before we say, okay, it makes sense. The same up here. That, you know, have different So If you were a protocol client, right? And you're expecting something encrypted what would you see on the channel? Would see something that So and reflect them. Well, a decryption often Yeah. Yeah. But here is the label that I get. With the chef key then I get the regular But you get Thanks. Okay. Will be sorry, wouldn't this action should be here. In the in the before"
  },
  {
    "startTime": "03:32:02",
    "text": "I don't hear what's happening in the middle. What's, not exactly. So restrictions but they every protocol trace This is leadership. Okay. Okay. So many Let's"
  },
  {
    "startTime": "03:34:17",
    "text": "the chairman, prove a repository as a big list of examples with many action other way. I would Yes. Okay."
  },
  {
    "startTime": "03:37:57",
    "text": "Yeah."
  },
  {
    "startTime": "03:38:07",
    "text": "I'm sure No. To yes, from"
  },
  {
    "startTime": "03:40:11",
    "text": "Yeah. It. Anyways, some this Yes."
  },
  {
    "startTime": "03:42:56",
    "text": "You know, Yeah. And"
  },
  {
    "startTime": "03:45:10",
    "text": "Yeah. So"
  },
  {
    "startTime": "03:46:01",
    "text": "7 Well, safe."
  },
  {
    "startTime": "03:48:06",
    "text": "Authorization service. So for Suva. 31st, not"
  },
  {
    "startTime": "03:50:00",
    "text": "I like that where you have and I'd rather Yeah. Not"
  },
  {
    "startTime": "03:52:00",
    "text": "redirect skew, to, Yeah."
  },
  {
    "startTime": "03:54:45",
    "text": "Oh,"
  },
  {
    "startTime": "03:56:20",
    "text": "Hi, everyone. I think we're gonna declare victory. And say we have successfully completed our session. Hopefully, you have all completed exercise 3, are now Tamara and experts, and, or at least know it's ask for help if you, didn't quite get to the very end. And thank you for Felix, to Felix for running it. Just that I Thank you very much. Of 3 men Where are you even here? That's my name. Don't wear it out. Can you Are you at home?"
  },
  {
    "startTime": "03:58:24",
    "text": "What does that mean just like Yeah."
  },
  {
    "startTime": "04:02:39",
    "text": "I'm and"
  }
]
