[
  {
    "startTime": "00:00:04",
    "text": "oh hello go on that\u0027s better yeah um so welcome to a the first session of faith um we have a session that is shared with the acne so the first an hour and a half will be off yeah and and and the last hour of this would be an acne so we have 90 minutes here um this is obviously I am the note well everything that you say or contribute here is still a under the note well so make sure you\u0027re familiar with this a we have a diverse product that would thank you for that M minutes taker takers a Mike and Justin thank you and blue sheets are circulating already didn\u0027t have to be too close it\u0027s good yeah a we have a one document that that was recently published a RFC eighty four one four that\u0027s the authorization server metadata a and congratulations to the author\u0027s I think Mike net and John said the correct okay thank you guys um quick status update here M so can you can you guys close that door sorry and so I think the whole floor was just training it was just so that so before this session or in preparation of this session we met with some of the draft officers to do the Shepherd write-up for the device flow and also for the best contract this document Oh PCB device fluorescent just sent me an "
  },
  {
    "startTime": "00:03:04",
    "text": "email the device flow moved into pallet which is so I didn\u0027t got advanced which is good and he needs to review NAB\u0027s document on the JW s request signing and actually oh yeah so there\u0027s an action item for us to go through the comments to make sure that we sort of summarized on how we address the difference I use she comments so that that would obviously help occur to advance the document faster because he needs to also produce a write-up for the document going forward it\u0027s not just a working group the Shepherd doing the write up but also the the responsibility to do the write up so I will talk to Nath and and the other authors to work on that to explain I think which is something another unreasonable request to explain how the comments have been taken care of and and the Durst documents will probably discuss most of those so I think incremental authorization will be discussed today em again jot jot BCP and MPLS we started that right up Homewood will be discussed today security topics talkin it will be discussed on Thursday and talking binding and talking exchange will be discussed later today okay so here is a our jet agenda for the day so we will start with the incremental incremental or authorization but William I think he\u0027s a is representing remotely and William can you join the line here [Music] hey Ron hey we can\u0027t hear you great get my slides up yes yes this lights ah okay great yes sir thank you so I\u0027m here today to talk about the earth to turbo incremental auth which was recently adopted by the working group so thank you for that next slide let me just recap while we\u0027re doing this so the problem statement is something like this asking for the kitchen sink of scopes upfront can also be a bad thing users will frequently want the context "
  },
  {
    "startTime": "00:06:05",
    "text": "of an authorization request so for example if an app needs both the the calendar and the contact scope then actually asking for those different scopes in a context that they\u0027re actually used in the app is something that makes sense can I go to the next line so this is this is basically what we want to avoid and I think this is particularly relevant in this sort of new era that we\u0027re entering where people are very very aware of the data that they\u0027re sharing and kind of considerations like that around Hoth next slide please so the definition of incremental off in the spec is the ability to request additional scopes in subsequent requests adding to a single authorization grant representing all scopes so far so you could of course implement this just by making separate completely separate and discrete orth requests and then tracking them all individually but the theory is that that is something else challenging to do if an app needed say five different scopes and wanted to request each of those separately it would then have to track five separate authorization call five separate refresh tokens so the advantage of incremental auth is that they get grouped together into a single grant that represents everything the user has granted so far particularly relevant for public clients there next slide please so when it comes to confidential clients in fact all of the existing spec doesn\u0027t actually stop you returning more authorization than what was requested so what do people kind of implement this as a way of delivering incremental auth for confidential clients so the value of the spec when it comes to those is the inclusion of some best practices security considerations and one additional parameter which is include granted scopes which is a way that a confidential client can kind of indicate that they want all of the granted scopes so far to be included in that response and not just the one that they currently asking for next slide please and the real innovation of that of this standard is to document how public clients can do incremental auth because that was previously not possible at all and we\u0027re doing that by ur and you take an endpoint called existing grant so when let\u0027s go to the next slide and I\u0027ll walk 3d so when basically the app does three requests the first one is completely normal for native apps and then the second one the first two steps are exactly the same as no laws so they\u0027ll just request whatever scope they wanted but if you look at this second to last line at the bottom there when they\u0027re exchanging the authorization code for that second grant they include you know field called existing grant the Refresh token from the first request and that will result in the access token and refresh tokens being returned on the bottom line they\u0027re containing the union of all that scope next slide please "
  },
  {
    "startTime": "00:09:07",
    "text": "this is just visualizing how that works so you have grant a and grant B and then what should be returned is the combined grant the union of both next slide please okay so updated since the last eight if it was adopted as the working group which I mentioned which is great and I\u0027ve been working here here at Google looking with some other people kind of testing this out and sort of seeing what else needs to be added to the draft so it looks like one thing we may want to document is exactly how the scope response parameter works with this draft it\u0027s sort of already documented it might be worth some best practices around that we of course want to provide an RFC 841 for metadata field that\u0027s an RFC so and the big thing is Interop and also I guess reviews so thank you to Austin I saw your review this morning I really appreciate that but yeah I really wanted to send out a call to action here if anyone is interested in this spec and if you have a client or a server that that can potentially use this very interested to to get in touch with you and to work on some interrupts there no I\u0027m so that\u0027s probably going to be one of my main focuses going forward between now and the next idea next slide please and so with that point in mind I\u0027m happy to announce that the apple of iOS library does have support for this standard now particularly the public client one I realize been at Norma show code but I just wanted to show this because it\u0027s actually just just to emphasize how simple ease so this is like literally the sum total amount of code that a client would need to provide in order to increment an existing grant they had with the calendar scope that is literally all they have to do and this is kind of like why we\u0027re doing why I really wanted to push this and that is if we make this really easy for people to do then I\u0027m hoping more people will do it and I think it\u0027s the right thing for users and so if more people do the right thing the users then then we all win next slide please and I published a demo using this this new API so the API by the way it has actually emerged yet it\u0027s in a pull request but if you if you are an iOS developer and you click this link it\u0027ll have everything a demo showing how this works using those new API so you can try that out and as I said before I\u0027m really interested to gets in the airdrop happening so I\u0027d love for if anyone\u0027s implementing is server-side you\u0027d be great to point this demo at your server too and see if it works and see what problems we have if any all right last slide so that was my update um very very interested to hear what people think of the - if any Wells has had a chance to review their card Amazon nice "
  },
  {
    "startTime": "00:12:15",
    "text": "Thanks any more elaborate I guess we can go over to Austin\u0027s feedback from LA today if that\u0027s the interest yeah there are a couple points raised I do you want me to summarize them sure you want me to share those I think uh yeah okay she\u0027d be under yeah there is third from the top great so it was two pieces of feedback here one was the way we way we documented how the the unioning is is done on the authorisation ground to also notice that I had a should in the spec there rather than a must and spec as well so the reason the reason I originally had it should there is I\u0027m trying to kind of balance balance two competing things here the let me just read the section that says if if the verification succeeds the new refresh token issued in the access token response of the token endpoint should include authorization for the Scopes in the previous grant so it\u0027s basically saying when the when the user when the client provides the existing ground parameter any new tokens issue should contain the Scopes from that parameter the only reason I really made that it should not a must is I kind of always feel like it\u0027s up to the authorization so but what what they want to do but it\u0027s it is probably a little bit confusing to say that so should there because if you\u0027re sort of not doing that in you know in a normal case then you\u0027re not really implementing this spec at all so my plan there is to actually change it to a must but kind of qualify that with some words to say you know ultimately it is in the discretion of the of the server what they what they want to grant but if you\u0027re implying is spec you know in the normal case you must include that so I hope that makes sense I\u0027ll just pause in case there\u0027s a comment on that feedback and about back Amazon what about situations where the authorization server wants to support selective consent and potentially include in that the ability to guess revoke previously granted scopes how would that work if this is a must yeah good question and I think I mean that\u0027s coming another trend that we\u0027re "
  },
  {
    "startTime": "00:15:15",
    "text": "going to see actually so you\u0027re very topical and and for the most part I think that can already be implemented in the bounds of Hoth so I definitely wouldn\u0027t want to have any texture that would tie anyone\u0027s hand around selected consent so I guess what you\u0027re saying is potentially the existing grants could be shown on that incremental auth screen that\u0027s not something that at least Google\u0027s in orientation does today but they could be and the user could actually revoke something as they reviewing and maybe granting or maybe not granting the next one so I totally agree to your comment I\u0027m it\u0027s gonna be hard to come up with some good words ran out uh-huh but I think we can we can probably work at such then that it accommodates then yeah I think your original kind of instinct is making that us should at least not a must is is right I don\u0027t think if we make this a must then we are tying implementers hands with regards to things like that right I guess the wrinkle is if you if you interpret a street if you actually kind of never do it then then you have any whether the spec I suppose maybe that might be worth noting but but yes it\u0027s more like in a normal case you would consider that existing grant and likely bundle that in but I guess either way if we keep it as a should maybe I can just clarify that you actually never do that then you\u0027re probably not going to spec at all does that dick is telling me he has a suggestion so I\u0027ll let him talk ok great now maybe framing it more on that the response shooting must include all the authorization that the user is granted and so by putting the user into the equation then you\u0027re tying in to what the user is granted as opposed to whatever the server decided as being previous grants right so that way if any came in and out it makes it clear I like that actually it\u0027s always comment from the jabber from Torsten lourdes that the alternative is to return the scope with the token response that the client can determine what happens but apparently that\u0027s what he just said yeah i actually that is a very good point from twisting this is something this spec does not today that they should so I think the OAuth spec actually already documents this behaviour so if you are returning an authorization we\u0027re sort of different scope than what was requested you\u0027re actually a meant to populate that field but these behaviors not mentioned is highly relevant incremental also I\u0027ll don\u0027t me take those a note to add something as well regarding that parameter and and like Torsten says that is actually a good way for the client to figure out you what the heck happened alright so the second point here is the respect goes into a little bit of detail "
  },
  {
    "startTime": "00:18:15",
    "text": "kind of some best practices around how to handle denials in the case of incremental authorization you know one of the things is kind of not throwing the baby out with the bathwater if you use a where to choose no for a particular authorization scope then and you know you shouldn\u0027t like completely abandon all the grants that you have so far the app should actually continue operating I think this is very important from a user standpoint you don\u0027t want to kind of add to the user or like really anticipate that they\u0027re granting scopes they don\u0027t want to that\u0027s the whole reason why we haven\u0027t word creative spec but Austin raises the point about how should the server handle it so I\u0027ll definitely add a section in that I totally agree with the assumption stated here which is that also the authorization so that would not normally discard any previously rendered scopes if the user didn\u0027t explicitly indicate that take heart again this brings up sort of another question I don\u0027t know whether the working group has looked into this anytime in the past but standardizing token discovery endpoint err a client could call a known endpoint and get back all the Scopes that were in the token so then they could learn what do they have now and then they would know what do they need to ask for you know a number of the providers have a proprietary API for that but standardizing that could simplify work for developers well I\u0027ve seen people using token introspection from the client to actually see what rather than the resource of use for that purpose but you\u0027re right yes I agree I know Google employees more or less implements for tokio introspection snake which which I think was actually not designed for that use case but it kind of always works for it Annabel Bachman Amazon a similar point to what I said earlier let\u0027s I think we want to avoid assuming that an authorization server isn\u0027t going to revoke previously issued consent if that\u0027s what you know they may want to allow the the user to do that through that UI if you\u0027re a user seeing a bunch of stuff that you\u0027ve you know whether you know you\u0027ve granted it or not whether you know this is new stuff that you\u0027re granting versus old stuff if you hit cancel what does that mean you know maybe it means you cancel everything that\u0027s a good point well for one I think I\u0027ll make sure like this pig doesn\u0027t tie anybody\u0027s hand would relate to that I think he\u0027s you know everything is up to the authorization server I mean I am interested to capture usability best practices and then kind of give advice to people in mulaney\u0027s so that is an interesting question it\u0027s only we have a yes or a no and this is actually like a yes/no and there might be some other actions in the users so do you think that\u0027s worth documenting there was probably room for a best current "
  },
  {
    "startTime": "00:21:16",
    "text": "practice around that but I have no idea what I don\u0027t think we as a community know what the best current practices worth right consent and revocation are so that\u0027s a project itself indeed so maybe maybe just some non normative text just sort of presenting this is something that that should be considered I guess by implement it\u0027s sad yeah at the very least in like a consideration section perhaps right on another thought is basic question is do we actually have an access denied use case where the customer or the user is not revoking everything like if I\u0027m if I\u0027m a a user and I reject the new scopes but the authorization server still says the old scopes are valid does it make sense that for that to be an access denied or should that be a success and just issuing you back the Scopes you had previously because technically you\u0027re still authorized just not right or the new stuff so so one of the problems is for public clients is that at the time of the authorization it can be a little bit hard to know what scope that particular public client actually has because you can imagine a case where where there are two installs of the same public client used by the same user that potentially have actually different scope which sounds weird but is it\u0027s only possible and I\u0027ve seen this with with some like cloud-based CLI tools so the way the spec is designed is is actually they second the kind of incremental request if you deny it it really just means like you\u0027re just denying that particular scope with no implication on the previous one be they asses behavior because they might be you know sort of revoking scopes in the back of their eyes yeah so I\u0027m saying if we\u0027re going to support that kind of a use case where there could be a revocation of everything then maybe it makes sense for us to reserve access denied for the case where where everything\u0027s getting revoked and in all other cases you\u0027re authorized but you need to check what you got authorized for yeah so I think the only blocker right now to implementing that is that the server is not getting indication in the request exactly which grant this relates to because you could have two simultaneous grants to the same client I\u0027d be kind of in power and so there\u0027s actually in a way if you\u0027re supporting that behavior there\u0027s no way to kind of correlate them right now we did have one idea about this which is on the authorization request the client could "
  },
  {
    "startTime": "00:24:17",
    "text": "provide like an access token or something to sort of hint to the authorization server which which grant this is but we\u0027re right now it\u0027s not documented doesn\u0027t the authorization server has to be able to know what is like what\u0027s consented and what\u0027s not like a each so in order to present it to the user so I imagine well well actually the way this is specified you would only present the the new consents so it knows what\u0027s being asked in that incremental authorization request so it knows what to present in that context to you to give an example what I\u0027m talking about like imagine you have a cloud product with various different scopes and you have like two laptops and two command lines both interacting with some cloud tool in that case it\u0027s the same user and it\u0027s the same all with a client ID but you could potentially have like one laptop with West so sure right now iOS and Android app on different devices sure wrong and so right now the authorization server in the context of that incremental request doesn\u0027t know kind of which of those grants it is we could document another parameter on the request I agree I agree with your statement insofar as it applies to the protocol as written today I don\u0027t think though that we want to go down a road where public clients and confidential clients are necessarily given different user experiences which is sounds like where that would lead okay so the simplest way I think to solve this is if the client includes an access token on the second authorization request do you see a problem with that at all if we were to do it um besides putting an access token in the query string that\u0027s that\u0027s the problem I mean how else can we indicate I guess we could hasha I mean how else to indicate to the authorization server kind of like this incremental request relates to an existing grant that has been made in the past I can tentatively think of some ideas but I don\u0027t want to try and blurt them out here in 30 seconds so let\u0027s let\u0027s take that as an exercise to continue that discussion all right it sounds good I think this is an excellent topic yeah thank you for raising it Justin richer and while we wait for Annabelle\u0027s ideas the thing that I\u0027m hearing throughout this entire discussion is kind of coming back to the fact that a woof 2 does not have any type of sort of structural model for what a grant is and so that might be something that we as a group may want to take like half a step back to think at about how this works how we might be able to chain multiple things together because ultimately if you had a way to "
  },
  {
    "startTime": "00:27:18",
    "text": "identify a grant you could build up this kind of stuff that there might be something going on there there are a lot of other systems that you know there\u0027s Emma and Seba and even the device flow have all these temporary tickets to kind of tie different parts of the process together here so we have approached this from a lot of different directions but fundamentally there is no object that is the authorization grant that we agreed on that like this is what it is in these what the parts are which is why all of these assumptions about like how is this stored how is this referenced what is it apply to is going to be completely different in every single implementation so so I very much sympathized with the not wanting to tell authorization servers what to do because they\u0027ve been doing it a certain way for very many years and coming in and saying that no our model is better than the model that you correctly interpreted from the vague specification is not gonna fly so anyway that\u0027s something consider what I actually got out to talk about though was that the introspection specification we intentionally wrote that to be slightly vague as to who\u0027s supposed to be using it the primary use case is very definitely the resource server talking to the authorization server that is that\u0027s the job that it was meant to solve however if you look at how the spec is written in kind of what it allows in different places and stuff like that the client can use it without really going off-book the trick of course is to have your authorization server implemented in such a way that it can safely allow clients to introspect which is not a which is not as simple as it seems on the surface having implemented that in several different systems there are a lot of gotchas about allowing clients to ask what a token is good for so I think it that\u0027s if you want to go that route that\u0027s that\u0027s the place to start and some additional considerations for how to use it properly within that context is probably the right way to go about it do you think we should actually talk about that use case here or that are you saying that\u0027s just a separate thing I think that if it\u0027s that if we\u0027re going to recommend the application of introspection to help solve this this whole notion of I\u0027m gonna go look up what my tokens good for and so that I only ask for the Delta or I go look up what the token is for to figure out if I got what I asked for or something like that then we should document that here the sort of the AAS implementation and security considerations for token introspection as used by clients for this I think that that would be that "
  },
  {
    "startTime": "00:30:19",
    "text": "would be good here yeah I mean one of the goals of this state is to document how that scope returned value would be used to indicate to the client like what scopes they had to avoid the necessity of that lookup right they might forget or them you know something might happen this or yeah and and and fundamentally we all seem to sometimes forget as a community how stupid oh our clients are and how they\u0027re not going to do most of the clever tricks that we allow them to do with all of these specifications they\u0027re just gonna blast tokens until it works yes I just I was just wondering whether it\u0027s really a good idea to do token introspection from the client when you\u0027re only interested in this course because it\u0027s essentially you get the token you sent the token back there\u0027s one additional round-trip lots of data being passed around you you may get actually realistically more back than just the scope you actually get a lot of data so like seems extremely wasteful like in terms of what the round-trip and the what goes over the wire wouldn\u0027t be more sensible to actually pass a parameter along that comes back if the token saying this is the scope that I actually granted you asked previously this in the request and here\u0027s what you get well you know I\u0027m just I didn\u0027t say introspecting from a client was a good idea I just said it was allowed by the spec that\u0027s true or not strictly disallowed to be pedantic so yeah there are a lot of downsides and one of them is that the data model that you get back from introspection is intended for resource servers it\u0027s got a lot of extra information that clients generally shouldn\u0027t know anything about also going back to the point about clients being stupid generally they\u0027re gonna use the token and see if it works I mean most low off clients that I have seen in the wild ignore the scope field they get a token it\u0027s the 200 the access token field is there they\u0027re happy they don\u0027t check expires in they don\u0027t check scope you know they don\u0027t do anything else if I get the access token I\u0027m call the API hey the API failed guess I need to go bother the user again and maybe pop up a screen that says no user really do click this or I can\u0027t give you the widget you wanted so yeah so it for most clients it doesn\u0027t make sense to do that extra round-trip because they\u0027re doing a round-trip to see if the token is any good by using it and they already have to have appropriate recovery for that failing anyway for the token being revoked or not being strong enough or having expired or any any number of other things that they already have - right the tendency is to reuse those code those recovery code paths as opposed to trying to do something more smart and proactive that said there are "
  },
  {
    "startTime": "00:33:19",
    "text": "a handful of people who especially with kind of back-end system clients that you know can afford to be a little bit smarter about things or it\u0027s worth putting in a little bit extra smarts then they do tend to do these these pre-emptive checks for expiration and stuff like that because the failure case is more expensive than the check in those it\u0027s a trade-off but I actually the vast majority of cases it doesn\u0027t make sense yeah and I think one of the quirks of old two is that when you\u0027re making that a paradise there is no stand-in response because we actually don\u0027t document that header at all so doing that pre change is useful because you can actually avoid the standards mm-hmm oh well I mean you get back something in the HTTP for hundreds that might mean your token isn\u0027t good right but we don\u0027t have a documented response for that so right then you have to be one with that on a per provider basis - yes yeah yeah okay I think we\u0027re out of time are we yeah no you know you have a few more minutes whew okay great well thanks Aaron I think that gives us a pretty good list of topics to look on the next before the next meeting and just a reminder if you are interested looking for people to test adding you drop with please get in touch thanks for him thank you okay dick you\u0027re next here no one to thank for that yeah see the manual yeah hi I\u0027m dick Hart I\u0027m gonna talk about the reciprocal Olaf which is now working group document how many people were in Singapore saw the presentation a few of you so for those of you that were there here\u0027s updater and what happened change name from mutual ooofff because brian didn\u0027t like mutual and to reciprocal which I think actually fits better added a reciprocal parameter that could happen in the first flow so that the party B could indicate what scopes they would like in the push and of course it\u0027s been adopted as a working group document so the problem there is essentially you want a symmetric relationship between the two different parties each of them is calling each other potentially and potentially the user could be starting it either of those parties and so we have this today "
  },
  {
    "startTime": "00:36:19",
    "text": "with Alexa and Sonos and then there\u0027s a number of other ones which I forgotten which ones of ships and which ones haven\u0027t so I can\u0027t really mention anybody else but it\u0027s deployed now between us and all between Alexa and Sonos and so the previous flow for anyone that had tried to install Sonos on Alexa was super complicated you need to log in like numerous times to go through to do it because you you you weren\u0027t at the right site and so you have to get bounced over to one site to go and start something and all over the place so I go through that a bit here and the flows you know the user is over in the Lexx app like so knows indicates the Sonos authorizes like satsang always user gets redirected to Alexa with asanas authorization code Alexa exchanges that code for an access token which is your standard flow and then Alexis will send you back over to Sona to start the second flow and then Sona always sends you back over which then of course drives a login with Amazon because we started in the app but now we\u0027re in the web browser so now the user has to log in Amazon even though they were already logged into the Alexa app and then the authorized Sonos and Amazon then the users redirected back to Sonos with the Lex authorization code so known as exchanges that code for it and then users rejected back over to Alexa completion which I think the first version was even this clean it was even uglier than this so the reciprocal overflow I made the font a little smaller so it also don\u0027t have screen a little bit of a cheat there so one through five is all the same step six seven and eight are removed and so what the user is now back over at the Alexa app at the end a new step is the user authorizes what Alexa is going to grant so nose and then Alexa just back channel called so nose token end point with their authorization code and provides a context for Sonos bypassing so knows their access token and then standard flow in step 11 which is Sonos exchanges the authorization code for an access token so there\u0027s a scope now and so when Sonos comes over they can include a scope as a another part of the flow so what kind of scope they would like and so the Torsen asks a good question what if how does party a know whether they should go and send a scope over it\u0027s either pre-configured or obviously the in this example party be sent a signal as to which scopes they wanted and then the reciprocal authorization codes it\u0027s a new grant type thank you I think Brian you gave me the suggestion that we should use you have this kind of grant "
  },
  {
    "startTime": "00:39:20",
    "text": "type and then the party B access token and prayer persons comments all this is is really for the party B to understand the context and then of course the authorization code from party a so that\u0027s an example of what that looks like something that we\u0027re starting to do now and I\u0027m thinking of adding this into the spec is and it sort of follows aren\u0027t fortunately it was nice of Dennis that and have his talk right before this talk is this essentially is additional incremental authorization and so in the Alexa world the skill could ask for something and so similarly you know where you want to torment all the skill may only have been given a little bit of permission at first when the account linking happened and when the users in the application land but later on when the users you know asking the skill to do something and the skill doesn\u0027t have permission say to get the users location or get their email address is you could have a voice interface where you know Alexa asked the user if it\u0027s okay for a particular skill to get a new permission the user says yes and so then we\u0027d like to go and update that to the skill and so using this same interface we can go and push a new authorization code to the other party for them to acquire new refresh and access tokens that now represent the updated scope and so I just want to call out that we reinvention this really being a symmetrical relationship I haven\u0027t really come an example where it\u0027s asymmetrical where really the user can start at either side and either party could update the other\u0027s authorization implementations as I mentioned and I got some typos that people have pointed out in the spec but sort of opening up for discussion people have anyone else think this is be useful besides the other voice assistance the question is any comments [Laughter] anybody have feedback aren\u0027t sort of that updating authorization flow yeah I yeah you said he said excluding auto here with voice assistance but it as we have one yes I think this is extremely relevant and I\u0027ve seen it very similar you know set of steps that you presented so I think it\u0027s good good today okay any other feedback honored anything you think we\u0027re we didn\u0027t capture nothing yet but I mean let me take an "
  },
  {
    "startTime": "00:42:22",
    "text": "action over here okay any thoughts are an including sort of another section that we you could use this same flow for updating an authorization that sort of picks up on your incremental that puts it in what would be in a voice assistant world so we\u0027ve got that example was that Alexa asking if the user was happy to grant more Sonos let\u0027s go is that yes right okay that\u0027s extremely interesting so that that\u0027s in a very trusted relationship I guess but it makes sense you don\u0027t usually have to pull out their phone and review a web request I guess yeah well just like you guys we have speaker recognition yes right nothing it I think it make sense to do that okay really and about Backman Amazon so the current draft has the reciprocal grant request coming back over the as part of the authorization response correct with the authorization code and the state know that I believe that\u0027s what it says the that there\u0027s a risk there\u0027s an additional scope require a scope request was that what you\u0027re saying I\u0027m on the ground no not that not the grant I\u0027m talking about the mechanism by which Sonos would tell Alexa and your example what what scopes it would like to get yes that\u0027s in the authorization code from Sonos right in that and it\u0027s authorized it\u0027s the initial of a authorization response yes right that okay so is there what are the trade-offs around having that as part of the authorization response versus as part of the access token response that\u0027s all I always have to wrap my mind around who\u0027s calling who in each of these things you look at the screen wait and see that\u0027s right sometimes it\u0027s best what are you really so I was writing my slides I got confused as the crew was calling up so if I understand the draft correctly in step 4 step 4 is the user has granted consent @co knows and has come back to Alexa with an authorization code yes that in that step Alexa could possibly have received a scope value from Sonos right this says "
  },
  {
    "startTime": "00:45:23",
    "text": "this is what\u0027s known as wants so my question is that so that\u0027s kind of coming over like the less secure channel right and so you\u0027re thinking that we could have that in five right like Alexa call Sonos with the authorization codes so knows in addition to providing an access token and a refresh token could provide the Scopes that it would like right that that would get that over the more secure Channel the flipside the counterpoint to that though is that that necessitates that for five and onward is kind of happening a synchronously and that may or may not be the case depending on the back end of limitation yeah okay yes yes Gus on the list yeah I I like having a more secure Channel and I think functionally it\u0027s in the same place and adding more stuff in the redirect it\u0027s always problematic since it\u0027s much more limited in its ability mm-hmm and of course it\u0027s open especially to if we consider other people and on the list have been talking about recently scope data and having some additional content along with just rather than just a static scope value so you could imagine that getting bigger and being a problem right yeah is that does that mean you don\u0027t need that elixir ization code in this case right no no usually it\u0027s I don\u0027t have in the slide here in step 4 we\u0027re also the Sonos is including which scopes who would like in the redirect it does back to Alexa so if you go to I don\u0027t know it\u0027s oh I got this here yeah that is where I was putting the Sonos with signaling which scopes it was missing in the other sites and here yes it\u0027s not listed there correct and so what Annabelle was suggested is that it would actually be in this no not that call in this home you call that happens in five to go and add the reciprocal parameter coming back from sona\u0027s as part of its response saying okay I just gave you this and here\u0027s what I here\u0027s the scopes I\u0027d like you to send me yeah I wonder would you actually that may be a good idea to include that parameter because that stage you could actually then fall back to the other mode rather than failing later on when the other when you have the authorizations over not knowing about the functionality of "
  },
  {
    "startTime": "00:48:24",
    "text": "this extension or did you consider that case what happens if you you know I key go through then it doesn\u0027t support that would it completely fail or could it fall back to the longer flow instead you know what I\u0027m talking about no no so you in order for this to work both parties have to support it right yeah but you don\u0027t know up front it\u0027s all three parties the authorization server headaches so no I know well there\u0027s really Alexa in its resources and Sonos in their resources right but it\u0027s really the to authorization server yeah so you just assume that they know about each other\u0027s support for it for this function idea and that\u0027s it you if they don\u0027t know about it then they wouldn\u0027t be able to do it right but it would fail at some point yeah yeah well say what would it would it just say so know what say say we thought that Sona supported it hmm but they actually didn\u0027t deploy it right when we would make a call with that back call to push a code fail right we can fall back to the longer flow that you should previously or would it just fail or denied us fail because cuz the other flow was essentially a bunch of super complicated UX that both people needed to do right so that you\u0027re longer flow isn\u0027t standard at all right the the initial flow is standard the longer flow was like a wacky way of trying to accomplish it okay and to add to that if you think about how this would fail you know if Sonos doesn\u0027t support it then they\u0027re just not gonna ever send any tokens back or any any reciprocal scope back to us and if we try to give them something anyway their token end point is just going to reject it if so no supports it but Alexa doesn\u0027t then Alexis just gonna ignore any reciprocal thing that gets sent back Sonos is never going to get a call to their token and point to give them tokens at that point if you wanted to fall back you would have to be Sonos triggering the fall back but how would you even detect that right like at what point do you decide it hasn\u0027t been called and then do you Howard so knows inject something into the experience it\u0027s not really I think the district was assuming that the current flow was actually a standard flow which it isn\u0027t step six years I non-standard right sub six usually you\u0027re all done by five in the current somebody\u0027s on the phone his mom called him relaying another comment from Torsten from Jabbar the flow description given on slide six would be a helpful addition to the draft since even you "
  },
  {
    "startTime": "00:51:24",
    "text": "seem to get confused about about who\u0027s calling who right thank you for pointing out the obvious person and what\u0027s this the why is it what\u0027s that because it isn\u0027t really tan it\u0027s a different so slightly different it\u0027s a difference that that\u0027s the new step is ten B but it has a equivalent of what ten was in the other eyes other one Thank You Torsten how is your day today to be back comments so I\u0027ll do a new draft with pictures yeah okay good okay thank you Thank You D okay Brian enjoy close enough okay I\u0027m gonna Jam three different documents into one update here a lot of it it\u0027s it\u0027s just sort of some status updates and overview but a couple of these mutual TLS and token binding maybe have some relevance to the pop token stuff that\u0027s going to be discussed on Thursday and so yeah welcome to not San Francisco I\u0027ve never been to Montreal before supposed to be I won\u0027t go to politics all right so I\u0027m gonna start with oauth2 token binding which first sort of got introduced to the working group in Berlin and IETF 96 hence my go to this photograph here in Berlin so I talked to a few people about this so combining in general and there\u0027s the OAuth application of it and then there\u0027s the lower layer technologies that make to combining work and I want to give a brief overview of kind of how that stuff works which will maybe help inform how the OAuth pieces work and enhance understanding of people really not document I noticed one of the authors of that stuff is in here so I\u0027m sure he will make sure I\u0027m right on point but there are three core drafts that make up that set of documents right now coming out of the token binding working group the last meeting this week on Friday the very very last meeting is for that working group for anybody\u0027s interested it defines basically three things how "
  },
  {
    "startTime": "00:54:24",
    "text": "the use of token binding is negotiated in the TLS handshake the protocol of token binding which is really just the message format and then the application of token binding to http what token Bonnie does is enables this long-lived binding of cookies or other security tokens like tokens to a client generated public/private key pair on on the browser or or underlying platform the use of this is negotiated in TLS handshake via TLS extension a possession of the actual token binding key is proven by signing the TLS exported key material and then sending that along with the public key and a few other things as a encoded HTTP header on every request and then in turn the server can bind cookies or other tokens to that key at least in the browser use case the key is scoped to the effective top-level domain plus one the the scoping around OAuth is a bit ambiguous and I intentionally but generally that\u0027s the scope at least in web browser cases and then in federated so across the million cases where you want to bind to a key that\u0027s used in a different domain there\u0027s this thing called a referred to combining versus what\u0027s normally called the preferred excuse me provided to combining or the provided is between the client and the sort of the main server the referred enables the client to communicate a key that would use with a different server so that that original server combined tokens 2.4 its usage a little bit more graphical showing of how this works in the TLS handshake there\u0027s just hello extension number 24 if you\u0027re interested that the client includes in its client hello along with basically what signature algorithms it supports to do tow combining there\u0027s there\u0027s three defined right now and then if the server is happy with this and wants to do tow combining with this client it responds including the extension and this its server hello same extensions same structure but it only has one of these key parameter types was the key signature type basically indicating the client hey this is the one that we\u0027re going to use in this case in this example the client offers up a couple different choices and the server responds with okay let\u0027s do two combining and please use ECDSA with the p2p civ curve with me assuming negotiation isn\u0027t successful in the TLS handshake then on every subsequent HTTP request the client includes this header which is the sec - token - binding header with an encoded token by any message in that message that can be more token bindings each individual took combining indicates the type which was either to provided or referred I talked about earlier so see they\u0027re saying this is the one I use with you normally or this is one that I use with another server the token binding ID which is basically a name for the key the public key with a type indicator as well but it\u0027s effectively the public key and then a signature over that type the key type "
  },
  {
    "startTime": "00:57:25",
    "text": "and the exported key material which is defined in RFC I can remember the number but you can think of it as basically a like a cryptographically secure identifier contextualized for this usage for the individual TLS session and then there\u0027s some room for extensions what this does is when verified properly this proves that the client possesses the private key with respect to that TLS connection corresponding to the public key that was set in that message and these keys are long-lived and span TLS connections so while TLS connection might be torn down expired or whatever the token the actual binding to this key can persist beyond that because the the signature is is over the ekm for the TLS session but the key itself is longer-lived so if a new sessions brought up the client just needs to use the same key in sign the ekm from that session not session excuse me connection this idea of cross domain or federated token binding is also supported in the web browser use case there\u0027s an HTTP response header that the the relying party or client in the Roth of an ID world includes on its redirect over to the IDP or the authorization server and what this does is it\u0027s just called included referred token - binding - ID is true what it does is it signals to the client that or the browser that it should reveal on the subsequent requests the IDP the both the normal token binding it would use as well as the token binding that it would use between itself and the reliant party and this allows for that identity provider to bind tokens that to the key that the browser uses with the rely on party basically binding for the when it comes back for the initial connection there um and that\u0027s the provided and referred as the the name and the distinction between the two again provided as the one with that\u0027s used normally with their server you\u0027re talking to and referred is from a referred site in this case it\u0027s the same same header and just inside of that encoded message it actually includes two token bindings instead of one and there\u0027s guidance in the document itself that basically suggests that generic token binding implementations should be able to send referred based on some other signal to the API itself or from the application and ultimately that\u0027s what a lot of oh F is going to rely on is the hopes that implementations do in fact expose that in a reasonably useable way so with that in mind and it was quick but it hopefully gives a little bit of overview the oauth2 token binding standard that\u0027s being worked on within this working group basically provides an oauth2 proof of possession mechanism based on token binding that defeats replay or play of lost or stolen security tokens of all sorts probably the most interesting and the most applicable use case is binding access tokens you bind those against the referred to combining ID similarly sort of supporting that the federated use case so the client makes "
  },
  {
    "startTime": "01:00:26",
    "text": "request includes both the normal token binding idea that it would use with the a s as well as the token binding ID or key that it would use with the resource server the authorization server then binds the access tokens to that key that would normally use with the resource server and thus provides this proof of possession mechanism around the access token binding it to the the key use with the resource server and this can be represented and in the jwq access token as well as the introspection response with the CNF the confirmation claim to find anything in RFC 7800 and inside of that a new confirmation value tbh forto combining hash member so it\u0027s a sha-256 hash of the token binding ID included inside either the introspection response or the the JWT that basically is a hash of the tow combining ID which is what allows the resource server to make that comparison and check whether in fact the the issued token is bound to the key which is in turn proof possession of by the client there\u0027s also some text in there about binding refresh Durkins just to the provided token binding ID there\u0027s some support for binding authorization codes to variant flows around native app clients and web server clients are a little esoteric I won\u0027t go into the details and then speaking of esoteric there\u0027s also some language about binding JDBC based authorization grants and jibiji client authentication that\u0027s it in a nutshell won\u0027t go name deeper details but I will cover a few happenings since London draft 7 was published and really the only main difference here is it was clarified that the encoding of that tbh value is basically for URL encoded but that\u0027s a somewhat ambiguous in some cases it was clarified that that does not include any of the trailing pad characters or white space or anything else this actually was a result of a review on the MTO stuff from Justin that was equally applicable here so I just added the clarification and I updated and affixed a few references that were either referencing wrong parts and other documents or sort of the the HTML tooling where it does self references when it shouldn\u0027t erase to those as well as update you know related not directly but somewhat related the open ID connect token bound authentication draft a new draft of that was published and it\u0027s worth mentioning here just because the tbh confirmation claim is actually defined in there so the same clarification was added in both places even though it\u0027s sort of the the normative definition of it is in that draft the three underline sort of quarto combining specifications are I\u0027ve said it now I think two or three or maybe four ifs in a row that they\u0027re almost done but in this case they really are almost done the token binding over HTTP is in the RFC editors cube which is really good and then not far behind it the TLS extension for negotiation and "
  },
  {
    "startTime": "01:03:26",
    "text": "the token binding protocol itself are in this approved announcement to be sent so they\u0027re just waiting for a tea follow up there and I think they\u0027re close ish so it shouldn\u0027t be much longer and that\u0027s where we\u0027re at with toe combining 4\u0027o ah next one the sorry call my DNA I\u0027m thinking about to AP\u0027s reside on the same device whether it they can share a TLS connection and my understanding is no because the token binding negotiation is at the TLS level so if one app already has a TLS connection to the same authorization server or a resource server then another app should initiate another TLS connection so that it can\u0027t have a different configuration for the talk combining whether the application be wants to use the talk combining or not john bradley yubico and one of the chairs of the token binding work group so the definitive answer is it depends so alexei who\u0027s eyeballing me would probably have the better answer for Windows which probably has the most advanced implementation but it\u0027s going to if if you\u0027ve implemented token binding by including CRO net into your application and every application has its own key store then yes they\u0027re all going to be different if you\u0027re running say on Windows that actually provides an API there may be a way to actually share the same TLS connection and token binding via some magic flags that alexei is now going to illuminate us about it\u0027s under a but yes so under a book called Microsoft so each application will have its own till that cos connection and unassuming but the you know the token binding keys can be shared and that\u0027s platform specific right so like the extent to which token binding keys can be used by multiple applications is platform specifics on Windows we have a concept of app containers and if the applications are in the same app container the same integrity layer level then they can share tow combining keys calm eyed again and the first motivation of the pixie is to distinguish two applications and deciding the same device to not confuse each other so armed fair how the context of the token binding ID we\u0027ve got sharing materials so they there should be an API between the application and the operating system so that I am who and who on my tour combining keys fancy especially on the first authorization case and later token "
  },
  {
    "startTime": "01:06:28",
    "text": "binding token bound token to the resource er right so again that\u0027s application specific so work that\u0027s that\u0027s probably the part of the HTTP spec that it took us the most amount of time to negotiate with the iesg is trying to explain that you know different vendors are going to have different api\u0027s and slightly different takes on it so on Windows apparently that you have some concept of an application group so they can only share if they\u0027re part of the same ie signed by the same developer key or some such thing perhaps Android will have a similar mechanism but since they haven\u0027t and I said how they\u0027re going how they\u0027re going to expose it on Android I can\u0027t we can\u0027t answer those questions until the the various operating systems actually implement the the api\u0027s but there should not talk in binding IDs or hucked and combining keys ought not to be shared between completely unrelated applications in a single browser yes it\u0027s a single pool but again well even in a single browser it may not be the same pool because some people are creating separate token binding keys for private browsing mode etc so again yes so so it we\u0027ll have to see how that plays out as the as the developers actually implemented it for native apps called my arm say okay I think I understand the whole say picture right now but I\u0027ll say it could be convenient whether say description of this discussion in the job draft or in the document or somewhere like and say implementation not or something that would be greatly helpful Annabel Backman Amazon so regarding token binding of access tokens received from the token endpoint it wasn\u0027t clear to me is there a limit is it only one referred token binding that you can include or could you request an access token that is bound to n different referred token token bindings referred token IDs whatever the right term is the terms are a little hard only one okay so which is a limitation and intentional limitation both of the way that the tow combining message is structured and only at least at the HP layer only allows a single referred as well as the confirmation method claim that we have only has only allows for basically one "
  },
  {
    "startTime": "01:09:30",
    "text": "confirmation type of each you your question sort of maybe begs at the scoping of the keys and that\u0027s why I mention earlier that Olaf is a little bit how to pass it off is a little bit loose in in a browser-based world their scope to the effective top-level domain plus one so that they don\u0027t they\u0027re not more broadly scope than cookies and privacy considerations and all that an OAuth client given the right api\u0027s could could quite conceivably use the same token binding key across a wide variety of resource service if they have a trivial deployment of their system it\u0027s it\u0027s the client that that\u0027s largely managing them so they have a single key that that they use with right and if you\u0027re talking about a widely distributed system where you know it\u0027s completely different services in your back-end that are using tokens for one scope versus another you know trying to get all of those pieces to share the same a token a binding ID particularly when you consider that that token binding ID is actually getting bound like up at the the the VIP or the load balancer somewhere away from the actual systems that are trying to do stuff with it that actually know they need to share there\u0027s some I I don\u0027t really think it\u0027s feasible to just assume that that\u0027s going to be able to be shared so I think we should think about how we can get from a refresh token to access tokens bound to indifferent token binding IDs [Music] it you know one of the reasons to binding it to a key is so that you have to have that key in order to use it and and I recognize that access widespread access and distribute systems to private keys can be problematic but what I don\u0027t think we\u0027re in a position where we want to undermine the value of the protocol to support that kind of case let me let me rephrase my my suggestion it doesn\u0027t necessarily have to be a single access token bound to multiple referred token binding IDs as long as there\u0027s there\u0027s a mechanism for a service or for for the client to get an access token that is bound for a token binding ID from some other service separate from the one at request now seriously it this probably just falls in the realm of best practices or you know non-normative so text but I think maybe it is some neurotoxic azide thing if I\u0027m understanding correctly that the draft would support that right now you can "
  },
  {
    "startTime": "01:12:30",
    "text": "present a refresh token with the referred to combining ID for this service use that and then at some some time later present the Racine refresh token with a different referred to combining ID and get a new access token bound to a key suitable for using this service but there are some implications of that you know as far as those tokens have to continue to both be valid you know this is the subsequent refresh for a new token shouldn\u0027t invalidate the previous one there\u0027s implementation details that fall out of that but again aren\u0027t normative but are probably worth being discussed as best practices are not normative texts so we have identified that in some clustered environments where the the coinage is being distributed across the cluster it may just be the token binding isn\u0027t the right answer that well mutual TLS may actually fit better for some of those server based applications the sweet spot for token binding tends to be more than mobile applications which are dynamic and generally not clustered clients that is true although there\u0027s there\u0027s wording and important here specifically for allowing a client to have an unbound refresh token so you can be used from different nodes or whatever while still obtaining bound access tokens for for outbound use specific to a key that only they have actually a lot less worried about the refresh token being bound to a single token binding ID just because that\u0027s having a central system or at least a single distributive system that is doing token refreshes that just kind of a reasonable thing it\u0027s the access token that\u0027s potentially being used by n different client systems to you know M different resource servers that where I see the problem but I think I think it\u0027s a good point that if this doesn\u0027t have to your token binding isn\u0027t necessarily the hammer to use on every now that\u0027s absolutely true so as far as the resource server is concerned you\u0027re either you or some sort of introspection so in principle the token binding ID for that particular access token can be contained inside of the access token so you\u0027re not really just because you\u0027re creating a new access token potentially for a different part of the client that\u0027s that\u0027s talking to that resource or both of them can be valid at the same time you\u0027re not revoking it so I think there may be some of these these larger sort of edge cases that we might want to go through if we have some extra time here but the again for the larger server implementations it just may be easier to use mutual TLS which still works so "
  },
  {
    "startTime": "01:15:31",
    "text": "we\u0027ve got let\u0027s you might have to take that so thick you have a common yes the card Amazon yeah I haven\u0027t looked at this back in a while so I don\u0027t know if this is included but just picking up on what they\u0027re talking about one of the issues in the past is that your TLS layers manage at your load balancer but your access token is out the application right and so how do you get the trust where that the ID vis negotiated somewhere different than where the app\u0027s trying to verify it sounds like not necessarily that maybe some standardization around how does a load balancer what what header does it pass that down to the app is that that\u0027s a fan okay okay tastic I did and so I\u0027m working on exactly that if I understand you correctly and it\u0027s gonna be discussed on Friday last thing on Friday if you\u0027re still around please come to the token binding working group session and express your support for for such a draft okay good thank you nice it sits in the token binding working group it\u0027s call it has a horrible name I can\u0027t do better it\u0027s a HTTP tow combining with TLS terminating reverse proxies or something like that but you it\u0027s really short but you can find the draft so yes I agree it\u0027s a problem that I\u0027m trying to try to put out something that\u0027ll help solve it so so right it you want to give a quick update on those documents yeah it\u0027s five minutes five minutes no problem all right ooofff mutual TLS some of this is give a real quick over being contact why is this being worked on it\u0027s an enhanced security profile of OAuth 2 based on TLS client certificates mutual TLS the draft is already being used by open banking PSD to ask sort of regulatory regimes as well as being preference of profile by other stos what is it it\u0027s an asymmetric key based client authentication method for for the client to the authorization server using mutual TLS there\u0027s two methods take PK I based in a self-signed certificate mode and then also mutual TLS certificate bound access tokens for proof of possession protected resource access so actual pop tokens and this similar to to tow combining but with a different name uses a confirmation member inside the confirmation claim this one\u0027s called x5t pound sha-256 and it\u0027s just the shock to be 656 thumbprint of the certificate embedded inside the the access token confirmation clam a few things have happened since london working group last call happened I was on vacation for some of it so that was fun getting the feedback was trying to relax on the beach draft seven eight-nine have been published mostly "
  },
  {
    "startTime": "01:18:32",
    "text": "it\u0027s been editorial clarifications and improvements from people making my text better thank you all one sort of important thing I think is worth noting here is that the I dropped the use of the sender constraint terminology with respect to access tokens because a reviewer pointed out that going back to the pop architecture document sender constrained is defined as they as a client authenticating literally authenticating itself via some other method and having an access token constrained or bound to that client whereas this this one actually is kind of a weird middle but more than anything the access token is is bound to the certificate itself and not the client identity so trying to be more consistent with terminology here I just got rid of the sender constraint terminology and I include a picture of NAT here presenting at a conference just a couple weeks ago extolling the virtues of sender constraint tokens and this particular draft I guess he\u0027s not here but I was hoping to give him a hard time about using the wrong terminology and push on it but that\u0027s the only major like difference that\u0027s not editorial and that in turn came along with a changing of a metadata parameter name to reflect that small but legitimate breaking change and that\u0027s all the stuff that\u0027s really happened and I wanted to make the pulp fiction reference in here trying to find the shepard for this document but this has all been taken care of this morning we got a shepherd start the shepherd right up so document state has been changed so this is now this was legitimate on Monday but is no longer accurate so thanks for doing that things happen quickly here in the IETF so that\u0027s in these are moving thanks for all the reviews I\u0027m looking forward to it progressing Oh - token exchange now in draft 14 real quick overview this is like a STS framework via the token endpoint on an authorization server SD SPN security token service I want to try to provide contacts here but it\u0027s hard because it\u0027s really sort of a Swiss Army knife of just token in token out actually two tokens and in some cases and it\u0027s oaken out with with you know claims or content representing that delegation this is just one use case which is sort of the resource server as a client gets an access token in from a normal off flow and in chain exchanges that with its own authorization server some other authorization server sorry its own authorization server only to to get a token that\u0027s appropriate for usage on some back-end system the details are here it\u0027s just but it\u0027s one of many use cases that are facilitated by this one "
  },
  {
    "startTime": "01:21:32",
    "text": "that I just hear a lot that\u0027s enough for context and an opportunity to show a picture of my kid from a year ago happening since I eat 99 so 99 in Prague was actually the last time I presented on this because it\u0027s been sort of in the throes of review or latter not not working group but a lot of review we\u0027ve had graphs 10 11 12 13 and 14 publish clarified some stuff around the Act claim the act fame is the actor sort of a claim about to whom this token and its privileges have been delegated and it says that it just clarifies that only that the top-level claims about the subject and the token itself as well as the current actor which is the most recent actor in the in Act claim are actually to be considered when applying access control decisions had several clarifications and editorial improvements stuff mostly out of 80 review I did change with working group consent scope and client ID claim names to what they are now they had previously been SCP and CID to align more consistently with what\u0027s what\u0027s in the introspection draft and try to just normalize names I try to really to go with the shorthand convention there which made sense at the time but in retrospect and having some developers and other spec writers look at it consistency between the two made a lot more sense and will make even more sense probably when Torsten presents his next draft here about signed introspection responses because then they\u0027ll line up some new you are eyes were added a long time ago to represent sam\u0027l tokens no normative stuff around it just giving you our eyes to say hey this is a sam\u0027l token and I have answered quite a few questions and with this fact that there\u0027s no normative support in the document for validating or issuing access tokens from other authorization servers it\u0027s always been that way but it seems to be something that some people are interested in asking about but I think that the complications as well as the security considerations definitely warrant keeping out of scope for this document and having those kind of use cases be supported by a more explicit exchange such as the GWT bearer grant or jbt assertion grant currently this document is in ad evaluation waiting for write-up on a point raised that I think I\u0027ve addressed with that Act claim I think ekor left so it\u0027s sort of that kills a lot of this type slide but I had three things I wanted to do in this slide one is I always include pictures of the places where we\u0027ve been are gone closest thing I had here was a picture of me in Bangkok from almost 20 years ago I did want you to get the one night in Bangkok song stuck in your head so hopefully I\u0027ll have that going on the rest of the night and the main point of the slide was to try and sort of go into actually closing out his point needed and moving things forward because I think it\u0027s been taking care of him we\u0027re just sort of sitting here but he\u0027s he left earlier so yeah so yeah okay thank you "
  },
  {
    "startTime": "01:24:41",
    "text": "five minutes Thurston Kenny yes Torsten is Houston okay it\u0027s maybe okay Torsten getting us not there you go hey guys can you yeah we can now you have five minutes this is such a complicated time okay good yeah then is the presentation visible yes okay because I can\u0027t continue it um so I\u0027m gonna my name is Dawson notice that yes I\u0027ve come and I would like to present a individual draft that I did with you know from connected ID it\u0027s a small extension to token introspection next slide please which allows a resource server to request and then authorization so it responds with a chart we thought can you please oh I can\u0027t see which slide you\u0027re showing so assumption is in slide number two so it shows the the extension so the client asked for a chart representation of the introspect response and the a s just answers with representation which allows us to sign and provincially also encrypt the response next by please the use case for that is quite simple we are we are looking into my eye assurance level use cases which is payment and electronic signatures and those use cases require the resource server to keep track of all the data that it consumed from authorization server for auditing and number affiliation our purposes and that\u0027s why it\u0027s a good idea to have a science assertion on resize and use of structured access token is not always possible for example iterations where you want to have an integrated authorization which allows the client to obtain a grant that is good for interacting with different API is for example to sign a contract on one hand and to initiate a payment on the other side so we can\u0027t carry all data in one shot because it would violate privacy regulation and that\u0027s why we sing a token introspection is a much "
  },
  {
    "startTime": "01:27:42",
    "text": "better fit but our top introspection needs to support signing and potentially encryption and that\u0027s why we have written this graphical next slide please it shows in detail how this is going to work it\u0027s quite simple and there is a new except declined you that the resource or uses the accept our application slash dot GWT next slide please das just answers with the perspective GWT next slide please um and the a s determines whether what with algorithms are being used and whether there is just assigned a judge or a a signed and encrypted job either by default or the a s may supply some configuration data of why our reservation the draft also defines some registration ways for that following the pattern established by the Open ID connect on dynamic client reservation next slide please so that\u0027s the last slide I already presented it off in London and got some feet some pushback on the topic because we also had included proxy use case because of the fees by feedback we got rid of that on focusing on the non-repudiation between our s and is entirely so what we did is we incorporated we did a version oh one and we incorporates feedback from the mailing list so thanks to the hills and battery for giving us feedback we added a lot of stuff regarding security considerations we edit metadata and so on and so on and so on and the reason why I would want to present that today is I would like to ask the working group to adopt that as a working group item that\u0027s it from my side now I would cut the line after Justin right so Justin richer they deleted all the stuff that I thought was a terrible idea from the last document so that\u0027s a huge improvement the security discussions is going in the right direction I think it needs a lot more chewing on but that\u0027s what we do here I would support this going forward with the caveat and I raised this in London as well that we that we think about using this response mechanism for other parts of the OAuth protocol that might also want a signed response token endpoints registration endpoints yeah yeah oh yeah we\u0027ve got a bunch of other places where this where this patch might also apply whether we do all that in one document or not I don\u0027t know or care right now but I suggest this as a good starting point moving forward and support it thanks and so we\u0027re gonna try to take a home on the mailing list or ask for adoption of the mail a because "
  },
  {
    "startTime": "01:30:42",
    "text": "we don\u0027t have time right now okay thank you very much everybody Thanks thank you to us thank you pleasant meeting yeah "
  }
]