[
  {
    "startTime": "00:00:26",
    "text": "All right, it's 1300, so it is time to get cracking. Welcome to the MLS Working Group We're going to be here for about two hours. We've got lots of slides lots of presentations, lots of extensions It'll be fun All right, it's early in the week, so you may not have seen this. This is the note Well, a reminder about the IPR policies and any harassment, code of conduct stuff like that. Summary of the IPR statements are if you know something about a patent, you've got to say something That works, you can do disclosures, you can do disclosures on your own, in the whole nine yards yards what else we got know really well this is stuff about you know, personal conducts We'd like to make sure that we keep this professional. No need to do attack each other on the whole nine yards And, you know, if you don't like the way I'm doing things, you can always complain to other people up the food chain, etc. But you know, let's just keep it all professional. It'd be great All right eating tips. Again, the onsite meeting tool, if you can scan that QR code, you'll be in the, you'll get into the room and so then it'll record your present here. So the next time when we need a room, we'll get a right-sized one It's also the way we're going to manage the queue because we'll have remote presenters and we want to make sure that we're able to get them in and out out If it's all right with everybody, I'll just run the slides unless somebody really, really wants to do it themselves All right, so our agenda"
  },
  {
    "startTime": "00:02:02",
    "text": "So I'm in this trivia, which is this. Hopefully we'll keep it short Then we're some working group drafts that we're going to talk about We have one remaining issue in the MLS architecture draft So Brendan's put together a PR You must kind of go through and explain it a little bit. We talked a little bit about on the list and a lot in the repo and Conrad has like another kind of thought on it because this is the remaining issue that is stopping us from progressing forward with extension. So we're trying to figure out how to how to close this uh close this out and so we can I think there's something that needs to be said we just got to figure out how much we want to say Then we start talking about extensions for the rest of the time So Raphael sent me some slides like minutes ago to actually talk about the base MLS extensions document, which has already been accepted. And then we have a bunch of other extensions that are either directly related to MLI or, as this list starts, the ones that are related to MMI we have a bunch of other extensions that are either directly related to MLS or as this list starts, the ones that are related to Mimi, which is like, you know, instant messaging again, and then some more draft I didn't update this bit. britta hale sent me some slides if we have time. We'll go over some thoughts that she had She and others have had about doing post quantum in MLS So without further ado, did anyone want to bash anything? Well, not me, hopefully Okay, okay, cool. Good. All right so we'll stop this one. Brendan, you're up. I will get the slides going There we go There we go. All right right Okay, hello. I'm here to talk about APR that I opened. I guess about two months in the architecture documents to cover invalid commits and access control. So next slide, please First thing to note is, why is this PR needed? So at last IETF, we talked a lot of about encrypted versus unencrypted hand-check messages and just part of that conversation, a lot of reservations came up and were expressed"
  },
  {
    "startTime": "00:04:02",
    "text": "about people not feeling comfortable deploying MLS with encrypted handshake messages And one of the concerns there that stood out to me was concerns about how to do access control So, you know, if the group state is encrypted, how do you know who's actually allowed to be in the group and send messages to That's a fair concern And on top of that, sort of as part of a exploring this issue, other security issues in MLS deployments have kind of come up, what I'm going to call a forced rejoin attack. And so in particular, Mimi is potentially vulnerable to this And just to frame the discussion, these are, you know, architecture issues. They're not really particle issues, nothing is wrong with MLS a protocol. The issue is more to deploy it in a way that introduces these sort of security aggregation this security degradations because these are architecture concerns, MLS are just the right place to discuss these problems but kind of on top of that in addition to architecture being the right document there's also an onus on architecture to discuss this because the lack of current text is negatively affecting real-world use of MLS and other contexts So next slide, please So a first rejoin attack, what is that? So in many and most deployments that have come up so far, the delivery service is the one who chooses which can commits into given epoch, not the group members. So have several group members also commit at the same time, the delivery service is the one who chooses which commit ends the epoch and it says this is the commit, this commit wins, the epoch is over no more messages to this epoch And of course the problem with that is that the delivery service has relatively limited visibility into which commits are actually acceptable to members The delivery service can't verify the MAC. It can't verify a signature it can't verify that the encryption works correctly, it can't verify"
  },
  {
    "startTime": "00:06:02",
    "text": "all these things. So the consequence of that is that the delivery service can end up choosing a commit that members are unable to process And what's typically done when that happens, when the delivery service says, you know this commit wins but this commit is not able to be processed Members are just supposed to do an external rejoin that's kind of slightly more robust, because it's easier for the DS2 to verify the next to join should work in theory. Next slide There are a few issues here with this issues. So the first one is that this external rejoin mechanic is meant to prevent a trivial DOS attack. So the DOS attack is where a member sends a command which nobody's able to process, the DS says this wins, and then nobody can process it, so the group is kind of just stuck and can never go anywhere So it's meant to prevent that DOS attack And it kind of does, but you can make the DOS attack again You can make the DOS attack work again just by kind of adding some extra steps What this does do is it prevents group members from achieving PCS through updates or commits. Because kind of what you think, if you kind of think of the abstract, what you're doing is you're saying, if I ever receive a message I can't process, and anyone can make a message I can't process I'm going to throw away all of my secure state and I'm going to download the secure state from the server and use whatever tells me the state should be which you're doing, is you're saying, if I ever receive a message I can't process, and anyone can make a message I can't process, I'm going to throw away all of my secure state, and I'm going to download the secure state from the server and use whatever to tell me the state should. So that's kind of not great. And also, it allows arbitrary modifications to the ratchet tree So people can change the group in ways that they might not otherwise be able to if you weren't kicked out of the group you know if you have like a policy in the group state that says Alice isn't allowed to join this group because she's been mean to be in the past and then you get kicked out the group and you come back and that like aspect of your group policy was removed and then Alice has rejoined the group you have no way to know if just the DS did that maliciously on its own or an actual member of the group who was allowed to make those changes actually made those changes So those are the main concerns to impact that a little bit more Back to what I said, the simple DOS attack here, that this is"
  },
  {
    "startTime": "00:08:02",
    "text": "going to prevent is when users something to commit that nobody can process The delivery service chooses that one is the one that wins and then no one can move forward. So if you externally rejoin to get around that, it opens up a new kind of DOS attack. So when a user sends a commit, nobody can process All of the group members are suddenly triggered to externally rejoin. And as part of this, cycle of external rejoins, the malicious user can all send to commit with the wrong group info because Walt the TS is largely able to verify the group info, there are still things in it that users need to join that the DS can actually verify So you can make a group info that looks good to the DS, but isn't actually correct And when you do that, these other honest, users that are just trying to rejoin the group, they end up using the incorrect group info And they actually end up being the ones who's in the invalid commit. And then that church triggers another cycle of rejoins because people can't process that committee either And so they have to rejoin. And you can kind of keep this cycle going infinitely And what's kind of fun about this is because it's not jon peterson sending invalid commits. It's basically in user can end up sending it in a valid commit It makes it really hard for the DS to identify which user in the group is actually malicious. Nice to this So it's the DOS aspect. There's also the post-compromised security aspect So the attack here is if Alice's view of the key schedule is leaked in some epoch, we're going to call that view so the attack here is if alice's view of the key schedule is leaked in some epoch we're going to call that epoch i um and alice sends a PCS achieving update to the group, which is the processed by Bob, at this point, you would think the group is secure because Alice was compromised. She sent an update It was processed by people, so nobody should be in a compromised date anymore But what can actually happen is the DS can send a junk commit to Bob. When Bob sees that commit, he immediately gets triggered to do an external rejoin And when he does this external rejoin, the DS can provide Bob with the group info course"
  },
  {
    "startTime": "00:10:00",
    "text": "corresponding to Iuqai. And when Bob uses that to rejoin, he ends up rejoining the compromised epoch and that allows the DS to eavesron So essentially if there was ever compromised at any point in the group state, you can use this external rejoin mechanic to put the user back into the compromised state and never allow them to kind of leave that. And it appear like RFC 94- implementation. This is all that's needed to prevent the group from every achieving PCS again We have sort of talked about like different potential medication on the list and then they get up to get but those medications tend to fear a lot more into like actual protocol implementation where like you're looking at specific things and you're looking at specific things and messages and like trying to vary specific things about messages So that tends to go a lot more into the protocol like engineering sides of things which is not you know necessarily appropriate to talk about in depth in the architecture document. But yeah, Richard So I'm just trying to follow along with this attack I'm confused by step three here where you say the DS sends a junk commit. It seems like the commit the sort of commits we're talking about, which are invalid for some members are things that only the members of the group can generate not the DS or someone outside the group so what can you expand on how step three works in your mind So a junk commit is any commit that can't be a process for any reason. So, I mean, you can just like generate random bytes and say this is a commit and that would be a good junk commit, you know. But it's a junk commit if the signature doesn't verify it's a junk commit if the MAC doesn't verify, it's that's what it's junk commit is. And the DS can't check any of those things, the DS can't verify the MAC, it can't verify the signature and so on, so that's why it sort of works in the deniability way, where the DS could say, hey, someone actually sent this and I just couldn't verify that it was drunk Does that make sense? Yeah, it seems like that's making a lot of assumptions. Well, for, for"
  },
  {
    "startTime": "00:12:00",
    "text": "all, if commits are sent in unencrypted, then the DSI can verify the signatures because it has all the data it needs right but it can't verify like the confirmation to or the Mac or stuff like that. So there's still things in there. It can't completely verify that it's valid, yeah. But, okay, so they can at least verify that it's from a member of the group so from these by a member of the group. Signed by someone who is in the ranch tree. How about that? Can't verify that someone who has the group secret um but in addition to that, it seems like there's a lot of assumptions baked into here as to how client process commits that fail for any of them reasons Right. Well, in this case they were talking about, we're talking about where you have the external rejoin mechanic. So the DS chooses which commit wins for each epoch, and if users can't process that, they have to do a rejoin right my point is like the the way you end up in this attack is a certain behavior at the DS and a certain specific set of behaviors at the clients. Yes So it's fairly specific, yeah Okay, Brendan, can you speak a little bit closer to the mic? All right, everyone may So, okay, I'm going to yes it's fairly specific yeah Brandon can you speak a little bit closer to the mic oh no one may so okay I'm gonna I'm gonna restate what I think this attack is so first of all there has to be a key schedule compromise of one of Alice's devices And Alice just does an update pattern doesn't replace the device doesn't reenet, doesn't do anything else, just does an update path The second thing is that the DS maliciously sends a junk commit to at least one other member and and based on the implementations that I've seen, it would need to send a junk commit that"
  },
  {
    "startTime": "00:14:00",
    "text": "already has quite a bit of valid looking MLS MLS And then Bob would have to be, the policy of the group would have to be set that Bob triggers an external rejoin automatically in this case Did I get that right? Sorry, can you restate it? Alice has a key schedule compromise And rather than replacing her than uh replacing her client or reenitting only chooses to do an update path. Does that change this? scope of the attack for you if Alice only does an update path? Because I think that it would still work if she does a re-init as well It does, I think it changes the scope of the attack If she does a re-init and there is not a new group is not created venue, you know that then alice noted If Alice creates, does a reenet and the new group is created and Alice is in the new group then she knows that everything is healed and this attack is not possible So a simple record recommendation would be if you care about this class of attack, if you have a key schedule compromise and external rejoins are enabled do a re-enit instead of an update pattern problem solved. Well, the security guarantee here that we're supposed to get from doing any commit is we're supposed to get PCS from any commit So that seems to kind of change the whole from doing any commit is we're supposed to get PCS from any commit so that seems to kind of change I mean we have a variety of other attacks which we have which we have"
  },
  {
    "startTime": "00:16:00",
    "text": "mentioned and are mentioned in the security considerations that involve sending you know sending a commit that is that has has paths that are decryptable to some members and not to others, right? There is nothing we can do to prevent those problems. We can just detect them So because of the nature of this protocol, we can't solve every possible problem that occurs with them So I don't really see this as a burning issue Like, we can do, we can, we can solve this particular problem by doing a re, by Alice choosing to do our re-in-et. And also, if you don't want to do it reenets and you just want to do classic update path PCS repair You don't need to accept external rejoins Those are two perfectly valid options for solving this problem That's all I, that's all wanted to say about this slide Okay, thank you Are there more people with their hands on? There are. There's Raphael's coming in Yeah thanks. So I think, unfortunately, I think this is still a valid attack, but it's very, very, very subtle Because as Richard mentioned, a number of stars need to be aligned essentially, for it to succeed. And I think it's important that we understand exactly what the conditions have to be in order for it to work. So one of the things you said on the earlier on an early that the rescind mechanism was supposed to prevent a DOS attacks. I think it's, it doesn't really prevent them, but it's a way of getting out of it"
  },
  {
    "startTime": "00:18:00",
    "text": "mechanism was supposed to prevent a DOS attacks. I think it doesn't really prevent them, but it's a way of getting out of that situation. That's just a technicality really I second what Richard said And so in step number three, what you imply is that any junk commit is immediate going to trigger an external rejoin and I think that's a big assumption. So for some applications, that might be true but for others who still support Resink or the external rejoin, it might take a while until they actually rejoin because for example the ux might be such that you have to wait for user inputs it's not uncommon in into an encrypted messaging apps that you have a series of messages that say unable to decrypt and only then a user actually pushes the button in order to reach on It doesn't invalidate the attack, but what I'm trying to say is that there's a number of things that don't make this as straightforward as it might be. Yeah and I guess Conard is going to say more about it in a minute as well Raphael, did you say earlier that? the DOS attack doesn't work when you have external rejoin for some reason? No, I meant that the DOS attack if I understand it correctly, always works, but the external rejoin is only there well, to rejoin, not to prevent the attack, but to recover from it. That's what I meant You promoted the external rejoin to a mechanism that it's not, it's not a prevention mechanism, it's only a recovery mechanism Got it, okay, so once the DOS attack stops then you can recover With the external rejoin, yeah. Okay Okay Yeah, that's it. Thanks So first of all, thank you for putting this in. I think that the point"
  },
  {
    "startTime": "00:20:00",
    "text": "the issue you're pointing to is a very important one This is a known issue in signal messengers today. It already was a message a couple years ago for what happens with basically a junk update. And as Rafael and Richard already noted, it's application specific, that's why I said most signal based, not all signal based messengers, but many of them are affected by this. And why I highlight that is unless was designed, our baseline was at least as good as signal, right? And so if we're talking about that sort of, correspondence, we are right on point Now what you're pointing to is very much an issue because it goes a step beyond that. And how do we address that? And I think that we can get to some nice ways of addressing it and recommendations I would recommend that that goes into an extension though versus and an architecture change here so that we are keeping to the common baseline as we currently have it So I think the, I guess the plan is to go through this, then we'll have Conrad go through his slides, which are very much related to this, and then we'll come up. We'll try to figure out what the best way forward is to get this documented in some way And yeah, and I mean people that said that, that's like, has this issue as well, but that is kind of a sad argument because it's kind of, I don't know, letting go of the actual like provable, like, simple to understand security guarantees that we have in MLS because MLS is in a lot of ways better than the signal protocol and that it's standardized and it supports, you know, large groups efficiently and also it's supposed to have like this really nice provable security model and I don't know saying like well signal is also vulnerable to this is I don't know it's sad Sure, we can definitely aim higher and I think it's worthy for us to do so the issue here is that as the PR is currently stated, it is more of a generic statement of the problems"
  },
  {
    "startTime": "00:22:00",
    "text": "versus a more concrete solution. And there have been a lot of discussions already on, I'll say, nice, elegance solutions to this. And if so if we go all to try to address the PCS it's a matter of like can we do that nicely and fully versus Okay, yeah so you made a comment just a minute ago about the about sort of abandoning the straightforward you know, easy to understand PCS updates, but I don't think that's really true. I think that it's we have a difference set of assumptions in environments where we accept external commits So if you're only going to accept external proposal we have a different set of a different set of those assumptions And I think that that's the like I think it's appropriate to mention these problems in the architecture document but I think we I think that they are, that there is a fairly well understood set of, uh, those kind of trade-offs The other thing, I just wanted to clarify about step three is is, for the DS to send a junk commit, I think it would need to send a commit that had a valid signature So it would need to, I believe that the only way this attack is possible in step three is if the DS actually was in collusion with the attacker of Alice device, and it was more than a key schedule leakage that it was also a signature leakage"
  },
  {
    "startTime": "00:24:02",
    "text": "You don't need to collude with the attacker on Alice device. I mean, so but I think it I think the, I think for the DS to send a commit that will trigger an external rejoin in any implementation that I'm aware of, that it would need to have the signature key of a member of the group. Of some random member of the group Of a member of the group. Potentially, yes that's a very different kettle of fish from what you're talking about here. Because as soon as you say, that somebody has, somebody has that level of access, then they're is a, you know, there are there's three quarters of a page of additional attacks that are possible and noted in the security consideration of RFC 9420 And you're wrong on that one. So, of course, the attack is much more powerful if the attacker has a signature key as well, but it still works with a the signature key, unfortunately And I was also going to say that it's not clear to me at all that it's necessarily impossible to produce a junk commit by trying to use another user, for example as like a signing oracle. So if you have this external, rejoined mechanic, then it is pretty easy just to give users like, you know, like random group inventions or maybe like an old group info and get them to sign a commit under it So that doesn't that's not necessarily like the hardest problem in the world is to get a signature on your junk commit So, and Brendan, do you? have more slides because it kind of devils into discussion here? I do have more slides, yes. Okay, so let me just drop a quick, quick passing thought here, and then I'll get out of the way"
  },
  {
    "startTime": "00:26:00",
    "text": "It seems like the focus here you know, given that a lot of this is about automated region behaviors and things like that, that may be the right focus for a PR, but I'll reserve any more thoughts on that later Okay, you're trying to cue Q queue. Okay, so can you go back to that old slide? You want to go back? Yeah so like so can you go back to that old slide? You want to go back? Yeah, so locate, oh, no, forward one. One more? There you go, thank you. No, forward two now Oh, forward, sorry There we go, stay there So like I say at the bottom, and up here, RFC 9420 implementation which is this idea of, I see a bad combat, I do an external rejoin that's all that you need for this tech to work and to prevent the group from ever achieving PCS again What's happened a lot in the list discussions is that people have, you know, jump straight to proposing solutions and saying, oh, well, we can fix this by, you know, checking that the EPOC counter is great than it was before, or we can, like, you know, do all sorts of things or like what we kind of just discussed right now, which is the idea of you know, it's not a junk commit if it is signed by a group member and like how can that potentially prevent it? thing. But we have a lot of like ad hoc proposals rather how to potentially address these issues. And with all these ad hoc proposals, they veer a lot more into actual protocol engineer and they also tend to not address all of the issues So what we've been talking about so far is trying to adjust is trying to address like the post-compromised security attack, but we don't actually address like the dOS side of the attack So that's kind of the thing is we can't explore the solutions to these problems. I'm not saying that the external rejoin mechanic is irredeemable. I'm just saying this is a problem and that it does need to be addressed in your implementation or else you'll have this vulnerability And in terms of actually how to you"
  },
  {
    "startTime": "00:28:00",
    "text": "address it, that's going to be, you know, a lot more complicated it's going to take a lot of work, it's going to be protocol engineering. And I think that definitely makes sense to go into its own protocol document somewhere So that's what I wanted to say. Next slide, please Okay, so what is actually in this PR with respect to invalid commits? So with respect to invalid commits, we have brief description of three different approaches to handling invalid commits. The first one is that members choose the next commit through consensus vote Richard, do you still have your hand up? No Okay, members choose, members choose the through consensus The second option is that the delivery service chooses the next commit, so the D.S chooses the winner, and possibly you also have this external reading mechanic. That's what we've been talking about so far And then number three is the group member is silently ignore commits they can't process, so this approach is a lot more similar to what you would kind of do with any other invalid message where you know, the DS sends you an application message that you can't decrypt, you kind of just ignore it You don't like do anything specific. And so why do we decide to talk about these three specific approaches? We talk about them because they cover all of the proposals that I've seen for handling invalid commits So in that sense they're kind of exhaustive and then next slide please what do we actually say about each of these approaches? So for number one, for the consensus approach, we say that there is a DOS risk and also you can potentially force users to stay in a compromised state, because if you send a commit and you block actually processing the commit on trying to find consensus, then you can force the user stay in a compromised state longer where without consensus, you would be able, you would be able to just to send your commit, see you get sequenced, and then process it, and then you would be out of your compromised state For number two, we sort of talk about the DOS risk as well, and also mention how this approach with the external rejoin can allow the DS to revert PCS achieving updates"
  },
  {
    "startTime": "00:30:00",
    "text": "So that was basically the last two slides exactly where we say you know, here's how the DOS risk, this is how the DOS attack can work and this is how the PCS attack can work And then for number three, where group members can silently ignore commits the camp process, we say that this can allow the group state to fork, which complicates the operation of the group in a lot of ways because you can't think about the group anymore as a linear series of epochs, where like epoch 2 follows epoch 3 and then follows epoch 4, and there's only like one set of messages for each epoch You have to think of it more as like a branching tree because members can choose to accept and process different commits And that can be complicated to support just on its own and also if you do want to do some kind of external rejoin and you have to lot of like different head epochs the DS has to find some way to choose like which head epoch I'm going to allow you to do your external rejoin to so it complicates the operation quite a lot. And the next slide So what's in SPR with respect to access control? We've got brief descriptions of two different approaches. Richard is your question about the last slide. Oh, I'll just let you finish me Okay. So what's in this? period with access control? We have brief descriptions of two different approaches The first one is if you have public handshake messages we say that you can do the kind of obvious thing of just having the DS inspect the ratchet tree and then look at the ratchet tree and see who's allowed to be in the group for each epoch. That's pretty straightforward I think everyone likes that one. And then for number two, if you have private handshake messages, we sort of briefly mentioned that you can compute a bearer token from the MLS Key Schedule and then you can use that bearer token to restrict access to specific epochs. Because if it user is not in the group state and not actually allowed to participate in a specific epoch then they won't be able to compute the right barrier token And so that's kind of clean as well. And then why I talk about these specific approaches Because they cover all of the proposals that I've"
  },
  {
    "startTime": "00:32:00",
    "text": "seen. And also they kind of have complete coverage of handling public and private handshake messages. So that's nice Next slide. So to recap the motivation for this PR and the reason that I think it's important is because we've seen, you know, implement your and other working groups like Mimi unintentionally reduce MLS's security through their specific architecture choices, and the keyword there is really unintentional Like if people read this text and they say, I understand all these problems, I want to handle all these problems that's great. In practice, though, I think that is less likely because what happens is people read this and they think that it's prescriptive. They think that I'm telling them to do something specific and I think that maybe reflects more so that they're reading it and they are feeling pushed to go in a different direction. And then the PR addresses that sort of unintentional architecture choice by discussing the approaches to handle invalid commits and to discuss the tradeoff between them and the attacks that are possible in different cases We also discuss two approaches for access control for public and private handjack messages because I'm not trying to rehash the conversation we had at last IETF about recommending that people use public or private handshake messages but if people do want to use private handshake messages I think that we should have text to help them feel empowered to do that And then like I said, this is not prescript it's only descriptive. It's just saying if you do X, you will have to deal with problems, you know, Y and Z Yeah, so that's all I got All right, cool. So what I think we're going to try to do is have Conrad do some slides too, and then we're going to loop back. So if I can ask you to sit down and then we'll end up being back here So Conrad, I'm going to pull the slides up up Think, think, think, confirm my selection. There we go go Hello So I'm talking now because Sean, you asked me to kind of summarize"
  },
  {
    "startTime": "00:34:00",
    "text": "the attack. And I think Brennan already kind of did that so I'll just be very quick about the attack itself and then maybe jump into a few ways that we can deal with it as Brendan said from more from a protocol design stand so that might be something that we want to include an extension or in an archive or in the architecture document or in an errata document for the protocol document itself so that kind of procedural question that I'm not sure of. But yeah, I'll just start with the attack itself just to rehash what Brendan just said So Alice is in the group and somehow her local state gets corrupt This could be because the DS did this or some other, something else does this And so in any case, Ellis wants to rejoin the group. Alice fetches a group info and does an external commit and now Alice is back in the group so that the re-sync operation without an attack for now Next slide, please And the problem here, and that's, and the RFC is not super specific in terms of, like, doesn't prescribe a lot of checks in terms of what how else should look at this group info before she actually rejoins. So Alice wasn't even epoch once, this kind of chain that you can see there then switch to epoch two and then to epoch three And now, next slide please, her status is somehow compromised Could you switch to the next slide, please, John? thanks and next slide again sorry this is kind of a stepping through slide. So let's go to the malicious delivery service, patches a group info and now the malicious delivery service gives her the group info for epoch 1, and Alice does an external commit and now she's back into epoch one and so if EPOC 2 was Bob's update, then the episode has just succeeded in turning back uh bob's PCS"
  },
  {
    "startTime": "00:36:00",
    "text": "gaining commit. And I agree with Brendan, and this is not, or with all the other folks, that that talk just now that this is really not a great attack to have because PCS really goes at the core of MLS and re-sync is like you don't have to do it but it is an operation that we specify in the protocol specification. So I think we should at least give some more guidance on how to avoid this bit particular attack. Richard. Just quick clarification here. This external commit that Alice sends initially initiating into group one, or I guess this would be moved to group from a group from epoch one's like two prime like that's not anyone something that anyone else in the group would accept right because they're all at epoch three where we're out fallen out and so they would all view this as an old commit on an old state of the group in theory yes, but the adversary could also corrupt the state of everyone else and serve them all this same group info and, you know, have them gather in this false state everyone except Bob, of course, who might, you know, maybe even bob but yeah bob might be a bit confused Okay, thank you So, so, yeah, it can. So it seems like the fundamental mechanic you're assuming, though, is that the DS can somehow synthesize something and send it to a client that will cause it to do a re-sync That's the precondition, yeah If the episode we can do that, then we run into this problem And Brendan has laid out, like, how this might happen in various scenarios of you know having the DS controller commits and stuff Okay, so how bad is this attack? It allows the DS to roll back previously processed PC update, which I think, again, goes to the core of MLS We should give some guidance on that There's not enough validation rules with regard to external commits in the RFC to prevent this to my knowledge at least I haven't found anything there might be a bit"
  },
  {
    "startTime": "00:38:00",
    "text": "somewhere saying that you have to, you know, you cannot roll back the epoch, but we'll get to that in a second And then another comment as Ron said, there are plenty of other attacks that are possible if they adversary controls the ES, that goes to the direction of denial of service. And so what the DS could also do in this case is just block Bob from doing the update in the first place, and thus you wouldn't have to roll back the PCS update but the attack that Brandon found was a is a bit more powerful because the episode can just compromise Bob and then wait and wait and wait and wait and at some point in the future as long as the kind of this original group state has not expired because some potential has lost its validity it can just force everyone to go back to this really old group state where the adversary has all the secrets or all of Bob's secrets Okay, next slide, please So just to kind of give a quick list we discussed a couple of mitigations already on the pull request. The first one is the kind of easiest one that can to mind immediately was just saying, okay, if Alice stayed fixed at epoch three, then surely she shouldn't accept a group info that has an epoch lower than that. But then as Brennan pointed, out, you can get a, you can get kind of a signing oracle for other group members if the DS kind of plays it, plays it right. And then the DS can actually get another group members to do a commit and create a group info for an EPI epoch that's higher the one than the one that Alice is looking for and so kind of bypass this check but I still think this check is good to have. Then there's transcript verification, which I'll get to in a second And then the last one, Ruffel suggests, is kind of have the client keep track of the public keys that have been updated. And then as soon as it sees a group info that has any of the old keys in it, then it just rejects it outright Okay, next slide, please"
  },
  {
    "startTime": "00:40:00",
    "text": "uh yeah so quick epoch checking This kind of makes sense but the adversary can sidestep it by having Charlie create another commit that has a higher epoch than Bob's original kind of healing commit in the scenario we discussed before If you had stepped through the next slide, please Oh, yeah, so Ellis State gets broken again. Next slide, please And then the adversary kind of blocks bob's commit to charlie and so charl in the kind of process of time Charlie does a couple of commits herself, and then Charlie reaches commit four, uploads a group info for commit and epoch four, and then the adversary process of time, Charlie does a couple of commits herself. And then Charlie reaches commit four, uploads a group info for a commit and epoch four. And then the FSA region just give that one to Alice. And in this epoch, four, there's Bob has never done an update And so kind of again, the adversary has effectively wrong back Bob's update. So this kind of an epoch checking is nice, it's low cost, but it's not a complete defense because it's not, it's just a integer and it doesn't say nothing about the cryptographic state of the group. Next slide, please Okay, so next one is transcript verification, which is a bit more yeah, sorry, Ron Sorry, maybe I'm rushing it too much with this No, he said he can wait. Rowan says he can wait Okay, okay, fair enough. Transcript verification kind of tries to bridge that gap and get into the cryptographic verification kind of side of thing where Alice, when she requests a group info, she also asked the delivery service to get all the, the passion of all the messages that led to this new state that the delivery service is kind of handing her. And so then Alice can actually check that the new state is an extension of the transcript that she last knew as the last good group state that she has had which was state two where she had already processed updates"
  },
  {
    "startTime": "00:42:00",
    "text": "extension of the transcript that she last knew as the last good group state that she has had, which was state two where she had already processed this update and thus you can you can see that the new state like she doesn't know like what the steps are in between necessarily because somehow her state broke, but at least she knows that you know this new state includes all the updates that I have processed so far. And so no one can force me to roll back um of course this uh next slide, please. This requires that the DS actually has to keep around the transcript hashes or people have to forward them to Alice somehow. So this is kind of an architectural requirement here Next slide, please And finally, public key bookkeeping, which is also a really nice solution but does require some clients site bookkeeping where whenever a client doesn't update in the group, the every client that processes the update keeps track of the old public keys or at least you know hashes of the old public keys and whenever they're client does a re-sync, it checks the public keys in the new group state against this big list, potentially big list of old public keys that has seen in the past. And if there's an old one in there that it knows has already been updated in the previously known good state then the client just rejects the group state completely. And so this kind of in terms of kind of total prevent this attack entirely is I think, at least on par with the transaction, sorry, the transfer preventing this attack entirely is i think at least on par with the transaction sorry the the the transcript hash approach so yeah um that was essentially my small take on what we can do in terms of protocol engineering but the question I was like, do we like this mitigation? Anyone have any opinions on those? And as Brendan said, like, do we want to talk about this in the architect? document and give some guidance? Do we want to have something in the errata for the RFC? Again, like, I don't know if this is how the IDF process for errata works. I've never done that"
  },
  {
    "startTime": "00:44:00",
    "text": "before and the last one that we could do in any cases have an extension that kind of solidifies this as part of how you do an R sync as sorry a re-sync not an R sync yeah sorry Ron. Hey, yeah so I'm going to reiterate the reenet for a complex user in a system that has external commits as an appropriate solution And I do like the transcript I don't think we want to put any of this in the architecture document The document has been through two words group last calls It's time Thanks So I think it'd be very relevant for the working group to address these in detail The challenge with the architecture document is that is, again, not prescriptive. And the details as a current stand in the PR, basically punt the problem Because if we say we require bookkeeping for public keys, or require consensus, or any of these sorts of approach if that's not a very detailed description of how to do it well, it's just leaving it up to the implementation where they think they may have solved the problem but they actually didn't solve the problem. And that level of detail to how to do it well, I don't think can fit neatly and within the guidelines that the architecture document needs to hold, which is non-narvel So an extension or potentially few extensions on how to solve this for application where it's a problem would be very relevant writing title, external join considered harmful external or automated external recent considered harmful"
  },
  {
    "startTime": "00:46:02",
    "text": "I think it's probably accurate to say that like the risks of taking a group info from the DS are not like deeply explained uh in rFC 94 probably accurate to say that the risks of taking a group info from the DS are not deeply explained in RFC 9420. Doesn't arise, I think, to the level of ROTA, but I think this could use more discussion. I do think it does seem like the core of the issues that in both of these presentations is this automated automatically triggered re-sync behavior on errors So I think that's probably where I would focus the architectural discussion is flagging that as a potential problematic, as the recent re-sync operation being a risky thing because you're accepting very information from the DS And especially dangerous when you're doing it automatically in response to some protocol circumstance So I think that's about the right level on which I would address this For the details, like you've discussed here, Conrad, I think those would be really great content for an implementation document, which we've discussed often on in the past you know, to cover things like how you use the DS tracking your ratchet tree to speed things up and and things like that So like going deeper into some of the mitigation strategies, I think could be really good for a much more technical document like that that an implementer could sit with and ponder which of these mitigations strategies could make sense in their application And as Britta said, lay them out in some detail that could be useful and you get hard guarantees out of Just to just kind of completely independent of what I was saying just to throw out something that another kind of use case where to highlight that this recent case isn't this external rejoin case is not the only recent case and WebEx today the way we handle invalid commits is we crash the MLS session and rejoin you with an internal join. So you emit a request to join the group, and you are added by someone else who's in the group"
  },
  {
    "startTime": "00:48:00",
    "text": "which works great in real-time case. Real-time is a weird case for this in a lot of ways But it's useful as an intuition problem to say, you know, maybe we haven't covered, maybe this is an inherent to the protocol. So that's why I think, you know, focusing on the, the automated rejoin stuff is not, inherent to the protocol because we're operating in different ways to today. And so, but so I think it's something we can safely say, like, yes, you should pay attention to this, like this is you know you should focus on this as a potentially dangerous issue Yeah, I'm not sure. So I we might want to have this implementation talk and you're right, we might want to tackle this now that we have some more experience with implementations and deployments but i'm not sure this should go in it because it kind of goes into the heart of the protocol mechanics and verifications of stuff, verification of to tackle this now that we have some more experience with implementations and deployments. But I'm not sure this should go in it because it kind of goes into the heart of the protocol mechanics and verification of stuff and when we get which security guarantees. So I'm not sure that's the right place Like if we don't want to have it in a radar that like again that's fine. I'm not sure what the process is there, but I think I'd rather having it as it as an that's the right place like if we don't want to have it in a rather that like again that's fine I'm not sure what the process is there but I think I'd rather have it at an as it as an extension sorry then have it in a kind of implementation guidance document that seems a bit, you know well, it seems like implementation guidance to me in that it's kind of talking about how you respond to the errors that the protocol emits So we have this boundary where things are fed into the protocol and you get either good results or bad results and this is about how you respond to the bad results and you may you know want to like do some nuance processing here, like you might treat failures of the members MAC differently than you treat significant failures and differently than you treat decryption failures right? Because those have pretty different consequences, pretty different semantics. So yeah, this is like deep technical stuff to really get into how you should do that, but it's all about how it kind of externally to the person So yeah, this is like deep technical stuff to really get into how you should do that. But it's all about how it kind of externally to the protocol, how you as an application react to this stuff of present"
  },
  {
    "startTime": "00:50:02",
    "text": "Hi, so I'm not sure if this is like off topic at this point in time, but Richard, you've said a couple of times now that you think the pull request should be restricted to just basically saying like external rejoin is bad, you know, be careful instead of discussing the other approaches And I'll say that I don't like that answer because it seems to presuppose that the right answer for deploying MLS is this model where the DS chooses which commit is right, and then you have some kind of system for like, figuring out, like, what to do when, you know, a commit can't be processed Yeah, it seems to kind of precipice that that's the right answer, and it's not clear to me that that's an approach that's actually workable, like in a secure way for anybody much less all applications Because we've already gone through a lot of rounds of cryptanalysis where people, you know, say or where I say like, oh, this is like insecure for some reason or it doesn't work for some reason Then people will say like, oh, well, we can fix it if we do this And then like that changes the attack a little bit, but it's still, you know, in insecure. You still have the DOS attack. So then we make it a little bit more complicated. And we kind of keep changing it and doing the protocol engineering to fix this approach up front without actually ever reassessing if this is actually the good top-level approach Thank you I think I agree with Richard that the scope of the architecture document should really be a stern warning that that stuff can potentially be dangerous if it's not really thought through, but we cannot have details in the architecture document like Britta pointed out earlier. It's not a normative document, so it really should"
  },
  {
    "startTime": "00:52:00",
    "text": "be elsewhere. I don't have a really strong opinion on whether it should be in an implementation document or in a dedicated document, but I want to note that we've been talking about that implementation document for a while and it never you know met sprung into existence. So I want to make sure that we, you know, decide on something that's actually actionable And I think we should just, you know, start writing down the mitigations here to the extent that we're confident that they actually work so that we don't end up in the situation Brandon just described where we, you know, do half-baked mitigation and then effectively we work so that we don't end up in the situation Brandon just described where we, you know, do have big mitigation and then effectively we've just changed how the attack works So we want good mitigations and it does really matter what that document is called because we can still think about that at a later point in time if we grow the scope to handling other things as well, then it might well turn into the implementation document, but we should maybe not be that ambitious right now I want to highlight that if we have the full compromise case, which is what Brendan had mentioned is one of these cases, then the solution of terror down the MLS session and restarting it that was mentioned actually doesn't solve this problem. And you're actually still vulnerable to attack. In fact, it's more ideal from the attacker's point of view because they have a copy of the key packages and whatnot So there's various possible things that can be done here, but they do need some exploration. And it's probably worth writing those out in detail and possibly analyze those in detail to show that they actually are achieving the guaranteed we want them to achieve. So I agree absolutely with Rafael and with Brendan as far as stating that this is a problem in the architecture document is probably worthwhile, but we need some sort of thoroughness"
  },
  {
    "startTime": "00:54:00",
    "text": "and rigor to the proposals that we're putting out and backing for those So some sort of extension or something beyond that's a little bit more formal than an implementation guide i think would probably be the right way to go Ron, I think you're next on the list or not so I was just going to plus one one for a I was just going to plus one what Britta said like I think the right balance here is to describe the problems here. You know, I think we've not? So I was just going to plus one what Britta said. Like, I think the right balance here is to describe the problems here. You know, I think we have arrived at a pretty coherent agreement on what the problems are things like you know avoiding the delivery of invalid commits and responding properly to invalid commits in non-risky ways And then we should absolutely, like, dive into the details in another document Okay, so we're at the point where we've drained the queue on both of these presentations and we need to figure out what to do So in the GitHub repo, it has been proposed that we do nothing, which is one thing. Then we have Brendan's proposal on the other side, which is to be more explicit And then there's a couple of places along in the middle that we've talked about This wasn't a document about This wasn't a document, does it, is doing nothing include. No, we're not. I guess the point I'm going to make is doing nothing is not on the table for real. If we just spend an hour talking about it, we got something we got to say, right? Just a clarification Is what's in the architecture document, does it include? does it include the problems or not not? What's there now? I mean, have, please have the authors Do we know what? I agree with Sean's assertion. The fact that we've had this discussion illustrates the document is not sufficiently clear on this point"
  },
  {
    "startTime": "00:56:02",
    "text": "Or do you want to know about what's in the document or what's in the PR? What's in the document? Rowan is doing his own review of the document To answer your question, what's in the document currently? doesn't discuss any of these problems at all, which I think that we all agree is a problem because it's negatively affecting you know, real-world use of MLI What the pull request does is it does discuss this problem, but it also discusses the other optional alternative approaches to solving this other than just having the DS choose which commit is correct because we can have one approach which is have the DS choose which commit is correct and we can discuss the problems with that but I think it's also worth it to say that there are other options and other avenues to explore here so that people don't get stuck kind of going down this one path without ever like thinking is there another way Okay, well if anybody else has any suggestions, thoughts on this? because it sounds like we, we maybe, it seems like there's an agreement that we have to describe the problem, the amount of text that goes in the document to describe the ways to solve it is what I think we're spinning around on or where to put that text And so it seems to me like we have a couple of options. We can just put the problems in and kind of punt on what the actual solutions are or try to keep iterating on what the actual solutions are So, yeah, just get it that's where I'm going there So we're not discussing solutions that"
  },
  {
    "startTime": "00:58:02",
    "text": "all here. We're only saying these different approaches have these different problems and we're not being prescriptive about which approach people take. We're just saying these are the options. These are the problems they have actually solving the problems, I think that we all agree is you know, somewhere where a different document would come in. I do not agree that that's what the current PR does the current PR makes a number of recommendations and is very speculative. That is not consistent with what you just said. There are no recommendations in that PR. I don't understand. Like, what's text that? says that to you? Yeah to that, the current PR proposes these possible methods of, like, for example, the consensus and the bookkeeping of public keys as possible ways That's not what my PR says no It lists those as possible ways that should be considered for addressing this. Not in my PR Does your PR list these methods at all or mention them? No, it only says like this is the approach. It has the PCS and the DM risk. You need to address these in some way if you're going to use this approach Or accept to take a nap and I guess Okay, my reading of that just before this meeting, showed that those were mentioned is considerations and trade-offs in them. The public can happen, I guess. Okay. My reading of that just before this meeting showed that those were mentioned as considerations and tradeoffs in them. But maybe if your goal is just to state the problem, then maybe that is where this discussion is going anyway that we just want to make sure that the PR explicitly states to problem and not any possible solutions to it and then that gets taken and done thoroughly elsewhere Yeah, I definitely agree with that. That's what the PR should be And I think they use it like the public keep bookkeeping idea is mentioned. I don't think that that's in the PR Hello, PR number two line 845, one solution to this problem might be to require group consensus on a commit. For example, there is"
  },
  {
    "startTime": "01:00:02",
    "text": "One solution to this problem might be to require group consensus on a commit. For example, there are a number of statements like that So, you know, and that was just me, like, looking very, very quickly to find something So I think that there are a lot of statements that people would construe as recommendations Right, but that's not a recommendation. That's doing what I said, which is saying, like one solution to this would be to do X, and if you do X, you're going to have the problems To be clear, I oppose having anything that says, solution, recommendation, you know, like just problems problems all good But yeah one solution, one possible, like, problems all good but yeah one solution one one possible that like no I'm not okay with that I'd don't understand how to phrase it then because to, you know, talk about the problems that you have with a specific solution you have to describe that approach right? Like, what is the phrasing that would be better for you? So I think what Rowan is pointing to here is that you could just describe the original problem with the whole re-sync without describing solutions or problems with solutions So if we punt the question of the solutions and the problem, with those solutions to however we're going to address it as a group and only focus architecture to mention this original issue and say something should be done about this and leave it there, then my understanding of what Rowan's saying is that he would be confident and happy with that. But it sounds like a way you're saying then is that the PR should only discuss the external rejoin approach. Right, that's only one way to solve the problem of having it invalid commits Because the core problem here is how do you handle invalid? commits? The external rejoin is the solution that people have to that. And then you get more problems from that specific solution to invalid commits So there's the external rejoin as a solution"
  },
  {
    "startTime": "01:02:00",
    "text": "to some sort of invalid commit. It's not the solution to the problem that you're describing, which is all the secure implications thereof if it's done incorrectly It is a functionality option that is in the original protocol So what I think you're pointing to is that there's other ways of looking at this, of that the PCS issues and whatnot And as of us saying in this architecture that doing external rejoins, it's a solution for something to just state by using that functionality option in the protocol you have these potential insecure and you need to address them in some way in your implementation and leave it there then you haven't gone into the solutions to the problem yet Okay, so let me ask you then, if we say, if you do the external rejoin mechanic, and then you have these problems how do you phrase it without saying, you know, one solution? to the invalid comments problem is this extra? rejoin mechanic, and then that introduces these vulnerabilities? Because that's what it sounds like. That's what I believe rowing is objecting to is the phrasing of saying that external rejoins is a solution to the invalid commits problem So if you stop that sentence right after the point where you say and a solution to this is then I think you've cut it at the right place But if we say just external rejoins, then we're discussing that without the context of why that mechanism is used yes i don't think it's necessary You've got primitives in the protocol, and so saying that like, if you use this combination of primitives you're gonna to see this problem. But to be clear, this is not a problem with it external rejoins in the abstract. This is a problem with external rejoins as a way to handle invalid commits"
  },
  {
    "startTime": "01:04:00",
    "text": "No, I think you can express it as, here is a combination of actions. If you do these protocol actions you're going to see this problem. Right the protocol action is if you see an invalid commit and you do an external rejoin then you have that PCS and DOS risk It doesn't matter whether the, whether the because you saw an invalid commit. It could be somebody else who came in who was joining because they weren't PCS and DOS risk because it doesn't matter whether the whether the the reason was because you saw an invalid commit it could be somebody else who came in who who was it joining because they wanted to join the group right No. Like if you're joining a group just like fresh, because you want to join a group and like you join an old compromised group state, that's a completely different vulnerability from saying that I was in like a PCS achieved state and then the DS used this mechanic specifically with invalid commits to put me back in an insecure state. What I'm saying is that there is a combination of primitives that are used that caused a problem and document that is great. But then we're only documenting it because it's the specific approach that people have used to solve this one problem and we're not discussing other ways to solve invalid commits We're only discussing the external rejoin like, vulnerability because this is something that people are using to handle invalid commit You know, and then we're, like, not talking about the invalid commits problem, like, other ways to approach it that would not have that same issue So there's two problems here. There's the functionality issue and the security issue. The functionality issue of a corrupted commit the external rejoin gives you options to solve But what you are highlighting with this and this discussion is that there's a security issue in the real issue thereof. If you use that to solve that function problem, you now introduce a security problem for your PCS And the discussions of the solutions to that security problem are what we're saying could be punted to something else outside of the architecture. Right, but we're not discussing solutions here are not discussing solutions to the more concrete problems"
  },
  {
    "startTime": "01:06:00",
    "text": "Like we're saying, this is an approach dissolving at this approach has these problems All right, okay, so I think we have we have going to do some hums here, a show of hands tool But before we do that, who's read PR-T-61? Okay, great. That's what I figured. So we're after the discussion, I'm glad everyone's informed and it's followed along That's great. Nick, have you got the questions? We're going to make two questions. One is yes or no to adopt a APR to address this issue. And then the second one is if yes do we want to list the approach? as Brendan has in his PR or do we want to completely leave out the approaches and just list? the problems with no solutions? Do you have any? adjustments to this, Brendan? Yeah, you can say one more thing on the issue before we do this Okay, so just to, I guess, to repeat myself from Sylvia earlier to discuss this one specific extra rejoin mechanic and to say, you know, this has these problems, you need to solve it in some way And to not discuss the other ways to solve the invalid commit problem in my mind, what that is doing is presupposing that the right answer to deploying MLS is having the delivery service choose which commit is correct for each epoch. And that's not a all clear to me that that is the right answer, like my implementations have never done that And it's not clear to me that that's like actually a workable answer, like something that will actually end up being secure and functional in the end if we do this protocol engineering. Because like I said, we've already gone through"
  },
  {
    "startTime": "01:08:00",
    "text": "a lot of rounds of cryptanalysis of people proposing. We can do this to make it work, we can do this to make it work. And a lot of those ideas have kind of fallen through So we should do the protocol engineering, but it's not correct to presume that this is the right approach to only discuss Just real quick, chairs, you feel free to ask your questions, but I feel like Roe and Britta, Brendan, and I are pretty close on at least in understanding what the issues are here and so we have a coffee break after this and it's like let's sit down and hash this out. That's my hope Okay, we're going to ask the questions to get a sense of this from folks who have read the PR and have heard these presentations starting with the first one Okay, so we have more than half the participants have answered and it's all yes or no opinion Now a reminder for this if adopted is likely going to be a yes So this is a yes or no question, yes for listing the approaches and no for including only the problem problem Yes for yes for yes for including the lines that Brendan had in the PR that lists potential solutions and approach to dealing with the problem"
  },
  {
    "startTime": "01:10:00",
    "text": "no for list only the problem and none of the potential solutions that people would take Sorry, it's not coming up reload, I'm not able to second Thank you We've had a couple votes. Is it not coming up on folks as media echoes? across? Okay, I'll do one more try Thank you It is working on Well, I see it Okay, we're going to have to move on for now. I think there's technical issues"
  },
  {
    "startTime": "01:12:00",
    "text": "with the show of hands. All right so we'll come back to that. Just be clear on the previous point. Anyone else who wanted to join in this little discussion on the coffee group? feel free to join just find us. Because I mean what would be ideal is that you guys, since you're all here, um figure this out give us some text we can get it done and then we can get the document out the door like this week so we really appreciate that thanks all right so now we're going to move on and we're going to have Rowan talk about some extensions Oh, no, sorry, I'm wrong. This is, uh, first is going to be Raphael Sorry Sorry I assume he's there Thank you for a moment three bucks I mean it's one slide so All right, problems some problems. All right, let's go on Since you're here, we're on, let's, I'm sorry, switch back to you Which one is yours? Appsync? It's actually with them hi. Okay, so first of all, hi apologies to Conrad and Raphael, if I repeat something about safe AAD in here Okay, next slide, please Okay, so these are all the drafts that I have worked on that are in MLS So the first thing I was going to mention is a couple of issues on the safe extensions framework Then I've got two extensions that"
  },
  {
    "startTime": "01:14:00",
    "text": "I specifically wanted to talk about that are related to Mimi One is App Sync, which Richard presented in Australia. And this second one is a new one, semi-private message. Next slide, please Okay, next slide. So safe extensions is in section two of the draft IETFMLS extensions draft So I think Conrad and Raphael agreed that it would be nice if we have a way to send additional authentic data from multiple extensions that doesn't that where these extensions don't clobber over each other so basically some kind of probably some kind of mixing mechanism. And we need to acknowledge that there may be some non-safe extensions that or yeah not safe extensions that uh that this necessarily make them unsafe but that also may send AAD, and so how do we do that? so I have a PR that proposes some stuff it probably needs a little bit of extra stuff. Please have a look at it if you're interested in this topic. Next slide The other thing is that in general, Richard and I were preparing the new App Sync and in the extension and the two of us came to opposite conclusions about what the what the appropriate place was where a proposal credit came to opposite conclusions about what the appropriate place was where a proposal, credential, or wire format extension ends up being advertised for capabilities and in the group context. So I create an issue. It's like a one-liner. It's issue number 30. We need to figure that out I think one of the problems is that there's sort of an overload of the term extension, which is used for any safe extension for the ID that you get from Rihanna for that"
  },
  {
    "startTime": "01:16:00",
    "text": "And then there's another usage of the term extension, which means basically only the extension that you can stick in leaf nodes, key packages, group context, and group infos. So we might need to just morph those definitions a tiny bit Okay. Next. Okay, so the App Sync proposal, the x signal for a new proposal type called AppSync which is a safe extension Okay, these are basically the slides from before. There's only going to be a couple of changes How many people here are familiar? with AppSync? Okay, not very many people. So I will go over these slides. So first of all, we have go back please. So first of all, we have this one wonderful thing in MLS called Group Agreement and it's a very powerful tool. So this allows us to use MLS to confirm that the group agrees on the state of the group. If you have application state, it would be very nice. If we can also have that agreement cover the application state because applications frequently want that So let's import the application state into the state of the group Next slide, please Okay, so we came up with this one of the uses one of the applications that would use this is in Mimi that we would have a participant list basically the roster, which is included in the MLS Key Schedule. And then there was also this idea of sort of generic room policy like things that admins have a, you know, the role admin has these attributes or capabilities and, you know, recording is not allowed in this group but external commits are allowed those kinds of things there are several of these things which"
  },
  {
    "startTime": "01:18:00",
    "text": "are operational settings which are in, I believe, Section 7 of the architecture document. This was also discussed that this would be nice to have agreement about what these settings are so everybody could configure their MLS clients appropriately So an App Sync proposal is used to update a particular piece of application state, and that particular application state has an application ID. Next slide, please I'm going to skip this The important except for that is for each for each application, there is an application ID and there is some state and the next slide we will talk about what you can do to modify that state. Next slide, please So with the draft as it exists there is a concept of a couple of different types of common representations of state. So either an original it exists, there is a concept of a couple of different types of common representations of state. So either an irreducible blob that you just set completely or, you know, you report in a single atomic operation all as a whole piece there are arrays which are ordered and there are unordered lists and there are maps now there was some pushback about this that this is really not MLS's business And so I made a P PR number one which basically says, okay, this state, will be completely opaque to MLS, and it only has the ability to replace the existing state within for this particular application ID with a new state. Now, we know that for something like a roster if i have a roster in a group with a thousand people and I need to add"
  },
  {
    "startTime": "01:20:00",
    "text": "jon peterson sending the entire roster, this is in effect So there's also the idea that you could have an application-specific patch operation as well so these are the choices We would like more people in the MLS working group to take a look at this extension and see if regardless of what choice we make along the spectrum of, you know, the two approaches and the second approach with with patching is this something that seems reasonable? for us to do? Raphael Yeah, sorry It seems like I had a technical issue earlier And had I presented I would have said the photo. So it seems we have some overlap between different proposals here. One is absync then there is one that is already in the MLS extension stock about extension state. And then there is a third one proposed by francisco arias but not yet discussed that proposes updates to group countries extensions so they each solve up slightly different problem or different aspect of the same problem And I think we should actually sit down and see what we want to do with all of that All right any other comment? Okay next slide I wrote a draft called semi-private message message What is this? So"
  },
  {
    "startTime": "01:22:02",
    "text": "So, we had, based on discussion in Mimi about medity of privacy we had a discussion about how there are a number of applications where a DS would like to be able to see the contents of a handshake message But in the Mimi context, that would mean that sending a public message would get forwarded through a number of providers not only the hub, which is the one that is responsible primarily for the DS function So we already have a concept of external senders that we can use to send external proposals in MLS So we could have a concept of external receivers for a message called semi-private message. And so you could use this to share handshake messages with the list of external receivers who are in the group context known to the group This would be an explicit share, so it would be providing less information to less information to everyone else in the world because it would look like a private message I mean, it would be this it would be a new wire format semi-private message but in terms of the information that you would be able to glean from the outside world, it would look like a private message. You wouldn't be able to tell the same of the message, and you would just be able to know the group ID and the epic There's also a PR, PR number seven the Mimi Protocol which basically"
  },
  {
    "startTime": "01:24:02",
    "text": "describes how to do this in a sort of roll your own way And so it takes the well, I'll go to the next slide describe exactly how it works So basically you have two keys and two nonses So you have a non-s. So you have a non-s pair to encrypt the sender data When you decrypt that, you find out who the sender is and the reuse nons. Sorry, the reuse gar Then you also have a key and knots for the ciphertext, and that's Xorg with the reuse guard. And using those four pieces of information, you can decrypt the contents of the private message So this this combination of per message keys and nonces this is increased to individually encrypted to each of the external receipt and it's placed in an in vector called keys for external receivers And so the rest of the message looks basically the same as a private message So here we have some semi-private message. The only difference here is that we have an additional And then we also have in the some of the instead of private content aAD we have semi-private content a AAD and that includes additional authenticated data of the key for external receiver So that's the idea We'd love to have some feedback on this Thank you. Feel free to go to the next slide. Rafael"
  },
  {
    "startTime": "01:26:02",
    "text": "Rafael Sorry, me again. So I think you presented that already in the Mimi group before we had some discussion, so maybe it's worthwhile Just repeating that here And that is that I think the proposal is now right in terms of scope It's a way of selectively giving access to the content of a private message to parties that are at least known to everybody in the group So that's a good thing when it comes to implementing it it's going to be not so nice because it goes through all of the nice layering we try and have, but that's an implementation detail at this point It's unfortunate that it does not cover the group ID. That's a very sensitive bit of information So if in the broader scope the idea is to hide messages from photo was servers for example essentially anyone who is not the hub then you might also want to hide that. This is not achieved here I don't have a solution for that, but I want to note that we don't have complete protection of that. We're just as good as private messages in that sense So specifically when you take these private messages, you don't hold the keys to decrypt them and you put them in client cues, for example, you can still absolutely correlate who's talking to whom, even if you don't see the content of the proposals in the commits So you can still infer a lot of stuff that is not protected. Okay"
  },
  {
    "startTime": "01:28:00",
    "text": "I just want to mention that one of the benefits of doing this over, for example, the role your own approach that was in the Mimi PR is that leaking the keys explicitly for a specific message is a little bit more of an issue for MLS Seems like the kind of thing that you want to avoid the MLS stack being able to do gratuitously whereas if it's baked into an MLS method format, it's a little bit safer. And so we would acknowledge we would still want to encrypt the group info and the ratchet tree when sending it to the hub but we're not trying to do that using key material that is exfiltrated from the MLS key schedule So first of all, I think that there's a good improvement When we first were working on MLS, we of course were saying that there's a single server and life's good But with Mimi, we're looking at various other servers involved, and it's on the distributed case when we have even more, it may be very flexible. So the fact of being able to ask for let's say, updates be handled by a particular DS and even as a form of a revocation where you could set the updates are commits to one and then control messages to another later on it gives us a lot more flexibility. That said, I also echo what Rafael mentioned as far as hiding the identities. It would be nice if there's some sort of recommendation with this about encrypting that as well since it's kind of heading in that direction of how do we protect these control messages a little bit more And the other point, which I do not have well formulated right now or thought out is about the nonce and nonce reuse particularly as this is a key"
  },
  {
    "startTime": "01:30:00",
    "text": "for the DS and things are being encrypted to there from multiple different receivers And it's something that might want to be considered or flushed out or just I'd like to hear what you've looked at regarding that. Okay yeah specifically the the, those four, the, the, the two pairs of key, of nonsense and keys are individually encrypted for each external receiver using HPKE, so they have their own, they have their own label so I and the label is dependent on, if I recall correctly, it's dependent on the on the on the epic and Group ID So if you fork, then yeah, you could end up in a situation where maybe you have a two-time pad, but I think it's pretty safe from the sort of obvious stuff Okay Conrad. Yeah, I just want to second, Prida, and Rafael. I think this would be very useful to have in the toolbox for Mimi, of course, but also maybe generally in any sort of federated or relayed setting where you'd want to use MLS, but still keep the metadata leakage to one party that you've done, or to some parties that you've done cam the keys to. And of course we can look at the cryptographic design and then make sure it's tight, but yeah, I think this should go Okay. All right, next slide. Other stuff stuff Whoops. Can you go to the last slide? please? No okay. Can you go to the second slide? please? Just two go to the second slide please just just two to enter might do it Oh, you want to go to the second slide? The second slide, yeah"
  },
  {
    "startTime": "01:32:00",
    "text": "there. Summary. That was good Summary, wherever that one. There we go. OK, great Okay, so I covered those three things um That was good. Summary. There we go. Okay, great. Okay, so I covered those three things. So I had a draft related to a MLS member proof that was bad idea. I'm abandoning that There is something related to key package context. So this is something which again, this has app key package context so this is something which again this is this has application state so this might be something that becomes the kind of thing that is in a general application state extension Everything that we need, that I think we need and Mimi for key package related stuff, I think you can do with this extension. But it's just sort of sitting on the back burner while we discuss other sort of more structural issues We also do need a way in order to be able to convey the generic room policy and that again that's kind of let's kind of tabled waiting on the overall discussion of, you know, absent versus versus one or two other options or some combination some new combination All right. And then not related to Mimi, the self-remove proposal that is built into, that is currently in MLS extensions, there's no change there. I previously raised another an issue that we may want to have external commits an extension that allows external commit to incorporate proposals that were previously sent pending proposals I have received no feedback positive, or negative on this idea, so I would welcome you know, anybody who wants to come talk to me privately about that, please do Finally, we have"
  },
  {
    "startTime": "01:34:00",
    "text": "this ratchet tree options draft, which I did um i just want to remind people that it exists i think this discusses some useful ways to talk about changes to ratchet trees where you don't have to upload the entire ratchet tree or the entire group info in, for example, a welcome or when doing an external commitment changes to ratchet trees where you don't have to upload the entire ratchet tree or the entire group info in, for example, a welcome or when doing an external commit. And the last one is Britt is going to talk about, which is some post-quantum stuff. I have one draft which is related to a hybrid chem cipher suite And this is this is blog pending the output of the chem compiler's design team in CFRJ they just announced a sort of a way forward last week, and one of those ways will be a concrete combiner for a concrete combination of a classical a classical chem and a post quantum chem that we will probably build a cipher suite for and there are other post-quantum approaches. And Britta's going to talk about it will probably build a cipher suite for, and there are other post-quantum approaches, and Britta's going to talk about one of those right now. Thank you very much. Well, later maybe we might have we might have run on time on that i'm sorry we might have run out time so yeah we still need to do this poll. So I think you're good now. And then we're going to hand up to Richard he's gonna get the balance of the time I'll have to speed up a little bit. But Nick dropped some text in the chat room about what our interpretation is of the discussion that we had earlier with the first part of the discussion So what it reads if you're not in the chat room, the chair's interpretation said there was an objection to the fact that the PR contained a high-level discussion of how to approach solutions to the problems raised. And the PR should only describe the problem Brennan clarified earlier that the PR does not include technical details about solutions, and that those should be left in the protocol documents"
  },
  {
    "startTime": "01:36:00",
    "text": "So what we're going to do is a show of hands. It's going to be two questions Yes or no. Yes for listing approaches and no for only including the problem I think we've solved our technical problems I can actually start this Do I'll give it a another minute All right, what we got is four for yes, eight for no and five, no opinions. But what I'm hoping is that you guys will get together and we'll figure out some tech From the coffee will come answers. Yes right, let me stop. Hopefully Of course, now I'm having a problem with me to echo So this is the section of the meeting where I talk about cool new stuff that we cannot adopt as a matter of IETF process because we are being held hostage by our area director on this architecture thing. But hey it's fun to talk about cool new ideas anyway And I'll try and be briefs to the pretty good sometime This is a different credentials draft, same content as last time You know, we need some other new types of credentials for things like verifiable credentials"
  },
  {
    "startTime": "01:38:00",
    "text": "It's not a big draft. It's been around for two IETFs and people like it and we had an adoption call and where people said they liked it. Maybe we should just chuck this in the extensions draft. So I think I forget to the authors on the extensions draft are. Maybe I should just talk to them Yeah, I mean, at this point, I don't know why we wouldn't, right? It's been sitting around long enough. So I would just ask Arfielan, if there's no objections, then like we're standing on process let's get it done Anyone have concerns about that approach? Not seeing any concern faces in the audience. All right, cool This is actually new work So we all have PCS, right? Sometimes you can't get PCS. You send an update and someone else sends a commit without your update, you gotta throw away the update You lose your chance for PCS. So instead replace Replace. So update, right, you get the update and the way you know where to apply that update in the tree is based on who sent the message This is just a proposal that says it in the proposal instead of in the envelope What that means is if I'm a committer and I get a late update that shows up after I sent my committal off, the next time I commit, I can basically re-originate that update. I can say instead of you know, it won't show up as an update, it'll show up as a report instead of, Imad saying, you know, it replaced my leaf, I'll say this is a leaf I got from himad, please replace his leaf with that with that one. And in here, the leaf notes has the same form as if it came in an update It has to have that as its leaf node source and it signs the same stuff so that you get some good authenticity to make sure that it came originally from the person that's being replaced But really syntactically, the only thing we're doing is adding that one little UN 32 there. Next slide please. So, yeah, the idea that you can re-originate these proposals. I don't know if folks have done this in their implementation but you can do this to add and remove. Like, if you get an ad proposal, it does"
  },
  {
    "startTime": "01:40:00",
    "text": "get committed. The committer can create an ad proposal with the same key package that will have the same effect Same with removes. You say, oops, I forgot this removed proposal in the next commit. Here's a removed proposal in line that has the same effect. So this is just doing the same dance with update. When I talked to Marta, about this because she's a smart person, she pointed out that you can do rollbacks with this. So if someone puts it, has enough update in an early epoch, and I can just like grab the key package from that update, even though they've committed five times and they've advanced the epoch. If I've like compromised the private state that goes with that old thing, I can use the replaced proposal to roll that user back to the old compromised epoch. Not great So the solutions sketch that's in the document is to add an epoch track the epoch as the theme of the day whether it's for your resinks or for your place right? So like let's add an epoch It's a leaf node. Leaf node extension says, I created this leaf node in epoch number N, so you can just check your not rolling back like that. And in general, I think like I was saying earlier, like the idea here is to treat this as basically make sure that the order of operations is someone sends an update and I take the leaf node from that update and feed it back in So kind of tightly coupling this mechanism with updates That's less technical slide. I think we got a little same same like what should we do with this like back in. So, kind of tightly coupling this mechanism with updates. That's the last technical slide. I think we got a little same, same like, what should we do with this? Do people think this is interesting? I think we've got a couple of applications interested in this for faster PCS and for some other use cases interested in folks on security risks and whether we do this as its own Docker extensions. Anyone have thoughts? have feedback on the mailing this as well. Profail. Yeah just a quick one. So more PCL is always nice. I think we have to be super carefully, especially after the attack prime described earlier. We, it just demonstrates"
  },
  {
    "startTime": "01:42:00",
    "text": "how, you know, brittle things can be So yeah, we need a lot of scrutiny on that Yeah, for folks who do formal modeling would love to inquire this sort of thing in some of the models All right, the opposite I'm just going to talk So, first of all, I think that there's a really nice functionality If you can keep, and if we make it required there, where that rollback is like one epoch back, then it seems like you gave a law of functionality for not a whole loss in PCS. It essentially you're talking about one epoch. If you're talking about, I'm rolling back five epochs or whatever, now we're beginning to really take a downgrade. So I think when we talk about the security here, it does need to be very clear and that just discussion. But the functionality is nice. So to be clear, the rollback I'm talking about is in the EPPC comparison is the last time that leads got updated. So if Rowan last updated in Epo 3 and issued an update in epoch 4 and then the group advanced Epoch 7, and now I'm taking that leaf from Epoch four and committing it on top of epoch seven That would be allowed, according to what's in here, because his currently visit leave from Epoch 4 and committing it on top of Epoch 7. That would be allowed according to what's in here because his currently is at 3 and I'm updating him to 4. So I'm moving his leave forward regardless of the fact that the group has advanced now because discuss like tying this leaf node epoch to the group epoch that might be interesting as well. We'll give you some tighter assurances with less re-usable but yeah definitely happy to discuss that stuff yeah it's really that how far back you're going to reach for that update yeah that's a good point to the main question I have, which is actually item of three here it seems to me like this sort of functionality is more of a core part of the protocol and it's a much bigger comment actually about all these extensions, some of these extensions are really more fundamental protocol that we probably should be required"
  },
  {
    "startTime": "01:44:00",
    "text": "for most implementations and not just an extension It seems like maybe at some point we should be starting to discuss another draft and instead of accumulating more and more extensions. But I like the functionality And by that you mean MLS 2.0 How about 1.1? Whatever No, we can have that discussion. All right I think I'm, if Britta's got an interesting stuff, I might just skip that one because we talked about this one last time and we can't really do anything with it. This one is big enough that we wouldn't just do it in the extension documents This, the idea here is that, in large groups downloading the ratchet tree and downloading full-size commits gets expensive. And so this document specifies how you can operate some clients without the ratchet tree So you get lower authentication protections same confidentiality protections, and you lose the ability there's some tradeoffs here. But you can order it operate with hard login guarantees instead of, ideally login, but sometimes linear guarantees So you get more efficiency at the cost of some functionality Like I said, it's got real trade-offs It's a fairly heavyweight mechanism ironically, heavy weight in terms of text, lighter weight in terms of client requirements We'd love to have additional collaborators on this. We've got a draft out there but I think this is something we'd have as a separate document for the working group to adopt So there's mainly just an advertisement for now. So get in touch if it's a second interesting to you. So balance my time Cool. Yeah, I think we got time for PQMOS There we go. OK well, this will be a pretty short overview because I didn't make a whole bunch of slides. It's all nice and last minute here So big question is, we're at a point of time where we should start talking about how do post-quantum with MLS We already have this X-wing comparison"
  },
  {
    "startTime": "01:46:00",
    "text": "that Rowan has proposed, which is very nice because it is one cybersweet, which is your standard or traditional depending on what terminology you want to use and your post-quantum, and per ratchet you're going to do both. Now that combines it all very neat and it's nice if you are doing that very rarely. So if you're only every so often going to do an update, your whole update is going to be both. You do take in the overhead of both. But for some applications, if you can take on that computation, not too bad or if you're willing to take your PCS window and make it longer. Downsides. Oh, we went to the next slide, so downsides of that are, of course, these overhead. And for a law of lightweight, uses or uses where you don't, especially when you get to look at authenticity of post-quantum, and you don't want to take on all that signature size, it begins to have an effect So what we're proposing for doing about that, and there's another job that's coming. We welcome people to be thinking about it and recommendations Talked about this at the last IETF, there really shouldn't be any surprise here. And following that, had a bunch of discussion with different people about trade-offs and what you do in different implementation And the short version is, how can we get the post quantum to be still strong, but by keeping a very narrow ratchet on your traditional so you could all your typical PCS effects, but you have post-quantum key material in that key schedule, and you can control how often you update that Big picture how this works is essentially you have two sessions. You have your post-quantum session and your standard session and we're going to use an exporter key. So you take your post-quantum session and you use an exporter key from that as a PSK into your standard ratchet So what this is giving you is you know that that king material, has all your post quantum guarantees You're going to inject that into your traditional key exchange"
  },
  {
    "startTime": "01:48:00",
    "text": "ratchet. And so occasionally you can do what we would call a full update, which is essentially much like the X-ween draft. You have your standard and post-quantum at the same time In between those full updates, you can do partial updates, which are just your standard ratchets, how often you want to set that continuity. So then it has a very fine grain control about when you want to take on the cost of the post-quantum side and being able to have very tight ratches on the standard side So there's some DS, of course, sides that have to be figured out as far as you need some correlation between making sure that you have two groups, your post-quant group and your standard group, and they know which ones to inject But as far as what changes are needed, there's really not much changes at all to the protocol because you are just taking everything we already have as far as exporter keys and everything we already have as PSK and you're matching the two hours between your standard and post quantum so in many ways we have all the functionality we're just doing it in a very clever way so that's the angle goal as far as some of the pros and cons here. I don't think we have really have time to go into any more of it. But if you are interested in one, just to discuss more what would be for your particular use case, come talk to you And that draft will be coming out pretty soon soon all right well we still technically have 10 minutes so um feel free to jump to the microphone if you do want to add anything Otherwise, I'm just going to do a go back to Raphael's slides, which we skate But go ahead, Raphael Oh, cool So let's see if I can actually see the slides. Yay! TORX. Fantastic So just one slide, really. Sorry that's his appointment. So yeah, I just wanted to give a really brief overview of what's been happening with the MS extensions document. We had some previous discussions on one piece that has been merged about the extension state"
  },
  {
    "startTime": "01:50:00",
    "text": "So as a brief reminder, it's not an extension per se, but it's another part of the set extensions framework. And so it's it's guidance on how you can distinguish between state that can either be read or not by other extensions. So it's a measure to separate that As I said earlier, there might be some overlap here with Absin And also that brings us to the next point here. And that is the group context extension update proposal it's a bit of a mouthful The idea there is that current the way the spec is written if you want to up update a group extension you have to essentially replace all of the content, whereas it might be much more efficient to only replace parts of it Unfortunately, the author, who I believe is from francisco arias not proposed any discussion on the mail list, I think, or in any meeting so we still need to wait for that But to me at least it's sounds like a sensible idea And then lastly Ron already mentioned that it would be nice to have a safe use of the additional authenticated data that currently has no structure whatsoever and proposed some to have a safe use of the additional authenticated data that currently has no structure whatsoever and propose something that is rather straightforward by segmenting that with the appropriate extension ID It just needs a little more of discussion because it's not entirely clear since no structuring it is also valid How are we going to deal with that specific bits? And we cut a draft after the last IETF, so once the"
  },
  {
    "startTime": "01:52:00",
    "text": "issues are going to be resolved, we can cut a new one And that's it So Rafael, I just want to make sure you heard that Richard going to approach you about the additional credential stuff, right? I hope I missed that part Okay, yeah. Yeah. We'll make a PR to submit it. Basically, a draft been floating around long enough. We might as well just stick it in extensions the big extensions document and just get all of it. Run Hey, um, what section is the extension state? show up? Is it in safe extensions or is it It should be be Okay. I can go dig for the PR, but I didn't see it in the editor's copy. It's in the yeah, it's in the merged PRs Okay. Thank you Okay So thank you. This brings our meeting to a close. Thank you for the lively discussions. Like the four or five of you that want to figure out how to fix that PR 261. Let's get to it. That'd be great I also want to thank Nick, who is back filling for me because I forgot to ask for a note taker, so he took notes for us. So thank you very much, Nick Everybody, have a good day I got... No, okay. Stop"
  }
]
