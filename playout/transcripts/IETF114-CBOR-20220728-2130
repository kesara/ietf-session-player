[
  {
    "startTime": "00:00:07",
    "text": "you have to do something before the time okay it has just gone 1730 in philadelphia 2130 i believe in utc so it's time for us to start this is the seabor working group meeting at ietf 114 welcome everybody and thank you all for coming i had thought christian was going to be on remotely but i do not see him uh i wonder if he got the time right but in any case um it should all go well uh so note the note well well um you probably all know it by now many many times but this is uh your obligations with respect to internet intellectual property disclosure and compliance with the various bcps if you don't know it learn it ah here's christian hi my co-chair is here so everybody in the room is wearing a mask thank you each of you is wearing a mask i should say you're not all sharing the same one um thank you for doing that and um i'm going to keep my mask on even though the rules say i can take mine off but if you if uh if anybody in the room is coming up to this mic which i don't think anyone is but if you are you're welcome to take it off otherwise please use the the magic code here and get on meet echo light if you are in the room uh please add yourself to the queue through that tool if you can't scan this you may get it from the the meeting agenda"
  },
  {
    "startTime": "00:02:02",
    "text": "so what we have for the agenda i get three minutes it says and i have one left uh we're going to go through status on the working group documents we're going to talk about some upcoming work cddl tag registry development and maintenance and yes so that's that's it for the agenda any agenda bashing to do we all happy with the agenda thank you christian i see your nice space now yes as i said doesn't chat sorry for my delay um but i'm here now and yeah jumping in whatever he did right and um as you you weren't on when i said this to the room but the speakers in the room are facing everybody else not me so it's hard for me to understand what the people who are remote are saying so if i don't if i look stupid that's why all right um document status we have rfc 9164 cbor tags for ipv4 and ipv6 addresses and prefixes that's been published thanks to the authors and the reviewers of that document yay 9165. additional control operators for cddl also published recently well not that recently anymore so again thanks to the authors and reviewers file magic is in the rfc editor queue it finished iesg processing and um that's that's always excellent uh karsten you have an update for time tags so you're on"
  },
  {
    "startTime": "00:04:03",
    "text": "yeah i actually have some slides in the big slide set that i made so maybe we can do it at the okay we'll just we'll defer that to when we hit your slides okay uh okay and that's what we're about to do so go ahead and request slide access [Music] okay yeah it's always a bit confusing to use this interface don't know what makes it so confusing anyway um so i want to talk about time tag which we just mentioned um i want to talk about packed and i have one slide on 92 54 which is not a sibo um working group result but it has zebra in the name and it's maybe something that we should keep in mind in in future uh work and then at the end i would like to talk about the city evolution and maybe a little bit more about what the 9165 means and then the 2.0 roadmap which obviously needs new dates from those that we discussed in atf-112 okay so the time tag document defines a tag for times uh we already have two tags for times"
  },
  {
    "startTime": "00:06:00",
    "text": "zero and one um but these only have limited uh possibilities for attaching additional information and tag 1000 one has been registered to carry lots of additional information and that has been around for a while and it also has been registered for a while already because at the time 1001 it was actually a first come first served space so it was easy to register and we just did it and it's also in use in implementation so it's not something we can we really should be changing a lot uh in in the way of breaking it but we still can extend it and when we discussed this about a year ago um when we did the wreck group adoption uh we said uh this there's this new stuff going on the sedate working group and we wanted to wait for their uh considerations to become available so they are taking the text form of internet time stamps rfc 539 and adding hints to them so the the white stuff is the existing 3-3-9 timestamp format that we all know and love with the date the t and the time and then a numerical offset if desired this is of course inspired by iso 8601 and what sedate does is providing a way to add hints to that these are these uh bracket bracketed uh things that are added as suffixes to a 539 um date string and that includes time zone hints so you can say that the those minus 08 there actually are america los"
  },
  {
    "startTime": "00:08:02",
    "text": "angeles so if some politician gets the idea that the um summertime daylight savings time needs to be extended to december you can react to that because you know no this is an american time and not a canadian time or whatever and the other thing in the brackets uca equals hebrew is a more general extension mechanism in this case uca means um a unicode calendar the unicode project collects certain localization information certain types of that and they have calendar formats so this would be a an indication that the the date is expressed in gregorian time because that's what rc 539 does but maybe it's best shown to the user as a hebrew as a date in the hebrew calendar so this is the work that sedate has been working on and it seems to me that sedate is now converging i think the the last big problem was solved in the meeting on monday so we might add this information to to the time tag uh definition and since the time tag is designed to be infinitely extensible uh this was really easy so we just defined two new keys minus 10 and minus 11 and actually another copy of them plus 10 and plus 11 for critical information and there you can put your timezone hint and your extension suffix so i quickly wrote this up when when the sedate meeting was done and submitted this as time tag"
  },
  {
    "startTime": "00:10:01",
    "text": "one so that that's a pretty straightforward obvious thing to do and the only reason why we uh could decide not wanting to do that is that this might be overloading the time tag in in some way but since this is maybe not trying to be the kitchen sink but but pretty except uh accepted how do you say that um pretty responsive to to people trying to add information to timestamps that should be okay i think however sedate also has certain limits in which it operates because of the way it is uh chartered and this it is chartered really not to leave uh what uh 339 can do so for instance the date is not going to have other time scales besides uh utc they have time zones but not time scales like tai or leaf smeared utc or all the stuff that is floating around out there um but the time tank take long has had that so we are not limited to that but sedate is limited to that so um one question that came up uh was floating time which means a time stamp that actually is in local time without telling you how the local time relates to utc and we already have one such tag the tag 100 the date tag that is a zoneless tag it doesn't tell you it doesn't tell you a date but not which time zone you were in when you experienced that date and since we appear to be able to do that on the day at the date level we might as well do it at the uh time level and uh"
  },
  {
    "startTime": "00:12:01",
    "text": "emil had some some uh arguments that we actually should be doing that on on the mailing list this in the last couple of days um yeah so there's also a little issue with sedate that rfc 339 added minus zero as a numerical offset and that's incompatible with iso 8601 and yeah we probably don't have to react to that issue because we don't even encode numerical offsets in uh time tag which by the way is something that maybe people want to do but i haven't found a use case for that yet so so i haven't seen a reason to put that in yeah so the question really is do we want our larger freedom to actually put something like floating times uh in and um the the way we could do this is a little bit um well it could be inspired by ntp version five the ntp version five people also want to put in floating times and they can just use the or they plan to use the time scale field for uh saying that so they would have utc and tai uh and leap smeared utc and local time we could just do the same thing um so that that would be something where we wouldn't have to to invent something new but could just import this from ngp it's only one new value for the time scale attribute but of course it has some some pretty interesting ways in in which the semantics of time tagged data changes so um"
  },
  {
    "startTime": "00:14:01",
    "text": "this this is the situation and uh um i would propose that uh we with respect to see date we try to go for synchronized publication with them so whenever uh their working plus call finishes hours uh should be finished uh two i mean we don't have to do this precisely but that should be the general target date uh but on the other hand we should also be watching what ntp v5 really does in terms of adding floating time and uh maybe even adding their their leap smearing time scale as well but we probably don't want to wait for their completion uh to uh actually publish this this document i mean there will be many things happening in ntp v5 obviously but we don't have to copy all of them so that would be what i would consider the obvious plan um the other plan of course could be to to say well yeah there are some use cases for floating time but these are not use cases for tag 1001 and it should be done in in a separate attack uh so that would be an alternative plan i haven't heard arguments for that yet but if people feel that way then then we probably want to consider those arguments so that's what i have to say about a time tag so if people have an opinion on that now that would be good to hear or on the mailing list ira wanted to reiterate what i said on the mailing list earlier in your response to your question ntb v5 the protocols back there isn't"
  },
  {
    "startTime": "00:16:02",
    "text": "even a unified spec to be called for adoption the requirements and use cases have only just been adopted after a long period so i consider that npp v5 as an rfc or even as a late stage stable internet draft is a year and a half away on that order so um you certainly you can watch it but um i don't think you want to wait that long to adopt time good so i think what you're saying is in sync with what i'm proposing on this slide very much so and a separate tag is a fine collusion at some time in the future um i don't you know we don't need to add it because there are ntbp five use cases or other use cases unless somebody comes forward and says we really need it in the general case good ok nobody else picks up questions any other other comments right hi christian head off um so just for clarification um even if we if we went with this document as it is now there is nothing that would stop the later addition of the floating time through additional keys at the same time right no yes yes you're right there's nothing that would stop us from doing that but we could do it now so um maybe it's just easier to do it now"
  },
  {
    "startTime": "00:18:00",
    "text": "okay i think we can take that one to the list the next one is uh sibo pact and that i think has taken a a pretty surprising turn we have actually managed to make this quite a bit simpler than i thought it would turn out to be um so we now have this function tag uh concept so we actually have even have an extension point in the packed uh mechanism uh we have ongoing implementation work we probably want to have at least one implementation that actually implements the current uh draft um before we uh go forward i think we will have to do a second working glass call but that's for the chairs to decide and i think that's correct um so the the one thing that that came up in in discussions of other uh tag activities is that we are doing a little bit of a sled of hand here um by just saying all those uh tags that we defined in pact can be used in place of the data they stand for and what we probably have to to remember is that 8949 defines tag validity in such a way that a tag can define the shape the the structure of a valid tag content so i can can say this tag is only valid if the tag content is an array or is this or that so we have a top-down control every tag can talk about their their content and that that information is even"
  },
  {
    "startTime": "00:20:00",
    "text": "recorded in the tag registry but a tag cannot really control validity upwards so a tag is a tag and um if an outer tag has been defined at a time when this inner attack maybe wasn't defined yet there's essentially no way for the outer tank to to make use of of the fact that this inner tag maybe fits extremely well in in the outer tank because the the inner tag cannot make this kind of information available but that is a problem because tags often are the role of attack often is to define data that that actually stand in uh for other data and we currently have no way to record uh this uh intention and we actually had this problem already in 87 46 in the tank the race but we kind of glossed over it 87 46 is a collection of some 25 tags some of which create data structures that really are arrays and some of which operate on data structures that really arrays and so we define the term typed array and use that term everywhere in this spec where an array is needed but if we now came in and defined another tank 26 tag that has the same properties as a typed array we cannot do this because 8746 uh just enumerates those 25 tags and that is a complete list of what can be the tag content for for such a tag and"
  },
  {
    "startTime": "00:22:01",
    "text": "the same problem of course happens with sibo package now a reference tag stands in for the reference data but a tag that has a reference tag as tag content or has a data structure um that it wants to control that has a reference tag in a position that it wants to control that tag has no way to make way for using this reference tag there so an implementation that has a tag validator that operates before unpacking will break we'll find a reference tag in a place where i didn't expect the reference tag and we'll mark this as invalid brenden i think that there's a logical flaw here um your tag validator must have already validated the outer seaboard packed tag for it to ever encounter a reference tag and if it's done that and it's recognized that tag and it's been able to validate that tag then it knows full well that it's going to encounter references inside it yes so there is no flaw well you you you you say it knows that it has encountered a reference tag it may not know what the reference tag is no no it's encountered the outer seaboard-packed tag the one that defines the romp array yes it must have encountered that or it can't have encountered a reference tag not necessarily how do you end up with a reference tag that's not inside a rump or an array of references um the reference tag might be referencing to a table that has been set up as part of the content format for example"
  },
  {
    "startTime": "00:24:00",
    "text": "but then there's an implicit tag you you still you're still operating within the confines of a dictionary you know it's there and it's absolutely mandatory that you know it's there so if your tag validator is dumb enough to go and encounter a seabor packed tag and then give up when it encounters a reference well then you just have a terrible tag validator yes but one that actually is allowed by 89.49 um so this this is really about the legacy generic decoders and a generic decoder usually has some tag processing in it so for instance my implementation if we find the tag 2 or tag 3 will actually generate a number because in my implementation there is no limit to the size of a number and what's going on with the audio here and um that means when it finds a tag too on top of something that for instance is a data compressor uh tag which we haven't talked about but that's actually what motivated the sole discussion it will not be able to build a number of out of the uncompressed data it will just fail in in this place because the tank validity checking for tag 2 really is hard coded in in the generic decoder so what what this concept that these slides are about is actually doing is describing how this uh implementation of tag validity"
  },
  {
    "startTime": "00:26:01",
    "text": "is uh actually deficient and we create a new category of decoders that actually can deal with this situation the old decoders of course stay valid cbo decoders they just won't be able to really work in a packed environment or environment where we have new checked arrays or data compression tags and so on and so on yeah but when you're right that there are some very specific assumptions here about how you actually reach this situation where things break and one such assumption is that a table setup tag is not supported by the validity checker of legacy decoder so it will just present that setup tag as is uh to the application but then it continues validation within that yeah yeah yeah so so that that's the flaw right you've parsed into a tag that defines the structure of its data in a very particular way and you've just blithely ignored it and continued on validating tags anyway yeah okay fair enough that sounds like a bad decision but i guess that's what we've got yeah zebra is really designed to make that possible so the idea was to to share the duties of tag validation or tag processing between generic decoders and applications so when a generic decoder finds something it doesn't understand it just sends it to the application"
  },
  {
    "startTime": "00:28:00",
    "text": "and if it finds something that it thinks it does understand uh it actually may blow up in in a place where it shouldn't lower yeah no i i appreciate that uh okay thanks but that's a very good observation that we probably need to make this a little bit more explicit anyway so um what the the new draft uh of packs that that i did right before the before the itf well uh too late in any case um does is define a concept of tag equivalence where a tag not only controls what what is inside it but also can say uh what it actually looks like from the point of the tag validity of an enclosing tag so a typed array tag for instance could really say um hey i'm an array and everything that that actually takes an array is supposed to take a typed array um as well so of course that doesn't work when typed arrays are not implemented but as soon as they are implemented they can go into places that take a raise so for instance the data compression tag can stand in for a byte string and you type the rate i can stand in for a zero array what a tag can not do is stand in for something else that is not the same domain so for instance we have the the tag 4 which gives you a floating point number mantissa and exponent and we have 264 which also gives you a floating point number but with an extended range of the exponent and that's never something that that you"
  },
  {
    "startTime": "00:30:00",
    "text": "could handle with tag equivalence because if the the tag generates structure that would be surprising for the environment uh it cannot just say uh i will only ever give data to you that you know uh how to handle so that that's a limitation of this concept and if we want to make tags generic between 4 and 264 we probably have to invent something else anyway this is written up and i believe this is pretty much a mandatory component of standardizing sibo pact christian has pointed out that this probably needs some caveats because people shouldn't use this mechanism to build overly elaborate uh type systems that do weird things with the data going on um in there uh so that there is a little bit of text that provides caveats maybe we want to add some more uh caveats and now the question is how how do we uh handle this we could just standardize as part of the sibo specification this is the smallest number of documents the smallest um editorial effort uh but yeah i just ran to through a very interesting case where people had really big problems with defining a data structure together together with a new tag in one document so the problem details the document over in in uh core that raised some eyebrows because it defines the tag and yeah so maybe there are arguments to put it into separate documents but my plan would be to not to anticipate them but just to wait"
  },
  {
    "startTime": "00:32:01",
    "text": "whether they actually come and do this in in the zebra pack specification and then the question of course is uh does this get an updates tag does it do an update to 89.49 which of course is interesting proposed standard specification updating an internet standard specification i have no idea how that works or whether that's a problem at all um or we could simply not say that it updates it which would be a little bit of a lie but maybe a little bit of a white lie so i don't have a strong opinion um on that uh yeah again we could put it into a separate uh document and then we have a little bit of an open [Music] issue here with the question how do you actually express tag your equivalence in cddl because cda doesn't currently allow you to do that it has exactly the same structural approach that sibo uh had in 1749 and then we get that we kept for 89.49 so we will have to invent something to be able to express these things as well but i'm not proposing to to wait uh with zebra pact until we have uh invented that new cddl but this should be a separate effort i think any comments on this plan i don't know i don't know that it's a comment but"
  },
  {
    "startTime": "00:34:00",
    "text": "it's a question for barry or someone with deep experience of process i don't i thought a proposed standard could not update a full standard is that not true well i haven't investigated that so let's find out so i didn't quite get ira's question [Music] if i have a full standard an internet standard 8949 and i have seabor pact and i published it in a later rfc and i say it updates 89.49 in a way that's um rather that's maybe stretching a point in any case is a proposed standard allowed to update an internet standard right yes absolutely um what effect that has depends on what the update is but i will give you a more extreme situation rfc 5321 is the current smtp standard it's at draft standard level and it obsoleted rfc 821 which was full standard so you know all that kind of stuff happens um in the case of an updates i would say that the the new feature that the updated creates is at the proposed standard level and the rest of the protocol remains at the full standard level but yeah it's fine if that's the right thing to do then that's what we do the reason for my question was"
  },
  {
    "startTime": "00:36:00",
    "text": "i agreed with carsten i don't like saying don't update that is don't admit the fact that it alters 89.49 yeah oh absolutely if if it turns out that we made a mistake in an in an internet standard level document we need to correct the mistake and um put that back through the standards track starting at proposed absolutely thank you okay if we are done with this item i would quickly like to go to the next one which is rfc 9254 which is a standard defined by the core working group what the calling group does is provide a form of concise web access to constraint devices and when you provide some form of constrained web access you probably also want to support management so in 2013 we actually started thinking about how to integrate snmp into the the core environment and shortly after that it became clear that we really didn't want to implement snmp here but but integrate yang so we started an activity that did that and at some point we found that the best way to do this would be to encode the yang data not in xml which is the original way of encoding it or in json"
  },
  {
    "startTime": "00:38:02",
    "text": "but in sibo so that's how the the callback group uh got to do the yang zebra um document and this is of course pretty interesting because with with the the publication of young sibo uh we now have a way to provide yang defined data in cbo or you can put it the other way around we have a way to define sebor data using yang and one example for that is the the constrained voucher that that anima is defining for for brewski onboarding that is actually a young defined data structure that is now encoded in sibor and what we did when we did this we didn't try to to compress all the the xml wordiness uh so for instance ip addresses or date time they used are still text strings when you have defined that them that way at the yang level young sibo doesn't change that but it has one significant performance perk and that is all the yang names the names for the various items in the structure which are text strings in young xml and json are can be replaced by pure integers and using data coding this usually is very very efficient because typically when you use one name inside the data structure you probably use names that are close to that and the allocation mechanism that is still being defined in the draft that is still in the isg um that tries to make sure that those datas are typically relatively small"
  },
  {
    "startTime": "00:40:03",
    "text": "anyway we we have a new tool in our toolkit so when we see sibo as a useful way to to structure data to represent data that is being interchanged but maybe the the group that is doing that that is working on that is more familiar with yang or doesn't like cdl for any reason we may want to use yang and that of course opens a little bit the question um how do we uh make sure that these two uh parts of the sibo ecosystem stay on good terms with each other over time um so that that's a pretty complicated question but i think in the future when we do something on the city outside uh we probably will have one look uh at the yang side and see how how are they doing things and uh um are we doing something stupid here we're making it harder to combine city fine data with yang defined data or not and actually that has already happened the the way cgl uses regular expressions has been aligned with the way yang uses them so we already have done that a little bit but i think it's now obvious that we want to look into this some more so yang is a pretty complicated language you can do a lot in that language you can express co-occurrence constraints using xpath which is a touring equivalent language so you may not always have for"
  },
  {
    "startTime": "00:42:00",
    "text": "the right level of complexity in mind when you do gang but when you do a really complicated management information based standards then maybe yang is is a better way to do this so i just wanted to point out that this is something that will inform our cdl uh development in the future and we will try we certainly always have in mind that there is this other thing there that we want to um we want to make sure that we don't do stupid things good so this is my my little preliminary for the the cda2 discussion um so just as a reminder what the sibo working group does we have the sieber format which is stable we're not currently changing anything there but we have an extension point which is the the tag use ecosystem um so uh we have to think about good ways to to move the tag ecosystem forward which is mostly done by by the users of sieber but sometimes we generate some highly reusable shared tags and the other item on the zebra working group played as cgdl which was standardized as a 1.0 and with a strong understanding that we would want to develop this further and that's the the city a 2.0 uh discussion uh cdl defines one extension point the control operator so whenever we want to do something one question is um can we do this with a control operator and it turns out we could do much more with the control operator than we originally originally thought"
  },
  {
    "startTime": "00:44:00",
    "text": "so for instance we have uh rfc 9165 which is really cdl 1.1 because it makes some significant additions but using the existing extension points so it's not a new version of cda at all it just provides additional functionality through this extension point and that's in particular the abnf support and the dot feature support um there are also some other places where this group can do things for instance when we did sibo we defined diagnostic notation because we thought it was important to be able to put sibo on a whiteboard and uh well cddl is very is great on a whiteboard but when you have tools that need to interchange cddl uh these tools would need to to have pretty printers and parsers for cddl and maybe it's just easier to just interchange json and therefore well there is what you see on the right side of this slide is the entirety of the definition of the json grammar for cddl so if you want to interchange cddl as json this is the document you may want to look at so that's something where we might want to do work but i'm not go proposing something anything concrete at this point in time so the actual city that put 2.0 work is work where uh we need to go beyond the city syntax we have defined in 1.0 and we identified annotation and composition as to the the highest priorities let's talk about composition that that's"
  },
  {
    "startTime": "00:46:00",
    "text": "where we uh want to build a cdda specification from multiple files possibly files that come out of a library so we don't have to do all this cut and paste uh stuff that we have to do today to actually build our city uh specifications so there should be something like an uh export interface uh for from a library file into some other specification using the library and an import interface uh so that the cd8 spec can get some uh definitions from from another spec and of course we need some naming uh conventions or mechanisms uh to do this so the whole name spacing issue i gloss over that because i'm i'm already over time sorry we also had the discussion how to do alternatives so writing one specification that can actually generate different structures depending on some parameter um in rfc 4 84 28 in cinema we actually used some some lexical mechanisms where we told people combine the cdl in figure five with that in figure seven and you can do json and combine five and six and you can do a zebra we now have that feature to do this a bit on a more semantic uh level and uh maybe at some point we can extend this in some way that you actually can translate uh between the alternatives but translation is not so it's currently something that uh city uh supports at all um the the other thing that that maybe is even more important than than"
  },
  {
    "startTime": "00:48:00",
    "text": "coming up with a good syntax for this is doing automation so making libraries available from from existing uh sources like rfcs and internet drafts inregistries non-iitf sources 3gpp and so on and being able to trigger this automation from a cdl spec so one way to do this is actually to come up with a syntax that is cdl1 compatible so a cdl1 file is a cdl2 file and on the other way around a cdi2 file can be passed by a cdl1 processor and it can still do useful things it cannot use all the functionality but it can be useful things and that's something that that helps of course with an ecosystem where we now have multiple uh implementations and we all want to take them along for the ride to cdda2 so we would uh put some of the functionality of cda2 in comments or control operators or maybe rules that are otherwise unused and one way of trying to do this is to really put all of this composition functionality into something that works a bit like a preprocessor maybe not like uh cs uh cpu preprocessor maybe a little bit more keeping in mind that there is a certain structure that we want to generate but we could put all this referencing and automation and so on um into something that looks like comments and is actually interpreted by"
  },
  {
    "startTime": "00:50:00",
    "text": "the uh pre uh processor um so that that actually could be useful for abnf as well because cgl is so close to abnf whatever we would do in such a preprocessor would probably immediately immediately be applicable to abnf as well um yeah so this is a potential objective for the composition the annotation aspect really is about going beyond carnigen's car kernighan's car is a car where you only have one indicator light uh which when it's off says everything is okay and if if when it's on it says something is wrong um and that's your traditional validator that validates an instance again against the schema and tells you that's wrong or that's right and the idea is that annotation can give you back more information but right now what we have in in cdl implementations are annotators that don't get the benefit of information provided by the spec writers so the spec writers cannot say whether a particular rule is has only been created uh to to uh minimize the line length in the specification or something so these are not rules that are carrying semantic information that that an application would be interested in and we only have dot feature for carrying information beyond uh rule names and these rule names also are not related to the real world so we cannot use rdf names as as rule names and so on um so this is all related to the post schema validation instance thing i"
  },
  {
    "startTime": "00:52:00",
    "text": "showed this slide on itf 112 so i'm going to go through this very quickly but basically the idea is that if you do a validation process you get an enriched and augmented uh version of of the instance and of course what what is the data model for that enriched uh version um and can we define json and sibo diag and yemen and sieber for that so that would be an important addition to the cdl ecosystem so you can take the validator output and feed it in into some application that for instance gives you a specific interpretation of what what you just validated so the question is when do we get all this and in itf 112 i had some some pretty optimistic timelines and i think these are a little bit more realistic ones so for iatf 115 we should have a prototype of this composition engine which might be a preprocessor if we're lucky and maybe some first elements of the annotation semantics for instance just the definition of the post schema validation instance and that would allow us to to look at this in itf 115 and decide which of the functionality that has been prototyped uh do we actually want to go forward with and and which should be discarded because it's too complicated or too dangerous or uh to to uh too much of a problem for enterability and then in in 116 we could try to make"
  },
  {
    "startTime": "00:54:02",
    "text": "sure that we actually have a spec for that that is technically complete and and agrees with the implementations that exist and then we could maybe do some document splits or decide how exactly this should be published but we should have something that is reasonably stable so implementers uh can actually start uh playing uh with this and there's also a longer term objective uh which is really uh increasing the integration with iana there there's so much data in the ina registries that we uh currently have to manually extract uh to use that in in specifications uh like we had with core sid we had a multi-year discussion with ayna that finally came up with a uh mechanism that we could all agree on um we could discuss with ayanna how we actually get the web access interfaces we need well-defined um maybe even be able to tell ayanna how much additional load we are generating uh by people using cddl and maybe even define some rules for future registries so they they become automation friendly yeah i already talked about the interpretation between yang and cdl so let me go back to to this uh so this is a bit of course also a question to implementers what would what components what what toolkit elements what they like to see uh to be to best be able to participate in in this development"
  },
  {
    "startTime": "00:56:08",
    "text": "so i think brian yes hello friends speaking as somebody who's done some cdl development in uh dtn rfcs um the composition aspect is something that would be very helpful because we're starting down the road of building up libraries and as you said copying and pasting or or concatenating things runs quickly into limits of scale so could i use you as a source of little snippets that we could use to understand our use cases definitely great doing things via comments sounds really scary to me um and i wonder whether it's not a better approach or at least approach an approach we should consider um to introduce new syntax elements uh which would make the documents incompatible with uh ctdl1 but at the same time define possibly very simple rules how to remove all that new stuff and receive the receive the equivalent cdtl1 document that one would have obtained if we were if we went for with comments so that as a user i don't have to tread carefully around what possibly the new language might interpret brandon you have an opinion on that yeah so i ended up um needing an extra control operator in cddl uh specifically"
  },
  {
    "startTime": "00:58:00",
    "text": "to represent um sequences that are key value pairs but not encoded as a map encoded as an array instead and the solution i eventually settled on was to not do anything at all in the cddl leave it exactly as it is um and then use external an external document to annotate which paths into the cddl had this kind of information and and that seemed to be the simplest thing at this stage and i wonder exactly how much of this is actually something that belongs in cda cddl itself versus something that honestly belongs in uh an external annotation is any of that available for people to look at definitely it's still very much in the prototype stage and i i don't have it ready yet and ultimately the goal of that project was to produce an automated suit parser generator um that hopefully will come at some point but it's not quite there yet i think i would like to see how you actually reached into the cda file and annotated some additional functionality functionality in there that would be interesting lawrence it's closer to the microphone we are switching on the floor mic we are having trouble switching on the floor mic yeah just"
  },
  {
    "startTime": "01:00:04",
    "text": "does this mic work yep all right let's bring that one down here so this was a comment on eat's use of sibor for jason and its use of cddl for sibor and jason so i did a lot of work with uh that where i have cdl that can express uh data structures that are uh you know kind of encoded both in uh jason and sibor and i definitely ran into a lot of limitations with dot feature i don't know if anybody else has tried this but um there was at some point i just had to give up on dot feature for for it um and that was where uh you were i was embedding seaborg and jason and jason and sebor and that really that was too much for it um i also found that the cdl tool uh the diagnostic output or the error output from the cbvl tool with the the use of dot feature to distinguish json from seaborg was hard to work with yes that's my comment yeah i think the the embedding point is is really really important that hasn't been addressed yet good point what should i do just just set the mic on the table so okay and we are out of time so um let's if we need to wrap things up though let's do it quickly carsten yeah i i got some pretty good feedback um now and we probably have to um uh pursue this feedback here on the list"
  },
  {
    "startTime": "01:02:02",
    "text": "in particular i would like to know what lawrence's embedding situations were and how we maybe possibly can can address those okay so um we have that the um the other item we had christian you had a tag registry item we have our next interim call will be on the 24th of august and i guess we'll just put those last two things on the agenda for that yep let's do that okay um so everybody thank you for coming and uh thank you especially for marco for taking notes and the um those of you for uh for whom it's after midnight thank you for staying up late and we'll see you all on the 24th of august and on the mailing list thanks everyone thank you for signing a few days"
  }
]
