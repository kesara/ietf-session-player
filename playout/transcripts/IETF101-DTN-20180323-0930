[
  {
    "startTime": "00:00:04",
    "text": "oh yeah that\u0027s another something just checking your spelling I speak as well somebody was somebody\u0027s doing this I don\u0027t like it yeah yeah good morning late whatever wherever you are on the planet ITF DTN working group yeah I did this Oh actually that\u0027s not is it I think it\u0027s the right one hmm no that\u0027s right okay sorry last-minute changes this is the proposed agenda so a lot of things on the agenda main priority is obviously to close TCP CL and that in some ways should be our very first priority so we\u0027ll take "
  },
  {
    "startTime": "00:03:04",
    "text": "whatever time to finish it and then BP sac he and AD TK and butterball any agenda bashing or changes yeah just a few words about the TCB CL work I know Brian has been working very hard on this these put outs and latest updates very recently I asked Victoria to sort of callate most of the outstanding issues that were circling on the list and then some other ones she worked with herself that\u0027s really that\u0027s less of a presentation about what various people think is wrong it\u0027s an opportunity to discuss in the working group here while everyone is currently paying attention to TCP CL and DT and in general just to make sure that we have the consensus of the room and the list and meet echo so that we can really get some consensus on the behavior that\u0027s expected at the TCP CL layer hopefully get the resolutions militate and then Brian with assistance from anyone who is feeling generous we can just get this done because it\u0027s banging up the working group as we well know we got good documents that are holding waiting for that the triumvirate of BP SEC VP base and a interoperable transport for the three so that\u0027s the reason it\u0027s there and I\u0027m unfortunately if if some of the later things on the agenda get pushed out they are of a lower priority than TCP CL and are you able to take notes as usual thank you very much so this is actually the almost exact last slide as we as last time we were going to send the two documents to the IOC and so let\u0027s try to fix this and these are the milestones we have so without further ado let\u0027s start with yes do we have a Java scroll it\u0027s a can somebody watch jabber and take the questions to the mic thank you first so we\u0027ll try remote presentation again with Brian usually right in the queue and then I think you put the yeah "
  },
  {
    "startTime": "00:06:05",
    "text": "mute yeah on it Brian I will be your clicker for changing slides so tell me when good morning yeah there are very number of slides here just really a summary of the draft of the last Tuesday if you have changed this so you can move on to the next this is just that overview the presentations not really much information for what we\u0027re doing become Vaughn so I\u0027ve included this slide yet just for background anybody that is reading this fresh but it hasn\u0027t changed since the original IETF that I presented this on we\u0027re still trying to do the same thing and refine the draft to be able to do this in a consistent way so you can go to the next slide and one of the major goals is not to change behavior workflow or scope from the original TCP CL and as I\u0027ll talk about one of the last things they got missed in an earlier edit was the negotiation of the reactive fragmentation which is in the last oh seven drast been added back in in a form you can go to the next slide then so there was a number of comments that were included in the zero six version of the draft either I tried to go through all the comments from review and either address them by an actual change in the draft or respond to the comments on the mailing list email I did add a section to the frontmatter I think it\u0027s section 1.1 which is the commercial Slayer services so this should help the understanding of exactly where the line is drawn between the the CL and the bundle protocol agent I we can get to it in more detail later on but there was a comment or question from Victoria about whether this was intended on being the complete and exclusive list of what CL provides and my short answer to that for right now is yes I think it is supposed to be the exclusive and complete list of what does the CL do and so that last week on this slide all of the edits that were made in the oh six draft I believe were too many not all were made to fix "
  },
  {
    "startTime": "00:09:05",
    "text": "up wording and reconcile requirements that a lot of them got inherited from the version 3 protocol draft and really just simplify things trying to get away from more lower level details about messaging if flags and make the requirements a bit more on the the workflow and the expected sequencing of things and section 3 then becomes a lot of more description of the protocol and less of actual requirements so section 3 is is an overview to an implementer or somebody who\u0027s trying to troubleshoot protocol on the later sections become actual vertical requirements so next slide please and I didn\u0027t realize until it was too late until it was the day after the cutoff but I had been making later edits to my own copy of the draft which is now version zero seven but I missed the cutoff so they did not get included until relatively recently so there were a couple of services and these changes are relatively sparse there were a couple of services that were missed as far as again this listing of services is supposed to be complete so the obvious one of actually initiating a transmission was missing so that was added in and there was a little bit of touch-up in the services listing one of the actual changes in behavior that was done in the 0-7 Draft was to add back in from TCP Co v3 negotiation of kin and end of the CL session do reactive fragmentation so I\u0027m sure we\u0027ll discuss this a few minutes but the intent of this as an extension header is a couple of different things one is that it\u0027s not really the convergence layer that\u0027s doing any of the logic for reactive fragmentation itself it\u0027s really the BP agent that\u0027s doing this the reason for that and it\u0027s described a little bit in the draft itself but the reason for that is that the by the definition of how a transfer can fail at the point the transfers failed the TCP CL session really has go bad in it and the session effectively "
  },
  {
    "startTime": "00:12:06",
    "text": "will be either closed by one endpoints or will have failed at like an operating system TCP socket layer and the TCP CL session and the TCP CL itself is a bit useless from the point of view of doing the reactive fragmentation either for generating the reactive fragments or for reassembling them so this is a BP agent task and the only thing that the CL can do in terms of this reactive fragmentation behavior is to negotiate and signal whether each of the ends of the session is capable of supporting this so for that\u0027s one of the reasons the other reason is that after hearing discussion on the mailing list about what reactive fragmentation really should involve and even in seeing some of Victorious late comments that we\u0027ll discuss in a bit there are still kind of in my mind different notions of what reactive fragmentation can possibly represent and so by moving this into an extension item what it really represents is that what\u0027s what\u0027s negotiated in the 0-7 version of the draft is this particular variation of reactive fragmentation as an optional behavior and if somebody wants to come up with their own late variation of what reactive fragmentation should be and how it should be parameterize then that can be accomplished through a different extension item and B as far as this is concerned it\u0027s not necessarily directly affecting the TC PCL segment of either end of a session so the the CL is used for signaling this information but it\u0027s really the BP agent that is going to actually be acting on it and then the last change is the simplified shutdown behavior again similar to the other later at its the requirements were changed from a relatively lower level set of statements about the individual messaging to something a bit higher level to just state that during a shut as soon as the shutdown is initiated you can\u0027t in you can\u0027t initiate any further transfers and there\u0027s still both in the draft and as an item here that there\u0027s still the frog ative of the CL node itself to simply decide that it doesn\u0027t want to actually complete a shutdown and "
  },
  {
    "startTime": "00:15:07",
    "text": "it just wants to close a TCP connection for whatever reason and if there aren\u0027t any in progress transfers that\u0027s basically a clean version of closing a session but if there are any in progress transfers it just causes the transfer to fail so shutdown is that the clean way of avoiding transfer failures but a CL note can always just close the TCP connection and possibly fail some transfer so next slide please you\u0027re a little wouldn\u0027t know is that the last like there\u0027s one more after well I\u0027m sorry I I must have condensed this thing yeah this looks right so yes so the zero seven I know the zero six version is what was on the agenda but there is a zero seven version that makes those late changes in some areas and this was something that I know is mentioned real recently in the mailing list and I\u0027m not sure if it\u0027s worth including in the see the TCB CL draft itself but there is an updated working implementation the real basic working implementation of the TC PCL before and it is something that could be included as a URL reference with some text in the draft itself it\u0027s an RFC correct today yeah I\u0027m sorry Scott I was holding holding your question just because it\u0027s very difficult to me taker do you still have a question okay okay so no um thanks Brian obviously stay on the call because we\u0027re going to move straight on sir so hopefully Vicki\u0027s got a little bit of a presentation on this and then we can try and get a discussion forum I\u0027m buying everyone so Rick caught me in the bar I think and said hey can you give this a read and I did and thinking of this from the point of view that having been sitting in Rick\u0027s chair I understand DTN but I haven\u0027t actually implemented TCP CL before a couple of things jumped out at me one one when you do something like a shutdown for a version mismatch don\u0027t you end up "
  },
  {
    "startTime": "00:18:09",
    "text": "opening yourself up to essentially losing potential connectivity if you know how to speak the older version so should should the the contact header have some indication of what version of of PC PC lu-lu you support so that you could actually negotiate which version to use there was earlier I think a similar comment on this and my if I remember right right now there is in the draft language about that a node should start at its highest version and if it supports multiple versions to work down the list so there is language in there about attempting multiple versions but not from the perspective of like what you just mentioned where it\u0027s it\u0027s up front exposed these are the versions supported right because I would think that what you would really want to be able to do is keep the TCP session open and just send a new contact header with with the next version down that you support so that you don\u0027t actually tell the TCP session down because you don\u0027t want the three-way handshake to to occur again and again yeah I for me this was really just hold of her behavior from the version 3 of the of the the protocol when you started the comments saying we\u0027re trying to stay as as close to the TCP CL v3 so that that may that may be part of what\u0027s confusing me the second thing is is I see a lot of places in the document where it says things like you know a TCP CL implementation should do something but you don\u0027t necessarily give a good indication of when it shouldn\u0027t and so it may be useful to say you know if you really think it\u0027s a should then give an example of of either where that would be true or a case where it would not be true and with my background I can tell you that if you don\u0027t do that you\u0027re gonna get a lot of comments during iesg review going okay so when do I make a decision as to do this or not do this okay when I cancel it that I do a kind of generic statement that I made you recur Lior was is that it may be useful to have something like a state diagram that describes when you move from these different points to other points and what the what the decision would have to be in order to make those moves Brian can you make some of those comments on the list so yeah I know I know Ed\u0027s taking notes but it\u0027s useful to know it\u0027s comments on the right so I recommend we move straight on to "
  },
  {
    "startTime": "00:21:10",
    "text": "Vicki and then we hopefully can have a discussion about what the working group thinks reactive fragmentation is how much Livesay which layer and how we really make some progress by simplifying it down to a basic set of rules but thanks Mon Ami so can you show if you can\u0027t even really and first of all I want to say thanks to Brian for over time these putting into this I know I\u0027ve given him a lot of grief recently but he\u0027s taking the time to go and reply to every single comment so and basically all the work that you\u0027re doing and the comments I\u0027ve got today are on the most recent changes so bringing back in their contact had an extension to to sort of the reactive fragmentation and some of those signals that go between the kovitch layer and the bundle protocol agent and so I found this quote which I thought it might be quite useful to have seen a little bit and so reactive fragmentation if the bundles only partially transferred the receiving bundle there would modify the bundle to create a fragment from it and forward that on however they weren\u0027t really but also it\u0027s looking for a feedback from the convergence layer to see how much and how much actually did get sent unacknowledged so that it can create the second fragment and so the contents of the draft at the moment I\u0027m going to talk about the reactive fragmentation and we negotiate that in the contact editor using the extension item like Brian mentioned and so that consists on flags which there\u0027s a critical flag which in the draft it says if a critical flag is set it means the piano has to interpret and negotiate the reactive fragmentation capability and to me that wasn\u0027t really clear what that meant I hope I\u0027ll get on certain and she\u0027s got the type which is reactive fragment and the actual value of it then is a one octet Flags field two flags in that I can generate which says that the sending node can generate reactively fragmented bundles so it wants that feedback on how much and how much did actually get acknowledged and I can receive is then for the other side to say that I\u0027m quite happy to pass up a partially transferred bundle and then the bundle layer it is capable of forward in that all as its own fragment so the idea is then if the sender can\u0027t generate reactive fragments and the receiver can receive them and the convergence layer then will pass that well the receive data Sall the segments that gets sent through and and if the transfer line fails it can tell the bundle protocol agent so that it can form a smaller bundled with the unacknowledged section per bundle on the receiving side and the convergence layer "
  },
  {
    "startTime": "00:24:11",
    "text": "would hand the bundle data upwards to the agent even if the transfer failed and so then it can then create a fragment from that and it would then trust that the sender is also creating the second fragment from the stuff that didn\u0027t get transferred and so what I wasn\u0027t sure about was if there are other combinations rather than just the happy I can generate and I can receive and so if one side sends that extension header and the other doesn\u0027t it says in the draft but you know reactive fragmentation would occur but what confused me was if there\u0027s different combinations of having the critical flag and then different combinations of can generate on one side in cameras even the other but I think in most cases you probably want to establish the session but disabled acknowledgments and one other point that I want to make on this was that since in that TCP CL session both PS can then initiate transfers so bundle can go in either direction if there\u0027s a strange combination of the can\u0027t generate and that I can receive does it kind of limit that session to one-way transfer and would you check that contact header information basically for the start of the transfer in each direction to see if that transfer would then use reactive fragmentation and the other thing as I was reading through draft it wasn\u0027t really clear to me when the data that gets received and gets actually transferred up to the bundle protocol agent and it does say in the draft it hints at it in a few places that the bundle data can be inspected by a bundle local agent and so that then could just be refused and so I guess that\u0027s happening as the segment\u0027s come in and there was it wasn\u0027t really clear to me and and then part of another discussion we mentioned would there be a threshold on the amount of data that you should receive before you should consider doing a reactive fragmentation and the other new part of the draft is to do with the signals that come between the curvature and bundle protocol agent so I thought I\u0027d do a bit of a summary of those and can I hold you there a second does anyone have any immediate questions on the reactive fragmentation behavior and and so on or do you want to hold those questions till after the end of the thing so this slide shows a bunch of the session related ones so the bundle protocol agent can tell the convinced layer try to try to set up session for me and they could also say you shut down and then the signals that go the other way the session has started which is that the TCP connections open so I wondered if that was actually a useful signal or not because we\u0027ve also got this session established 1 which is basically the TCP CL session is up and running exchange the contact headers it\u0027s ready to use and then the bundle protocol agent also get feedback if the session got shut down or if it failed and the ones that "
  },
  {
    "startTime": "00:27:14",
    "text": "are related to sending a bundle so the bundle protocol agent would tell the convinced layer began in transmission it would give a bundle and there\u0027s one in there at the moment that says the convergence layer would indicate transmission availability so the fact that the session is open Michael I was wondering if we were to get the same information from the fact that we get the session established signal and also we know if if we\u0027ve begun a transmission then we know if it\u0027s succeeded or failed because there\u0027s another signal for that and the other ones there are a transition success of the bundles fully transferred an intermediate progress so I wasn\u0027t sure the code in the draft is that this is at the granularity of each transferred segment so I was wondering if that\u0027s the number of bytes that\u0027s been acknowledged so far if that gets passed up for every segment that gets acknowledged and also transmission failure so I was wondering in some of the intermediate progresses with just saying transmission failed but we said this many bytes through and if in that section of the draft Osweiler and also says that TCP see our supports indication of reasons for the transmission failure and so under and then in fact meant that there was reason codes should go up to the bundle protocol agent or not wasn\u0027t really clear on that piece on the receiving side and again we\u0027ve got that intermediate progress so I was wondering if that probably meant that data as it comes in every segment gets transferred up to the bundle protocol agent and there are various areas in the draft which kind of hint at that and the fact that the bundle protocol agent can inspect that bundle and is able to then refuse it which is the second signal is from the bundle protocol agent downwards say and interrupt that reception and then the other two are the courageous layer saying that bundle was fully received or failed the reactive fragmentation and if there\u0027s any comments on any of that from my perspective some of these questions hint at a layering model in there so and I know Brian\u0027s spoken about this before which is the convergence there really should be just shoveling the bytes of a bundle and notifying up to the bundle processing agent that I have a bundle I only got the first half of a bundle per se or it\u0027s failed - don\u0027t expect any more bundles from me I think some of the complication comes where you get that in to meet make upon you get that progress feedback is starting to blur the lines and it\u0027s the questions the working group is do we care about this layering enough or is it just seen as a as a sort of computer science II nice to have or does it have value to to stick slightly more formally to this separation which says are open questions Schiaparelli TPM I I think the layering "
  },
  {
    "startTime": "00:30:17",
    "text": "is important I think I think sticking to to clean learning is important and I think in particular is important because TCP CL is not the only convergence layer right there are going to be others there are others there could be others that that are similarly capable of doing reactive fragmentation I think we want to have a common framework for all those things we don\u0027t want it like we invent it for every single one so I think the key to doing that is maintaining clean layer in between bundle protocol and the convergence layer as as Vickie was was speaking I was thinking what is there a simpler way to do all this and my first thought was when I just so flag in the bundle and not have the curves there do it the problem that is that then the convergence layer has to parse the bundle and pick it out of the flag out of the bundle so what I what I think is possible is to have a to simplify the negotiation and the thing that came to my mind as I was doing this was this I would propose that we have a flag in the segments of the of the the convergence their protocol attentionally do you mean the transfer in it as there\u0027s a start of an individual transfer ahead of which okay so I think it might be a like a bit too setting in every in every segment because he missed the first one you don\u0027t know what to do and I think it only cost a bit and I\u0027m I\u0027m inclined to think that it just needs to be there in each one just so that you always have it and that the the and the intent of that flag would be it would be set by the sender and it would be different hop-by-hop it because it\u0027s convergence there and with the flag would signify is that I require that you fragment this bundle reactively fragment the bundle if it\u0027s incomplete now the the sender will acquiring it doesn\u0027t mean that the receiver has to comply it\u0027s that this is what the sender is intending because the sender is committing to being able to do the sending end of the reactor fragmentation by setting this flag when when the receiver receives the data if it determines that there\u0027s an incomplete reception then then if the sender simply authorized reactor fragmentation and if it is able to do it it does the reactor fragmentation it signals to the sender "
  },
  {
    "startTime": "00:33:19",
    "text": "whether or not it is doing this by the presence or absence of the interim acknowledgments so if if the receiver is if the sender signals that reactor fragmentation is required on this bundle and the receiver is able to do it then interim progress acknowledgments come back so that the the sender knows and it has the information to do the to do the fragmentation if either the flag is not set or the receiver is unable to do the reactor fragmentation then there should be no interim no progress acknowledgments coming back only only a acknowledgment at the end whether it is all received or none received so the this the negotiation is actually pretty simple and the processing is pretty straightforward the absence or presence of the interim progress acknowledgments indicates whether or not the reactor fragmentation can happen and will happen okay Rick speaking personally checked off I take your point what happens if somebody am I allowed to change that flag during the transmission or once I commit to it do I commit to it or do we use this as I\u0027ll flip it when I got with as if I understand there are suddenly start setting this bit when I believe I\u0027ve sent you enough data that I now reacted from starts to make sense exactly because it\u0027s because it\u0027s a convergence though it\u0027s by definition it\u0027s hop-by-hop so it\u0027s different on every hop of of the of the end path because it\u0027s really a function of what the sending node can do and what the receiving node can do and it would be a an implementation detail how the sending node on the protocol agent would convey this information to the convergence layer adapter the converts their adapter then would be responsible for setting the flag in the in the segments that pass to its peer just as a clarification point because Scott Tamiya sort of continuing a couple Viki Scott nurse or a continuing a conversation we had earlier we\u0027re trying to when we say reactive fragmentation we are focusing on a single use case which is I am the sender is sending a very big bundle to Scott and halfway through the transmission the line goes down the transmission breaks what I don\u0027t want to do is next is throw away all information that I\u0027ve just you know the one gig of the two gig I\u0027ve sent to him I don\u0027t want to resend next time round and that\u0027s that\u0027s all we\u0027re trying to scope reactive fragmentation to is the "
  },
  {
    "startTime": "00:36:20",
    "text": "recovery online failure and I expect one was going to say but there are some really cool exciting things you can do the reactive fragmentation but that is out of scope at this point on the contrary go on their own info do you know yeah I don\u0027t quite understand why reactive fragmentation is now reeling it took the earth again because I think at the beginning of this working group it was established that there are all sorts of security complications associated with the use of reactive fragmentation and I\u0027ve been sort of half following the discussion on the Middle East some time back I never saw an email from a terrain so maybe it was not the way I was busy were or a thought everything was okay but I would like to invite him to to comment on this Scott Bailey JPL there I\u0027m not a big fan reactor fragmentation and I was a sooner look went away completely but if we\u0027re going to be doing it I think the security concern went away when we agreed that the payload block would always be the last block in the bungle so that you could fragment and and you could break partway through the security concern had been that for Bundle authentication blocks half of the the bundle authentication would be a block that follows the payload and in the event of threat of a complete transfer you couldn\u0027t validate that the bundle was okay and I think we were past that now following on for a more general point of following on from Ronald DTM is delay and disruption tolerant networking now I know a lot of the delay focused members of this group don\u0027t really care about reactive because it\u0027s it\u0027s all about delay management for those of us on the disruption side of it the reactive fragmentation does make sense because if I\u0027ve got a big file and it breaks halfway through I\u0027d kind of like to not have to send it hard again a brain EPL so so we\u0027ve talked about a couple of things but I have a sort of orthogonal question for the group which is this this is starting to sound to me like the discussions we had in BP Biss regarding custody transfer which was a feature that some people needed and some people did not that at the high level seem simple but could get bogged down into details and use cases and there was a thought of if it is not the common case then the standard could go forward with "
  },
  {
    "startTime": "00:39:21",
    "text": "the common case with extensibility mechanisms for understanding how new things come to be so my question to the word group which is either brilliant or terrible you know it is is there value in saying that the TCP CL is vitally important as a draft because it shows how these three things security and protocol and convergence layer could work together and that we should be focusing on a section in there that deals with how to extend it or to accept the fact that there may be multiple other CLS in the future in some way but is this discussion necessary to hold up the tcpo right now this is my is my question to the work in response with my chair hat on that is a very valid question and half the reason I wanted to have this discussion today my response would be if the working group says fine push it out we\u0027ll do a TCP extension that you know as long as we\u0027ve got the header contact header we can negotiate extensions or something then as it currently stands in my opinion the TCP CL draft alludes to hey you can do reactive fragmentation with this chunking and this signaling has only bit arrived and a bit didn\u0027t arrive so I think as it currently stands people will start to do reactive fragmentation because they think they can see the bits are there if we don\u0027t want to do reactor fragmentation I suggest we take it out of TCP CL and keep it really simple or we do reactor fragmentation and we do it properly but that\u0027s going to delay your edge and Scots drafts and that\u0027s the real question for the working group so thank you for that and they\u0027re just the follow-up comment to that is in general having some language in TCP CL that talks about future extensibility and reserve bits is necessary for other things as well and this may be sort of the first identified example of that I\u0027m singable in the queue behind you noting so scholarly GPL again just a comment on delay versus disruption I think it\u0027s a very good point I have felt for a long time that proactive fragmentation based on the data rates going over the links was at least as good a way to deal with with that sort of problem as as reactor fragmentation so it\u0027s simpler and and less of a burden on the convergence there development but the sort of thing that I was proposing a little bit earlier actually is simple enough to be workable so in that context time seems to me it\u0027s okay to proceed "
  },
  {
    "startTime": "00:42:24",
    "text": "with with including it in this draft if we can make something as simple as that by everyone and I think I\u0027m gonna make God\u0027s skin call in a second so two comments the first one is is you always have to be careful when you\u0027re running applications trying to play fun games with fragment sizes when you\u0027re running over top of a protocol that\u0027s already designed to do that for you and in this case we have it twice right because TCP is going to try and figure out its maximum segment size and an IP is going to be doing fragmentation underneath you so you always get all sorts of interesting you know potential out of order handling the packets that drive application developers crazy the second thing to consider is reading through the reactive fragmentation description in that\u0027s in the spec right now I\u0027m not sure it\u0027s going to cover all the cases correctly because I don\u0027t think there\u0027s enough enough information in each of the segments in order to make reassembly efficient and just to kind of reiterate something I said to Rick as we were running past each other in the hallway you may want to take this completely out and actually make something that looks more like our sink running on top of TCP CL so that you can actually do things correctly and recover very quickly because they have all sorts of hashes that allow you to identify segments and bundles and blah blah blah so that you\u0027re only transmitting the things that you really need to transmit once you should reconnect with with a with a note I\u0027m following on from that comment announcing TCP announcing CL would be a new convergence Larry we wouldn\u0027t try to cram it into TCP would be them right so you could actually make the decision of whether or not it sits on top of TCP CL or if it\u0027s just its own conversion slow your period because it\u0027s going to run on top TCP anyways ok so suggestion oh go ahead so just just to speak to Tehran\u0027s point about security and to Scott\u0027s point whenever you do react your fragmentation you you are opening yourself up to the security concern of to handle the case where I\u0027m a hundred bytes away from you know I\u0027ve received 200 gigabytes - 100 bytes of my large bundle and I would prefer not to go through that again is handling that case it\u0027s hard to distinguish that from the case of yes that\u0027s 2 gigabytes of payload and since I don\u0027t have the last hundred bytes of it even though the payload is the last thing in the bundle I can generate garbage and send it to you and make that denial of service attack particularly in details denial of service attack becomes "
  },
  {
    "startTime": "00:45:24",
    "text": "exhaustion of queuing and persistent storage as well so so there is a front-end aspect of the security that reactive fragmentation needs to address and that needs to be addressed either by saying I have only so much of my dedicated storage that I\u0027m willing to use to support reactive fragmentation or I will only do reactive fragmentation when I have something that\u0027s strongly authenticated on the front end but there there needs to be additional security mechanisms there to make sure that someone is not attacking your persistent storage which they will do or reflection attack ok so I I have a proposal to the room and it\u0027s always very difficult to do this over jabber and meet echo but I I would like to hear a hum so the binary proposal is one option is we understand the reactive fragmentation is a complex issue and we\u0027ll need more fort more work to either get into TCP so to get it right in TCP CL and the other side of that is we strip back TCP CL to some very basic functionality to progress so the document is clear doesn\u0027t allude to reactive at all so no one can try and slip it in by mistake and we keep it clear and we get it done so if there\u0027s only if only that make any sense so if you are in favor of continuing to work to get reactive fragmentation right in TCP CL please hum that\u0027s fairly clear and I\u0027ll ask for those who want to see it stripped out so we can see who\u0027s abstaining if you want it stripped out put TCP CL back to something clean simple and pure please hum I think that\u0027s a fairly clear indication make a comment on your chest and the part of it that goes into TCP CL is not really how you do the reactive fragmentation it\u0027s just to enable some support for it so that can be defined in the future so do we still need to be careful about how much is actually mentioned in TCP CL how we are going to support some future definition of reactive fragmentation or do we just want to strip that out I don\u0027t know how careful we need to be just to enable the support for it I propose that we strip it out altogether it\u0027s it\u0027s a it\u0027s an important capability it shows up in obviously 4358 the original architecture and people will remember it and it will come back but I think omitting it from this specification does no harm and possibly some good advice by simplifying and and in encouraging simple implementations "
  },
  {
    "startTime": "00:48:25",
    "text": "the comments that I made that which is why we\u0027re discussing this again now I make comments about why well what do we do with the ax so should we leave those in TCP CL ready for some future definition or how much how much are we simplifying so so I don\u0027t have a comment to that what I what I would say is this also is reminiscent of when we discussed BP sac and there was a question as to whether we included CMS and cryptographic message syntax and boxes and so on and the way we resolved that again was by putting in giving some thought to extensibility so while I am in favor of taking the reactive fragmentation bits out of this version of TP TC PCL what I would be in favor of is greatly strengthening the language of extensibility and how we create reservations pit reservations in the headers and also to have a discussion associated with it if there\u0027s an example that goes with it and that example happens to be the case of rector fragmentation purely in an informative way for how extensibility could work that might be a way of sort of capturing thoughts but I think the TC PCL needs additional language in terms of how it would be extended if this is the direction we\u0027re going to go mark s co-chair at one point in time I would like to hear Brian suppose comments on this discussion so from the purely getting the thing finished standpoint the simplest the simplest thing would be to remove the language about fragmentation maybe remove the notion of segmentation so right now there is only a single extension area which is in their contact header but it sounds like there may be some kind of idea of I guess adding also an extension area to each of the transfer the transfer in it so that some kind of extension policy could be applied at the individual transfer level but I\u0027m not sure it really depends on how how the seal is being used in the sense that there is language in there right now describing that it\u0027s possible for a network to use the CL you know one session one transfer "
  },
  {
    "startTime": "00:51:25",
    "text": "mechanism that there\u0027s a lot of overhead to using it this way but it also gives you a lot of control versus keeping a session up negotiating parameters for that session and then those parameters are just a blanket policy for every transfer that happens between these two nodes I for me it feels like it would be a relatively simple copy and paste sort of action to have extension items to find an area extension area defined both for the session itself and for the individual transfer and then if somebody wants to come along and say I have a fragmentation extension for this individual transfer and for this individual transfer the fragmentation policy is don\u0027t bother if it\u0027s less than X number of bytes received and do something else if it\u0027s more than Y number of bytes received something like that but it would be an extension item applied to the individual transfer and going back to this is some of Victoria\u0027s early questions there\u0027s a little bit of description in the draft but I mission this also on the mailing list is that there\u0027s a lot of interplay between the segment sizing which is part of the negotiated session and what you would do with those segments in the sense that if you really didn\u0027t care about fragmentation at all and you really wanted to take the minimum amount of overhead and simplify the actual run time behavior of the CL as much as possible then a blanket policy would be I have my maximum segment size identical to my maximum bundle size which is some could be some very large value and what that would mean is that if you\u0027re if the sender is obeying this policy - it\u0027s two points one point was I I think the the idea of adding an extension area in the the individual transfer header I think actually has merit because I think we\u0027re not the only ones who are going to think of things like this I think that that future enhancements to the protocol "
  },
  {
    "startTime": "00:54:27",
    "text": "would come along in the future and it ended with and and without that sort of mechanism I think it\u0027d be more awkward so I think it costs very little and if it\u0027s not used as great make it make it you know vanishingly small but but I think it I think adding extension to the transfer initiation header I would be in favor of that the other thing that I think we can do that I think would again simplify the specification and would cost nothing the interim progress acknowledgments really the only point of those has been to support reactive fragmentation I think I don\u0027t think there\u0027s any other value so I will propose that we remove those I think that we can do in store preserve the ability to do reactive fragmentation the futures say that there is a mechanism for sending back an acknowledgement and in the basic specification the the received length field in the acknowledgment is always the entire length of the transfer you know you know and and without saying so acknowledge to ourselves that in the future there might be an extension that would that would state conditions under which the received length value in an acknowledgment might be something other than the total length of the transfer but before you go my let\u0027s go chair I think I know the answer but I want to make sure does this discussion has any impact on VP PS document no there\u0027s no no there\u0027s no impact on this document from any of this discussion there is there\u0027s what a point that ie that Brian brought up a little while ago about reassembly that I thought I would mention in passing which is that the reassembly to the extent that reassembly is difficult and needs more support reassembly happens in the envy phoebus the specification for for reassembling fragmented bundles happens there so if we need to do something about that then we have to revisit reassembly and view this I think that\u0027s ok I think we\u0027re we\u0027re ok currently but if there is an issue there than that\u0027s that\u0027s where that that conversation needs to happen write your comment about the intermediate progress the other thing that enables is the inspection of the bundle by the higher layer by the bundle protocol agent to say actually I\u0027m not interested just reject the rest of this transfer i I think the "
  },
  {
    "startTime": "00:57:29",
    "text": "what I\u0027m what I\u0027m suggesting we can remove is the acknowledgments going back to the sender so signaling to the receiving bundle protocol agent could still happen and I think that\u0027s a purely an implementation matter understand inside the sender has already decided I\u0027m gonna send this Rick Taylor speaking with chair hat off I would propose that if we\u0027re simplifying this down I don\u0027t see the point of the segment\u0027s anymore and I think the segment\u0027s is is the flag that kicks off reactive fragmentation again and again I totally agree with the point about an extension point in the transfer header as well as the contact header so you can you can negotiate extensions for the entire session or on you can add an extension per transfer whatever that might be but I don\u0027t think in the bare simplest form we should bother with segments a TCP is already doing you know receiver knowledge windows and all that kind of stuff we don\u0027t need the extra overhead of segments so effectively your transmission is a single segment Brian element I\u0027m going to echo what Rick is saying in just slightly different way if you have segmentation in the TCP CL and TCP is already doing that for you you get these very interesting behaviors with overlapping control loops that you probably don\u0027t want when you\u0027re talking about Layton sees as long as what we have possibly going on here so I think it does make sense to strip the segmentation stuff out and move that into some type of extension if people want to try and do it separately from the base bag Scarborough I\u0027m also endorsing this idea I think the in the event that we will come up with an extension for reactor fragmentation the I suspect that the transfer header and and the interim progress report acknowledgments are sufficient and the segment the the the segmentation the segment headers are not necessary in that event and certainly if if we\u0027re simplifying the the basement ocation I don\u0027t see any need to retain the segmentation headers right I\u0027m Vicki you\u0027ve got two more slides about shutdown do you want to try and blast through those fairly quickly editing on the fly in light of the previous conversation so it\u0027s very end but couple Oh Brian can you connect again have you got any responses we lost you completely as if by magic ah yeah I had to "
  },
  {
    "startTime": "01:00:32",
    "text": "completely do it do over on my side but yeah it seems to be back I missed the last thing I was talking about was the the extension items and the contact header versus the versus the individual transfers and I can\u0027t the last half is like I should have already I think and please correct me anyone in the room if I get the summary wrong that is the proposal is that the extension point that exists in the contact header we should have a similar extension point in the transfer header okay so individual transfers could be extended in some unspecified way okay that segmentation doesn\u0027t need to exist because it opens a can of worms where people start are tempted to do the wrong thing myself included so a transfer effectively becomes a single segment and TCP handles over buffering and when doing stuff already and that\u0027s where we are as good summary obscene notes so do you have any feedback on that would the the current messaging I\u0027m talking about the protocol messaging with the current messaging structure then be the same just removing any of the logic about multiple segments for a transfer so a single transfer would amount to one transfer in it and one transfer segment although it doesn\u0027t necessarily need to be called segments anymore transfer data maybe Scott Bailey yeah I think that\u0027s it is that the the stream of transmission from the sender some young t CPC out to the receiving t specl would be with would be with the essentially a stream of transmissions punctuated by transmission headers so there\u0027d be a transmission header and at the end of the transmission header then you commence sending data and then the end of the data and there\u0027d be another transmission header okay and then and then the reverse traffic would be the same acknowledgement messages that are already in the specification okay but but a single one per transfer only a single one yeah I believe so okay well a single one in the sense that that there would be no other punctuation in the in the transmission of the transfer if it\u0027s two gigabytes then you have a buffer and you\u0027re gonna you know TCP sends you know whatever the size of that buffer is but that\u0027s you know notnot not not identifiable and yeah over the yeah over the wire yeah I think sorry Rick is I "
  },
  {
    "startTime": "01:03:34",
    "text": "think the proposal is that that transfer becomes an atomic thing you write the transfer a bundle or it doesn\u0027t get transferred I does raise a question about if we put an extension point in the transfer header then at what point does the other end get to say I don\u0027t like that don\u0027t send me this so can you remind me again do you get a transfer ACK after sending the in it before you start sending data or do we have to now wait for the end of the entire transmission for the other end to say I have no idea what you\u0027re talking about with that extension header right now there\u0027s no opportunity to acknowledge after the init message but there is the opportunity to reject so there is an opportunity there to say shut up yes yes or refuse I think is the name of shoes what would you wait for that message before you then start sending what would have been the segment\u0027s the the new the one segment would you wait for that replied different yeah how long do you wait until happens if that comes in like when you\u0027ve already started sending that huge chunk of data I know Scott Bailey I would suggest I guess that that that when you get many of these one of these refusals the refusal will identify the transfers or something in the refusal identify the transfer right and and and and what the sending TCP cell should do is when it\u0027s informed somehow that it has received one of these refusal messages it should say Oh am I still sending that if I am I\u0027ll stop and if I\u0027ve already finished you know too bad but that needs to be clarified in the document that\u0027s one of those things that it does need to be clarified yeah okay yes that\u0027s right yeah that needs to be clear does the mechanics definitely already exist so on them take a note to add explanations okay so put you on hold for a second because Vicki\u0027s got a couple of points about shutdown and then then I hopefully we can close this whole thing with some progress go ahead Vic just not to you moron shutdown training basically you\u0027re just edit on the fly is it that the lay oh I\u0027m so shut down messages there\u0027s quite a bit through the draft about when you can actually use them so there\u0027s a list that people catch up on that I think one thing that the drafters say is that if you receive a shutdown you should just have the shutdown in reply but you don\u0027t have to so I\u0027m not sure if that\u0027s something that we need to look at and listen next night so and then the rules that were in the draft at the moment after sending a "
  },
  {
    "startTime": "01:06:34",
    "text": "shutdown you\u0027re not allowed to initiate any new transfers but it doesn\u0027t actually say you can\u0027t accept any and on the receiving side it says you can\u0027t accept any but it doesn\u0027t forbid you from initiating any and you\u0027re allowed to carry on any transfer that\u0027s in progress at the moment so that\u0027s if there\u0027s still more segments to send and so maybe we\u0027re changing all that that doesn\u0027t really need to be considered but it also says that you can immediately shut down TCP connection so you\u0027re not then able to send any acts if there\u0027s a transfer coming towards you but if the sessions idle then obviously is not an issue next slide and it doesn\u0027t mention I don\u0027t know if it needs to or not but it doesn\u0027t mention behavior if so if you were send another in it after you\u0027d received a shutdown what you would actually do about it if you\u0027d silently ignore that or if you\u0027d refuse it or reject it or send a shutdown back or yeah quick quick question Vic Brian\u0027s suggestion of a of a state transition you know state transition diagram do you think that would go a long way to answering some of these questions and perhaps ironing out these these else cases yeah it could be quite useful actually bobgoblins Ronnie Burman so what relationship do you to exist between the TCP I\u0027ll shut down and the TCP closed that\u0027s going on underneath with the TCP connection itself yes well I\u0027m slightly confused about and I\u0027m trying to pick out from the description and the draft what actually means I mean the the thing I kind of interpreted was that when you send a shutdown message you\u0027re basically saying I\u0027m not going to send you anymore but nevertheless transfer finishes but I wonder if that should be kind of I don\u0027t want to receive any more as well I\u0027m not really sure with we go burn so if I think maybe bronze goes allowances yeah yes so about the shutdown the the language right now might not be exactly clear but the the intent of what\u0027s written so because the the CL itself is bi-directional once the session is established there\u0027s no real orientation to either of the two peers the language right now should be that when when you send a shutdown or when you receive a shutdown at that point neither peer is allowed to initiate a new transfer and either peer if they see the initiation "
  },
  {
    "startTime": "01:09:37",
    "text": "of a new transfer would refuse not read not reject I\u0027m getting my language a bit messed up but it\u0027s basically it\u0027s an invalid message at that point a transfer in it is not is not accepted there is there is a signal there is an on the wire message of I got a message that I didn\u0027t expect to see at this point in the protocol and that\u0027s what would be I think the response but the shutdown is intended to be and it should be written that way but I can go back and look it is intended to be symmetric in that sense that there\u0027s no distinction between shutdown transfer shutdown as a sender or shut down there\u0027s receiver there is no there is no mode to the pier of a session and there is no mode to a shutdown in that sense there\u0027s no directionality to it okay so but the intent the end intent is to allow transfers to complete that are in progress versus shutting down the TCP connection means if there happened to be a transfer in progress it\u0027s it\u0027s failed okay so yes you\u0027re separating the shutdown of a transfer as opposed to also shutting down the TCP connection because what because one way that some applications handle this is is they\u0027ll do a TCP close and that\u0027s that\u0027s a half closed which means they can\u0027t send any more data but they can receive any data that\u0027s in transit okay so because because the CL does acknowledgments okay well I don\u0027t believe that that would be something that would be that would work talking about the current 0-7 version of the draft and not what we were just talking about about single segment behavior the until they acknowledgment until the the CL transfer acknowledgement is received the transfer itself hasn\u0027t finished hasn\u0027t succeeded okay the receiver of a bundle the receiver of a transfer still has to send out TCP connection you know TCP socket data to acknowledge the the transfer okay yeah yeah just to be clarified because when I read some of the the description of shutdown I see the TCP close happening when someone says a shutdown but I think you need to clarify what you\u0027re waiting for and why the TCP connection needs to stay up okay Vicki actually suggested a block of text for this absolutely yeah okay Scott burly and I think it\u0027s already "
  },
  {
    "startTime": "01:12:42",
    "text": "clearly inspecting some additional language to clarify my in my mind I would like to remove the distinction between clean and unclean shut down and just say that shut down always means an orderly shutdown and it always means that upon receiving a shutdown and upon semi shutdown you cannot initiate any more transfers and upon sending a shutdown and receiving shutdown you\u0027re required to complete perception of the of the current transfer and and and until you until that\u0027s done until you completed reception of the current transfers in both directions and there\u0027s only one because they\u0027re one at a time until you\u0027ve completed those the shutdown is not finished and you\u0027re and you\u0027re not authorized to close to close the socket to shut down the the to stop the TCP connection stopping a TCP connection is by definition not a shutdown it\u0027s a it\u0027s an anomaly and and and and you recover from its error correction there\u0027s also comment in the draft at the moment and that you can\u0027t send a message so for example you can send a shutdown if there\u0027s already some kind of message that\u0027s being sent so if there if the segment is being sent at that woman and it\u0027s quite a big segment you can\u0027t then send the shutdown at the same time you\u0027d have to wait for that anyway so in with a new bit of discussion that we\u0027ve just heard would you wait for about transfer to finish and then send a shutdown afterwards rather than send a shutdown and then wait for their transfer to finish I think of it\u0027s a great sorry Rick Taylor I think if it\u0027s a graceful shutdown then you wait for your next opportunity to say I am going to be gracefully shutting down and if if you have to wait for your current transmission to complete before you get a chance to talk on the line then anything else is an abort it\u0027s a I\u0027m killing the connection if it\u0027s an emergency because you can\u0027t muscle transmit anymore just close the TCP connection and and recover from that you know everything that I\u0027ve heard so far that is absolutely the intent of the behavior so so I brainy API I am a little worried about the case that Viki just brought up which is if we are using this for very large transfers and very early in the large transfer we have decided to to reverse our opinion on sending the data and I don\u0027t know if that\u0027s a credible use case I\u0027ll defer to others whether that\u0027s going to happen but if I am 100 bytes into my two gigabyte transfer and I realized oh these are the wrong two gigabytes to send the idea that I need to take time and even if the late hop two hop let "
  },
  {
    "startTime": "01:15:43",
    "text": "that thing finish seems very wasteful to me shutting down the TCP connection seems drastic altering shutdown semantics seems drastic so I agree with everything that Scott had said before about clean shutdowns but it is perhaps having a canceled current transfer without shutting down and without breaking down the TCP session might be a useful thing to consider Rick just could you responding to that I think not having the functionality you want is the price you pay for having atomic transmissions it\u0027s a compromise that I don\u0027t think you can have that without bringing segments back in scope early again yeah I I think that since we since use cases for me to stop a transmission to gigabyte transmission after sending the first hundred megabyte hundred bytes don\u0027t leap to mind I I suspect that this is going to happen infrequently enough that the cost of simply stopping you know closing the socket and the opportunity to speak connection is is a reasonable cost and the simplification I think is is very valuable there if we modify the the shutdown semantics to support anything else I think it\u0027s my name is too much work and I don\u0027t think it\u0027s close best reform hmm Marc co-chair we can I discussed we are aware that we are spending more time than plan on this but at the same time we wanted to clear this out so I\u0027m not saying that\u0027s finished it\u0027s tascam but continue and then try to finish but for the presenters we may not get time for all the presentations they\u0027re unclean shutdown which is basically I thought the definition of it was maybe a little bit off and and my suggestion was that an unclean shutdown was closing the TCP connection before all the transfer had finished and so I think that kind of relates to all the discussion you just had and I think on the final slide next one the next one after oh no like there was two comments they were just sentences I didn\u0027t quite think made sense we can move on so the reason code so if there\u0027s transferring progress and you send the shutdown with a reason code the only born that\u0027s relevant is resource exhaustion but then in the draft says that you should try and finish your transfers and certain quite make sense to me and the other thing was that you can put in a reconnection delay in your shutdown message and could send this area which means never reconnect it so wonder if I was a sensible thing to do or not I\u0027m that kind of covers my point three "
  },
  {
    "startTime": "01:18:46",
    "text": "Schiaparelli and on these two points so I think a good point about stressors in progress than open code being resource exhaustion does it make sense that you\u0027re allowing transfer to finish I think I think maybe we can recast that as anticipated resource exhaustion meaning we have to allow this transfer finish but but and it\u0027s possible but I\u0027m actually a resources all together and I\u0027m gonna throw the whole thing away but that\u0027s in my business I\u0027m not yours so it\u0027s I think it\u0027s okay and I\u0027m the last point I think that they never reconnect I think you could always do things by management so I I think it\u0027s maybe a maybe sending zero reconnection delay is is unwise and it may be that implementations should avoid doing that but maybe have another capability there\u0027s not unreasonable Rick Taylor responding to Scott\u0027s coming I I think sending zero never reconnect is dangerous for two reasons one I think it might be abusable and two I think somebody might look at that and go hey I can do routing with this I can say I don\u0027t want you to send me that kind of data anymore and sneak it in through the backdoor and we\u0027re trying to trim stuff out of TCP CL that can be abused for other reasons Schiaparelli again sure I\u0027m fine with that okay I\u0027m taking a note to remove the zero as a valid value in the recognition delay and anything that\u0027s related to it zero value I I don\u0027t have any problem with that and then the on the resource exhaustion reason code I believe that was really just intended to be to catch a whole I don\u0027t believe that that code was in v3 of the the CL spec I think it was at it just to cover the whole of I don\u0027t want to I don\u0027t want to accept a connection or I don\u0027t want I want to shut down any connection it doesn\u0027t really say what resources are being exhausted it could be that that the total number of TCP CL sessions that a node has established hit some limit or hit some above some soft threshold and you know I\u0027m closing this session because I\u0027ve run up against my limit of how many sessions I should be allowed to have that kind of thing it doesn\u0027t necessarily mean my disk is fuller my Ram is it really is me supposed to be a "
  },
  {
    "startTime": "01:21:49",
    "text": "catch olive I\u0027ve run up against some women I don\u0027t want this session any longer a retailer and I think with the removal of the segmentation the fact that you can no longer shut down within a transfer I think a lot of these boil off I actually think some of the shutdown codes are really aborts anyway and the ability to say something complex has happened that means I can\u0027t recover you\u0027ve probably aborted before then so I my personal opinion is some of these can be trimmed down to stuff the other end can do something with that information I mean if it\u0027s like I\u0027ve crashed with this pointer exception you know the other end doesn\u0027t care you guys yeah so coach your hat on does anyone else want to pick apart apps to specl retro fragmentation transfers this whole topic does of any comment before we move on to the next subject okay so I think we have a path forward Brian we\u0027re expecting a new version of the draft as soon as you could with reactive trend fragmentation and segmentation essentially out and few other fixes that we discussed which people be interested in a virtual interim meeting to just try and stay on top of this and make sure that we\u0027re making progress Brian I\u0027m hoping you\u0027re not going on vacation for the next month and I know we\u0027ve got public holidays coming up what we do in the UK so we can look at maybe four to six weeks or something like that if we get a draft out well let\u0027s not commit to anything now but we can so an APL yes I think that\u0027s a great idea and I would I would second it I would suggest that if we do that there may be an opportunity because there\u0027s an upcoming CC SDS meeting that is close to or several people are who are working on this if that happens in the April timeframe we could get a group of people together in April to sort of work through text for that so if we would have an interim meeting in in the May time frame maybe there is a chance that that we could produce something for review at that time but obviously the mailing list would be included on that sort of stuff so so any kind of private meetings wouldn\u0027t actually be private they\u0027d be minuted at so and so forth but yeah no I think it seems reasonable okay so thank you Vikki and Brian ed do "
  },
  {
    "startTime": "01:24:49",
    "text": "you wanna say a few words on your BP SEC interoperability Suites I know where we\u0027re going to try and cram down to highlights if if people can try and be reasonable but I only have her can you do high highlights to many villages and look not the right thing I am this used to this one that was so my name is Ed Murray and I wanted to talk briefly about VP secular interoperability Suites if we go to the next slide so my understanding is that BP SEC at this point has gone into working group last call I believe that at this point BP SEC is a document has also been requested for security ad review and I\u0027m not aware of any open comments on the VP SEC spec although I certainly encourage anyone here to read through it in the context of last call and get back to us into the list with any changes so given that something that came up at a prior meeting two or three meetings ago was the idea that would really need an interoperability spec not necessarily an operational interoperability spec but at least a testing interoperability spec to make sure that people understand how this can be used and we said that we would write a very short document it is a very short document maybe eight pages total which is a draft that says here here\u0027s an example of an integrity cipher suite an example of a confidentiality cipher suite and how you would use them in the context of BP SEC we have picked for integrity H Mack 256 sha-256 and we had picked for confidentiality ASG CM 128 selecting GCM it does make things a little bit easier in the sense that your payload and your ciphertext are the same size and that spec is out there for review at the last working group meeting we had also requested or asked the question whether this internet draft should also be adopted by the working group because it would need to be adopted by the working group in order for it to also go in as a necessary condition for getting BP SEC through isg review next slide in terms of updates the kinds of thing that this specification does is it lays out how we refer to these particular cipher suites in in the "
  },
  {
    "startTime": "01:27:49",
    "text": "context of BP sack wherever possible we appointed two other documents that have discuss how you configure the specification we\u0027re trying not to invent sort of whole new enumerations but we do need something that says this is how the parameters identified these are how the cipher suite results are identified in BP sex so we have some tables like this in the spec next slide same thing for the security results none of this is new to the spec next slide in terms of what has changed I fixed a few typos since the last time we clarified in the introduction that this is does not necessarily imply operation it is certainly here for interoperability testing and we clarified a couple of items in terms of the parameter definitions and the result definitions specifically that for this I first what you must encrypt the entire payload of the target block instead of portions and just to clarify for those who aren\u0027t familiar with GCM that in this case the ciphertext and the plaintext would be the same size so at this point the the requests are whether we would adopt this as a working group document and whether we can get additional reviews if anyone feels that there\u0027s more to be said about how to configure these specific cipher suites or interoperability testing for VP SEC so I think off the back of that will ask on the mailing list for working group adoption of this and if people are keen we can get the ball rolling on that kind of stuff thank you what next I\u0027ve lost the agenda okay uh next slide I\u0027m still Ledbury and I\u0027m still from APL so we had been talking before about network management and and what network management would mean in the context of a delay-tolerant network we had put together a internet draft called the asynchronous management architecture which was our definition particularly of what an autonomy model would look like an automation model would look like for a DTM that am a document has been unchanged for the past one or two IETF at the last IETF we had said that there would also be a request to look at this as a as a working group document I don\u0027t know the status of that but with request the status of that and then sort of finally what we have done is given that the AMA is is at least we\u0027re not currently adding to it because we don\u0027t have any additional comments "
  },
  {
    "startTime": "01:30:50",
    "text": "from it we think it\u0027s in good shape we came back and said if we were to create a data model to that AMA that captures the kind of autonomy that we would like to see what would that look like in the context of some of our reference implementations something that we\u0027ve looked at as we\u0027ve talked more with other working groups in the IETF is there is a renewed interest or more converging set of interests in automated network management we have been doing our best to keep in front of those and to understand what those sensibilities are and we\u0027re still trying to find something that works in a very embedded space for us in particular we want to make sure that the existing protocols that are coming out for automated network management aren\u0027t too verbose layering some level of autonomy on top of a stack that we already are concerned about deploying and a delay tolerant area isn\u0027t going to help solve our problems if if we don\u0027t have sufficient autonomy if if autonomy becomes how do we summarize existing data sets and and that\u0027s it and then that also isn\u0027t helpful for this community and in particular a lot of the automated network management that we\u0027re seeing coming aboard he is still relying on very synchronous and tight control loops for configuration and and that also doesn\u0027t help so we believe that the data model in the AMA that we\u0027ve put together is still unique and relevant in this area the next slide so in brief what we have started putting together is the AMA which is an aspirational model for how we think network management should be done we have then taken that and put in a data model together to that aspirational model and then we are working separately on resurrecting the amp internet draft which is the Seaboard encoding of that model next slide so in terms of logical modeling what does all of that mean we do have a model we are we are working right now to understand whether that model can and should be modeled in yang particularly if we want to do the modeling and Yang but said that on the wire we wouldn\u0027t be using net comp as a protocol what does that mean and that is sort of an outstanding question that we have right now next slide briefly the autonomy model that we have put together is data and constants the ability to define operators command and control and variables and macros and time and state-based rules and automation and essentially we the claim is that this is the set of autonomy data modeling necessary to do the kind of network management that we want in a very compact and typically binary format for our resource constrained devices next slide and then what we\u0027ve done is we\u0027ve taken one of the reference implementations of DTN ion and started putting together a series of what we call application data models which would almost be like gang models or going back to SNMP MIBs for these things and we\u0027ve created them so that we could manage in "
  },
  {
    "startTime": "01:33:50",
    "text": "band ion in those ways just to show that the specifications and the models are expressive in the ways that we need them to be expressive next slide so where we are right now is for all of those models we have created a JSON expression of those which have the sort of syntactic and semantic sugar that we would want to see in them we have for example basic types of Yuen\u0027s we allow parameterization of basic types so that you can say I would like this integer but I would like for example the number of transmitted blocks from a particular source as opposed to breakdown in defining multiple ones it reduces the amount of data that has to go back and forth on on the wire next slide we support variables and initializations for variables so that you could sort of create those in real time in the operational context of the system next slide we have tables and reports and in particular we have things called parameterized reports all of these sort of associative lookups and parameter drives reports are ways of trying to reduce the multiple handshakes that we see in other network management systems where you have to dump an entire array back to a requester so they can understand what indices into a statically sized array is their particular associative lookup next slide we have the series of controls parameterize controls and macros which are fairly common at this point next slide and constants and operators with the idea that new MIBs actually or new a DMS as we call them can actually define their own operators as necessary so that if you support that that that model then here the additional set of operators that are are in your lexicon that can be used as you create your own time and state-based rules in your system next slide in general we\u0027ve then taken all of this and just to prove the concept and that the model does what we need it to do we have some Python scripting up that will accept those JSON models and generate C ap is that work for ion and it does sort of the round tripping that is necessary to then allow people to not only have eye on all their generated C files let\u0027s be able to go in and just write the implementations that are specific to their needs next slide and here would be an example of some auto-generated C code we\u0027re sort of at the bottom are the things that are put together the read the code that then populates tables and auto generates the initializations and glues together the calls to this don\u0027t need user input and are put in automatically and then someone and really just write the code that is necessary to perform that specific function and since we\u0027ve done that we\u0027ve been able to start work again new applications of models and management of ion at a fairly rapid pace in a couple days maybe a week maybe two weeks if we add test coders next slide so so where we are right now is we we do have the AMA document every one that we have sort of showed it to to date sort of generally agrees that this is a good way of doing network management a style "
  },
  {
    "startTime": "01:36:51",
    "text": "of network management asynchronous management in this particular domain we think that even though there is a large amount of automated network management that\u0027s coming in it doesn\u0027t really fit this particular niche that we are working in and that the AMA is still a good and relevant document and there is a question as to whether it is useful to adopt it here the ADM template as a as a as expressed in Jason is something that we\u0027re working with now but there is a question out to the worker group at large as to whether modeling using yang modeling at this on the back end from a schema perspective is a useful thing to do or is it just confusing if net comp is not the wire protocol and then otherwise probably by the next IETF there will be at least an internet draft which shows an encoding and a reference implementation of this just as a way of validating that we believe the model is correct and and expresses what we needed to correct to Express okay well Rick I behalf of Ed and I have some interest in this work going forwards I\u0027ve been I\u0027ve been going around the various young doctors in network and that cough group and the latest best advice I\u0027ve had on if the working group was try to take this on we would be suggested to do the work in this group if we found issues with yang that wouldn\u0027t fit our modeling we would generate a document which we would then take to let mod to say we like your yang but it doesn\u0027t work in our use case and give them the problem to solve obviously they\u0027d ask for our help in solving that but the feedback I\u0027m getting is no other working group particularly not the Cornett conf network guys are going to take on this work we should do it here and send them basically change requests so so that that\u0027s reasonable because I would also claim that no other working group is trying to solve the problems that we trying to solve and and that that makes perfect sense it would be nice to be able to come forward and say here is an echo system that we can demonstrate does what we needed to do with the performance requirements that we have we would like to adopt yang with these changes and we could give very specific recommendations with my chair hat on I\u0027ll need to check to see how much of this is actually charted work I think there\u0027s an architecture that\u0027s part of the Charter but where they\u0027re actually working on this is chartered I\u0027m not sure and also we have to be Marcus saying no we need to make sure that we get these called triumph or a documents out first and then there might be an opportunity to have a discussion about whether the Charter is still making sense but that\u0027s I think is going to be post those three documents so although ed is keen to push this work forwards adoption and so on is going to be on hold until we can get TC b-b-b second VP based on so also agreed the the existing Charter has some language for regarding network management requirements this kind of data model is not network management requirements there was a question as whether the AMA was close enough to specifying what network "
  },
  {
    "startTime": "01:39:52",
    "text": "management should be doing that it would count as requirements but I don\u0027t think any of this should take time away from the working group and getting the core specifications through cool thank you i\u0027ma let bombshell we\u0027ll move on to the next presentation so we don\u0027t take any more of the working groups type oh great thanks Scott burly work at JPL the slides here I\u0027m heavily indebted to Kapali vana thong for putting the slides together we\u0027ve been working very closely on this for the last Oh going on a year now and they\u0027ve been very good interchange of ideas and I think the document is a lot stronger as a result next slide have you touched uh unfortunately something was touched okay I will try to go through this very quickly the deal here is that public infrastructure is arguably an important function for delay-tolerant networking but in DTN we cannot rely on the ability to do on demand or interactive communication so the existing public key infrastructure mechanisms are not really usable so we needed something new that was DTN friendly for distribution of public keys and key verification next slide here again this and I won\u0027t go into detail this is a general picture of the overall structure the idea is that there is a an aggregate key Authority that comprises multiple key agents the multiple key agents reach consensus among themselves about key information that public key information assertions and revocations that should be distributed to the network they periodically reach that that consensus and then issue bulletins the reaching of census among the the key agents needs to happen in a timely fashion so typically you expect it to happen to look for example the internet some non release notionally non delay and disruption afflicted network so that consensus can be reached in a timely way and then that once that consensus bulletin has been agreed upon the bulletin is chopped up "
  },
  {
    "startTime": "01:42:54",
    "text": "into pieces each of the members of the aggregate key Authority is responsible for sending some subset of those pieces the pieces that are that are sent out by each of the individual members of the aggregate Authority are are multicast two entities that need that key information here shown as DTK key users so the DK key owner who generates a public/private key pair retains the private key locally and never discloses it to anybody and then sends that the public key to the members of the aggregate key Authority the key Authority members collect that stuff over time reach of agreement on what they\u0027re going to send out sent in and want to cast it out to the key users there was configuration involved in doing this that is the other keys of the key agents have to be known to all of the the key entities and the DTA key owners end users so that the transmission of data to and from the key authority can be authenticated and there\u0027s a new thing called trust model number configuration which I\u0027ll come to in a minute this is new in this version next slide this is a general picture of what I was just talking about the authentication of a bulletin the key owner that generates the the new public key public/private key pair transmits that it\u0027s its own ID and the key to the members of the key authority and the authority then since the bundle off to the key users the bulletin rather off to the key users next slide there was some feedback from the original presentation of this material and at the last IETF there are three items in particular first what happens if some bulletins are missed by key users how would they know and how would they recover from that failure in theory this is this shouldn\u0027t happen very often because the pieces of the bulletin are sent there\u0027s some redundancy in that multiple key agents will send some of the same pieces and the bulletin poll is a racial coded so that there\u0027s a there are parity blocks going out as well as to minimize the chance that that nobody did anybody will lose a bulletin completely but it\u0027s still possible and so how do you recover from that the second item of feedback was the the question about using different trust models for accepting keys and revoking keys that is could a different population of key agents be responsible for for revoking keys different from the "
  },
  {
    "startTime": "01:45:55",
    "text": "the population that\u0027s responsible for accepting them and third item feedback was whether or not the the consensus mechanism for reaching consensus among the key agents needed to be documented in the draft next slide so responding to the first of those feedback items yet great idea so there\u0027s a there\u0027s in the new bulletin structure there is a new field the bulletin serial number the idea is that each the key Authority you know I would get would issued bulletins serially and they would be numbers attached to those bulletins saying which bulletin there was it not another radical idea mister and it\u0027s not something I miss it\u0027s not a monotonous ly increasing numbers I monotonically increasing number it may be monotonous also the the receivers would store the the bundles serial numbers of the bundles that were received and so you could as a receiver you could when we receive a bundle when you recover a bundle from a bunch of bundle sorry when you recover a bulletin from a bunch of bulletins segments you could say oh here\u0027s bulletins so and so but I what happened to bulletins so-and-so - one I don\u0027t have it and there\u0027s a mechanism defined in the new draft for requesting that key agents we transmit bulletins that are not received this would be a an ad hoc and and we hope rarely used facility because it is conversational it would take conceivably some time it could take a week for this kind of recovery to happen and so there\u0027s there\u0027s a always the possibility of error conditions and we hope to minimize this with heavy encoding of and and and we\u0027re done transmission of the segments of bulletins but just in case none of that works this is how you recover next slide multiple trust models there\u0027s a new field in the buildin called the trust model number and what that amounts to is a different let\u0027s say we were say this the key users and key owners know and have to know in advance the public keys of the key agents that make up the aggregate key Authority all this does is say oh there might be multiple sets of key agents that is you know in effect multiple key authorities nominally under "
  },
  {
    "startTime": "01:48:55",
    "text": "the same actual management authority that would be responsible for four different operations on the network an example of that would be you might have a different functionally different key Authority a different set of key agents for key revocation then the set there will be engaged in key assertion and but the mechanism is general you might use this mechanism have different trust models for fre of other reasons to be determined and there again this these definitions have to be load loaded into each DTK anti entity during bootstrapping it ultimately will be necessary to modify those things after operations begins stone or understory as a warning you\u0027re eating into your little percent okay site because we\u0027re very tired yes okay so I almost and there needs to be a protocol defined for that we haven\u0027t done that yet and whether it needs to be part of this specification or not we need to just discuss where this is still not the final draft I think next file we talked it over and decided that the consensus mechanism was an implementation detail that we shouldn\u0027t try to define in this specification because it doesn\u0027t really affect interoperable between the key authorities and the key users and this would be a thing we can discuss but I think I think it simplifies the specification in a useful way to leave it out of the draft next slide oh oh and one more update is adding an additional message type to distinguish between assertions that are that are authenticated by an out-of-band mechanisms such as a direct connection or intervention of a human operator and and assertions that are authenticated by being asserted by a node that already has has a known public key you could be a could be when you were all over your Yorkie you do that yourself when you\u0027re starting up maybe a the node that created you is already trusted in it asserts your initial key on your behalf next slide that\u0027s a quick question are you asking for working group adoption with this no not yet I even talked this over but I think we\u0027re we were interested in feedback from the working group I think there may be a couple more things as well as we\u0027re going through here that "
  },
  {
    "startTime": "01:51:56",
    "text": "that we still need to add so I think it\u0027s premature but I think with any luck we will ask for a working group adoption at the Montreal no less individual who is generating the Belton is generating the Bolton the bulletin oh the bulletin is bulletin is generated by the aggregate key Authority which is the cooperation among all the key agents so the key Authority is multiple agents and you\u0027re who is going to decide the new serial number then if they are multiple agents where they could be out of sync or this is this is why the key agents themselves the the members of the aggregate key Authority need to be on a network that is essentially non delay-tolerant they that that that consensus mechanism needs to happen in a timely way and that and part of that consensus mechanism would be coordination of the of the bulletin numbers so they would need to have kind of a mechanism where the okay ie I need another number you the others agree and that all kind of stuff so the in what I imagine works is that the the the key Authority in in aggregate generates a bulletin say once a day and and so once a day at a at a given time they\u0027re all going to exchange messages contributing to the development of the bulletin at the end of the day they\u0027re gonna say well okay here\u0027s the one here\u0027s his bulletin number of 613 because it\u0027s the 600 13th time we\u0027ve done this because they\u0027ve they\u0027ve reached consensus on the content it should be straightforward for them to reach consensus on on what day it is looks fragile fragile to me but sorry looks fragile to me I think it\u0027s okay the the recent consensus on the bulletin itself and the hash on the bulletin which actually identifies the bulletin we already have implementation so it\u0027s it\u0027s a doable thing and I think adding the the number I mean in the the hash almost functions as the number except that it\u0027s not sequential and and and the and having an additional sequential number should not be challenging the skull I\u0027m "
  },
  {
    "startTime": "01:54:58",
    "text": "looking through the agenda of the mobo I didn\u0027t have any slides feel no the slides for for what\u0027s the last night and you said you wanted to say something about bundle and bundle encapsulation and custody transfer oh and I think the only thing to say there is is is to ask if there are any questions on it and if there need to be any discussion I don\u0027t have any new material I might be wasn\u0027t honest yeah yeah we can if they\u0027re worse if there were time today and if there were questions would be good opportunity to talk about it but I know there is but one last thing I\u0027m squeezing is Phoenix was at the hackathon who managed to get a python-based VP piss working do you want to say a couple quick words just or we can just say well done thank you for doing it yeah so I mean I would have some small demo so if one of you wants to see it at the end I can show it to you so but what we actually did at the hackathon was yeah so I met with some guys from experts which is a Slovak IT company and we just wanted to check whether the PPP\u0027s implementation inside micro PCN which I\u0027m a developer of meets the current draft version of EVPs and so we developed an alternative ppb\u0027s implementation in Python as a proof of concept and yeah as a result of the hackathon we have communicated successfully with micro PCM we build a small REST API to push some contact lens and Bala\u0027s to micro PCN and we also built a test setup which is reproducible through docker containers and yeah and the course of the hackathon also micro PCN on the EPI implementation was updated from the current draft version o6 I think to the current version 10 and we switched somewhat easy CL implementation which was inside Micro PC and the default to the TC PCL although still version 3 in that case so yeah I think it was pretty successful it was fun to work with the guys from ex works and we have found no additional issues in the PPP\u0027s draft so yeah I think it\u0027s ready to become standard hell thank you very much very useful any other business does anyone else how many comments anything we have three minutes left so well done everyone for keeping things "
  },
  {
    "startTime": "01:57:59",
    "text": "short to the point I I hope you don\u0027t mind going through that TCP CL thing it\u0027s something I pushed for because I think we\u0027ve made some progress and got some consensus there otherwise yeah thank you for coming and speech on the list comments please blue sheets of people down below she\u0027s shittin you\u0027d applause we got blue sheets we got everything yeah put it thanks guys yes well maybe in Montreal will will remove yet another thing minsu the protocol suite "
  }
]