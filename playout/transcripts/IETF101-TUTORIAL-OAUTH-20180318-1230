[
  {
    "startTime": "00:00:04",
    "text": "I\u0027d like to welcome you I\u0027m Karen O\u0027Donoghue I\u0027m with the education team here at the IETF and so I\u0027ve got two purposes here the first one is to introduce our topic and speaker today and the second one is to solicit your input and comments on tutorials that you would find useful in the future and even better volunteers to provide those tutorials we\u0027re working to improve our education program and we\u0027re really looking for feedback on that and so we\u0027d really appreciate that so without any four oh and the other thing is I\u0027m not positive that the current version of the slides that are uploaded has the tutorial the survey link in it but there will be a version uploaded later today that will have the survey link in it and so you can look at the slides and then click on the survey link and provide brief survey feedback alternatively you could also email to the edge of team and that will do it as well so without any further ado we have today Justin Risher who\u0027s going to talk about OAuth 2.0 I think he is definitely a long history in this space and I\u0027m not sure that he really needs much introduction he is also has a long history in the IETF and we deeply appreciate his efforts thank you all right thanks Karen all right I\u0027m a little bit taller than Karen so here we go hi everybody and good afternoon my name is Justin richer I\u0027m an independent consultant working out of Boston you are looking at the entire company of bespoke engineering so hello everybody I\u0027ve done a lot of work with OAuth over the last bunch of years here and this is you know for IETF 101 this is kind of an OAuth 101 class there\u0027s a math joke and there somewhere but anyway I have done this course a bunch of different times this is a distilled version of a two-day class that I often come in and give to companies so I\u0027ll basically sit down with an engineering team for a couple of days there\u0027s a lot of hands-on exercises and stuff like that we obviously don\u0027t have that much time to get into a super ton of depth here in the next hour because like I said it\u0027s a two-day like a full 2-day class but there\u0027s a lot that we can cover that\u0027ll hopefully give you guys a good grounding you know in and around ooofff itself and kind of you know what it is and how it how it works and all that kind of stuff and if you are interested in in going really in-depth some some guy wrote a book about this so I Antonio sansa and myself published this with Manning press last year the code for all of the exercises is open source as is the case with all of the exercises for that longer version of today\u0027s class that I mentioned and if you stick around to the end of class my publisher has given me a discount code on this so you can get 39% off yeah it\u0027s a weird arbitrary value so you get 39% off if you go through the publisher that\u0027s for both the e-book and the the printed book so if you\u0027re interested in "
  },
  {
    "startTime": "00:03:04",
    "text": "that come grabbing after the class all right so what is oh oh off - I\u0027m assuming that a lot of you guys have probably heard of it I know it\u0027s gonna be brand new to some of you guys like Brian I know you\u0027re really new to this space so you know pay attention so I want to get a couple of answers of what do you think Oh auth - is and if we could at all possibly use the mic and we\u0027re gonna try and do this part quick so who has who can give me an idea a quick definition of what OA - is they\u0027re actually just shout it out and I\u0027ll repeat it nobody has any idea what I love too is it\u0027s a great place to start yes a third-party authentication mechanism alright anything else all right so a lot of people look at oo often they\u0027ll say ok it\u0027s you know it\u0027s an authentication protocol or it\u0027s an authorization protocol or it\u0027s some security thing that lets me log into Facebook but I don\u0027t really know what it is I just know that I see it all over the place and so from the specification this is what Oh auth - is everybody got that well these are the important parts you know as we all know this is the IETF we take a lot of words to say something very simple but do so very specifically so the real important thing here is that it\u0027s something that allows a third-party application to get limited access to some kind of service on behalf of somebody who we call the resource owner in other words Oh aww this\u0027 fundamentally not really an authorization or authentication protocol it is a delegation protocol Oh auth is all about delegating a right of access that lets you allow a piece of software allow an application to access something on your behalf so fundamentally that is the design and goal of OAuth it\u0027s not about authentication it\u0027s not about authorization it\u0027s about delegating a right of security Authority and that fundamental understanding will help you see kind of where our fits in the entire sort of large stack of security protocols out there in in kind of the wider world so these are the different players that we have involved and I realize the text is kind of small on that slide unfortunately it does get shrink down but you\u0027ve got access to the PDFs if you want to see these and I\u0027ll point these out as well we\u0027ve got a resource owner an authorization server a client and a protected resource now all of these words mean things in the real world but they mean something very specific in the OAuth space so the resource owner is an entity usually a person but not always a person it could be sort of a logical entity but usually we\u0027re gonna say it\u0027s a person that they have access to some resources a P I now that could be a resource that\u0027s about them and often it "
  },
  {
    "startTime": "00:06:05",
    "text": "is so this is like my account information my time line my photos whatever kind of example you want to do or it could just be something that I just have access to you know say I\u0027m working in HR and I have access to everybody\u0027s time card information that\u0027s a resource that I have access to even though it\u0027s not necessarily about me specifically but importantly what makes this a resource owner in the OAuth world it\u0027s not just that they have access to it but that they can delegate that access so this is the entity who has the right to say not only this is something that I do but this is something that I am going to allow somebody else to do as well and in general like I said they\u0027re a person with access to a web browser and for simplification purposes to start out we\u0027re going to assume that that is always the case we\u0027ll go into the exceptions for that later on now the protected resource is an API now this can be any flavor of API that you want really authors written around HTTP but pretty much beyond that it\u0027s kind of it\u0027s kind of up to you this can be restful this can be soapy this can be any new kind of thing that hasn\u0027t been invented I guess the kids are doing Graff api\u0027s these days it really doesn\u0027t care as long as it\u0027s an HTTP kind of resource you can throw off at it and it works pretty well the important thing is not only does this protect things for the resource owner but it shares things when the resource owner says to do so now the term that really trips a lot of people up is client because if you\u0027re coming from any type of web programming you\u0027re probably thinking the client is the browser it\u0027s not and you might also be thinking that the client is the HTTP client which kind of is but it also kind of isn\u0027t because an OAuth HTTP client could actually be a sorry an OAuth client could in fact be and canonically usually is an HTTP web server so in the OAuth world when we say client what we really mean is whatever piece of software is calling that API that protected resource that we were just looking at the client is whatever application is consuming that API now that doesn\u0027t necessarily mean that they\u0027re like downloading information they could be purely pushing information into the API but they are still the client of the API and for OAuth purposes it\u0027s whatever piece of software is calling that API that\u0027s what we call the client all right so whenever I say client here that\u0027s what I\u0027m referring to not necessarily web browsers not necessarily HTTP you know transaction clients we\u0027re the client of the API alright this is fundamentally the problem that we\u0027re trying to solve like I said it\u0027s a delegation protocol I as a user want this piece of software to go call an API for me now this is a really old problem we\u0027ve seen this a lot over the last twenty thirty something years we\u0027ve been trying to solve this for a very long time there\u0027s a lot of different ways we could do that one of the things that you see a lot especially in enterprise spaces is that okay I\u0027m the client application so I\u0027m gonna have you log in to me and then I\u0027m gonna take whatever you used to log in to me your username and password and I\u0027m gonna go replay those at some "
  },
  {
    "startTime": "00:09:05",
    "text": "API and pretend to be you to go talk to the API this works really great in enterprise spaces obviously there\u0027s kind of a big problem here and there\u0027s a couple of big problems first off the well you\u0027ve got somebody stealing your keys so you\u0027ve got an application that\u0027s impersonating you going off on the other side and when that request yeah that\u0027s useless so when that request comes into the protected resource in a case like this how does that protect a resource know the difference between me logging in directly as a user or a piece of software logging in to do something for me it doesn\u0027t because the only thing in this model that the protected resource can tell is that somebody showed up with the username and password and that maps to a particular account this is fully impersonating me as a user which means that this client application can do anything that is possible on that API for me whether I wanted it to or not there\u0027s nothing that I can do as a user as a resource owner to limit that access and say I want to turn off access for that well pretty much my only option is to change my password right that\u0027s the only thing I can do to stop that application and the thing is if I\u0027m in an enterprise space and using kind of single passwords and you know you\u0027ve got a big active directory that everything\u0027s going through well what\u0027s gonna happen is the next time I log into that application it\u0027s gonna get my new password and it can go call the api\u0027s for me again even though I didn\u0027t ask it to so we\u0027re really stuck with a lot of problems here but it\u0027s it\u0027s functional and it works a lot of space one of the biggest problems with this though is that it doesn\u0027t work if that protected resource and that client don\u0027t speak to the same account so say I\u0027m logging into something over in Google and they want to call something over it Yahoo my passwords not necessarily gonna be the same across those two services you can\u0027t assume that they will be so when you can\u0027t steal the keys just ask for them we see this all the time don\u0027t we you go to even like LinkedIn today it says give me the username and password for your email account and I I\u0027ll be really good and only download your contacts and not do all of the other wonderful things that I can do with that username and password so this is really has a lot of the same drawbacks as before but it does have the benefit of this now works across domain the biggest drawback to this though is that it\u0027s training users to give somebody the password to a service even if it\u0027s not directly related and this can be a bit of a problem you can say right so what this means is that now when a user goes to an attackers website they say oh give me the username and password to your email account and I promise I\u0027ll be really nice and only download your address book they\u0027re gonna be like okay well LinkedIn did it and nothing bad happened and Facebook did it and nothing bad happened so sure I\u0027m gonna go you know type it into here and nothing bad will happen because we\u0027re training users to do exactly the wrong "
  },
  {
    "startTime": "00:12:06",
    "text": "behavior in treating their credentials all right so what if instead of using the users password you have a key that\u0027s good for opening any door that it comes across no matter who\u0027s knocking and this is a pattern we\u0027ve had for a very long time we call this an API key don\u0027t we so the user shows up and they start using this applications I need to go call this API on your behalf but instead of me stealing your password I have a super powerful password that\u0027s just gonna show up and it doesn\u0027t matter which user I\u0027m asking for I can get their information now again this is really functional within a single security domain but again one of the big problems here is that it can go access my information this application could go access information without any input for me without any even action for me I don\u0027t even have to log into this application for it to be able to trigger that it can just go pull all of my stuff whenever it wants to whether I did anything here or not and again this doesn\u0027t really work across security domains so we use this all the time in enterprise spaces even today and a lot of web api\u0027s kind of use this pattern as well but there\u0027s a lot of downsides to it as well it\u0027s also a bit more complicated because now I have to design my API so that you tell me what user you\u0027re asking for and I need to be able to input that and I have to fully trust you to always as the client always do the right thing so let\u0027s combine a couple of different aspects here and instead of a universal key that\u0027s good for everything let\u0027s let\u0027s create a new service specific credential call it a token and for my account as the resource owner I\u0027m going to get a special password made and I\u0027m gonna hand that to the client application so that it can call the protected resource from my behalf so this is no longer my regular password that I used to log in this is a special password just for calling this API and we\u0027ve seen this all over the place and this is really starting to get closer to what we what we want but it has this has some drawbacks too so on the up side the security model of this is great because that token maybe I say this token is only good for read access maybe it\u0027s only good for an hour but it\u0027s oh end the particular resource now knows the difference between me logging in and this client logging in on my behalf because it\u0027s a different credential it can map those two different security models that\u0027s really great the biggest problem here though the usability sucks it\u0027s really awful one of the biggest examples that we had of this in the real world was Google Code anybody here remember Google Code so Google Code and I\u0027m dating myself a little bit but there\u0027s a lot of great beards in the room so I\u0027m okay and Google Code was a subversion hosting service they later added get when that was the cool thing but in order to access your subversion repository from your subversion client instead of entering your Google account password you had to go to a special page and it was about three menu layers deep and generate a service specific password for "
  },
  {
    "startTime": "00:15:08",
    "text": "your subversion access on Google code and then copy and paste that into your subversion client instead of your normal Google password and again the security model of this is great because you know now you have something that is very specifically for subversion you can rotate your Google password in this one then this other one independently really really kind of good stuff this is only good for subversion they can\u0027t go download your Gmail or anything else like that really awesome security profiles but the problem is developers still screwed this up all the time now our developers this is people like us like the Nerds of the Nerds are still screwing up the usability of this because it\u0027s too complicated and technical that should tell you something about how usable this is would be for an average user because I hate to break it to you but we are not average users we need to remember that when we\u0027re designing these systems so we\u0027re getting closer here and really what I think the answer here is that we take the thing with the good security practices and we automate it we automate it we improve the usability and we sort of make that part better so we\u0027re gonna do that with a little protocol called OAuth and in OAuth you\u0027ve got this component called the authorization server now this is added into the mix we\u0027ve still got the resource owner client and protected resource just like before but we\u0027ve now got the authorization server to kind of bridge the gap between all of those and manage this connection this generates those tokens those service specific credentials that I talked about before like this is a special password for this piece of software to call this API that\u0027s generated and managed by the authorization server this is also where the user locks in where they say yes this software can go do this thing and it manages all of those authorizations which means this can also turn them off or say this is only good for reading and this is good for reading and writing or you know whatever other things you need in your API design all of that is represented all of those rights are represented in this thing called the OAuth token specifically the OAuth access token this is a representation of that triangle of entities so from the resource owner to the client for the protected resource all of that gets bundled up into the token and it\u0027s used by the clients and so it gets issued by the clients but the format\u0027s actually opaque to the clients so all of these are perfectly valid OAuth tokens I get a lot of questions from new developers like what does it auto can look like it\u0027s kind of whatever you want really so I mean the first one here is just a hex blob second one is a type four UUID so that\u0027s 112 bits of entropy if you got a good random number generator third one does anybody recognize what that third one is that is a specific format just yell it out it is basics before you\u0027re correct but "
  },
  {
    "startTime": "00:18:08",
    "text": "beyond that it is a JWT a JSON web token will get we might get more into that later if we\u0027ve got time so what this is is this is a structured format that is basic ste for URL encoded JSON with a signature applied to it in a sort of semi-detached mechanism that\u0027s the hos a suite of specifications and that\u0027s another tutorial and the last one here is a high entropy wordless choice so there\u0027s four random words I think that\u0027s like 160 something bits of entropy something on that I\u0027d forget the funny thing about this is that these are generally secrets like this are generally meant to be human memorise Abul and in OAuth token really isn\u0027t people never really see the token so why would you ever use something like that because you can ooofff really doesn\u0027t care how off does not care what the token looks like all right so whoops forgot to check ahead on my slides now I have a question who here has used OAuth raised just raise your hand all right most of the hands went up so who here has ever used a facebook application or logged into a site with Facebook who here\u0027s ever logged into anything with Google who here has ever used Spotify yeah Spotify applications who here\u0027s ever used steam for gaming okay who here has a smartphone well guess what you\u0027ve used OAuth it is literally everywhere Oh off to is everywhere on the web these days and like a good security protocol you usually don\u0027t see it because most of the time it\u0027s just sitting in the background and doing its job but if you\u0027ve ever been turning on a new application or connecting you know a native app to a to an account or something like that and you\u0027ve seen something like this this type of approval screen that says hey there\u0027s the thing that to go do stuff chances are you\u0027re using OAuth and if you\u0027re not using OAuth you\u0027re probably using something that should be running OAuth but thinks they\u0027re cleverer than the ITF and probably has some big security holes which has an independent consultant if you find one of those call me because that\u0027s fun work all right now a brief history of OAuth 2 now back in 2006 everybody was using passwords to get to API HTTP basic right if anybody hears from the HTTP auth I\u0027m sorry I\u0027m gonna say how bad eh to be basic is though you probably already know that so the whole idea behind h-2b basic was that you know hey we\u0027ve got this great web protocol we need some way to authenticate it let\u0027s use usernames and passwords because we use that for everything else awesome problem here is that that allows for and it really kind of encourages this kind of impersonation setup like we were talking about before and so it was really all about the you know you give me your password I promise "
  },
  {
    "startTime": "00:21:08",
    "text": "I\u0027ll be nice and I will go call that API for you and a couple of Internet companies came up with proprietary solutions for delegated access we had dbo thoughts of and a handful of others and and also remember back 2006 was 12 years ago but remember what the internet looked like back then myspace was the top site the iPhone wasn\u0027t out yet or it sort of came out but the App Store wasn\u0027t there yet so imagine a smartphone with no apps it\u0027s really weird to think of that right Android was still a couple years off it was the internet was a really kind of different place 12 years ago and so back then we had a couple of small sites one was Magnolia a start-up which has since evaporated the other was this little social messaging platform called Twitter or something like that I think they\u0027re still around they got together and they\u0027re like hey we\u0027ve got a cool thing you\u0027ve got a cool thing we want to plug our cool things together problem is that they were both looking at using open ID for login now open ID is a federated identity protocol not the topic of today\u0027s conversation but means that there is no user name/password so to get to the Magnolia API there was no user name and password that you could present and by their very design federated identity protocols don\u0027t allow you to replay them that\u0027s a really good security benefit so neither of them wanted to really build up their own additional proprietary protocol so they thought you know what we\u0027re gonna get together we\u0027re gonna talk to a bunch of interested people and we\u0027re going to create a standard that a bunch of us can use and that was oauth 1.0 no formal standards body just a bunch of smart nerds in a back room a toss conn came up with this document published it out on the web and said hey here\u0027s the thing and that\u0027s what usually happens when a bunch of smart nerds get together in a back room they publish it and almost immediately a session fixation attack was found in the baked into the protocol and the inscrutably named Olaf 100a was released right after that thing is though this actually worked pretty well and pretty soon a lot of people started to use it and people decided you know what we\u0027re going to kind of get this together clean up the language a little bit and it did get published here in the ITF as RFC 58 49 so people start using this thing it solves a problem it solves a very real problem back in 2006 2008 this time frame the sort of API economy restful design of API is all this other stuff was really starting to come online mobile apps we\u0027re starting to maybe look like they might be a thing and so this solved a very real problem that people had in a way that was you know elegant and fairly usable for most cases so much so that in something that usually doesn\u0027t happen and as I\u0027m now I\u0027m speaking to a standards group you guys know this the big players who already had their proprietary solutions said you "
  },
  {
    "startTime": "00:24:09",
    "text": "know what we don\u0027t want to invest in our proprietary solution anymore we\u0027re just going to use this standard that a bunch of smart nerds came up with instead so Google and Yahoo and all of these other big players and eventually you know Facebook and all this alongside Twitter and others decided you know what we are going to use this ooofff standard instead of our own authorization and delegation protocols and that\u0027s actually a really cool thing and it\u0027s something that I think as a community in the IETF we need to study more how that happened because that doesn\u0027t happen nearly often enough usually the open standard gets put on the shelf right next to all of the proprietary standards that everybody else needs to support so anyway people start using it and they start using it for all kinds of off-label fun stuff like native applications that started to become a thing it didn\u0027t start out as a thing when a auth was originally invented suddenly people had like applications on their phones and Google came up with some really interesting ways to deal with this in the OAuth wanto world don\u0027t have time to get into the details right now ping me after if you\u0027re if you want the details people started to use this as delegation when there was no user in the loop which doesn\u0027t make sense because it\u0027s a delegation protocol but people realize that well I\u0027m I can delegate rights to non person users and entities and stuff like that so I want to use this to be able to replace API keys that way my user facing API is and mine on user facing API is use the same structure it\u0027s a lot of value to that from an architecture perspective so they started to use OAuth in ways that it was never intended and I walk made a lot of assumptions about you know key placement and wealth one made a lot of assumptions about key placement so you ended up with people distributing it in ways that it was never meant to so that brings us to version 2.0 and like with any second version of the system it\u0027s no longer a protocol it\u0027s now a framework because that\u0027s what we do is nerds right but in all honesty it was chopped up in a very deliberate way so Olaf 1.0 tried to solve all problems for all use cases all in one go o auth 2.0 said you know what we\u0027re gonna look at how people are really using it and focus on those specific problems and we\u0027re gonna come up with patterns that you reuse all of these components in this in you know slightly different ways so that we can actually pull this stuff together removed a lot of the pain points like a proprietary signing mechanism whatnot and that got standardized in RFC 67 49 and 67 50 already it\u0027s two documents instead of one you can see it\u0027s starting to be modularized more so what this means is that ooofff two is not really a single protocol you can have two implementations of auth - that don\u0027t talk to each other because they\u0027re using different parts of the protocol framework but you get a ton of code reuse you get a ton of pattern reuse so you get a ton of really powerful stuff from an architecture and engineering standpoint that when you go to solve your one problem that uses one part of it well now there\u0027s these other use cases that you might be able to pull in for very small Delta\u0027s and it\u0027s kind of a set of standards that works across all of these different use cases instead of one standard that doesn\u0027t really fit anything quite that well so very briefly "
  },
  {
    "startTime": "00:27:12",
    "text": "o auth is not defined outside of HTTP although the Khitan working group came up with a gssapi extension that allows you to do it over lots of non HTTP protocols the ACE working group is working on a way to do OAuth over co-op it coop rather it is not both it is Oscar they renamed it do you guys remember okay I left a bug Francesco about this but there\u0027s a version of OAuth that runs over co-op for co-op and core for sort of embedded devices kind of stuff and to the previous point about what Oh auth is it is not an authentication protocol it is very definitively not an authentication protocol it relies on authentication so the user has to authenticate so that that authorization server knows who everybody is and whatnot the client authenticates so there\u0027s authentication all through it but authentication is all about communicating who the user is and why they\u0027re there and how sure are you of all of this kind of stuff well it doesn\u0027t do any of that it doesn\u0027t communicate any of that it very explicitly stays out of that however ooofff gets used to build authentication protocols such as open ID connect which is built on top of OAuth and so people using Open ID Connect think they\u0027re just using OAuth where in fact they\u0027re using OAuth plus a couple of key components that makes it into an authentication protocol excuse me our authors about user software delegation not user to user delegation if you want that you need to add a few more components the there\u0027s one standard out there user manage to access or uma that allows you to do that again built on top of OAuth or auth doesn\u0027t give you authorization processing this really isn\u0027t like sam\u0027l sorry not sandals a camel it\u0027s also not like sam\u0027l in that there\u0027s not a way to describe oh when you get this here\u0027s how you process it and here\u0027s these rules to apply and stuff like that no authors really just about carrying that handle from one end to the other and what you do with that handle ooofff doesn\u0027t care what you do with that token in order to interpret it ooofff really doesn\u0027t care there are lots of standard methods defined and how you do that but those really aren\u0027t a lot they\u0027re added on to oauth like you said before o auth doesn\u0027t have a token format but it needs to have a format that both the authorization server and protected resources can make sense of even if it\u0027s opaque to the client it\u0027s not necessarily opaque to everybody in the system so there are token formats JSON web token or John is one of the most popular ones out there and it\u0027s a useful common format and OAuth doesn\u0027t define its own cryptographic methods ooofff 1.0 did there was this fairly complex custom signature algorithm that got applied across all of the different HTTP query parameters and stuff like that Oh auth - you said you know what that\u0027s the part that people are getting wrong and ignoring most of the time and it also made people believe that they didn\u0027t need TLS across their HTTP connections which is of course idiotic so in order to avoid all of that o auth you said you know what we\u0027re not getting into the signature game at least in the base protocol so use TLS for everything "
  },
  {
    "startTime": "00:30:12",
    "text": "and go from there and like we said before it\u0027s not a single protocol I\u0027m not gonna reiterate that all right deep breath we\u0027re halfway through how\u0027s everybody doing good all right everybody checking your email awesome now I\u0027ve been to these tutorials I know how it works and so we are now going to dive deep into the canonical flow of OAuth 2.0 this is the authorization code flow these are all the pieces and this is what it looks like alright everybody got that awesome before we get into the details of what that diagram looks like you need to understand that makes use of two different kinds of communication it is an HTTP based protocol so first off we have the back-channel this is just straight up HTTP calls you make an HTTP request getting HTTP response that means that we\u0027ve got headers we\u0027ve got the body content we\u0027ve got you know different URI parameters and stuff like that different HTTP verbs that we can use really really rich messaging system and it\u0027s directly between two components so between the client and the auth server the client and the protected resource this is where we\u0027re gonna stuff sort of like the really secret things that we care about like those tokens that we were talking about before this is where they like to live in the back channel talking directly between components the front channel on the other hand is what we do when we get a user involved because notice in this back channel when the client is talking to the HB resource sorry - the authorization server over HTTP the client is gonna say like oh I\u0027m here on behalf of this user and the authorization server well how does it know that the user is even involved in that process used to be we knew because the user gave their password to the client or presumably gave their password to the call to the client those were scare quotes - anybody only listening to the audio audio stream and in that case the clients really just impersonating the user so you know off what we do is we use the front channel we use somebody sitting in a web browser to interact with the authorization server but the thing is we\u0027re no longer talking directly between components so how can we send messages here well a front channel requesting response is actually a stack of HTTP requests and responses what it means is that in order for the client to send a message to the authorization server through the front channel it sends a redirect to the users browser to a very specific URL that URL is hosted at the authorization server and it\u0027s got a bunch of query parameters on it that are set by the client now that redirect goes to the browser and then the browser not the client makes the HTTP request back to the authorization server that means we now have an HTTP channel between the resource owner and the authorization server the client is not part of that which means that the resource owner they can now authenticate we can do you know all sorts of session mapping and heuristic evaluation of security and all of that other good stuff that we like to do on interactive HTTP sessions without "
  },
  {
    "startTime": "00:33:15",
    "text": "involving the client directly so none of that leads to the client that\u0027s all really great it also means that now that we are between the browser and the authorization server we can do multiple requests you know we can redirect internally we can go to off to other sites and then come back and all this other stuff now how does the authorization server get any messages from the client in this if they\u0027re coming from the browser well that URL that the client redirected us to has a bunch of query parameters on it that have values on those query parameters that are then received and interpreted by the authorization server so you\u0027re not just going to a fixed URL you\u0027re going to a URL with a bunch of parameters that say you know I am this client this is the kind of stuff that I max asking for then to get information back to the client we do the same process but only in Reverse the authorization server sends a redirect to the browser that says go load this URL what that you redirect looks like varies depending on the kind of client in the canonical case where we\u0027re talking about we\u0027ve got two websites that are talking to each other well that\u0027s going to be just an HTTP URL that has a bunch of query parameters on it that are act as the response to that front channel request all right we do this in order to separate the information we use the front channel when the users involved in the back channel as much as possible wherever the users not directly involved the front channel is going through a third component it\u0027s going through the browser we can\u0027t always trust it to do to make sure that messages always get through exactly how we want to because they can be sort of you know snooped and modified that is assumed in the OAuth protocol and there are protections in the OAuth protocol to mitigate that type of stuff but we use the back channel for all the secret things as much as we can so now we\u0027re gonna go step by step through that crazy diagram alright first off user shows up the client and says I want you to use that protected resource and the client says I can\u0027t do that I need you to go get me permission before I can go do that right whereas in the past the client would just say great give me your password and I promise I\u0027ll be nice now the client says all right go talk to this other server and they\u0027ll come up with something that can that I can use so just just go over there do what they say and come back so we send an HTTP front channel responds we send a redirect to the browser and then the user goes and talks to the auth server now at this point the user can authenticate to the auth server whereas previously we were stuck with credentials that had to be copyable like passwords we can now do multi-factor authentication we can do you know massive risk based engines like most of the large internet providers do today you know you can do pretty much whatever you want between the user and the off server and it\u0027s a very rich channel of communication because it\u0027s the web right so the user authenticates so the all server now knows who the user "
  },
  {
    "startTime": "00:36:15",
    "text": "is and they all server knows who the client claims to be because of those query parameters that were in that redirect so we can now say like ok so it looks like this client is asking to do these things is that ok with you now back when we were just asking for for somebody\u0027s password or just stealing their password on the way through we didn\u0027t have any way to ask the user if this is what they are trying to do we now have a place where we can ask the user the resource owner is this your intent are you actually trying to get this client to go talk to this resource server you know do you really want to log into farmville with your Facebook account is that what you meant to do today and it seems funny to give that kind of control to an end user especially to a lot of security architects but think about it in terms of KU is in the best position to know what they are trying to do it\u0027s the user they know what they\u0027re trying to accomplish they may not know what they\u0027re really doing but they know what they\u0027re trying to accomplish so this is an area of active research of how to best communicate this decision and gather this consent and a lot of work that I do is kind of in this space I could rant about that for several hours I won\u0027t but ping me after if if you want that point here is that we can ask the user did you mean to do this do you approve if you do approve you send back this thing called the authorization code now that authorization code is a temporary retention drawn here\u0027s a little paper carnival ticket that gets sent back to the client how does it get sent back through a redirect through the front channel just like we were talking about before it\u0027s query parameter through the browser the browser makes a request to the client and that gets sent back there so now the client has everything that it needs to go talk to the authorization server and get the real credential that paper ticket really isn\u0027t good for accessing the protected resource it\u0027s not meant for that what it\u0027s meant for is the client to then turn around and then talk directly to the authorization server in the back channel at this point though the client can now authenticate itself it can now prove that yes I am the piece of software that was making that original request and there are a few different ways to pull this off that way the authorization server can say like oh yeah this is who I told the user it was who was trying to access their stuff you prove that you are you know the same entity that made that request we\u0027re good to go I\u0027m going to give you a token an access token that access token can then be used to call the protected resource by the client and you notice that you know once the user said everything was ok they kind of got out of the process because remember the ultimate goal is getting the client some something so that it can do things on behalf of the user the users no longer on the HTTP transactions they\u0027re no longer really directly involved once the user says yes this is OK we\u0027re good with them in a nutshell that\u0027s how OAuth works it\u0027s about delegating that access and going through this so that you get that "
  },
  {
    "startTime": "00:39:15",
    "text": "token to the client so that it can call the protected resource now there are a bunch of things that have been added to OAuth or sort of built into OAuth that allow this to work in less than idealized situations that we call the real world and one of those is this concept called a refresh token so far we\u0027ve been talking about a thing called an access token access tokens once the users said ok they keep working the user can log off of the client they can wander away they can get eaten by an alligator doesn\u0027t matter ooofff doesn\u0027t care what our cares about is that that access token is still good so the clients going to keep using that access token as long as it\u0027s good and this is a key design point so auth is designed to work when the user isn\u0027t there and it\u0027s also designed to deal with the situation like well when does that access tokens tokens stop working maybe it expires maybe the user wasn\u0027t eaten by an alligator but they logged into the authorization server and said you know what I don\u0027t like that app accessing my stuff anymore I want to revoke access to that so that access tokens gonna stop working so what does the client do then well if you did Oh off to get a token in the first place you can just do oo off again to get token again you always have that option so the failure mode of ooofff is more OAuth which is a deliberate design decision because if you think about the arity of different components in in an OAuth ecosystem you\u0027re probably gonna have one authorization server a handful of protected resources and a whole bunch of clients whose main job is not to do security security is the thing that they have to do in order to call the API and do the stuff that they really want to do so with OAuth 2 we made deliberate design decisions to allow the clients to be as dumb as possible one of the best ways to do this is to not have complex if-then-else code paths for error handling if you get into this place like you always assume that your token might not work and if your token doesn\u0027t work ok maybe go try to get a new token which is great if your users still there but if you use your has in fact wandered off you can\u0027t ask them right away and you can\u0027t call that API again what do you do then well there\u0027s a construct called a refresh token and what that means is that the Refresh token is something that you get alongside the access token it\u0027s not good for calling api\u0027s it\u0027s not good for getting you know getting the data to the client what it is good for is saying that I have proof that the user said that it was ok to use this API but my access token isn\u0027t good anymore so give me a new access token so that I can keep calling the API without bugging the user this way your access token can live for maybe a couple minutes so it\u0027s just kind of sitting out on the wire for a few minutes app goes to sleep whatever it\u0027s not "
  },
  {
    "startTime": "00:42:15",
    "text": "calling the API anymore access token times out app wakes up you know couple days later and says I need to go refresh that API access token isn\u0027t good anymore but I have a refresh token I have a refresh token that allows me to go and get a new access token and that refresh token basically says hey you know the user said this was okay unlike the access token which is a bearer credential at least in its most basic format refresh token is not refresh token has to be presented alongside the clients credentials just like that authorization code we saw before and it\u0027s only presented in the back-channel it only ever lives between the client and the authorization server so protected resources never see this alright refresh token is a really simple concept but it\u0027s really really powerful because it allows you to really dial in the risk between all of these different credentials getting stolen all right another concept that\u0027s built into OAuth is what I\u0027m calling the safety I maybe I don\u0027t want my API to be all or nothing so back in the day when it was just username and password if I had the username and password I could do anything I wanted to on the API because it was the whole API it was on or off but now that I\u0027ve got this delegated token I can probably do a better job at splitting that up so we use the concept in OAuth of a scope of that token now the scope of the token is used to represent a lot of different concepts most commonly it\u0027s the type of thing you\u0027re allowed to do am I allowed to read this API am I allowed to write to this API you know what kinds of things also you often see the kind of thing that you\u0027re allowed to make actions on so am I allowed to get your timeline your profile information the metadata of your attributes versus the attribute values themselves what am I allowed to do and occasionally it also means when you can do this you know can I do this when the users not logged into that main service anymore can I do this only when they\u0027re online can I do this only on Tuesdays at 2:00 p.m. right what are my different options Oh mideco I think our camera fell asleep just FYI so I think Miyako fell over but we\u0027re gonna keep going here in the room until they do that if anybody\u0027s in the chat room can somebody at meet Eko so both scopes are strains they\u0027re just very simple strings that don\u0027t have spaces in them that\u0027s really their base definition what doesn\u0027t say which parts of this you\u0027re allowed to use a scope for it just says it\u0027s a thing that says "
  },
  {
    "startTime": "00:45:17",
    "text": "what the tokens good for and it just gets out of the way which is a good thing because it allows you to design your API in sort of very specific ways and it\u0027s a bad thing because everybody uses scopes in slightly different incompatible ways which can be really frustrating to developers who of course don\u0027t have to call just one API in their day-to-day lives now the resource owner approves the scopes and those get bound into the access token so when the access token shows up the protected resource it can figure out these are the scopes that it\u0027s allowed for and it can make that decision of how to interpret the incoming response yeah I think me that goes still down all right all right so far we have looked at the authorization code flow and kind of the basics of how it works fundamentally it\u0027s the delegation protocol it\u0027s all about a user saying this software can do it in the world that oweth was originally designed for I think we\u0027re waking up yay thank you me deco and in the world that Olaf was originally designed for it was all about you know a web server talking to another web server alright that\u0027s not the world we live in anymore we\u0027ve got in browser applications we\u0027ve got native applications we\u0027ve got apps that never see a user you know things that are just poking around data centers talking to each other it would be really nice to use this security layer that we invented across all of those things and in fact that\u0027s what happened with OAuth 1 which was never intended to solve all of those cases but it was kind of used for that anyway because it almost solved people\u0027s problems and they just kind of hammered it into you know the square peg into the round hole to make it fit with OAuth 2 instead of giving everybody a square peg we gave you a way to make your own custom shaped pegs with a couple of patterns that are fairly common I\u0027m way stretching this metaphor so this canonical use is all about server talking to another server a web server talking to an API those types of systems have particular aspects for example a web server can keep secrets from the users that\u0027s not true with an in-browser application because anything that\u0027s running in your browser you can inspect it it\u0027s not you can\u0027t do that with a remote web server unless they have other problems for a native application similar thing it\u0027s running on your device developers can think that they\u0027ve got it all nice and locked down most of the time you can inspect and do some fun things with that as well and there\u0027s all these different kinds of delegation that we could do right so we\u0027re gonna look at a few different ways that you can use oauth2 beyond the authorization code flow I will say "
  },
  {
    "startTime": "00:48:17",
    "text": "though that if you\u0027re learning if you\u0027re just learning OAuth to start with the authorization code flow for two reasons one it really is the most robust and the most widely used version of OAuth 2 it solves the widest set of different use cases and two and you know and it really should be your default based on that and to everything else that I\u0027m about to talk about here is an optimization of the authorization code flow for different specific purposes and every time you have an optimization you have to make assumptions about what you\u0027re optimizing for all right means you\u0027re making assumptions about the environment that you\u0027re in you\u0027re making assumptions about the clients and the users in the api\u0027s everything that I\u0027m gonna talk about in the next few slides here is gonna really be for specific environments and circumstances and one of the ones that gets misused to the most and so I\u0027m starting with it is the implicit flow the implicit flow is what happens when you shove the client up inside the browser now the authorization code flow goes through a lot of different steps to make sure that things like the client\u0027s credentials and the clients like identity and authorization never leaks to the end-user that the access tokens aren\u0027t exposed to the browser and all of this other stuff but what if your application is running literally inside your browser it\u0027s a JavaScript application that is executing inside the browser at runtime all of that stuff that you\u0027ve done all of those hoops that you\u0027ve just jumped through to make sure all of that stuff is secret from the browser really doesn\u0027t apply anymore because it\u0027s all in the browser it\u0027s all in there and so the implicit flow in order to get the access token is really a front channel only flow so what you can do is you send the user over and instead of coming back with an authorization code that you then go and repost and then get the token you send the user over and they come back directly with an access token and herein lies the trouble because that\u0027s great for an in-browser web application because now now you\u0027re bound by same origin policies and it comes back as the HTTP URL fragment so you know it doesn\u0027t depending on your browser thank you google it usually doesn\u0027t get sent across redirects or posted back to servers or things like that so it supposed to stay nice and inside the browser doesn\u0027t always these days which is fun but if you\u0027re using this the implicit flow in any other kind of application you\u0027re breaking all of the assumptions that that went into it so this is the "
  },
  {
    "startTime": "00:51:18",
    "text": "biggest problem I have with the implicit flow not that not its design in and of itself because for an in-browser app it works pretty well we didn\u0027t have HTTP POST message when this came out these days we\u0027d probably use that instead right but a lot of people see this and they say you know what this is simpler this is easier and I don\u0027t know why I\u0027m doing all these redirects and HTTP calls on this off code and all this other stuff like that I\u0027m just gonna do the implicit flow until something breaks and then then I\u0027ll go figure out what this whole thing is I see this time and time again and this mistake has been at the core of a number of very large-scale attacks including one that that did a lot of damage to espn.com again more details on that after the talk if anybody wants to ping me about it the problem is that that\u0027s the simplicity of the implicit flow comes at the cost of assuming that everything is going to stay right inside this little box those assumptions go completely out the door when you\u0027re using a native application when you\u0027re using a web server based application or really anything else other than something living directly and completely inside the browser and in order to encourage people to use this correctly when we wrote alt we made sure that you can\u0027t get a refresh token here well why not because well if the users there in the browser you can just send the back and go get a new access token because they\u0027re still there but you know a lot of people we\u0027re using will start using the implicit flow in other types of client apps and say well okay my user went away and now I need a refresh token how do I get that so even though we tried to design that into the protocol people it didn\u0027t quite sink in and so I really can\u0027t recommend the implicit flow unless you are very much in this very tight constraint right now the client credentials flow is another fun one because you take the four parties of the author of the authorization code flow except that you kind of take the resource owner and conceptually squish them down into the client the whole idea between that for this is that well I\u0027m really kind of solving the API key use case now at the beginning of the talk we talked about how people use API keys to say like I am here on behalf of this one specific user well that\u0027s not the only way we use API keys sometimes we say API keys are hi I am this client I\u0027m not here on behalf of the user I\u0027m here on behalf of me and so API let me in and let me do my client things here previously those API keys "
  },
  {
    "startTime": "00:54:22",
    "text": "would have to be known by all of the particular resources who would then need to go and validate that yes this is this specific client talking to me and they\u0027re allowed to do this and managing all of that was really kind of complex the client credentials flowing ooofff simplifies that because now the client takes its credential that represents itself and it goes and talks to the authorization server and gets back a plain old access token then he uses that access token to call the protected resource now that client is not going to get again it\u0027s not going to get a refresh token because it can just go get a new token anytime it needs to because it has its own credentials it\u0027s not on behalf of a user so there\u0027s no user to go bother and that access token can then be used for all of these different protected resources but the protected resource never needs to know the clients credentials right I\u0027ve only got like five minutes left so I\u0027m gonna burn through this next up one of my personal favorites the resource owner password flow this is all about stealing the password this is the client saying give me your password and I\u0027ll go call an API and I promise I\u0027ll be nice now hold on a sec we said that this was really bad and it is so don\u0027t use this one but I\u0027m still gonna tell you how to do it so you know not to use it that makes sense which is why we specified it basically when you get the users password instead of calling all of the api\u0027s you call the authorization server and get an access token and then call the protected resources now your protected resources don\u0027t need to know the users password they just need to be able to understand Oh auth access tokens this is really intended for was intended at the time for legacy applications which would then move to the authorization code flow except that what happened is we put it in the standard and everybody said hey that\u0027s easy and let just use that instead forever which was never our intent thank you so that\u0027s a really bad thing the assertion flows if you\u0027re talking to Microsoft you care about this otherwise the device flow is all about a limited access client we\u0027re seeing a lot more of these days so this is not in the core ooofff specifications this is in an extension that\u0027s working its way through the working group right now the whole idea here is that your device starts an OAuth process and then it gives you a random a random code from the authorization server that you then go and plug in using another device if you\u0027ve ever used a set-top box to like connect to Yahoo or something like that this is what you\u0027re doing you\u0027re actually participating in an OAuth dance with multiple devices so what happens is you type in that code to the authorization server or you you know scan a generated barcode or anything like that the authorization server says hey I\u0027ve got a request that was waiting for this I\u0027m now gonna bind it to your account and I\u0027m gonna send you across and give you an access token at the end of all of those you get an access token and all of your protected resources speak those now native clients very quickly are things that are running on "
  },
  {
    "startTime": "00:57:23",
    "text": "your devices stuff that\u0027s running on your phone on your laptop stuff like that they functionally live outside the browser so this is a different world so instead of accessing the content through your system browser you\u0027re working directly with an application alright that means really two things one you got to deal with secrets and two you got to be able to get information back in the front Channel now dealing with Secrets is really kind of a problem because a native application isn\u0027t very good at keeping a secret from the user his user can always poke in any buddy in this room could go and poke in and figure out what secrets are there which means that if you have the same application installed on a thousand different devices and you\u0027ve got the same secret it\u0027s not really a secret anymore o auth one assumed that it always would be which was a mistake in OAuth 2 we said you know what don\u0027t pretend anymore that that\u0027s a secret so you can either use dynamic client registration to give every instance a new secret which is an extension OAuth or you can use a public client which doesn\u0027t have a secret now how do we protect those oops I put these in a weird order sorry when I trim down the slides it\u0027s a lot of my transitions are what got cut now to deal with that secret and said we can use this thing called pixie now pixie oh I remember why I did this in this order right so plot some Pixies in a moment how do you get information back to the client in the first place well you need a redirect URI if you\u0027re running a web server that\u0027s awesome it\u0027s just HTTP if you\u0027re running a native application you\u0027ve got a few different options you can do a custom URI scheme which is far and away the most common these days you can have some sort of locally hosted random web server Google\u0027s starting to do this more on their apps and you can have a remote host with either push notification or remote URL capture on native device not going to go into detail how these work they\u0027re all platforms specific the TLDR version is that there are ways to get information back to a non HTTP server using using OAuth today now the problem with those custom schemes is that on today\u0027s platforms anybody can register for any scheme it\u0027s just you pop up you say hi I\u0027m an app I want this one and system says okay so combine those two aspects the fact that anybody can get any scheme and the and the client no longer has a secret to authenticate the instance you come up with the world where pixie starts to make sense now pixie proof key for code exchange very shortly the client generates a secret hashes it sends the hash to the authorization server in the front channel authorization channel does its notarization server does this normal dance sends you back the authorization code then when you send back the authorization code you send the non hash secret along side of it to prove that you were the one that made that initial request this allows you to tie in to that transaction without having a unique identity for the client in other words you don\u0027t need the client credentials to get a similar level not quite the same but a similar level of security here you can verify the "
  },
  {
    "startTime": "01:00:25",
    "text": "challenge here because you now have the native you\u0027ve saved the hash from before you regenerate the hash and you\u0027re good to go all right there are lots of different use cases for all of these different grant types this is really how you should go about choosing them the first question that you ask is not do I have a native application am i running in a browser am i doing its who am i delegating for OAuth is fundamentally a delegation protocol if the first question you should be asking is who am i delegating for is it an end user is it some third party entity that\u0027s issuing assertions or is it just me once you know who you\u0027re delegating for then you can start to determine which kind of clients that you\u0027re going to be using and therefore which flows you\u0027re going to be using Open ID Connect is identity on top of this we don\u0027t have time to get into it dynamic registration lets you get clients blah blah blah token introspection we don\u0027t have time for all this there\u0027s a lot of stuff with OAuth this is why token binding is a bad idea more on that on Wednesday all right wrapping up there is a survey if anybody wants you can write that down say how good this tutorial was or how terrible it was let eyestalk know either way and that link should be getting passed around as well and that\u0027s it unfortunately we\u0027re out of time I can\u0027t go into detail on the other stuff like I said there was a lot of content here to cover thank you all for your attention and I will see you around this week thank you and once again anybody that wants the wants the discount code for the OAuth in action book come talk to me yeah it\u0027s it\u0027s it\u0027s hard because sometimes things go a little long or a little short different parts okay sorry are you starting at one thirty or forty five okay good fifty minute break in between that\u0027s good I was hoping that they had done something like that oh yeah oh yeah all right so here\u0027s the clicker this is set up for HDMI output but VGA behind it so whatever you can do there okay so that\u0027s we gen off of this no this is my elect that\u0027s your laptop so this is going away okay so this is a clicker and that\u0027s got the up arrow a USB stick thank you and that will automatically "
  },
  {
    "startTime": "01:03:27",
    "text": "tie everything into me deco so because this this goes into their splitter so that\u0027s why you have to use this one little piece of magic to make that work like I think I\u0027ve got I think I have you that time for some nail fantastic if not the Secretariat it should be floating around and they\u0027ve got a million adapters so alright alright enjoy oh it\u0027s back HDMI port all right [Music] [Music] "
  },
  {
    "startTime": "01:06:45",
    "text": "[Music] yeah "
  }
]