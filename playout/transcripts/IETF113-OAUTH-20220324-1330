[
  {
    "startTime": "00:00:05",
    "text": "okay welcome everyone let's get going so this is a second official session for oauth web group uh let's get going the no well obviously applies here hopefully you're familiar with this already um hopefully you're already familiar with those tips too so i'm gonna skip those let's see with these are the sessions that we've talked about this is the update the monday agenda and the thursday agenda so um we have a number of topics that peter um with the help of philip and daniel maybe we'll talk about device code flow uh vittorio with the brian in supporting mode uh we'll talk about step up authentication hey daniel then they will talk about libraries and daniel will finish with the pixie security bcp this is a discussion that we had yesterday in a side meeting we just want to recap that and make sure that what group is aware of that discussion any comments questions about the agenda okay let's get going then peter okay everybody can hear me all right i'm gonna take the uh the microphone so first of all maybe while everything gets ready um my name is pedro castleman um i am uh really delighted to be here uh this is my first ietf so it's sort of a really momentous moment for me i actually want to thank everybody in this room and in this working group for the welcome that you've extended and how how how welcome you've made me to feel over the last couple of days thanks for entertaining my many questions and um i really appreciate it and that and i've"
  },
  {
    "startTime": "00:02:00",
    "text": "so enjoyed it so much just uh working and collaborating with all of you so far um okay next slide please um so maybe to start with um so i'm going to talk about device code flow and some of the exploits that we've seen that uses social engineering techniques that allows adversaries to really abuse the protocol and gain access to resources when they really shouldn't and on the one hand right it's very easy to look at social engineering attacks and to say well that's just social engineering what can we do about it but i actually want to challenge us a little bit i read this quote recently uh there may be more that we can do and so what i want to ask folks as we talk about this today is maybe just stretch a little bit beyond what uh where we may have traditionally thought about where the boundaries might be and how we can go a little bit further perhaps next next slide thanks for watching um so we'll talk about i'm going to just briefly talk about device authorization grant some people may not be familiar with it i'll talk about the exploit patterns that we've seen and we'll we'll talk about that and also just look at it it's not like the uh that rfc 8682 doesn't have any security considerations it's not like it wasn't for seen but maybe we can do a little bit more and give more guidance on this topic um and then what i'd love to do is maybe talk a little bit about what we could do and what we should do uh also while we've been here uh philip has also offered he's come up with some some additional ideas around social engineering attacks related to device code flow so he'll share some of those insights and daniel has a demo in case folks thinks this is not real uh he'll show a little bit about how this this actually works so uh next slide please"
  },
  {
    "startTime": "00:04:00",
    "text": "now right so uh next slide so what is device uh authorization ground so it's really a protocol that allows device devices that lack a browser or input constraint right where it's difficult to input text to be part of the oauth ecosystem and to participate in the and obtain access tokens and refresh tokens next slide and they're really for devices like this right this picture is something uh they're for smart tvs uh or that was the original intent for smart tvs picture frames printers right devices uh like that um and so next slide please so if we we think about sort of the main participants in this for a typical flow you have your authorization server your endpoints you've got your consumption device and your authorization device and it typically starts with next side you know you get your display user code you also get a device code you get the verification uri the next slide please the um the user on their authorization device scan or enter the code next slide uh they then authenticate and authorize right and that can be a multi-factor authentication which is great so you can have really strong authentication on this flow uh next slide and then uh the uh the consumption device ends up retrieving the tokens the access token and the the refresh token uh next slide so really in a nutshell right you have this flow where you start a session on one device and then you authorize on the second device and the next slide and the benefits um so you can do authorization for devices with limited input capabilities it's really handy it's really easy in some ways"
  },
  {
    "startTime": "00:06:00",
    "text": "and you can also do this with strong authentication using a personally trusted device next slide but this is the problem mind the gap right so the the challenge that that we run into is uh next next slide please is that there's this thing there's a kind of a session transfer that happens here there is no protocol between the you between the users authorization device and the consumption device and there's no way to establish that trust relationship and so and it's not a back and forth it's a one way right and really our defense here is we are relying on the user to make an informed decision and that doesn't always work right we as individuals people in this room of course do not have this problem we are very good at spotting these these attacks but uh not really or or maybe not but uh but but there are great many people out there where this this little this gap is being exploited um and so next slide please so so let's talk about how social and how this opens the door for social engineering for a moment uh next slide so now we have our i'm not sure if that is a that's our adversary and they get control of a device let's call it the attacker control device and they can access and they can get a code these are an attack pattern that we've seen in in the wild it's been documented i shared some of the attacks that that's in the public domain so it's a it's a real thing that happens so the attacker ends up they get a code and the next next slide uh next one's uh one more and what they then do is they end up step number two"
  },
  {
    "startTime": "00:08:01",
    "text": "they change the context and they do this in very clever ways right they may obtain a device and then they may send you an email or a text message and the text message will say something like hey if you want to continue watching netflix please enter you need to re-authenticate right and of course these things happen occasionally so people do it some of them are even more devious right they they'd say something like hey uh you can get six months free of netflix if you go and enter your promo code right they don't even call it a user code uh sneaky very sneaky right so there's all sorts of ways in which the user can be tricked into entering these things and they scan and to enter the code i have a bus stop up there and it's not a the uh there has even been attacks i think in new york city that sort of follows the same pattern with bikes rental bikes where somebody took a qr code on a bike copied it put it on another bike when the customer came along scanned it it didn't unlock the bike but it unlocked the original bike for which the qr code was printed and the thief made off with the bat with the uh uh with the bicycle uh daniel actually when we talked about this uh share this this attack with me and it sort of just emphasized how um uh how tricky it is when when there is no authentication or no trust relationship right when you have this this gap when you're transferring a session so now the user scans the the code next slide please uh and they end up they authenticate they'll authorize and and and the sort of the tragedy of this is if even if you had multi-factor authentication deployed the user would still complete the authentication right the the attacker is not trying to steal the password"
  },
  {
    "startTime": "00:10:00",
    "text": "or the authentication credential they are just trying to get the user to say yes right and then next slide they end up retrieving the tokens uh the attack retrieves the tokens and now they have an access token and a refresh token and depending on what's in the access and refresh token they may have access for a very long time maybe to something as simple as a consumer service or a bicycle but it may you know that extends to other services that uses the protocol as well um and next slide please rafat so basically if you think about this it's sort of a classical man in what we used to call man in the middle type attacks you initiate the session you retrieve the code you use some social engineering technique to change the context and and this attack sort of generalizes it applies to other protocols where there is an air gap right so some versions of seba might be subject to this you know some of the work we're doing with things like psyop and openid connect may also be uh subject to this in fact whenever you're scanning a qr code this is something to to think about uh next slide please and here are some examples i thought i'd just to sort of give people a flavor right uh would you say yes to any of these things right hey here's the document just enter your access code or you know hey you're about to be logged out uh do you just want to just make sure that you keep having service right or uh hey your security department or your company has made a change uh and you need to take action otherwise you won't be able to do your job and these techniques are you know and then there's the bicycles right so these are all ways in which you can change the context and and there's many more i'm"
  },
  {
    "startTime": "00:12:00",
    "text": "sure rafat next thank you um and and in all of this right our defense right now is this mythical creature i call a homosecuritist who is a security expert he understands how the protocol should work he can detect these attempts uh he is so focused on the current context he knows exactly what's going on around him um but they're a rare species right instead next slide this is really homo sapiens right we need to help homo sapiens here they're really expertise elsewhere right they're very smart but this is not their area they're busy they're in a rush they want to help they're often worried about breaking things right and so what can we do i think the question is as i was looking at this how do we help them to make fewer decisions how do we help them to make better decisions uh and when they make a bad decision right how do we protect them and how do we provide guidance to implementers of these protocols to not just implement the protocol but actually take into account this attack attack vector so that we have safer implementations rafat so of course right rfc8628 isn't silent about this this was a something that was considered so next slide please so this is the entire section on remote phishing and really i'm gonna sort of summarize right two recommendations around better ui right so that uh there is some acknowledgement there and then there is uh something that says okay if you made a bad decision to limit the risk just limit the lifetime of the tokens right so that it's not a forever problem and so that's the extent of what we're recommending uh for protecting against uh phishing right now next slide please"
  },
  {
    "startTime": "00:14:02",
    "text": "but it's not all there's some others right that's also relevant uh so there's a section on non-visual code transmission and it really sort of talks about proximity but really proximity in the context of a non-visual co-transmission and it's not in the context of fishing and i think this is actually a valuable and useful one in the context of fishing and putting some more emphasis on that might be good next slide please the other thing uh in the security consideration section is it does talk about trust uh there's a topic called device trustworthiness so so another thing to think about is what if you only allow trusted devices to participate in this flow which may not always be practical but if we could do that that could be another solution but again the guidance that we have today is really more about considerations of malicious authorization servers there's a sort of a comment that says there's two devices um but it's all and then it says well you need to trust the device provider which is good right we should but it doesn't really tell us more about what that mechanism should be and that may well be out of scope of the protocol but maybe that's a consideration that we want to provide more guidance on as well uh so that's what we have today uh next fight please report so what else could we do right so there's some ideas that's come up in discussions with uh uh daniel and philip and many others in this room even uh so next slide please um so one is uh looking at proximity right uh christina i think you're familiar with this stuff as well you would have seen versions of this and some of your work too so you know could we could we look at introducing more guidance and mitigations on how to use proximity uh not just pointing out proximity but"
  },
  {
    "startTime": "00:16:01",
    "text": "but how we might accomplish that both for user for the user experience but also in terms of uh mitigating some risk on the back end uh do we need to give con guidance on content filtering right if you're deploying device code flow or device authorization grant should we give guidance about the need for having content filtering solutions in place additional metadata token binding writes who if somebody manages to obtain access and refresh tokens do we want to at least make it so that they cannot exfiltrate the tokens and use them in lateral attacks on other devices right is there some additional hardening that we want to do there uh trusted devices i already sort of alluded to um and then there's even work that's happening work in a way system uh that may be relevant right so do we need to think about things like secure qr codes right is there a solution that can help there so these are some of the examples uh there might be more i i fully expect that people in this working group have many more ideas that we can add to this uh these are just some some early beginnings aerofog excite these so uh another thing to think about is you know one of the comments when you and sort of uh it's on the the mailing thread at the moment is well you really shouldn't use device code flow in certain settings right but uh just like our customer or the end user is busy the engineer sometimes uh also is busy and is not an expert in the field either and so giving some guidance about you know when you need to have these cross device type flows uh giving some guidance about which protocols to use then a kind of a protocol selection guide that might be something else that helps um and it's true right the engineers can"
  },
  {
    "startTime": "00:18:00",
    "text": "just read all the different protocols and decide or they can employ an expert um but again right if we if we as a community can make some recommendations that that could be another potential solution um so what should we do right uh if we go to the next slide uh so you know there's some options here right one we could say we'll do nothing i'll remind you about the first slide i put up which is you know maybe we should do or could do more um you know a simple thing is just more implementation guidance threat models risk assessment frameworks even user experience guidance right profiles recommendations and so on um you know maybe there's new protocols that we need to look at cbs one of those that's interesting but um you know may actually be subject or actually be vulnerable to similar exploits and then you know i you know any other options right i think that's part of why we're bringing it to this audience is to see if there is some other ideas that people might have so um rafael i think we can come back to this slide later i do want to give philip an opportunity to maybe come and talk uh so when philip and i spoke earlier today he mentioned that he sort of came you know he saw another kind of social engineering attack and related to this protocol so i'm going to hand it over to philip to talk about his insights as well thanks philip thank you peter now i need to remember which one is the name of yours i have a long list of slices this one okay um thank you peter for making us uh giving us a good summary on how device flow and device authorization ground works in general there was one very important piece that you mentioned and that's the use of qr codes and there is a"
  },
  {
    "startTime": "00:20:02",
    "text": "class or there is a certain attack that is that is ongoing that is uh that is um possible to exploit at the moment uh which abuses the fact that uh not everybody uses those qr codes let's have a look um so i want to point out the textual versus non-textual um nature of of the protocol on the left side um we're asking the user to go to his other device enter a string and then enter another one on the right side i'm asking the user to to pick up his phone scan something which gets translated into the exact same url and the code already embedded and the user only has to compare at the end when when he opens up the qr code with his browser they only need to compare that the code that he sees on the phone matches the one that is over here and why is this important we can go to the next slide um before i go right that is important this non-textual thing was brought up into the rfc as an optimization and we have a text there that says that with the optimization that the user does not need to type in the user code the bigger optimization actually is that they don't need to type in the actual url and let's have a walk through why because let's imagine that the end user mistypes the verification uri so that's the url that i was told to go to um or i just entered it into a search engine because that's the thing now where the url bar is overloaded with multiple functions meaning that i will either land on a phishing site directly if it's a well-known provider of you know this is a device login or i will land on a search engine result page full of landmines paid ads and search engine optimized phishing sites i will enter my user code as i'm told by"
  },
  {
    "startTime": "00:22:01",
    "text": "my tv for instance and instead of being presented with hey you know confirm the code and being able to log in it tells me i should phone a phone i should call a number uh where a scripted scenario will take place um an agent on the phone will first ask me for an email address and because i'm on the phone with him it's really easy to make me distracted as he walks me through a password reset flow where he asks me to confirm a code he just sent to my to my inbox which i'm happily going to give him because i just want to log into popular vod website who knows as i do that the agent is now authenticated they can run the rest of their scam they can buy digital products they can attempt to upsell fake services to me so to directly extract money out of me um and the ridiculous thing is that at the end of this all when they're done they're still going to log me onto my tv i'm very happy because i can finally watch the tv show that i was about to log in and the detection of all of this is delayed let's move on thank you so the key point here that the end user actually did initiate the authorization flow it is you know their target to login onto the tv it was not the attacker the user has a legitimate stake in completing the flow improving consent confirmation screen on the other device does absolutely nothing because i will never see it all i see is communication on the tv from the manufacturer or the developer of the application and everything else is in control of the attacker and i'm actually satisfied at the end because i logged in and i you know walk away with my account details either stolen or out of a couple hundred bucks uh yes this is an end user problem there"
  },
  {
    "startTime": "00:24:01",
    "text": "are post signs along the way that i choose to ignore but we can still do better because if we prefer non-textual code transmission if we did not offer the a enter url in the first place this would not have happened likewise if there were actual password reset links and then password reset codes this would also not be possible because they could never gain they could have never asked me to can you please repeat the 64 hexadecimal string that i just sent to your email that's not a thing so question for the group for a future discussion after daniel is done with his demo is other than the qr codes uh is there anything else that is readily available and usable that we can offer thank you thanks philip let me quickly switch do you wanna no i'm just gonna invite daniel up daniel let me see if i can um thank you peter thank you for the screen here share the screen yes oh shoot or maybe it's a phishing attack i guess totally open need to rejoin sorry yeah that's what i was worried about right now come on"
  },
  {
    "startTime": "00:26:00",
    "text": "okay second here this one just taught here that you sent me this one this one okay see yes complete share yes yeah if you could stop it here yes okay so this is just a quick demo um to visualize what we're talking about here because usually a screencast says more than a thousand screenshots so um what we have here is uh on the right hand side wallet um that we're um working together with a project uh in the id union project um and uh in the middle you see a phishing site so essentially you have to imagine that you only see this part as a normal user you go to a website and you want to use your wallet at that website that website is um in this case called attacker.example.com button practice might have a name that is less suspicious um so you have that website you want to log in you see a qr code everything looks completely normal to you you want to log in at that website um so what you don't see is that this is an attack uncontrolled website maybe it's a compromise website maybe it's just set"
  },
  {
    "startTime": "00:28:01",
    "text": "up specifically for that purpose and the attacker is not showing you a qr code that will lock you in at attacker.example.com but instead the attacker has taken that qr code from another website in this case it's a it's an xcloud uh login um that also works with the with the wallet login and the attacker has just stolen that qr code from there you don't see that website you just see that website but this is in the background when you say that and this just because okay the red one is what the user um so the red one is what the user sees the blue one is what the attacker has opened on his computer on the background so as a user you see the red website attacker.example.com and now you can play the video please um [Music] so you see that qr code you want to log in you open your wallet app on your device that would be on your mobile device you click on scan qr code and stop here please you click on scan qr code and on your mobile device you see do you want to log in um do you want to provide some data to that website for the login process and yes you want to log in at attacker.example.com so you click on yes and send and do and whatever and the login is complete it shows success on attacker.example.com in this case nothing happens the attacker could show thank you for your cooperation what happened instead is that you can see on the left side the attacker locked in or now has control over a session that is locked in under the victim's name in the next load um as a user you didn't see that an attack was happening here thank you awesome thank you thanks daniel thanks"
  },
  {
    "startTime": "00:30:01",
    "text": "daniel rafat can you show the last slide of my presentation again so so back to the question about what we can do about this hopefully this is sort of a bit of an overview i think you've heard from a couple of people who have come across this social engineering angle and some of the challenges that we run into with it and um and so yeah i mean i'd love to hear back from folks in this room right a reasonable thing that we can do right is it is it um is it worthwhile right to provide some additional implementation guidance on top of um the device authorization grant uh to highlight some of these topics um would it help or you know is there other things that we should do should we really be thinking about other types of protocols or other types of solutions and yeah that's my question for for folks in this room or or online okay tim peter knows what i'm going to talk about um tim quality microsoft i just didn't like as you said jeez i should just terrified him as a colleague of mine i i didn't i didn't actually declare my affiliation i am a microsoft employee as well yeah um so so i think there's two i think we have to up level the discussion to the use case um to solve the use case moving forward in my opinion the solution is web authent and cross device flow and that is an important distinction because we have to start that message now because these tvs that are sitting here stay in people's houses for seven to ten years but we imagine in the next 12 months six billion devices around the world will have cross-device phishing resistant authentication capability right and that's a huge when this conversation started that really wasn't part of the discussion um so i think it's"
  },
  {
    "startTime": "00:32:02",
    "text": "i agree everything about trying to reduce the risk with what's there today has to continue that discussion has to continue but in parallel we have to start the conversation about getting rid of device code flow and i think they intersect at a point where you can start to reduce the attack surface by reducing the scopes you're granted when you use the vice code flow um and those will drastically intersect hopefully in the near term um so yeah i'm happy to take any questions on thank you any questions for tim yeah justin justin good justin how does it work yes so yeah i like it yes i have to be a little careful because it's it's still ipr predicted but more or less there's bluetooth involved that handles proximity and key exchange and then it's standard web authent from the client simply okay so so okay we're not gonna okay so that's fine editorial right we'll get back to that hi victoria octa uh i think that uh the web often future is beautiful and bright and very powerful but i think that there are stepping stones that we can use to get there and uh in particular right now we have this section in which we say use whatever you have to transfer context between the requesting and the authorizing device and i think of it we have an opportunity to be a bit more prescriptive so their bluetooth is mentioned and bluetooth is also the thing that fuels this is the thing that the team described if we were to be more specific and say okay here is a how in practical terms to use bluetooth we can transfer context from a requesting device to a collocated authorization device and once you have that entrained and without mandating uh web often but for example just saying when this happens you open"
  },
  {
    "startTime": "00:34:00",
    "text": "the system browser and you go to his url plus code at that point you would mitigate the number of the challenges that you highlighted and if it's standard now you can reasonably expect the hero apps like your authenticator or google authenticator or the oculus authenticator or even operating systems can start doing this of course other challenges you still need the interstitial dialogue saying this is happening but i think it will be a significant improvement not just from the security perspective but also from the user for user experience thanks vittorio hey tony tony natalin so i assume you're talking about of google's implementation that really doesn't have much to do with wedlock then at all it's down in the fido level to the mic tony so it doesn't have much to do no no he has a mic yeah so it doesn't have anything really to do with web authen so it's all done in the fido level protocol underneath and it's got severe usability problems and this is one of the reasons why it hasn't been released and it's still in what i would call trial i'm not sure if this is the proper you know paradigm to actually go in it's you know the bluetooth does have some some severe issues and they do have some security issues associated with their where their pair where their pairing or how they do that you know the quick pairing thanks tony okay justin hi justin richard um so the composed uri is something that i always hated about the device flow and i helped write that paragraph with all of the considerations of don't just auto post the form and all of that other stuff because i always felt that that"
  },
  {
    "startTime": "00:36:01",
    "text": "was a bad idea um because i think i think fundamentally here what we're realizing is that these are two very different interaction modalities uh in one we're communicating something that a user needs to like be able to type whether it's you know the pair of uri and the code or you know just the code itself would they get the uri from documentation or whatever that is very separate from being able to have a uri with a whole bunch of stuff packed into it or like even like we saw in daniel's demo um being able to send a long arbitrary untypable chunk of information to the user where we're not expecting them to copy and paste or to remember or to transcribe or anything like that and i think our first step at this needs to be separating these and not treating these solutions where oh we're just going to send a whole bunch of cryptographic information over bluetooth excuse me that's not really the device code flow anymore right it might be using some of the mechanisms or something like that but it's really solving this in a different way and that's where i i do agree with the statement where this this nexus of things of saying like okay if you do really do have to use the device code flow then we know that that's got some severe limitations so we're only going to let you do these particular things with it and we're going to warn you and we're going to send you know notice that hey there's a new device on your account and all of that other kind of good advice that we can actually give today while still being able to develop these new paradigms and not pretending that this is just another way to expand the device flow thanks thank you for stressing okay hunt hi this is santiago um i have a more general remark i'm not even sure it's in"
  },
  {
    "startTime": "00:38:00",
    "text": "scope but i'll try anyway so um there was something that rang my bell in in a previous talk which was basically this um observation that many developers don't really know what they do or might be you know puzzled by what's available in the standards and my experience actually from developer using encryption standards is that many of the stuff doing by crypto researchers is very much low level and it's very hard to grasp actually how to apply that and what errors can be made so my impressions this might translate a little bit also to you know things like oauths and the processes involved and what i actually would like to have if you and i read that a little bit in user experience guidance is maybe something like you know about design patterns in programming like you know um standardized label descriptions of certain cases or error cases which are interlinked and help me navigate and relate a little bit different how different things can be put together and which errors might occur if i choose a certain solution that was that direction that's all okay tim thank you okay microsoft sorry tony i'm not gonna let the room leave with what you said um that's not correct um so um there are at about we're guessing two billion devices that now have this capability over the next over the past three to four months and you are correct though that that was not the the communication to the phone was not web authentic my point is i didn't actually say verbally was that from an idp standpoint you don't need to implement anything special it's just web authentic okay thanks okay hey thanks tim um do you have any just last minute comments or i wanna just summarize this after that and see what we're gonna have together again some great points thanks everybody justin i i think your point is spot on i do think these are separate things i think that the points been made we have to secure what we have and then we have to look for ways in which we can minimize the use of that and provide better alternatives that's kind of my my summary of that i think that the point around uh either way when i think about engineers right they've got expertise"
  },
  {
    "startTime": "00:40:00",
    "text": "elsewhere they may not be security experts and the rate with which oauth is just expanding in the world and being adopted expecting more people to become experts at this is not not right and so giving i feel like i'm hearing uh yeah we need to give more guidance and we need to help the developers with that um and yeah i think that's kind of what i'm taking out of this that there's interest in proceeding with this yeah absolutely that's what i've heard too and and maybe if you have a proposed solution also propose those solutions right um so anything else um so if folks are interested in this topic uh reach out to me uh uh let's start working and figuring out how we how we shape uh a response here as a as a group in the community thank you everybody thank you thank you thank you and philip as well for your contribution here today thank you all yeah that was a great presentation great great discussion thank you victorio my friend come here yeah let's see how we can do that hold on okay sure honestly told you so now i need a request i think i can hand it to you let me see i just sent you the controller yeah there you go i don't have to do anything now i can't go to sleep i don't know why and no one did it before it's an ultra annoying idea to ask you yes there you go all right okay everybody and welcome thank you for taking the time to come here today and hear about brian and yours truly proposal on dealing with step-up authentication step-up authentication is a pretty well-known problem which emerges"
  },
  {
    "startTime": "00:42:02",
    "text": "in various circumstances and for which we have no standard solution and we don't have interoperability and that's the reason for which we decided to try to analyze our problem and see whether we can suggest a very essential way of dealing with that so we're going to spend a few moments on the problem which is well known but still by due diligence then few moments of your proposal which is a really really bare bone so it shouldn't take long and then we'll discuss all right so we know that there are organic ways of witnessing a step up of education so a client might ask for an initial set of scopes and then knows that it needs to call another method of api and that api might require requesting a different scope which in itself might require to do a step-up authentication so those are the cases in which the problem solves itself let's say that the step-up authentication just occurs however there are a number of other situations in which the client can do everything right and use all the information at its disposal and successfully authenticate the user in the way that the authorization server requests and still the api might refuse a service it might say you're trying to buy an item which exceeds your uh spending limit and the item that you're trying to buy is not available at the moment in which you are asking for the token and so the authorization server cannot do anything to reflect these height and requirement or we know that it's fashionable nowadays if to do continuous authentication and so you might have um risk engines or any other black box logic which might decide that the token that you send is not enough and today unless you have some"
  },
  {
    "startTime": "00:44:00",
    "text": "proprietary way of dealing with that particular scenario you're stuck because the client is just going to repeat the request for research server get the same token that he requested before and the refuse service just in the same way so not great okay so what we are suggesting is very very simple we are just introducing a new um error code which basically says authentication level was not sufficient and then we are borrowing a couple of parameters that are already in use in open id for id token requirements and we're basically saying okay a resource server you can specify in your challenge sending back this error code also the acr that you would like or the list of acrs that you are okay with for uh for the client so that the client can turn around repeat the request of the refrigeration server and include voice parameters now in the case of open id when you use those parameters again affecting the token in this particular case we would extend your semantics to apply to the access token and also open id is lux let's say it says well authorization server if you want to do it do it but you are not forced to instead in here we would add something in the metadata which for the foundation server to comply to this particular flow it would commit to actually do its best to comply with a requested acr this system would be compatible with existing mechanisms we have today such as the scopes like today we have insufficient scopes and so we would be perfectly fine if you happen to be in the circumstance in which you need both to elevate your acr and to request new scopes to ask above things at the same time and uh basically now that we have a vehiclet"
  },
  {
    "startTime": "00:46:00",
    "text": "profile we can actually describe how to report the outcome of these different authentication in the form of the acr claim we can extend the schema of the infrastructure endpoint to also specify exactly the same claim so we basically have all the various pieces of the solution available another real power of this thing will come into play because i can show you a fantastic animation so here you have a client that you have your resource server and your authorization server business as usual i just try again i include my better token but as it turns out actually here sorry not very big uh there is no acr it's just like standard token and again i'm using jwt just for simplicity but you can perfectly have an opaque token that uses uh introspection and there is of server deems that the level of authentication reflected is insufficient and so now it returns insufficient user authentication and in this particular place it includes only one acr value of course it could also include the max age if necessary it could also include scopes if scopes are also missing and then at that point the client turns around goes back to authorization server and it includes the information about the acr which would not normally have been available which could be contextual to the particular request and the characteristics in there then for the server we do whatever it deems necessary hopefully trying to comply with my acr and assuming that the user successfully authenticates we get our usual response and this time we got reflected in our settings that we did comply with acr and at that point we just repeat our"
  },
  {
    "startTime": "00:48:02",
    "text": "request and oh we get back to andrew so the main advantage of these is that now we have an interoperable way of dealing with this scenario we presented this problem in a similar proposal at the um off security workshop last year and this session was the most voted by the people despite the fact that we did it at the very last moment and the comments and the tweets like the various reactions were all like oh wow are you saying that this is not standardized yet like it looks like it's a problem which is fairly common and also i know that some platforms already have their own proprietary solution but it seems like whether it's solved this way or in some other way this type of problem is a problem that people have so one advantage would be we now have an interoperable way of doing this the other is that it is a relatively small step we are not asking anyone to start implementing eventing uh seven buses uh event syncs uh asynchronous stuff stateful stuff this is a ultra basic sending back parameters in the context of transactions that are already occurring so we are not creating new messages or anything and we are staying squarely within the extensibility mechanisms that respect offer and um yeah brian am i forgetting something thank you your praise is very important so okay look at all these people in the queue okay steve clarifying question is acr multi-valued in that i'm sorry sir your name and your affiliation lefty once it says so on in"
  },
  {
    "startTime": "00:50:01",
    "text": "the queue all right so if you flip back one or two slides maybe um i think i might have lost control no all right can you go back oh come on so in that slide it says acr values is that it's a multi-valued so you can request any of these yeah this is a very good yes yes the semantic is exactly the same as open id plus access token justin so my question is really around why the resource server is the one that's caring about uh authentication levels as opposed to the authorization levels applied to the access token um because there's this great blog post that says how the resource server is not the service that you're actually logging into it has this whole metaphor with chocolate and chocolate cake you may have read this one it's vitoria's blog if no but if people didn't get that joke um so uh so i'm just trying to see what what the use case is here where that's driving the the rs needing or even caring about that information about the authentication level of the user at the as because you know traditionally once you get the access token it's just whatever the access token is good for and so can you can you help me understand what's driving to this particular solution absolutely and thank you for every question because it's a it gives the opportunity for a useful clarification which is uh we still care about the authorization in this case and we are not trying to mess with what open id already does this is"
  },
  {
    "startTime": "00:52:00",
    "text": "uh similar to the use cases that we explored when we did the generality profile which led to adding the acs of the acr claim in the layout and basically there are a number of scenarios in which the resource in itself has uh requirements about the authentication level of a user still for authorization purposes so it's not like that they want to mess with anything it's more of like if i am reading nails i'm okay with this password but as soon as you want to send mail uh i would like to know that a user performed mfa now personally i agree that it would be best if a resource server would somehow translate these in some other form like for example scopes that reflect a different authentication level but the thing is we already have acr which already have a semantic with maps to mfa and for people that build the policies mfa is an easy to grasp concept and so requiring it somehow is something that happens very very frequently like you know in real life back here in the microsoft days i had to do this all the time but actually here i would personally want to place in here also amr so going to the level of method but the guy with the pink mask is very much against and uh he raised a good point that it would be brittle because if you ask for something specific then it's easier for break it but the thing is that the developers i work with in practice they ask for that they ask her saying i want to know if you used a smart card and not just that you use mfa so follow-up corollary question if i may go ahead um that does beg the question how does this relate to needing step-up authorization for additional scopes and things like that and since you brought up amr"
  },
  {
    "startTime": "00:54:00",
    "text": "what about vectors of trust um so for scopes as we mentioned basically you can just return here the list of scopes that you want alongside with this so imagine it emerged within sufficient scopes on that source of trust i let but i uncountable to answer the question but you you don't have to answer it now maybe if you you don't have an answer now yeah later okay george george yeah so i mean i think uh for me this this makes a lot of sense i think we should have some caveat that says this works where the resource server and authorization server in the same domain right i mean i think we're seeing use cases where you know you get you know authorization server issues an access token that works for multiple resource servers you know that maybe not within the same domain i worry that we don't have standards around acrs um i have seen people use justin vectors of trust tags as their acr values you know aal1 aal2 as the value that's being requested we also have the eap stuff in the openid foundation that allows you to request a hardware backed phishing resistant authentication so there is some stuff here but i think there's you know some more guidance from a larger interoperability perspective that we're going to want um but within a single domain where the resource servers and the authorization server are sort of all run by the same company um i think you know this would work fine and i do think there are lots of cases whether it's time based or otherwise where um apis that are being invoked need to have some level of addition additional authentication right um i want to know that you entered your rsa"
  },
  {
    "startTime": "00:56:01",
    "text": "code i mean this happens this used to be on ebay you know e-trade all the time right you got to do a trade and it pops up the thing for your rsa token enter your code right um and i think we sort of have to include that as sort of an authorization mechanism to justin questions thanks george this is a good point to mull over i think um for for the meeting minutes um i i captured that um the same domain issue but i wasn't quite sure what the cross-domain use case george was um like you're saying this is not enough for across the main use case or sure i want to take you know a token issued by you know i you know by a company that is you know um issuing uh tokens and use them at some completely other reason like think about a resource server that works with multiple email providers right the each email provider is issuing its tokens right and it may support multiple issuers right and and those tokens are coming into its api now it needs to know what are all the different specific acr values that each of those issuers and figure out which one to send right i'm just saying there's complexity there um so we could we could frame this in the context of you know this makes that this makes straightforward sense in the context for the resource server and the authorization server in the same domain right when they're not is sort of out of scope of the spec unless we want to tackle that problem um can i reply yeah no of course of course by all means great uh great point uh interesting uh thing to think about i think that the fact that"
  },
  {
    "startTime": "00:58:00",
    "text": "acr is by reference and it's just a string and both parties need to know what that means is a natural scoping mechanism let's say that a resource server will say i need these acr and that acr connect can have been acquired only out of band while talking with a particular authorization server and i think that that might be enough of a scoping mechanism because like they are more than one authorization server and they share the myhcr like imagine that the gain faults actually uh succeed and save at the gain profile as identity providers and authorization servers that follow the same model and they share like acr values which have semantic in the context of that particular system at that point it looks like you might have more than one domain but you might have a good reasons to use the same stuff so i i take them at a point that people need to think about this and they need to be probably mindful and explicit about how to scope it whether that results in being in the same domain i think that we need to uh uh i approve the thing like study it and see whether there is a conclusion or not but in general i agree with uh with the premise thanks say george brian do you have a point about this discussion or something else yeah it was it was exactly that the there is some agreement on what the meaning and levels of acr that's necessary it might be on a pairwise basis it might be on an ecosystem type basis but there's nothing inherent about that that would limit it to a single domain so that i don't i guess i do disagree with that characterization the general idea that there's something needed to to work and unders a shared agreement about acr yes but limited to the same domain is not not the right scoping"
  },
  {
    "startTime": "01:00:00",
    "text": "okay thanks brian philip phillips here i'm sorry um so very quick thing that uh very quick thought that came into my head is that the client and the resource server will probably need to share some level of trust or there needs to be some level of trust established because otherwise the resource server can now turn and make the client do something that maybe it didn't want to do in the first place uh this is just something you know that that came to me if there's a rogue rs that the client is made to talk to it can now turn back to the client and tell him listen just add these parameters i'm not sure if there's anything in it but it's just a thing to consider whenever we write up security privacy whatever considerations the other thing is um it's great that there will be something else than 6750 that actually uses www authenticate because it will force clients to implement parsing it correctly thank you thanks philip i really like the observation mostly because of visa validates using a specific semantic for those parameters as opposed to just say let's have a generic property bug that we sent back to the client and that the client might mindlessly just send out so that at this point like the um the semantic of acr values and max age and scopes is very well defined and now of course the requisition server might still abuse it and sure the um the uh resource server can ask for an absurdly high level of authentication but the point is they can do this already let's say that if they are getting a token from a fourization server potentially they could say when you call this method when you ask for this scope i want you to use visa authentication level so your point in general is well taken that we need to"
  },
  {
    "startTime": "01:02:01",
    "text": "make sure that we don't enable uh all the extensions in which we play stuff that allows things that are unexpected to occur but i think that we can define the semantic of those parameters narrowly enough that the vets should be content all right i'll leave you once again so i'll take this opportunity to remind about the there is an iana registry for um access or authentication context last rest it actually covers across as well based on rfc 6711 i set it up years ago it has like all of the globally recognized um context classes like uh the e e i dash level so sure and stuff like that in it and you know and and a suspicious number of swedish stuff as well but that could be used i mean there are certain things that or shouldn't really should have global wrecking recognizability right and you dump stuff in there and i think maybe it's time to go and revise that rfc and maybe update the iana registry to make it a little bit more like applicable to oauth and oidc anyway thank you 667. yeah go ahead as dave robin uh representing backnet the building automation control so i've been evangelizing oauth 2 bacnet people educating them the whole thing uh collect token binding client ids you know scopes everything um now with it seems that we're throwing in an additional thing here that i have not been evangelizing to them and the question is you said uh oh i could use a different scope here i have a read token now i want to write scope as well right why or i could have this generic email scope and get this different a um acr value"
  },
  {
    "startTime": "01:04:00",
    "text": "so it seems like the permissions are no longer scope based they're a combination of scope based and acr based it's sort of this weird cross product or something and i find that confusing i understand your answer was well we have this acr mechanism so we'll use it as opposed to uh new scopes so i'm not saying that this is a bad thing i was just questioning why not use scopes what is additional scope not giving you that you need the existing scope plus the acr value is effectively a new kind of permission so there are two uh various levels so first scopes are not necessarily only for missions but they could be used as permission uh in this particular case uh scopes are typically something that you have at request time and there are things that are you are typically have in a third party scenario if you are a first party potentially people use all this flow with no scopes at all so at that point you would be asking them to include scopes in a scenario in which potentially there is really no delegated flow so technically in term of a universal turing machine scopes have the enough expressive power to do all these okay it's just that now i'd have to introduce them and basically have the same semantic i already have with my acr with implementation that already react to this because open id connect already this mechanism in which you can ask for these even if you have no scopes at all and the circumstance in which you needed to elevate do not include the scopes because they configuration the consideration is not statically um calling to this particular subset of a resource is more situation happened and so i needed to ask for this so in terms of clarity and in terms of distance from the implementation this finger we believe would be um clearer and also the other point is scopes as a mechanism of a challenge has"
  },
  {
    "startTime": "01:06:02",
    "text": "and very few people use it because it's so generic that um in the end what makes a difference is the scopes that you are asking for and the particular semantic for your particular system so just having the mechanism that sends the scope around doesn't make much of a difference and despite our years in which we tell developers do incremental consent don't ask for everything upfront just at lunch we were discussing the fact that in practice the developers wanted to avoid these as much as possible and so um rather than asking for scopes when they need it they ask as much as possible upfront right so that they reduce the number of prompts and the opportunities for developers to do something wrong so sorry through the user to do something wrong so we believe that by being specific and by piggybacking on existing capabilities that are already rooted on those values we will have a better shot at interoperability and implementation than with scopes which so far could have done this but haven't done it okay well it's similar to the resource indicators thing of preventing scope of use where scope scope is abused to indicate resources clients and all the other stuff it's perfect [Music] one second mike brian d do you have a point about this discussion go ahead just one more thing that use case is kind of near and dear to my heart that this fits better with is on the resource server side some kind of anomaly detection or ai or whatever black box indicator or even signaling that it's receiving that suddenly decides the token is invalid and wanting to be able to take the user tell the client to take user through a re-authentication flow to remediate that situation is something that is even harder to model with scopes i think you probably could but it's even more difficult than the kinds of static scope to authentication levels so um"
  },
  {
    "startTime": "01:08:02",
    "text": "just one one more driver for being able to sort of independently express hey i need this user to authenticate again at this level and do it in this time frame to to get access mike mike jones microsoft uh reinforcing my friend life's comment when we defined acr in open id connect we already suggested that people should use um the level of assurance profiles registry uh for the values and i also agree with brian's comment that uh the fact that there's uh mutually understood values doesn't imply that things are necessarily in the same domain indeed life's registry enables that to not be the case okay thank you victoria do you want to wrap it up um well as you have seen the scope of this thing is pretty small um if you think that this is a a problem worth solving then the draft is out there so if we want visa to be adopted and work in it reluctantly but bryan and myself are willing to move this thing forward yeah i get the feeling from the room that there is interest and there is still some maybe confusion or still some um something to clarify so i would encourage you guys victoria and brian to maybe update the documentary take that input into consideration maybe clarify those points"
  },
  {
    "startTime": "01:10:01",
    "text": "and submit a new version and let's see if how we can move it forward the next time um i'll read the the minutes with interest i suspect that if you'd read the current draft you'd see that many of those things are addressed okay there is always a possibility that some data is to be managed we could also ask um yeah okay for for reviewers of the document i think that's always good uh since now people are aware of the uh of the document uh like maybe maybe you have a show of hands and i can scribble down a few robin phillip peter [Laughter] yeah just put it there perfect you don't want me to drop it okay thanks victoria that's great thank you all okay awesome can you exit i think you're still in control"
  },
  {
    "startTime": "01:12:06",
    "text": "there you go take it away daniel thank you so today i want to talk about the sorry state of the clients um regarding war clients obviously um next slide please do you want to use the mobile device why it worked nicely for audio so um oh sorry my observation is that there's a lack of good modern and universal oauth client libraries and this is something we should address this is something we should fix again if you want to try it okay so that's in the same web interface oh yeah got something here this is where you go there we go excellent this is great yeah fantastic okay so um what is a good modern universal uh client library um so what could it be let's say uh i'm sorry is the scribble panel part of the slides now can we close that there we go thanks um i would say a good library is one that follows the latest security recommendations is one that feels native in the language or framework for which it was developed it is hopefully also maintained and documented especially the so both parts are important maintained obviously also for the security part and documented also because so you can learn what the library actually supports and what it does and how to use it as a modern library um i would say"
  },
  {
    "startTime": "01:14:00",
    "text": "library should support at least a certain set of security features like pxe um it should support methods for asymmetric client authentication maybe mtls um and maybe maybe maybe a big question mark it should support things like um auth 2.1 or floppy this could so even if if we don't say okay this all libraries need to support happy that would be a bit strange obviously but um maybe these kind of profiles can give you give us a direction um in which which way to go what a good library could support and universal means that it is not tailored towards a specific use case or specific vendor specific api because many of the oauth clients that you find out there are written for sign in with google maybe they support google facebook and um i don't know amazon whatever um so that's not a good library if you want to use the library something completely different um it should not be limited to certain use cases as far as possible obviously a library on a mobile device would be different from one um with a web interface maybe maybe it could be the same library um but apart from that it should not only cover very narrow use case yeah it should be very configurable for various uh feature sets ideally so it should not assume the same feature set um in all the use cases for example i saw that many libraries claim to support authentic id connect where in reality they just implement openmd connect so you sometimes cannot even switch it off um that's not a good thing ideally you just throw some issuer url at the library and the library configures itself because it can read"
  },
  {
    "startTime": "01:16:02",
    "text": "this obviously also requires that the authorization server provides server metadata daniel do you want to take comments now i think it's essentially on there okay okay yeah um yeah maybe we take the comments afterwards okay okay so what's the experience in practice when i say experience in practice i mean my personal experience and that is at yes.com where i help customers to implement yes.com which is more or less frp2 profile um so all standard features um but um yeah in practice this means that um there are some libraries that you can use to implement what we are doing like philips node.js library works well we have a demo for that on our website you can just use that it's a few lines of code works really well um there are some other libraries like in java the nimbus library but apart from that there's not much else most of the time that means that our customers end up with custom implementations so we have a developer guide we tell them how to make certain requests how to process responses and they have to implement this step by step um the experience is for me personally that i cannot point uh developers to good libraries because maybe i just don't know where the good libraries hide but my impression is that it's really really hard to find out what are the features that the library supports um is it even a client or server library some just say okay we implement auth okay what exactly do you do um what are the specifications that it supports um is it just rc 6749 and 6750 or is there also pixie is there anything else not so clear often um that the authors"
  },
  {
    "startTime": "01:18:00",
    "text": "have a look at the latest security recommendations or not this in particular is often just not documented so you have to dig into the code and figure out whether they i don't know would even handle things like an issue in the authorization response and stuff like that um many of them are incomplete so it works for sign in with google and a few others but apart from that nothing else and there are dozens of unmaintained implementations so if you go on oauth.net where erin has listed all the libraries for different languages if you click on them like every second of them last update four years ago or something um yeah and interestingly this lack of good libraries um is um like a um self um what's it called so so so fulfilling prophecy thank you um the because because we have this lack of libraries we as an uh offer of an api we have to document every single request every single response how to process it so we have to write a complete documentation on the http level um and this leads developers to just implement it this way because they have this this implementation they see okay it's just a few requesting responses what could go wrong um so they just go and implement it themselves so there's no real incentive for them to learn how to use a library with that okay um why do i keep hiding my phone in my pocket when i need to switch slides and then there's what i call the auth configuration help um assuming you don't have server metadata then you need to figure out a few things until you can use the library yeah i know but i need to i need i need to have a hand so maybe i have an italian somewhere in my uh ancestry i don't know but um the auth configuration help so just to set up a library um without server"
  },
  {
    "startTime": "01:20:02",
    "text": "metadata um to to um use oauth you need to figure out like the dozens of dozens and dozens of uh uh things like what are the endpoint urls authorization endpoint token endpoint if you use open id connect user for endpoint what are the supported grant types uh what's what method of client authentication is used what are the security mechanisms you should use or can use or must use sometimes you want to use a security mechanism you don't even know if you can you can use it and this is not even talking about the specifics of the api itself so you still have to figure out what are the scopes claims and so on um yeah so without server metadata this is a really tedious process and this also reduces the value in using libraries because if you have to figure out all of this yourself then maybe it's just easier to implement the http requests what are the consequences from this well there are plenty um first of all there's an unnecessary fragmentation so the libraries only support a specific subset would be great if they could just support a larger feature set and maybe then we don't need that many libraries um this also leads to a slow adaption of new specs so we have recently uh standardized the issuer parameter and the authorization response this is a really really small change but i don't expect to see that in any of the libraries soon except for phillips library thank you philip and this can lead to developer frustration except for those who is in phillips library um so to quote um hans jackie if i may quote you um he just uh was it yesterday i know the day before yesterday he said that when they implement an auth client they usually count several hours of research or do"
  },
  {
    "startTime": "01:22:01",
    "text": "several hours of research before actually implementing something and this is not a good situation um if you this is completely unscientific um but if you um take a look at twitter and this is only from one day so i just opened twitter search for auth and if you do that you find many many voices from developers who seemingly um spend hours and hours of configuring auth so part of this is the auth configuration um and i really wish that for developer only the only thing that they had to do was to throw an issuer url into a library and then off they go of course so having to implement some specifics for the api but we are far from that um when when you count the voices on twitter um this of course also costs time and money so we see this with our with our customers who often spend a couple of days developing the integration until they they get to the point where they can actually use the data that our identity providers provide also for those offering the apis if you offer an api and you want to provide an sdk for that api you often also have to maintain what is essentially a specialized oauth library and it would be great if we could come to the point where you just as you don't implement tls or https today where you could just use a library that's already there in your framework in your language and use that to integrate with wars api providers also have to spend a lot of time just explaining what they are doing it's standard auth so they they have to explain it over and over again and they have to support developers who don't understand or off but maybe they they shouldn't be required to understand the auth they should just be"
  },
  {
    "startTime": "01:24:01",
    "text": "able to use auth um yeah and then of course the developers they have to do trying errors uh trial and error to figure out uh what is supported in a certain api um i here used twitter as an example because twitter just recently created an auth 2 api and this is very interesting because this is not a legacy api this is new they support pixi and so on so it's it's uh it's from so it's okay from the security profile uh perfectly fine um but if you read the documentation it's interesting that you see that they expect all developers to essentially implement this from scratch um so they they talk about they have a glossary with auth terms they um explain the or flows and uh they also have an explanation for every single parameter that you use and uh one thing in particular struck me um so they give an example for an authorized url and they even say you will need to have the proper encoding for this url to work be sure to check out our documentation on the percent encoding why do we have to do that yeah i mean this is i mean we're not explaining tcp to them either so this should not be required but i know that this is a problem so i understand why could i put it there because we have the same problem with customers implementing yes so yeah there you go um yeah and obviously my favorite topic security um customer implementation is obviously also bad for security so there are many many opportunities for hidden security problems um so when i see customers implementing um our apis um i sometimes have the feeling that they probably don't do all the security checks they should be doing but it's hard for me to check that because i cannot look into their code i don't have the time to check their code"
  },
  {
    "startTime": "01:26:00",
    "text": "um but you can just hide a lot of security problems in a custom implementation the if there come new security recommendations it's unlikely that custom implementations will follow them and of course we have known anti-patterns that are still being used like state being filled with a static pattern um also pixi being used with a static code verify code challenge um yeah so there's some research i took that from an older presentation but i guess this is still more or less current researcher researchers have spent some time to look at actual oauth implementations and they found uh security problems in almost all of them it's like sometimes they had like 96 clients that they looked at and almost all had security vulnerabilities again this is a bit older this research i guess there's not so much new research on that topic because it's the same picture okay um yeah so let's discuss some solutions and uh when i say let's discuss let's discuss that um but i'm going to make some proposals maybe as the basis for the discussion proposal number one would be to define a goal because currently when somebody starts implementing a library or when somebody has a library and asks themselves what could be the next feature that i implement there's no guidance that we provide maybe we can provide like defined levels of support defined feature sets something like that something with a label on it just saying hey this is uh i don't know uh super duper confined whatever um this can be based on existing profiles and specifications so maybe we can reuse or attach this somehow to auth 2.1 maybe you can use poppy as a guideline something like that um or we could just say within a very"
  },
  {
    "startTime": "01:28:00",
    "text": "narrow context with the core oauth plus pixie plus something else um and just say okay they're sorry um that they're mandatory to implement features for a certain profile and i like that maybe connect does the same thing so you have uh mandatory to implement features for all the id providers and you have mandatory to implement features for dynamic open id providers and and more places like this in the spec and this is of course then the basis for uh conformance testing but i think before conformance testing even it would be important to say uh what we expect from a modern good and universal awards library um number two is to make metadata mandatory or mandatory in the sense that we expect it from any modern implementation um because all of metadata enables libraries to automatically configure themselves to figure out what are the security mechanisms endpoints and so on and this can greatly reduce the friction that you have in implement oauth and i hope that this also does away with the auth configuration hell um so that reduces development time and costs increase and it also increases the value in using libraries because if you have that and you can just throw a library on it there's no incentive to write the oauth flow yourself and um yeah hopefully the libraries can then also adapt to just using automatically some new or or security features yeah um therefore um i propose that this is becomes mandatory in auth 2.1 and also generally that we expect this from modern uh fourth implementations then there's number three um maybe the elephant in the room it would be great to have something like conformance tests um based upon the profiles that we define or profiles that are there already"
  },
  {
    "startTime": "01:30:00",
    "text": "um we or somebody else could provide conformance tests this is a great thing of the openid universe it really helps to ensure that implementations are standards compliant obviously we could also ask the itf protocol police which was established on first of april 2021 um to to do that for us uh but um yeah so we reissue that rfc we really should yeah um so there are many open questions um obviously when we want to go in that direction that's something where i hope to get input from you and uh yeah where we need to think about i do have something else no i'm just asking for other ideas and that's the moment where we can open the discussion thank you daniel great presentation victorio oh he took notes vittorio so i have to apologize for the huge around that is about to flow from this microphone but i've owned sdks for identity and developers for a few years so i have a very strong opinion about some of these and i'll start with sheet sandwich with good things as in i think that the um the conformance test is a fantastic idea would be interesting to see what it looks like because off is so protein but it's a really great idea and anything that in which you can like put a label on the library and say this library supports xyz along the lines of what you're saying so that it's a bit more predictable plus user talking about off libraries is a bit misleading normally the libraries are there to help people to perform some kind of goal and that goal is usually removed from the protocol level like"
  },
  {
    "startTime": "01:32:01",
    "text": "when we operate at the practical level we are doing something which is pretty fine-grained and it doesn't usually map with the jobs to be done like for example people do sign up all the time using those flows but we don't ever talk about sign up so there are like things that the developer the normal person think about when we're trying to perform a goal function and similar which will happen to use off but between off and the function that we want there is a death and so often as the case don't expose the low level because the developer would not be able to do it and so depending on all the things that are between the top level and off it might be hard to do it like you'd have a counterpart of intel inside in which you don't need to know the details of a prefetch pipeline and you just say i like that if there is intel but the library you should expect that a lot of libraries will operate at high level then there are like when you say off we mean so many different things and in general if you look in terms of jobs to be done there are resources as in when you say uh people say off instead they are doing open idea that's because they're trying to do something and then at the point the highest repeat is signing as the resource or the api versus the requesters those are vastly different animals and although when you do resources you can approximate some of the things that you're describing as soon as your client there are huge individual differences that every provider do which have a big impact on the quality of life of a developer the microsoft people have a resource or refresh tokens that can be used with multiple resources others don't have that or they have a mechanism for the metadata in which you can express multiple tenants and there is a proprietary mechanism for selecting between votes from a developer point of view that wants to get the job done the fact that this thing is not strictly conformed doesn't matter for the person"
  },
  {
    "startTime": "01:34:01",
    "text": "that tries to sell the service which is required for that the fact that it's not conformance doesn't matter the metadata uh mandatory stuff we are lucky that uh apple decided to more or less use open connect but despite we pleaded and prayed and threatened they are not supporting the discovery endpoint and probably there are strong reasons to do so in the market people want to do something with apple so the fact that we don't support it is it's just the way it is um [Music] in term of the library i i didn't understand if you were suggesting that we would uh for example start the process of building libraries ourselves somehow or bless them i think that the up off example is a good example of when you try that initiative it's difficult to sustain it over time and it also shows an interesting uh drifting toward the proprietary because google was the main proponent but we still had a special flavor of the library for the reasons that i said earlier because people want to be productive with google and so they add layers on top of it that are not strictly for the um spec and that's it thank you um so two things uh so regarding the lay the last point uh i don't think we should ourselves be producing libraries uh i i don't think that will bring us somewhere so sorry stop immediately blessing them or something is something else but we shouldn't be producing their code ourselves um the other thing that uh you race and i think that's a very important point there's not always the one use case uh maybe there's a use case where like or yeah there's a use case that is quite"
  },
  {
    "startTime": "01:36:01",
    "text": "common to many of the libraries like a sign-in or just getting an access token the easy case but i imagine that any library can also be created in a way um that you can dig deep dig deeper so when i compare to http libraries for example um there's usually a very easy way to send a get request and i get the response buddy and that's it right um maybe there's a way to do the same uh with with a cookie so maintain a session with the server when i say when i'm sending two or more requests um but usually i can also say okay please add a header to that specific request please change the encoding of that specific request or here i want to use i don't know i put some json into this please handle this for me so i think there's a way to to write libraries where you can dig into all the details which you can then use uh to uh to send very specific requests maybe also stuff that is far from the core of auth but i think developers shouldn't have to do that so just as an http library uh i so i'm not sure when i last uh wrote something where i sent their http headers over a tcp connection um that should just not be required from the developers so and in the same uh in the same spirit manner uh users should not be forced to implement http requests themselves and just they shouldn't be thinking about encoding if they don't have to okay justin uh justin richards so um a couple of things here one i want to echo victoria's point that the uh the use of an oauth library is always always contextual and while technically you could also say that http use is also contextual it's not contextual in really"
  },
  {
    "startTime": "01:38:00",
    "text": "the same way because the applications that you're building on top of http kind of mostly don't care about the http itself um the oauth stuff is a really brilliant abstraction of the security properties of apis but it is not a complete layer separation of those properties and two direct examples of this that um that i think inform this uh i will start by saying that i absolutely hear where you're coming from and i also wish the world were better i think that there are a few things that are stopping the world from being better though the first problem is oauth itself it is not a single protocol so writing especially a client library for oauth means at least six different things depending on which flows you're doing um i for a while maintained a a java implementation of a client library they could do all of the oauth stuff for the auth code flow and we routinely have people coming in saying like make it do the implicit flow and we were like no it's a web server you were yeah that's a totally that's a different thing we're not going to do that right and so that is going to be a consideration for any oauth library just the use of it is going to be drastically different depending on which flows you're doing the second thing is that ultimately developers really want to have they want to get to that end state of doing the thing that oauth is protecting and we saw that well antonio sanso and i saw that when we were uh putting our book together originally a few uh is a few years ago now one uh we went out of our way to make sure all of our examples were not provider specific we were not talking about google or facebook or github or"
  },
  {
    "startTime": "01:40:00",
    "text": "anything like that the first review that we got back in uh during uh during the um like the copy review phase with our publisher somebody said this is useless it doesn't tell me how to connect to github so you need to throw out all of the examples and write how do i connect write a client to connect to github that would be a useful book this is garbage no no they they it actually had nothing to do with the specific specifics of that they were mad that we were that all of our examples were not pointing to github.com specifically right it actually had nothing to do with like hands-on implementation that the quirks of things like that totally a different thing and um and vittorio covered that um but the the point of this here though is that uh is that the end users of libraries of this developers ultimately want to just go and do the thing and so in my view this good general purpose library uh suite that you're describing the actual end users of that would be people who are more sdk developers than anything right this is the stuff we would want to be included in a package that speaks a protocol and that is a very different type of thing to architect for okay thank you mike we have a long list of people waiting so i want to kind of allow them to give them a chance to to save something right okay as a practical matter um for instance in the connect world because we have a certification program then we can host a list of certified implementations which perhaps joseph will speak to when he hits the queue and so we have a quality bar"
  },
  {
    "startTime": "01:42:00",
    "text": "as danielle pointed out there is no quality bar for oauth implementations and but we could list quality implementations i do note that a prominent member of our community aaron pirecki out of the goodness of his heart hosts oauth.net which among other things has oauth.net slash code with a whole bunch of implementations on it and i'll just ask aaron to speak to that and what is already happening for the community thank you thanks mike hunt yes this is santiago from rodriguez um i just want to make three short points first one appreciate this this discussion here taking place i think it's not so usual for any working group second point is i think uh issues raised here are kind of generic to some other itf groups as well right so it's about a very general thing about an rfc being out of context when you google it so this might be something like a sidebar referencing libraries or whatever kind of stuff maybe that's versus one idea and thirdpoint is basically adding to some of your examples uh basically so i think um there is one more point it was discussed that um os libraries might be included in sdks yes probably point is it's already right now to a certain extent so typically if you deal with some google or facebook or something there will already be oros functionality within the sdk whereas for some less known providers you will need to use some general purpose for us library and this is actually also a practical problem in my opinion because not that you need to do all alls with different libraries um it also makes the handling less generic in a way and there is for instance security problems i mean most of the security problems seem to relate to cross-site scripting and so on but for instance there's also problem of maintaining os credentials on the server for instance which gets much more problematic if you have different ways"
  },
  {
    "startTime": "01:44:00",
    "text": "of you know how libraries read the secrets and so on and also there is stuff like you know what you what what do we do about refreshing tokens and this kind of stuff yeah so it's operational stuff you need to do logging that kind of stuff that gets also quite difficult when you have um you know multiple libraries you need to support so maybe it would be even nice if sdk developers would think about offering a way besides what they have included by themselves you know to probably get a token from a third-party library included so there is some interoperability thank you i'll ask the rest of people in the queue to be a little bit quick so to allow everybody to get into a market peter peter castleman microsoft um so i think a couple of things um as we've been looking at implementations one of the challenges that we see is that there's a lot of mistakes being made again and again in terms of implementation to mike's point around the quality bar i think anything that we can do in terms of defining a target and a set of acceptance criteria or test cases and implementations whether we put certifications next to that that's a separate discussion but very supportive of that idea of helping to just improve the security profile by having at least some standard test cases and a profile to aim for thank you peter um i think joseph joseph can you hear us sorry i don't think the prompts pop up um yeah so i mean i agree very strongly with everything daniel has said and i could talk about this for a long time um there's some weird stuff out there um i've seen vendor documentation that really strongly encourages people to just generate one pixie challenge and code verifier and to use that always um i've done a lot of work in open banking i'm sorry i forgot to say my affiliation i'm either ortholite or open"
  },
  {
    "startTime": "01:46:01",
    "text": "id foundation or both um yeah even in open banking a highly regulated industry where there's quite a regulation that applies to the clients um securities like eight or nine on the list when people are implementing clients and they just don't get to it some of the checks just don't get put there we've seen that across multiple ecosystems um i mean i think that the profiles and insisting on metadata absolutely makes things a lot easier um fappy insists on metadata and that's made such a difference to everything um as you know i'm heavily some people know i'm heavily involved with the open id conformance program um that's a great program but getting a library through that program is definitely not a non-zero effort it does require some determination from the the developer so it's not just about providing the tooling there's more of a problem here um and i think as a few people made the point about these sdks yeah a lot of the earthquakes do get incorporated into the sdks um there are an awful lot of sdks that have very poor oauth client implementations in them um and that they have filtered through that's one of the reasons for the horrendous stats of our apps that daniel showed is that there's a lot of apps that are all using the same sdk that's very bad um so i mean i think one of the ways forward here has to be a kind of collaboration collaborative effort of all the authorization server vendors where we agree that this is a direction to go and we each individually put effort into tackling one piece of the problem and making sure all our documentation says consistent things that look go here don't implement protocol from first principles because everybody's documentation like daniel says it goes right back to first principles and often doesn't mention libraries even for the places that there"
  },
  {
    "startTime": "01:48:01",
    "text": "are actually good libraries thanks joseph thank you dave yeah hi um so yeah just to agree with what joseph's saying what daniel saying i disagree with what justin was saying um about kind of there's too much you know different context and this needs to you know and this is just for maybe sdk authors yeah definitely the big providers who make sdks if they can use these libraries that's excellent but i actually think this the normal thing should be like daniel said you don't re-implement an http library hopefully you don't re-implement a jot library um if the if the scope is restricted enough you should be able to just use an or2 library so i i've yet to hear a convincing argument why why that's not the case and uh sorry yeah um my affiliation is money hub and with our own uh our own sdk yeah we just use phillips library and it's it's very very easy so yeah very strongly in support of daniel's suggestions thanks dave hey aaron hold on iron one second daniel do you want to say something just really quick uh adding to that this question here um maybe there's an eighty percent use case so maybe twenty percent you can't uh cover with the library and maybe that's fine but i feel that there's like an eighty percent use case here uh where we need to think about okay aaron i'll give you a chance uh one second just in yeah um i just wanted to thanks for teaming me up for that mike i just wanted to say i'm happy to do um to put some more work into the oauth.net site code in particular to better highlight the libraries that are there right now it's pretty much a list that i've chopped up and encouraged people to contribute to but i haven't done a lot of i would say maintenance myself on in terms of like auditing existing existing code um and i do think one of"
  },
  {
    "startTime": "01:50:02",
    "text": "the challenges of that is that there well you know there's uh a lot of options available for any particular oauth implementation so it's hard to sort of say here's the stuff that you have to do and here's when you're done um so i definitely a conformance test would help with that but that is a whole a whole topic by itself but yeah i just want to say i'm happy to to take suggestions or do some more work on maintaining that list awesome thanks say aaron justin super quick um just i wanted to appreciate that uh dave came on to disagree with me and then proceeded to basically make all of the same points that i just made um because really what i was talking about is that when we're talking about these generic things the target of this is not the same as you know like uh like a lot of uh general libraries you're building this to be embedded into something and that is a different kind of architecture and set of considerations that you are evaluating for and that you're designing for and that was really the main point because um by building into an sdk like even it doesn't have to be like a large provider like hey here's google here's how to talk to google it's oh there's an api that i need to talk to and i'm going to build a module in my code that talks to that api give me something that does the oauthy stuff yes i would love to have lots of those things across lots of different platforms available i think that would be very very very useful i just don't think it's quite as uh universal as we would like it to be and that's the point i was trying to make not that this is a bad idea thank you sorry vittorio we we need to move on um daniel do you wanna just wrap it up and then we wanna switch the other one okay yeah uh to wrap it up i do have one more slide um"
  },
  {
    "startTime": "01:52:01",
    "text": "so thank you all uh i think this was a great discussion and i'm looking forward to uh following up when i'm eating this um there's a threat already so it would be great if you could put your ideas into an email yeah so that we can yeah definitely thank you all for the great feedback great discussion let's continue that and see what could be done in in this area let's switch to the last topic here very quickly please stay seated yeah how to oh yeah the plane has reached the position i'm gonna boot you off first and uh which one is this one yes there you go sure yeah so this is uh essentially a repetition from um control uh so yesterday we had uh uh yesterday in the depart yesterday we had a discussion um in the info meetings here at the itf meeting uh regarding the role of pixie and the security vcp um so yesterday i created this slide so i'm going to go over this really quickly um pixi is in your security bcp and i recommend or must in many cases and the reason is that pixi is a really really good tool um pixi provides csf protection so it can be used instead of state um to protect clients against csf pxe is also a protection layer for authorization codes and that's the main reason um we made it a must in many cases in the security bcp with the alternative of using the nonce in some cases if you're using operating connect there are essentially two different attacks that we're talking"
  },
  {
    "startTime": "01:54:01",
    "text": "about here the first one is an attacker sees an authorization response sees the code that is in the authorization response takes the code goes to the token endpoint of the authorization server sends the code and gets back the access token so the attacker ends up with an access token um this is uh bad um but the attacker can only do that if we are talking about a public client because with a public client there's no client authentication at the token endpoint okay so for confidential clients uh for a long time the belief was that if an attacker steals the access the authorization code that the attacker cannot do anything with that however the attacker can do what i call authorization code injection that is the attacker can take the authorization code and on his own device start a new session with the same client do the authorization request response and in the response exchange the original code with the stolen code so essentially providing the stolen code to the same client the client will then use that uh code on the attacker's behalf at the token endpoint providing the authorization client authentication and the attacker will therefore have control over session with the original client in which the code was used that was stolen from another device from a victim the attacker only has to do that when we're talking about confidential clients because for public clients there's an easy attack now the thing is if you have confidential clients and you do this code injection attack both pixie and nons prevent this attack if you have a public client no client authentication and the attacker can go directly to the token endpoint then um only pixie can prevent this attack because the attacker would have to write a code verifier which you"
  },
  {
    "startTime": "01:56:00",
    "text": "cannot know therefore we created a nice table or aaron created a nice table thank you aaron showing what you see here not going through all the details here um the thing is uh csf can be parented by both pixie and nonce that's fine um but if you have a public client that use a response type code then only pixie can provide protection if the code is stolen therefore we say in the security bcp that for public clients pxe is a must because it's the only layer of defense that we have in case the code gets though okay um and yesterday we agreed that we keep this in the um so this is the wording not going through all the details but that we essentially want to keep this uh wording that we have in this security bcp that's not the slide next one um hello it's this little slide set i think maybe so we agreed to essentially keep the wording uh what we'll be doing is we are going to explain what i just explained and what what is on the slides better in the security vcp because it took us a while to figure out why we uh why we wrote this in the security recipe that's not a good sign um yeah and also some changes on the wording in the details uh because the attack is not described at the right place mike mike has a comment on this mike jones microsoft first thank you for putting this together yesterday into aaron that was a good discussion i believe there are cases where you're correct that"
  },
  {
    "startTime": "01:58:00",
    "text": "code injection is not prevented i have thought about some of the openid connect flows such as id token token where you send a nonce you get back an id token in the front channel you get back the code in the front channel and the token and you use are you yeah they said id token token so it's also token and also id token code yes i said the wrong thing um if you're using id token code you get the id token with the non-senate to check you have a c hash in it to check and so the attack is prevented not for the code flow and i agree with you and i'll just repeat for the minutes here i am volunteering to work with daniel and the other authors on language trying to help developers understand exactly when this is essential and when there's other mitigations i'm not changing the basic conclusion uh but like much of this it's subtle and it depends upon when you're getting the cryptographic hashes of the things what and when you're not very briefly to this in this case the code is already leaked to the attacker because we assume the authorization response leaks to the attacker attacker has the code and can just use it in the token endpoint so c hash doesn't have the id token so nobody would accept that id token right but the attacker can just use the code and go to the token endpoint so that doesn't help in this case you check the id token against the nonce you check the authorization code against the c hash and so it's impossible to inject the code are you guys trying to find out whether there are some cases and open id that would also need to be sort of like additionally uh improved whether we whether we can narrow down the cases where the the pixie would be a"
  },
  {
    "startTime": "02:00:01",
    "text": "must but i don't think this is one because there's no client involved after the attacker anyway we will work on this my point is there's still details to work out okay yeah earn just give aaron and i'm gonna close the mic after that i just i just wanted to say that uh to mike's point there are two different attacks being talked about here so the code injection is the attack that is prevented by the c hash but stealing a code and using at the token endpoint is not prevented by the c hash because that's i think that the client is using to protect itself two different attacks and that's why i was trying to make that table which it got more complicated than i wanted it to be and maybe not be clear enough yet so we need to work on that still awesome thank you aaron um daniel thank you for two great presentations do you wanna wrap up for the good okay wrap that up so it was nice to be here okay everybody indeed it was great seeing you all and hopefully we'll see you in philadelphia thank you all bye great"
  }
]
