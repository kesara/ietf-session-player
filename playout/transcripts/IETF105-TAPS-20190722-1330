[
  {
    "startTime": "00:00:05",
    "text": "keep fussing with this maybe why you beat or are the fresh batteries oh thank you are we be at time oh yeah we\u0027re time yeah okay we\u0027re having a little problem with the remote clicker here so why don\u0027t we what if you\u0027ve got one that just plugs in sure I mean I can do the chair sides from here but I think it\u0027s easier for other folks to be able to advanced on slides oh yes I did test it and it worked I\u0027m not sure I trust it okay let\u0027s try oh that\u0027s interesting the ears works well if this looks like an Apple thingy it\u0027s just excited it it looks like a trademark infringement okay let\u0027s let\u0027s get started I think the agenda is a well even though we have had short agendas in this meeting so far I don\u0027t think we\u0027ve ever actually ended early so I\u0027m assuming that we\u0027re going to be pressed for time by the time we get to 3:30 so blue sheets are going around this is the transport services working group if you don\u0027t know what transport services or taps are then you stay and watch and learn Teresa is going to jabber scribe for us that\u0027s helpful for the for the minute taker to get your name so if she\u0027s looking at you funnily it\u0027s probably she\u0027s trying to reach your badge we have a minute taker in the back I see you okay so we need a minute taker so Sarah banks and her son we\u0027re going to tag team doing the minutes as a kind of a learning exercise but it looks like Sarah\u0027s been delayed so could somebody get started in the ether pad and then when Sarah gets here I have I\u0027m using Mary\u0027s clicker why don\u0027t you take leave that one you take this one and I\u0027ll try it at the end of the session you will be no worse off than we are now if it doesn\u0027t work oh yeah well you should take those with the old one you\u0027re giving me that and you\u0027re taking oh you just have matters no okay well okay I\u0027ll try the battery there we go thank you all right preciate it okay so a minute "
  },
  {
    "startTime": "00:03:08",
    "text": "taker somebody please well what we really need is for somebody to capture the action items right you don\u0027t need to record everything that said thank you Cory Cory first we\u0027ll take notes because he hasn\u0027t worked on the drafts this time okay as your as your penance awesome all right so no well anything that is said in this room is considered an IDF contribution if you don\u0027t know what that is you should meet some of that stuff yes today\u0027s agenda you may not be surprised if this agenda looks familiar because this is almost exactly the agenda from the interim meeting which where we made some progress on the issues but there are still some open-open elements and so today we\u0027re going to try to push some of those along so young published in the RFC since before the min set draft is sitting the RC editor q it\u0027s got a Miss Ref it\u0027s waiting for the security document to be submitted and then they\u0027ll be published together we did complete a working group last call for the survey of transport security protocols so thanks for the folks who read and commented on that for the document to proceed it needs a shepherd a shepherd is ideally somebody is not an author but is willing to be a intermediary I think I see a volunteer I haven\u0027t even told you what you\u0027re going to be doing but Philip thank you consider yourself signed up for those of you who don\u0027t know what a shepherd is a shepherd is a person who makes sure that the authors respond to feedback that comes in the review cycle the ietf has called the area directors reviews and and tries to make sure that the right discussion happens so the document progresses so thank you very much Philip so that means that is my area director here Agnes so Magnus you should expect this within the next day or so once I can fill this form yeah we had an interim many of you were there virtually it was a virtual into him interim and we talked about framing what is it the implementation draft which continues to evolve and mature as we learn more and then about how how default parameters are represented you know should applications be able to ask for things without giving the parameters and have something happen the yang model which we talked about here a couple of times was discussed and people continue to think it\u0027s a good idea and then there\u0027s a bunch of open issues with the architecture in the API draft so our schedule it\u0027s unchanged since the last ITF so the goal here is to submit the architecture "
  },
  {
    "startTime": "00:06:15",
    "text": "implementation and API drafts for publication by November I suspect that the implementation draft won\u0027t be done but it sure would be nice if we could all agree that the architecture in the API drafts have done I don\u0027t know four there but if those of you during the conversation today be interesting to hear people\u0027s input on that just so that we can kind of set expectations that either the computers frozen or that\u0027s my last slide so I think we should move on the computer appears not to be frozen okay hello all right hi I\u0027m Tommy poly and I\u0027m gonna give a quick update on the state of framers and we have renamed them in the document to message framers so we can put all of our messages and frames all right do you can you make it fullscreen is it okay other clickers no breaking them tiny or no it\u0027s okay snap fullscreen ooh that\u0027s interesting why don\u0027t you stop clicking for a moment we\u0027re going to try to get it into it that looks right okay see if it works so you want the up arrow all right well that\u0027s ask Marian how about you just tell me I will just tell you great all right so as a status update we did have a pull request to rewrite how we do framers and this was based on our discussion that we had last time and I f-104 as well as in the interim so we did merge that in there were still some open questions or thoughts that people had so we said we kind of come back to those potentially revise the text in accordance with that once we\u0027ve landed it so I want to cover those today and then I also want to share that we did release a version of the framing API in our network framework within Appl systems for swift and c and so we have that in our iOS and Mac OS beta currently so this is a way to implement framers and you can play with it you can test it out and see how it feels to hold you can see also how some of the practicalities of like putting this into a concrete language turnout okay "
  },
  {
    "startTime": "00:09:18",
    "text": "so I want to first cover essentially what the API surface looks like currently for framing based on this latest PR so if you are an application and you have your connection and you would like to add some sort of message framing into it so let\u0027s say you have a TLV format over a TCP stream you can create a message framer object like this new message framer and that\u0027s the thing that you can register all your events on to handle framing and D framing data and then you can add this framer on to your pre connection now the way the text currently describes it is that you add them on and each one you add kind of goes on to the stack closer to the application so you could add a lower level one and then maybe hand your connection to someone else and they could add on more framers I\u0027m one of the issues that was raised I think my max was it wasn\u0027t super clear what happens to the order of all the events when you have multiple framers going on so we will want to clarify that the intention I have here is you essentially will get any start events to start framing from the bottom from the transport up in that order I have a question do you ever any model famous because you could also just like create one frame of it it\u0027s even more complex and especially you certainly could I think the reason to have multiple is for more code reuse let\u0027s say you have like a basic like let\u0027s say I\u0027m doing something for a DNS framing that can work over TCP and UDP I could have one that just does like the length value framing over TCP and then one that strips out some of the and does more interpretation that can work over both TCP and UDP and so I would want to compose them separately you could certainly do it that way but since the it\u0027s not necessarily the taps implementers but it\u0027s more like third-party apps or third-party libraries that would want to be implementing framers II you should at least define what is possible for them to do but that\u0027s a good point so once you\u0027ve added your frame where you can add specific things that you want to communicate to your frame or when you\u0027re sending and receiving so there\u0027s a message context that we already have as part of our send and receive calls and so right now it specifies that you can add kind of special values specific to your frame or onto that send to receive to say you know when you\u0027re sending your header and the specific value so if you had an HTTP framer you could put your header values in there so they could lay it out similarly when you are receiving you are able to look at the message context and "
  },
  {
    "startTime": "00:12:19",
    "text": "see the properties of how it was D framed so there is a open issue kind of around this I\u0027ll get to in a second then there are some events around kind of the frame where lifetime of saying hey this misses framer is now actually active on a connection the connection got far enough in setting up the transport that you are ready to start framing or the connection has closed you should stop framing now this just allows you to prepare and cleanup similarly when you are if you are writing a framer you can send it events to say okay I\u0027m ready for more application data the connection is now ready for my perspective or you can say I hit some error there\u0027s some invalid message that came in just fail this connection one of the points brought up in the issue is that sometimes you need to be able to close a connection without having an error on it so I\u0027m one way to solve this is to just rename fail connection to like close connection you can have an optional error have two different methods to do that so why do you need actually to add your framer to the pre connection so you what\u0027s the other option that you\u0027re thinking of at it just - a connection so at least the way we have things right now you get your connection the moment you call initiate um and so if that action of initiate is asynchronous you know you mean the connection could become fully ready before you\u0027ve added your framer which is okay if you haven\u0027t sent a received anything but if you let\u0027s say you had already started receiving bites or you had already started sending somehow then you\u0027re adding your frame we\u0027re at an unknown point in the stream of data and you don\u0027t know if it\u0027s actually valid to start parsing where you are it\u0027s just a little bit less safe yes right because it may need to send a prefix before it begins framing saying like this is the type of framing I\u0027m doing to the other side so that\u0027s why it\u0027s currently in the pre connection I think if we wanted it to not be in the pre connection you\u0027d need to split out the create connection from the initiate this kind of preheat phase where you think your framer and then activated data right you don\u0027t really need it I guess well there\u0027s an so this is not which are you talking about the start color the make it ready no let\u0027s start this is the start event can generally be ignored it\u0027s mainly if you need to send some like prefix to do like a little extra thing before you begin framing messages "
  },
  {
    "startTime": "00:15:19",
    "text": "it\u0027s your opportunity to do that or allocate memory or whatever you need to do it\u0027s you should be very simple or short yeah come on and so these I\u0027m a slightly pleaser then it\u0027s given to the framer not something you have to write so yes if you are yes these are for people who build the code that is framing and D framing it\u0027s not for the application sending/receiving t the model i I heard of this was the framers would be implicit based on the Transperth premises add them explicitly seem seems like the reasonable thing yes yes right right and so this PR didn\u0027t go as far as to do that but I agree that that should be done implicitly for a lot of protocols that are framed okay as the framer currently has to be added to the pre connection ah can we use it still to influence things like starchiness at the moment yes so I don\u0027t think I have it on these slides there is a method for a framer or a protocol to prepend another protocol or framer on top of it I think it\u0027s called prepend framework and so what you do is you would do your start TLS and then you would add on this other frame around top first reconnection but this thing yes right and essentially this all has to happen before the connection becomes fully ready because otherwise you don\u0027t know whether or not the application has sent and received data and you\u0027re in some weird intermediate state between boundaries so I think I\u0027m asking a variant of this topic yes do you still believe that if I am using taps with a Kramer on one half of the connection or the other half of the connection that I think I only need to do it on one side but it\u0027ll still work fine end to end that there\u0027s no additional semantics in here right yeah for knowledge that the application can convey it to the stack and either on the sender the receivers mm-hm so you could have a taps or non tap some alimentation just doing a TCP stream on one end that does its own HTTP oh yeah and another side that does a framer with "
  },
  {
    "startTime": "00:18:19",
    "text": "HTTP but nobody you start stacking yeah things are listening on ports it\u0027s still the same on the wire and protocol this is about how we signal to the application there\u0027s nothing on the wire great if you want to be up signal we go that\u0027s it that is it I think cently it\u0027s an EMT requirement for taps right we can\u0027t we can\u0027t require and both ends right all right so then on the data path um we have you can get in there\u0027s a new sent message that the application is trying to send you can look at that and you can send your own data to frame it and when you\u0027re receiving you say if there is new receive data on this connection and then you can parse it you can say alright I\u0027m done looking at this and you can deliver data up that\u0027s kind of the basics that you need to do I don\u0027t include all of the parameters here but they are in the document so some of the questions that came up in the course of the PR these are just kind of like side things that you want to get our opinions on one I think my phone got up of like I had originally been discussing these framers as like protocols in the stack I have backed off of that mainly questions like are they should we be calling them currently we don\u0027t I think that\u0027s fine there was also a question about like how much are we referring to things as objects I kept it as objects lab because most of the API document really does refer to objects and stuff like that it does raise a broader question of is this the way that we want to be referring to kind of the operational functions that we have within the document I think it\u0027s clean but if people are allergic to that that\u0027s fine so where are you pre connection equals parameters for us okay I mean because we\u0027re favored the object that is a framer is corresponds to a single connection I mean you might have a constructor or factory to these things but there\u0027s a single instance of this per connection yes so where has your object right so that\u0027s an interesting question so this has probably brought up in some of the discussion on the PR the way that the current PR describes it is that you have "
  },
  {
    "startTime": "00:21:20",
    "text": "a message frame or object that you create to represent kind of the abstract of your framer and all of the functions here take the connection that\u0027s specific so essentially when you get a start it means this instance of the framer curves corresponding to that connection is being created in the way that we did it in network framework we actually have it be that you define your own class that conforms to a protocol and we instantiate your object new for every connection they boil down to the same thing but they do look semantically a little different till isn\u0027t about the questions what a framework is already they are protocols I think they are one possible way to implement parts of protocols not the only way to implement them but I think I find them really useful when I explain them to people I usually say they are as sort of a set of functions that can transform a message into a byte stream or vice versa and then maybe do other things on top so in a de traffic right now says it\u0027s a piece of piece of code I think that\u0027s to implementation of functioning actions even simple transformations between message data and draw transport by transport bytes I wonder what simple transformation is right so maybe we should specify this also doesn\u0027t the frame on that you\u0027re specifying does a lot of buffer management and maybe we can separate the functionality for the transformation from the actual a for management right so maybe we have like multiple things that the frame others maybe we want to separate them or also maybe we don\u0027t want to be so specific in the API try to standardize what no the frame was implemented right if you could open issue for what you\u0027re discussing that\u0027d be great so before we launch into this discussion I just want to point out that we\u0027re at the end a time for this slide so if this but this is I think you know we\u0027ve been wrestling the framers for a while and so it\u0027s worth talking about this did you have a lot more in your door so the only other thing in this this is just for reference if you look at the slide deck I have a link to some of our sample code for what a framers look like in Swift and I include some of it here so you can just see how it looks we don\u0027t need to go through that now it\u0027s too hard to read it\u0027s a reference for you okay so let\u0027s have some discussion so Eric\u0027s near apple just to what Reese was saying I think I like that view of the problem in the a framer at its most basic is kind of serializing and deserializing a byte stream into something that\u0027s messages and then if you want to go further with that and have it do something semantically with those messages like maybe a framer would do a handshake for you at the beginning of some protocol like that\u0027s kind of up to you if you want to define that but you also have the thing that the client application could read out that to the needed message and do the logic for "
  },
  {
    "startTime": "00:24:21",
    "text": "engine but I think that\u0027s the next way to communicate it to people because it\u0027s pretty easy to grasp like I\u0027ve got this logical message I would like it to be a live stream and from there the rest of it kind of falls out it\u0027s good so towards the second question I have a hard time understanding the PR at the first place for me much easier when I\u0027ve sort of the framer object as a frame of buffer manager and then having different object communicating with the buffer manager but this brings me to the question whether the actual API but it\u0027s exposed at the moment is too much focused on the buffer management and a little bit less focused on how to compose multiple framers and how to really spec these concepts or how to build out these concepts this is this is my problem with this API so by the way I like what I\u0027ve seen flickering smooth ER from there and the connections fragment unlike this much better than you like which was better connections was found having a protocol class that implements the framer itself okay but that\u0027s good that was a little bit more what my initial PR was trying to get at so just to clarify what you mean so the data path does you know involve some buffer management and to be clear the part that the taps and lunation needs to provide is the ability to you know interact with the data path so there will be this buffer management so I mean do we agree that these kind of functions just like sending and receiving will exist kind of in this form I\u0027ll show you whether they really have to exist in this form if you\u0027re going for a much more actual language earth think about that you might want to push trainers for example down into a haka offloading or something like the little supplementation which have something framing like that\u0027s implemented EPP F if you want to enable this kind of stuff the buffer management might look quite differently then that\u0027s the reason why I have a little bit of a problem that I think it\u0027s a nice way it\u0027s one nice way of implementing the finger but I\u0027m not sure whether it\u0027s the only way of implementing I see I see right until to to that end we had define is this is a way to do it you must have at least these capabilities if you want to express it differently in your implementation that is fine partially gets down to the reusability of code "
  },
  {
    "startTime": "00:27:22",
    "text": "though like if you know we would ideally want someone who wrote a basic implementation of how to do HTTP framing on top of something to be able to be somewhat portable and so having something that is common is useful in that regard okay this is the way how you add friend to a connection or through a free connection and then have okay this is how you implement the framer and if you want to have an implementation specific other way to implement framers you still have some kind of frame representation you can have and whether this comes from a library or is compiled from EBP effort something else that\u0027s not portable that\u0027s fine still you have common way to at this yes I think that we should leave that open trim they just do if they want okay let\u0027s try to move through the queue quickly and then cause at this discussion what maybe this is what you just said but I suggest moving parts of just a frame implementation to the implementation drop and heap the way that the application adds the framer to the pre connection and the set of functionality that the framer should implement in the put cutter stuff in the implementation draft or maybe a separate draft if this really grows out of proportion yam extrication the same way having tried to implement framers or partially implemented this newer model of remiz a lot of the way the API works is like for example - it\u0027s really painful to do it like that wait it would be much easier to do and I think that\u0027s like an implementation specific like the communication between the framer and the connection I don\u0027t think that has to be standardized in the API I think part of it should be moved to implementation asturias head on set a draft and we talked about the brigde x1 right there\u0027s a lot of implications from the way this works so if we want to standardize the different way we hoped would have read like a lot of comments to the implementation bar like a special amount because there\u0027s so many implications on how the rest of the connection works we talked about received at the next length is basically somewhat becoming irrelevant with frame as active because the frame is going to frame how much they tied once and how much the connection and application set rigid frame high configures economic agreeing with syriza the what we have it\u0027s possibly - exactly so one thing "
  },
  {
    "startTime": "00:30:28",
    "text": "before you just so I can comment so you can respond great yeah I\u0027m agreeing as well what what that means is that you essentially what we are left with in the API just to clarify is we have to have a way to add it and we have to have a way to send information to it so this is the part I\u0027d like a little bit more input in scrutiny on because yes oh yeah yeah we should we\u0027ll describe what it does and then the implementation can say this is one way to do it one of the issues that was raised for adding information to the context is like it\u0027s a little bit vague and I think in general we could have better text around like how do we when we were sending something how do we tell IP or UDP what options to send how you tell a framer to send it\u0027s not super rigorous and I think that\u0027s the part that is going to be most important if this is the only thing that gets exposed so you have these questions up here it\u0027s all hands in the pipe right internal uh no not anymore not necessary not really not necessary cool we can move on um so yeah message traders are not protocols they\u0027re a special kind of thing um you know that we we have this idea that we want to kind of like generalize these things to the objects that we can on I think that\u0027s dangerous because if we do that we\u0027re gonna use it you shouldn\u0027t we should we should give ourselves like a foot gun cuz it gets really tempting and yeah so so you\u0027re asking question if you go back to the Eco back to yeah Here I am about whether there is a better way to represent how to give metadata to the frame uh I think if you want to do a better way to give metadata in the framework then you have to go and have this whole object model for what those metadata objects look like and then the metadata objects and the frame objects are I think that\u0027s this is the point at which we can say like is an abstract API but like too much abstractions is leads to something that\u0027s sort of like unimplemented lis abstract and key value pairs are kind of we understand them we know how they work yeah this is this is just this is a little bit ugly but it\u0027s a completely acceptable not prejudiced you go to the next slide yeah this is this seems like it can go in the implementation draft if you go to the next slide dance receive cursor I just I I\u0027ve done too much with like that database libraries if the board cursor just makes me and yeah it\u0027s like so it\u0027s "
  },
  {
    "startTime": "00:33:30",
    "text": "a fill point here is that yeah there\u0027s a lot of languages in which you know a single threaded cursor is not so I would not even put this in the I would maybe put this is an example and yes can you comment a draft but but make it very clear there\u0027s a bunch of different ways to do this and I think that it\u0027s absolutely correct to say and yes if we get another one for like the Python implementation great for exam that thing with the TLB this completely unnecessary in right because the date object is typeless and that you hand over to the send anyway so it can already include its own make the data query here in minutes comments about refactoring this into the implementation and okay great awesome okay Thank You Tommy none take it aside okay John tongue yeah sort of somehow it\u0027s not rolled halfway training yeah all right I\u0027m I\u0027m I\u0027m quite glad you know how this frame our discussion has turned out I would have said you know this kind of stuff that we\u0027re doing now is way less important so I mean this should be a quick and easy one actually let\u0027s see it\u0027s much smaller question in the frame [Laughter] sorry okay see I\u0027m starting off easy first question is is anybody that really really hates the idea of us allowing that we can specify that somebody can specify a specific protocol Brian Trammell with a philosophical question can you define and allow well "
  },
  {
    "startTime": "00:36:31",
    "text": "sorry can you define the word allowed there are two ways to allow this rate you can essentially say either in the abstract API we have a way to do this and in order to be compliant with taps whatever that means you must have a way to do this yes or you can say hey if you\u0027re implementing a taps tag but you might want to do this and the only really good reason I can see for doing this is if you\u0027re essentially doing recursive house raid so you\u0027re building an L 4 plus protocol like you\u0027re gonna build web sockets as a protocol that you\u0027re going to make available in taps built on top of its own taps implementation where you absolutely must then specify that this new style has to live on top of this over stack does that make any sense I we need white boards for this I think um like your there are two reasons to basically say I want to explicitly specify your protocol right okay you\u0027re a lazy application developer and you just went one way you want and you know me you wanna in you rights get on stack stack overflow that says just flip the TCP switch on and everything will work fine these are the people that I think we should support no I mean I because they exist right there are two ways to roll on this one is you put in the abstract API yes the other thing is you say hey if you want to do this then do some implementation specific way of doing it there\u0027s the point at which you\u0027re going a tap to application that you want to force a protocol on you\u0027re kind of getting into the internals of the system anyway and we just kind of say yeah you can you can do that but do it on the side I\u0027m still struggling to understand the second version the second version sounds like you\u0027re trying to make it harder for be able to do it yeah I mean okay discouraged yes but discouraged by making it hard to use Michael yeah you can you tell us often we you you say on walk and a point with this protocol and then your API has to let you do this yeah so don\u0027t make impossibly hard yeah I mean I agree with that I mean I think discouraged in the sense of writing that you know this is not a encouraged way to do it and it shouldn\u0027t be like the obvious default way to do it but making "
  },
  {
    "startTime": "00:39:32",
    "text": "it hard on purpose seems weird okay yes yeah we need to be able to specify yes yeah I\u0027m trying to see if there are people that have an issue with that like if we if we all simply agree with this which I hoped yes exactly that\u0027s the proposal this is so yes I think we should say that it should I should allow you to specify protocol but we should not so we should say your implementation should allow you to do this I must but you should specifically say that it is up to the implementation how it wants to express this and that it is not standardizing because I think if we do try to standardize how it is then we need a registry of all protocol is that you can enumerate explicitly we don\u0027t want to get into that right exactly so we should allow you to specify it somehow it\u0027s up to you and I think one of the reasons in favor of a lot of people to do it some way into this specific way is if we do not then there is I think more lenient someone who really needs to specify something specifically we\u0027ll kind of like ossify around using certain transport selection options to always get tcp and we change that they\u0027ll be upset yeah so let\u0027s encourage and have the standard way he always protocol agnostic yeah regarding the point of not standardizing it i mean there are you know the next slides talk about these concrete proposals of profiles so this is a bit it\u0027s not in that direction right or whether you take them as it okay yes sir and to me and for the typical use case of this would be that you want to write your application in a tax compliant way but you know that at this point other and your support protocol so you can make it more efficient by also saying that you know even just for testing right yeah so a quick chairs interrupt here so michael has eight minutes left in his slot I clearly got "
  },
  {
    "startTime": "00:42:33",
    "text": "something to say he said it was short we should let him get through it so the question is so near yet you\u0027re the next in line ask yourself shouldn\u0027t wait because otherwise it\u0027s just too easy to like you have an existing application and then you just think the easiest way to move it over it\u0027s just saying pcbs TTP\u0027s appear a so it should be the prepare denied it did agree to this approach where we say it should be possible but you don\u0027t specify the next wave hard well I mean it\u0027s gonna be hard and dad you have to change it to ride two again you have to ride against a new API anyway right so it\u0027s it\u0027s not it\u0027s not like you have an application written on sockets you just bought it and it runs because it\u0027s not sockets anymore so that\u0027s already hard deported to the way where your selective protocol then pointing it to a generic solution yeah there is a you know I think the easiest way to discourage it efficiently is to make profile easy to use so everyone will use profiles and most people who yeah we just disagree with that yeah can I see the next slide please yeah yeah exactly I saw that maybe maybe yeah I\u0027m getting the feeling that I should have see this is this is let me try and help all what is because that is the actual proposal on the table I think and yeah it\u0027s probably more more useful to discuss this so who has Red Bull requested okay one two couple of people three yeah okay so this is a polyp or requested that describe that describes profiles and describes you know you would choose a protocol by way of choosing a profile that matches on so for instance TCP yeah yeah so discuss actually I originally got in line to say that I had almost completely changed my mind on what I did before even though nobody understood it that\u0027s probably the cold medicine talking I so I continue to really dislike the forest transport I like the fact that it\u0027s called force because it fine it kind of feels like you know that makes it feel a little bit discouraged I think we should make it feel a little bit more discouraged than that I like maybe putting like it\u0027s gonna be in the document that in shaft like you know we should use the blink tag you say don\u0027t do this that\u0027s a different a are yeah I guess we\u0027re so probably just yes I think and I was really confused by it because they seemed like alternate proposals to "
  },
  {
    "startTime": "00:45:33",
    "text": "do the same thing except I think that\u0027s what - yeah but they were but yeah I\u0027m a baby Phillips should go ahead and explain Corey wanted for the second one for before half but if I don\u0027t make it I think they\u0027re both puzzles are not alternatives but apps to each other so the profiles is like oh we have this kind of news cases don\u0027t make it so hard then you have to set a bunch of properties so we have a shortcut to say and I want to reliable stream in order speed protocol thank you and whether it\u0027s TCP Oh quick I don\u0027t mind and we have the other one to say I\u0027m implementing this specific protocol that uses in some of its internal state machine fields from TCP I know it\u0027s shitty protocol analogy but I really need TC deal because of this reason so please force TCP or for TCP or UDP because we have badness for those and therefore I think this are not alternatives but these are two ways one is saying catch the common case have a profit then I don\u0027t need to add does lock properties and the other one is the Elm is the reason I really have to force the protocol and this is a rare case and this is discourage you please don\u0027t use it and we get the technical compilers thank you so what about maybe that\u0027s stupid what about a profile that just has one property in it and it\u0027s grant the property name is protocol and the value is TCP if I want to pick TCP so I\u0027m using the same machinery and it shouldn\u0027t be protocol like you\u0027re terrible guy want to pick a protocol should be the name yeah yeah technically I mean that could be just a profile right I I don\u0027t dislike that as much as I thought I was going to when you first started saying it that\u0027s that\u0027s actually a pretty good idea because I think I do continue to think that the main reason that you would end up like forcing a protocol is because you\u0027re doing some low-level stuff right which is why I like to turn on the state for this because that\u0027s what like both Rosten go uses there you\u0027re you\u0027re mucking about underneath the compiler and bad things are going to happen to you okay Phillip yeah I think there\u0027s a community people who don\u0027t think that\u0027s unsafe they think that\u0027s absolutely required don\u0027t remember the woman who came here in the early days of taps who was talking about like these highly optimized TCPS and how can I make how can i how can tap support this I think that\u0027s what this is allowing her to do why are you calling it unsafe I think that that\u0027s unnecessarily but basically you\u0027re you\u0027re disabling taps I\u0027m using the taps API but I\u0027m gonna disable the entire engine right I assume that if you want to do that you would just use TCP where you just call correctly this first "
  },
  {
    "startTime": "00:48:38",
    "text": "protocol property you can send it multiple times for example you can say I can accept the following state combination sorry I can accept TCP or a city or eep because I wanted to to talk sit sit for example and then taps can still race these three against each other but if you want to do I mean if you\u0027re going down that path then you could just as well not specify these three protocols but the service that you want right because your bindings it explicitly require explicitly have some weird knowledge that they use some fields of TCP yeah that\u0027s the case for it okay okay I can\u0027t imagine that yes hey we\u0027re running out of time in this slide so let\u0027s try to activity Q this is a remote I think actually I monitoring people I\u0027m I\u0027m I\u0027m I should feel me moderating this that\u0027s not even my proposal yeah so you go ahead your people more emo it is absolutely essential for apps to be able to specify transport protocols my experience is that there\u0027s too many subtle differences from Braun transport protocol to another to expect apps to run successfully over arbitrary protocols second that permitting arbitrary transport protocols you make testing of apps and support into nightmares it\u0027s one thing if an app can support and assess it on any protocols for small N and that\u0027s potentially useful but arbitrary number of protocols is unworkable using profiles is inviting more variability between endpoint situations and more ways for an application to fail in mysterious ways also point if you can say must always he said must be able to discuss more on this full requests so I mean one question that was biting me about it was like well when do we need to need any specific put Isis fire protocol if Jeff\u0027s is doing is show up say like okay you have property to conceal and how hard it is okay these are the properties give you tips dissipate these are the properties between UDP so when you do I need to specify what is the reason I can hand it here one reason like well one very specific application is only working with TCP because they have shame layer and stuff like that yeah the server\u0027s listening on "
  },
  {
    "startTime": "00:51:38",
    "text": "that protocol only on that test those are not like those they should not really try to do steps at all because they have the DEF specific requirement so I mean to me the application developer I would say like okay if I can specify all protocol that I like be good but then I will use some other and for me if I can\u0027t see ya trying to replace them or make a decision here that makes the application developer to get what they need and that\u0027s the use case of a test for me otherwise I am NOT good these tests I\u0027m going to use like something something that that gives me in specific product because I am using tabs because I would like to try I would like to get the best of human transport services that\u0027s my requirement when I am thinking of these they were as clear that\u0027s what it\u0027s all about we what we\u0027re building should be capable independently it\u0027s a complete replacement future so you can\u0027t say don\u0027t use taps because it\u0027s the one being alternative in the eventual Nirvana work essentially and I say nothing they cannot believe what\u0027s on the slide is the right way to specify DCT because there are many protocols that could satisfy those behaviors I think we do need a way of explicitly saying I want TCP I don\u0027t want a reliable order to congestion control preserving message boundaries Prescott I wanna see CP yeah yeah okay I\u0027d like to get a feel for for my proposal of just saying a property is a protocol and the name is TCP as one of these profiles so would that be something that you like because I think you know I said yeah I said I think that comes out so Michael one question for me I mean when you said like I have profile and TCP do you expect that they only provide that one or do you expect that they also put some fund of really prepared forever here because I can make a mistake that I want to see but the record where it gives me "
  },
  {
    "startTime": "00:54:38",
    "text": "something else if you if you specify a profile I want TCP you don\u0027t need all these things right just just a very simple profile that has only death yeah Apple so one comment just to Colin\u0027s point right now on the watch we actually only allow taps or things based on top of it you can\u0027t do sockets directly so [Laughter] funny yeah I don\u0027t like the profiles proposal if we have also expose what we currently have in the document because it\u0027s essentially another way of saying the same thing it\u0027s a convenience I completely believe that every implementation will have conveniences for how to easily set up the common sets of things however I don\u0027t think we should be defining what those sets are because they will vary based on different use cases today and use cases in the future like our EPA has kind of default sets of like here\u0027s how to set up the profiles but that is not required to be you know cross implementation compatible if we\u0027re looking at kind of forest like the yang model having or being able to describe everything that could be because it\u0027s not really a developer typing it out if you wanted like a big yang model here\u0027s my pre connection you can go through every property and set it the way it needs to and you could reuse that that\u0027s just that essentially a profile that\u0027s very interesting but we don\u0027t need to in the API itself and I think it\u0027s similar for the protocol specific stuff we should say the implementation should have a way to do it but that\u0027s not interesting to make part of API think we need to be smaller in what we\u0027re adding the value that we add as a group music we have the stuff that we\u0027ve gone over of the different transport services we analyze the transport protocols so we\u0027ve distilled the set of things and properties that are useful to put in there so that is the value that we are adding to the API doing these other things are not really what the taps group is the expert in it\u0027s going to be what the implementations do in the future with it so it makes a lot of sense to me but I\u0027m going alright I agree with you but I think Keith made a very good point which is that there is a requirement here applications must be able to specify a legacy protocol if that\u0027s what they need there was a front then we don\u0027t have to say how how it\u0027s done but I think it\u0027s an architectural requirement for the abstract API is you have to be able to do that otherwise your manat if you\u0027re not requiring it to be supported then you know there\u0027s a there\u0027s a full applications users who okay and so I guess like the two options "
  },
  {
    "startTime": "00:57:38",
    "text": "I see there are either something in the document says your implementation should must expose some way of sending it to you a protocol and may have profiles but don\u0027t say what they are or we say well we can even want give a specific property name of choose a protocol but I think that\u0027s maybe further than we really need to go yeah okay awesome as I wrote those PR so I think we still need those mechanisms so we need a mechanism for explicitly choose one protocol I think this one should be part of the core API because otherwise it makes stuff much less portable for this and as a second one I think we might need each product profiles that allow to set up comments of properties and that\u0027s we see these profiles as set the following properties by the way this enables second thing we had a lot of discussion about which should be the defaults for all these properties by including the profiles we get rid of a lot of these discussion and say not the default has to be somehow physically comfortable but ok we have a bunch of default profiles and what your settings what you call this a bundle which is a profile and it includes all the defaults or what you discuss each to each default and have it listed across the document is the same thing right technically for these prophets we have default values and you can still overwrite them so you know your pre connection with the profile then you get something tcd comfortable and you can add further restrictions of further requirements like zero RTT or you can relax some of these bells but you get rid of the problem F as having to completely agree on one set of defaults for the properties I can say ok we move this to the profiles this is one way to do this I\u0027m not sure that that\u0027s the right way but this was one reason for of this proposal let\u0027s cut the line after Anna my discussion so I\u0027m selecting a specific protocol I would like to step back over then really understand the use case behind that because there were a couple people who brought up some kind of use cases for it but those are really not convincing for me for example if you have a very specified spec which usually means you have a user space in the invitation of something which is whatever minimized because we use it undecided advice or whatever then you probably don\u0027t want tip so you don\u0027t want all the flexibility to get it because we wouldn\u0027t make sure that you really really have that one that piece work that you want so I\u0027m not sure if that\u0027s a convincing use case for me also if your server only supports TCP and you to try to open a Greek connection to the server it will not reply so anyway have "
  },
  {
    "startTime": "01:00:39",
    "text": "to for vectors as long but then like if what we want but what everything and anything you wanted in DNA because it\u0027s the wooden Ephrata system so I would understand why this is reading inquired because I didn\u0027t see a good case for it and that\u0027s protocol specifically profiles I I do agree with Tommy that I think this is very implementations there\u0027s a figure especially I think we shouldn\u0027t specify a set of pop a profiles because that\u0027s exactly the flexibility one here so I would recommend to make we put it in the implementation draft but not put it in the API and this is also another general comment I have I think we should actually try to like not extend the IPA IP API too much because the more complex we make it the best incentives people have Germany we should stop at some point hi my name is Michael shorten speaking as TC venture I just want to give a heads up that there are legacy applications that you not only know what protocol they need they also want to specify individual TCP curvatures if you\u0027re interested in that please contact et bien session you will learn about one of the use cases there the specific parameters vacations interested in that case other keepalive parameters and if you want to be generic you will have to think about that level of training for Nora T I can access the parameters possible yeah no no no but there\u0027s a time because just a heads up in case we come to a PC PMF you interested in this specific use it\u0027s a relevant so I\u0027m going to argue that I actually think that having do not have letting applications have strict control over the protocols they usually actually get terrible thing for the ecosystem so the example I\u0027m going to give is let\u0027s say I have an app that runs you know Apple watch end you know talking to an apple to a Mac OS server so I\u0027m using Tommy stack and living it\u0027s a smtp over TCP and I recommend it today everything works great and next year Tommy deploys quick and it\u0027s tactic limitation and my app suddenly starts doing SMTP over quick in an entirely done way just treating it as over TCP and the IETF says no that\u0027s not how you guys seem to be over quick you should use old grief it\u0027s a quick but sorry we have deployed stuff the only way to do it you know in our existing running code is to treat the so some PCP because that\u0027s the legacy we got accidentally I think I\u0027d be a terrible outcome you don\u0027t want that to happen we don\u0027t want protocol should definitely come online just because the stack upgraded we that\u0027s gonna have that\u0027s going to be bad then you go system it\u0027s a treasonous Travis cry again info Keith "
  },
  {
    "startTime": "01:03:41",
    "text": "Moore as an app developer I would love to be able to find out what options exist to connect to appear that doesn\u0027t mean I want a lower layer to choose an arbitrary stack and not just legacy protocols and then and then I also want to say something Harris myself so I\u0027m really in favor of profiles because our target audience for the API drove our application developers in my mind who want something nice and shiny and like some new features and who maybe don\u0027t want all the details of the transport protocol I want to make it easy for them to use right like we have tossed you such examples or we want to show all this API is really nice and easy to use you don\u0027t have to care about all the transport protocol details for that I really want profiles I want to mention they exist and I would like to have profiles in the egg and a draft that they exist and the specific profiles can be appendix or somewhere on the restaurant so I think we will need profiles in implementations but I agree with Romania that I don\u0027t think we should have them in day guy draft so not specified collection conferences and all and I would not want them as a parameter maybe you can mention that it\u0027s possible to when we describe our transport parameters we may say it\u0027s also for implementation as possible to guru in various ways so let\u0027s let\u0027s maybe try to close this out by taking a couple of hums so let\u0027s say have a hum as to whether people think that it is that profiles should be an element of taps setting aside where it\u0027s documented I\u0027ll put do we want profiles yes or no I\u0027m free yes I\u0027m trying to be vague I\u0027m gonna drill down okay we don\u0027t want profiles okay so buddy there seems to be consensus that profiles are useful should the existence of profiles be part of the API specification Humphrey yes okay the profile should not be part of the API specification the existence of profiles not the specifics okay so there\u0027s a few humps but it was it\u0027s stronger for yes then no so you guys look very confused this all supports what I thought I heard in the line pieces of the draft but it\u0027s already mentioned really well you can it know whether you you that now you\u0027ve got "
  },
  {
    "startTime": "01:06:44",
    "text": "something that\u0027s general it can be extensible right we don\u0027t have to specify all the profiles that should exist so I think you\u0027re there are three options and the poll 328 is almost so option number one is profiles or normative first-order citizens again the API you must implement them you should use them here\u0027s what they are and we\u0027re going to even specify a and if you\u0027re going to do that you also need to specify a base set up right the second one which is what the poll request is almost now is it\u0027s in the appendix we\u0027re saying you could do this and there is a normative reference down to there by saying here is an optional profile thing right where if you\u0027re going to do this here\u0027s how if you\u0027re gonna do this I think those are that\u0027s and then the other one is you could do its own document and then say hey this is it maybe that document to standards track and then it\u0027s like basically a tax extension it\u0027s like we have files and then there is maybe a non normative reference in the API drafts saying hey you can have if you want profiles go read this other graph too great or you could put any implementation so there\u0027s yeah there\u0027s a bunch of different so do you think you heard a consensus on one of those I I didn\u0027t know if you\u0027re convinced on any of those I heard a consensus on we want them okay so I think we\u0027re out of time we\u0027re not gonna we\u0027re not going to resolve this here beyond that point Tommy unless you think you can state what you think is the unifying solution here that everybody is going to agree on I think that we\u0027re gonna have two options because I think there was confusion so when I was going to propose three options were one do essentially what the PR is today how do you have profiles and they modify the existing symbols in the API abstract API requires that it takes a profile symbol that is part of the API - maybe I mentions that profile conveniences exist is that it does not modify the existing take a parameter you just say you can build this on top maybe you should and three you don\u0027t mention the middle guys I think that might be a clearer hum yeah - as mentioned right essentially saying like you the API can also add a way to create a set of a pre connection that\u0027s pre-configured in a way that\u0027s good for this but it doesn\u0027t modify any calls on the pre connections it just set stuff for you but I think those are the degrees that so without trying to muddy the waters further option what can we do a home on that do people understand what the three options are enough that they can express a preference okay option one all right I "
  },
  {
    "startTime": "01:09:46",
    "text": "heard the vaguest essence of hum but I was trying not to because then we\u0027re gonna then I won\u0027t do it perfectly and then we will argue about that do it hum now if you want a parameter we\u0027ve entered we\u0027ve entered a nonterminating process I know if you don\u0027t want to change the we\u0027re gonna move on I think I think let me here\u0027s here\u0027s how I\u0027d like to do what I would like somebody to propose the options to the list and we can do an online hum or something equivalents right people try not to get too much into editing the questions who would like to do that I think good candidates are Brian Tommy Michael or Maria okay yeah told me oh honey you\u0027re gonna close the questions to the list try to while it\u0027s still fresh in folks minds and so when people can just do a plus one for the thing that they like and maybe try to move on today did you have anything more on this run yeah what spread a surprise hominid from your the coffee I just made the mistake of transience everything as if this was my proposal I\u0027m not gonna do this this time I\u0027m just going to read to you what this is and see what happens because it isn\u0027t my proposal I\u0027m just trying to moderate this okay parameters and defaults should we specify rather than recommend default values the proposal is the red line here right that was Cory\u0027s proposal if I remember correctly essentially replacing all the text about the default value could be or is recommended with well requirements language should we do that or not and that and enter the policy discussion which is why I\u0027m not going to answer comments I\u0027m just gonna watch you [Laughter] [Laughter] what we were doing is somehow disagree with what the I chatted in the other RFC\u0027s when we did I I want to see if if "
  },
  {
    "startTime": "01:12:55",
    "text": "this per request should be approved or not so this is yeah okay sorry it\u0027s a it\u0027s not a pro request it\u0027s a it\u0027s an issue yeah right okay but I mean if we should do this so what one comment I have like I really don\u0027t see the policy matters for this must here I mean the policy can override the different thing but here is more about the sentence like saying like before mostly this and the ePub some policy whereas before that\u0027s the different factor for me policy could be overridden I was unhappy by kind of saying the default is recommended to be something let\u0027s just be bold it we know you\u0027re exactly saying we must yeah thought before it must be now yeah all right yes allowed Erica near Apple so if you say that a fault must be this is that the default for an implementation must be this or they default in like basically a rescind into the default when I implement this I need to specify this unless the client overrides it that\u0027s plural so at that point we\u0027ve already seen that for transport properties of a large number of protocols different platforms have different defaults are we trying to say that the entire world should not have done that and is do we somehow believe that they will do this if we say it must be that like is this going to be any more effective if we say must because we haven\u0027t seen different platforms make their own choices I think the center question is about requirement language or not so we could have shipped for these cases for for cases where you think that this should be different different platforms Gouri so as I understand it your problem with the issue your reason for following the issue is that the language was kind of like if you feel like it maybe you could save you like how this is the default you know let me let me make an alternate suggestion here the default is because when you stick a must in there yes can we just say the default is so I\u0027m afraid I\u0027m a little confused by this discussion because I thought the question was should we have defaults yeah we\u0027re agreement reopening okay so that\u0027s settled all right good but that\u0027s not requirements language okay no it\u0027s not the coin is like this it\u0027s it is less it is less kind of the area then then what we have "
  },
  {
    "startTime": "01:15:56",
    "text": "is okay so we avoid the lower chance to recommend which is okay what\u0027s there is bad let\u0027s go it is and if we want to reopen this in IETF last call on your life is it should be must then we can have that argument among your ETFs Twitch\u0027s be more fun you have a table comment on this I mean even though not you can even specify whole protocols without normative language yeah and we\u0027re not doing a protocol and the other point to use a must is because you might have some interoperability issues so you know if you if you think that like it\u0027s important that all platforms use the same default because it\u0027s the assumption of the user and otherwise things will break then that something you should make clear and that would be reason to use math but I think still think you shouldn\u0027t use no magic language anyway the reason I wanted normativity language in was because the things we were society cup normative language that said you must do this so we eat when we say the default is well you recommend this because the RSC already said do you thought I think just say is I\u0027m still very happy yeah if you and I say you just click on tradition if you say we were commended but when the RFC says must and done what yeah two dimensions here also override could be not just a client but will all be the existent policy or something and I think the other part is that it\u0027s the default here is how we use it for for the protocol selection and racing so if you say ignore it doesn\u0027t mean that you can ignore the feature necessary it just means that it\u0027s not used for selecting the problem so that\u0027s also different things that I think we have to be confused in this discussion agreed and I think Gauri that the point that you\u0027re making about how you know a taps implementation should not use protocols in a way contrary to how they are specified there should be some text somewhere in the implementation or in the API document that says that if you\u0027re billing a taps API this isn\u0027t an excuse to put in a permanent hack that violates how we think that protocol should be used Teresa again it\u0027s trouble scribe for Keith Moore please define things in such a way that applications behave predictably predictably across different locations and different hosts if defaults are implementation dependent I don\u0027t think this happens I can\u0027t go three with that yeah so Joe anything else cool no okay awesome thank you we gained some time and we it\u0027s in Paris sir the next is arch and API open topics "
  },
  {
    "startTime": "01:19:13",
    "text": "all right so still the next part of someone moderating just stuff that has to be done so for for your information I compiled a list of issues from github that we might want to discuss today if the time permits so we go as far as we can get and I sorted them a little bit across that we might make progress here and they are not completely editorials so if you don\u0027t find things that are look at eternal yield this is my invention so if the first engineer I think we could discuss is the question of Tommy whether listen filtering bruh hey behavior for TLS should be somehow exposed I put the T for T less brackets because I think it\u0027s generally useful feature the business option delivers the connection but doesn\u0027t provide a particular wait to reject connection so the text suggests that receive connection delivers the connection once the Tila\u0027s server handshake is complete but some implementations may want to rate limit or modify this behavior so I think there are three possible resolutions that I\u0027m reading them aloud but I think we should have a short discussion what makes most sense for this improbably just read all for the result us today of these three I like resolution a naturally not received event in your connection events with listen calls um primarily it\u0027s a little bit weird it means we might actually want to rename listen because listen has it\u0027s like listen and except they have meetings and sockets we don\u0027t have it slightly different um we have slightly different semantics for these now in taps but I really like the symmetry between sort of like to receive connection back pressure and the receive back rusher it makes sense to have like one way to be miss Eric as our security one of our security representatives here you have an opinion what do you want to generate an opinion on this well Tommy\u0027s talking so this is something that we\u0027ve discussed a lot specifically we chosen our recommendation not to do this but instead to actually model be listening more on what the existing listen call has which is kind of like a window of how many connections you want to receive I think unlike the connection with "
  },
  {
    "startTime": "01:22:14",
    "text": "general receiving data in which the application has some expectation of how much is going to receive a server that\u0027s receiving connections out of the blue really has no idea how many there could be and adding these calls could either add latency where I essentially have to call receive new connection a thousand times if I want to be able to receive a thousand connections at once and have that be the window so having a convenience to just say here\u0027s the window of how many more connections I were willing to receive it is useful I think that\u0027s slightly different from the what the issue is trying to get at because even if I allow a connection to be received I may want to do something before all of the application for a custom so before TLS occurs we\u0027ll just to do some filtering so they\u0027re related but right not an additional then essentially get an initial knob to say how many in connections and we\u0027re going to accept that\u0027s not TLS specific but we may also need something business what the issue was that allows us to reject certain connections from certain places or like say oh my server doesn\u0027t like under their dolls I want to reject everything for this supplement yeah Dominic\u0027s just that point one of the things when I was first learning sockets I always thought was really strange is that there\u0027s no way to respond to a sin with a reset so something good we know like for you know stacks that are doing you know Carl implementation but actually doing their own PCB so I\u0027m gonna get back in line after listening to tell me I want to withdraw my statement on a it\u0027s beautiful but it\u0027s not practical um I\u0027m not sure I agree that that\u0027s that he is the right way to do this I think we should probably continue to discussion somewhere else I will know that I forget where it was but I think it was in an early version of post sockets there was essentially a three listening like event which is essentially an event that came back the application and said would you like a connection that looks like this before I go to the whole effort of setting up all of the context and stuff here is an incoming connection that here is the remote address of it there\u0027s any information about the remote that we have do you care and then at that point it could essentially return no right like so in post I think it was a call back and it was like it would return to boolean you know do you want this and it could be like no Freddy it would just drop out of those a way to to short-circuit the early processing there are two different problems that we need "
  },
  {
    "startTime": "01:25:14",
    "text": "to address here one of them is back pressure like the fundamental rate limiting problem and one of them is is sort of like early rejection and I think we should probably what you put something in this issue who are splitting into two different issues that it points out that these are two different things that we need to control but I don\u0027t how many more of these do you have to go through these kind of questions of these questions of these issues are we gonna go through today I think six or seven we should probably make a note me issue and move on would be my I don\u0027t think we\u0027re gonna resolve on this okay cool yeah okay okay so but I think the general so just just the feeling is adding an additional event for let\u0027s say pre acceptance a solution we might want to go with I\u0027d be so so yep anyone I\u0027m speaking against it fine I think we have a solution for the TCP layer with my new look my map reconnect any volunteers to write text for this okay I think we go for the next issue that yeah so there\u0027s a issue 158 unidirectional streams for multicast source and sink support we have a selection property that allows to create intellectual streams the main document but no way to credit curry very web the connection is unidirectional so the question is is the mechanism sufficient for multicast I think we want Jake\u0027s input on that just make sure that if the local address isn\u0027t it\u0027s a group address and it isn\u0027t specified any transfer property that it has to be unidirectional receive stream then it should just say oh the connection because then ditch yeah that\u0027s what he did Gouri Fairhurst and i think we should do we could do more multicast I think we should do the least that say about what was already done so I like what was done okay so I think the question is most "
  },
  {
    "startTime": "01:28:14",
    "text": "probably yes and the other extensions might come in with another PR from some of you okay the next question is already answered I think in the last discussion so I think framers are enough first start here less so is there anyone against closing this now closing the issue with yeah okay okay so we need text and we need text for this and the implementation but the issue itself is we have a sufficient mechanism for it so there\u0027s the question between differentially bad selection configurations from connection issues so currently we want just have one initiate error event that could be everything from racing failed to use just specified in unsatisfiable configuration with the transfer properties there are three ways or two ways which I could imagine to solve this one is at another event that tells you that this is unsatisfiable or the other one is to extent the initialization error to contain a reason which could be configurations answered as far away or we don\u0027t have any candidates that certifies satisfy your properties in what I\u0027m in favor of I would like the initiation error to contain some kind of reason could be an implementation specific enumeration or something I think there\u0027s multiple like failure modes and we want to initiate an arrow to contain some information about why it failed I don\u0027t think that we right now can foresee all the different reasons why something might fail and so I would say it should be information included in the error but we can probably not specify all of them hi Brennan Trammell I\u0027m a little confused because I thought and maybe this text came out of the draft or maybe I\u0027m just thinking about post sockets and it never went into this draft um that if you try to initiate on unsatisfiable constraints that should be throw an event it should give you an error on the call itself for eight like the point of an initiation error the reason that that\u0027s an event is that the initiation happens asynchronously whereas everything you know about an unsatisfiable selection configuration happens at calls line you have enough information to resolve the failure at the time that you make the call so you don\u0027t have to queue an event it is it\u0027s not asynchronous and I don\u0027t recall whether that means in two taps her if I\u0027m just remembering post sockets Tommy you have hasn\u0027t returned value oh "
  },
  {
    "startTime": "01:31:22",
    "text": "yeah so when go you have a multiple thing right yeah but um that having been said I still think that we want to add additional information initiation error event because there are other asynchronous things that can that can that can happen right so yeah I would suggest resolutions beyond this one Mike Alyssa I think max has opened two or three issues that relate to communicating specific arrows or adding information to arrows what about just adding a listed in the appendix to you know a list of error codes say these are initiation error is these kinds of errors and explanation yeah max franca and first of all it\u0027s somewhat related I also the nature about initiation ever being very specific right now when it should occur and I think it should just be more generic because the thing I just said about motorcars then it should fail out it should also initiation aright the local versus the group addressed but it isn\u0027t a unicast receive stream so that\u0027s the thing and I think the error events like descriptions of errors or however you want to call it shouldn\u0027t just be on initiation errors but maybe should be on all error events in general that might be useful like you probably always want as much information as you can get from the events Tommy I\u0027m Colin yes so definitely on these in favor of be and generally in favor of having fewer events with more descriptive errors being returned I think this is actually a rather EPI design thing and we would look similar to some of the conversations we have around send sending gating the various completions you can have to send like I was able to set this or I got an error or maybe even whose act having one event that you expect he\u0027s a lot easier for the application to handle right because if the application depending on the language has memory or state of actions that they need to be able to take knowing that there will be one event that they need to handle in completion of an action as opposed to any number of things they just gets a lot more complex with them and less practical to hold API so I think when we\u0027re looking at things like this unless we have a really good reason we shouldn\u0027t be adding extra events that can just be communicated in single events so is there anyone who wants to give it make a PR and may do a make over of the error events to add reasons make a proposal for our text for that there\u0027s some volunteer mucks your warranty "
  },
  {
    "startTime": "01:34:23",
    "text": "okay well you can quit boring so there\u0027s an issue race by Colin consider API that takes panning policy as an input so padding is increasingly supported by Transport so for example you could do a lot a lot of padding stuff in TCM sorry um now was UDP light but you can also do this with quick and we have some use cases especially for implication if occasion prevention in quake that need some kind of control of padding the question is whether we want to expose this functionality within tabs I\u0027m not asking whether how we want to expose them just ask me whether we want to expose it at all the reason why you might want to expose it in the transport is that you don\u0027t know the MTU you don\u0027t know for example if this is petting before interruption how much encryption or overhead this there will be so petting just if you buy AB and too much bytes can just make a packet to bake so it makes sense to give this as an input through the transport so the question is whether we want to include that Eric can your Apple I think aside from the fact that like yay padding in good things to consider padding is one of the things like you said with the overhead and especially on more expensive interfaces and things like that there may be a cost and so that\u0027s something where I think we have to expose it if we want to be able to do it in because like you just said the application doesn\u0027t know how to do it and the the the protocol that knows how to do it doesn\u0027t it\u0027s allowed to do it and that\u0027s kind of definition so Cory if we have a 30 year information then maybe we can do something smarter here otherwise we just do something stupid [Laughter] Dominic\u0027s I mean while I agree this is a useful thing I\u0027m not I mean I also feel like we do want to finish and I feel like you know just because we published the first document says he was never going to be extensions so 100 fish should be you know something that we start thinking about okay what do we want as exceptions to the basically "
  },
  {
    "startTime": "01:37:24",
    "text": "minute so I think there should be away in the API to support some kind of use of petting but there might be different ways to implement it another way is to you know tell the application what the maximum size is the message can happen the application again with the petting or the other way around 2000 transport what the message sizes you want and then the transport in do something on this this can be problematic if you want to have read the patent or for example heck happy within quick then you can\u0027t easily do it wasn\u0027t the application is the transporter so you can you can you can in the interface could talk about the message message size instead of using petting as a function okay cut yep so somebody\u0027s going to start a API miss X next show a bucket to put it in okay so suppose we just add a label on get up for the extensions and put this is the first one under the label that says it\u0027s not the first one scoring you know I know in a bit time here but um everyone have a sign the beginning we said we just like to finish these things yes so what did we do with this list when we finish we will decide that when we decide whether what happens with the working group I mean what I want to do is publish these three documents right if there are other documents that might happen in this group it might happen somewhere else yeah super stress are quite happy unhappy Independence someone that says under other things rather than trying to decide no yeah no that\u0027s what I\u0027m saying I\u0027m actually I\u0027m saying I\u0027m making a stronger statement that we should just we should note it somewhere where we are keeping track of things that we could do in the future I\u0027m not saying I\u0027m trying to push it out I would suggest that the github issues list is the perfect pose to do that stick a tax ID stick a tag on it that says no we create a new tag that\u0027s like hey things that are gonna happen in extensions like we have decided as a working group please don\u0027t go in the core Docs but we\u0027ve also said just working group that we want to do them so and this is why if this is a this is a pretty easy thing to add right like so it\u0027s it\u0027s a message context sorry property right Sam yeah it do you think that there is other future work besides extensions is there a different tag that is future work we just got a few worker yeah we don\u0027t even need it I mean like extension you don\u0027t wanna use it yeah you\u0027re right we know we use the word extension because extension might mean something exactly I thought you were using anyway that means something you know yeah so if you droid I will do that right now "
  },
  {
    "startTime": "01:40:29",
    "text": "yeah should send return message contract this one are is some kind of issue that started as more as a semantic one but turned out to be ever actually be two questions the first one is there are concerns that and often unused convenience return value could be harmful in some languages which is the easy one so just drop it if you don\u0027t like it the second one is more interesting because sent hours are currently want one matched with send code so if he\u0027s issue a San call you get one sent error if this data wasn\u0027t sound so for the first one the question is for the first sponsor of the question the original question whether said San should return a message contact as a convenience or not we have the resolution to either remove the message content of return value or have it option one as a convenience and make it optional for languages that have problems with unused return Louis is there any time so my initial confusion here was what is this return value so if I call send and I give you a message context that here\u0027s the message I want to say will the return value ever be anything other than what I passed as the message context now what will always speed the message context to your past which is a little confusing then so the only case it is a relevant value is when I pass like a default or nil or something I didn\u0027t specify anything and then for some reason I want but then I realized that I want to care about what the value was how they didn\u0027t want to create something so if you don\u0027t want to create a message context but afterwards would like to introspect on which was the source of rs.10 for this telegram or some other values that the transport system shows that\u0027s the only reason or if you want to later on use it for use it for reply matching what would you which we edit this is the only reason these are the only reasons where you want to use this return value you just always pass a value if you care about using it and that should be very cheap it should be easy to do but it\u0027s you should pass the handle that you want because we already take that yeah and and if there\u0027s something you want to learn about what they want the transfer system chosen tit and that should be a queryable parameter or something like that and not not a result of sin which is just okay plus "
  },
  {
    "startTime": "01:43:31",
    "text": "two this seems like it\u0027s very very very C C API driven and it seems like is leaking sort of like specific language semantics I like I like Tommy\u0027s revolution here okay so can we go ahead and close this yeah close the first half on the second tab is the more interesting one I guess the question is centers are cruelly one-to-one match with send calls so if you have an application that\u0027s stupid and that writes by twice and at some later point that\u0027s filling up some send buffer at at some later point in time this connection dies and there\u0027s still stuff sitting in the send buffer and there\u0027s a few kilobytes then you get a few thousands send arrows back so the question is is this the behavior we want or do we want to have another way by saying either you could just get one cent error and some reason or some message context object telling you which sense failed or have some property how to control the aggregation of these events document currently says that especially for each cent call you did you get the sent error event potentially as I read the document currently it would be we are out of time for this session so now you\u0027re eating into a discussion of yang models your assumptions that every send will eventually either get an error or a set right okay so it\u0027s not it\u0027s not going to make it a sender it\u0027s a will definitely get either successes go so that so they know that there\u0027s something there\u0027s a thing is like a a final error on the connection after which everything after that gets neither success or failure I think we should take this discussion to the list I have more but I think we "
  },
  {
    "startTime": "01:46:34",
    "text": "should discuss the yang model yeah so the next questions are basically how to handle protocol stacks that are not equivalent draft appointed existing implementations and implementation should separate our protocol specific bits so perhaps as a way to move forward you could just take the text with links to the issues and send those it\u0027s individual messages to the taps list and we could try to get a little bit of discussion on there and see if we can make some progress okay but it does seem if we don\u0027t if we unable do that seems like this is a good material for an interim yep I thought he said you\u0027re closing the first half hello so I\u0027m not going to talk a lot about Yang actually but mostly about testing tabs because that\u0027s what we were using the yang model for in the hackathon so max Jake and I were basically participating in the hackathon the entire week and and doing various things like implementing multicast but what I focused on wasn\u0027t testing so um what we are using yang for right now is so you have we\u0027re creating a pre connection and you have to specify a remote endpoint a local endpoint transfer properties and security parameters as you can see above and of course all of these have to be filled first with like some content and now what the yang file gives us is that we essentially substitute all those four parameters and the initial like filling those parameters with data we substitute all that with a yang file which contains like some remote and point address or hostname and port and transport properties and security parameters and all the stuff it\u0027s in a single file it\u0027s easy to refer to for example in a test case I can say ok I have my UDP client to Jason and then I throw it into my tests and they send something I get something else I get something back I check whether us what I expected and the advantage of having it in a model is that it\u0027s easier to port across implementation so I I\u0027m going to go back to this later on so this is sort of their benefits of Yang that I got and the pain points is "
  },
  {
    "startTime": "01:49:34",
    "text": "actually or it\u0027s not actually that much of a pain point anymore once you have it but getting it to work is first a little bit weird because it is a different implementations of yang but pi yang was too painful for validating instances of models for some reason so what we are using for pi EPSA kaliya c++ library you\u0027ll have to install this library and you have to build it and we got it to work so there\u0027s a shell script so if you check out our repo and you just run this script it works on linux and mac OS on our machine so actually it\u0027s not that bad to get it to work but it\u0027s sort of a little bit ugly but yeah so what we did with this model was I wrote some tests basically sending data and then I\u0027m running an echo server and getting back data so I test whether TCP works what are you DP works without gos works and next steps could be to also test like for example failure modes and while testing these of course we found some issues too in the code sandbox to fix but also I looked a little bit more at the model and for example the security parameters right now in the model have the identity and the algorithm as required so you always have to specify a algorithm and I think it\u0027s not always necessary for example if I give you a certificate and in a certificate the algorithm is already in there right so like my application doesn\u0027t necessarily have to give me an aggravatin just because it gives me a certificate and also maybe I\u0027m a client maybe I don\u0027t have my own certificate and then I don\u0027t have to give my certificate to like the API right so they could both be optional depending on whether I\u0027m a server or a client and TLS for example so this should probably be optional and then another suggestion was to sort of do more sanity check for this pre connection and endpoint configuration that we are getting so for example we could check if at least one endpoint has been specified in this JSON file right because either it\u0027s a client or a server either needs a local or a remote endpoint and we could check that and we could also check if there\u0027s transport properties and there that exclude each other but if we don\u0027t do that then our implementation should throw an error that those properties exclude each other or something like that so again what the yang mother gives us is that we have the pre connection at the endpoint sort of all in the same file specified and we can do sanity checks on them first and then we can throw those files into the implementation and see what the implementation does with it and hopefully my tips does a similar thing with the with the young file then for example Apple implementation does so that\u0027s the basic idea also we could add "
  },
  {
    "startTime": "01:52:34",
    "text": "profiles to the yang model but I guess we would have to agree on profiles first right so two really interesting points that came up in the hackathon was first the yang model includes an interface type and I remember the discussion we had on interface type so days in a yenna AF type yang module which contains lots and lots of different link types so this 802 11 is in there I found it I\u0027m not sure I actually found a different cellular like links but I guess they probably also in there and then there\u0027s like hundreds of different link types that I don\u0027t really know but right now the yang model that Jake wrote import sort of those link types so you can like say I require Wi-Fi and then you\u0027re using this and in our API draft we are not pointing to any specific registry of different link types or different interface types but we leave it up as implementation specific so it could just be a string saying Wi-Fi or like an enum or something so I was just wondering like do we still want this or I don\u0027t know just found it interesting because Jake just used the module right so and the other thing which we maybe really want is that we could also model our output or essentially what we get from the taps implementation so for example we get a TCP connection with a specific remote and local endpoint and over an interface and maybe if we model this this connection stage that we get as an output then we have a portable input which is a pre connection and endpoint configuration and we might have also in portable output that is the connection that we got maybe or just the protocol that we got and then we could test whether we given a certain input whether our implementation produces the expected output and if both of these are portable then we could run essentially a similar tests on different implementations and portability and like checking that this is actually valid or invalid input might be something that becomes easier with yang because otherwise we would probably have to check it in some other way but also maybe not and so this is what I was wondering whether there\u0027s any kind of like interoperability portability tests that we can define and then also of course for testing we might want some tests whether or implementation satisfies the API contract so we\u0027ve been talking a lot about them different different issues that came up when implementing and maybe if I do this and with my application return me one sent event or multiple or something like that and we could put those into test cases and then it would be easier for for example two different implementations to make sure they are all doing the same "
  },
  {
    "startTime": "01:55:35",
    "text": "thing and the correct thing so those are the ideas that I had that I mean this is actually where the profiles idea could go should go right is this is really big part of that very sorry but then the other point regarding testing this is something that we discussed at the hackathon them so maybe if other people have thoughts on this too if we want to check the output of what the tap system ends up doing basically but we give it so we can either have you know essentially a standard way in which all the systems export what they chose to do but that may be a little tricky because when we have more heuristics we\u0027ll do different orderings will be hard to validate the other alternative is to essentially have another big molar whatever configuration for a server and go through in pairing or turning off parts of the server so you know make the server only listen on one address or address family or only one protocol or something like that and validate that the client is always able to do some racing that ends up connecting you don\u0027t necessarily care about the order as much as we do the end result that we are still resilient to however it works so that\u0027s another approach okay yeah so that would already be possible with the current yang model I think we have one yang for the server one thing for the client we sort of let them do their thing and then we see what the output is listening to you that I don\u0027t want for us because there\u0027s a new gang one is that just a different way to implement profile okay so did another idea that we had to model not sure why it\u0027s not on the slides but we could also model that a given transport protocol implements reliability check implements order check like this kind of thing right so we could add that to the model as well I\u0027m not sure if that\u0027s what you mean by profiles I believe you\u0027re just describing a way of describing profiles not that we don\u0027t need profiles you\u0027re just saying that you could describe them using a I actually because you can just do it if it\u0027s a configuration fight right that\u0027s what we\u0027re kind of talking but it doesn\u0027t have to be a configuration fight it\u0027s a configure set of parameters for configuration I thought the point of the chart the point of profiles was to help applications request useful sets of behaviors so what she is coming up with "
  },
  {
    "startTime": "01:58:37",
    "text": "descriptions of useful sets of behaviors in doing her testing writing that stuff down and making it available to applications developers make makes it so they don\u0027t have to do that same figuring out that she\u0027s doing right I thought that\u0027s the point of profiles yes absolutely I do publish a minion in a trap so people know and sorry but no I do not think it is a reasonable expectation for like an arbitrary iOS developer to learn how to write a yang or how to use a yang model so I see those as completely separate points so this is for me for testing and like me and Knox and she can use it perhaps other people can also use it but like an arbitrary like application developer we won\u0027t ask them to use yang right fine like model models more than just the profile from transfer properties right you move the endpoints and things like that so you would have to have assistant if you just want the angle for the endpoint and right now would have to change and you would have to have separate models for the endpoints and model for the transfer properties and so on also you would have oh we could model the profile and using the yang model okay so we have zero minutes left also you\u0027re now on your own carry on your mr. yang so I I guess I haven\u0027t clarified question like are you suggesting that we have profiles in the yang model but also define the profiles in terms of the features that they implement or are you suggesting that we do not have profiles and instead only have the features and you define all of those in a second I think that that would make the yang models less useful in my opinion just because part of the point is that they\u0027re relatively simple to edit that looking at them in a way that\u0027s similar to looking at the source code at least in my mind part of what I have to to do is that you edit it encounter the way you edit the source code but it\u0027s easy right but it\u0027s but it would working in several different locations and so like "
  },
  {
    "startTime": "02:01:38",
    "text": "the same reasons that it\u0027s easier for the user to to use a profile instead of using all of the individual emanate an application developer the same reason that it\u0027s easier for an application developer to use a profile instead of using all the values I think it\u0027s easier to define a profile for the application to specify a profile for the application developer there is to the foreknowledge or maybe there\u0027s an editor the egg model that would make it reasonable to do that um but I it\u0027s not immediately apparent to me what that would okay I suggest we figure out whether we want profiles and the API draft or appendix or whatever before we discuss further like where it goes are you can you say where people are missing goodness oh you\u0027re done okay well thank you thank you everybody Oh before people leave the room I\u0027m sorry I would just like to propose that we do a virtual interim in September the anybody have a real problem with that we can work out the dates online okay I see some heads nodding and thumbs up I don\u0027t see anybody saying that\u0027s a really bad idea okay thanks everybody thanks to Cory for taking notes and for Theresa for Jabbar scribing and we\u0027ll see you online "
  }
]