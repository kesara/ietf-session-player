[
  {
    "startTime": "00:00:04",
    "text": "not based on a spinet you have Steve I don\u0027t well justin is online etiquette we don\u0027t think he minutes then which was three feet the discussions again someone take a few notes it\u0027s just important what things like major decisions ideally someone who\u0027s not a presenter who sheets are being passed around three stars we have a couple documents so we have a couple of documents in in ISP evaluation the authorization server metadata is in the evaluation the charm document since so that\u0027s good native apps document is it\u0027s pretty much in the end of the processing so it would be an announcement okay Wow okay okay so young so it would be that authorization server metadata and the char document I in is evaluation and then 85 document is further along and announcement would be sent fairly soon we have one new working group item added to the to the milestones which is the mutual TLS profiles profiles document we discuss it in Chicago and there was a clear interest in in working on that topic so we gotta update it in its already I think version 2 of the document and we\u0027ll talk about it later today the token exchange in a rice floor I\u0027m working good last call but we need more comments but we\u0027re also going to talk about this net are you here in the room whoops you forgot that I was "
  },
  {
    "startTime": "00:03:04",
    "text": "meeting so when he shows up he can probably tell us a little bit about the status of the char document because it was waiting for an revised ID are there any any other sort of employees there is that info on and some of the other documents I don\u0027t think so from the authors of the document No authorization server metadata\u0027s nothing you guys have waiting for the IHG - yeah waiting for right up good we also met last week or at least some of us for the our security workshop in series this was the third workshop we organized net series and the first one in Darmstadt the second one in clear and this is now the third one it\u0027s an it\u0027s an intent to sort of collaborate and discuss topics with security researchers who have been quite successful in in doing a formal analysis of our protocols and also discussing other security related techniques I think while it\u0027s labeled as OS I think it has it\u0027s equally applicable to people working on cozy and other security mechanisms laws for IOT or we also talked about the formal message apply but TLS just brought I was again a very good workshop the information is uploaded so you can find slides and papers there so we thought that said we talked about formal analysis that was done in in in this group in HDA ETH series but also from the guys in Korea who are now in Stuttgart the stood cath university we talked about crypto related attacks antonio from adobe who had successfully compromising hacked many our systems talked about the recent vulnerability discovered by the JW e which mike is going to talk about a little later so that was a good set sight way into the cryptography was quite interesting you looked at curve cryptography and he gave a give us a good tutorial um he also had new ideas on uh Noah\u0027s and I hope that some of them actually trickled and down into the OS working group are the PCP ideas for up for implicit flow and etc and we also had some disk son what we could do to improve our way of working will um I will share some more detailed notes I haven\u0027t had time to do that yet about the the workshop itself and point out specific presentations but it was really good workshop and thanks to Dawson and and of course the team in Surrey for putting "
  },
  {
    "startTime": "00:06:04",
    "text": "this together and spending the time to sort of play the agenda review the papers really review the slides and so on so it\u0027s good - thanks thanks dozen for today the first thing we will talk about is the mutual TLS profile we have the security topics person is going to do that William would speak about the incremental authorization and then we have they already mentioned web token test current practice document so that\u0027s what today we have another session I didn\u0027t put it in the slide deck yet nap since you are here now could you say a few words about the current status of the charr document if you go to the microphone so I\u0027m not second round number as such I\u0027m one redditor of the author document I think I have applied most all of the remaining comments already and I also have talked with Mike about the registration of some of the parameters into the IANA Ayana registry and we discussed and ordinary connects has actually larger set of things - resistor so we thought that it might be a good idea to just do it without not the connector we don\u0027t touch off jar that means that we don\u0027t have to go through the another iron a review so so um all right can you put up for the guys who haven\u0027t been closely following the discussions in the ihe could you explain a little bit on what the type of comments were doing the IHC processing and why it took so long because the document has been in processing already for a little while all right so the loss is three comments came in April 24th right a part of the reason why it\u0027s he was taking long was it it\u0027s been that troubling season for both me and John right I\u0027ve been almost always that\u0027s a desiccator that the document is like of course the transition be our biggest change is that so the one of the most substantial comments which we acquired during I yes you review is that that so before we were composing the values in the Ricker\u0027s object and only Lucas parameters right and we are fighting to use something on the Lucas object but now due to because of the comment that\u0027s saying that it\u0027s probably much better to just use what is in inside the because object we decided to do that now as a result we kind of remove the "
  },
  {
    "startTime": "00:09:05",
    "text": "possibility to add a parameter like scope on the the query parameters right and that was I thought that was a good thing but then we were waiting for some developer feedbacks as well and the feedback was that some of the some of the implementations are actually using scope as a switch to switch the Processing\u0027s so it seems to be a good thing to leave the possibility to use that possibility to provide scope duplicating or existing as a query parameter just as a special but from the security point of view just use what is inside the rigours object it\u0027s just full convenience so what I have done is in the spec it\u0027s clearly saying that it must use the parameters in the Lucas object right but it may and client may send the parameters in the query as well just for the backward compatibility or other things correct have you submitted the updated version already was Mike just before the lunch yeah but it\u0027s uh it may be good to post a mail to the list and to explain some of those changes yes I\u0027m also I\u0027m going to push that to the to the idea for the other thing the other comment actually was provided by Brian actually that Ayana staff was also provided provided by Brian but the other one which could have been substantial was that the danger of using Lucas URI if you don\u0027t vet the request URI wall and you know naively fetch the content of request URI it may pose a DOS attack to that authorization server so we\u0027ve also put some comments about that in the security consideration like like looking at uh like following up from the discussions we had last week like yeah we have to think about what could implement this get wrong and it\u0027s sometimes very basic things since for adding some additional stronger wording and explaining the possibility is that the client the malicious client may point the URI to extremely big file clogging up the ports or it could I just "
  },
  {
    "startTime": "00:12:05",
    "text": "learned it from you know it could specify that request authorization because your eye as it because you are right so it\u0027s going to be recast right so if the the authorization server actually doesn\u0027t cut off you know just after first fetch it may just continue fetching until their order in the Sabha memory six is exhausting so that kind of thing I have had it to the security conservation perfect okay thank you thanks okay okay any any other items I should add to the agenda anything some material bashing nope you want to use the clicker I look forward to it thank you ah so I was forget if I should introduce myself I usually don\u0027t Brian Campbell from ping I\u0027m gonna present on the status of the mutual TLS profile for oauth2 it is now in draft two as a working group document yeah a little picture of Prague here from the last time they\u0027re all here so what is the mutual TLS profile for OAuth it\u0027s basically two things kind of rolled up in together into one I\u0027m gonna give just a little background on it here hopefully give some context so it defines mutual TLS client authentication to the token endpoint as well as a means of doing mutual TLS sender constrain access tokens for protected resource access it\u0027s a wire why are we doing this um the TLS client authentication is something that\u0027s been done in practice for a number of different deployments and implementations for a long time we\u0027ve never actually written down and Specht out how to do it so it\u0027s not necessarily inoperable or at least not referenceable by people that are using it or other profiles that need to do it senator constrained access is something that binds what are typically bear access tokens to the client certificate so that they\u0027re no longer bear tokens and they can\u0027t be replayed or even played the first time by some other entity that doesn\u0027t control the private key corresponding to that certificate I\u0027ve been told that the bank\u0027s particularly European banks need these for some server-to-server API use cases that are being driven out by some new open banking regulations this spec as it is right now is referenced by fappy the financial api working group in the open "
  },
  {
    "startTime": "00:15:06",
    "text": "ID foundation in the read and writes api security profile as one of one suitable holder of key mechanism to use with OAuth which is a requirement of Fafi and it\u0027s also referenced by the open banking api on security profile so there\u0027s already demand at least from the standards world for applications of it how it works just real quickly mutual TLS client authentication how that works is it\u0027s for authentication of the token endpoint TLS connection is made which is always required anyway but is established with mutual concert if ik identification the client includes the normal client ID HTTP request parameter in all requests the token endpoint which allows for easy identification in the client and the a s is able to use that client ID lookup the client configuration as appropriate and verify that certificate established on that channel is the right one for that client this was done intentionally to allow the trust model to be to be somewhat open and flexible because people deploy these sorts of things in a lot of different ways and with that said there is some metadata around indicating for support for this and the nature of it both provided for the client metadata as well as the authorization server metadata Center constrain excuse me mutual TLS sender constraint access tokens they work by associating a hash with a certificate that\u0027s presented during authentication to request the access token so the the access token requests they took an endpoint stiphu gets presented there per the last slide with mutual authentication and a half of that certificate is included in the access token itself following that to actually use the access tokens the TLS connection from the client to any protected resource is also mutually authenticated TLS and the protected resources then matches the certificate from the TLS connection to the certificate hashed in the access token itself and if those don\u0027t match up its it rejects the request in order to kind of facilitate this in an interoperable way at least as interoperable as we can be around standardizing access tokens there\u0027s a new JWT or jack confirmation method which is the call it the x.509 certificate sha-256 thumbprint confirmation method a little wordy but x5 t / s 256 is shorter sort of and this is building on top of RFC 7800 which defines the sort of overall confirmation structure confirmation method structure and this is the new sort of method under underneath the Seon CNF that defines for confirming certificate confirmation so here\u0027s a hash of the certificate basically included in the access token this defines the syntax of it using the facilities provided in 7800 and it\u0027s not here but we were talking about this in "
  },
  {
    "startTime": "00:18:07",
    "text": "the last one Justin sort of pointed out that there was a lot of easy on sort of pointed out that there is a lot of talk about using introspection but there were a lot of assumptions made about how exactly introspection would work in conjunction with just about any holder or key mechanism then weren\u0027t clearly specified in the document and so the latest revision calls that out pretty explicitly it says that the same data as the the jock confirmation claim is returned in the introspection response and it\u0027s the responsibility of the protected resource to actually do the validation of that on this document now request registration as Ciena of CNF the confirmation claim as a token introspection response parameter and just says it\u0027s a brief statement that says it has the same semantics and format as the claim of the same name to find in 7800 that\u0027s largely to account for I don\u0027t know maybe it was an oversight maybe was just something we recently realized that you\u0027re gonna want basically the same kind of data around 7800 both in introspection responses as you would in in John and so this draft just sort of it\u0027s not retroactive Lee but tries to retro actively define the contents of 7800 as being relevant for for introspection responses and then in turn picks up the the certificate thumbprint confirmation and then just I don\u0027t know if you can see it\u0027s a small an example of each here on the left is a jock confirmation method you can see just the hash of the client certificate there and the token introspection response is unsurprisingly very similar except it\u0027s a JSON response on HB 200 with the active is true otherwise the claims look the same in a confirmation mess of this design um so as I was working on this and just sort of as a proof-of-concept to myself I took a couple of cots products an authorization server and a resource server and utilizing what was already in place around mutual TLS support not specifically for this profile but just the ability to set up the two products to require mutuality less from the client and some existing configuration and customization hooks around that I was able to implement in support for this profile using existing product functionality which maybe hasn\u0027t been entirely stated but was sort of an implicit requirement of wanting to be able to do this in a way that\u0027s easy for products and deployers to do on a very near-term timescale and not requiring major infrastructural changes and so no it\u0027s only been just recently adopted working group item but there are a lot of people interested in this work proceeding with work dependent on this work and moving forward so I\u0027m hoping to request that we consider taking this "
  },
  {
    "startTime": "00:21:07",
    "text": "into working group last call sometime soon so um how many of you have read this if the latest version or one of the earlier iterations since the last IDF meeting see a few hands two four five six okay yeah I hope you have not just written it they\u0027re also ready Sean Leonard says I read the draft good work I would like to see more algorithm agility for the confirmation method ie more than just sha-256 hard coding any algorithm is not safe because once it is crypt analyzed implementations will be hard-pressed to move off it also how can the certificate be transmitted with the token if a relying party wants the entire certificate as far as cryptographic agility goes the agility is intended to be implicitly supported in the same mechanism that we support thumbprint agility for certificates in J the JW x-series the JW s and j2 ve where there\u0027s the thumbprint and new hashing algorithms can be defined through basically a new claim name and the convention following this is just the x5 t which is x.509 certificate thumbprint and in the the pound shorthand for whatever the algorithm is so you know at which time sha-256 is broken I hope I\u0027m not standing in front of you guys doing the same song and dance when that happens but if it does happen in each upgrade there would be the need to define a new compromised confirmation method under 7800 that defines the hash algorithm to use and and just say hey it\u0027s the same thing but you have shit with I don\u0027t know what the latest is sha-3 super coolness with these parameters for to an 80s since you are seeing adding a new Iverson just means registering a new buddy registering a new confirmation that\u0027s what John Bradley yubico so if somebody registers a new hash algorithm for certificate thumb prints as part of JSON web tokens then that would automatically happen in be usable in the JSON web token somebody would have to take the extra step of registering it for the introspection endpoint but in principle this is as agile as Jose and we could perhaps put some sentence in there that called that out I don\u0027t know that if if somebody "
  },
  {
    "startTime": "00:24:10",
    "text": "wanted to send the entire certificate then we would have to create it somebody could do another extensions back that said this is the confirmation method to do that we talked about doing that in it amongst the authors and I think it adds to the confusion having too many methods and the problem is that if you give the Reliant if you give the resource server the entire certificate they think that they should do something with that certificate other than just comparing and they\u0027re most likely going to get that wrong so I\u0027m not keen on passing the entire certificate down as part of this spec but somebody if they really wanted it could and of course just do the math the certificate is already conveyed doing the TLS handshake we don\u0027t want to send it twice okay so we\u0027re backed up here I\u0027m Sean said okay yeah another hash algorithm claimed name can be defined but an example would be good as well as text in the draft this says what you said to find a new confirmation method etcetera and then he says yeah I wanted to see how it interacts with the JWT spec jose spec etcetera like will one upstream registration be sufficient or will you have to do one specifically for mutual TLS TLS so off and justin says if the CNF is registered with all the semantics of JWT for its sub bits then it should flow through the introspection write the last one - Justin\u0027s point yes so at least for confirmation method a new hash algorithm defined as a new confirmation method would flow through the JWT as well as introspection if there was a need for new hash algorithms in the in the Jose a layer of things around the J to be K some plant related pieces or the Jade of us J to be thumbprint related headers those would be separate registrations as far as being explicit about how to achieve our the majority with this method I think that\u0027s a good good point and should some some text should be added to draft similar to what\u0027s in the other places I sort of jumped there with the implicit assumption that it could be done but some clarifying text would definitely be worthwhile as far as the the full certificate just this might come up as well but there\u0027s a number of number of reasons not to include it one would be that it\u0027s it\u0027s potentially very large and we\u0027re working with access tokens here which are space can train to some extent all the parties involved here do you have access to the full certificate through the mutual TLS channel so there\u0027s really just the need to have a secure pointer to that in the token itself and finally this only provides recommendations on how you might convey the certificate information between the authorization server and "
  },
  {
    "startTime": "00:27:12",
    "text": "resource server which is how they actually do that is always at the discretion of the two parties involved so if they really wanted to do a full certificate they they could do that through whatever method they would they would otherwise do Jon gently toss News Europe I would like to add that as far as remember we choose or we decided to use the fingerprint because we just want to give the RS the option to to verify that the sender of the access token is actually in possession of the certificate so how did the sender actually proves that it really is a possession of the certificate and the certificate validation is up to the TLS tank yes that\u0027s very important to point out so in the resource server the resource or was just supposed to fetch the certificate from T elastic buildeth the thumbprint and compares to the confirmation method in the access to that\u0027s it I think we more clearly need to spell that out that no trust shame verification is required expected needed whatever I got I got that feedback during the security workshop as well from um to implementers a particular Google I have a question did you consider using hash of s PK ISO public key info instead of the whole certificate just was using SCP just riccati pinning which is a smaller pattern it allows to the heart stays the same after you reissue that cells for different expiration date and stuff like that we considered a lot of different options the hash of the full certificate seemed like the most straightforward if at which time a client has to obtain new certificates basically they all need to obtain new access tokens which didn\u0027t seem like particularly burdensome things since all our clients are typically in a position to obtain your access tokens to the normal flows anyway so it\u0027s it\u0027s possible but the certificate hash seems like the most straightforward most easiest to implement in an interoperable fashion it depends what you want to accomplish because if you hash the whole certificate you obviously also in fluid for example the subject field sure and if you just if you otherwise issue use the same key for multiple different subjects and I don\u0027t I don\u0027t know why would why would you want to use the same if you really issue the same certificate why would you want to use the same key like you have some cases where this actually happens and where it matters "
  },
  {
    "startTime": "00:30:14",
    "text": "okay but it\u0027s probably worst point to think about it\u0027s a good question so Justin said that was okay for his answer Sean says some method of retrieval will be it would be helpful he says if it\u0027s available to all he would like to see text that describes the availability some method of retrieval would be helpful and if it\u0027s not in the token then it has to be stored in referenced which has downsides and it\u0027s available to all would like to see the text that describes how or at least the fact that all parties have access to the certificate itself a couple cases for SPI has multiple issuers can occur if you\u0027re running bridges for instance the patron saint of legacy technology today so I\u0027ll talk about peak averages but and also if you\u0027re doing short-term certificates right reissuing assert every like five days or 90 day right like let\u0027s encrypt us you wouldn\u0027t necessarily want to do I know let\u0027s encrypt doesn\u0027t apply in today but they might right and you wouldn\u0027t want to reuse you have to reissue your access those tokens just because you\u0027ve essentially just refreshed the timer right so that\u0027s I think that\u0027s a pretty good argument for John Bradley yubico again I would take the counter-argument that access tokens should probably have around a five five minute to our sort of lifetime and that\u0027s what clients do is refresh them going back to the resource server so you rotate the certificate you then make a call to the token endpoint with your new certificate and get a new access token it\u0027s adding extra complexity of having the client try and parse out the spki out of the certificate I think it\u0027s putting more burden on the clients where it\u0027s just doing a hash of the of the certificate out of the that\u0027s provided by the TLS stack is probably the maximum that you\u0027re gonna get a lot of developers to do lucy Lynch so several times now people have stated at Mike assumptions like tokens need to refresh every five minutes or whatever if the draft is based on those assumptions calling them out in the draft would be good Sean Leonard says I disagree with the Hat I disagree with hashing the spki the relevant security token is the certificate not the public key the public key can be extracted from the certificate not the other way this also assumes that the cert is available to all parties I agree with John Bradley just now "
  },
  {
    "startTime": "00:33:15",
    "text": "right probably did would it make sense to add an additional confirmation message that says for example in addition to sha-256 let\u0027s say sha-512 to address some of those cards so the only other thumbprint that we have registered in the specs and how was sha-1 which shit using sha-1 as an extra example was not top of mind so if we were going if we wanted a another thumbprint then probably going back to John and actually doing a char 3 thumbprint which nobody\u0027s going to support for some decades but I would rather have somebody have Mike register a new thumb parentis since he did the sha-256 1 we could do a Chaudhary thumbprint that would be ignored but could be use it as an example that will heal Jax just just to clarify the sha-1 thumbprint is only defined for Jenny be SJ w + JW k it\u0027s not actually applicable here this just follows the same pattern but emitted the sha-1 variant Mike Jones Microsoft I was just going to make a clarifying point that in the JW s spec where x5 T is defined it already gives an example of how you would define ones with new hashes so rather than reproducing that you could just reference that guidance right there not defined and registered yeah I had planned on borrowing wording from the garden yeah don\u0027t define something just for the purpose of defining it if it\u0027s never gonna be easy I wholeheartedly agree that that\u0027s why we chose one method that would be secure for the long foreseeable future and easily implementable okay so there were a couple of reviewers already and I the me orders seemed to be a few clarification needed nothing major but still an update may be appropriate maybe you you even get to that doing this week but I think starting a working group last call it doesn\u0027t seem to be too far-fetched don\u0027t have a few reviewers who could do a review during the working class call to Austin that\u0027s cool did I see your hand net costing you also okay do any anyone who is not awesome author of The Rock okay nice that you want to no kidding "
  },
  {
    "startTime": "00:36:16",
    "text": "it would be nice to have two reviewers who are not the authors of the document so that we have some some solid reviews during the working group last call there are a lot of comments though Justin says I have a cop I have a client who\u0027s implementing this in the near future so will be will be reading this in depth wonderful okay thank you Justin edit perfect thanks buddy or do you have some more no clock is ticking the astronomical clock is ticking standing ovation sound as usual with your thoughts okay and that\u0027s why we were joking John Smith was not really central in directing all together I was fine so hi um this is Austin from yes Europe John Bradley from yubico we\u0027re gonna present the current status of the or security topics PCP so we\u0027ve been working several yeah month on the topic of coming up with the best current practice 400 of security which in the end is an evolution of the security threat model which is defined in RFC 6890 n-- and the security considerations sections of our C 60s 67 49 and 50 before Chicago we more or less concentrated on on how to protect on how to secure the redirect based flows in all of implicit an authorization code Rand and we came up with some recommendations that we presented last time during Chi cago and track we worked on different or we focused on a different topic which we are going to present today which is access token leakage and in different ways access tokens can leak on resource servers today we will be focusing on one specific use case which is access token fishing by a fake resource server and this this scenario this threat angle is is really emerging because a lot of people are starting to use OAuth in the context of standard api\u0027s and in this context the basic the basic assumption is the trust model underneath off trudeau as it have been defined in NRC "
  },
  {
    "startTime": "00:39:16",
    "text": "68 19 arm is enlarged or it\u0027s no longer the whole so what\u0027s the setup the setup is a client wants to access a resource server which it exposes to a certain standard API for example for accessing email texe calendar data so for example the J map our working group is working on this kind of stuff and also it\u0027s been mentioned that there is work on open banking API is across Europe so also in those cases clients are going to connect to resource service that they haven\u0027t seen before which means are the relationship is being established at runtime health electronic signatures and so on so these kind of API are merging all over the place and we have to make sure that security are of those use case and those I play ap is is is insured so our assumption is that the client is being configured with the RSS URL at runtime which in the end means that the trust model is going to change in the past the developer got to know the URLs of the resource of on the a as up front during development time notice is going to change what does this mean so let\u0027s assume the client obtains an access token from the a s and then the usual invocation happens so the a s issues on access token and the client uses that access token actually invoke a request a process at a resource server so fine so good but what if the resource server is a bad guy and the resource server takes the access token turns around and just impersonates the client and accesses the legit resource over on behalf of the user which is perfectly possible because in the end the client doesn\u0027t know whether the resource server is going to talk to is really the ledger its resource or but for this particular user and this is this kind of API so what are our options and we we have sketched out three different kinds of countermeasures or classes or categories of countermeasures and we would like to do is we would like to present those different categories of countermeasures to you some of them or most of them are familiar to the working group members and we would like to gather your feedback what do you think should be the best way forward what the working group should be recommend what should be documented the BCP so one option would be yeah let\u0027s let\u0027s work with metadata let\u0027s let\u0027s tell the client where it is safe to use access tokens this is more or less consistent with the way today cookies are typically handed because the browser typically are only cents to cookie to "
  },
  {
    "startTime": "00:42:17",
    "text": "the origin of the of the of the of the cookie and nowhere else are we could we the a s codes could publish some some some information which resource over the a s knows and where it is safe to send the access token to but the the downside is this puts all the burden of ensuring that it\u0027s implemented securely to declined and developer and this is since this is the large end of the whole ecosystem we would like to come up with potentially different more robust ways to do it just jump in the view right so our experience with OAuth and our experience with OAuth implementers is that this is the sort of thing that they typically get wrong or don\u0027t do which is why it\u0027s not really our first preference that\u0027s right it\u0027s also hard test that\u0027s right so the second option also well known to this community is audience restrictions so in the end with what we can do is we can restrict the access token the scope of the access token to a certain audience our resource server and in order to cope with that particular threat we must use an audience that it\u0027s bound to the transport so we can\u0027t use a logical audience for just a simple reason the resource server for example if using the on the HTTP response for the status 401 as it is defined in our C 6750 can just tell the the DES client oh please mint let me mint an access token that is good for calendar for the calendar server so this doesn\u0027t give any indication which server or the client is up to talk to right so that\u0027s why we think a good a good way would be to use a the physical the URL that the client is sending the the access token to as the audience alternatively and that this has been pointed out in the workshop in Zurich we could also use a fingerprint of the TLS certificate yeah which is we share some merits I think let\u0027s talk about that later on but the point is the client has to tell the the authorization server hey please meet me an access token which is good for that specific target and the a s doesn\u0027t need to know well this resource server is is alleged one right so in the base level and I have been told by developers of our products that a s is not not not necessarily know the RSS that their access tokens are being used for in the most employment I\u0027m familiar with das knows all the resource service and if that\u0027s the case the a s can do more because we\u0027ll come back to that later on right so there are some objections that have been raised to this in the past hi Justin where the resource server may be actually split across multiple domains so there are some edge cases where some "
  },
  {
    "startTime": "00:45:18",
    "text": "people want an access token that would work across a virtual resource server that had multiple routes so that would have to be something that we would address if we went down this road yes yes you could get two tokens but I would suggest let\u0027s let\u0027s let\u0027s further this one let\u0027s first proceed with our presentation we will come back to a summary slide where all the countermeasures are being listed which I should serve as a foundation for a discussion okay so let\u0027s assume for the moment on the client tells das where it\u0027s gonna use the access token um there is a need for a certain parameter to tell the AES resource indicators would be one potential options and then an access token is being created which is bound to this particular URL and if the client sends this access token to our s acts and RS X uses the same access to met ours surprise RS RS one can validate that the audience in this access token doesn\u0027t match to its actual URL and will refuse to to process the request it\u0027s it\u0027s fairly simple no one raised that meeting so we have to turn it a bit potentially in the direction of the resource server X that makes more sense right okay it\u0027s it\u0027s funny to have entertaining towards right okay so if the a s up front knows that the URL that\u0027s being passed by the client does not belong to one of the resource servers that this a s is protecting that it can just refuse to create our access token which means that you would directly see an arrow and this is fail fast yeah good okay as I said there are two different options I don\u0027t want to dig into the details we can use the URL which is which allow us to have a really fine grained audience even for a multi-tenant system and so on the TLS fingerprints would have the advantage that if someone is able to obtain a certificate for the domain of the alleged RS that would be discovered as well because the access token is is buying is bound to the to the concrete public key that\u0027s why I think it\u0027s worth considering um right in a heavily district heart Amazon and "
  },
  {
    "startTime": "00:48:18",
    "text": "heavily distributed environment you may actually have a number of valid TLS or certs back in the same resource server so fingerprint wouldn\u0027t actually yeah but it\u0027s something we can consider but in principle it would be sticky to whatever you the client would make the call to the resource server and likely would go back to the same ways the same geographic cluster no Jenkins net the other toward the TLS certificate one is if it\u0027s a web app you can\u0027t get the TI stiff get out of the browser that\u0027s that\u0027s the biggest problem okay um could you please take note because this is this is the kind of you know oh you have any Neal can you just write those pros and cons down thank you very much because that\u0027s that\u0027s the reason why we can present it let\u0027s have the discussion afterwards please okay so because there\u0027s all yeah I mean I mean so the third option and then we we can like can go into the discussion is proof of possession that\u0027s something we have been working on as a what you go for last couple of years which means on the client or you called it sender constraint access tokens so there are different different terms hold of key is another one but in the end the idea is that the client somehow has a key material and is able to demonstrate possession of this key material and das amo associates the public key of this key key material live the access tokens do you want to explain that sure this is essentially the the presentation that Brian just gave us one of the ways that one could do this we\u0027re also working on a way of doing it with token binding but essentially the client yeah obtains a certificate with or contains a token proving its controls a given certificate gets a access token back and again makes a TLS connection or a connection which has some sort of applications level signing to resource server X if you\u0027re doing an application like when you\u0027re signing you have to audience restrict whatever it is you\u0027ve sign obviously and then when the bad RS goes to replay it at the good RS it doesn\u0027t have the private key necessary and in a sense the audience restriction restricted what application layer token that you\u0027ve created if you\u0027re doing it that way would have the wrong audience which is similar to them our first proposal the resource server "
  },
  {
    "startTime": "00:51:19",
    "text": "one is going to reject that access token so our Trent our various options for the transport layer our token binding yeah okay um so thank you John sorry the different proposals on the table um Brian just presented the Missha TLS Tov we also have the token binding which which is on the way which both belong to the same camp which is the token is is somehow bound to d2 the TLS connection well there and there are two two armed proposals on the table on the application layer which is the sign for crest proposal by Justin and in the j-pop proposal by Ned and John I think right they all have different different characteristics properties and so on in the end and that\u0027s that\u0027s defined the question and that\u0027s why I want to to kick started the discussion what should the BCP recommend I mean there are a lot of different options and what I\u0027m hearing from from people out of the working group there are much too many options right so what are we are we gonna are we gonna suggest or recommend people also there I just gave an overview of all the the are the options which is presented and also something else if someone has an idea what else we could do do which add something or shall we start a discussion no not Sai Kumar on all right just for clarification Jay pops how come Jacob actually has been taken to MPLS right so it would be half of a pub yeah okay so G pub initially heads the transport side and the application layer side and this this refers to the application side of it yeah Annabelle Beckman Amazon regarding the audience restriction two comments a echo Justin\u0027s concern we do have use cases where not only do we need to use access tokens with multiple different resource servers we do not know at the time the access token is requested what the precise origin of those resource servers are so binding that token to the audience of the resource server would be a problem for us again to echo dick the TLS server certificate problem it\u0027s not the case that\u0027s solved by replaying and hitting the same goal the same geographic cluster because even within that you may have multiple search server certificates may ask you a question yes um why do you need to use the access token "
  },
  {
    "startTime": "00:54:20",
    "text": "on multiple different resources what why there is a need I would like to understand that because getting multiple access tokens is harder what it\u0027s possible it is possible but it\u0027s asking more from implementers for reasons that are largely opaque to them okay thanks at Turf Alphonse Google um so it seems to me that the two mechanisms here are the two classes of mechanisms that actually address different threat models it seems like one of them prevents the token to be sent to the wrong receiver and the other one prevents that hoping to be used by the wrong client and really I think the threat model that you\u0027ve sort of described in the beginning that we\u0027re worried about is the latter where the wrong client is using a token that shouldn\u0027t be using the token and the solutions that prevent the wrong receiver to get the token just as a side effect also happen to come to that that that\u0027s right and so the more direct mechanism to address the threat seems to be the one that addresses the one client from using a token so the proof of possession things since you were asking like oh there\u0027s too many of them how do we explain which ones to use if they\u0027re if there is a legitimate reason to also address the other threat model the wrong receiver getting the the token that I think that would then it necessity the audience restriction mechanisms and the threat model that is about preventing the wrong client from using token I would think the proof of possession with that Thanks their card Amazon so just to confuse you guys in Amazon we are using audience restriction with URL for a massive deployment and so we\u0027re we\u0027re using that to help solve that problem around how do we prevent somebody that\u0027s receiving a token from reusing it somewhere else okay so one of the advantages of the audience restriction is that it doesn\u0027t require that client to do any new crypto so while it isn\u0027t as necessarily as strong a protection it has potential deployment advantages in that it might be easier to get client developers to actually do it unless we get token binding everywhere in which case it will be dead easy right "
  },
  {
    "startTime": "00:57:20",
    "text": "this is Turk again um right I agree I just found myself sort of having to think quite a bit more about why this like I feel like there\u0027s a mechanism that does the audience restriction but really what we want is we want to make sure that the wrong client isn\u0027t getting its hands on the token and using the token I found myself thinking much more about like why a implies B why having these audience restrictions actually gives us this property that we want like for example how do you make sure that the client can\u0027t be tricked into asking you know for token that actually refers to the bad server and so forth like there\u0027s probably answers to all those questions but it seems you have to make moreso leaps of faith or then when you actually notice the actual problem you want to address which is that the wrong client is using great with the audience restriction we\u0027re making the assumption that the client can be tricked to ask for a token for the bad guy but allowing I mean that\u0027s a different if the user getting access to the bad guy is it different attack than the bad guy getting access to the real resource so we\u0027re trying to prevent the bad guy getting access to the real resource if if the bad guy can completely hijack the rest of the session they can make the rope you know they\u0027ve obvious they\u0027ve already created the wrong client and got the user to login whatever application it is into their batteries or server so there\u0027s nothing that we can do at this level of the protocol that would actually stop that because it\u0027s just a legitimate Olaf client at that point so I think in certain profiles of off you could make you can ensure that the S declined points only to trustworthy resources but it depends on the concrete profile so for example in the any mobile connect use case there is another trust anchor which is a discovery service but we do not know how other profiles are going to use a wall so our assumption is that the or a decline can be tricked into accessing a URL which it doesn\u0027t know anything about right so not secure Murrell number of search again I\u0027ve been I just check the record I\u0027ve been preaching for audience restriction back in 2011 I thought I thought that was a very good solution yeah but actually since then I have kind of changed my position because that one\u0027s simple and good but can\u0027t solve the problem one legitimate server list email resource Allah is actually compressed that\u0027s correct so I\u0027m going to us send the constraint I "
  },
  {
    "startTime": "01:00:24",
    "text": "think there are some other merits are pros associative audience restriction that do not are bound to this rat right so in in deployments I have seen in the past the audience restriction serves the purpose of letting the or giving das the chance to issue access tokens tokens which only contain a data that the RS is entitled to C which is a kind of a privacy ah property but yes your comment was completely right the client has to be aware of that fact right so how do you get two different access tokens so in my former life I taught you Telecom we use refresh tokens as the anchor and then fetched different access tokens for different resource service based on that refresh token but it\u0027s something that\u0027s not specified in D and it wharfs a space but it can be done within the boundaries of it yeah I mean there are other reasons for having the resource indicator there may be different token types at different resource resource servers or different claims that you want to put in the access tokens so people have added this for other reasons so it happens to also provide an audience route a way to do audience restriction which is useful for this but it has other useful properties and you may want to do it even aside from from solving this token theft problem so audience restriction doesn\u0027t solve the problem won\u0027t work the token leaks at the authorization server through some miss configuration through an intermediate box it\u0027s exfiltrated from the client intercepted in other places it stops the bad client from tricking the the bad resource server from tricking the client into creating token for it but doesn\u0027t solve as many of the possible threats as that\u0027s proof of possession yes Brian speech from coherent I think the leftmost option is publishers legit RSS is isn\u0027t really a solution to your point it puts a lot of requirements on the client it\u0027s over being polite and it doesn\u0027t yeah maybe it\u0027s already happening we\u0027ve kind of taken it out that it doesn\u0027t solve the problem of cross play between the legitimate listed RSS and it puts a lot of burden on the client that probably won\u0027t happen the audience restrictions stuff is there are benefits to indicating where you\u0027re going to use it as you guys have mentioned potentially varying the content of the access token and varying the cases whatever more or less customizing the access token for the particular resource as well audience restricted that was the the "
  },
  {
    "startTime": "01:03:26",
    "text": "intent of the resource indicators I\u0027m sorry for the bad name but that was the name of the draft about a year year and a half ago was to facilitate both of those things it turns out that it was very controversial because the I think a lot of people want to do a lot of different things with it and the concept of going from our URL or some indicator on the authorization request to an actual audience is very it\u0027s conceptually sort of easy to think about how you might normalize or generalize that but it\u0027s very very difficult to write down how to do it in in text so that might be difficult I think the same problems would exist here and you get into difficulties of interplay between the authorization endpoint and the token endpoint and using that parameter I was very interested in the idea of using the TLS server cert because it sort of immediately takes away all those concerns but apparently there\u0027s deployments where that you know the variants of the cert itself would make it there\u0027s other concerns that come up so maybe that\u0027s not viable proof of possession solves the problem as many have stated as well as other potential problems that took in linkage mutual TLS that I just talked about solves it really really well but it\u0027s it\u0027s a niche deployment kind of thing it\u0027s not I don\u0027t think widely applicable to the broader the broader ecosystem of OAuth it\u0027s gonna be for things like open banking where there\u0027s big money interests and and regulatory requirements around the ecosystem you just could do indicate why you think that\u0027s a nature um deploying mutual TLS is a huge pain in the ass and under certain constraints or requirements it can be done and it solves a lot of problem in those cases but I don\u0027t because of the the pain-in-the-ass factor I don\u0027t think it\u0027s gonna be anything more than specific sort of niche deployments that it\u0027s useful for so combining I think it\u0027s great but it\u0027s very early and it it it remains to be seen whether it\u0027ll be widely available and implementable and and when application signing seems really simple when you start to think about it and have a and have a solution in mind it turns out it\u0027s really really hard to get right and do it in a bra interoperable manner that actually addresses all of these problems I know Justin will say no no no we have it it works but it it works under the way that he thinks about it and wants it to work making sure that the right parameters are included in what\u0027s on what\u0027s not signed does it protect against this particular threat what other threats it\u0027s really hard I\u0027ve personally gone through that moment of being up in the night like oh I could invent an application signing protocol that would solve all these problems and you know after thinking about it it\u0027s not that easy it\u0027s very difficult so "
  },
  {
    "startTime": "01:06:26",
    "text": "that\u0027s my diatribe I don\u0027t know what to do you gave us good reasons to not recommend any of those that are that are useful but there\u0027s also downsides to a lot of them so in terms of being able to kind of come up with one recommended practice Brian you your description sounded like a little bit like maybe that combination of audience frustration and possession is sort of like depending on sort of their pros and cons in different deployments and in some deployments you may be it may be feasible to just use the proof possession maybe some of it will be easier the driver in the future while some others serve can stand with an audience restriction ease did I hear that sort of no no I\u0027m asking you yeah I know I was necessarily saying I think audience restriction something to enable audience restriction is potentially something that could be rolled out sooner to a broader audience because it\u0027s sort of just adding an additional parameter but it would still have to be standardized and deployed but it\u0027s more likely to sort of take place it turns out it\u0027s also I think harder to standardize then than we think it is yes josslyn\u0027s just just one one one salt I mean all the options listed here are fully specified none of those option is captured by an RC right we have some drafts about some of those so my question is where we focus in each arm right we somehow have to decide okay sure sharing my thoughts having written drafts or considered implementations along the lines of many of these there\u0027s there\u0027s pros and cons of both yeah it may be that there isn\u0027t one perfect solution because we were a toolkit and the right thing to do for a native app may not be the right thing to do for a server application that\u0027s also its own you know if doing mutual TLS is a pain in the ass on the server its pain in both asses on on on a native app yes every wave plane in everyone\u0027s ass Justin says I agree with Brian that HTTP signing is limited to places where it makes sense HTTP isn\u0027t simple to deal with it was never meant to be Universal just useful just useful I also agree that M TLS is a huge pain in the ass and we won\u0027t see it everywhere either why not both right and Justin should have also pointed out that application later signing actually is useful for ending and where you may have middleboxes that want to provide security inside the firewall they yeah "
  },
  {
    "startTime": "01:09:34",
    "text": "so there are different use cases that for each of them off the top of my head I think that audience restriction is probably the minimum thing that we could do that actually gets rid of that\u0027s generally deployable and gets rid of sort of eighty percent of the of the problems that were currently seen and probably that in combination with other things depending upon the deployment scenarios so we have to pick some of these things that we actually turn into RFC so what I what I heard so far and I\u0027m sure we have to continue that discussion us on the million years so this is a starting point but I but so far I heard at least some of the things that we we could get rid of particularly a s polishing let you did RSS I think there was no no one sort of arguing for that one which is the least something I also heard in for the audience restriction I heard more people arguing against the D less server certificate fingerprint as opposed to that URL did I hear that correctly Brian let me utilize that Brian sure we sit down and write on the draft for audience restriction which covers both options and then have a discussion in the working group potentially based on resource indicators sure I also heard from unapproved possession side I heard net saying that the che prop part of it actually went into MDL s so is there not much left from the chamber microphone the part of j-pop that we\u0027re talking about for application level signing which is similar to but slightly different from Justin\u0027s didn\u0027t go into the mutual to us do you think that\u0027s worse right to pursue in the future or is that sort of like should that be deleted from that list as I sort of not to attract this somebody not me he needs to choose between Justin\u0027s proposal and Nats proposal for something very similar but also my recollection was that Chester\u0027s proposal visits a lot of excitement in a group yes so like we think acting is not the problem is application-level signing is hard I don\u0027t think that that\u0027s necessarily the fact that nobody wants to deal with it isn\u0027t necessarily a reflection on one of the proposals being better than the other but they are they are very similar proposals so we should probably only do want the they\u0027re very "
  },
  {
    "startTime": "01:12:35",
    "text": "similar except except for all the ways that they\u0027re different in fact the only thing they have in common is it their application there I did want to maybe just circle back I do think we should pursue in TLS and tow combining that\u0027s I mean we\u0027re doing that anyway yeah so I mean I just wanted to clarify I hope that\u0027s not on the table to take them off but I I think they\u0027re they\u0027re maybe not sufficient for more immediate needs or wide enough because em TLS is sort of niche and toe c\u0027mon Ian\u0027s at least some future period of time away but that does solve a lot of problems but if the group feels like something\u0027s needed some kind of audience restriction I guess is the way to go okay wrap it up yeah thanks for the feedback I think the wrap up already was given Zoey okay um so as already pointed out um there are no a net net pointed out also audience restriction for example doesn\u0027t work for replay on the compromised RS so there are other related topics we will take a look into and in the end we\u0027ll try to come up with a subset of recommendations that cover all those different threads in the document right so hope in Singapore we will see an update which covers all all those topics thank you very much so you have much time do we have it\u0027s alright good afternoon everyone William Dennis from Google and today here to introduce a new topic for the working group which is incremental auth so the problem statement is the following asking for the kitchen sink of our scopes up front is a bad thing "
  },
  {
    "startTime": "01:15:38",
    "text": "users should have context of the authorization request so rather than kind of you know jamming 10 scopes that the user at once you should be giving them this you should be presenting the authorization request for just the scopes you need when you need them so for example granting the calendar scope makes sense in the context of interacting with a calendar related feature yeah don\u0027t don\u0027t bomb lit in with something else and so I think there this is the one from 1124 if that\u0027s good if right before lunch there\u0027s no there\u0027s no next I didn\u0027t got a new version I don\u0027t if you want to send me another one that\u0027s fine I\u0027m just missing a good image that makes my point but um if you can imagine an OAuth consent screen that has like ten scopes on it from from calendar to contacts to like YouTube the sort of kitchen-sink of scopes we so think that\u0027s a bad user experience to have have all of that at once and so the definition of incremental authorization then is the ability to request additional scopes and subsequent requests rather than front-loading everything and importantly in a way that results in a single authorization grant that represents all the scopes granted so far the latter part is important without that it\u0027s not really incremental like it\u0027s just a whole series of separated requests each with their own scopes so an important part of the definition is the fact that when it\u0027s incremental you know you\u0027re only tracking one authorization grant that represents the sum of all the Scopes granted so a typical implementation of incremental auth would just display the new scopes so if if you\u0027re very granted scope 8th and in the app requests could be normally the authorization server would only show consent for scope B and of course a single refresh token being issued for the union of all those scopes go that they consider granted now this is a this is probably not a completely new concept our auth - doesn\u0027t actually stop you returning an authorization grant with increased scope and so a lot of people have used that to implement incremental auth so they increase the scope where they know it\u0027s okay to do so in the sense that the user already granted it previously so it\u0027s sort of okay to bundle in right it\u0027s okay to bundling an additional scope um on subsequent requests but that really only works for confidential clients so if if the client is confidential this that\u0027s probably a safe technique to use although it\u0027s undocumented for public clients native apps in particular not so "
  },
  {
    "startTime": "01:18:39",
    "text": "much so as far as schools concerned this is definitely something we\u0027ve been promoting in fact recently we\u0027ve actually started requiring it so this is an excerpt from the user data policy that basically just says you know don\u0027t ask everything up front don\u0027t try and like future-proof like if you think you might have a calendar feature in the future don\u0027t start requesting that today just request that when when you decide you need it but as I as I alluded to what about public clients so all the techniques at least that I\u0027ve seen so far and and from people who responded on the list we\u0027ll roll with the commercial clients for its kind of you can kind of implement a fairly obvious and fairly safe incremental auth just just from the original Ola spec so there\u0027s no real standard way to do is publish ice until now that\u0027s what this draft comes in it defines the the protocol for native app incremental auth which I called a parameter loss I apologize and in addition to defining the the profile for public clients and their protocol for public clients we can also take this opportunity to sort of formalize how it should work for confidential clients so just because everyone hasn\u0027t sort of worked out how to do it doesn\u0027t necessarily mean that it\u0027s valued to have some normative texture and how you should do it some security considerations etc so the you know the main part of a spec I think the kind of even if part of the spec is the native apps but you know let\u0027s bundle in the confidential clients and and document that as well that was the kind of kind of the idea so how does this app Kragh mental work the incremental auth for native apps I\u0027ll stuff using that we added a new token endpoint parameter this is for during the exchange of the authorization code called existing grant so when you\u0027re exchanging the authorization code from the second or subsequent grants you actually just include the Refresh token from the previous grant using this parameter existing grant then when we\u0027re issuing the the new refresh token you will actually contain a union of the scope so this is the sequence diagram you can see the initial authorization request where we request scope a we return the authorization code into a token exchange we get back the access token refresh token sometime later we decide you know maybe we\u0027re presenting the calendar feature and we need to increment and request the calendar permission so in the subsequent requests and this can be repeated as many times as we need we do a fresh request for scope B we get the response for scope B we send the authorization code from that particular grant along "
  },
  {
    "startTime": "01:21:40",
    "text": "with the Refresh token from the from the previous request and we get back an access token refresh token with a B as a Union toss them just one questions so your assumption is that the a s doesn\u0027t know why processing the authorization request whether the user already has granted scope a to this particular client that is not the assumption no the the issue is that because it\u0027s a public client because this is a native app there\u0027s a potential for client impersonation so while we may know that a user has granted skroob a to an app that claim to be that app we don\u0027t necessarily know it\u0027s exactly the same client because it could be impersonated basically so I was wondering whether you could give an indication in the authorization request already but that would mean potentially to send Refresh token with the authorization request right actually I wouldn\u0027t expect it I have a slide on that so we can we can discuss that okay but it sort of think of this as like a proof it\u0027s like proof that you already obtained the grant maybe I should go over some of the alternative designs because I do actually talk about that do you think if this question is about that then I just want to say that I have seen native apps you use the sticky grant pattern some from large apps who wound up having app in personation to do village escalation later that if you give if you make the assumption that everybody who\u0027s installed your app gets the union of all permissions that they\u0027ve asked for for any instance of that app bad things start happening which is why this would be an improvement yes I guess maybe it\u0027s worth detailing that attack so the attack goes something like this you have a popular mail client that has legitimately obtained grant for the Maus code and then you have an illegitimate app that presents a quite incremental authorization request for some innocent scope the user approves that turns out these clients actually counterfeiting the the legitimate mail client and then they get they actually get more scope than what the user approved whereas if you force them to actually request for the mail scope themselves for example the user would hopefully see choose wisely this game requiring email access and hopefully deny it so that I think is the privilege escalation attack that John was referring to so nuts a camera so it\u0027s just a question how make sure that the claim by the client saying that it\u0027s got the existing grants got me is actually legit so there are some validation checks that you definitely need to do I yeah I have covered that a little bit later okay mmm I\u0027ll get to that if you have any questions then then with you we can cover all just as more clarification Tosun speaking I know about a threat my "
  },
  {
    "startTime": "01:24:42",
    "text": "my question was related to the user experience they expected user experience so in the end if the user already has the app installed already granted a then in the subsequent authorization request the a s cannot really indicate to the user or your already granted a to this client no it\u0027s asking for another permission this is like the client would have asked for B only that\u0027s that\u0027s just doesn\u0027t that\u0027s what I would like to know I guess is implementation detail if you wanted to highlight that on the consent screen you potentially could as you already pointed out you don\u0027t know the instance in order to really identify the instance you would need to use the refresh dog right potentially yeah I guess in in the case of Google\u0027s authorization server we display that UI so it wasn\u0027t a consideration but maybe we can add something okay so now your your thing so as far as the implementation details are concerned like obviously don\u0027t just Union any two grants and stick them together we have a few checks in there so you make sure the the existing ground is valid in its own right so unexpired Unruh vocht and the client ID should match of the two grants so those are the kind of the two must match did that answer your question so not second on tomorrow such so I\u0027m kind of together with Dawson because it\u0027s a public client and so authenticated client right right so unless you send something like refresh token you really can\u0027t write so this this is this is the Refresh token that you send okay so so when when you do the when you exchange the authorization code from the incremental auth request you will pass the refresh token from the original request okay so the existing existing grant scope is not saying this scope not escape string no I mean like no it\u0027s a grant of scope hey I can\u0027t go clarify that yet yes so yeah maybe but then yeah yeah so the theory being of course that you know the client is already in possession of that of that Grant and can\u0027t use that so the sort of the theory being well they\u0027ve already got permission for that from the refresh token they\u0027ve already got permission for the second scope from the authorization code then there should be you know no it\u0027s sort of a convenience in a way that you version them right okay so now some alternatives so we do think about passing the the Refresh token in the authorization request parameter then you can do more nice things on the "
  },
  {
    "startTime": "01:27:43",
    "text": "authorization page the unfortunate robach of course is putting that token in the in a get request which we never do so the second alternative is kind of similar in a way it\u0027s just using an access token as proof of that existing grant the benefit is that you could apply to more than just the code flow with the Refresh token but the drawback is that it\u0027s more susceptible to attack like as was covered in the previous talk these are these sort of access tokens are gonna pass around everywhere potentially whereas the the nice thing about the Refresh token he said it it only ever get sent to the token endpoint and only ever gets sent on a back on the back Channel and so we\u0027re not altering that property here which i think is nice I guess like you know if you if you want to work on this we couldn\u0027t think of some other ways to solve the DUI question absolutely yeah all right so some fun news running code we actually already implemented this and it\u0027s already live on Google\u0027s all server and I have a proof of concept as a client you can try it out today it\u0027s open source it\u0027s based on the apple of library and I don\u0027t know if we can do a YouTube video it\u0027s possible to click that link this is a never been done before I think it and I\u0027d say if I don\u0027t know all right okay so here we just did the initial authorization request so this is the calendar scope about a introspective token there and you can see that there\u0027s a one scope list in introspection which is the calendar scope all right now again this is the incremental auth request and this is for the blogger scope user approves that do the code exchange and now we\u0027re going to introspect the token and as you can see there are two scopes listed in this token and you can try this demo out yourself on that github link I here are the stills here if if that was a bit too fast so yeah this is Jeffrey Gaskin I saw a second request for the to choose which account is that actually redundant and could you avoid it or is there some reason you have to show it good you picked up on that I was hoping I would notice yeah I think that\u0027s a little bit of jank in the demo ideally what you do since we support open early connect which has a parameter called login hint you could actually pass in the the hint of the user in that second request to avoid that experience you know other implementations of all who which don\u0027t support multiple logged in users you probably not going to see that problem "
  },
  {
    "startTime": "01:30:43",
    "text": "at all because there\u0027s only one user there\u0027s only concept of one user so I hope there will fix that jank and I don\u0027t think it should be be concerned for a lot of other people and yes anyway the logging in pram can solve that problem so awesome point question just popped up do you detect if the user account is different between those requests because that might happen yes I probably should have actually that is actually one of things we check I should amend that slide so it\u0027s the client ID as well as the user and the fact that the previous grant has to be valid yes so if anything is different if the different use a different client thing like that you know you definitely won like a finding token and I have I would be just big weird thank you that\u0027s a chimera number of such again two questions so you said you are introducing new parameters right yes why don\u0027t you just the first question is why don\u0027t you just use refresh token or something like that because you\u0027re just sitting in fresh token writing the other question is that it\u0027s really good from the point of view of the collection minimization you just asked for the Scopes what you need right but at the same time it\u0027s conceivable that the attacker can actually start asking grant in a small scope here and there so that the user doesn\u0027t notice that he\u0027s actually being profiled the entire thing that\u0027s a typical spying strategy by the way but so you know the reason why they do that is that it\u0027s actually easy so boiling the Frog yes yeah to you know get the full picture so um you know I suppose I can foresee some pushback from the privacy community as well unless you kind of address that that\u0027s all okay I guess I\u0027m a little surprised to hear that because this is actually like a pro privacy feature there\u0027s a ton of privacy but yeah it\u0027s going well okay if we look at the week if we look at your sort of attack there where it\u0027s like you just like nibble and get like one scope here one scope there you don\u0027t really need incremental auth to do that so if you really want you could just do ten authorization requests and have ten grands and and and frankly like if it\u0027s an attack that you\u0027re doing that that\u0027s not like a particularly large barrier the goal of this incremental auth is more of a developer sort of friendliness thing well one is like we want to promote incrementals because I believe it\u0027s privacy positive and and and sort of one way to promote a good practice like that is to make it more developer friendly and so to make it more developer-friendly we\u0027d like them not to "
  },
  {
    "startTime": "01:33:43",
    "text": "be tracking like ten different grants but I\u0027m not anti came in said that this introduces the attack that you mentioned so Lucy Lynch and and I have privacy concerns about this and it appears from your presentation that this is additive not particularly transparent to the end-user that it\u0027s attitude and that in order to revoke any one of these things who would revoke the entire set of permissions and start over as as an end-user so so say I give you missions to access my calendar mm-hmm once but I want to revoke that but I\u0027ve already given permission for mail or something else right I would end up not being clear that both things were from enabled and when revoking one I would revoke them all is that correct so I too the actual allocation of tokens is sort of implementation detail for better or worse you know love to so so I think a good implementation is you could piecemeal revoke I would like that makes sense to me which means that you would have to display to the user every time the Scopes that they have allowed that\u0027s to me an implementation of the UI yeah okay I\u0027m not quite sure I follow your time at revoking but others that normally doesn\u0027t happen during the the consent experience I guess that would annoy me the revoke right right you need a way to signal to the user all the Scopes that they I think the authorization service could certainly choose to do that in the UI so it\u0027s well that makes unfortunately that that whole that whole kind of thing is not defined by oath and so this this spake doesn\u0027t doesn\u0027t change that for better or worse I guess the whole though I mean almost doesn\u0027t even document revocation I don\u0027t think has a standard no dick heart Idec were there comments at showing what\u0027s already been granted showing what\u0027s added as opposed to I think showing that it\u0027s all of the things is over overloading it but saying here\u0027s what you\u0027ve already granted and he knew things would be right I have a little NIT aren\u0027t just terminology that auth is ambiguous yeah the authorization or aussi to be clear because at first I was wondering it wasn\u0027t really clear what kind of author you\u0027re talking about so that the full title is authorization "
  },
  {
    "startTime": "01:36:45",
    "text": "no I think we need a yeah I hate arrows well no just kidding so this is really about discriminating different instances no John Bradley thing again this is really about sorry no you become okay called drugs that finally got me so this is really more about being able to discriminate instances of apps so that you\u0027re providing the right incremental or D incremental grants to to them so we should I\u0027m happy to work with you on coming up with a way of using a hash of the of the Refresh token or session that the session information from open ID Connect there\u0027s a couple of different ways that you could indicate in the authorization request which instance of the client it is so that you could provide a more fulsome grouping of information you\u0027ve already granted these things to this app do you want to add this one and potentially in when you go to revoke tokens you\u0027re now going to have different grants for different instances of apps so you\u0027re gonna have to look at do you want to revoke the access to this app for this thing on your iPad versus your Android phone etc so there\u0027s a few other things around this that probably need to be flushed out happy to work great thank you I look forward to hearing the ideas um yeah I think this is an another area that\u0027s a bit under specified in oath which is with with a native app client you can\u0027t potentially have two streams of authorization and so with incremental auth you can actually have two streams of that you like you said iPad app I\u0027ve thrown up one could have calendar permission one one maybe doesn\u0027t um and I think that again I think that\u0027s a positive thing um I really like your proposal it solves a problem a practical problem that we also saw along those lines at Archie telecom but um along the lines that the speakers before me say that um I think das needs to have a complete picture on the or they are of the of the client in Shenzhen should be able to display all the Scopes that already have been granted I mean it\u0027s in the end it\u0027s at the discretion of the a s how to really show this information but it should be possible and I\u0027m also not quite sure that\u0027s really the refresh token should be the end in the in the object model so tip what one could also do you could have a refresh token or multiple refresh tokens referring to the same authorization grant and so on so one could implement that much more sophisticated ways that we have to do that that we have done that at Deutsche Telekom okay so I would also be happy to support that work so if you you like my "
  },
  {
    "startTime": "01:39:45",
    "text": "review or contributions David Tong says should a hint not be sent it should a hint not be sent in the authorization request that the client is going to apply increment off this will allow the AES to customize consent screen I agree I agree with not sending a token in the authorization request but maybe a flag should be sent yeah I feel like it\u0027s pretty common feedback now in addition to a flag that it sounds like it could be useful to know exactly what scopes for granted so a hash of the refresh token could achieve that or or something else so let\u0027s let\u0027s take that as a good feedback okay um so we should also cut this now so how many of you have read this document this is a serious error version who read it not many so I I Shawn 3 yeah 3.3 peoples is for of course blaster blaster also Boston and John I think you said that you are going to do a review of this one it was that correct like normal inside okay anyone else there\u0027s anyone I would not very good okay excellent so I guess yeah thanks so the code is only available for iOS so you don\u0027t have Android code yet you don\u0027t have code running in multiple platforms you know forget it um no just kidding thanks thanks William we support our users on whatever platform the heaviness so if the code is really simple you can look at the diff and it\u0027s very small so if there\u0027s demand happy - happy - ported to Android yeah as you came across not as you can match just one extra parameter so it\u0027s not rocket science well you\u0027ve put together for the native app you\u0027ve put together so much different libraries in different for different operating systems so it\u0027s sort of like you you raise the bar for yourself unfortunately um okay so I guess is premature to do call for adoption I I think it is given how many people have read the document I good but "
  },
  {
    "startTime": "01:42:45",
    "text": "I guess like the topic seems to be in scope I guess yeah yeah we really need more more feedback because I know it\u0027s a little tricky so I guess fee all right I guess you ask is please have a read and thank you for the written the reviews we\u0027ll come back to in a few months oh wait of course we can always do that under millions this way hello I\u0027m Mike Jones from Microsoft and I\u0027m here to talk about an early draft of a JSON web token best current practices document so when we last met our heroes in Chicago we discussed a number of reports of jobs having been implemented and deployed and securely or incorrectly or both and discussed ways of preventing confusion between different types of jets that might otherwise arise hearing all this discussion among others Kathleen Moriarty had suggested that we write a best current practices document for jobs motivated in part because shots are starting to be used by a number of different projects and working groups in the IDF which is a sign of success but it means that those that were involved in developing it aren\u0027t actually probably even present in many of the discussions about how to use it in these new application areas where a BCP could help people writing new apps to do it securely and correctly so your own Scheffer took the courage of a first draft which he then shared with dick and I and we revised internally a little bit and about a month ago we published a 0-0 individual draft which you can find on the data tracker subsequent to that there were a number of discussions mostly in the second working group that led to discussions of explicit typing for the security event token but really that would be just an example of explicit typing for a job and so we turn the crank one more time before we got to Prague and defined how to provide explicit Tibbett explicit typing for any kind of job so the "
  },
  {
    "startTime": "01:45:48",
    "text": "structure of the document I think is borrowed a bit from the TLS BCP and I like the way that Iran did that that there\u0027s descriptions of threats and vulnerabilities in one major section so these whole subsections describing all the problems that we would have described and then there was a following section with subsections defining a bunch of best practices and there\u0027s links from the problems to the solutions or the mitigations and it\u0027s often one too many so there might be multiple ways that you would mitigate a particular threat one of the interesting things about writing a BCP for something that\u0027s already in production use and number of context is you have to understand and balance a number of goals first and foremost we want the document to provide actionable information promoting the secure implementation of deployments and jobs and we want the guidance to be applicable to a broad and growing set of use cases at the same time we recognize that not all deployments will choose to do new things and in fact not all deployments are going to need to change but we try to do an analysis of under what circumstances it would be beneficial to change and in what ways that said we\u0027re also trying to describe ways to keep existing deployments secure even if the scope of what those deployments are doing might increase so for instance if you have an issuer that starts issuing an additional kind of job how do you prevent an attacker from capturing that initial job which was legitimately issued and trying to pan it off as something that it\u0027s not get unintended consequences and we try to recognize the costs of changing and hardening existing deployments and there\u0027s a bunch of practical trade-offs like this that I think one of the productive next steps is for people start to start to just to discuss those and look at what we want to do in some specific cases so one example trade-off that\u0027s probably gotten more discussion primarily again in the security of it touken world ii Vince working group is "
  },
  {
    "startTime": "01:48:48",
    "text": "this notion of adding explicit typing now in fact there\u0027s already a type header parameter which could always have been used for explicit typing but it\u0027s largely not used in deployments that I\u0027m aware of so after discussing a number of alternatives at least the three of us thought let\u0027s just recommend doing that it\u0027s straightforward you don\u0027t have to define any parameter and the way that it works because it\u0027s a media type as you define an application slash for instance second vent + JA media type and you\u0027ll see an example of that in the set spec which is referenced from the current PCP draft of using that approach to type future jots going forward you know but we\u0027re not currently mandating that existing deployments do this we want to have again actionable information on how to make those trade-offs dick is smiling because I forget in one place to delete already secure because we had an agreement to not talk about it that way I\u0027m my bad you\u0027re right to laugh at me but you know part of the trade-offs too and this was always president echad design is it\u0027s designed to be used in some space constrained environments including in browser URL contexts as query or fragment parameters where space is not free and increasing the size of something they actually break the deployment so next steps are the obvious ones we\u0027d like people to review the document we\u0027d like people to discuss it and particularly tell us how you think this fits with your use use cases what\u0027s going to be valuable to you what you think you would do differently etc we\u0027d like to bring as much sort of application and use case knowledge into the discussion as possible and at the end of the time here perhaps we can consider adoption as a working group document especially in light of the fact that Kathleen wanted us to do this I\u0027m done okay any comments who has read the document two three four "
  },
  {
    "startTime": "01:51:52",
    "text": "five six seven eight nine if I wait a little longer booth 20 yeah well that\u0027s good for an early draft I\u0027ll be back so um Brian do you go first it\u0027s Brian from pang I don\u0027t know if this is the right form I did have a few questions one of the mailing lists about a little bit more guidance around the use of type and in nested job scenarios I and I responded on list that\u0027s an omission and we should just define the syntax and sort of sort of following up on that I\u0027ve been really uncomfortable with type just based on how it\u0027s defined and at the core layer it\u0027s sort of toothless definition did you did you give any consideration for guidance around doing something similar may be with with the critical header at the hose a layer to actually give give it teeth against play against existing protocols that that wouldn\u0027t know or wouldn\u0027t do any validation around type in Chicago again in the second the second working group and in the list prior to that there was some discussion of that and there was some concern that not everybody\u0027s implementing critical correctly which isn\u0027t an excuse and it\u0027s not clear that having it be a new must understood claim gives it any more practical teeth than using a field that we already have and which you know an application profile of any jot is going to have to define what the validation rules are and so one of the validation rules for new jots using this technique would be that you must validate that the type header matches what you expect sure sure I was just thinking about sort of retroactive the existing application profiles like open ID connects like Roth tokens where there\u0027s not actually a application profile that that\u0027s something that\u0027s a little it would actually take effect on those existing deployment right well one of the trade-offs is crit is designed to break things and there\u0027s a reason it\u0027s there but for an existing deployment it\u0027s unlikely in most cases that implementers would choose to proactively break things "
  },
  {
    "startTime": "01:54:53",
    "text": "unless you know you\u0027ve got a whole lot of context but that\u0027s that\u0027s the whole point of crit is that a new profile could define the use of crit in such a way that use of that token against an old profile like an OAuth access token would break without the old profile having to be explicitly aware of the new profile that\u0027s kind of the decided about where you\u0027re right I I misunderstood you I thought you were suggesting just editing the code and redeploying no no you\u0027re talking about new ok presuming the the actual functionality was implemented it\u0027s a way to to protect against the sort of fundamental problem that\u0027s come up here we can talk about it more I\u0027m not sure can you put a paragraph on the list with a suggestion sure it\u0027s been discussed in other contexts but particularly if our off is gonna do this work which we think it\u0027s in scope because job was done here then we should make the Roth people who aren\u0027t members of the ID events you can forward a message from idea events if it\u0027s already captured well yeah I only saw thinking about trying to articulate it but I\u0027ll try to look up what I wrote previously and maybe sorry I\u0027m just there was there was some commentary on the BCP that was was not responded to and as I read through it not being a cryptographer myself I started to wonder if these are actionable real things or that need to be considered or if they\u0027re they\u0027re just kind of fun and it was really hard to tell some of the ones specifically that come to mine are people have criticized a lot of potential use of compression inside inside a jwe as being a leak factor I don\u0027t frankly understand the attack factor I don\u0027t understand beast and crime from what I do understand I don\u0027t think it\u0027s legit but I\u0027d love to have someone smarter than me tell me whether that\u0027s probably good to ask the CFR gee what they think of yes respect and other things like potentially deprecating RSA 1/5 encryption that\u0027s been a common a common criticizing point around the whole area that maybe maybe this would be the right thing to do and it may be you know time to write a short draft that does that thanks to Shawn Turner\u0027s feedback when he was ad supervising it there is a status field in the algorithms list and we can change that to deprecated you know that\u0027s a separate thing but yeah just some thoughts I think it\u0027s good useful work so I mean on the topic of compression um it\u0027s not necessarily the case that compression and you obviously compression Elise information um because the length length tells you something about the content so "
  },
  {
    "startTime": "01:57:53",
    "text": "you know the dictionary and so they\u0027ve been a bunch of papers on this you know some some in the adaptive setting like sorry so all I\u0027m going in the setting that is be setting where is crime we\u0027re on the attacker gets control some of the data and they don\u0027t control all the data and so they basically used the data they send in to see the dictionary and then look for and then basically sister Co compressing the attackers data and then the victims data then these are get some some information about the victims type data is there also been attacks in studying to designer doesn\u0027t do this like docked on Phonics paper out of what I want to say UNC a few years ago showing you could use a packet lengths to measure what people are saying and variable voice codecs so you know it\u0027s not necessarily the case that you could never use compression with encryption is just like super bad news if you get it wrong and so generally they\u0027ve got I think I think that the gut the appropriate guidance here would be you know either something that something level of you never do it or only do it if you really know what you\u0027re doing in here as a bunch of pointers but you did not g OJT generally safe practice i think more about what the protects look like if someone wants to but probably not necessary here okay and this is in the notes and and so we can go after that afterwards you\u0027re on your own chauffeur and back to pkcs1 1.5 we actually did use the TLS PCP to deprecate or to opinionate about algorithms so I think it\u0027s it\u0027s absolutely legit to do it in this context as well no need for separate draft and because yes 1.5 is non-controversial and now probably wrap up this session I would like to get a sense from the folks in this room whether they believe that we should sort of do this work in this group or whether you oppose to that work so hum now if you think that we should adopt this work that might be presented and please come if you are posted okay now sir yes I would talk to echo about what he sees this also within scope when we talked about this it was with Kathleen and I think this is clearly in scope for this working group there may be some technical issue about it not being like in the Charter or something which I can take a look at I don\u0027t see any problem with it being soft in the Charter other Turner now okay that\u0027s thanks so we able to do a confirmation or we will do the confirmation on the on the mailing list as usual and then yep we\u0027re good to go okay thank you all and I look forward to seeing more reviews yeah so if there\u0027s some reviews of this one I "
  },
  {
    "startTime": "02:00:54",
    "text": "think it\u0027s good workhorse on light of what we discussed that workshop last week we talked about one specific back there more crypto related attack invalid curve attack yeah so if you if you want to volunteer raise your hand right your hand floated into the air as if on its own what\u0027s that mistake you all you want to do yeah you don\u0027t yep what is you want to do okay yeah with you anywhere else you can still read it okay but Frank that\u0027s good yeah thanks thanks for showing up and next session on Friday Friday morning [Music] you "
  }
]