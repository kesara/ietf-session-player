[
  {
    "startTime": "00:00:41",
    "text": "so uh we would appreciate it sorry go ahead Ron all right um we do still need a volunteer to take notes during today's session"
  },
  {
    "startTime": "00:05:30",
    "text": "foreign so I think we should probably get started um we do still need a volunteer to take notes uh since no one has offered yet I guess I'll try to do it along with the running the meeting here um well this is not with us today she's traveling today so I'll be uh chairing on my own um okay let's dive into the uh the chair deck"
  },
  {
    "startTime": "00:06:00",
    "text": "uh so right uh first we ask everyone to uh be aware of the note well and review all of its uh everything that it says about you know how to behave here uh standard ietf boilerplate uh and then let's get into the agenda bash for today so the first thing up is to uh wrap up the uh excuse me wrap up the deck on uh transport requirements um that we started looking at back at ietf 116 and then continued working through at the last interim session uh so that's there's one slide left on this deck uh that's for record to present but he's not with us just yet um the other item on the agenda is uh Rafael Robert has a deck on transport versus delivery service so I think what we could do since uh since Eric isn't here yet is uh start with uh Raphael's deck and then come back to the discussion of the last slide of Eric's deck afterward uh Raphael does that sound all right to you sounds good okay um all right so with that in mind uh does anybody have anything else they'd like to add to the agenda okay uh so in that case let me throw up Raphael slides and yeah [Music] sorry let me sort out the buttons here there we go go ahead Raphael yeah excellent thank you for joining the slides um yeah so essentially this is in response to the discussion we had in Yokohama where um we now have a total of three proposals for various aspects of transport and delivery service and the protocol between providers in general"
  },
  {
    "startTime": "00:08:03",
    "text": "um so I and and we don't really have consensus yet on what the scope should be exactly and what the the architecture looks like so in the last interim we discussed a lot about um very specific aspects of the architecture thanks to Ecker um so maybe some other questions in this presentation are no longer relevant um so yeah in essence I thought it would make sense to look at what the status quo is what the general understanding is um have some discussion about it and um they also try to explain a bit more um what the understanding is regarding MLS specifically because we already agreed that that is at the core of Mimi um but yeah at times it feels like um not everybody's on the same page regarding the architectural requirements of MLS that being said um the far fewer people here today I think um so Jonathan Rosenberg is also not here where is he let's see him but yeah anyway be that as it may um let's start with a presentation um so next slide please so yeah so this is uh the three drafts we have uh currently um so linearized Matrix which I think at this point replaces the original Matrix draft which has also expired I think um from Travis Ryerson done from Jonathan Rosenberg we have the Mimi protocol and from myself and Conrad we have the Mimi delivery service next slide please"
  },
  {
    "startTime": "00:10:01",
    "text": "and actually did I um did I miss anything because it was your hand if anything is missing okay right so um we have a little bit of consensus already um in the sense that across these three drafts there is this concept that a group or a conversation or a room which is essentially the same concept um is owned by one of the providers um that has to do again a little bit with how MLS works on one hand um and to separate the other providers in a Federate environment they're called other guests or I think participants in The Matrix draft um there also seems to be some consensus on the fact that the API in general is a rest for one with one exception of the long polling in the Mimi protocol draft so this is good we have some consensus to start with run these things but we need to talk more about the details next slide please so this is to illustrate um what we just talked about so there's the idea of an owning provider which in this scheme here would be b.com and then there is a guest provider um um the whole question about the transport and the delivery service is how does a client that belongs to the guest provider how does that client get to talk with the owning provider um because ultimately uh an action is initiated on that client and it has it is reflected on the owning provider so this is what we're gonna look into a bit more this of course will"
  },
  {
    "startTime": "00:12:00",
    "text": "be a lot easier um if there was only one provider but then we wouldn't have Federation and we would need interrupt so this is what we're looking at next slide please so where do we not agree just yet um it's not entirely clear what we fundamentally want so there was some discussion about a server to server protocol and there was also some discussion about a client server protocol um and so this is where we diverge in the sense that we um yeah there seems to be preferences and we are not really looking at what the architecture actually requires currently so this is what what we need to look at in more detail um the scope of the protocol is also not entirely clear in the sense that it it's not clear um what operation should be supported what kind of data should be transferred what State Should be held by the server Etc we also don't agree on the fan up mechanism just yet so we agree on on the part where um there is a restful API between other client and the server or server in the server before the fan out but when the funnel happens um The Proposal in the Mimi protocol by Rosenberg is for long polling um whereas what we proposed at least was push I don't remember what Matrix is specifically proposing that regard so we need to talk about that the other thing that is not clear at all is consumer versus Enterprise so we've discussed a lot in detail without saying exactly whether that applies to Consumer messaging or to Enterprise messaging the Assumption here is that a lot"
  },
  {
    "startTime": "00:14:00",
    "text": "applies to Enterprise messaging simply because all the people in the room discussing it work on Enterprise Messengers um and the question why that is relevant is actually the last slide that Echo was supposed to present today regarding metadata so this is the one fundamental difference um that we need to look at maybe there are more operational things that have not really materialized yet that we will discover where we have differences between consumer and Enterprise messaging as well okay next slide please okay so I try to summarize in very broad Strokes um what these three drafts mean and of course it's opinionated so feel free to disagree so the way I understand it uh linearized metrics essentially departs from this peer-to-peer deal that was in the initial submission um for Matrix so this is definitely more aligned with the consensus that we already have um from what I gather it has a lot of dependencies from the rest of the Matrix universe so things that are not actually defined in the document itself references that there are also not two other sorry apologies but um it includes some things that we have not discussed in Mimi at all um uh which are for example that history is kept on the server uh it also doesn't make it entirely clear what the metadata situation would be um so these are things we would have to look into next slide please so the Mimi protocol draft is pretty"
  },
  {
    "startTime": "00:16:02",
    "text": "comprehensive at the time of writing I think now we caught up a little bit with the other two um so in a way it's a batteries included approach in the sense that um it specifies an application layer protocol as well as a transport layer protocol combines the two together um goes Way Beyond the scope of mls in terms of functionality um so things that are like either adjacent or on top of MLS and by doing that of course it blurs a bit the abstraction layers we could potentially have here and as I mentioned earlier it proposes long polling four fan out um and the open question here is how that would be compatible with open Federation um so again I just tried to look at the broad Strokes um from my perspective of course um all the details is not something we should look at if they're not relevant just yet next slide please so delivery service that's when we submitted that is not a transport protocol and really it only describes the and then specifies the messages between the client and the owning provider and in the next slides we'll see how that fits into the architecture um so specifically it is agnostic of a specific transfer protocol which could be a GPS Matrix XMP um because all it does is specify how these messages look like and how they're being serialized it's also agnostic of the question of whether we want client to server or server to server"
  },
  {
    "startTime": "00:18:00",
    "text": "um and the idea is that it can cover both like explicitly consumer and Enterprise messaging um and the whole motivation behind it was to make the scope as narrow as possible so that we could get consensus on that um so essentially it supports all the things you can do with MLS but it doesn't try to go beyond that in the sense that there's a bunch of things we will probably have to specify for Mimi that go one level above as an as an application layer thing above MLS um so this is completely out of scope of the document yeah and just as a side note we uploaded two new drafts in the in the past days for that so it's a little more complete now um yeah next slide please so going back to the architecture question um so if there are different ways of looking at it one would be to look at the providers and um look at what would make sense from that angle so the that's not the one we choose right now and I choose to look at it purely from a technical level um and then see if we can make the ends meet somehow um so MLS has this property that it needs a delivery service that orders messages um and the consensus we have around that is that this message ordering happens on the owning provider so on a very abstract level that thing has a counter and it looks at commit messages that come in and whenever the um the Epic number on the commit message measures the counter then it's incremented by one other messages are"
  },
  {
    "startTime": "00:20:01",
    "text": "rejected for that epic Etc um so this is fundamentally important and um this Dynamic happens between the client that created the commits and the earning provider so the concrete commits the commit somehow arrives at the earning provider gets either accepted or rejected and the client immediately learns about whether it's been accepted or rejected the guest provider in that scenario is not Super Active um it doesn't really like purely for the dynamic of sending a commit the guest provider doesn't have anything to add to that yeah next slide please so um what the the MIM protocol from Rosenberg is describing is essentially a protocol between the gas provider and the owning provider um as a server to server transport that is specified and to me that's not entirely clear how that fits in with MLS um because it doesn't really specify how the the client actually takes part in the server exchange the other thing is um it the the guest provider sort of takes the um the place of the client here and has access to all data which is a big question uh particularly when it comes to Consumer messaging whether or not we want that um next slide please so the the last part would be the fan out so when the client has sent a commit to the earning provider and the commit has been accepted or any other message for that matter"
  },
  {
    "startTime": "00:22:01",
    "text": "um then that message needs to be delivered to all the other clients and in the first step it will get delivered to all the other guest providers that are part of this one particular Federated group um so um essentially like conceptually this is um a distinct second phase of the protocol and um this is maybe a little less controversial because now clients are not really involved anymore this is truly a server to server protocol um and the only question is what shape should it take um so again the proposal from Mimi protocol is to have long polling here where the guest provider would open a connection to the owning provider um and the argument for that is that this is very controlled so it's good for preventing spam because the earning provider cannot push out stuff to anyone it needs to wait until the connection comes in the counter argument is um how does that work with open Federation because you would have to establish connections between all of the servers in the world that want to participate in this um so The Logical answer is this won't work with open Federation this only works um when you have agreement between providers that they actually want to Federate and then they have these um these connections open um yeah next slide please so we um we had it in another very small draft to bridge the gap simply because the delivery service we're proposing uh is is not really a transfer protocol at all so"
  },
  {
    "startTime": "00:24:01",
    "text": "um what we propose is maybe over https and I understand that nobody had the time to look at it and it's also not super important because all it is really is a wrapper uh for the delivery service messages um to go over HTTP um again the delivery service is agnostic this is now an opinion that it tries to use http and then next and last slide please try to um yeah lay out what the stack could look like um so since we seem to have consensus on HTTP in general like all three drafts at least not against it um so https specifically and then the question is what do we have above hdp and so what what we're proposing here would be to have this really thin layer um to wrap these messages over HTTP for the delivery service which in turn is a bit of a wrapper for MLS messages and and Aggregates you know a few more things with that um but you could also have a discovery which is in scope but we're not talking about it just yet on top of Mimi over https there could be other things um so this is essentially a proposed stack of how that could work um so that things are as modular as possible um in the sense that uh if if we have something else that could simply leave on top of uh Mimi over http um then again if we want to use a delivery service over a completely different protocol um that could also work um yeah so yeah I hope that that was helpful to look at some of these um"
  },
  {
    "startTime": "00:26:02",
    "text": "aspects and I think that was it from our presentation I'm happy to take questions which nobody asked during the presentation which is surprising yeah it's a little unusual it's uh usually a very chatty group thanks Rafael's yeah I have a queues open if anybody wants to ask questions or comment on any part of this go ahead Travis so the dimension of like linearize Matrix and all that um we do have a a sort of work in progress draft it hasn't been published yet that removes all the dependencies from the existing Matrix system because I definitely agreed it shouldn't depend on a lot of that we're also just working on tying it to MLS this is a sort of brief update there um just to sort of add the additional context yeah makes sense um I suspected as much but since I didn't see it in the draft started quiet today um let's maybe see if we can ask some questions um how do folks feel about scope um is there a preference or good Arguments for having a larger scope and having um like batteries included approach where you have one one big document that specifies uh nearly all of the aspects or do folks prefer a more modular approach"
  },
  {
    "startTime": "00:28:09",
    "text": "uh yeah I guess at risk of just uh also monologuing a bit um I think the sort of batteries included approach would probably be a bit better in that sort of sense um because if it becomes too modular then we might end up just trying to design the world you know grains of sand at a time sort of idea um whereas having a sort of single or larger document it might be a little bit easier to work through I think the important thing is is whether there is a document that shows good examples of the that you know kind of gives the big picture but the the part that I think that has not been done in any other set of in documents from many of the other authors is how the you know how how MLS specific uh things which uh have impact on the on the clients and on the um and on the server to server interface uh that we have those um those things are are easy for are accessible or easy for implementers to understand um so I think that the Mimi over HTTP draft I think that could be separate and you could refer to it but I don't have a strong opinion one way or the other on that one but the you know the the delivery service draft I think is is really really important yeah thanks uh Ron for that so yeah just to reiterate on that since"
  },
  {
    "startTime": "00:30:02",
    "text": "also nobody's in the queue um the idea behind the delivery service was really to only specify stuff that eventually will have to be specified in any other draft as well um it's not stuff that is specified in the internet uh linearized metrics yet nor in the uh maybe protocol at least not fully but if those you know those documents at some point they would get to the point where they would um have to do exactly that um so there again the idea is to extract that and have that as a separate thing um as a common denominator essentially um and push a lot of of the other things that we have in Mimi protocol for example like you know having um clear text usernames on the delivery service and and stuff like that to push that away and and to have that on top of MLS if that's what we want obviously but in the last session we also said very clearly that we want to actually harness mls in terms of cryptographic guarantees it can give us for things like Access Control policies and and other things um and and we shouldn't you know hand out uh completely unverified plain Text data between servers thank you so I remember this discussion of encoding permissions and apples and so on at the MLS layer and um I apologize I'm personally I'm not an expert on MLS or really how it works there's one thing I was wondering though is that like a question of the layer of the stack at which apples are represented or is there some way in which MLS can actually cryptographically enforce that participants in a group are like complying with the apples that are uh yeah expressed at the MLS layer"
  },
  {
    "startTime": "00:32:00",
    "text": "so when you um or Ron maybe you want to go ahead or not or is it related to something else yeah um so the agreement of MLS says that everybody like if you had a policy document that describes what the policy is what the admin policy or the group joining policy or whatever it is then you can share that with every member of the MLS group and you can be assured that everybody in the same epic sees the same copy of that document and then they can enforce then any any individual person can go and enforce that uh it doesn't say you know it doesn't Define what the what the semantics are of that document it just says if you have an extension and you want to be able to convey that information and get agreement on it this is what you this is how you do okay so it sounds like you get like a cryptographic guarantee that all of the participants have the same view of what like the agreed upon apples are but of course you can't prove that like individual clients or servers actually did then go and force those Acts exactly that makes sense thank you yeah so and and what what's derived from that is the fact that the server cannot just you know add someone as an admin without clients noticing so this is another guarantee we get out of that unless we specifically you know give the server the right to do so but especially in a Federated environment where you have several servers you essentially don't have to rely on all of them but only in those that you specifically choose who can add and remove people so again you have owning providers your guest providers um the guest providers for example then they don't have the right to add or remove people from a group because they're guest providers by Design so all of these nuances can be expressed and actually enforced"
  },
  {
    "startTime": "00:34:14",
    "text": "so Raphael maybe if you wanted to open up the latest version of the draft since it's fairly new um does does anybody object to maybe uh walking through the top three or four things that are likely to get someone who isn't doesn't have a lot of experience with MLS like these are things that you need to be aware of and you know that what the the DS implications are in your draft yeah I think we could do that um Tim is that something you would be able to share or maybe it's better if you share my screen let me see yeah here I'll stop sharing slides and you see if you can uh yeah share your screen if that button doesn't work then we'll figure something out yeah give me a second"
  },
  {
    "startTime": "00:36:23",
    "text": "getting there slowly um while we're waiting on this uh as it turns out um uh Eric rascara won't be able to join us today uh but we still could take a look at that last slide in the deck which has to do with privacy metadata since um after of course looking at this draft um Raphael I think you already broached the topic of um of metadata privacy when you were talking earlier so I think perhaps we could still have a useful discussion um yeah the two are actually pretty linked um so that's a very good point um yeah I'm really sorry I'm having trouble um sharing my screen here since Ecker is not here I'm blaming Firefox uh if this doesn't work I'll try sharing it from my end if you can point me at the oh I see it yeah yeah it's the one you updated earlier today yep no sorry this is just not responsive sorry for that all right let me give it a try"
  },
  {
    "startTime": "00:38:18",
    "text": "all right can you all see that yeah is that the right draft dude that's definitely the right draft yes okay sweet all right then I guess just let me know which part you'd like to look at and take it away yeah if you can scroll down a bit um past the introduction um yeah so regarding the flow um that's what we already touched on and the presentation a bit so what what this specifies at this point is um the messages that go from the client to the delivery service um and the delivery service here would be the owning provider um so this is why I'm more abstract than in the presentation but simply to illustrate that this is a request response scheme um and in phase two there is a fan art between two delivery services from provider one to provider two [Music] um again this is where we have the proposed long polling in the memory protocol and where we are proposing a push mechanism so this particular part is not specified in the document just yet the initial approach was to just have a very high level but then the feedback we got was that folks don't really understand what we're trying to achieve here so now we've added some more um and if you can scroll down a little more"
  },
  {
    "startTime": "00:40:01",
    "text": "um yeah thanks um so the the whole idea is that the client can also authenticate to the delivery service um in a way that is specific to the group so authentication across borders of Federated systems is always complicated because how do you how do you share trust Etc um so this takes away a lot of that problem simply because when you start with an established group um a client that interacts with such a delivery service is a client is a member of that group so it has cryptographic key material as part of the group that you can actually use to authenticate and depending on what the operation is the authentication is slightly different in how it works um but just to give you a very concrete example um in MLS every member has a leaf node in this budgeting tree and the leaf node contains a signing key that is specific and unique to every member um and so when you want to authenticate and to prove to anyone that you're part of that group you can simply reuse the signature key to sign anything and so this is the mechanism we're using here um these requests from the client to the delivery service very simply signed with the same key that is also being used uh in MLS and that allows the delivery service that holds this this ratcheting tree um as a state as group state to actually identify clients and ascertain that they're indeed part of the group and that they're allowed to send commits and send application messages Etc"
  },
  {
    "startTime": "00:42:01",
    "text": "so we we don't need another layer of authentication in that sense um it's a little more fine-grained because not every operation is necessarily a signature but this gives you an idea that the authentication is essentially um completely decoupled from any other authentication you might have on the system you don't need a username and password to log in or to to share credentials Etc thank you um yeah if you scroll down a bit further request response scheme um so yeah what we're proposing here is to Simply mimic what we already did in mls in in terms of uh how we structure these messages where we use c-structs and then we serialize them uh with a TLS codec that has worked really well for MLS this is what we're proposing here uh simply because this is very close to MLS um so the the code of the application that would deal with the delivery service would also be you know sit right next to the code that deals with MLS so we wouldn't depart from that logic and then we don't have to have a debate about whether we prefer you know Json or plot above or whatever um so and the next part is actually looking at the operations in detail um so again these operations is what we think uh is the common denominant denominator for any system simply because it's uh it's an exhaustive list of things you can do with MLS there's more stuff you can do on top of MLS but again that's not in scope for the delivery service um so this well the next part here is not"
  },
  {
    "startTime": "00:44:01",
    "text": "super fleshed out um but the um the idea behind it is that um there is a c-strap for every request with a bunch of parameters that are needed um to um to send to from the client to the delivery service and then there's a response um that you get back immediately what's also needed is instructions for the delivery service on how to handle these messages so the delivery service has the groups the public group State meaning the the ratcheting tree which is this binary tree for those that are not particularly familiar with MLS um it also has an object called the group info which is comparatively much smaller than a ratcheting tree typically which contains you know a few more things that clients need in order to be able to interact with the group and that's pretty much it from an MLs perspective um so whenever a client sends a request to the delivery service um the delivery service pulls up the group state authenticates the client and then looks at what exactly the client wants to do and and can perform that operation and tell the client whether or not it worked out and ultimately fan out the message if if that's what needs to be done so yeah if you if you score a bit further so I'm not going to go over group creation and deletion um so the maybe not that much if if you go back a little bit joining groups um thank you so um joining a group there are different ways of doing that um with MLS and ultimately it comes down to"
  },
  {
    "startTime": "00:46:00",
    "text": "uh whether somebody who's already in the group sends you a welcome message or whether you discover the public group States and then you can depending on the policy that you can insert yourself into the group if you will and the mechanism for that is called external commit um so this might uh yeah look surprising as Ron said this is really the MLS terminology and clicking in here um and um so when you receive a welcome message um what you need is the the ratcheting tree that is on the server um same with external commit there you need the tree first and then you issue you as a client you issue an external commit to insert yourself into the group um and maybe I should say a bit more about the group stat and the ratcheting tree so the server Hazmat and by observing messages that come in and out like commit specifically um the server can actually update this ratcheting tree so every commit covers so-called proposals and the proposals then say in what way the tree should be modified so an ad proposal obviously like the name says proposes to add someone um to to designate a location in the tree and um the server can essentially update the tree in the same deterministic way that the clients will also update the tree when they receive the commit later on so there is no reason that the clients actually have to constantly update the tree on the server this happens automatically um and it's a very convenient mechanism to"
  },
  {
    "startTime": "00:48:02",
    "text": "have whenever a client joins a group particularly when the group is larger so MLS is about scalability and the question is how on a cryptographic level but the question is how can we make scalability happen what needs to happen on the server side and that's exactly it the server is essentially assisting clients here whenever they want to join a group because it could be prohibitively expensive to whenever you add someone to a group to also upload the whole group State the whole ratcheting tree from a client to a server so yeah so these are the on a high level these are the two operations on how you can join a group um and uh that can be initiated differently with uh different proposals but like the joining client hand it's either one of the two in the end um the next part is rather trivial adding and removing users so that's one of the core functionalities of MLS is to how to remove users to the tree so what happens here is simply that the client um in the case of adding users they're added with so-called key packages so key packages and for those who know the signal protocol that used to be called pre-keys in MLS it's called key packages in pgp it's it's called public keys so essentially it's a public key material of a user um that you need here so when when you add a user to a group you all you do is essentially you tell the group here the key package of the new user this user is now in in the next free Leaf so everybody will calculate the same Leaf index in that tree and so that's how the"
  },
  {
    "startTime": "00:50:00",
    "text": "user is now part of the group and in turn the new user will receive this welcome message that allows them to then sync up cryptographically and and be cryptographically part of the group um removing users is even easier because you can reference them by the the leaf index in the tree um and so now we last time we spoke about policies and Tim just mentioned that so this is where uh policies would essentially kick in um and determine whether or not a particular user can add and remove other users fundamentally MLS is like full Anarchy anyone can do anything unless we agree to have specific rules and now these rules can be observed by the clients there can also be observed by the delivery service if if they are on clear text if it's an extension to MLS that isn't clear text the server can enforce that as well ultimately it's important that the clients know about it but it can be very convenient if a malformed ad proposal gets already stopped at the server level right the next part is adding and removing clients to and from a group so um MLS doesn't care much whether members are users or their clients of users they're just members at the end of the day however we care um because they're fundamentally different rules so you might not be an admin but you are still allowed to add a client that belongs to you to the group so this is why we need to differentiate here um run yeah and if we support uh publicly you"
  },
  {
    "startTime": "00:52:03",
    "text": "know public groups then we would also you could be in a public group or you would need to maybe show that you have some some identity but then you could just join and start uh you can join in the same way um even if you're not on admin yeah makes sense um right updating clients so this might sound surprising for those who are not super familiar with MLS um and when I said this cryptographic property called post compromise security and what that means is that um clients update their key material regularly so that they can actually recover from a compromise and this is where that operation is expressed clients can refresh the key material by uploading a new Leaf node with fresh key material and replace the older one in the tree this is what's Happening Here and that's a dedicated operation because it doesn't really have any any other particular effect while doing so of course I can also upload more stuff that's part of the leaf node not just the key material that could you know introduce a new signing key for example if they have a new certificate they could propose a new extension and whatnot but fundamentally this operation updates a relief node and if nothing else there is only just new key material resyncing clients so this part um sorry but I believe is going to be very important um because we've heard from a lot of people who implemented the signal protocol previously um that things just go out of sync"
  },
  {
    "startTime": "00:54:02",
    "text": "um and that's not specific to the signal protocol at all but it's the only protocol that has been deployed at scale for end-to-end encryption and um it's the first time that we have cryptographic sessions at scale that last really long so with TLS sessions are typically very short so we never had the opportunity to witness that necessarily and even if it happens when you just you know tear down the session and and do a new one yes too um so you say signal is sort of the only example we have to look at here but like there are other you know ewe encrypted systems like I guess iMessage off the top of my head I guess do you mean Signal's the one that like where the details of it are public and where there's maybe a substantial body of research on um people's experience running it um yeah that's a good point I mean iMessage clearly is there um then again Apple doesn't usually share a lot of information on on these internals so that's that's a good point so Sigma is is not the only one technically but Cigna is the one we heard heard from about um yeah and where there's a body of literature on it okay thank you so yeah again it has nothing to do with a specific protocol it could be iMessage it could be you know anything else whatever Freeman is using for example um yeah but um the the fact remains that you have you know long-running sessions and you have bit flips on devices you have faulty memory uh you have all sorts of things that at some point materialize and what you need then is to be able to restart the session and the big question is you know how how detrimental is that to security um and particularly with MLS um it's a little more complicated because now we have group sessions so if things fail at a group level then you know you're out of the group"
  },
  {
    "startTime": "00:56:00",
    "text": "immediately with one-to-one protocols like signal and others um it's more granular like you for example you don't you're not no longer able to decrypt messages from a specific participant in the group but others still work with MLS it's pretty radical um you can quickly tell when you're out um because none of the messages you receive can be decrypted so on story short you need a mechanism to actually recover from that and this is what uh resyncing clients stands for um it's generally not super complicated um thanks to these external commits so the the thought behind it is that um you you actually leave the group and you rejoin it in one operation uh with one of those external commits as if somebody had just you know invited you to the group again um so the the remaining questions are questions about authentication in that context that mechanically um if you have still access to the server assuming that not you know your client has not been wiped completely um then you can actually resync uh the MLS part here um right next operation um and and by the way so I strongly believe that resyncing is something that has to be part of of every mature uh protocol I get anything you want to deploy in production at some point you have to think about resync you cannot really say yeah I will you know we'll see when when it happens because it will happen at some point and then you have nothing um to recover from that um yeah next One is updating client find out information so this part is not super signal interest yet um essentially the delivery service can"
  },
  {
    "startTime": "00:58:00",
    "text": "um also store information that is relevant for the next phase the fan art phase um and it depends a bit on how that phase is going to look like but this is to say that the the state required for that can simply be part of the the delivery service state and clients have a way to update themselves in that sense yes right uh for I think for resync I think it might be confusing um it we're not talking about a re-init you're talking about a participant joining and that had previously been in the group but doesn't have the doesn't have one or more epics in between yes um so just to disambiguate the terminology re-init is like restarting the whole group for everybody and discarding the old one and the MLS terminology for example when you want to I don't know upgrade the Cyber Suite so you re-init the group in the sense that everybody gets added to the new one everybody knows about it everybody discards the old one we think is specific to the client um so it's only the client leaving the group and adding itself to the group in in one operation so I I think that resync has a bunch of baggage associated with it particularly around history um so um just a just a thought if we called it rejoin I think it would have the semantics that you want but it wouldn't have the baggage of you're including all the history that you lost right yeah so yeah the history and other things are clearly out of scope here um that's a very good point um so it might be the case that the client missed a lot depending on you know when it got out of sync and when it"
  },
  {
    "startTime": "01:00:02",
    "text": "took action to get back into sync or or to Regine to use the new term so yeah make sense we can we can rename that uh share a strong feeling about it but I think we agree on the scope here scope is purely again on the MLS level how do I get back into the group right um yeah if you could scroll a bit further to him so I think that's that's pretty much it sending a message that we skipped over that part um of course you can send actual messages text messages whatever the content is going to be um that is what the um the content format protocol is going to determine ultimately um there's not much to be said about that so in the MLS jargon they're called application messages um just to distinguish them from commit messages and they contain free formats bits essentially and um they don't have to be ordered within an epoch and if applications agree they can even also be unordered outside of the epochs meaning that you could still receive application messages from previous epochs um it's just a matter of agreeing on that and keeping the key material around um and of course their son in O of one so a kind creates one application message hands it over to the delivery service and the delivery service uh multiplies that message and uh sends it out to everybody there is no individual one-to-one encryption anymore right the next part is the queuing service so this is probably there's"
  },
  {
    "startTime": "01:02:01",
    "text": "probably going to be more discussion on that um the queuing service is the fan art part and maybe we need to rename that maybe the terminology is not good enough here um but it it pretty much boils down to a delivery service receiving a message whether it's commit or application accepting it and then looking at its own State and determining who it needs to send it to and if it's local users then we don't need to specify how that works however if it's users on another server another domain then we need to specify how this message gets there [Music] um and the the most straightforward proposal here is to have a push mechanism on how to do that yeah I I think I want to punch on more details about the queuing service at this point um because this is really only selling once once we actually get there around go ahead yeah um you know we at ITF we have people with a bunch of experience in a bunch of different domains I think this is one place where this is a great place where we can call on experience from you know from people who have not been maybe like super active in other areas um or that you know people on the IAB or isg who have a little bit more of a broader view there are tons of these uh you know message bus architectures you know Kafka like uh jet stream uh Nats uh you know there there are tons of these Frameworks that people use to go and deliver things"
  },
  {
    "startTime": "01:04:01",
    "text": "from one from one machine to another um and I was yet I was unable to come up with an ITF standard uh approach that seemed like it offered similar functionality um anybody anybody here want to like say a few words about that or like a suggestion of is there a thing we can just kind of off-the-shelf use somebody's picking up so maybe maybe the question here or the challenge will be to figure out how much is in scope how much do we even want to specify here for interrupt so far it's been relatively easy for the delivery service um because you can argue that everybody will have that problem here um we have to see whether we want to specify a food protocol or just message structure to give you an example uh one extreme variant could be like a fire and forget sort of thing from an interrupt perspective or you only specify the the wire format of the message um another variant to go to The Other Extreme could be an interactive protocol where the um the guest delivery service actually responds to this fan out uh with meaningful information saying for example hey um you know this client no longer exists um or the user no longer exists so we might actually you know be interested in this sort of thing um to get this feedback because the owning delivery service might not have an accurate view at all uh on what's happening on other servers"
  },
  {
    "startTime": "01:06:01",
    "text": "because there is no other you know protocol to synchronize at this point um so they it might rely on feedback from other servers saying hey you know this this user is gone remove it from the group or whatever so yeah that's fundamentally the scope um but I'm not particularly worried about it just yet um because this will be details we can uh talk about um yeah I think that that concludes that document um maybe for the sake of completeness if we take a really quick look at the the new Mimi over https just to complete the picture sorry you mean a different draft Rafael it's a different draft yes we just uploaded it right before the the interim here I should be here then the moh zero zero here yes that one correct excellent thank you yeah if you can scroll down a bit again the boilerplate stuff um so yeah um this is really small and the idea here is to um see what we need in in terms of standardization at the HTTP level um so this essentially has two interfaces uh one for the first phase where you have this client originated request that comes in um and the other one is for the fan out phase"
  },
  {
    "startTime": "01:08:01",
    "text": "for now so all of the things we discussed like adding users removing users Etc all these things that pertain to a particular group um they go I think if you scroll up a bit yeah process group message in in one three one so this is one endpoint that receives this delivery um dirty service message and that does the processing um and and gives back a response so um the other endpoints they're essentially just to receive for example welcome information when you're not yet part of a group so technically that's not really interacting with the group just yet um and yeah so the idea behind it is these endpoints have names they have a Content a specific content type they expect and the body is really just the TLs serialized request from the delivery service protocol and the same goes for the response and that's pretty much it if you scroll down a bit more yeah um so welcome external committee information that's what we discussed earlier this is when you want to join a group you need to request that information um there are things um where the server can sign stuff and that's why you need a verification key so for example the server can sign a or issue a remove proposal um in the context that I just explained earlier where it receives feedback that for example a certain user no longer exists"
  },
  {
    "startTime": "01:10:00",
    "text": "uh it can actually if you remove proposal that is then committed by one of the clients an MLS says that every proposal always needs to be signed even if it comes from the server so that's why you actually need to know what the signing key of the server is um and that's the end point to retrieve it and so we didn't really speak about the details of one-to-one groups versus regular groups we did in the last interim session and they or even the one before I'm not sure and it seems like there's some initial consensus that in order to avoid abuse and spam we want to only be able to add people to groups if we already have a one-to-one connection with them and if we don't we cannot add them to a group um this is something if we come to that you know agreement finally that we can relatively easily represent with MLS by simply having two categories of key packages one that is publicly available to anyone and that's good enough for a one-to-one connection that needs to be accepted by users uh and another category that um is not available to everyone is only available to um people you have a connection with and those are also marked with a special extension so that you can confuse the two essentially like you you cannot take a key package for a one-to-one request and use that to add someone to an an actual group um so what is in scope also for the"
  },
  {
    "startTime": "01:12:01",
    "text": "delivery service is to make these key packages available and this is how you can you can retrieve them with the connection key packet retrieval and if you scroll down a bit more there should be another way to retrieve them um yeah the group key packet retrieval um and um yeah one one more one really important point is rate limiting and we'll also get back to that when we talk about metadata privacy um if we really aim for open Federation we need to be really careful uh about the ways the system can be abused and um so we already talked about how the authentication works and so we have actually several layers of Defense here in terms of right limiting um one which is completely out of scope is of course IP addresses but uh every request for a group is now specific to a group uh obviously and every group has a group ID and so we can write limits on group IDs um furthermore within group most of the requests they're specific to a certain member in the group um and then we can also rate limit on the um the leaf index of the specific number so you can relatively easily add the DS Level have rate limiting for sending messages because you can say you know user X in in group y um you know has already sent 10 messages in the past five seconds now we need to throw that down a bit um so we don't really uh lose our ability to do meaningful right limiting in this kind of architecture"
  },
  {
    "startTime": "01:14:03",
    "text": "right yeah so that's that document maybe there are more questions around that before we jump to the the Privacy stuff yep the keys open no okay so I guess different vibe today all right so we had this one slide from Ecker that was left right yeah exactly in fact when I spoke to him he suggested that you Raphael probably have a fair bit to say about it um so let me pull that up yeah at last the very end of this this deck um right so yeah so it seems like last topic to discuss here is privacy for metadata excellent yeah thank you um yeah this is a vast subject it's a complicated subject um and one that I read very early uh before the charger was finalized to understand whether this is in scope or not from my perspective this is really important when we talk about consumer messaging this is a lot less important for Enterprise messaging um and since consumer messaging is very much in scope for me um I want to say this is also on scope and it's something we have to think about um so going over the bullet points here um m s mostly protects the content of messages that is true it's a protocol for end-to-end encryption and it's designed for key agreement and using these Keys we agreed upon to actually encrypt messages uh in addition it has"
  },
  {
    "startTime": "01:16:03",
    "text": "um two kinds of messages or two two versions of messages uh they can either be public or they can be private and that applies to proposals and commit messages and the private ones they're additionally encrypted essentially to give some more privacy so this is one way how MLS could be used to have metadata protection at the message level because the header is also encrypted so there's very little you actually see in clear text it's the the group ID for the message but for example you don't see who the sender is of message you first need to decrypt the header and then in the decrypted header you can see who the sender is and then you can derive the key material to decrypt the rest of the message so this is one one mode that gives us a protection at the message level but only having an at the message level is not good enough because you know by talking about that we conveniently disregard that we also have two root messages from A to B and in that context we need metadata again um so that it's certainly not the full solution um so what is metadata and a curve seems to give some examples here which is all more or less the same so um who is messaging who um meaning who is the sender of a message and who is the recipient a channel membership so group membership in the MLS jargon um which sort of overlaps with who is messaging who because typically if people are part of a group you can you can already infer that they're messaging each other if the group is not completely dead um"
  },
  {
    "startTime": "01:18:00",
    "text": "contact lists um I guess that is out of the the specific scope of groups and probably more on a user level I assume um where users have contacts in general you could also see that as the sum of all the the one-to-one groups you have with other users another question is are we going to do anything to address that and so what we've been working on um is to see and and when I say we it's Conrad and I to see if we can come up with a variant of the delivery service that still lets us do all the things we want to do meaning you know adding removing people joining groups having this server assistance Etc and um so the to to make it short the the outcome of that research is that what we can do is we can have um pseudonymous groups where we still have all this group State on the server however the server doesn't really know for sure who the members in the groups are so it sees that there is a group with a different set of members but it cannot it doesn't see the the certificates for example of the users um so it's it greatly reduces the amount of metadata that a server gets to see uh because it it can only anonymously collect um messaging patterns in that group so it still sees that Member One you know is an active member in the group whereas member two hardly ever sends any messages and stuff like that but it cannot really correlate that with"
  },
  {
    "startTime": "01:20:03",
    "text": "um other identities like real world identities or identities from some sort of an identity provider um so we believe that we can do the delivery service in two flavors essentially and uh the difference are relatively minimal in the protocol they're a little more substantial in how the delivery service Works internally but at the protocol level it's going to be relatively minimal and it's very much like we have already done it with MLS where we have this public and private messages where one is encrypted and the other one is not um so it would be very similar to that [Music] um it would also come with uh yeah more explanation on the architecture as a whole so that's while we you know strip away some metadata we don't add it again later for example if we end up not really specifying how the fan art works then that might be one of the areas where we need to be more specific going forward when we want to do that yes Ron go ahead do we um I I can totally imagine that some people who want to deploy a messaging system want to have more metadata for various reasons or may even be required to have some and uh also you know lots of services that would be very keen to have limited metadata or no you know the minimum possible amount of metadata um I guess the question is uh how do these systems uh how do these systems interoperate"
  },
  {
    "startTime": "01:22:03",
    "text": "where I have one that is a sort of a you know metadata loving system and a metadata you know metadata phobic and metadata philic systems how do those two uh figure out what to do yeah no that's a good question so um the underlying assumption here is that uh nobody's forced to do anything like if you don't care about the metadata um minimization you you simply don't do any of that [Music] um and two degrees it's an open question you're asking but uh in the sense that we cannot fully answer it but my understanding so far is that the uh the interrupt that we're discussing is always on a group level so um if you want to interrupt for a certain group then you have to follow the rules of that group and if it's an Enterprise Group then you know what protocol to pick whereas if you want to interrupt with another group um then you have to follow those rules so we have not really expressed anywhere what kinds of groups we have and how that works and how that is advertised Etc um but I would see the separation strictly um at a group level so to answer your question Ron you mean uh like on based on the the owning the owning uh servers uh preferences that's who you think would decide yeah I mean a group always starts on an owning server like when you when you as a user you create a group you create it on your server um I mean that's at least the understanding we have now that you don't create it on somebody else's server you always credit on your server"
  },
  {
    "startTime": "01:24:01",
    "text": "um now that makes your back end the earning back end um and now you the next step is you invite other people to that group and the the context of that invitation has to make it very clear what kind of group it is and what kind of protocol is being used for that group and then either uh and it might be the case you know that we want to advertise that in uh extensions of key packages so that we can actually negotiate the capabilities and then you can tell by a key package whether or not it's fit to be in that particular group in the same way you can look at its support for cyber Suites today already yeah manually finally somebody who is not wrong actually go ahead sorry my microphone didn't want to cooperate um yeah no I've I've been paying attention I think that your draft has been good but I wanted to comment on this um from my view it it would seem that even though this may be up for debate among specific implementations different use cases might come forward with different configurations I would think that the ietfs work on interoperable messaging to Define what is the sort of bare minimum requirements would be helpful so that when implementations kind of sort of depart from that that is then um sort of their choice right or there's a distinction between this is the metadata that is at minimum required to run an interoperable messaging service and everything else on top of it isn't required but um is tied to features or other kinds of"
  },
  {
    "startTime": "01:26:00",
    "text": "services that that particular provider has chosen to implement and so I would because I feel like this section this this topic is so important I think that's the way that Mimi should approach um talking about it that's it yeah thanks um I personally at this point at least I feel it's relatively binary in the sense that you have to decide ahead of time whether you care about metadata protection or not and then uh pick that one flavor um and and instantiate your group um I don't think but this you know could change over time but I don't think it makes a lot of sense to say the you know the minimum level is always you know consumer groups because they have next to no metadata and then we can build Enterprise groups on top of that I think the price would be too high to pay for Enterprise uh you know vendors who really don't care about consumer messaging at all um but we'll see I mean at the end of the day we will have a protocol that is super detailed to look at and then that's better to take a decision based on that rather than some gut feeling that I have right now yes Tim uh yeah thanks so um it does seem like perhaps a lot of the tension here is introduced by the notion of wanting like consumer messaging to interrupt with Enterprise messaging because it's intuitively very just different expectations from like the operators and the users of those systems I think about things like privacy what I mean is that like if I join my employer slack I mean I understand and to some extent like agree to having some like either you know the messages themselves or metadata about them be visible to my employer um so I wonder I don't know I wonder whether Maybe"
  },
  {
    "startTime": "01:28:01",
    "text": "it's too big of an ask for this working group right to say that like yeah we'll work out a way that you can have like iMessage interop with Microsoft teams um because I wonder whether a protocol that can capture both of like the consumer and Enterprise models um like if one protocol can reasonably solve both um yeah that's a very good point um I I have an answer for you shoot uh so one of the reasons I mean this is in fact one of the reasons why the dma was created um if you look at the language carefully it actually talks about about provide your European providers being able to get access to customers on you know what turned out to be basically consumer uh messaging systems but let's take the case where you have a like a a stock broker and they're customers so they've been getting in trouble because their customers are contacting the stock Brokers using WhatsApp for example and trying to do trades and so this is a classic case where you have a user that is using a consumer surface that wants to talk to somebody who also has a you know an Enterprise messaging system because they have a customer you know supplier or customer you know provider kind of a relationship yeah the question is though which which protocol um gets chosen in the end right so you have a consumer talking uh to a company is that going to be on the consumer protocol or is that going to be on the Enterprise protocol um that's definitely something to to think about my gut feeling here would be that that would be the Enterprise protocol"
  },
  {
    "startTime": "01:30:00",
    "text": "um because it's fundamentally with the with us go ahead sorry maybe it's the Mimi protocol with the right intersection of of uh of settings you know basically what this is what I'm able to do are you okay with that and if that's not what your default allows the consumer messaging system says like hey you're being asked to go and comply with this thing that says that you're going to be recorded are you okay with that sure if I mean if we get to a point where it is you know so fine-grained that that we have you know like a slider between privacy and I don't know what what the other end would be um then yes but again right now I see it as a bit of a binary thing where um you cannot just you know granularly strip away the metadata from the Enterprise variant like either you do all of it or you do none of it um but maybe we get to that point yes Travis good uh yeah uh just on this the uh I guess rough idea for a protocol would be that it should be able to handle um as little metadata as possible just enough to deal with moderation or trust and safety um because it's always easier to add metadata than it is to remove it which I think is what you're kind of referencing there by having Enterprise and consumer being on sort of separate ends of a scale there um ideally the I believe the protocol that Mimi ends up accepting should be dynamic enabled to actually support that idea um being able to have the minimum uh sort of metadata to just operate and then being able to slide that up rather than slide it down if that makes sense yeah I pretty agree with you on a fundamental level like um if you want to"
  },
  {
    "startTime": "01:32:00",
    "text": "design something you know that is secure and or private you know you start from there and then you add stuff you cannot go in the other direction that never works however in this particular instance um we don't we don't have the luxury of having no metadata uh simply because we need the metadata for you know routing the messages for preventing spam and abuse and the question is only whether the metadata is pseudonymous anonymous or not so that this is the degree of Liberty we have is to take away like the the real life identities um to take them out of the system and doing so um requires a bit of work to make it pseudonymous so it really doesn't come for free you have to do you know more encryption at a certain level you have to do a few more things so for example and I didn't go into all the details there but um rate limiting becomes a bit more challenging when you don't recognize for people like you don't recognize your attacker between two requests because you lack you know the metadata you don't know who it is so um one of the properties for example is that uh you never have the same identity in two different groups you appear as two different users to the system uh even though you are the same user um so this is where it gets more complicated to to prevent abuse and spam and so one of the solutions there is to use something like privacy pass which gives you tokens that are essentially Anonymous but they're limited so you can spend them on operations without being recognized but you can only spend as many tokens as you initially received"
  },
  {
    "startTime": "01:34:00",
    "text": "at a time when you were in fact not anonymous stuff like that so we don't we don't have the luxury where we start with very little metadata and then we we add it for Enterprise users it's simply not um the reality we have in front of us right now yes go ahead run sorry just took a long time to unmute um the uh what do you see for for consumer services that want more information for spam or Abuse Prevention um that is perhaps selective like in the case where somebody said I think this is spam or somebody report you know reported or blocked a user um do you see do you see that finding it discovering like you know basically re-correlating a bunch of a bunch of sessions that were pseudonymous pseudonymous using using different identifiers do you see that as a sort of a feature or a property that may be required um do you see that as something that might need to be included in the protocol and if and if not like what would be the response to somebody who wants to have good spam spam or Abuse Prevention well I mean the the understanding right now is that you can address all these scenarios because if somebody I don't know contacts you and you want to block them um you can you can still do that because at that point you you see actually their um their real identity the user is not going to be pseudonymous to you and then you can also report that user to the system and then the system"
  },
  {
    "startTime": "01:36:02",
    "text": "can do whatever it wants with that report that's not really something Mimi should solve but um what it can do in Practical terms it can you know um limit the amount of uh privacy pass tokens that user gets or terminate the account or whatever um well I mean like an obvious way to go solve this problem if you were sure that it really was spam would be to then reveal the all of the you know all of the other pseudonyms to the other system so that they could go and basically kick them out of those other groups but like you know basically solving the problem for a single recipient isn't really very good like we what we want ultimately what what some of these providers probably want is the ability to take information that somebody was a that some user account was used for spam and used that to go and help other people who were who are recently communicating with the same the same real user yeah so that again that works with privacy pass so the Privacy pass issuance is at the user level uh very much not Anonymous at all um so if that user has been flagged for misbehavior um it will not receive any new tokens and then it might still have some left but it can you know can and spend them and generate a little more spam that the run out of tokens very soon and kind of receiving new ones so that's essentially how we how we prevent that across groups"
  },
  {
    "startTime": "01:38:02",
    "text": "yes Travis uh yeah sorry yeah microphones are taking a long time to unmute today um hmm just out of interest is this stuff written in a draft either published or unpublished at the moment um just for further reading we are we have a bit more um it's not completely finalized I mean the idea would be to to bring that um to the delivery service document as we flesh it out more um and you know whatever version we have today which of course not be the final one because um there will be discussion there will be things that we have not really thought of um but yeah did I mean the ideal way for us would be to um to bring that into the working group as early as possible so yeah to transfer your question a bit more uh from from before on we have to do some serious threat modeling which we have already done but it's probably not you know exhaustive um and see what all the possibilities are and see if we have the right tools to prevent that and understand if um we are in a worse place than say in a system that had no encryption and no metadata protection at all um we can still do message ranking for example with Facebook Messenger does where you can you can you know flag um"
  },
  {
    "startTime": "01:40:00",
    "text": "messages and then stuff like that after the fact when they're revealed so users can still de-anonymize other users in the context of an abuse scenario that's absolutely possible so it sounds like a path forward here might be to start a draft that does the threat modeling that you were just discussing right so that we said that working group can better understand what are the capabilities we need in terms of moderation metadata does get uh provided in the protocol yeah I think that's a good idea are you volunteering to do that draft as well um yeah I would I mean I would definitely contribute I mean I can also get it started um it would be interesting if more people would um contribute to that um but since we have done some prior work here um we are in a good position to get that started anybody else in the room would like to help with that document uh yeah that's my microphone would unmute faster I can probably help out um feel free to ping me offline cool thanks um I can never say no to request for help so I you can also count on me in small in big ways excellent thank you questions this is good it's good that we have some action items because as a chair that's how I get evaluated is whether uh we're"
  },
  {
    "startTime": "01:42:01",
    "text": "handing out work to people I'm in Conrad maybe you want to say a few words about the threat modeling you were the one working on that more than myself before it progressed too much here about private art sorry can you elaborate on the scope of it like give me the thread model on the just metadata in general sorry I uh do you know well the idea is to start a document with a threat model um that is specific to abuse scenarios in the messaging system and to use that essentially to Benchmark the metadata minimizing version to see if if we miss out essentially on some stuff because we have less metadata now oh I have to say I'm not super well versed with the current state of the art you mean the Franken the franking stuff that you mentioned earlier as well um I don't really have to look into that but uh of course be happy to start something yeah yeah sure I mean the Franklin stuff I'd just um mentioned that for the sake of completeness billboard row instead like blocking users you know what uh when is that important Etc what what effect does it have what desired effect should it have Etc and can we still have that effect we have this metadata Oh you mean the stuff on Anonymous credentials blockbustible Anonymous credentials well in that particular case privacy pass does a trick but um but yeah but the document is about the threat modeling and since we did some"
  },
  {
    "startTime": "01:44:00",
    "text": "threat modeling in the past um we could potentially reuse some of that that's the point here not not provide the solution but let's take the problem first yeah okay so it sounds like further you know discussion here will happen is that uh as that draft gets drafted um so does anybody have anything else on privacy for metadata otherwise we're at the end of the uh you know agenda for today um the official items we have 15 minutes left on the clock so is there anything else anybody would like to discuss today because if not I think we can give everybody back 15 minutes out of their day which is always for me a good outcome of any meeting yeah all right no takers so I think with that um sounds like we can wrap up for today oh sorry go ahead run I was just gonna say like unmuting preparing to say goodbye to everybody fair enough yeah it is weird how long that takes in uh and meet Echo um okay uh thank you Rafael very much for uh leading all the conversations today I'm very much appreciated"
  },
  {
    "startTime": "01:46:00",
    "text": "um and thanks everybody for attending uh so yeah we have another one of these scheduled another one of these interims that is scheduled for June hang on where is it uh sorry for Wednesday May 31st um since we got through everything today like there's nothing officially on the agenda just now but uh of course feel free to contact uh the chairs myself and Alyssa if you want to discuss anything in that session and of course we'll you know we'll talk about it more on the list as well thank you very much for taking the notes and drawing the slides oh yeah so long folks"
  }
]
