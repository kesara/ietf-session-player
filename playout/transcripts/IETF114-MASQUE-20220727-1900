[
  {
    "startTime": "00:00:05",
    "text": "okay you can share um thank you all right before we get to started can we get a volunteer to jabber scribe and a volunteer to take some notes quick everybody look away be sure to look at the remote attendees they can hear yes"
  },
  {
    "startTime": "00:02:06",
    "text": "oh so what exactly does a jabber scribe do in the current situation well the traditional mode for anyone who is text only and listening to the remote audio stream question mark yeah i can do that now it's actually useful that we've had a few sessions this week where someone's audio like just we couldn't hear them their microphone was on the frets so they said that i can be me i can be jeb prescribed i think ted was also volunteering but thank you ted who would like to take some notes somebody want to bite the bullet can we get two people to take notes and back each other up sometimes it's a little less intimidating if you have a partner in crime thank you very much do you want minimum is anything that we appear to decide and outcomes from different questions and conversations no need to transcribe it's all on youtube exactly all right thank you very much sir"
  },
  {
    "startTime": "00:04:06",
    "text": "all right with that out of the way let's get started welcome to mask at ietf 114 this is the first in person-ish meeting of the mask working group we had one in vienna that's the ish part um diving right in this session is being recorded it will be on youtube anything you say will be visible and audible to everyone else in the world make sure that you have already joined via the on-site tool if you're here in person if you're here remotely via the video stream you already know where that link leads as usual you can get into the queue by raising your hand and leaving it by lowering your hand and you can start and stop sending audio please state your phone name before speaking and use headphones if remote this is the iutf notewell you've already seen it by this point in the week but please take a moment to make sure that you are familiar with what we do make sure that you're familiar with the note well this these are the terms under which we participate in the itf pay extra attention to the parts about the code of contact and how we treat ourselves and others in addition if you are here in the room at itf 114 there is a mask policy in effect you must be wearing a legitimate and good mask if you do not have one they are out at registration you can just go pick one up we have some fun helpful links this is mostly useful if you can actually click on them and this is our agenda for today we have a bunch of stuff so we're going to start off by talking about connect ip and moving some of that forward hopefully in a pretty big way and then we've got some new work that's being proposed in the form of a couple different individual drafts from different people and at the end we're going to take some time and talk about rechartering because our current charter takes us right through the end of connect ip and"
  },
  {
    "startTime": "00:06:01",
    "text": "stops there with that tommy let's talk about connect ip okay do you want to have your phone present some slides do you want me to click for you um let's see let's try this thing i'm already on qr code so i'm asking to share slides yes perfect are you going to approve me yes indeed thank you which it doesn't actually give you a place to select there you go much better all right cool can i control it yes i can alright hello everyone i'm tommy polly from apple and i am editing the connect ip document we have many authors uh so thank you to the authors if you recall from previous times this was a joint effort of bringing different proposals together into one unified connect ip earlier this week we did have a meeting of the authors to try to hammer out some of the issues and so the majority of this presentation will be trying to talk about the issues we think we have resolutions for all of them but we would like to get feedback from the room on that to see if there's anything we missed or things that we don't actually agree on and hopefully we can actually go and merge all the pull requests and make some progress so get excited everyone um but before that we do have some updates on testings and implementations uh so uh there was a connect ip table at the"
  },
  {
    "startTime": "00:08:02",
    "text": "hackathon i myself was not there because i was on an airplane but i was dutifully hacking on connect ip on the airplane um so uh connect ip implementations were being made in several places on several different code bases i don't think we've done cross implementation interop yet but uh a lot of work was going on and we've learned things from trying to implement dave oh sorry i forgot to join the queue dude it's cozy just to add from the hackathon folks we were very darn close to but everyone was realizing the oh implementing the mask bit is easy implementing the please kernel take this packet and put it where it's supposed to go is way less easy so mask magnus did a good uh summary at the end of the hackathon and kind of what we said is we're gonna finish this and reach interop in the coming weeks and for the next hackathon in london we plan to arrive having figured out the silly tunnel interfaces so we can really focus on the protocol stuff thanks yup but uh good good progress was made all around so thanks to everyone who was contributing to that and we had lots of people who weren't authors on it so thank you to all of them all right so first just to summarize some of the recent changes um in the latest version of the published draft we had done work to try to improve text around how you handle the uri templates a lot of this is lifted from connect udp as connect udp finalized so we want to make sure we had parity there we had issues with how address assign worked uh when is that required or not and so we tried to clarify that we talked about the fact that icmp is a good way to communicate errors um"
  },
  {
    "startTime": "00:10:02",
    "text": "and we also talked about how to uh make sure you had enough mtu for your ipv6 traffic so these are all good changes but as you will see a lot of the issues that we currently have open that we're trying to resolve our follow-ons to these so a lot of it's in the kind of the same space things that we realized were still left open alrighty to get into the actual issues um the numbers up here are the github issues i have kind of all the content here to talk about in slides but feel free to also look at the github issues and if we want to get really in-depth maybe we can switch over at some point right so the oldest issue we have is one just talking about you know do we need a default uri template kind of this was raised by the fact that connect udp has one it defined this well-known mask udp um and the structure of that seemed to imply that you could put other things under this well-known slash mask and so there's just kind of a question of do we need this for connect ip um i think there's you know good debate back and forth in our last discussion the authors kind of agreed that it actually probably does make sense because there are going to be cases where you may be referring to a generic relay proxy box just by name um and while it is you know very obvious that a browser that may only have a space for a name will definitely want to be able to do connect and connect udp there are use cases where it may need to do connect ip as well so there doesn't seem to be a reason to limit it from doing this and so we just essentially have the exact same text that connect udb has for connect ip to have the default uri template for that in this case the two parameters there are the target that you"
  },
  {
    "startTime": "00:12:01",
    "text": "want to connect to as well as the ip protocol that you want and the default for both of these is just star and star for wild cards which is already something that is supported by the ui template thoughts here any objections to having this be defined of course no one has to use it you can it's probably better to use a more specific one if you have a mechanism for that but for the same reason that connect udp had the support for just the hostname it seemed fairly clear to be parallel martin thompson it's great you can see when people are going to get in queue before they actually get in queue because they pick up their phone and they tap a button they tell me using well known again yeah but this doesn't actually have to create a new well-known registration it just updates the one that connect udp made oh yeah let's talk about that as well sure i mean yeah that's the uh part of it um but it's just like if we already did this for connect udp so yeah i mean i think this this goes to the um the question of how you plan to configure these things yep um and because you need a a uri what is it pattern or template geez yeah um that provides a really useful way of distinguishing this from um the other things you might put in in configuration because you have domain names in some cases and what appears to be something like a uri in in those other cases yeah so i tend to think that essentially requiring people to use the"
  },
  {
    "startTime": "00:14:00",
    "text": "full template configuration is a better choice and why i guess why is this different from connect udp then it's not which is so okay you just happen to be the first one to put it up on the slides i i think okay i mean i think we came to consensus on it for connect udp previously and that was discussed in the group okay so essentially it's like i don't see a good reason for this to go out of its way to not use the well-known that connect udp already established i i guess if if if we're going with precedent then fine yeah and like i agree that using a template like if you know if we use if we have something like what ben has for his directory like great use that but if you don't have that i don't see a harm in this davidskenazi i'm not really a well-known enthusiast but you're a well-known mask enthusiast nice so i'm realizing that the chairs forgot a slight update which is since the last ietf http datagrams and connectudp were went through itf last call were approved by the iesg and are now in the rfc editor's queue which means that those documents are pretty much done it also means that we can't change them which is great but i mean all 48. so anyway that's really great but that was the first deliverable of the working group which is great we all did that together hooray um but yes the two that will cost you exactly so we better agree on this so anyway yeah the argument that convinced me uh as well was that it's consistent so yep chip it but thank you david for that note that is a very good point we have two of our three main documents have now progressed"
  },
  {
    "startTime": "00:16:01",
    "text": "and that is wonderful hey ben schwartz so uh i i sort of reluctantly agreed to the inclusion of this template in connect udp uh and uh and so i can i can reluctantly agree to the similar inclusion here exactly that's exactly the same book if necessary uh but i do think it's like i don't think it was a very good idea there i think it's a little bit worse idea here um in particular connect udp uh when in the the connect udp draft the one that that's in off uh that's in the editor's view uh always has a target um this draft in my understanding does not connect ip does not necessarily have a target now connect udp also has recently uh well is is uh hopefully about to gain support for for non-target requests as well so there that will be somewhat parallel listener style for listeners yeah yes um yeah because we need webrtc but but uh this this has some weird effects here like the draft currently says the target isn't the target parameter may be specified yeah uh in when when populating the template but that actually has to be changed so this means in the pr it essentially says this default one always has it but the existing text on the on the template and the parameters says that uh star is equivalent to empty i i understand that i'm just saying you're no longer actually following the uri template engine rules because the ui template engine rules say that the target variable can be unspecified in the inputs to your template in which case the rendering engine will do something and in this case what it will do is give you a pair of slashes back to back right but but so it will not like the update to the text right is that in general regardless of actually the"
  },
  {
    "startTime": "00:18:01",
    "text": "well-known or not if your uri template puts these parameters within the path segment and not the query segment of parameters because there are the two flavors you can do there right that are allowed for this if they're in the path one then you must not have it be empty you must have it be a star so that's even worse um because that means that now i have to introspect inside this like as a client i get a uri template back and i have my variables that i want to substitute into it i can't just take my uri template and my variables and hand them to a uri template engine i actually have to go disassemble the template and figure out which which template structure is being used here in order to figure out whether i need to i think that's kind of a problem placement so that's a problem if we allow them being in the path at all uh regardless of wellness it's it's uh it's not it's not a problem even in this case and you know you can have empty path segments in each other you would just have slash slash i'm just telling you this it's ugly and that it creates weirdness uh if you have this now ambiguity of like sometimes it's star or sometimes it's empty string you could also just make it always be star and just allow empty strings and in which case you're saying the target parameter is always there and like yes that's fine i think that's a perfectly fine resolution and the other thing is um iproto is that is that um sorry what is it that's the ip protocol number uh okay which can be anything or you can say no i only want to open up for this okay i want icmp only okay yeah uh yeah in that case uh i mean well anyway we have there's some there's some fiddliness that that needs to be sorted out there okay yeah so if you put the slash inside the curly braces things go get interesting um and may solve the problem here uh"
  },
  {
    "startTime": "00:20:02",
    "text": "provided that your target and protocol um provided that you don't have a protocol if you don't have a target so if you get the order right uh but what if you said i want to open up everything that does esp because i want to run ipsec over this but i don't i want to send it to everywhere but i only care about this person so so you are saying that you could have one or both with yes yeah that doesn't work then so um it turns out if you if you read rfc what's it got what's the number again 6570 the uri template one yeah there's a bunch of ways you can spin this and perhaps that should have been the case for the other one anyway um but essentially what you do is you put the slash inside the the um the curly braces and so you do target slash it will make the path component optional at that point i see so you don't need double slashes so you wouldn't end up with double slashes or stars or any other sort of weird probably in there you just if you have a target then then that component is added if you have a a protocol then that's added the only problem there is that you need in the case where both of them are optional then you have to have some way of distinguishing between the two of them which is kind of awkward we can also just go the it's always there and you just put a star when you want it to be open-ended yeah okay to make it very explicit that like hey i'm trying to open up a full tunnel vpn here i'll need to have a look at the uri grammar before i can say that i'm comfortable with that sure that's fine uh david's ganazzi like i i did a bunch of reading and please correct me if i misread to figure out if like slash slash was allowed or a star was allowed and what it came down to is slash inside the path is allowed but there's a bunch of software that normalizes it and then it's going to remove one slash and then"
  },
  {
    "startTime": "00:22:00",
    "text": "you're going to have a sad day so we should avoid slash and star seemed fine um what the reason i'm okay with the text as it currently is because ben has a valid concern that you don't want the implementation of this that's using a generic uri template library to have to figure out if they're in the path or not but in that case you just always put a star like you're going to have this variable or you know it hasn't or it knows that it's a target that it's going to like it knows what to fill in exactly so i you know at the end of the day yeah it's kind of fugly but at least it's consistent with connect gdp whatever how about so what i would propose here is this like i think this particular issue we have agreed like you know we don't love the well-known but like it's consistent so like we kind of we came to agreement on that this other issue that ben brought up i think is a separate a separate issue of like having the stuff in the path component and being ambiguous about can it be empty can it be a star or like having it be different between where it is and that like that's the grossness so could we open up a new issue to essentially just determine if do you like do we really allow empty and that variability between empty and star well the the reason to allow mt is that if you're using a level three uri template and this is why everyone should be going wide-eyed and i hate uri templates but we've decided that that's what we wanted to use is so the level three because these are like pokemon for some reason is that you can specify uh question mark target and it'll say if it's empty won't do anything and if it's there it'll do question mark target equals what you put in and so that ability to save those bytes"
  },
  {
    "startTime": "00:24:00",
    "text": "is kind of neat like at the end of the day whatever four star who cares uh whatever simplest implementation or maybe yeah we decide that like like the other way you do is like if you recognize like it's always technically star but like if you recognize in the query string that you're about to put something equal star you can just drop it on the floor if you don't want to spend the bytes on it actually which is it's the same thing what the current pr does that's why i like it it's it's simple yeah this is this is gross this is not the grossest thing we've done it's not the grossest thing we will do oh man i can hear you okay sounds good um so i think it warrants a bit more discussion just to make sure we're happy with that but this particular issue seems okay next one um so we had a couple different issues around some of the new texts i was talking about ensuring we had enough mtu previously the text provided three different options i believe for how you validate you have enough mtu to get things like minimum ipv6 packets through like one way was you know you have a direct connection from the client to the proxy there's nothing else in between you you know you padded your initial quick to a large enough size you know you have room in the datagrams and then you don't need to do anything else to make sure you have a minimum mtu i think there's a middle one that was trying to say like oh you may have intermediaries and if you coordinate sufficiently with your intermediaries to make sure you have enough mtu then this could also work and then the failsafe was if you can't guarantee that you don't have intermediaries and that they have enough room for your minimum size packets you should do some icmp through this to make sure that you have sufficient path mtu um intermediaries are messy and gross and"
  },
  {
    "startTime": "00:26:01",
    "text": "so as we were talking we were like uh let's try to just like maybe let's just ditch the text that says oh maybe you could coordinate with your intermediary so we just say either you guarantee from end to end that you have a big enough quick connection to hold your minimum size or you do pathetic discovery through the tunnel and that's it for this ben is going to get in the queue once you can press the button oh corey hello oh yeah um i wondered if we need to be a little bit careful with a since we're tunneling other things um because the properties could change and while that's okay and one for quick it's not known for the protocols do we need to word around that in some way sorry okay can you just repeat it if you understood and you have response i'd like to get to to answer gory's question david snazzy here um it's let's say you have an end to end quick connection and you start with adding quick initials to uh 13 whatever the number is in there um you'll be fine but if you implement uh dynamic pmtud inside quick and your quick mtu goes down to something below that then you need to nuke the connect ip stream maybe we just need to add a sentence for that because our implementation doesn't do dynamic pmtud so we don't have this problem but if you if you do i'm just adding a sentence saying if you detect that your mtu goes"
  },
  {
    "startTime": "00:28:01",
    "text": "lower like we actually don't think we did say anything because we already have text that says if you detect that the m2 is not sufficient you have to nuke the tunnel so if you're not doing dynamic pm2d that means you start out with your initial size but that's not a guarantee that subsequent packets that you're sending make sure you maintain that size so like if the path m2 changes on you and you just don't notice it is possible that it goes then your quick connection is going to be right and then you'll send the packets and they'll just get lost and you'll realize that you're losing packets and yeah things go so i think maybe the assumption in quick is that that's all okay but if we're tunneling other things over quick then maybe that's a bit surprising that suddenly everything just disappears um i'm sure you work out what to say yeah yeah and just to add i think you're right but at the same time that's also true of ethernet and like if if that happens at some point you know like i think it may be worth adding a sentence so if we can take a note in the pr just to say like not even necessarily normative text but just like note that if your quick connection itself and like if that link loses its mtu uh stuff can go wrong and you probably want to just kill that stream if that happens so okay yeah that shorts so so okay you must do pmtod over the tunnel and if pmtud says less than 1280 or whatever then you can't do v6 what yeah okay so that's and that's actually i think miriam's question is what do you do right i mean is that it i haven't seen maybe the very latest text does it is very clear like go away so so that is one of i think that's issue 62 and i think mary mentioned that that may not be clear enough in this latest pr so we may want to update that i"
  },
  {
    "startTime": "00:30:01",
    "text": "didn't see it at all in the pr i think we made it like we discussed it and it's not in the text yeah the issue says we should say that you must close the stream and we were not clear when that was added the i mean maybe i need to pull it up but i'm 99 sure that in the pr it says if you detect that it's not sufficient you must abort the stream it i don't i didn't see it when i looked just now okay maybe i'm just getting that sentence maybe i'm just crazy but okay but let's just let's just add it then i think everyone's okay with adding it um so the whole text says like because we're setting sending everything about datagrams that's the only option but like the other option is to send it over streams uh i i i i think we when we talked before we don't necessarily want to go in that direction like you could have like some way to negotiate like i would like these to fail over to become reliable but i don't think that's the base behavior yeah that's fine i just don't think i want a must there or like if the mass should be bound to like using datagrams or whatever i don't know like if you if you really want to use if you want to do this right if you want to detect this and then fade over to streams you should be able to do it i see so it's like you must abort the stream unless you have some other mechanism so that is it this sounds like a must but we know you won't like in like the reality is that 98 of flows are going to tolerate this just fine and therefore as a as a client implementer i think it would be very hard to convince yourself like yeah i'm just gonna shut everything down and brick the user's device because like you know i'm not technically in compliance with ipv6 anymore uh as opposed to like well you know what i know i know i'm not in compliance anymore but those packets probably won't get out of the network if there's round packets well i mean so the mtu falls a little they're too small you're right no that's fine yeah the mcu"
  },
  {
    "startTime": "00:32:00",
    "text": "is a little bit below 1280 most things are still gonna so you can those because most of the applications on top of you won't be double checking that they have enough room most because most most applications aren't running all the way up to the mtu limit the ones that are are usually smart enough to have a little bit of of pmtud of their own in them and tolerate it and back off uh and well if you're using v4 that's fine you don't need to tear this up v4 technically has the same problem if you're you know at 576 or something but my my point is uh to me the thing that makes the most sense to to just try to be as like limited as possible here is to say like but you should do pmtud over the tunnel uh to find out the mtu if the mtu falls below 1280 you are no longer a compliant ipv6 implementation and and what you do with that information is up to you we could make it a non-normative statement of essentially saying like if you detect that you are not able to provide valid ipv6 over this you can abort the stream and just say like you can and if you have something else you want to do like be out of compliance or tunnel them over reliable datagrams knock yourself out i'm fine with any of those because at the end of the day we're not going to implement any of these we're going to pad the quick initial package and that's going to be enough all right so so it sounds like are we okay then just like the minutes of the issue saying like make this option a should do pm2d and just say you can close the stream when you hit an issue so as the default suggestion i'm okay with that since magnus since you filed the issue what are your thoughts when miriam failed one of them dude you're okay with it um yeah i'm about uh find out yeah bring this one um i just want to see that we have one"
  },
  {
    "startTime": "00:34:01",
    "text": "we don't have any loopholes in this so to say and then if you think it should without having that should very hard specific what it means you would end up in another problem so um but yeah if you're actually having that saying okay and the problem really is the http intermediaries here because even if you're paddling and you and you uncertain if you have an hp media you would run into this problem so that's why the master is supposed to be there to cover that situation but like so to follow the rule that if you ever say should you need to give her kind of the explanation of why would it not be so like we could even just be very explicit like you should do this otherwise you could end up in a situation where you're not a compliant ipv6 tunnel okay david what's your proposal i have a proposal that i think everyone might be okay with which is you know our what we do here never something that everyone loves um is to say um if you detect that the path mtu goes below the limit and you like sorry let me rephrase if you are sending your ip packets over datagram and the path you detect that the path mtu is no longer sufficient you must close the stream because you're in violation of the rc like you can send them another way like streams that allows that you could also not detect it you could also not detect it and uh like at the end of the day we're just we're we're doing lip service to the ipv6 rfc we're doing it right and in practice it'll be fine and it won't be a pain to implement for everyone i think this is a good little ground all right connect ip doing right by ipv6 oh wow i'm gonna i'll bring that to i'll break bring that to eric binky um okay does is everyone okay with that"
  },
  {
    "startTime": "00:36:02",
    "text": "yeah write it up sold okay thank you for everyone's input so far next one all right this one i think should be easier um previously we mentioned you can do icmp uh when you have errors like you know let's say you negotiated a full tunnel at the other side and then you told them here's your source address with an address assigned you say here are the routes you can send to with the route advertisement and then the other side just starts sending garbage that's not in that that violates your acls and they're being bad um that may be intermixed with good traffic you don't need to tear down your entire connection or your entire stream to them how do you let them know they were sending bad things and you could invent a bunch of capsules but we think that just sending icmp errors back is the right thing to do because that's they have the correct error codes and that's the right thing for this layer um it was kind of non-specific so the changes we did is we gave specific examples of like hey probably if you're trying to send something you don't have a route for you should send destination unreachable with the error code of like you can't reach that thing i forget which it's like number five um and same thing for if you send a bad source um and if you send a packet that's too large or then you get the correct error for that so just do the obvious thing for those um and then the only other part of this that's i think a bit more interesting is it essentially says that you should if you were giving routes about advertisements to the peer which not everyone does but like in a peer-to-peer vpn case both sides give it to each other in the client to proxy case just the proxy gives it to the client that should include in the protocols"
  },
  {
    "startTime": "00:38:00",
    "text": "that are listed as allowed icmp but then essentially if you are not giving routes aside like the client does not give routes to the server um it essentially says that it is always assuming that you essentially always need to be prepared to receive icmp packets so even if you are just creating a ip tunnel for esp you need to handle icmp over this thing because that's how you get your errors any issues with that art and duke has issues with that just to clarify this this is that the this is that the proxy by the way martin did google no hats um uh so to clarify the the cert the proxy ought to for these icmp messages in the tunnel and the client must be able to handle that whether or not they do anything with it it's not neces i guess we don't say anything about whether or not you need to forward them if you receive them from the outside it's more like you can generate them on the proxy to tell like client sends you as the proxy something that they're not allowed to send to and like you just you will you can generate icmp back to them of like stop you did the wrong thing okay fair enough um but the client must be able to handle that like prepared to receive is a weird like like you shouldn't crack i mean okay like you shouldn't have done this anyway um like probably what you're going to do is just log an error because like if this proxy server told you you're only allowed to send to this other ip address and you sent to a different one like you you have problems it's like i don't know what it means like must handle it's like it's just like you will receive this i don't know okay well right so i mean like this is kind of a wordsmithing thing but like"
  },
  {
    "startTime": "00:40:02",
    "text": "if without further negotiation the server might generate these things then the client has to be like prepared to receive them like it's not an error if i get a nice team exactly right okay it's it's almost like saying like you know if we've defined all the basic quick frames i don't think we have like a client must support receiving this quick frame and not crash when they see this number it's like yeah it's okay it's just the protocol all right all right okay so the point is that you might arrive and you'd be prepared for it that's cool thanks alex uh hi alex stranowski google uh i just wanted to clarify that the text that tommy has on the slides here about the language is not the language which is in the pr i don't think so i think the commodore and wordsworth thing is more about the slide please look at the pr if you think that sure text needs more wordsmithing yes these are conversation topics not this literal text then ben schwartz uh i just wanted to try to understand uh whether this really covers all the uses of icmp like does this mean that i can uh you know run traceroute through a tunnel whose ip protocol says tcp um you know uh i think like you yes but that doesn't guarantee that it's going to forward it and like like i don't think it says anything about whether or not you will discover a full well lots of lots of icmp black holes on the uh right right we can contribute to black hole we could say like you should not black hole icmp that that might be nice but uh but the the important thing is like i can functionally i can send icmp um yes uh including and i can receive icmp replies from from source ips that aren't the target right because uh traceroute in traceroute the the source ips are not points are not the target ip uh like is that also something that that works that's a good point in this framework or does our format compression lose the source ip"
  },
  {
    "startTime": "00:42:01",
    "text": "well there's no compression here okay um you know you would absolutely get it um i would like to hear other other authors opinions on this because i don't care i can either say like either you say you only allow it by default from your peer otherwise you say you just allow all icmp and just do with what you will i'm noticing nerius ghost is in the kill if i'm not funny uh so to answer ben's question i i agree i think we should just say just add a note that the source address can come from somewhere else yeah uh in terms of black calling we already say that like connect a pn points operators routers so if someone wants to knock themselves out and read the hundreds of pages of rc that have been written on what a router is supposed to do you should but one of them is don't blackhole icmp so i don't think we need to say anything i mean i think practically it's fairly likely that a lot of clients will just black hole ismp if the proxy tries to randomly trace route through them but it's true yeah that's probably okay oh that's the other point i wanted to add is you don't need icmp to do traceroute you can uh like if you're sending tcp you can send tcp packages with a small hub count and then the icmp is the response not the sent packet that's true that's true mia slightly disagree so this is only saying like even if you didn't ask for icp you might get it yes um so if you want to actually use icmp and you want to send icmp messages you should you should ask for it you should tell your proxy to do it i mean i agree that like if if my like if my intent is i want to open the thing so i can ping this random server and that's all i want to do just saying i want to open up icmp makes sense if what i'm let's say what i'm doing is like i'm trying to open up sctp"
  },
  {
    "startTime": "00:44:00",
    "text": "to this particular server i sh i think if i have an error reaching that that comes back as icmp just receiving the icp all the way through is nice i shouldn't have to explicitly say please also open up icmp for me yes um and so that's okay here so then i guess the only other case is like if i want to send random pings and icmp based race routes and also use sctp why wouldn't i just open up a request for each of those or like have my tunnel be big enough to do both that's kind of just like good practice with the proxy so so mine was first yeah i mean from the discussion we had why i brought this up it said that was really to ensure that you first the endpoint can sound nice and be back to the client if it sends something bad yes and to also get the feedback from beyond the proxy when it if it for example reach port unreachable or something like that the packet to be they should be returned back if the uh the proxy can actually map it back to this request so cool yeah violent agreement that's the same right like the if the proxy if approximately sees an icp you don't know if it's the one that you send if you send the same to the client or if you generate a new one i mean this is the same use case yeah no but there are cases like because we're saying that the icmp is used as an error message for certain cases for us to request it might be the proxy that generates only for the tunnel it doesn't comes from the lower the interface beyond external side yeah so if it comes from the outside you just don't know it's the icmp you get from proxy it's the same uh well i mean the the addresses on the icmp could be different like you could tell like oh this came from my source address of the pr i was trying to send to or it came from my proxies ip address"
  },
  {
    "startTime": "00:46:00",
    "text": "okay but like yeah you cannot stop it you cannot replicate right you can't stop it you can receive it from my other place and that's okay um so hi alex again uh this is actually an area which i tried to push back on two ietfs ago when we started adding iproto originally because of the complexities around this i think that the only way we can resolve this is that you can't actually allow sharing the same ip address with different ip protos if you want to support these sort of hard to distinguish icmp messages and align them up with the different tenants on the same ip so like i think one thing which is very clear is that having the proxy and the client be able to have over their direct point-to-point link exchange icmp about that is very easy to do but the moment you start saying oh i have an ip proto restriction that says i can only do dcb over the tunnel and also want to get icmp messages from the far end we need to make sure that we are able to restrict that down to the messages which are identifiable for the yes like three tuple there that is a good point because right these error cases are such that the proxy can recognize oh that icmp was in response to this packet that i sent and that came from this tunnel right and essentially it's like i think the proxy should have the choice to only forward those or if it thinks you have full control over this ip address forward you also icmp right so i think the so i think the minimum behavior that we need to guarantee is you will always get icmp error reporting on the point-to-point link regardless of what ip proto that you you have requested if you want to guarantee that you also get all icmp messages for this ip you must also request icmp for this iproto however uh advanced proxy may be aware of the three tuples and five tuples and forward you additional icmp information but if you want to guarantee you have a full tunnel ask for a full tunnel um you may also get some other icmp if the"
  },
  {
    "startTime": "00:48:00",
    "text": "proxy is smart great i think we can clarify that a little bit in the text but this is useful thank you okay um this one was meaty so previously uh i think last ietf we were trying to fix up address assign so we fixed this for one second oh sorry anthony you're requesting slides but i assume that means you wanted to be in the queue sweet one last comment then we'll keep going one last comment hi um i'm new to this mask thing but i know the esp and ipsec world rfc 4301 as a text what kind of icmps you should allow and that's basically looking in the payload because icmprs should have a payload part of the packet which you send forward and you look at that payload and then you decide was it allowed by the mask that sounds like very good text to copy yeah that only will allow if the forward packet was allowed then you do the reverse lookup and if the reverse lookup supports it then you allow those only errors yeah so that's a force rfc four three zero one is it next for it and i can support you thank you wonderful yeah i think i remember that text yeah i mean we can't we can definitely add more text if this helpful but like you can just decide to ignore all icmp messages or whatever like you can do whatever you want the only point is like you have to be prepared to get them yes yeah but i think it's good advice though because this is a that's a well-behaved proxy that's acting as a very nice tunnel all right so back uh to address requests previously we tried to fix address assign and i think we did a good job there uh long just raised some good issues explaining how address request had semantic ambiguity problems so this really isn't too much of a problem in a vpn to vpn site to site case"
  },
  {
    "startTime": "00:50:02",
    "text": "in which sides are assigning each other addresses requesting addresses assigning routes bi-directionally and they're just like all free-form tunneling it is more of a problem if you are kind of like client to proxy opening something out because previously the address request was just like an optional thing that you send if you want a particular address and if you don't want a particular address you don't send it um yes obviously the the proxy would never send that to the client because the client can't assign addresses but the sensible place if you do care about your address is to send the capsule for address request at the beginning right after your actual um request uh the server has no idea if you're going to send that or not and so it will receive the request maybe give you 200 but like it's how long is it going to wait before it checks if you have an address request capsule or not before it gives you an address to sign like it was completely ambiguous and you could come up with some you know rule of like oh you just negotiate out of band whether or not you do that but that was gross um there was discussions about okay you can add a header to say i'm going to send this capsule but that also is problematic the proposal here is just to say you always send an address request if you want an address assigned so there are different models of connect ip not everyone needs an address assigned because like for example like the proxy server never receives an address assigned from a client so it doesn't send an address request but if the client wants an address to sign it needs to send an address request if the client out of band already knows what ip address it has assigned to it and they don't need the address to sign then it doesn't need to send it so it's just kind of very parallel like if you want an address to sign you better send an address request um this also opened up kind of a nice property that"
  },
  {
    "startTime": "00:52:01",
    "text": "the address request previously you would only send if you had a specific prefix you wanted to be in or a specific address you wanted but if you don't care you send all zeros for your actual addresses that's nice because now you can say explicitly like i want a v4 address assigned to me or i want a v4 and a v6 or i just want a v6 um and you can also specify within that the prefix um so you can even have just all zeros but like you say i want to slash 64 or i want to slash 128 you can you can give the semantics of what you're expecting to get back and then of course the proxy can assign you something more specific within that or you can just use that as input as a hint um so i think that works pretty nicely uh one other tweak here just to make sure that if you're asking for v4 and v6 or if you're being assigned v4 and v6 you had it all at the same time was that just like we did for the route advertising capsule where we just had the capsule be a array of repeating route structures that have the different protocol of families the address requests and addresses sign capsules can contain multiple addresses so you know the first one just says oh this is a v6 address and it has the v6 address so then it's followed by a v4 address and that's all in one capsule any issues with this this was the hardest for us to actually discuss so hopefully we'll have consensus on it david scenazi so no i don't have any issue with this i just wanted to uh this was a hard one for us to reason about and it's a really hard one to explain so if if you're wondering what the hell tommy's talking about don't worry that's normal"
  },
  {
    "startTime": "00:54:02",
    "text": "about it and thought that was a nice solution that was really both simple and like avoided a lot of the caveats that we were running into so just wanted to say like we're we're on the same page i think this is a good way forward yeah i think it's one of the things that like looks kind of like oh that's kind of simple and straightforward but yeah that's after the fact yeah maybe a diagram would have helped but we'll we'll see what mt thinks he's taking the long way around i don't know if that's something you should be worried about so so have you changed the spelling at all i'm looking at the spec i'm looking at the the discussion here so this is a pr it's not merged in yet you said issue 66 oh 70. all right i'm looking at it now the pr doesn't change the wire format did the wi-fi just well it changes the capsule number and then it just allows it to be repeatable the interior of the capsule is now repeatable as opposed to being a one singleton so it's repeatable and you have to include the address family as well you already have this one so it's address family proof explain so there's capsule type capital length then address family address prefix address family address prefix address family address prefix okay i think i can probably get behind that it was like because i already had the parser for the other one it was pretty easy to just put a while loop around it and it worked one thing i realized here is that in this case departure fulfillment must be okay maybe we need to be explicit about that because if you're asking for both a v4 and v6 address and the proxy can only give you either of them yes you need to be fine with that so yeah that's a good we could add a sentence for that of just saying like remember just because you ask for something does"
  },
  {
    "startTime": "00:56:00",
    "text": "not mean you get it and that is true for both connect ip and life on the other hand well this is this says if you want something ask for it but you may not get it it this is really just reflective of life all right so okay no miriah yes so i i wasn't at the editor unfortunately but i read the pr and i thought it very good but i just want to confirm something so this doesn't assume a little bit of like pre-configuration knowledge about if you if you are supposed to request an address or not or whatever i i think so by default you request an address if you want to be able to descend yeah um it it leaves it open such that if you had some extremely specialized deployment where you were like completely out of bed you you just know you always have this it's a static i don't know what it is like or potentially even if you have an extension in the future where you say i don't actually put in source ips i let the proxy write my source ip for me i know i don't need to actually write anything here i don't need to do it so yeah it gives us that wiggle room but implementing the base draft you will almost certainly always send an address request yeah but that also means like if you want to do something else and you want to have this pre-configuration in there then it's kind of for all requests like like because you cannot provide it dynamically so like you have to just like statically configure it well so i mean just to be pedantic here while if you expect to get an address assigned you should send an address request that does not mean that you cannot get an unsolicited unsolicited address to sign nothing prevents any side from sending that i understand that it works i'm just saying it's like it gives you less flexibility or makes your configuration"
  },
  {
    "startTime": "00:58:00",
    "text": "a little bit harder i'm just trying to understand well let me explain so the the idea there is say if think of it kind of like dhcp if you don't ask the dhcp for an address you're not going to get one and you're probably not going to get you might not necessarily get the one you ask for if someone else has taken it uh so the idea is if you're expecting it to assign you an address you send that but let's say you're a vpn and in your via config file you put a static ip address you're not going to send dhcp over the vpn so that's what it's there for it kind of replicates traditional ip networking right or if you've agreed with your vpn that you just put all zeroes for your search address and it rewrites your packets for you that's also fine okay that's more insane but i mean as some fancy compression thing you're just like i just don't care about my addresses give me one whatever yeah always asking is like basically if you have this configuration then basically you have to take it like for all your requests like it's not like you can do it on a request basis uh yeah so so first of all does this add a round trip to the time before i can send my first packet uh no but it's a good question so um this goes in the same flight as your request so like i mean it's just like the capsule is back to back with your request you don't wait what source do i use so connect ip already has an issue with knowing what source ip to send from in general um so actually in some ways this makes it better so if i'm thinking of like full tunnel vpn or whatever i don't know but like if i'm requesting a specific address because let's say i knew a specific address i had received on another stream previously i could you know optimistically say please give me that same address i will send my initial packets from it you may drop them you may give me a different"
  },
  {
    "startTime": "01:00:00",
    "text": "address and so like it can fail over to something longer but this does not make anything worse certainly with regards to when you can start sending packets uh okay i think uh i would i would just like like it to be possible to just send packets on the the first flight basically if you're willing to tolerate nat but i agree uh okay you can like but they may be dropped if you choose a bad source address or you or we can also do a thing where the proxy can rewrite your source address for you if it doesn't like it regardless of that i i looked at the issue and i noted that there was a this question of um the prefix length so it seems like maybe this isn't entirely settled but what is the um what is the rule for the prefix length on the all zeros um so the capsules themselves yeah which you said that our address requests like the address assign yeah are of a structure that is repeated struct with protocol address prefix length right and so you specify in your request the prefix length so can i set up if it's it seems like all zeros means doesn't have a preference you see it means that i don't have a preference for the specific address i'm going to receive but i can express a preference for the prefix length i would like to receive i think that is not compatible with the ipv6 specification maybe not with ipv4 either how the ipv6 reserves is all zeros slash 128 that is the only reserved address for this purpose and so this is this is not expressing an address so think of it like so in ipsec it's like a traffic selector this is a this is a way of expressing uh desired range right it is not like i'm not saying i own this address like right but zero zero zero 64 is a valid sub well uh valid subnet well"
  },
  {
    "startTime": "01:02:04",
    "text": "uh or at least if you're allowed to assign that the other side may assign it to you right but now there's an ambiguity am i actually asking for it or am i asking am i am i is zeros here a dummy address and i'm not asking for it for real or so sorry to jump in on the wire format here you send 128 bits here right so sending all zero is a dummy yes that is a special thing and that happens to be resolved reserved okay and hopefully that resolves things uh so so what you're saying is that if i've like if i if i want to request the okay 0 0 64 i would send 64 bits of zero and then 64 bits of one okay i think that i can i can retract this we can and say this is safe because there is at least one reserved ip address in any range who's whose ip identifiers all zeros and therefore any any such subnet is non-allocatable it's essentially saying that this wild card must be all zeros all the way through to the end fine all right uh jonathan john athletics i was um slightly my eyebrows very slightly that when you said you could send a unsolicited address of sign even if you didn't get an adder's request because i wonder what happens if a client sends address a sign unsolicited to a proxy it would ignore it i mean is there a way to say that i mean it would i mean i guess should there be a way of saying if you get an address assigned when you're not able to be have your address assigned you should does it explicitly say that close the stream or does it need to say that i don't i don't think so um so we've talked about error handling in general um i i think it's certainly plausible that some future"
  },
  {
    "startTime": "01:04:00",
    "text": "extension that wants more complex semantics for different types of assignments could add some oh i didn't i rejected this capsule i rejected that but i think if you do something like try to assign your server address it just decides if it either ignores it or says you're a misbehaving client and closes on you i don't know martin what do you think yeah i think many things um but probably not about that i was thinking about another question that i've had hmm yeah so just because you send an address assigned it doesn't mean that you get the address or sign so if you receive an address assigned you just should send a request no sorry the other way around if you get a request doesn't mean that you actually get that ip address right so if you if you get a request you should just send in a sign with the ap address that you assigned yes and vice versa like if if the client sends a proxy like i've assigned you this address what you're telling proxy is hey i'm a client and i will accept if you send packets to me from that address like proxy's like okay i don't really care i'm not going to send anything to you anyway from that address but thanks for letting me know it's like you can give out your phone number to whoever you want but it doesn't mean they'll call you so another way of thinking about it of that is the client says i here's an address or sign can you can you please advertise this over bgp and for me and and establish a route to it i think the answer is just no yeah the question i got up to ask was um will you always receive an assign in response to a request oh that's a good one can you can you expect to see some sort of indication that that when you ask for something the the server has acknowledged that because there's this particular arrangement has this weird property whereby in a lot of cases the server is just going to go here have a bunch of addresses as soon as the"
  },
  {
    "startTime": "01:06:00",
    "text": "connection is established and um it doesn't really depend on seeing a a request in that in that case right well so let the way i think about it currently is that you know i think we're pretty clear that you are not allowed to send well sorry you are not guaranteed that packets you send will be accepted until you have received both an assign and a route advertisement and so on the client you can wait around for those and essentially like i don't know if i don't get it immediately if it's because you're taking a while to actually figure out what address i have i'll have to have some time out there i know it's a reliable stream so i know you received the thing so we can say like the server must eventually reply once it can actually assign it otherwise it should close the stream to be nice so i think this is a bug of something that we accidentally glazed over when we were talking about this okay i think when we made it such that every ad i think in the previous version of a draft address request always got an address assigned response but now that we've made it repeated and fallible i think we need to define that if you get a request that cannot be satisfied because we want to give you no addresses back whatsoever we still need to indicate okay that's fine or something which i think solves martin's problems yes so yeah it should be paired with a response um the response could be like if i if i send multiple requests you could just send no you still have the addresses you had before get over it um but you could also just wait like you probably do have to handle a timeout where this side just isn't responding to you so i i think there's that that helps i don't think it completely addresses the the suite of problems that are now possible so um in the case that you ask for say you ask for one address or two addresses and the server says no you can't have either of them i think it's reasonable to have either an error message coming back or even just address a sign empty yeah"
  },
  {
    "startTime": "01:08:00",
    "text": "yes which that's perfectly reasonable um but it is very very difficult to distinguish between a positive address assignment for something that you requested um particularly in the zero zero case where you you really don't care what you get and a spontaneous advertisement of uh addresses that that are coming through does it matter uh and and jonathan behind me is saying request ids um so from a client perspective do i am i still waiting is is still a question that i cannot resolve except for the empty case because the empty case will never happen except in response to that that's true but so what one property of these i want to make sure we're clear on is that an address assigned capsule is maybe we should be clear about this like inclusive of all of the addresses you are assigned now like it's cumulative so if we have it be cumulative which i think we probably need to clarify then it is unambiguous that when you receive it this is this is all of the addresses you have and so it doesn't really matter at that point like if there was a race like maybe i'll end up getting two of them that are duplicates if you want to generate an extra one in response to me but they are fully describing and at that point if the client has requested an arbitrary address address you could say here no one instead so say i request one address and it's an arbitrary one i don't care which one it is i get an address back that's how do i distinguish between that being a spontaneous advertisement on the part of the server and a response to my request i would argue that you wouldn't care and you may like you may get another response that's just a duplicate of that capsule like by the way you got this and you'd be like oh i guess that first one was spontaneous but i've already moved on okay i think i can probably see how that would work out yeah we should clarify"
  },
  {
    "startTime": "01:10:01",
    "text": "that none of that was written down i couldn't answer yes it was it was not written down it was not written down before thank you um i want to try to respond to ben ask about the crt cases initially i don't think they work currently i don't think you can do i think we need some type of extension saying that hey i'm going to send your pack of resource address please rewrite i think this actually ends up being something you need to signal explicit because otherwise you end up in or use the zero zero or something you need to we need to specify something for we can't leave it as it now so i well i i believe that you you could absolutely specify an extension that or or a behavior in here if we want to add it in that says if i send from zero zero i assume it's going to be the default thing you assigned me but honestly i don't even know if it's v4 v6 i think it's really messy yeah but what i think the one thing you can do now is if you know about an address you could request the address yes you you know you have a target because that's a specific address you have to connect to you could try sending on it there's a chance that they will assign you no address or a different address and then that was the case where that you'll have to retransmit your packet or like you know whatever you do normally but that one gets through yeah i understand that's the case okay that is the only case where you get zero yeah yeah well yeah but i think when you responded to them before it sounded much much wider that basic anything would work and i think that's wrong you need to have some really high probability that you know what the address is going to be to make this work or we need to have something either specified behavior or an extension yeah i mean well it's like i think when i saw the more open things like if you have the site-to-site vpn case where yeah yeah sure they they have their own computers that they assign to themselves then like yeah in a normal vpn case when you are saying hey give me an address you have to wait for the response before you start selling packets which is the case with all remote access vpns today"
  },
  {
    "startTime": "01:12:01",
    "text": "yes anyway but you know if this is a large enough tunnel that this is like this is i'm going to be able to send my entire device's ip traffic over this that one rtt is i think okay and if i'm doing very specific flows i probably have a previous address i can request so yeah benchmarks i i don't i still don't think it actually works uh what like the okay so so imagine that i i'm trying to optimistically send uh before i have the address assigned so i set my source address to all zeros i'm not saying that case and then i get that so that that's then using extension to do something like that so okay so then yeah so right now then there's there's no way to just like connect and and immediately send an ip packet in the way that there isn't connect udp no if i have a previous address so let's say i have one quick tunnel to my connect ip server and i've previously opened other streams i've already opened i see a an sctp stream to that host and i've opened an sctp stream to this other host i can just say give me another smp stream from the same address i mean i guess you can try but yes there's no reason to expect that the client would be assigned consistent ip addresses across those different tunnels but you are requesting it and so so for example like even the way we use connect connect udp today with our mass servers like there are lots of reasons on the web for within one tunnel to give a consistent ip address because lots of websites for example will freak out if you start changing ip addresses on every single connection within different resources um so i think it is reasonable and this may be kind of a deployment specifically like the the sides need to learn what is consistent in behavior but i think it's very reasonable for a proxy to be able to assign you a consistent ip address as long as it has it available uh okay i mean we're way outside the http resource model now right we're like"
  },
  {
    "startTime": "01:14:02",
    "text": "sorry i mean i met more different hosts like like for example like there are pages where like i load the main page and then they have their login resources which is a different host name and if it comes from a different ip address they scale it i understand i just mean like every every targeted connect ip tunnel is a separate http resource in principle they're like there's no particular reason why they should have this like state correlation across them where they somehow which is why it's a request like we can't guarantee it but optimistically that's something i mean i think i think you're right that it it's not it's probably just uh not that important i don't personally really know why the why you would want to target targeted connect ip tunnel uh anyway but uh i think we should just be very clear that that basically uh zero rtt is not really supported i don't think that's the way i would summarize it it's just like it it is just kind of the wild west and you can request something and you can be optimistic about it but so the wild west is what i'm trying to avoid because the the the weird thing you end up with is like i sent like i picked a random ip address for the source address and i didn't guess right i didn't guess what i got back in the end randomly is a very good way to probably fail to get so like this is my question are source addresses allowed to be rewritten or is there a rule like if i if the address assigned comes back and the source id i said wasn't on the list was my packet delivered was it rewritten or was it dropped i don't have any explicit indication well if you send something you should get an icmp error if it doesn't like what you did okay so that's that's great i would like to see if we have a hard rule that says like yeah either your packet is like dropped yeah that's what the other text was about to say you should get an icp error in that case okay that then it's clear that you know yeah yeah so i have not cut the queue because i think it's important that we close on this to make some progress but please do try to keep things free this is the last"
  },
  {
    "startTime": "01:16:01",
    "text": "slide it's the last big one um so i wanted to reply to ben and actually try to clarify some of the things which i think there's some confusion here so there's a couple different modes of using connect ip i think broadly speaking the dynamically assigned openvpn case zero rtt is almost never going to work because you're going to be assigning these ip addresses to a virtual network device on the host os anyway so i personally consider their zero rtt to not be a priority or a goal so i think the place where the zero rtt optimistic packet sending thing there makes more sense when you're doing one of the targeted tunnels either because it's a udp user space thing or something like that and there particularly if the client already has a long established uh h3 connection which already has multiple such targeted connect ip tunnels with high probability it's going to be load balanced to the same process module on your immediate areas in which case it already has in memory the address assignments for that client and it is very very very likely in fact almost certain for most reasonable implementations it's going to reuse the same ip address for that particular client it's not guaranteed it's not going to have to get an error back in case it doesn't work so if you want to use i mean if you believe this then it should be a shed if you would i think i thought it already is a shirt like i thought we already have a texture of it if a client asked for an ip we should give it back but like we might not right like there's no guarantee because it might already be giving you somewhere else yeah uh but the other thing i wanted to mention here is that you never have a guarantee a packet delivery here if it went over a datagram so like even to your earlier comment of like i'd like to get back on icmp earth it was lost somewhere on path you're not going to get it so all of those things around the other commentary around like is it going to be written with an extension if we have that in the future like you could imagine having an extension of like please go be right to my target ip why i might send you garbage source bits and if that gets sent before the package is processed then yes you should expect but that would work but that's not currently defined in the base exactly exactly cool no we do have one more i think this is already covered yeah oh sorry mike mia um have a question regarding this idea"
  },
  {
    "startTime": "01:18:00",
    "text": "we had about sending an empty address assigned if you don't want to give the client an assign an address or yeah why would you do that i mean why don't you if you don't want to give the client an address then just close the connection right yeah more realistically you just close the stream i think that's a better option that's a good point thank you so actually this is relevant to what i wanted to ask i think part of the earlier discussion we changed something that's not currently in the pr but i think is a good change which is to say that now address assign is cumulative yes and i know again i'm going to write it uh and that solves some of these problems so let's say you know if you i'm only assigning you one instead of two like you can see that uh so that's nice i just want yeah i guess so yeah this solves unassigned which was oh that's great yeah yep cool um bingo yeah all right that's even better so all right uh oh sorry uh jonathan was saying that that allows you to remove addresses and i'll have a sentence that says that actually because why not right and like i think it should still be permissible to assign only zero addresses because potentially in a side-to-side vpn case there may be a moment when all connectivity is lost and then they bring it back online and you don't necessarily need to tear down your quick streams yeah like i mean i don't think it should be forbidden to do that yeah i don't think we need to say anything let's say yeah uh cool okay no i just wanted to make sure because i was kind of a non-trivial change to the pr that we had the editors had agreed to i just want to make sure that no one objects to that but it does seem to solve quite a few things nicely and on top of that it becomes fully consistent with route advertisement which is just next exactly yep um so the last bit here this is essentially already covered in our discussion we just had like if you need to send the packets you need to wait for a signed right advertisement if you want to know when it is time to send"
  },
  {
    "startTime": "01:20:00",
    "text": "address a sign you wait for an address request i think it's very clear uh just the one last thing i'll mention which we believe is not in scope for this document but if you are trying to extend connect ip and you want to have fancy new capsules that do things to affect your routes and addresses and those are like super important about the ordering you need to be concerned about the ordering or have a way to batch them but that is left as an exercise to those extensions to deal with and it does not need to have any complexity into the base connect ip draft and that is the last thing i have so unless someone has a point on that we can move on to the rest of the agenda so close all the issues thank you very nice thank you tommy next up we have ben do you want to share slides do you want me to share slides cool cool magic magic slides thank you all for the engagement on that by the way we're very close to the kind of end of the issues list for connect ip so this is excellent to make some good progress access service description first okay sweet uh okay hello http access service description objects next so the the backdrop here is that uh although it's clear how we describe and convey and configure a connect udp endpoint or a connect ip endpoint the services that we're really interested in i think are likely to be more complicated than that they're likely to have multiple components so i think that it's reasonably likely that you'll have connect udp and connect ip"
  },
  {
    "startTime": "01:22:02",
    "text": "and doe all offered essentially as a package meaning tied to the same user accounts intended to be used together as a as a service um i think it's reasonably likely that you could have a doe resolver this associated with an old-fashioned connect tcp proxy i think that there are a bunch of these different combinations of uh of these services that we i think are going to want to be able to configure convey uh in a in a standardized way next and so the realization for me is that although that we have i think all these different potential use cases they actually are all instances of a of a single pretty simple general problem we need a machine that takes as an input a url or an origin or you know could be just kind of a string and its output has one or more of these different kinds of services that we've begun to define both here in mask and in ojai and potentially anything else that is an access service a thing that you would want to use as a component of a larger access service that helps you get access to something else on the internet okay next so the thing i'm proposing here is a really dead simple json format and the easiest way to talk about it is to just look at one so like here is a an access service description of a uh of a proxy this proxy has a doe server a connect udp endpoint a connect ip endpoint and an ohio relay and so like rather than saying oh client you know your user interface has like four different text entry fields and you're supposed to go in and paste one after another all of the different um"
  },
  {
    "startTime": "01:24:02",
    "text": "all the different uri templates for all of these different services we can say look we're standardizing a format and so your your user interface has a single input field uh and that is uh maybe a url hosting a file like this maybe you know maybe even literally a file picker and this thing is if this thing is actually a file that's being passed around uh next here's another example this is how oblivious doe would be represented in this so again we're we're tying a doe service to some other kinds of access services in this case a gateway which helps you get to that doe endpoint and again it's just a very simple json format next so the idea for this draft is that probably access services all these different sort of composite services that i've been talking about are generally identified by a url and that is the url of an access service description it's a url that you send a get request to and it sends you back a json object except there are some cases where that doesn't work where for a legacy reason or for interoperability with some other system the only identifier we have is an origin or a host name we don't we can't use a url as our initial identifier and so in that case we use that well known we say this thing lives on a download next okay so like we can solve any problem by introducing an extra level of indirection um and so this is just a level of indirection instead of passing connect udp uri templates around we pass around a file containing well a url of a file containing connect udp templates and i think there's a bunch of useful stuff that this enables like"
  },
  {
    "startTime": "01:26:01",
    "text": "you can if you want to do fast http 3 bootstrap you need in well you you arguably need a uh https records you need to be able to query https records out of the dns but you can't do that unless you actually have a dns server that you can use know the proxy can't do a connect udp proxy can't do that for you so you want a dose server associated with your connect udp proxy uh because the whole point of connect udp is to be able to use http 3. so you know we can enable that we can enable encrypted client hello through a proxy and we can make that work even for these sort of legacy cases uh like the ones that we were talking about just uh an hour ago where our bootstrap input is a hostname because we're we're stuck in the in the legacy world where we're we're configuring old-fashioned proxies that aren't a full url there's some growing interest seemingly in client-side dns validation that's another case where the client needs direct dns access uh that a proxy like connect2udp doesn't offer i also think there's another sort of category of interesting ways that this can be useful and that is helping the client to learn more about the capabilities of the access service so for example you know we're about to talk about connect udp in listener mode there's uh currently no real way to discover whether a given connect udp instance supports listener mode you could try it and just see what happens uh but uh you know we've as we've often argued the the requests that you make to a specific resource are only valid for that one request right so you've got it in http 500 but you don't know that you're always going to get a 500 talking to that and even if even if you sort of are"
  },
  {
    "startTime": "01:28:01",
    "text": "willing to buy that that you can sort of probe for the capability to find out if it exists it's uh it certainly seems like more work than just being told at startup like here's the capabilities of this thing uh you can evolve the capabilities of your service right you can start by launching a connect udp server and then you can add connect ip later and you don't need to go and reprovision all of the clients that you've ever onboarded right they can just reload the configuration url so oh and finally this format is a is sort of a perfect fit for key consistency double check which i was talking about yesterday in in ojai because again that's a case where we need to grab something like an oblivious doe configuration as a you know and and and essentially treat it as an atomic unit and so here we have a format for representing those as an atomic unit so i think this is a useful thing it's dead simple and i think mask would be a good place to work on before we get too deep into the queue we have a timer on screen which is for both of your presentations i figured i'd let you allocate time to whichever one you wanted okay great uh quickly google uh thank you for thinking this through thank you for bringing it to the working group um in our infinite wisdom we specifically excluded proxy discovery from the charter um doesn't mean we can't recharge it of course uh i'd be interested in the communities to use if mask is the right venue for this or many or one of the many other working groups that this would touch thanks all right tommy polly um so thanks for bringing this up i think it's a very important conversation to have um in general i feel like i should like this direction and like you know certainly in the deployment we have of mask we have config files that say this is a thing that is a ohtp relay and a connect"
  },
  {
    "startTime": "01:30:00",
    "text": "proxy and a connected udp proxy it's like it it feels similar however like i'm not convinced about this particular shape for it um i think it's combining more than we need to particularly about like locations and keys and capabilities trying to all be in one json thing it's like both too much information that's available to everyone in one flat way that may not be specific enough but there's also not enough information to actually be fully useful for each of these use cases um regarding the scope of working group i think if we have a version of this that is just about mask proxying like things that proxy end-to-end connections but not ohtp and not dns then that can belong in mask but i'm not convinced about it being in mask if it's trying to do all of these things i think it needs a much broader audience unless we turn mask into the all things oblivious and proxied working group which is a i don't know i don't know if that's even transport thing anymore um specifically around here as i mentioned like i'm concerned about keys like when we find like you know your key rotation scheme in your key management scheme may be something that for your http server is distributed in a different way such that the person maintaining this one big file now needs to worry about the key rotation management of a bunch of different services that i think ends up being quite complex i think also you know a lot of people aren't going to be opening running fully open proxies like it's one thing to say i'm a proxy but even today like on the internet like you're not going to have a proxy that you don't have authentication to that just lets you do like here i just have connect udp connect oh http just like the whole world um i think anything around this would need a lot of like acls of like i allow ohtp relays to these gateways or"
  },
  {
    "startTime": "01:32:02",
    "text": "like a lot more specificity which feels like they need to be separate configs for those different protocols and also be related to an authentication source like if i'm a client who has authentication to use this particular proxy in this manner i have access to these services but people who are just random people who typed in a string into their browser should not have the full capability so these are just some of the questions it raises and so i think we need more discussion more work on it and i lean towards trying to understand the in-depth use cases for the different protocols before we try to combine them all together uh jonathan yeah i think my my theory was sort of similarly but more narrowly i'm since this is configuring things from i think i think at least four different working groups and possibly five i'm dubious whether you could do them all in one as opposed to each working group defining its own configuration maybe like you'd have some uh here's the bucket to put things in and then each working group would do it's how you configure its protocol but i'm dubious about you know defining things for ojai or deep deep in this work group davis kanazi google privacy of all the things enthusiast um so first comment is i i can i can kinda see how this is useful but i can't see anyone actually using it who would use this uh sure so the the the easiest example for me is that this this the use case i'm principally targeting here is exactly the the use case that we were just talking about with the dot well known uh uri temp the fix dot well known template for for connect ip so like that's a simple case where you"
  },
  {
    "startTime": "01:34:00",
    "text": "are you you've provisioned a bunch of devices and they have authorization to use an http connect tcp proxy and you want to augment that with a bunch of extra services and so the way we've started to try to do that is by saying okay for each extra service we're going to define a new path on dot well known and that's going to be we're going to find a ui template that lives under dot well known and then that's going to control the structure of all the connect udp and connect ip request that you generate my view is that those are not good solutions as i mentioned earlier they have a bunch of problems for example uh they break the http model of uh of requests because if i make a request to if i populate that uri template in order to issue a request and i get back a 404 or something like all that says is that that one particular uri doesn't exist it doesn't tell me that whether the uri template itself is valid or whether there's some other set of inputs that i could put in that would actually work uh that also it means that i need to to find out the capabilities of this thing i need to send a bunch of different probes i need to separately probe all the different capabilities that i'm interested in i can't just ask what are the capabilities associated with my local proxy so that to me is like a very simple use case uh and you know moving forward i think that our proxy configurations will be will not limit us to to host names we'll be able to configure whole urls and so you know i imagine going into my settings menu and saying i want to set my system proxy to this url and that url you know looks more or less like what i described it it has tcp udp ip ohi and do all in it and any of those can change later and uh you know the there's a standard so my my phone knows and for authentication probably uh you know there's some kind of like oauth authentication flow it's a unified authentication for all of those services"
  },
  {
    "startTime": "01:36:01",
    "text": "so i i o auth once and that that you know those credentials then are used across all of these services so i don't have to re-authenticate to all of them that's uh that's my what i'm thinking of so that's a description of what you can do with this not of who's going to do something with it but anyway i've taken up enough of the time we're almost done uh i would want to see people interested in implementing this before we sure i mean i am interested in implementing this on android for example i would like this to be an android system settings that i can drop into android and say like under my vpn settings i'd like to have a mask vpn setting where i can drop in essentially one of these one of these urls and then not just get connect ip but get the whole suite of associ of access services associated with uh one of these complex services okay that sounds interesting um then to your to the second question i because this touches on dough on uh oh hi uh on dns sec uh i don't think that mask is necessarily the right place i think that the the the layer that this operates over http you're describing all the things that you can do with http though dns sec sticks out on the side but that's just a that's just sort of a an enabled an enabled behavior there's no connection to dns okay so i think maybe but https might be the a better fit john isn't the dispatch i actually agree with that okay well it looks like i don't have time to talk about the other slides so uh i guess we'll we'll talk about this some other time do you want to drain the last two folks or totally up to you sorry sure um so mike bishop i'll be very brief um"
  },
  {
    "startTime": "01:38:03",
    "text": "respectfully disagreeing that this is not actually discovery of the proxy this is discovery of the proxy's abilities once you've been configured with a proxy um so i think there is a lot of value because no typical user is going to know oh this supports udp but it doesn't support ip and it does support oblivious hd who even knows what these things are outside of this building um you give it a host name it lights up interesting privacy services i think this is useful i think the the question of crossing groups is easily solved by it has niar registry each group can register their own config thing and it's just a list of supported services at this at this host name now does it belong here does it long and dispatch i don't know all of these are reasonable somebody needs to define it and everybody else needs to register i'm alex jonovsky here actually mike just said what i wanted to say much better i mostly wanted to say that one of the things that i was seeing with connect ip is that we've continuously had a discussion that people probably want connect ip and connect udp proxies to actually be hidden so i think deciding whether or not this is a discovery system or a capability system is actually a very good point and one of the things which i find would be very interesting is if whatever mechanism we choose this json file potentially one of them is what happens if it's behind an authentic authenticated http barrier right like you probably don't want to go and tell someone what the capabilities of this proxy are until after you know that you're willing to serve them and you might be willing to serve different capabilities to different classes of authentication and i think we wherever this ends up going we should probably think about that as well sorry just really really short um one thing just for when we're thinking about"
  },
  {
    "startTime": "01:40:00",
    "text": "some of the questions going forward um david was asking like who will use this and i i actually you know completely get from a client side like yeah i would love to use that i think the question we want to answer collectively is on server proxy ants because they're the ones who have to publish this who is deploying these sets of things and what things are they willing to lump and what are their requirements on client authentication or other things like that and those are the people who we need in this conversation who i haven't heard yet here all right our last set of slides before we talk about rechartering in our little bit at the end all right did i have eight minutes yes indeed cool everyone i'm david scanasi and uh so this is a draft that came out of a conversation with tommy where we were talking mainly about connect ip and forever i don't even remember what specifically we were arguing about doesn't matter but tommy mentioned oh i'm gonna run webrtc over connect ip and i thought that sounds wrong and tommy was like well no it's super easy i inject my user space ip stack right underneath my user space udp stack underneath my stuff and boom it just works look i even have a demo and that's kind of cool but um my thinking was maybe we can do something simpler that is just a small extension to connect udp so that's what this draft is but at the end of the day like the question that i'm asking the working group the most is which direction do we want to take for browsers doing webrtc over mask do we want an extension connector dp or do we want to use connect ip that's the real question for the working group i'm going to quickly run you through next slide please um"
  },
  {
    "startTime": "01:42:01",
    "text": "so um connect qdp is great um but it only allows connecting one five tuple so that works when you're only talking to one target but that doesn't work for webrtc next slide please so let's see how this works so the way it works today alice talks to the stunt server the stun server is also talking to bob it tells bob alice's address and then alice and bob could talk directly of course there's a lot more positive complication but for the purpose of this that's what matters next slide please and they can have their very interesting voice call next slide so now if we have a proxy in the mix that we want to do mask with alice is going through the proxy for everything the proxy talks to the stun server the stun server tells bob the address of the proxy bob talks the proxy next slide please and they can have this time their very interesting voice call again next slide so the feeling i got when tommy proposed connect ip it was like okay if you look at it the right way connect ip is a hammer um but maybe it's not the best tool for this job um mainly because uh speaking for chrome we don't have a user space ip stack or user space udp stack in there i'm willing to bet dinner that firefox doesn't die there and on top of that you need to have every datagram carry udp and ip headers which is a bit silly when all you need is the udp payload and some addressing information next slide so we do connect qdp it's great get a bundle of slides and it's connect2dp with that allows you to talk to multiple targets from the"
  },
  {
    "startTime": "01:44:00",
    "text": "same source next slide so how does it work this part doesn't really matter because like this is sorely in the draft but all you need to do is for the for the path that we've had before you send stars instead of a target when you get started to say i'm and then you have a connect udp listen header we should like shut this name but not today um and then instead of just sending udp payload oh yeah this registers a context id which was the extensibility mechanism built into connect udp and then you use that context id and when that's present you send your ip address and udp port with each datagram so when you're sending from the client that gives you the target from the when the proxy gets it it sends it to that target when it gets something from a target it puts those fields in there when it sends it to the client so it knows what the source was dirt simple and that allows you to build stuff on top of it and as usual it's turtles all the way down next slide and so [Music] discuss uh i i mainly want to hear about the this versus connect ip but any other questions on this do we think this is reasonable um where do we go from here all right all right jonathan is first so is this sufficient that i could run an https uh server http 3 server on my uh you know and get incoming connections uh yes we need this for tcp also uh so that would probably require an extension to regular connect as opposed to connect udp um but yeah so i'm not particularly interested in that i mean it just it just seems like this is the sort of thing where you know we're probably already setting you know as soon as any it first in the world hears about these protocols their hair is on"
  },
  {
    "startTime": "01:46:01",
    "text": "fire this is you know adds gasoline to their hair so no thanks that's i didn't thought about using it like that that's evil i love it tommy um [Music] so looking at this i think this is simple and straightforward and the problem with the connect ip variant of it is that you don't really have a port allocation service and so like you get too much um on this so i think this is cleaner for that regard so i think we should just adopt it and do it and i think it's a very nice extension and it's actually the most compelling extension i've seen to actually use a context id and i really want to have webrtc work over this cool yeah for probably similar reasons i do ben hi uh so i i do want this i don't think it's as simple as it looks i made some comments on the the list about some ways in which it's uh doing it right is going to be a little more complicated on uh on the point about running servers this thing is basically turned and and so we should take a good look at turn uh one of the things that turn i believe does is uh make some recommendations about the kinds of nat policy that uh that servers ought to offer uh it basically says that you should do address restricted not um i think you know we don't need to make a strong recommendation but we should remind people to think about now no that's that's a good point the way i've been thinking about it in terms of webrtc like this doesn't do all of turn because it doesn't tell you which public uh address imported assigned but that's something we could actually encode in the uh in the http response pretty easily if we wanted to and then the way i think about it it's a i think full code nat i never remember to which which kind of mad is which all right anyway at the end of the day it's an app where you're sending stuff to your mask proxy"
  },
  {
    "startTime": "01:48:00",
    "text": "and it's coming out with another address and then it's doing that mapping um so and you have just one not biting in this case um but it's such a way that multiple people can respond martin uh debbie downer again um yet another ambiguous thing in the charter like server initiated services are out of scope um that's not service yeah that's the that's the client asking for it uh that that is just as client initiated as connected clients so tony said not at the mic this is less uh less server initiative than connect id and i have to agree all right that that's a reasonable like to me it's more ambiguous than that but nonetheless like i think that's a valid interpretation if like this is better than connect ips like we can we can fix it but i think we'll have to consider that a little bit and see if anyone so that's fair and then uh as soon as i drain the queue we're gonna move on to the privacy so maybe tighten that text so that there's no ambiguity there okay cool um i'm sorry lucas who's wrong you hear me yes how are you feeling uh okay um i i think this extension is neat in the sense that you know it's it's a fairly small extension on top of something we already have that's already been running in production services for a while and enable something that is useful while we work on connect udp it's complementary um yeah there's some technical stuff we need to sort out but i i would support this doing this work if it doesn't quite fit the charter as written i think that's a great um thing to to think about for the charter considerations how do we how do we maintain and extend uh drafts we uh published or will imminently publish thanks awesome thanks lukas i fully i well"
  },
  {
    "startTime": "01:50:01",
    "text": "i'll state my opinions on the charter in in the charter section maryam yeah it could have been it does feel like a nice hack to me and then so but like i'm wondering why like if this is a hack then the right solution would be connect ip and like if you want port numbers then have an extension to get port numbers on connect ap like why doesn't connect ip give you what you want well because it's oodles of complexity that are not needed and trust me if this is a hack don't tell anyone but all of mask is a hack we're proxying everything over http and we got away with it what's the additional complexity i mean maybe you actually want this complexity to make sure that like addresses are agreed in a right way and you have error handling in only things you know but like like the it's just such not the right tool for the job like i don't have an ip stack in my browser yeah all right let's let's no i i know that uh we because about to see we already pulled sctp and dtls but you know let's let's not add more anyway magnus yeah yeah i think the biggest one of the questions here is and i i think we shouldn't take too hard on the historical precedence here but i mean there were reasons why turn was um endpoint dependent filtering you had to center set open up towards addresses you you knew through the signaling um i think that's probably fine to release but just understanding that you basically open up and um i think that's fine probably but it's it's it's a change when we've done before in this space so that's a good point and actually that's a policy thing that we could totally say in the spec uh it wouldn't change any of the encoding but that's a good point we should think about that and you have more expertise than i do unturned stuff so i agree all right that's uh that's it for me on"
  },
  {
    "startTime": "01:52:00",
    "text": "this one back to you eric thank you david all right we've come to the fun part of things so as david noted earlier both http datagrams and connect2udp are now in the rfc editor queue so a huge massive thanks to everybody here and remote for all of the discussion and really good engagement and reviews of those documents they underwent significant evolution from their inception to where they are now and that's awesome so thank you all for that you should be super proud of that connect ip is our last remaining item there and we're making some pretty good progress on that we've made good progress so far in our last two hours right here so we're gonna keep iterating on that trying to achieve interop close out as many of the issues as we can and once we've got some good interop and the issues are drained we're gonna try to move that along in the process which means it is now time to talk about rechartering so in what i hope is not a super controversial statement but let me know if it is mask is not intended to be a long-lived working group so i see a thumbs up from the audience so that means that there are places where we might extend functionality within quick or within http and there are long-lived working groups to handle long-term maintenance of some of those things and we're trying to talk about right now kind of what is the boundary where do we say we've done the initial set of things that we need for mask and anything for maintenance beyond this can be deferred to one of the kind of more broadly scoped groups so far we've been thinking that anything that's super specific to proxying and to make mask actually work in the real world makes sense to do here so we've had a lot of discussions so far in the initial kind of generic underpinnings of mask as we define them and in as part of those discussions we've had a"
  },
  {
    "startTime": "01:54:00",
    "text": "number of different people propose things that we say oh yes this can be done as an extension and we want to make sure that there is a time and a space to talk about those things and so that's kind of what we're proposing the next phase of rechartering for mask looks like as part of that if we're going to talk about doing some of these extensions that we've brought up previously we need to decide within our charter do we want to explicitly name extensions do we want to say we're going to do a timestamp extension as a random example do we want to instead offer some criteria for extensions and say we want to do extensions of this type do we want to be completely open-ended and say we think that there's a small list of extensions that people actually need and are planning to deploy and that that's going to kind of run itself down once we get to a place where most people are you know happy that we have a deployable thing and then we'll close things down so that's something that we'd really really like some feedback on uh the core underlying principle that i think we're proposing and that i'd love to discuss right now in addition to what kind of criteria we should lay out but the the core principle that i think we're currently going for is we want to include things in this charter that are needed to make mask actually work for real in the real world with real people so if there's a thing that you need that is okay i take the course back and i add this extension and that makes my use case that we discussed when we were first bringing up mask in our long list of different use cases that's something that we kind of want to make sure that we address if it's not making mask work it's not for real people or it's not in the real world the current proposal is that we keep that out of the next charter that has one big asterisk next to it which is around discovery and proxy discovery because people do kind of need to do some form of that sometimes that means there's a text field you type something into and so we can talk about that so i see we have two people in the queue we're going to open it up for hop in the queue now this is the happy moment to"
  },
  {
    "startTime": "01:56:00",
    "text": "express your opinions but the things we're most interested in focusing on are first what kind of criteria should we have for what we want to include what is in scope for our next set of work and out of scope um two are there specific things that we need in order to make mass work in the real world that we haven't thought about and three is there anything from this list that we're missing david you're first thanks and i would love to see our ad in the queue to get their thoughts uh on this at some point um or then again they can we'll get their thoughts when we try to change the charter anyway um but so my general take on this is when you start new work it's very important for the charter to be extremely tight so we don't go around doing crazy things and we agree on very small set of deliverables that we get done i would say quickly but you know i guess two years as quickly um so we had a great charter however now that we're done with those branching like deciding what we want to work on next to me should be a matter of who wants to do the work who wants to write documents we want to implement this who's going to use this and i don't think that we need like the help of the charter to scope us down that like if we tighten it too much it would get in our way so i would recommend to be very open in terms of extensions to connect udp or connect ip are all on the table things like uh discovery is on the table um the uh the other things you phrased as how do i make this work is on the table maybe if someone wants to write an ops document of how do you run a fleet of mask proxies that could be on the table and then our gate for whether we work on something or not"
  },
  {
    "startTime": "01:58:00",
    "text": "is the adoption call of course i would would like to see what the ad the isg has to say about that because at the end of the day they're the ones who decide but that would be my personal pro like preference tommy all right um so i mean i definitely think that opening up for extensions is important um i agree that we should not name specific extensions um i think the main reason for that is like we just saw the first presentation about an extension on udp listening and i think that's very important and like we just got that now that does like we will find something else and we don't want to preclude it it may be worth mentioning in the charter like other than just like open-ended extensions of all types like suggested areas and it's like some of the things that just came to mind are like one thing we want to make sure we have enough extensions to use the extensibility points we've created like context ids the udp list one uses that but like making sure we exercise the mechanisms we've defined is a good goal adding extensions to do like obvious functional proxying things like udp listen like this is a new functional capability of a proxy that was missing i think that's a very obvious category and then also things that make this proxy more efficient i think that includes compression or we have our stuff for forwarding but there's like things to make this stuff work faster or make sure you can do the zero rtt requests i think that's another category of good benefit um since it's open-ended and we don't want this to be a forever working group maybe one suggestion would be to have like a time box to re-evaluate to say like we will operate in this mode for two years or three isu can decide for how long and then we will reevaluate how those extensions are going and decide to say yes this is active or like no these have become this trailing edge and we need to stop"
  },
  {
    "startTime": "02:00:00",
    "text": "but give ourselves a box um with regards to discovery i'm okay leaving it out for now because i think that is a much broader discussion than we need for this group but i could be convinced otherwise if people are very passionate about that belonging here but i think it's good to have a place where we can talk about the protocol bits well spencer dawkins um gosh you all are good at generating questions before i get to the mic um i want to make sure i understood uh you correctly when you were saying you said two things back to back and you were talking about uh maintenance going to other working groups like like https or or wherever um with that is your intention that uh the mass specification the mass connect specifications would go to the appropriate working group wherever that is for maintenance and especially as you're starting starting to get deployment experience from outside the original implementer community yeah so two-part answer the first part is that the line for where we draw that line yeah something that we'd like feedback on right i think that's something we want to agree on as a working group so it may be that we say you know what we're we're going to keep things in mask until we've got significant you know outside the itf deployment experience so we can respond to things we say no that's okay you know connect and extended connect are ostensibly part of hcp and it's okay to have an umbrella group especially given our shared constituency here and there um but i think the the long-term answer is we're we spun up this group in part originally because we wanted to get a mix of audiences especially as we're talking about things like ip proxying and some more transport folks there"
  },
  {
    "startTime": "02:02:00",
    "text": "but the mechanisms themselves and some of that long-term maintenance we've been envisioning being able to route correctly for lack of a better term to the appropriate working groups in long term my my second comment was about um locating things uh i understand that that's a mass thing for mass but if i'm understanding the conversation correctly it was also a mock thing for mock this morning and um if i'm remembering correctly we've gone through a couple of rounds of chartering working groups where you know discovery was out you know was without a scope and uh i feel like somebody's gonna have to be able to discover something somehow um eventually you know at some point so uh [Music] whether that happens here or somewhere else or in the right place um you know that's yeah that would not be my call but i would encourage people to think about uh that more and you know and to support uh proposals for putting discovery in the right place thank you thank you all right keep it super quick ben and then magnus if you still want to talk let's go i don't think anybody knows what discovery means to the and i think that that's probably because it doesn't actually make sense in the context of mask you don't discover a mask server i think configuration is important unsurprisingly and should be in scope i think client authorization is as we've just been discussing is important and should be in scope uh i uh and uh okay i'll leave it there thank you sir magnus yeah um not that much i i do support that there are gonna be a contour of extensions that we need to support here and then just try to figure out this"
  },
  {
    "startTime": "02:04:01",
    "text": "uh during the next up to the next meeting i think give us some time there to think about what we actually want to do sounds good and it would be great to send notes to the list as to hey this is an extension we were thinking of uh 30 seconds i promise i'm inclined to recharter i do not have strong convictions about the technical content of that recharger um except they were not as people said we're not chartering mask m and um i i think uh the the key thing here is figuring out like i think there will be extension poles forever and i think we have to figure out what is the the off-ramp to hand those extension proposals to the other steward working groups here and i'd be interested i mean i think the time box is is like a course way of doing that um but i think we need to figure out maybe something more substantive there on what our exit criteria are thank you thank you very much and thank you all have a great rest of your evening in plenary [Laughter] relay ops"
  }
]
