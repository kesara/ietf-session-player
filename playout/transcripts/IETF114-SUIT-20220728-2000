[
  {
    "startTime": "00:00:04",
    "text": "this meeting usually rule of thumb is working group documents beat documents that are not working group documents and so uh we let the working of documents expand time and don't call time because we usually have a bunch of individual documents now that most of our documents are working group documents we can't follow that right now well well we can but it won't help exactly all right there's four o'clock so we should start okay let's go ahead and get going welcome to suit at ietf 114. by thursday you probably know the note well already but this is the rights privileges and responsibilities as participants please follow the code of conduct and treat each other with respect in addition you need to wear a mask in this room unless you're on the pink axe by the presenters mike and uh we just did the administrative tasks so i'm going to skip that so the agenda we have a long agenda today for um it seemed like two weeks ago we were not gonna have any presentations and now we have nine um so this is the uh first page of the draft agenda and here's the second page any bashes to that agenda it's the same one that's posted okay with no bashes we'll get into the first one it's the hackathon reporter okay yeah all right sue taco thumb report is this thing on otherwise hand me the white can you hear anything no switch the switch is on all right one two three now it's on all right"
  },
  {
    "startTime": "00:02:01",
    "text": "great all right hackathon report uh we had a combined cose suit t hackathon table with a bunch of participants listed there i'm going to go through that go through this uh pretty quickly until we get to the two issues to report on go ahead next slide there was a bunch of issues that were filed during the hackathon the whole set on the top i am not going to talk about because they're trivial grammar stuff and are pressed for time so only mention the bottom two uh the bottom two have a slide on each of them so that means only real two slides of content so first one so if you have issues go and read through those all right first question that we had at the at the tpackathon was um it came up as far as teep trying to implement the suit manifest okay so the eat profile previously used uh software name and software version claims but we observed that those were meant for human readable strings okay they were not necessarily machine readable so for example there was nothing to prevent somebody from patching a binary and then just not updating the human readable string right so it wasn't you know cryptographically you know bound to anything so that's the wrong thing and so lauren said you probably want to use the manifest claim so that's what we did in in t okay the only issue with that is that currently the manifests claim requires a full suit manifest right so manifest format allows you to have a suit envelope and we said we would like to be able to do that without having the entire suit manifest and is there a way to do that that was the question raised and we filed this issue for that for that it says okay for the manifest format we've got a content type as long as you have something to fill into a content type that means it's a reference you could do it even without a suit envelope right you could use something other than the suit envelope so example during the hackathon here was a proposal that was submitted as a per request to say okay alternate version the manifest body is not a suit envelope it's a suit reference which has like a uri and a manifest sequence number and brennan was online we went back and forth and said this kind of thing might make sense okay and so right now the proposal is to maybe add this to the update management which is on the agenda later and of course this would require a co-op"
  },
  {
    "startTime": "00:04:00",
    "text": "content format value to mean that's the format second issue that came up and so by the way if we want to defer discussion on that to the update update management document we could do that but that was one thing we followed one issue that we ran into when implementing and so we filed the issue and say we should really discuss a part of that document second issue that we ran into was uh having a suit parameter for the manifest sequence number so the t query response has now and this is now in draft 10 has system property claims although in teep there was a question about whether this is right but this is what draft 10 says and so in the suit report and now in the deep query response you can have this little blob of suit system property claims which has a suit component identifier and one or more suit parameters and this parameter is defined in in one of the documents that covers things like image digest size and so on but there's nothing that has the manifest sequence number to put in there right so the manifest document allows you to have suit manifest suit parameters the i think it's the update management one that augments that with additional suit mana suit parameters and this is just saying hey let's add yet another suit uh parameter that's possible here and put that into the extensions document just like we've put you know image digest and so on into there and so that's the proposal here option number one is to make that be type specific option number two is to make it be not be specific so that other protocols if they have the same problem could reuse option two so my personal preference is option two which means that would go into like the update management document but the point is the hackathon report is we ran into this we need some solution to it uh hey teep you should weigh in or sorry suit you should weigh in so the deep implementers know how to implement the suit manifest that is the set of technical issues that we ran into at the at the hackathon otherwise all was good okay"
  },
  {
    "startTime": "00:06:01",
    "text": "go ahead brendan so the suit report has an explicit solution for this um it does have an unambiguous manifest reference in it the problem that you're encountering comes purely from taking the system property claims out of the suit report so i'm not sure that this is the issue you think it is i would argue in fact that the answer is to use a suit report yep so this isn't the word this isn't the discussion on the draft um so i won't respond i'll just say uh my report is at the hackathon the issue was raised and we need to come up with something and in your presentation brendan um and in the teep working group we discussed this briefly where you made the same comment and so you might be right the point is just i'm reporting that we had this discussion and you can report on the answer thank you thomas if you go back one slide um on the on the previous issue um yeah it's how do you give me an example on how this would then actually look like in in in deep in teep or eat did you say in it would obviously be the eat in the in the deep message but uh yeah yeah yeah so this is okay so um you have a tee the te boots up and i'll use an arm-based example right for my arm colleagues here let's say you have um tf-a version xyz okay and so you boot up and you send off an eat that goes off and the eat has multiple layers maybe one for the one for the trust zone hardware right one for the chip right one for one little piece of information about tf-a piece of"
  },
  {
    "startTime": "00:08:01",
    "text": "information about opti and a piece of information about the the teep agent ta okay so that's what comes into your eat and that that however you encode that into each right in that okay you need to specify because now you have a piece of hardware and you have three components right in that chain right you have tf2sa you have opti and you have the the type agent and so each of those could have a suit manifest and so as part of your token you want to say here was the you know image digest or the manifest version number or whatever okay for each one of those layers and then i will send that off to the verifier and then i can say oh yeah all those things match you're good okay so how do you encode that and that's what this is talking about because you want to put the entire manifest into there you want a reference to it that's what this issue is is what's the easiest most efficient way to do that and so here in this example it's using the suit manifest number not the digest why because you can look up one from the other and so the policy on the verifier side to say is it good or not you would be allowed to have a policy that says suit manifest sequence number greater than or equal to five rather than saying digest is one of the following three things right the version five manifest the version six manifest the version seven manifest it's a little bit easier to deal with on the human authoring side and look up side but you can get one from the other and so that's why suit manifest number is slightly better than a suit digest right here okay thanks a lot that's really hard empty okay brendan would you come present uh on suit manifest 18. all right oh it's dark in here"
  },
  {
    "startTime": "00:10:04",
    "text": "okay uh next slide please i was thinking right you want it oh uh yeah i could do that yep got it uh so largely this is editorial changes um there there hasn't really been uh much in terms of uh churn in the spec um really what we've done is just made a few of these editorial changes that i've got listed here since as you point out we are short for time i won't go through them um they are all in the github so that's relatively easy to track now there is one structural change and the structural change here is that i've added a reference to an algorithm profile document and uh unfortunately it's the if time permits document i'm i'm hoping that we can get past the uh the if time permits and get to talk to it talk about it because i think it's probably the most important thing we'll discuss today um there are there's also one technical change now this technical change was not taken lightly i really tried not to change the ordering of the keys in the suit manifest however one of our implementers was very vocal about making sure that the ordering in the cddl was precisely matched to the ordering of the canonical seaborn encoding and i do appreciate that concern um so what i did was to look back at exactly what requirements we had and why we would choose to order things in a particular way and so the rationale for ordering here is that recipient necessary parameters should become before the ones"
  },
  {
    "startTime": "00:12:00",
    "text": "that are not necessary to the recipient and unseverable members should come before ones that are severable so uh noting that i'm not aware of any unseverable recipient unnecessary metadata with the possible exception of the canonical uri uh which i have moved to the front the first element um i would say that that third one doesn't actually exist and the result of that is that we have unseverable before severable and recipient necessary before recipient unnecessary and that required reordering a few of the keys so since some of the keys were being reordered i uh attempted to space out the remaining ones to allow us to hopefully grow in whichever direction is needed um so that's for the reason for the key changes um it is a breaking change but it was really not undertaken lightly and um my my big concern is that there wasn't much input on the list except from a single implementer so um i really would appreciate feedback from other implementers on this topic but i think that if we're willing to accept the breaking ordering change it is probably a better result in the end so brandon my interpretation was people just want it done yeah probably fair enough um so those are the actual key changes um i i it's yeah numbers um let's move on so we have some open issues um and we've already heard about one of them how do you reference a manifest in eat um we've got a few ayana feedback elements and to do's from the early review so those are all relatively straightforward none of them are breaking none of them are cause for"
  },
  {
    "startTime": "00:14:00",
    "text": "concern they're just editorial we'll get those sorted out um there are a few cddl nits but i hope that that's all sorted out with uh in short order here and um there was an error in some of the text example this is all stuff that i think uh dave already referenced in his hackathon report um but the real question there is of course is how do we reference a manifest in eat and um that's not strictly a manifest question so maybe we can just ignore that at the moment and and that's it that's what i've got for the manifest so i i guess the question i have is are there any other sort of uh working group last call type review elements that we need in here now dave failure and i agree that both of the ones that i mentioned at the end of the hackathon report can be done outside of the suit manifest document itself as long as the cdl is fixed up to have sockets right meaning the dollar signs are there that's part of the medial fixes then everything else can be done in a different document like update management for example so i think the suit manifest we can be done within short order because everything is just trivial you know cdd offices excellent uh well that's it so unless there's any questions we can move on what's the timeline for posting the fixes to the cdl when would we get a new uh update i said shoot manifesto uh early next week i should hope okay thank you minute taker is taking that down the okay uh multiple trust domains this is only two slides so i'm going to let you advance this one russ okay we have a few open issues um yeah there's a key conflict because i reordered the numbers in the suit manifest um it hasn't had its update yet so that's all that's going on there um"
  },
  {
    "startTime": "00:16:01",
    "text": "after the discussion in the teap uh working group earlier today i think that it is now clear to me that we do need an uninstall command sequence i don't think there's any getting away from that i think that's what it has to be now because of what that is it has to be added to the unseverable manifest members that's all that can be done that's where it lives um so that's going to need to be an update but again this is an update to the trust domain document i think that's it i don't believe any other commands are necessary i think unlink on its own is good enough um the only thing that i'm concerned about here is whether uh two generations of the same manifest that both attempt to unlink a component would cause the reference count to be decremented twice and i don't know exactly what text we should propose to prevent that situation um so that's i don't know if there are any other open questions on this uh but that is the current status of the draft nope i think that's a good summary okay oh we're just flying through here okay again two slides next slide please um yeah there's very little to say about this one um it's definitely not a complete list of update management actions i'm fairly confident of that i think this is something where we can expect the registration list to grow and that that is sort of uh the reason we have an iana registry because it won't be complete um and beyond that i'm not sure um i have a question here about whether you should be able to use a manifest sequence number in a version"
  },
  {
    "startTime": "00:18:01",
    "text": "comparison within a manifest that was probably because i misinterpreted the question that dave was asking me before and uh thought that he wanted a parameter in the the suit parameters specifically to be able to use it in manifest sequences well that appears not in fact to be the case so um maybe we can just strike that one so i don't think there are any open issues as a result yeah this is dave's favorite i think the two issues that i covered at the end of the hackathon report if there's any changes to be made this is i oh sorry one of them was the trust domains document right another one wasn't here so if we agreed to do something there then this is the document that it would be done and so i would put on a list of open issues there even if brennan might be an open issue so okay fair enough just until we confirm that we have consensus that your answer should be sufficient for cases because i i think we suggested that if there was a change this is the document that would be in the context of so one touchdown okay fair enough yep that makes sense last call for questions on this one from the room online i'll talk anyway regardless go ahead and go go on yes that's it so the main issue with the firmware encryption draft was the this instance of the practical thing from mcu boot where the flash image needs to be updated in pieces and it kind of precludes the use of aad and so um there's more explanation in here about effectively we have to be able to to recover from a power loss during the middle of an upgrade and it requires us"
  },
  {
    "startTime": "00:20:00",
    "text": "to be able to do the encryption and decryption in pieces go ahead and go to the next slide um and go ahead you can go ahead and go on oh um so that this is just a summary of the the the issues behind that basically we use a aes counter mode you can also use cbc for this this is written into the i believe it's nine of the draft this always requires something else to verify the integrity of the image and what we do so it's written that something such as a signature verification has to happen of the image so there was discussion during the coz of work the coza meeting to allow unauthenticated encryption um i guess depending on how that actually ends up getting worded will determine what we're allowed here currently it's worded in our draft that these are only to be used for suit for this and that should be it during the discussion with jose it's clear that the we don't need the integrity provided by the aead because there's a signature so allowing the blocks to be handled independently is okay as long as you validate the signature um so this external to the encryption integrity mechanism makes the system okay but the way the uh instructions are written in cosa it says the algorithm identifier is the algorithm identifier of an aead so we gotta say write a document says why it's okay in this particular context get the code points registered for aes counter aes cbc"
  },
  {
    "startTime": "00:22:01",
    "text": "and then if cosi adopts it we're done we have an answer if they reject it then we have a different problem make sense as far as we know that's the only open issue with firmware encryption well there's no slides that's the end of the slides did you submit two um so there was i added um it doesn't matter so uh i i added the pointer to the github repo of the document and where i um yeah i clicked the wrong one and um so that the newer slide only contains pointers to the github repository on three issues that were uh brought up by marco i think marco is here yep [Music] actually two by marco and one um and one other i think he was again ken ken proposed uh not this one other issue in the during the hackathon so to do um just to to shortly summarize um marco suggested to look into the counter signatures for the wrapper that we provide uh outside the encryption so we first do the encryption then we apply that the signature and there if we use the counter signature mechanism which is currently being finalized in the course working group we could shave off a few bytes so that's something we should be looking into because it's just the signature just goes into another header uh parameter rather than having um an entire cosi"
  },
  {
    "startTime": "00:24:01",
    "text": "sine one wrapper around it which i think has has a lot of benefits um the other one was about the wording refinement of the wording that we have in there on the use of the keck verification which was the mitigation to deal and thank you which was the mitigation to deal with potential battery exhaustion and so um since we use um the keck with oil with a nons with oil zeroes we should not for this for this verification step we should not then use a kick for uh encrypting anything afterwards with the same value because we would be reusing it i think we need to be explicit maybe obvious too many uh but uh i think we should be crystal clear there and on the on the hackathon it's safe yeah um and ken maybe you can explain your last item um i know you you created the br and so on maybe you can briefly summarize on the issue that you filed for the encryption document sorry to put you on the spot here like i think the suit encryption info was uh in the former suit manifest original code document that brendan uh moved i think brendan removed uh from the core document of sued manifest and now it's a in the pharma encryption uh document and uh i pointed that uh it uh i think i i i think uh it should be a reasonable position uh in this suit directive set parameter i think"
  },
  {
    "startTime": "00:26:00",
    "text": "so that's all yeah so um and what is also missing and i think we are getting close like the these issues um should be resolved fairly quickly the first one and uh definitely the second one with a little bit of uh um re-reading and and looking into the counter signatures uh and also what ken just said um probably what we'll be holding up is the former issue that we just talked about which is uh kind of unfortunate but it is what it is um and also there's the since we're using two uh key exchange mechanism in here the eas key wrap and also hbke we have this dependency with the hbke document in the courtesy working group and while it's advancing it there's a continuous update or synchronization needed between those two documents with regarding to the example and the complete example is currently not in a document it which is also something that's needed so it kind of gets delayed because of the completion of the other work and the dependency so that's uh yeah but i think that reconfirms that it was some right decision to move that out of the in the main specification to advance the main manifest document faster than this extension right brandon uh yeah i just had a question about the uh plan to register aes ctr and whether the intent was to register that as a deprecated algorithm from the get-go yeah that's what the cose working group chair recommended and the point is we need a code point"
  },
  {
    "startTime": "00:28:00",
    "text": "and yeah we'll we'll just have to uh read the politics yeah it's it's i i totally appreciate that i'm and and i also see where they're coming from on that end that you really want to avoid having a lot of people using this for non-firmware update use cases um i do wonder though if cozy is in general missing a streaming decryption capability and that's something that they need to address uh well we think so otherwise we wouldn't be willing to write that other document to get those good points but they the thing with streaming is you do want integrity on the chunks of the stream and not clear how that would work just yet and not one we're gonna solve for them good thank you super poor super reports is next so back to brandon all right i've got three slides for this one all right so there there's really not a huge change to the document this time around um essentially what i've done is i've added a big text section that explains why and how you might choose to use a suit report as attestation evidence now this has been something that i've talked about with uh with hank a fair bit actually and uh essentially the idea behind this is that a verifier may well be equipped to evaluate a suit report and i'm not talking about the proper the system property claims i'm talking about"
  },
  {
    "startTime": "00:30:00",
    "text": "the full set of suit records and that would allow it to reconstruct the state of the device which gives it all the information it needs for attestation evidence and so the idea here is that a properly constructed verifier has the ability to take a suit report and turn it into whatever other evidence it needs it can then to construct a more standard suit or attestation result out of that document and so this is the essentially the idea and there's a few justifications for why you might want to do this uh one of them is that then your device can have just an append only log of what the manifest processor did and that becomes enough for your attestation evidence i think that's a really powerful thing for a very constrained node um so so that's that's sort of the summary i've put a block of text in which explains all of that um that's the big change and in terms of open issues there is uh one issue as far as i'm concerned and that is that we have two different logs we've got one for debug type things and one for evidence the the one for evidence is the system property claims that dave wants to use and here i'm about to suggest that we get rid of it the idea being that [Laughter] that this merged log that you get at the end is better for embedded devices because they only have to append elements to a single buffer and so that makes it really easy for them um now as i say here this is a simple change but it desperately needs feedback especially if teeps about to start using the part i want to delete um then we definitely need to talk about exactly how this all fits together"
  },
  {
    "startTime": "00:32:00",
    "text": "so i'm going to put myself in queue here um there's that i don't yet have an opinion on that one you can think about it more um but uh the other issue that came up that was reported in the team working group was a question um and the context is the question that was raised there is um what's the right recommendation for how to encrypt suit reports if there happened to be any sense of information in it and so i just observed that the entire security consideration section of this reports document right now is uh two sentences and perhaps it should say more than that um the only reference is it should either be carried over a secure transport or assigned or both but doesn't say what secure transport doesn't have any considerations about you know encryption or whatever so at least that's an editorial um uh issue to be uh addressed if not an actual technical issue if it really is to say you must use if you care about encryption then or you know sensitive information and suit report then either put it in a secure transport or leave it out of the report right then at least that would be something if we want to have a mechanism to do encryption at the superport layer in the future so you get that vetting extension whatever my point is the security consideration the section should actually say something yeah no no that that's fair um that that element of the draft is definitely lacking so let's let's um let's see if we can get that fixed for the next one sounds good thanks i'd be tempted to ask you put a threat model in there karma brendan well i mean to say who's it's just coming back to me you know [Laughter] for those who don't know we're laughing about brendan was active in previous uh meetings this week about asking people to have threat models and so hey what's a security document with no"
  },
  {
    "startTime": "00:34:00",
    "text": "threat model speaking of which here's a security document here's a security document it has no threat model if you want the threat model you'll have to show up to the iot ops meeting at least ensue we did do a good job of having a full threat model in the information model document and so the manifest has a full correct model but now that we're talking about suit reports [Laughter] okay on to mud i think yeah so this this is really just an update and this is a very simple extension to suit the idea is that you have a mechanism to carry either a mud file or both mud uris and mud signer public keys the idea behind this is that it replaces the conventional approach to deliver mud information from a mud capable device to a what's the word a mud a mud manager i think it's a mud manager um and it replaces that with the update pipeline so the idea here is that your network infrastructure is supposed to receive a copy of the manifest before it gets pushed out to your device that means that before the device ever connects to the network the network infrastructure already knows what its new mud file is going to be because it's either fetched it remotely or decoded it out of the manifest obviously this is a severable element because the device itself does not need this information um it has a lot of benefits it's uh similar to device certificate binding but has the advantage that individual device certificates do not need anything about this information instead all of that is delivered to the network infrastructure in a much more compact form what this does give you is the requirement that you either do some kind of device fingerprinting or at a"
  },
  {
    "startTime": "00:36:01",
    "text": "station in the network now of course my uh personal preference on this is for attestation uh if you attest your manifest then your network infrastructure should be able to determine uh which mud file applies to your device and which software and that gives you a really good combination of knowing exactly the pairs of software and mud files that are active for any given device um it's going to be referenced by the iot nets document that's going tomorrow in the iot ops working group i'm i'm not aware of any open issues on this um it's a literally a two point a three point extension to the manifest it does does very little it says very little and i don't know what else we need in it maybe a review by elliot there you go um i'd like to see the suite of traditional long worked on so we'll just i think we should probably just park this one until we clear the queue out a little bit i'm not expecting a lot of updates to it because it's just it's so trivial that pressure in our queue to make sure that the metronome and the last one is mti all right this is this is the controversial one um you'll you'll notice that i've got two titles here uh there's there's zero because i filed the wrong one um and before the draft deadline sorry about that then there's zero one it's got a much better structure if you're going to read them please read the second one"
  },
  {
    "startTime": "00:38:00",
    "text": "um so there we go so the idea behind this is that we want to ensure interoperability between devices and the systems that manage them and we want to do this with as little uh as little m cross n problem as we can get um but this is an asymmetric problem uh devices can only be expected to implement a single crypto suite you might get lucky and have to uh that being the case the burden really falls on authors and management systems to handle multiple crypto suites so that they can support the devices they manage um having mandatory to implement algorithms may be problematic for some recipients so this is going to be a challenge for us and i think that it's real oh i should mention we don't do constrained to constrained right you don't in suit that you don't have a situation where you have two constrained nodes that are talking to each other you always have a relatively capable system talking to a constrained system so this is a different problem than most of the interrupt problems that we run into recipients if they don't have the the the crypto system they want available will simply not comply with the mtis i think it's pretty clear that uh and and i've had feedback from some implementers that say essentially if you make an algorithm i don't want mandatory to implement i might still use your standard but i won't comply with the mti um so i think that there's a danger there that if we push too hard on mtis"
  },
  {
    "startTime": "00:40:00",
    "text": "we're going to end up with just non-compliant devices uh i suppose that's a good reason for separating this out of the manifest draft in itself at least then they can comply with that draft but not with this one so then the question is if we're going to do mandatory to implement suites what should we do well if we do symmetric it's relatively straightforward we mostly know what to do with that but it the key and tag distribution is a real pain it's not a nice way of doing things we really don't want to advertise this as the way to solve the problem um for asymmetric the classical implement implementations at least the signature is small um a hash based is quite large and has a stateful private key which is not a thing to recommend it and it may be difficult to justify in some applications particularly if you're demanding an hsm because i'm not aware of any that support it yet um there are other options that are coming but they're not standardized yet the winners are announced but the standards haven't arrived so no matter what we do this is obviously a moving target uh so for key distribution which is the other side and this will play it more into the um the firmware encryption side of the the work and there are symmetric solutions and most of them will involve you know using a single shared secret and then deriving from it and there's classical asymmetric and this is well known might become broken um we have pqc asymmetric coming but there are no standardized pqc h or symmetric algorithms as of yet uh there are winners announced so obviously that side of things we probably can't do in an mti draft today again this is a moving target"
  },
  {
    "startTime": "00:42:01",
    "text": "so what should we do um i have a proposal and this is very much a straw man i very much think this is going to need changes and that i i would very much welcome input on this the proposal is that for symmetric we well i mean that one's obvious we don't need to go into it too much um i note here just quickly that i've got aead written for each of the encryption algorithms that's because those are the only currently standardized options um i'm betting that that part is the going to be the first one to change and end up as aesctr or something equivalent instead um so then the next stage of this is uh authentication well for symmetric yeah again we know what to do with that so for classical asymmetric i've proposed es256 um for key exchange hpke which i realized is you know both key exchange and encryption but never mind um and for for pqc what i'm proposing is a hybrid mode where the authentication is uh is hss lms but the key exchange is classical hpke i don't think we really have a better option than that today so brandon this is russ um i think in light of what we've been learning in jose um hpke uh led to some confusion what honest uh what our document is is a way to get with cozy structures the same properties that they can take okay but it is not exactly in the sense that um if you took an hbke library you'd have to pull it all apart though the ins and outs all apart right and so it's pretty close to es256 in the"
  },
  {
    "startTime": "00:44:01",
    "text": "end you just sorry uh jose hpke or something like that right um i think that's what that's really my only uh suggestion for clarity because i know at least one person didn't get it fair enough yeah so i mean that's that's a good update for the draft to mention that um so there's a lot of other favorite algorithms some of them are definitely favorites in the iot space um and my answer to that is there are going to be an implementers who demand fips algorithms we should not deny them an mti fips algorithm that would be a mistake um so i've listed three and they're all fips the question is um do we need something else that isn't fips that allows you know pick your favorite um algorithm uh i'm have very mixed feelings about this as i suspect you know many people do uh the list will end up being very long if we keep going down this road and so then this question is um the the reasoning for the ones i've picked is that people are going to demand fips um and that that's not an unreasonable demand if we want to pick another one i could see an argument for that but i think that beyond that it's going to start to snowball too much dave filler as with the t protocol um document editor hat on um one of the use cases of suit is of course antique and when doing both them in constrained nodes it sure would be nice if you had common requirements on what the algorithms are"
  },
  {
    "startTime": "00:46:00",
    "text": "for the same purpose the type document says something right now which could also be changed and so my point is the mti is here and the mti is in suit i would like them to be consistent but i don't have a strong opinion what they are but the cheap protocol document says right now and similar constraints as brendan said to everybody else right you have one side that is not constrained and the side that is constrained that happens to match exactly the uh constraints that the case is in suit right the constrained side is still the constrained side in both cases what it says right now in the document is that the constrained node which is the consumer of information can pick either es 256 or eddsa and the unconstrained side must do both okay that's what it says right now what it should say is an interesting question my point is we should keep alignment there but i bring this up because you say what about ed dsa and t would say well if you're going to do eddsa and then you probably want the same thing in suit not two different things right so you can only do one library in your tiny constrained device right so that was nice yes so dave this is dave waltermeier um if if the goal is to keep them in alignment how do we ensure long-term alignment between the two efforts uh are we talking about maybe having a common registry or something like that that could be shared between the efforts uh dave they are there are common registries because they're all coset algorithms but we don't have a required for use in teeth required for use in suits right well i guess what i was thinking is maybe a registry could define those requirements i i was thinking that maybe what teep needs to do is depend on this document yeah it does now funny you should mention that i just posted draft 10 so the cheap meeting was earlier today and we walked through all the issues and t as well as a couple of open issues right but all the issues that i said here in github um are now posted in draft 10 which came"
  },
  {
    "startTime": "00:48:00",
    "text": "out this afternoon right it matches exactly the github copy as of um this morning and the end of the hackathon and that one does take a dependency on the firmware encryption document you'll see that in the uh right now it's an informative reference um just due to how it's worded right it could become normative i think right now it's informative uh but to dave walter meyer's question i want to give an analogy to what we do for eat um in the eat in the rats working group the eat document says you can define a profile and it's going to use the word profile i'm not saying how to use your profile or whatever it says in use case what's mandatory to implement is not in the body of the document it's in the specific use case right so what you could say is that it's teeps job to specify what the mandatory to implement cases when using suit in a teep case now the disadvantage of that is that we would love suit to say i have a suit manifest signer and processor that can be used for both teep and other cases that's the reason to not do that and so i just want to throw out both the pros and the cons of that project so the approach of leaving it to profile is similar to what was done on the t-test with certificate we knew certificates were going to be used in all kinds of different applications i suspect pls s mine so on and so we said picking a mandatory to implement for pkx may not be a good choice for those so we left it to tls and ipsec and s mine predicted mandatory implement and that kind of feels like we're in a similar situation thank you again so i i like one of the things that brendan uh said earlier which does align with how teep does it which is if you say that the non-constrained side has to implement both of them in order to let the constrained side pick one you can do the same thing for how you do profiles right the non-constrained side"
  },
  {
    "startTime": "00:50:01",
    "text": "can implement multiple profiles and it must do all of them right and the constrained node supports often just a single profile that's using it for a single use case right and so as long as you principal around the mtis is to say each use case defines its mtis and your principle is that say the suit manifest generator if it's going to have a tool or a repository for doing both of those it supports a set of huge cases and it supports all the mtis for all the use cases it wants to be used for but uh so so ross here you're implying that shouldn't define any mti and that these other use cases should um yes i think that is the way out of the spot but i think i'm going to disagree i was just about to go there brendan i'd say the suit should just find the constrained node firmware update use case and then right rest up because represents its own use case that that was brendan's point is he's saying but the suit is a profile no great answer uh i i think one other things that uh i think you mentioned on the previous slide which is this is a moving target okay so i think that's exactly a good reason why we split out the mti discussion out of the main document so that um as the set of mtis change which you know 10 years from now the set of mpis is probably going to be different from what they are right now because your point of view is about the you know hopefully by then we'll have pqc standards right so you can actually reference that have different apis right and so that means that the ideal case is we don't need to obsolete or even update the suit manifest document right we would obsolete the document with the current mpis not update but actually obsolete it with a new set of mpi so that's the good reason to separate things so i i'm going to say this i have almost definitely made wrong choices in this"
  },
  {
    "startTime": "00:52:01",
    "text": "document this was explicitly intended to be a straw man please go bash it um it uh it's it's almost certainly wrong but it was the the best shot at the minimum set i could think of that would suit the use cases i can see today um i as i'm well aware that riot disagrees with me and their default signature algorithm is eddsa and as a result i wonder if we're going to wind up with four um options in the very in very short order as soon as they start editing this document with me um but uh that that was as far as i got today and the reasoning again was because of fips lawrence yeah i don't know if you've looked at the latest eat draft but it has the definition of a profile in it but it's not mandatory to implement so there's a definition there but it's not mandatory and i was i don't know what you think of that as a solution oh yeah sorry it's kind of short here um so the the latest eat has a definition of a profile which includes the crypto algorithms for eat um but it is not mandatory to implement so it's just a definition of a profile that you can so you can reference if you want to and say for you know for this kind of device use we're using this profile so they're not mandatory to implement they're just uh you know a palette of of profiles or this is the start of a ballot uh okay um i think we really need to take this topic to the list um that input from riot earlier than later would be very helpful"
  },
  {
    "startTime": "00:54:01",
    "text": "yeah i guess my question is whether the working group wants to adopt this work okay let's ask the question does anyone have a problem adopting it in its current state knowing that we're going to continue to work on it okay we'll take that to the list too dave waltermark since you're not traveling could you do the call for a thought i just want to report out in case the camera is not there there was nobody in the room that uh said that they had any issues or no hands raised so and there were no hands raised by anybody virtually yeah i'll park that thank you dave uh given that we have uh just five minutes left um we can either go back and talk about the hackathon things that they've skipped because we didn't think we'd get done or we could then i would find it useful if brandon is still around to spend you know two minutes back on the two hackathon issues to see if we can find a way forward uh given that the actual wasteboard was not to point the package on reports one pack of dog report would say we raise an issue all right so if you just go to the last two slides there the first one um so uh let's see if you can get any if we can get any direction here right so this one that the green part here is what the each spec says okay which um anything that has its own uh uh content type your own co-op content format value that you can plug into here and so the proposal in the hackathon was to say we create another co-op content format value which can specify i have a way of referencing a particular suit manifest and verse number and if that's a good idea then which draft would that go in that's the"
  },
  {
    "startTime": "00:56:00",
    "text": "question so i i think i've mentioned previously that um my preference for in these situations is to use the uh the digest of the manifest um i understand that you like uh the ability to do broad version comparisons simply so i i take that point um that other than that i yeah i mean this is fine i would i guess my my question would be how would you feel about making the sequence number um either or with the digest i personally would not have any objections the question is who gets to decide to either or and because as long as say an an author of a verifier can say we really like doing manifest sequence numbers or whatever it says it gives who gets to decide the order right it's really the real question yeah so so who gets to decide is always the constrained node right it's always the same as the mentor of the each which in this case is the the the device the deep agent there so i she's speaking as an individual i would not have any problem with that um i in a constrained node fewer options is better and so that was the disadvantage of say if you say or as long as the implementer gets to pick and only implement one of those two in the constrained node then that resolves that concern exactly if if we go forward with this and the question is which draft does it belong in and my personal preference would be the suit update management draft but i'm not interested i would have said suit report i would be fine with that too but my question is this is the super group which document do we think is the right one is it a suit document and if it's a suit document which one you see what i would do with this is i would embed it into the suit report because the state report already has those two elements of information in it"
  },
  {
    "startTime": "00:58:01",
    "text": "and so what it would do is simply aggregate the two of them together and call them a suit reference okay um i have a question independent of uh this one more sort of logistical question or process question when um brendan said he's going to update the manifest with the content he already had in which he talked about it um that's fantastic uh then the next step is with that triggered in the working group last call of that document or how would we proceed specifically now we have the summer months uh august some people are away and so on so how do we make sure that we um sort of like get those document out there so we can actually use them also in last call okay right you missed that and that the comments is what led to the breakup right and that's true yeah i would think that coming out of the next version they that all of your comments have been resolved and no new problems were interviewed okay very short you know okay that's my my view of it okay that's good to hear i think that's right i think that the principle we're trying to follow is if you raise a new comment uh on something that hasn't been addressed then uh we would look to see is that piece severable out of the main document into an extension so that we can keep doing that to let the rest go forward and we hope that the answer is always uh there exists no unseparable pieces sorry to reuse brendan's several coins term out of time so i don't know if we have time to cover the last slide so here no objection to putting into a suit report as you propose as you discussed there excellent and we'll take the second one to the list thank you all i'm surprised we got through this much today appreciate your"
  },
  {
    "startTime": "01:00:01",
    "text": "attentiveness thanks everyone sometimes the uh"
  }
]
