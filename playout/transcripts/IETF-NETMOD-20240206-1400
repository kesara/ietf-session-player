[
  {
    "startTime": "00:00:54",
    "text": "okay let's get started good morning good afternoon good evening everyone whever we might be on the interwebs uh thank you for joining um hopefully more will join as we proceed ah this is an official ITF uh meeting and all such meetings are subjected to uh ITF rules uh there's this document the not well document um has lots of information regarding uh the effects of your participation in the ITF process notably that uh any you say uh is considered a contribution to the ITF during the meeting thank you uh the isg has asked all chairs to remind their working groups of the need to for appropriate behavior this is described in more detail in BCP 54 in summary ITF participants extend respect and courtesy to their colleagues at all times ITF participants have impersonal"
  },
  {
    "startTime": "00:02:01",
    "text": "discussions ITF participants devis solutions for the global internet that meet the needs of diverse Technical and operational environments and individuals are prepared to contribute to the ongoing work of the group some meeting tips uh for remote participants uh please make sure that your audio and video are off unless you are uh chairing or presenting during a session use of a headset is strongly recommended using me Echo Q uh we are using the me EO Q controls so please raise your hand um to get into the queue and uh waiting to be called on uh typically um the presenter should moderate the queue but uh sometimes uh I'll step in and if no one's stepping in uh and you feel that there's a lull uh please just go ahead um and also be sure to uh in it when you're you know at when it's your turn to the Que turn on your microphone um actually some people actually forget to turn on their microphone so do turn on your microphone uh and then when you're done turn off your microphone um even if you're still in the queue like you're standing at the mic but you can like just step away for a moment turn off your microphone um but when you're actually ready to leave the queue uh do leave the queue by pressing the hand symbol again um so you're fully removed and it's not unclear to the chairs uh whether or not you're still standing in line uh as you know we're using me me EO um as well as chat um the chat window I noticed um carsten is on zulip I'm not sure if he's able to interact with the chat window here in the me EO client but and Michael Richardson as well um but uh if not then if someone could um monitor the zulip and capture any notes that they make there uh we are having a notes uh in"
  },
  {
    "startTime": "00:04:00",
    "text": "hedg do in the top of the top middle bar of the screen there's a what looks like U uh a pencil for opening up the notetaking tool and please um click that and log in to data tracker and participate in the note taking process uh we do have also um there's you know the links to these slides as well um as the well all the slides for the meeting are happen posted um and you can track them there for your interest the agenda for today's topic is uh short and sweet it's just a single topic that we're focusing on today much like the last interim uh today's topic is Yang metadata annotation for the immutable flag and the presenter is chiffon Ma and I believe that is my last slide so I will bring up chiffon slides and we'll get going can I control the slides uh yes just give me a second to do that you should have it now ah yes yes yes I can thank you okay so hello everyone uh my name is Tua and this uh presentation is about the uh immutable flag and this is not going to be a long presentation and again just feel free to join the queue and go to the mic if you have any comments and questions so uh first where is this immutable concept"
  },
  {
    "startTime": "00:06:05",
    "text": "actually derived from the discussion of system config draft I think around uh two or three years ago when we started to uh discuss the system config work on the mailing list and people really try to identify uh different kinds of system configur different kinds of system configuration like the non-modifiable uh and modifiable system configuration and deletable and non- deletable system configuration so uh the most initial uh idea of this immutable concept was really try to document the uh non-modifiable system configuration so this uh immutable concept is tightly Rel related to the system config work because a lot of system configuration is immutable but independent of the implementation of system data store uh that is because uh even without the system data store there still would be a lot of system configuration somewhere in the device while by proposing the system data stall we allow the server to expose an interoperable API for the system configuration visibility so the immutable concept is independent of the system data store hence why factor out and be documented in a single draft so and in this slide I try to give a a formal motivation of the this whole immutable flag idea and the motivation is that this is already the case today that the servers will reject the"
  },
  {
    "startTime": "00:08:01",
    "text": "client's attempt to uh try to uh modify and immutable node in in uh created by the server so so servers already do this today and there are proprietory documentations mechanism to for this immutable concept and already is also the case today that the client will receive every erors and if when such violations occur so while the an error might be sufficient to allow the client to understand that uh the client is not allowed to modify and immutable configuration it would be much better if the uh if the client could have some prior knowledge to about this immutability and avoid the errors as the very beginning so there is a desire to formally flag which no a server considers immutable so that the client can know beforehand when such violations may occur and this work really is merely about the visibility for the clients to know which configuration is immutable and tries to be uh to make the server's Behavior to be more transparent to the clients so this is a the motivation of this work and the current solution of uh this immutable flag is that we have defined a a young metadata annotation which we call immutable and as well an ability to retrieve it with a quar parameter we call with immutable so this uh immutable man notation is based on the definition in RFC 7952 and the value is used by a bowling"
  },
  {
    "startTime": "00:10:01",
    "text": "type to indicate whether a node a particular node is immutable or not and the immutability uh is Hierro applied to descendant nodes until explicitly overridden by The Descendant nodes so that the response size could be largely reduced by this hierarchy inheritance and we also Define uh with imut query parameter uh to be used in the retrieval operation so that this uh immutable annotation will not be returned unless explicitly uh being requested by this parameter and so that this could avoid breaking the lexic lines if lexic lines do not understand the immutable annotation they will not even use this quy parameterless they didn't see any change in their retrieval operation so this is now a single solution with a M annotation and people might uh recall that we used to have a young extension definition uh to be a joint solution uh used to collectively uh Express the immutability but the young extension is now uh not is not available now because the some people have concern that the young extension is is prescriptive and the server's Behavior Uh follows the the Y modu definition so this goes against with our uh Our intention that we want this immutable flag to be uh descriptive so the logic is opposite that's the young tension has been removed from the latest version of the draft"
  },
  {
    "startTime": "00:12:00",
    "text": "and then this slide gives an example of how this immutable annotation could be requested and uh and returned the so here we use some uh XML snippes to show that how like the uh NETCOM client could request to uh some configuration like application in this case uh which is a list and uh it also use uh with origin and with immutable uh parameter to retrieve the operational data store and the the servers will reply the related application configuration and in this case we would have two instance of the application node and the first is the system defined application instance which is uh specified with some underly protocol and default port number predefined by the server with expect expectation that this might be referenced by clients so the servers would like to protect this application entry form being Modified by the clients that's is uh system defined configuration and immutable immutable and the client might need to uh want to Define their own uh application so they can uh Define the application with different name like my SSH with the their favorite port number which is different from the system defined ones so in this case the the client defined um configuration is IM immutable is first so it's it's allowed to be added modified and deleted but the the server defined one would be in mute so this is also the case where a Leist"
  },
  {
    "startTime": "00:14:02",
    "text": "have uh have some entries and different entries some some instance are immutable While others are not Kent uh yes as a contributor um so in the previous slide you mentioned that the IM the immutable flag was uh hierle and um I'm not sure what the default is but the above the two application elements are the is the applications plural node and I don't see the flag specified there I'm assuming the default is false and and if that's true then the second application element where it says immutable equals false is probably not needed would that is that a true statement uh right yes so it if it's not there then it will inherited the immutability of its parent node which is the application container right and the container which uh the the immutability by default of the top level node if not specified would be first so this doesn't have to be explicitly specified for the second application instance which is would be first by default okay thank you yes Jason um I guess similar to Kent's uh question um the um immutable property is inherited does the draft and the draft recommends that it does not need to be specified if it's inheriting from its parent um do we is the intention that you must not speci specify it I guess I'm kind of wondering related to Ken's"
  },
  {
    "startTime": "00:16:01",
    "text": "comment is it actually incorrect to show it against that second application tag and instead we should just have a note on the side saying this is inherited false from the parent like do we do we want to preclude um mentioning it or or is a client allowed to put this property on every single element if it wants to I don't know if it's a question for the authors or maybe for the group or for discussion okay Ken I'll join that discussion um this particular case is the response from the server and it would be in the server's interest to make it be as sparse of a response as it can be uh and so uh not including um or repeating the immutability that was inherited it would be desirable and so I think in this case this the second immutable false should be removed or I mean the server wouldn't return it I don't think it's necessarily error um you mentioned can they client specified it's that's never the case it's uh the clients I suppose could uh sorry server the the oh okay yeah yeah I meant server my AP yeah okay but still nonetheless I mean to your point many people will take a snippet of config that they uh got from the server and then immediately feed it right back into an edit config and push it to the server so I think it' be um you know we need to have some language around the server not accepting that or basically ignoring any immutable um flags that gets pushed to it okay yeah yeah so I mean I understand this imut immutability the concept when it comes to clients immutable means clients"
  },
  {
    "startTime": "00:18:02",
    "text": "can change this but my question is how much can a server change what's immutable can it never change or change only at software update or can server change the content of immutable generally we would not like this immutability uh to be Chang very frequently and now there is a statement in the draft that this can only be change by some event system events like S software upgrade and license change and some something like that some like system events so I think by this way maybe it could be make sure that the client configuration could be independent of this uh I mean it will not be uh rely on the the immutability to decide whether the configuration would be invalid or not so I mean this SSH TCP 22 thing it would be there until the next software update I get you correctly yes that's my assumption yeah and and supposing that we have this immutability trke keeping as HTTP port to as immutable would it be possible to have some other fields under this immutable that are that are mutable I mean immutable false and is and immutable true let's say that we want change the port to be mutable would that be possibility so you mean the Ser you you said we you mean the server would change this immutable to be mutable right yes would it be would it be legal for from some server to say immutable true s is mutable PCP is immutable but port number is"
  },
  {
    "startTime": "00:20:01",
    "text": "actually immutable false is that possible yes this um so the the the port number is uh allowed to uh override this parent no dis immutability that's possible okay yeah I can sort of live with that if I'm really confident that ation TCP are never changing then so that only software updates can change the mutability because here we're getting into very sensitive areas one of the key cornerstones for inventing Yang and netc and all these things was to get rid of transient configuration as it exist in as MP and now we are getting close to the Border but if we can rely if we have to make sure that this language about under which conditions things can change when things are Mar as mutable to only be software upgrades I think we can live with it but we need to look at that language so that we never experienced these things change in the field okay thank you Jason um so I so i' comments on this on this new topic from Yen and then back to to Kent so first on on Yan's so the draft at the moment is not completely prescriptive about which situations a server is allowed to change uh the immutability of a node uh or about when it's allowed to um actually um change the value of an immutable node or change the immutability of a node so it I know the draft gives examples it says you know it shouldn't it shouldn't change a value of an immutable node but it's allowed to it shouldn't change whether a node is immutable or not but it's allowed to and it says it's should kind of only be done for things like software upgrade and"
  },
  {
    "startTime": "00:22:02",
    "text": "license change so I guess it's another question is how how strict do we want to be in the draft are we going to and I can see problems either way um if we leave it open then servers you know different server implementers will justify their reasons for why it needed to change dynamically from the server um but if we CL it to a very specific set of situations uh you know it's it's hard to know what other reasonable situations it may actually be kind of make sense to allow the server to change it but but just to be clear the draft does yeah the draft currently does allow the system to change both the value of an immutable node and it allows it to change the immutability of a node um I'm not sure we may want to discuss further how that applies to running versus system um maybe I'll come back you know what I think I'll come back after uh to to The Inheritance part uh that we started with Kent um we should probably try to finish one part of the discussion and then go back so I'll wait for the I'll go back in the queue for that comment I think I'm next in Q um Kent as a contributor the um I think the draft uses language it does mention software upgrade license and thirdly Hardware upgrade so and I think it has exactly those three whether or not it uses a word like uh like such events or exactly just only these events um to Yan's point I think it'd be best to lock it down and also to Yan's point about um application being mutable but Port The Descendant node being uh immutable false I think I think the draft might refer to this as overwriting and um similar"
  },
  {
    "startTime": "00:24:03",
    "text": "examples might be for instance if you have an a loop back interface or or some kind of interface uh which is fixed by the system so it's imitable uh true but the MTU of the interface is allowed to be modified so the MTU is overridable and hence immutable false uh another example would be a system must have a user called root uh immutable true but roots password a descendant node U it needs to be modifiable so hence it's immutable false I was just going to pick up on uh one of Kent's comps there here so um which I think is all fine I was just looking at how the immutability flag plays with lists and I think it's say sort Common Sense thing is that uh if it's mutable it sort of inherits on the list elements themselves presumably whether you can create and delete list elements and also on to the children I was wondering whether it would be helpful to try and split those two behaviors maybe with a separate annotation so it's possible to say uh you can't create or delete list elements but you can modify their children on them um or vice versa you can saying that you can add or remove new ele new uh entries but you can't then modify the properties because at the moment those two things are tied together and I wonder if in some scenarios that may end up being um somewhat annoying I guess with the flag you can just put it on on every single list element is another choice but I wonder if you considered that and if you had any thoughts Shan I think there questions to you yeah Shan go ahead I'll I'll respond after yes I think uh currently the the we we"
  },
  {
    "startTime": "00:26:04",
    "text": "Define that if a list entry is immutable then all of these uh children cannot be uh created modified and deleted and and and also the the children will inherited the immutability from its uh the the the from the is parent node so this is currently what we have find and but I I think uh whether we want to uh change the uh immutability I mean the the order of the a specific application like entry maybe that need to be uh this that need to be protected by the immutability that's something maybe uh need more discussion go ahead Jason okay um I guess about about the the lists maybe I didn't fully follow Rob but if a so the the imut the immutability tag um it could exist um it can only exist against a list instance right a list entry like when you look at the encoding in XML you get you see here in the example so here you can see the the uh application name SSH list entry is is immutable but I think I think we already answered the question that individual elements inside the list uh it's perfectly valid if the server overrides those and makes them immutable false right but I might have misunderstood your comment on that um and then uh back to the inheritance I guess Kent you mentioned that you'd prefer if the second application we remove the immutable equals false um"
  },
  {
    "startTime": "00:28:00",
    "text": "Notifier there I guess I still I still don't know if we've answered my question that is is a server perfectly allowed to return the immutable annotation on every single element if it wants to or must it use proper hierarchical suppression and maybe a slight coraly to that is do we want to do we just make the default be false or do we require all top level elements to have it explicit um and maybe maybe there's some lessons from other annotations and inheritance of properties from from from Yang that we can leverage there uh just commenting back on some of Jason's comments so uh the one you just most most recently mentioned I would suggest by default the top level having immutable equals force should be the default I think that's that would generally what I'd expect in terms of configuration and you don't have to return it yeah you don't have to return it in terms of whether it be strict or not I don't know I'm two minds of this I can see in terms of the traditional approach to ITF protocols is to be um strict in what you receive and loosing what you send sorry stting what you send loosen what you receive to to give flexibility here however I also know that some of the more recent sort of drafts from the IAB suggested a tighter definition of protocols and having less options is makes life easier for both implemented some client server so I'm somewhat agnostic to that one um going back to your original question on list and things is like yes in XML there's nothing to represent the list itself so you can't you would be a to put The annotation on the list so you are correct from that point of view um I don't know how metadata plays with Jason and where those annotations go but in Jason it may be that actually you can put an annotation on the list itself I don't know um so that's the other one we want to consider when we work out how how you report this annotation"
  },
  {
    "startTime": "00:30:02",
    "text": "uh yeah as a contributor um top level default FAL makes sense and not being strict I like the uh introducing the P pastel principle of uh being strict what you s and um you know flexible in what you receive but acknowledge the U the options that you mentioned I was thinking that it would be good to um I wouldn't necessarily be I would model it much after How We Do um X paaths um or or you know like Hier C paths so we many times allow for the prefix to a show but it doesn't have to show and and and so I think allowing it not forcing it to be strict is probably you know be similar um and and regarding lists uh in this example the applications node would have to have been a container node so they w wrapped the list inside a container and you know it's kind of best practice I guess if quasi best practice I I I I see it both ways um but um for XML it's best practice uh for kind of exactly this reason it allows you to uh well we traditionally always talked about it being the way that you could delete all list elements in one operation by deleting the the parent container um and now we're seeing another uh usefulness for having a a container wrapping the list element which is so you can set the imitability of it um and thirdly uh one thing not mentioned is if the list is marked as immutable um so we said no nodes no children descendants can be added removed um but also if it's an order by user List It means that they can the order cannot change I would imagine"
  },
  {
    "startTime": "00:32:04",
    "text": "um I I I'm so I'm also um in favor of making the top level just be default IM mutable false and it does not need to be returned and also in favor of leaving flexibility for Server uh to either you know take advantage of the hierarchical uh inheritance or it would be allowed to return it on every element if wanted to or needed to in some situation so I yeah I'm in favor of that flexibility so we may want to just on the slide in the second application container we could like Circle that in immutable false and put a note saying this is optional um or something like that that's one approach we could use there um about um lists and ordering um it's an interesting question if I guess Rob had raised it early if if you put uh immutable on the container above the list then I guess it might follow that things cannot be reordered the draft should address that um but if there is no top level container above the list I guess we'll have to decide whether immutable equals true on like the list element itself like in this case the application tags here if it says a mutable true we'll have to decide if that implies that the order of that item uh can't be changed it's a little bit complicated in my mind how you define that given that other things around it could change but we'll have to maybe Define what it means to order even without a a container above it yes I agree with this and maybe it be U more straightforward if it's a leaf list like if a leavea list instance is immutable matter it means that the order"
  },
  {
    "startTime": "00:34:02",
    "text": "cannot be changed but whether it's the same for the list entry I'm not that sure okay rad yeah so I joined late so apologize if uh my question has been addressed already so I see here was looking at your slides you're talking about metadata is this eventually going to go into Yang next or is it going to stay the way it is met data I'm not going to uh I think the this should be uh not be waed to the young next revision but some some some something that could be complimentary with the uh another work we which we discussed two weeks ago we call system configuration some um complimentary to the system configuration to declare is immutability okay um but uh I forget who was mentioning I think it was Jason saying we need clarification I'm jumping to a different thing now about whether list entries should be mutable I mean I don't think it makes sense to not allow ordering but allow list entries to be mutable but I have to admit I haven't thought about this extensively just I just don't see use case where you'd say I can't reorder them but I want to be able to up update an entry okay just to clarify I W I wasn't I wasn't implying that sorry if I caused some confusion I was more just wondering"
  },
  {
    "startTime": "00:36:00",
    "text": "if the immutable flag as it is with its current meaning also applies to order okay got it thank you uh yeah can't as a contributor um I don't want to hijack the the topic but you know Rashad mentioned Yang next and um and I'm not sure you know I mean chaan response was on point uh we don't really want to speculate what Yang next would be about but I think Rashad's comment was more uh speculating if the using of metadata here would be uh the long-term solution like like and and to that if that's the question I think that Yang NEX would carry forward the notion of metadata in fact it it probably make it a built-in part of the Yang language as opposed to right now it's being defined as a separate RC um and and and that furthermore uh the use of the metadata for this purpose returning immutability would also be the long-term strategy thank you Kent okay okay Jason um I guess back to um I'm not sure if we resolved uh an answer for whether a mutable changes allows changing of order uh so we should we should probably discuss that a bit more um I'm I'm I'm not sure I can see how that can work like if you have three items in a list and the middle one says a mutable true um I don't know how we can Define that that means its order can't change because I'm allowed to delete or remove entry above it uh I'm allowed to delete and remove entries below it because"
  },
  {
    "startTime": "00:38:00",
    "text": "those ones are not those are marked immutable false I can swap the one above and below it because they're both IM mutable false so I think it's actually difficult to Define uh it would be difficult to to to say immutable means you can't change the order um and maybe related to it is a discussion that has come up a couple times here that applies both to lists and leaf lists there's a in leaf lists that if every single El because you can't mark an overall Leaf list uh in XML um you can just Mark each each entry in the leaf list uh in in XML encoding so you can't mark an overall Leaf list with any sort of property um but there is a note in the draft that says if every single element is marked with a mutable true then that somehow uh causes the whole Leaf list to be immutable and you're not allowed to add any further elements um I don't know if the same would then apply to lists um but I think this might this might be kind of a little bit of overlap with this discussion about about ordering like the elements you've defined and said are immutable true it's not clear how that whether that should or can really infer anything about other elements in that list or Leaf list I I kind of feel like maybe it should not um and I guess I'm questioning a little bit the the concept that um if all Leaf list elements are marked um immutable true that you're not allowed to add further elements to it uh I'm not I'm not sure we I'm not sure that's that's what we want to do oops I just want to say I agree with Jason it's probably not actually needed either for the use cases that were listed in the document there are no"
  },
  {
    "startTime": "00:40:01",
    "text": "such cases where it's important to prevent moving entries around I believe what do you say Okay I I tend to agree agree with that Jason okay so I I I I guess I agree with that as well so the proposal on the table is that this immutable flag has no bearing on order of user ordered lists or Leaf list entries um but the second question is if every entry in a leaf list or list is a mutable true does that uh block does that imply that no further entries either list entries or Leaf list entries can be added and there uh I'm not as sure but I kind of lean towards saying it does not prevent that in other words there is no this mechanism does not kind of limit or prevent adding other entries into a list or Leaf list Kent uh yeah um okay so I don't know if I agree with that at all um about it not impacting the ordering or limiting the ability for clients to reorder I mean you have to ask like why is there such thing as order by user uh list in the first place and and you know the classical scenario is a firewall policy rule base or you know where there's a sequence of things that they need to be interpreted in that order and uh allowing um clients to change the order doesn't make any sense at all so I kind of struggle with um that I think that um we would need to uh I I the XML encoding is is the"
  },
  {
    "startTime": "00:42:01",
    "text": "problem is the challenge I mean in if it's Json encoding only there's no issue with being able to annotate the um the list element itself um and but an XML you know unfortunately uh 7951 I think it's maybe it's 52 doesn't give the uh detail but this draft could say um that if it's set on the parent container then even though it's not the kind of thing that would be normally uh I mean if it like maybe if it's the only container um if it's the only descendant of that parent container then it has this similar effect or something like that [Music] um but I mean I I think the current draft it is fairly specific about and making a distinction between what it means when the list element itself is immutable versus when the items inside the list are immutable and uh you know I think those are two different cases in the document uh the current document captures them as two different cases um so a few things on there um I guess I'm not super excited about having some exception to the behavior that kind of depends on the fact that you've created a special container to contain just your list um that just feels uncomfortable to me uh I I I guess if if if if we were to do this um I don't think we'd want special rules that it only apply if the list is the only item in a container uh it's should job probably just be some general inheritance that if the list is inside a container whether there's other"
  },
  {
    "startTime": "00:44:00",
    "text": "sibling elements to the list or not um and then I guess uh even so with XML en coding there's no there's no top level list entry and other encodings there might be but I think we might still run into so it is true you can give an overall property then to a list maybe in in some other encodings but um I'm not sure if that's necessarily all the use cases is to give that same property uh that would allow immutability or reordering to the entire list because I think a lot of the use cases here are actually more that there's a list that has userdefined elements and system defined elements in it it's a mix and I guess I guess I can resonate a little bit with the fir wall thing uh Kent um I mean if there some System created entries in there maybe the system wants them to be the first three entries in the list uh and not for anything to change um but I I still wonder whether that should be outside the scope of this annotation and that's just the error the server would just error it's not I'm not I'm not sure we can describe that with this annotation maybe the other thing to consider is in a mix of immutable and mutable entries in a list if we want the ordering property to be controlled is that just amongst the immutable elements and their relationship to each other or is that with relation to any other immutable or non- immutable entries it just it gets into a bit of a tangle in my mind yeah okay um it is a tangle and you're right about that good thing we're only talking about adopting the draft now and there's plenty of time for the work groups to to work on it uh these are some complex um interesting problems"
  },
  {
    "startTime": "00:46:01",
    "text": "um and also I want to retract what I said before about the special case uh the parent container I it's actually not needed you're right it the uh even though the XML encoding doesn't um uh support the list itself being there it is implicitly there uh in the model the data model the conceptual data model and it is implicitly receiving or inheriting immutability from a parent whatever its parent is in this example the the note applications plural um and all we're really talking about so it's not it's not affecting um okay what it affects is the ability for the server to express that um the IM the immutability of the list itself uh toggled between it and its parent um that applications was for instance immutable false um but the but the uh list element which is not present on the screen is mutable true true right or something like that it it toggled and it can't it can't express the fact that it toggled um but and and that's then so if there's no violation of rules uh it's just saying that it's not expressable um and then is kind of right like it would just appear on every list element right maybe that's the uh I don't know but the um I think that would then go to best practice right so it's not we're not saying that there's a special rules or or that are in play but then the best practice is that you wrap your lists inside dedicated containers if wanting to express them in XML"
  },
  {
    "startTime": "00:48:01",
    "text": "yeah I maybe I'm I'm I'm I'm not sure I'm totally in favor of going back to this best prce of wrapping this around I think you're right it can't be expressible in one single line like you can't show applications is a mutable false IM mutable true and then the entire list is immutable false but it is expressable in a way just you know every if that was the case then just every application line here would show a mutable false so you can still return the data it's just it's returned on every single list uh list element instead of one kind of top level list element I'm not sure that's the end of the world uh let's park this for now um we're on Slide Five of nine so maybe we can get to the next slide okay so okay so from this slide I I will properly present some um candidate solutions that has already and be touched before by some folks from the working group but uh be dismissed by the authors so I will uh present why I why we are not uh CH to use that and the first is the neck and neck refers to the netork configuration access control module and the the there are a lot of restrictions with neack to uh with if we use the neck rules to express immutability the restrictions is that"
  },
  {
    "startTime": "00:50:01",
    "text": "neck sometimes can be disabled by setting the enable neck configuration to First and neck can also be bypassed by emergency recovery recovery session and the most important is that um we we can have neck rules to declare the immutability but the rules themselves should also be immutable and cannot be uh Modified by the client and while the rules usually can be overridden by adding new uh rules before existing rules are matched so this is something I think uh the restrictions about neck and the second is about the no tax which refers to the solution uh there is an ongoing draft has already adopted by the working group in and about the no tax mechanism but this no taex uh is not preferred as immutable tax uh is returned is by reading a separate Notch module so we would like the immutability to be returned with the the the the the data the notes instead of uh reading a separate modu to to get that immutability information and also tax is something that can be controlled by the client it can be removed from the operational stat by add adding it to the masked TX entry while immutability something cannot be controlled by the client so this is uh why not no Tex and also the Y deviation statement uh which defines the way a server DVS from a standard this is also not"
  },
  {
    "startTime": "00:52:01",
    "text": "preferred uh for immutability which is not an implementation limitation caused by server software or Hardware ability it's more like a a node property uh of immutability and also we cannot use y deviation to deviate the mutability property of the uh system define configuration especially the instance level of immutability this cannot be achieved by Young deviation okay so then we have the uh this is I think this is the last slide of this presentation and uh it's about whether this draft is ready for adoption so I guess let me just pause here and uh see if any other comments and concern Jason hi uh yeah I still have a couple more discussion items um which may may be kind of interesting um I guess um well we should maybe come back to it but we never I don't know if we ever finished discussing and and maybe maybe Kent's right on this it could be tabled for for later but while we have people on the call it may be useful like I don't think we ever solve the fact that if all Leaf list yeah just quickly I mean um we're only we're less than halfway through there's plenty of time for discussion I just wanted to ensure that um chiffon had an opportunity to get through her slides and uh now that we uh have gotten to the end uh circling back on things and focusing on them um you're right we have uh everyone on the line so excellent opportunity uh let's move forward with uh you know Jo down into items um and we'll come back to that last slide um I'll do a show of hands poll at the at the end um and it won't necessarily be the end but at least will be the beginning of a new discussion okay I would I I would I I"
  },
  {
    "startTime": "00:54:00",
    "text": "would recommend we have a bit more discussion before we necessarily make the the call for option like might as well do that a little just a little bit more as things are wrapping up just so other other discussions can happen um the uh so so I guess the first one is the the item about if all Leaf list elements are marked immutable does that does that uh does that by definition mean that no further Leaf list entries can be added and then I would also wonder if if that would apply then to lists and why it wouldn't then also apply to lists uh maybe I I I guess I'm a little bit on the doubtful side about uh when when individual Leaf list entries or or individual list entries are marked immutable I can see how that entry maybe is not allowed to be added removed or modified uh but I find it I guess I find it a little bit odd that there's this property that if all of the entries are immutable it means you can't add any further entries uh I'm just not I'm not sure I really love that cery it may just have to be implementation specific in other words not I would almost say that we just we don't we don't say that in this draft and if a server wants to refuse further entries that's fine but it's not the fact that the other all the six entries already there are immutable that that implies that necessarily yeah I I can see use cases where there may happen to only be immutable entries in a list to start but uh the client's still allowed to add entries especially for a list uh quickly uh Jason can you clarify are you speaking um about the XML representation the issue XML"
  },
  {
    "startTime": "00:56:02",
    "text": "representation a specific comment no no so I I don't think it's related to encoding at all I think just it's just conceptually in the draft it says if every leaf list entry is marked immutable then it means that no further Leaf list entries can be added I think that's independent of encoding um and that's the one I'm questioning and I have my doubts again coming back to the use case that I think there may be cases where a server boots up and the only content of a leaf list or a list is say a single or a couple of immutable system entries uh I wouldn't want that to by our draft preclude that a client can add entries to a list that or Leaf list that uh is already populated purely with immutable entries oh okay I I didn't realize that was in the draft that uh if each of the list items are uh one thing then it means that they all are I didn't actually I think I'm gonna have to go offline or not offline but you know to a different window real fast to look that up um I thought at first it was going to be an XML specific encoding concern um and so I thought I'd take another whack at that and how can we uh enable the expresses through XML encoding and it was actually when chiffon presented her last three slides the one with node tags um you know I I agree with the current proposal of kind of inlining it into the response uh payload uh using the with immutable um input query parameter uh so the clients can you know select to return it and all that looks great um uh but there's this one issue of how to encode the imitability in XML uh the of list"
  },
  {
    "startTime": "00:58:00",
    "text": "and list leak list uh themselves and with that then maybe it says the draft says that node tags are used like it's not the preferred solution but it's a possible solution um you know for the most part you never have to use no tags but if you really really want to find out about the lists and leaf lists themselves then a No Tag lookup could be used to resolve it okay y yeah so together with this observation by Jason if we had a list where all of the or some of the entries were marked immutable true and there was a few that were immutable false those that were immutable false we can obviously delete and when we deleted them that list would suddenly be list with all immutable true and suddenly you couldn't add more entries to it at least that's the perception from the client I suppose so this sort of arrangement is probably not reasonable but maybe we should go back and see right now we are discussing a mechanism where immutability is conveyed entirely by attributes as I understand it but maybe we need a combination we have some extension statement in Yang for example you can apply that to a list that would say tell the client something that yeah in this list we allow or don't allow additional entries you can and then you can have individual attributes for individual list entries as well but I think we might need both I think conceptually we could need both especially to address especially to address things like uh some of these reordering is reordering allowed that we've been asking um and whether you're allowed to add entries but but I'd also think it may be valid for us to consider just not having those in scope like if we look at"
  },
  {
    "startTime": "01:00:02",
    "text": "the key use cases maybe it's good enough for this draft that we don't have a way to indicate uh stuff for the list overall or reordering um I think we should consider that that it may be good enough we've defined that individual list entries have properties individual Le list entries have properties and there is no concept of an overall property for the list that's any different than each individual list entry having that same property actually I've been putting comments in the chat but um so I was just going to say you could potentially use two separate attributes here one for the sort of uh descendant properties versus the properties the list itself whichever way around you to define those what the default is what the current the immutable flag means but I also Plus on Jason's comment that actually it may be over engineering solution and for what's required it may be a single flag is enough and you don't have as quite as much flexibility as you want I think the case that I was thinking of and I think this has come up in like the knam circles was when uh I can't remember it was i e or one the other sdos they wanted to be able to say um a particular user has the ability to I can't around it was add or remove elements for list but they can't modify the elements that are there or or vice versa so they definitely wanted a difference in Behavior between uh modifications of the list structure versus modifications of the elements within the list and hence I'm just wondering if we don't do anything here whether we'll hit that same issue um so definitely it's worth flagging as an issue for discussion at some point um I I agree with actually both uh what"
  },
  {
    "startTime": "01:02:02",
    "text": "Jason and Robert just me said um the uh I mean first to Jason like I mean I I if we completely exclude the ability for to ever express even in Json uh encoding the imitability of lists that like we it's not possible in any encoding and all interpretation is derived from the immutability of the list items um that is a complete solution it works for all encodings um you know what would the Fallout of that be how um you know to to uh Robert's point just now um 3gpp were hoping to affect the structure of the list uh not specifically the items themselves so perhaps it wouldn't lend to that um solution but it's worth considering it it I mean it's uh it solves the problem of there's no special cases like I like it for that reason um but the uh Robert brings up a good point and and also the point about possibly having different uh attribute right right now we're just having one attribute called immutable uh maybe there's different like spe list specific attributes like list immutable and there's actually two separate attributes that are Hally you know descending through the tree um and and the attribute is only specific or makes sense or useful to lists but it has some uh expression that allows us to express something that we can't just Express with a simple booing that's coming out of the um immutable annotation and um let me see I think I'll stop for now get back in Q in a second yeah I can so from a technical point of view uh I I think maybe that that could be a solution is have something different that applies to lists uh maybe it applies to Leaf list"
  },
  {
    "startTime": "01:04:01",
    "text": "as well um and it it would you know we could have separate semantics for that tag that you know solve some of these questions we have um it's not simple though right it's like uh can you reorder lists can you only can you only reorder the non-mutable items Etc uh so it may get complicated so I think it's technically possible but I I guess I'm still leaning a little bit towards keeping it out of scope um the downside I don't think the downside is huge keeping it out of scope like when we think about it here I mean things work today it's the server will just refuse what it's not allowed the client developer yes it's a surprise they'll have to go read the documentation and you know rework their clients to work around some of these issues the same way they will once we add this tag uh you know they're still going to have to encode some of these rules these new rules about how to interact with these servers that have immutable data um so you know if there's some more cornery cases that we can't describe with annotations or in the model but the server just returns an error and it's in the documentation maybe so be it so I I guess I am interested in how important this use cases that's I guess Rob mentions from Scott uh about about some of these cases are talking about they can't can't be described just individual immutable Flags against the elements okay so we the purpose of this is to provide extra documentation for the clients so they can avoid uh unnecessary errors it um so already the clients have to deal with the fact the server can return an error um but now the idea is that they can get more documentation and avoid a number of those cases um so if a solution is not complete um it's not the end of the"
  },
  {
    "startTime": "01:06:00",
    "text": "world I mean it's maybe a 99% solution but you know there's some weird cases that are not completely covered um I would find that unfortunate I would rather see a complete solution of some sort um and and then also I just want to Circle back a little bit ago there was a concept of using um a Yang extension uh to you know support or you know Express things that aren't expressable solely through metadata and just wanted to highlight shaon said this at the very beginning or earlier that uh the previous version of the draft had a Yang extension statement it was taken out and um the she said uh very eloquently that it was taken out because of concerns about the solution being prescriptive as opposed to uh just simply descriptive um um and I think that makes a lot of sense the um but that's not the only reason it was taken out uh I think also it wasn't a complete solution so what I mean is um with metadata it's possible to express um it's a complete solution you can you can express the meability of the entire tree uh using metadata but with uh SCH schema extension alone like for inance if you have a heterogeneous list where some of the list items are can be imitable and others cannot be imitable like this isn't something that's expressible in the Yang schema if you just you know the flag is utable true or false in the Yang schema it it wasn't possible to express heterogeneous lists that way so it was taken out um also not only because concerns of it being prescriptive but also because it wasn't a complete solution yes and the the the other reason might be that I try to F some y modules that"
  },
  {
    "startTime": "01:08:02",
    "text": "published by ITF but I didn't find any um that would probably use this immutable young extension so maybe it have shouldn't Define it so I was going to try and move conversation on just like different one again this is was a contributor so uh and it sort of picks up on one of the points that Ken was making and my question is about um what this draft should or does say about interactions with the running configuration data store and also uh what if anything does or should it say about like elit config requests and I so I think the questions I have is can you make a request for uh this immutable um annotation on running is that a meaningful thing to ask or not and if so what does it return and in terms of edit config requests is does it have any inpl at all so if something's marked as immutable in running does that mean that if a client tries to delete that configuration from running the server may turn around and say no it can't do that um or or does it just say nothing about running at all or the edit config requests and hence it's sort of out of scope in terms of what's being trying to what's being defined here so um I don't have any issues in terms of the specification profiling just like a descriptive Behavior it's just how do we avoid that descriptive Behavior then being used to modify how uh the operations work is what my concern is or question is okay so regarding the uh immutable immutability with the uh in how to interact with the running data stall so this the immutable configuration can only be created by System a system configuration that's present in system data stall so it will"
  },
  {
    "startTime": "01:10:00",
    "text": "not be present in Running by default but the client might be uh copy it I mean right if it right like write a a same value copy it into running and in this way if it retrieves running then this configuration might be returned with the immutable equals true and this just mean that this value cannot be overridden like write a different value to overwrite this is not allowed but this can be deleted from running just like the the the client uh make it visible in running and then can deleted means like make it invisible in running so it can be deleted from running and can also be created with the same value in running so okay on that one I think that that would be really helpful for the draft to be very explicit on that behavior um so I think that's probably okay uh but I think the draft should be very explicit as to what what's allowed and what it's um and what semantics are there okay okay yeah yeah so on this latest discussion here so I think it's also valid for a server to have this system immutable through things in running when the system first starts up as that means from the factory so it could be there all the way from the beginning and just stay there in running right yes but the but the thing I wanted to comment on really was this uh when you have these immutable true and false attributes on on things that means I mean there's something that you cannot express that idea in by extensions in the Yang schema but the other way around is also true these"
  },
  {
    "startTime": "01:12:01",
    "text": "attributes can only express things about things that are in the current configuration and not about things that could potentially be there like if you want to add things or remove things that sorry add things that are not there now that cannot be expressed by attributes so there's a sort of Duality between things that you have in the schema and things you have on the actual configuration list items okay Jason Frank do do you want to respond to that because mine I'm going back to a slightly different topic so Yan's I guess talking about maybe the need the potential need for for schema extensions versus instance data annotations okay maybe um yes maybe first let's discuss whether we would like to uh use the extension to express the schema level immutability I I we we used to have this before but as as I I mentioned earlier I we have removed it because of some concern that this is the young tension is prescriptive so I'm I I'm not sure that uh that would be needed so maybe need we need more discussion about that let me comment there so I mean if a server is going to re reject creation of new instances in a particular list that cannot be expressed with attributes and if you want to be able to express that it has to go into scheme and I don't see why an extension statement would be more problematic than the current situation where the server is free to reject it anyway so I don't think that there's any new prescri prescrib uh that is being added here by this extension statement but yeah"
  },
  {
    "startTime": "01:14:01",
    "text": "okay thank you Jason um I guess I'm I'm going back to uh two topics well I don't know if other people are finding this but there's not a ton of us and we um because of this Q structure we keep end kind of getting halfway through conversations and jumping to another one it's kind of just feeling slightly awkward but so maybe people should I don't know maybe people should feel more willing to jump in when we're in the middle of a topic uh to drive it to more to conclusion Jason do you wish to change the topic right now we're talking about the extension schema uh that is the topic yeah top yes I was because the previous one let's wait until um there's anyone else that has anything they want to say about the extension schema topic and then we'll then I want to go back to one that I was going to comment on before this one came yeah I'm holding on to a few thoughts as well but yeah let's make sure we get through one Topic at a time so right now we're doing the extension scheme of topic okay I will I will comment on that one uh then the um uh you know Rob Rob had earlier proposed that maybe there's a different you know a different sort of tag uh that applies to whether uh an overall list can have entries added or reordered or things like that um when he was talking about that overall tag I guess since that can't be expressed in XML I I guess we'd be talking about it as maybe a schema extension um I don't know if if anyone has some other thoughts on how you express in all encodings including XML some sort of property of the overall list I don't I don't I don't think that works so if we wanted that I guess I I can I can see how an extension might make sense um it's the yeah the problem is it's defined as as part of the schema"
  },
  {
    "startTime": "01:16:02",
    "text": "and so a server doesn't have an option of like different servers couldn't have the option of advertising different behavior for the list on their implementation um and I guess that's where maybe the the the tags idea could be considered uh but I still come back to I'd like to hear unfortunately the 3gpp folks aren't on you know what are these use cases really important like I know our our annotation against individual list entries uh definitely matches some of the use cases being described um I just I I still wonder whether we're you know agonizing over a corner case here that should be maybe a maybe that could be a follow-up work uh yeah uh so on the extension statement uh okay Yan uh was on point about the uh The Duality nature that's I hadn't thought I mean of course it's obvious now that's been said but um but in I in theory it's true in practice I wonder if so and the reason why I say is because I would imagine that uh any such list uh that the server is thinking or or element really uh that's um hasn't been configured U but the Ser that' be like system defined configuration it would it would appear in the system data Store and could be discoverable uh by the client you know assuming the server implements the system data store but the client could do uh get on that and then with the with immutable flag and discover the immutability of um information that actually hasn't been"
  },
  {
    "startTime": "01:18:01",
    "text": "configured yet in running I I think I I think I remember balash saying though that uh he was Keen for the mutable flag and it's part of why it was separated out from system data store that it could exist this concept could exist on its own without system data store um because I think maybe I I assume he's thinking that there may be some 3gpp server implementations that would not have system data store necessarily but may still have immutable data that appears in they running whether you know whether that's uh there's probably you know various opinions whether that's good practice or not but uh you know I think some implementations may do that uh so that's that may not I'm not I'm not positive we could fully necessarily rely on on a system data store to express that information but no it doesn't have to be system can also be operational if we don't have system then we don't have system data St but we can still have system configuration be present in operational so if you retrieve operational you can still get the similar information I thought that was only if it's actually used though or like in use yes yes in use yeah and I was going to say uh intended is another possible location where um data store that could return the immutability of nodes but uh in intended that's be that's before what is in use has been called and so it"
  },
  {
    "startTime": "01:20:02",
    "text": "avoids the concern just raised about operational yes yeah right um sorry any more comments about this topic ex extension schema if not then um I'll call on Jason to bring up his next topic so it s yeah it sounds like we're just going to shove that one um for a moment um I guess I'm going back to there was some discussion about I guess I was just looking for clarification a little bit um there's a discussion that you can you I I think we were leaning towards being able to get this annotation from running so there's some cases where you might read read from running and you might have um if I understand correctly you could you could have some say a list instance that says immutable true but you're actually allowed to delete it because it had the same value as it had in the system data store similarly you're allowed to create it uh as long as it has the same values in the system data store um yes is that does that does that kind of imply I'm not I'm not sure but does that imply that immutable data in the running can always be deleted because uh doesn't it doesn't immutable data only ever enter the Running by copying it from the system so immutable data can only be"
  },
  {
    "startTime": "01:22:01",
    "text": "system configuration right then that's should be present in system data store and will not be present in Running by default so uh it will not be present in running unless being explicitly copied into rning and then you can delete it yeah you can delete it and even you delete it the system will still uh the data store will still be merged into intended and that value will still be in use by the device if it can be applied successfully because it's in intended data stop anyway system will be merged into intended so even you delete it from running and can still be present intended and and maybe present in operational as well if it's in use okay but I think I think what follows is that I don't know if this going to match with with bash's thoughts from 3gpp that maybe doesn't have system data store but it sounds like by that definition anything marked immutable and running can always be deleted or maybe I reverse it does anyone know of a scenario where there's something marked immutable in running and you cannot delete it because I'm not seeing that in the from this discussion no I don't see any such case Okay so okay I guess that's kind of good because I was I was where I was getting to was that it was going to be confusing for a client to maybe that there are some ENT trees marked immutable that can be deleted and some that can't but it sounds uniform I think we'll want to confirm with bash on the"
  },
  {
    "startTime": "01:24:02",
    "text": "because I'm pretty sure if I I I have the feeling if I told blash yeah anything in running marked IM mutable can always be deleted uh he would immediately say no but maybe maybe just uh maybe just have to work through these corollaries I'm thinking maybe um blash was thinking some cases where the immutable configuration is not system configuration maybe uh something similar to the a statement in 3gp gpp leaz on that says something like the configuration can uh cannot be uh modified directly but can be deleted and then recreate with a a different value so that's in this case it's not the system configuration it's configuration create by the client does that mean we're not addressing a use case that was important to 3gpp like are they expecting a solution to that but we're not providing it we are trying to dismiss this use case for some concessional API consideration so this is something we decide not to support it okay K I hate to speak for 3gpp but they're not here and so I'll do my best to um you know put a bow around this of some sort uh I mean I think okay so what this draft is saying is that it allows for discoverability of the you know the immutable status of notes um it it doesn't it doesn't say anything about you know uh whether or not things can be deleted from running or not you know if they're immutable because they can be fch from system it just it doesn't say anything it's a it's a vacuum uh in term it's you know it it's mute on that point um so you know if uh and I don't I'm I'm saying this and I"
  },
  {
    "startTime": "01:26:02",
    "text": "I'm not promoting it it's a use case I don't actually uh uh support directly uh because I think uh you know going back to what Yan said a long time back about wanting transactional API um but in 3 gpp if a node got created um and then the client said you know give me the information with immutable and the server returns and it says oh I just flagged it is immutable um I mean this draft supports that it supports the discoverability of the immutability status of nodes regardless of how they got created so so it in my mind it half supports the 3gpp um use case um the other half of what they're wanting is if I understand it correct is some ability for the client to um do something it's it actually it's transactional it's a uh it's a non-transactional uh type sequence of events and this draft is not saying anything about supporting that there's there's nothing in the edit config request that has any impact on anything that this draft is um bringing forward um but just it's only on the get operations so clients can discover and how those noes got created as outside scope I agree it's unfortunate that the Lash and other people with stronger 3dp commitment are not here but I have spent considerable number of hours in 3bp as well and I can say immediately that there's no way that we can preserve the fundamental properties of neton and yang and also Implement all of the the ways that CVP models things so there are internal contradictions between those two so we have to go a long way towards implementing things"
  },
  {
    "startTime": "01:28:00",
    "text": "that are useful in 3p world but they cannot do them all and in the earlier versions of this draft some of those uh use cases were in but they have been taken out yes J so I guess I I've I've looked through the draft but I I so I I didn't realize that we didn't really Define that a client May return an error if you try to modify an mutable thing but I thought I thought earlier in the call Rob was kind of asking that we clarify that in the document um whereas it sound like maybe there was actually an explicit uh decision to avoid clarifying you know any changes or behavior to an edit an edit data or an edit config operation I.E erroring when it tries to create delete or modify and immutable so I guess maybe open question or question back to Rob just to make sure that uh like are does that contradict what you were thinking earlier about wanting to Define in this draft uh that you error that there's an error to an edit data I I think it's more the other way around so so my concern is I don't know which RFC says it but I think maybe non net comp for RFC seems to say something on the lines of that a serers allowed to return an error for any reason it likes and I get the impression that that's being uh used more heavily than it should have and then then it's saying that well it allows a server to implement any Behavior you want and I don't think that that is quite quite right I think that there's exceptional things a server might do run out memory Etc that are fine for it to just error on but in terms of the semantics that"
  },
  {
    "startTime": "01:30:01",
    "text": "Yang expects like an edit config request I expect that so should honor what's in a standard edit config request and hence that's my concern in terms of this immutability flag is is just in terms of not wanting to effectively change the netc protocol via the back door without explicitly saying it but you're is going to be saying well the the the servers can annotate all these different nodes as immutable and then when a client tries to set them the area is like no you can't change it it's an immutable thing and it's like well that's not what what the net comp for or Yang specifications really allow for but they have this this get out clause that says you're allowed to reject any config change so that's the bit that I would like to see tightened up and fixed somewhere I'm not sure this is the right place but I think it'd be nice in a fure version of net comp for Yang to be a bit more explicit about what sorts of errors are allowed and what aren't um that I think that would be helpful because at the moment if you allow to to return an error any time it means that you can make a like a nonsensical server implementation that just does what it Li does what it likes does that help clarify well I guess are are you so are you comfortable that the draft basically just says here's an annotation uh but doesn't really Define that a server would error when trying to create or modify uh an element that was marked with a mutable I I think I'd be comfortable at the level of saying if you try to if you try to change its value basically i' be Comfort if it said that that the site can either exist with a particular value or or it canot exist but it can't have it can't exist with with any other value I think that's okay to me that seems reasonable what I don't like is something that says uh you can you can delete this value and create it"
  },
  {
    "startTime": "01:32:00",
    "text": "with a new value but you can't change the value because that to me breaks like trans transactional semantics it's like there's no reason as to why we would want to enforce that behavior at the on the client it just makes it harder harder to uh code the client so that's what I want to avoid is that like transaction Behavior if it's a piece of configuration that says uh um if you try and write a different value to to this node it's never going to succeed then I think the mutable flag is probably fine for that I think that's that's okay presumably the documentation of the device says you're never going to be able to change this particular thing um I was thinking applying a p sell principle to this and the server being um literal about what receiving and you know the the thinking being is that there's nothing the client can do that would change the immutability property of any node on the server and therefore the a server implementing this draft would be perfectly in its right mind and in fact it might be recommended to discard any immutable uh attribute that comes any metadata that comes in the uh edit config requests just discard it it it has it has no bearing um it doesn't matter like what value it might have it's irrelevant it we could go that way um and that really underscores the principle of it's completely server driven uh however that approach would be less um amenable to the 3G PPU approach like if we actually want"
  },
  {
    "startTime": "01:34:02",
    "text": "to make it that the server can uh error you know on such cases so uh then then you know actually uh returning the error when the um when the client tries to change the meability of something I think that'd be more in line with what 3gpp is hoping for I I didn't quite understand the I don't think I was ever suggesting that a client would send um the immutable annotation into the server I don't think that that is a good idea I I think that the immutability is always a property of the server so the client would just put in a normal edit config request if they do a get config request then I think it's okay for a server to annotate back uh with with the request with the particular option to say I want to add in this immutability annotation I think that's okay but I'm not I think I agree with you that you should never you should never be able to affect the server Behavior by putting that annotation in I think that sound very strange I'm not sure Kent was necessarily implying that I and and maybe I'm bring up a different point but I something resonated that Kent said and that is we we probably don't want to prescribe that a server must eror when someone tries to edit this um I think we should actually avoid that I think a server can advertise this property uh a server May reject modifications to that property but I don't think we I don't think the draft says it and I don't think we should say it that a server must reject uh just for just I can give you one use case as an example you could have an immutable field inside a list entry but a server could elect to allow it to be changed by under the hood destroying and recreating the entity uh the list entry um I don't think we'd"
  },
  {
    "startTime": "01:36:03",
    "text": "want to preclude that behavior uh so yeah Jason I think I agree with you in the sense that I'm I'm it's the May that I'm suggesting uh rather than a must as in if you have an immutable flag set then a server May reject uh May reject changing that configuration to have a different value but I still I still think it has to say or should be saying um that that IM mutable the mutable value is is over the lifetime of that particular uh package install or something as in if you upgrade the device then it might be it changes what's immutable and what the immutable values are but you can't come along and say I've created a new interface I I'm I configure value 10 on this and then another interface comes along and I'm going to configure value 20 on that they're both immutable and I can delay the interface and create one with 30 I don't think that's right I think you should always have the behavior you can go from 10 to 30 I just don't think that's immutable so I think if it is immutable that the value that you're constraining it to is one value unless you do some sort of upgrade or package inst stall or something that changes it as in whatever is written in system is the mutable value that it has yeah but different interfaces and system could have different values right for that item yes or different interface types I mean the bit the bit I want to the bit I want to desperately avoid is US allowing basically writing a new transactional behavior on the client API that says now uh you have to force clients to do config changes in two steps you have to first delete this this configuration then you can recreate it to something else because I think that breaks what we're trying to do in Yang uh uh of saying you should be able to go from any one valid configuration to any other valid configuration and the server"
  },
  {
    "startTime": "01:38:00",
    "text": "should do the instrum instrumentation to get from A to B and you shouldn't force that onto a client so that gets okay actually I'll go back in the queue go ahead for the on thank you I mean this discussion that Rob summarized so well now is exactly what I by this offline validation in the previous interim I don't care if we can do it in offline tools or not but it should be possible to take any given configuration and answer the question is this valid or not regardless of what knowing anything about the current configuration that is a key thing just like Rob said now um going back to to to R Rob your case there I guess um I guess one one one tricky part to it is I think if there's if there's a list entry with an immutable field um and the list entry can be deleted like uh I guess maybe maybe I just want to read iterate that I think I think that's in line I think what you're saying is in line with the fact that we're not going to preclude a server or or inforce that a server must error on this um but I'm I'm just a little bit worried about what you said about destroying and recreating with a different value I mean if there's an immutable field and a client tries to write to it I actually I actually don't want to preclude that a server must erir if a server under the hood wants to destroy and recreate the object that's still transactional as far as a client is concerned in other words the client is declaring what the end state it wants to"
  },
  {
    "startTime": "01:40:01",
    "text": "achieve is says commit and the server does what it needs to to achieve that and I wouldn't want this immutable flag to preclude a server from doing that behavior but but my point is that is not immutable that that property I don't think should have the immutable flag on because I don't think it's immutable so if we end up with an immutable flag where it says some servers will allow you to go from current state to desired State and it'll and it'll do any modifications internally and yet we allow other servers to say no it's okay for us to force the client to delete the parent list entry that is on and recreate the list entry to do that I think that's really bad I think we just ended up I I I thought you know can't put in the chat I thought I thought we were kind of going towards saying that the server May reject it rather than prescribing that it must I think it's a may but so it may reject it but but you can't but it should not be used for this scenario so so what I'm saying is it says that either the value exists in running or it doesn't exist that's fine but you re recreate it it has to have the same value again because that's the only value it can take I don't like immutability being you can use it to program a value into the device and then and then you can program any value you like but once you program that value you can't change it I don't have any issues with like the system configuration that says like in the example given here with SSH it says the SSH protocol name is used and has this property so you can't change that you create a different one but you can't change the existing one if it was that the port number was marked as immutable and it says well when you configure SSH you can assign assign the port number 22 and that's fine or you can delete the SSH and add another one and and assign a different port number that's also okay that's the thing I want to avoid it"
  },
  {
    "startTime": "01:42:00",
    "text": "needs to be that the the properties you're expressing and that's what works well with system is it says it has these values this is this is what the configuration is so if you you can put this configuration running to complete the configuration you can't assign different values to it but you can assign that you can overwrite it with the same value to make the configuration complete um but but none of that breaks transactional Behavior well I mean I I think I I might see what Jason's saying we're not talking about a system defined list we're talking or or you know let's just assume it's not a system defined list it's some other list and it's completely in uh it only exists in running apparently um and so the client does an edit config and they set a value in that list so so like okay like the before configuration State and the and the and you know State a and state B so State a and maybe even a state C so State a is that there's there's no value in the list State B is now there's a value in the list and state C is really back to State a I or or maybe there's a different value in the list um but the the point being is that once the St you achieve State B and you do a get with the imitable flag set I mean and to 3G P's case they would say oh um it's immutable um they flagged it the server and flagged as immutable um and and so um now if you were to just try to delete that one node itself it would fail um presumably I mean May reject is what we're saying um"
  },
  {
    "startTime": "01:44:00",
    "text": "but that would also be a valid I mean State B if you just go back to State a it I mean State a was a valid state so the client could say I want to go back to State a and and hence it by doing so it removed it wiped out the node that the server just said was immutable but State a was a valid state so um I don't know I'm guess it's it's a little bit twisted um or or to give a a concrete example that some of the devices I've worked on you can put an interface in a mode where it's running in an L2 mode or an L3 mode and internally the way that's represented in the system is radically different so uh if you want want to change it even though the configuration looks like you can change this property between L2 and L3 within the system you have to delete that interface object and recreate it again with a different property all the way through the system and um when customers have a valid configuration and they've configured that interface to be L2 and they want to move to another valid configuration and that interface is now L3 they don't want us to come along and say oh no you have to delete the interface first in as as an intermediate state intermediate configuration and then you can go to the one with it now in L3 they want to be able to go from configuration a to configuration C and have the device itself delete the interface and recreate it without any sort of impact on the client and so what I'm saying is I I don't and for us we we all get bug reports if we can't do that transition that's effectively the the requirement from our customers are saying you have to be able to transition from State eight from any valid state to any other valid State and you as a system should take into account any instrumentation you need to do to get between those two valid States if you're moving from trying to move from State a to an invalid state of course you reject that that config change but it's it's going"
  },
  {
    "startTime": "01:46:01",
    "text": "from a valid state to another valid state that we should always allow and I don't want the mutability flag to be or anation to be used to stop that and force an extra intermediate State on the client because it just makes the client's lives so much harder to do and hence what one I'm request is I think this draft should be very explicit that the utable flag should not be used for that purpose as in it should be you must not use it this way so so Rob that that scenario you uh described we have exactly the same thing in our implementation as well I've seen it um and I guess what you're saying is um like if it's useful to express that behavior to a customer you know hey by the way your interface is going to be completely torn down and recreated so for example all your statistics are going to be reset back to zero etc etc you wouldn't describe that as immutable you describe that as if you if you want to do some proprietary metadata that says uh destroy and recreate parent or something if you weren't going to advertise that property it's a totally different property than immutable uh yes greated that yes that's what I that's exactly what I would say so I can see that so the thing is I'm not sure we can I'm not sure it's so easy to invert it and then pre preclude uh create text that prevents um an other implementations from amusing immutable in that scenario though it just feels very specific to have like text that says well for this specific scenario um you you know you're not"
  },
  {
    "startTime": "01:48:00",
    "text": "allowed to use the mutable tag I mean a mutable tag is it's just it's it's I think we're still debating whether what what a server is allowed to do with it but I mean we're gonna say either May or or must reject the change um I maybe maybe you're actually AOC that we're we are saying that the server must reject the change but I just don't know if that's too sweeping to control the situation you're you're trying to preclude I I think you we could State the the desire or the goal of being able to move from any valid configuration to any other valid configuration and the ual flag should not be used to prevent that from occurring as in it shouldn't be used a way to signal that Ser is going to force transaction force a third or split transaction behavior on the client I'm strongly for exactly that yeah okay I can see that um and I I think the way the draft is defined can kind of achieve that because um we we only allow stuff the only IM mutable instance data allowed is instance data that existed in system so you can't have you know interface fu with MTU 1500 uh exist in the same software release as interface Fu with MTU of 1492 like there's only one valid state for interface Fu configuration because it's Define in the system config like that actually I'm thinking that to use the statement like Ser May reject or M error could be the right way"
  },
  {
    "startTime": "01:50:02",
    "text": "since sometimes the S could just accept that but doesn't uh does not apply that so it it can be accepted by servers but it will not be applied successfully so maybe that's another case for the server did not reject but would not apply yeah no that's something I don't agree with if if a server silently accepts a configuration that it's not actually using that could be very problematic I think it if it does not going to do it it must reject it okay I think what uh chiffon was saying and correct me if I'm wrong chiffon but is kind of what I mentioned earlier with pestel's principle where the server effectively ignores all um immutable attribute or metadata that's coming from the client it's just ignored and so that's the case where uh the the May reject would be well it would that that particular server instance would would never reject like um that particular scenario I mean the point to Jason you know we're always the ultimately the draft would have to say it must reject May reject or must ignore or something like that those are the three states I think or you know we need to pick one um ultimately that is not how I understood Chang uh you're talking about the attribute which coming from the client has no meaning and we could ignore it that's not a problem the problem is if a client sends in a configuration that has some different values than for immutable through things like SSH TCP Port 2222 and and the server just ignores that because well it knows it's got to be 22 anyway and that is something I am"
  },
  {
    "startTime": "01:52:00",
    "text": "against oh okay sorry I do agree with you on that point Yan thanks okay okay so let's move to that last slide and talk about it a little bit in the last few minutes that we have here um I think we've had a a great discussion again uh following on the interim that we had two weeks ago on the system config draft um really getting into the details of uh this draft has helped a whole lot and uh and so um thank you everyone for the discussion let me prepare a uh show of hands right uh do people see the show of hands by chance I I think I started it yep okay no one was no one was uh voting or humming couldn't tell well I see the vote on screen okay I see yeah I see it now it it it just I think everyone was in shock like it started now's my time to vote okay uh well anyway this is very optimistic this is um well of everyone that has uh you know contributed to this show of hands it's unanimous that um this draft is ready for adoption so uh congratulations to the authors and the oh yes you you still"
  },
  {
    "startTime": "01:54:01",
    "text": "have to take this to the mailing list right uh of course yeah okay yeah we'll do the minutes and take that to the mailing list uh the adoption poll itself goes to the mailing list right so I mean it the adoption is a consensus process and uh so there's two things to go to the mailing list one is the um minutes and second is the adoption po itself um yeah Rob so so I support I support adoption of this but my adoption is s conditional on the comments I made before in terms of we want to make sure um that that this this can't be used as a back door to effectively change the semantics of the Yang or netc protocol uh so that's my that's that's my side that's that's with no hats on as well it's just individual okay um so not ready for adoption yet uh the authors need to make a couple changes and then uh when ready um they can ask for it to be adopted and the chair adoption at that time uh not hope that's not for my they can ask for adoption now and the adoption call could happen now on the current draft have problems that but I think assuming I I I'd write comments back on the adoption saying doop it conditionally with these comments that these things are addressed that would also be fine with me so I don't want to necessarily slow this down if your comment Kent was on my response uh it was uh okay now and now I understand you would make that be a an adoption um response condition like yes okay okay you're you're giving a preview of things to come uh so there is no blocking um actually kicking off on the current version of the draft thank you corre clarification"
  },
  {
    "startTime": "01:56:03",
    "text": "yep all right any uh last closing comments um I mean it's kind of like we we we we did the the main thing uh we achieved that goal um I suppose we should give time back I don't want to enter into another conversation another topic um thank you chiffon for presenting uh good uh slide prep and thank you everyone for participating in the conversation um uh I guess we're pretty much concluded with the with the interim um but I'll just leave it open for a little bit so people can sign off all right bye all thank you thank you thanks thank you bye"
  }
]
