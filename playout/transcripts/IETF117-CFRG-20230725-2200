[
  {
    "startTime": "00:00:37",
    "text": "Good. Hello? Hello? Yeah. I'm still Alright, folks. Take your seats. we're about to get started. THIS IS the CFRG. If you're here for another meeting, It's not in this room. Okay. We've got a pretty full agenda today. So we're gonna kick it off with the chair slides. Lexi, take it away. Hello? So, yeah, I'm Alexi Malnikofin. Nick Sullivan sitting next to me. Stanislaf is did a lot of stuff in background, and I believe he's enjoying his holiday the moment, So just quick update from chairs, the usual stuff, This session is being recorded. We have a minute take. Thank you, Joe. please don't forget to log in whether using the full clients or Local. only client, it helps keep track of who is in the meeting so we can have a proper room allocation."
  },
  {
    "startTime": "00:02:07",
    "text": "So the usual, I hope you you've seen the note well. If you haven't, you have some documents to read up. So this is about intellectual property and participation. Okay. So as I already said, we have audio and video recording. We have some presenters who will be remote. So please use to to get yourself into the queue. And please follow code of conduct, in particular, Be professional and be nice to each other. k. I probably we probably should have updated the slide on masks, I think. That's probably mostly a nonissue now, but Anyway, So as a reminder, this is irtf rules different from the rest of ATF. We do work on cryptographic primitives, but We do quite a lot of research and more experimental stuff here as well. So this is our agenda. We have a lot of quite short updates on various documents we have lot of document in a in flight at the moment. So which is, I think, is a good news. We we wrapped up flow or they're close to being published. And"
  },
  {
    "startTime": "00:04:02",
    "text": "A lot more will be following up. and agenda bashing. If not, We're doing the usual couple of slides on status various documents. I'm not going to read every a big document. So we have several finishing up actually in being in of 48 now. So just about to be published as RFCs. Some are being edited by RFC Educator. a noncurrent T and ISG review, but one in our are scared of you, We're not waiting for our TFTR to do anything. So it's all either in the research group or in post processing. And as you can see, we have a lot of documents in the in flight. majority of them were updated recently, so this is all good to see, and we'll have we'll hear updates on many of them today. if you see anything on these slides which you think is not accurate Please let chairs know. k. And with this, let's go to the choose updating, so So"
  },
  {
    "startTime": "00:06:03",
    "text": "And Nick is going to talk about the new document that got recently up r. adopted is guidelines for IT and geographic specifications. This is gonna be a pretty quick Okay. updates. for to to refresh people's memories last time presented an idea. around having a document to help specification writers specifically in the IRT era, i r t f, and CFRG to help make it clear what the expectations of these documents are to helped lead to higher quality written outputs. from this group. Next slide, please. So there's a number of use cases for this or a number of reasons that this is beneficial. I don't need to go into all the details here, but draft was shared on the list. and it Got it. certain amount of positive feedback, mostly all positive feedback. So next slide, please. So I'm just gonna review a couple of these pieces of feedback. that are intended to be addressed as the document continues. as a research group document. One of that was brought up was references to previous RFCs. this was a little bit light and sort of not keeping in the ITS tradition. So having more references to the deep knowledge that we we've shared together at the IETF is gonna be one piece of feedback that we addressed. The second is use of standard mathematical symbols. There was kind of a kind of a joke put in there to see if people would notice, and people did notice So there there's questions around the the the debate of group operations whether they're multi"
  },
  {
    "startTime": "00:08:03",
    "text": "looking for additive whether to use non ASCII symbols. And things like this. This will all be cleared up and discussed on the list. there's some questions about some terminology, like, formality, like, does formality mean? they're that there's always room for a more detailed glossary in a document like this. and that's something that will be addressed. the next point here is broad support and review commitments. So This was a part of the positive feedback. A lot of folks on the list said that they'd be willing to review and provide comments on this document, and we appreciate that. The last piece here is something that wasn't wasn't fully fleshed out in the document but was recommended as as an as something we should do, which is parameter choice one of the biggest things that people debate in bike shadow and over over our cryptographic standards. So having more detail about that is something along line. And so that that's about it. The the document is adopted. and it's gonna be continue to be worked on from this point onwards. So any questions? Anybody online? Nope. there anybody on the queue online? Chris Pat and Cloudflare. I think this document's awesome. I think the most important I I was one of the people who complained about like, the definition of formality and how it means different things in different communities. I think the most important thing we can do is make our document self consistent. So I think that"
  },
  {
    "startTime": "00:10:04",
    "text": "if that's, like, the the kind of the lowest condom common denominator, I think that's perfect i So Yeah. Yeah. Yeah. 1 vote for consistency. which is also one of the sections in in the document. Jonathan in in the chat said that using a unit code for double struck letters would be really useful, but not to obvious, it's allowed on the ROT 7997. think it is actually. I and use of mathematical symbols in general is probably the better use case for using UnicodeCode. So So someone mentioned this the other day, and I had a look. And I read RC 7997. Sorry. Jonathan Houghlin Cloudflare. Yeah. And it says in the in the text version of the spec, like, dot TXT version of the spec, You just have to write out the bytes like the as letters. And only in the PDF, do you show what the letter is, And that That would be really hard to read. Like, like, it's I I'm not sure double struck n is I was I could recognize the byte code for that off the top of my head. Right. Maybe. I I guess I could learn a new trick. server. Yeah. So common Perkins, there is at least some discussion about seeing that's I'm in favor. Where's that discussion happening? Well, the RSWG, the our RFC series working group, which is meeting on Thursday. and just I I'm unfortunately, the document author on the one that is discussing this. don't take anything that you read, set install. I was just going to say, I would really like to mass"
  },
  {
    "startTime": "00:12:00",
    "text": "Sorry. Wilhelm Baker. I'd really like to use mathematical symbols. I've tried. and the current 2 tooling doesn't support it. Well, they disappear and turn to blocks when I try and use them So, you know, it'd be good if this group said that this is something we would like to do and that's probably the way to have things happen. Alright. common Perkins. So the the RFC editor does support non ASCII characters in our seas. There are perhaps some rough edges around the tooling. There are some issues some policy issues which needs to be resolved. But we have had a number of RFCs that have none q characters in So if if the group thinks that it's a useful thing for the for clarity of the specifications, then can work with the RFC editor and and it will happen. Okay. Thank you. Thank you. Right? Next, Nick. k. Next is Tobias. I'm going to Alright. Yes. Yep. Uh-huh. but it doesn't Do it right. Do you want to share them? Or what Yeah. Alright. My name is Tobias, and I'm presenting on work on them, the video signature scheme. Next slide, please. So just a bit of a recap on this scheme. There's 3 protocol participants, assign a prove it and a verifier. The fundamental properties of the scheme is that it's multi message in nature and and the sense the signer can sign multiple messages."
  },
  {
    "startTime": "00:14:03",
    "text": "and it supports selective disclosure for the from the previous perspective. these proofs are set to be 0 notchproofs. mixed, So the as as previously said, next So the prover is basically in possession of a signature produced by a signer that as protects a set of messages plus a header. The header is basically payload section that must be revealed or verify us. in the multi message payloads are the ones that the approver can select within in which to disclose. They generate a 0 knowledge proof, which is basically a proof of knowledge. position of a signature. Next slide. And the verifier can then basically prove integrity on those revealed messages and the revealed header. guarantee authenticity of them back to the original signer. without knowing the exact signature that the approver was in possession of in order to generate that proof. Next slide. So just a few updates since last time today at obviously, we've published draft 3 in preparation for this ATF 117. The basis for most of these updates came through some new work from academia. There was a recent paper published in EuroCrip that revisited previous signatures in the construction documented in our draft, and they managed to find some additional efficiency improvements as well as reproving formal security, And in in that effort, they the optimizations have ultimately led to a ability to remove one component of the signature. and a a few components of the proof in order to"
  },
  {
    "startTime": "00:16:05",
    "text": "improve the compactness. Those numbers there just for note are based on the BLS 12381 Curve. obviously, signature size and proof sizes there. somewhat dependent to to the field size. So there is a link to the paper below for those that are interested. Next slide. Just a quick note on what we have served in in our implementation in implementing these is this this sign procedure verified proof gene and proof verify all found notable improvements and performance. Next slide. Some other things that we've done in this draft and the latest is within the Cypher suite definition, we have worked upon documenting in a in a self sweet like, extensible manner. 2 kind of functions or procedures we call Generator creation, which are fundamentally the public parameters that are involved in the scheme. So generators refer to basically the points that we commit messages to. and how we manage those public parameters in a way that keeps implementations of of the scheme simple. And then also the message to scalar mapping prestatia, keeping in mind that we we believe that additional surface suites in future BBS may want to do. different forms of scalar mapping. such as, like, ranging integers for, like, predicate proofs or or the likes, whereas the predominant mapping procedure we use today is basically a hashing a message to Scalar. So we've just really reject a bit of the document to provide that further extensibility in future for those that want to extend this game with new Sypho Suites."
  },
  {
    "startTime": "00:18:00",
    "text": "Excited. This is yeah. This is a little bit more sort of details on that create generations procedure. how the current procedure actually works, which is basically a feedback in counter mode. and also how Sypho Suites they said, which can extended. We need we needed flexibility, I think, it's important to sort of highlight here different constructions of the scheme may wanna use existing, like, public well known points, like the base point, in a field so they can one of the messages could be a ordinary sort of public key. And so the generated kind of creation procedure needed to be parameterized at the site for suite level. to support that. sudden. And, again, Yes. Sorry. Next slide. And yeah. So, again, with the met message to scale layers, as I previously sort of said, the use cases here for flexibility are really around things like coal to binding and the and the predicate proof. So you wanna take scalars and and make them messages and map them so that they can be used with range proofs, like extended sort of 0 knowledge proofs. that makes this compatible Next slide. and next slide. We also sort of adjusted the Cypher suite ID, for the different Cypher suites to capture that these things are prioritized so that we have good cyberSuite separation and future extensions. Next slide. some other more sort of editorial updates. We keep the test"
  },
  {
    "startTime": "00:20:01",
    "text": "vectors in the core document for now given the kind of feedback from the previous ATS session. still considering moving them out later. In the meantime, we have added new test vectors we had some feedback that we didn't have any using variable length messages and we also added some tests in for no header or no presentation header. just so that interoperability can be facilitated for those cases. We updated the error handling to sort of talk about where we expect implementations to to abort. And we also shifted the KDS, to a hash scale instead of Hmac. So that was really in a pursuit to sort of simplify the primitives we were using within the draft. Next slide. And that's it. Any questions? Hey, Christopher. what's the status of the implementations of this? You mentioned that you have an implementation. Of course, I try check with you how, and I couldn't find any. So I'm just curious if you If you know of more and if you do know more, could you collate them into a single list so we could test stuff out? Yeah. Really good question. Ahead of this, ahead of this ATF meeting, I think I'm aware of 3 others other than ours. that have updated to drive through. But we will collect them into the repository so it's easier for people to find them because I think all other than ours, ours is to be open sourced. everyone else is already open, so I believe. Bye bye. Thank you. watson Lad Akamai, I think I needed this draft earlier in a privacy path I'm I'm glad I was aware of it now. I'm a little concerned that you might be expanding the number of use cases"
  },
  {
    "startTime": "00:22:01",
    "text": "in a way that doesn't necessarily tell people who wanna use it, what it is they need do And also, when you have a eurocrypt paper from few months ago and you're putting it into a draft, that The amount of effort required to really review that and make sure it's right is still quite a bet compared to if it was just sticking with BBS from the original publication because that's been looked at a lot more. Yeah. So the the reason that DEXYCU authors wanted 1 or 2, they I understand, like, the draft also points to the previous academic literature as well. But there were some changes in the setting that this draft thus you're a cryptpiper So it's it's a it's a revisiting paper. It's not a completely new scheme. but but Wiggles changes impact the security analysis in a way that we might have to look at more carefully. Well, my my interpretation of it, and it'll probably be some for the academic authors to comment on, but they think that it is actually distribution that further strengthens the security rather than yeah, rather than kind of resetting. building building upon previous week. Armando First graph here. So you mentioned that you changed in your last slide about KDF. So question is, is there any motivation to use extendable output functions, rather than defining everything on, like, Yeah. So we originally had usage of extendable output functions, but we wanted to, in the draft, at least, try and we had we originally had usage of Exxons in other places as well. However, we kind of reorganized some of the primitives from has to curve. some of those to make use of them. Instead, and we kinda got to a point where the only place we would use in in the midst of would be in the key generation function because the this is this is a key generation step. Right? So implementations are actually kind of"
  },
  {
    "startTime": "00:24:02",
    "text": "free to generate keys. However, they want. It's more of a a suggested way, a secure way to take an IKEM and Generate. Does that make sense or somewhat. Okay. Vasilius of coauthor might be able to speak to Yes. Hello. Thank you. A little bit more. Marcel Carlos, I'm of the other shows draft. we do have support for external block actions. of the other surface with such a base on cycle 256 So throughout the draft, we do use xlfaximms. But through the primitive define into customer. you can use expand to message XND, which is just a plain, cross function, or it's not messaged itself, and we define such issues that use both. And whatever you use, that will be used. to derive the keys. These are not changed. Got it. Thank you. Thank you very much. k. So next is Frank. Oh, audio. I don't"
  },
  {
    "startTime": "00:26:01",
    "text": "The presenter seems to be remote, and we might need to reshuffle this. he's not doesn't seem to be online at the moment. which is quite unfortunate. Okay. So let's Scott. k. This is gonna be a very quick note about NASH to talk about the latest elements parameter set draft. next page, Very quick history. We created LMS RFC 8554, a while back, which is this finds a stateful hashtag system based on chalk 36 We were asked to 2 dosing span these choices. So Quinn and I created graph, Fluor, LMS, more perm sets. this defines includes a to a a 9 a 192 bit Shaw based track, right, hash function. which about halves the size of the signature And there's also a shake 56 based version at 129 2 and 56 bits the 192 function, of course, drops you from level 5 to level mystical 5 to midst level 3. But, again, it has a size and still it's quite conservative. Next page, Iana's assigned code points for these new parameter sets, and they're also standardized in this publication 800 is 208. The only thing that we've been, I've been told that is wedding on is a few more people reviewing it. And so would somebody please review it you. And, also, one other thing, I've also been asked whether or not Thank"
  },
  {
    "startTime": "00:28:01",
    "text": "we should standardize this format of our private key, which is exported. We I must if we do that, I suspect it should not be in this draft. It should be in a separate draft. k? Any questions? post estimate, classifier. I'm happy to review the draft Thank you. Have you considered 128bits trunket attached to Sprint. How how how well, how big? 128 bits? We did consider that. I had a conversation with this where we decided not to go that size because we're not quite comfortable if you're going to do the safe stateful base hash function, level 1 sounds a little bit too close. But but but again, if somebody wants to add add a new draft with it, I'd that wouldn't be opposed. Alright. Thanks. Thanks. Yep. I've Thank you. Nope. Yeah. publish the last Andrey, you're next. Yeah. Hi, everyone. How's today? I'm going to give a total properties of a deal that goes to our once again. Well, next slide, please. Well, since last IETF meeting in in actually much. Nothing much was done with the text over"
  },
  {
    "startTime": "00:30:03",
    "text": "we haven't published a new version where there's some minor changes in the text which due to the fact that we are doing very are taking a short pause for research stage, and we're looking for some As I found previously, we are looking for some function applications which require a new sort properties from AETLgorithms. And the next person is scheduled luckily by the next NHTF meeting. Next slide, please. and how speaking about looking for part If your application if your protocol has some specific requirements for AET. please let me know. I would be really hap happy to hear from you. Next slide, please. Paul, in his top I also want to address a question, which I receive quite often. it is about classification of how we classify properties in the trust. We divide them into 4 groups where, like, basic security, additional security, implement location properties and additional functionality. And we've 2 of these. Everything is quite clear, but with security properties and additional functionality properties of like, distinction between them is a little big paid. Next slide, please. If you speak about security and the, like, about basic security, we usually can see there's some non respecting adversary. who wants to break, like, usual potentiality and integrity is for basic setting. It is for basic security for AED scheme. And if you want to achieve some and use some additional security. Next slide, please. we, like, extend what anniversary can do or"
  },
  {
    "startTime": "00:32:01",
    "text": "it wants to achieve and communicate in communicating VPAD scheme. Like, it can repeat we allow him to repeat nonces and inquiries or, like, Next slide is or, like, allow him to or we consider an anniversary which wants to make, like, many forges at once. Hi, Dave. Next slide, please. Thanks. Padv, additional functionality situation is a little bit different. Like, when you have some product and you that some additional functionality to it. You usually change the interface of your product because it has to, like, a return new data or it has new inputs, And we follow that approach in the chart too when speaking about additional analogy. We say that property is additional penalty property if it implies different, like, a change or extended interface. like, Veev, incremental ADT, you have a new function, update function. And Next slide, please. And can you consider Then let me change interface. You actually change you define a new class of algorithms. It is, like, error in some sense, a bb class than usual AET, And for bypass, you have to redefine new redefine base fracts predefined basic adversarial capabilities And it is, like, and new distinction between additional security properties and additional functionality is. You can analyze every casual AD scheme for having additional security, but you cannot analyze it for likes in this new sense of basic and of new basic threads and new basic adversarial capabilities. because how?"
  },
  {
    "startTime": "00:34:03",
    "text": "you even can't put it in security model due to different interfaces. So this is rather theoretical and But the thing that cosifying and finally finding a pay to five properties is a good way to find common languages the language. And if you have some opinion on that, I would be happy to hear from you. Well, that's all. Next slide. We yes. With context. Any questions? Watson Led, Akamai Technologies, My question is sort of in this sort of breaking down of the properties let's say you look at something like a Cypress one pass. I mean, this one pass It it can't be fully robust and non resistance instead you're leaking a certain amount of information, namely the length of a common prefix, or if that Is that fit into the overall splitting up of the security properties or misread it, sir, that some of the terminology might you have these terms online, you have non resistance, you put them together, and you don't really have a language to talk about things that might not be as robust as other things. Mhmm. Speaking about one pass, I guess it is more, like, implementation proxy. But when we some implementation properties can influence like, security properties and connection between them, very recent connect You can't achieve some implementation practice with about losing Mhmm."
  },
  {
    "startTime": "00:36:03",
    "text": "and without losing security properties. And but these protests by itself, I think when they can be divided like, in some different groups. company. I'm first of all, I I'm I think this is thank you for, you know, doing this work because it's like there's so much such a nebulous big space, all these a e a e a d papers. I wanna throw one more at you. wondering if you I'm wondering if you saw that paper from, I think, Barbosa in 2018. he called it indifferentiable authenticated encryption. I want Yes. I just wanna hear your take on that paper and how it might or might not fit into this draft. Uh-huh. I have it. Like, I actually really love India differentiability, it is like one of my new favorite things. Not speak not only about AD, but about hashes, and I like I like it. it is in the queue. I have to study it a bit a little bit truly because it is new, but I'm going to think about that and edit to somewhere. I think it is security property in some sense. Yes. Thank you for your question. I think it would be really cool to see security proofs for like, normal like, I don't know. Probably, you have to start with, like, a robust AE scheme. and you prove that it's in differentiable when AES is a ideal site for whatever. Yeah. I think that would be I think that would you know, maybe it'd be the the tool to rule them all. Maybe. god. It is Oh my very interesting and, like, interesting bills and this with the industry stability and related, so it is might be critical. Thanks."
  },
  {
    "startTime": "00:38:04",
    "text": "Alright? Thank you very much. Thank you. them, Yeah. Thanks to Dan Harkins. So proposal to add some features to HPKE. So next slide. So some of the issues of with HPK is a it has some bloat when you use the nest curves, the serialization of the public key is more than twice as big as it really needs to be. can be an issue for constrained devices and also for use cases where know, you can't amortize the overhead oh, with a whole bunch of packets. Another issue with HPKE is that assumes guaranteed inward delivery of packets, and that's not really how the Internet works. And this is bad because if packets were reordered or dropped, the HPKE contacts would would become out of sync, and there's no way to even realize that happened or to resynchronize that everything just goes south. So there's no way to bug it. It's resolved, and things stop working when you go out. 4, That's not good. The other issue is key wrapping is not wasn't really the guiding point of of doing HPKE, but I think it is a valid obvious use case. So it would be nice to have a some key wrap and support. So next slide, please. So what the draft proposes is to add compactrepresent patient of public keys for the nest curves. This is all a RC6090. This would defines it defines new camps and new serialization and deserialization. but also proposes to add deterministic authenticating encryption from RFC 5297, which is the"
  },
  {
    "startTime": "00:40:03",
    "text": "the specification of the Rogue away Shrimpton paper from from EuroCript which will address proveable security treatment for key wrapping and also address the the lossy network use case for certain types of traffic For certain types of traffic can't use DAE, the draft proposes to add an r c2401 style anti replay window. to deal with lost or reordered packets in a certain certain window. So next slide, please. That's the graft. And the resource code The source code is completely compliant with RFC 9180. It also includes support for compact representation for the theness curves as well as as DAE Ciphers There's complete test vectors for both of these things. I stole some some of the numbers reserved to Ayanna to generate the test vectors. So if if might have to change them. It should be pretty easy to enter a new test vectors. Next slide, please. So the crust is pretty stable. The coat is very stable. The draft is currently at 1, but it was based on a final 2, so technically this is maybe 5th version of of There the draft. has been a whole lot of discussion on the list, but there has already been some cases where I'd like to propose of these features in different protocols. and be really nice if we had an RC to point to instead of this this graph. So I'm hoping maybe we can get a RGLC call call, That's it. Thank you, Watson. Watson mud. I can't mind because people haven't heard it before. I think when I look at this draft, What there there's nothing that Stanza's really wrong, but I guess"
  },
  {
    "startTime": "00:42:02",
    "text": "if you are talking about communicating nodes over a lossy channel where you might have these retransmissions, why aren't you doing something interactive? to set up a a session transfer key Because it feels like maybe Maybe what you're doing here isn't quite right for the application It's a very different context than where HPKE is really analog. And I'm worried a little bit on security implications there. No. It just seemed like a logical way to address the problem. I guess it could be dressed another layer by This is a let us help you avoid avoid security pitfalls that we know about. Yeah. I I I'd I'm not sure what the security pitfalls of of DAU would be. It has a security proof behind it. It's been the roadway encrypted paper. So so Chris Wood, know this is, like, adopted document, but I like to suggest that perhaps we split it into 2 they're, like, 2 very different use cases that are being addressed by 1 specific document, one of which is, like, very simple and small that is, like, the compact representation. put that in a separate document. We do not need an RFC for it. You could just keep it in the the group because it's already been adopted on the basis of the being in the ID. But, like, we just went through the registration process for getting 3. Super easy. It's already deployed. We don't need to be spending so much time on it. And then that would allow us to focus this draft on -- So -- -- like, the How do how do I get a new get a new get a new get a new cam assigned, and how do I describe the serialization, deserialization. You just need a drop that is it has a stable reference a stable reference. Like, so just pop write an ID, and you follow the process for registering, and that's described in the in the registry. That's all you need to do. Okay. it's I mean, same for the AED, actually, as well. Like, we we don't need RFCs for any of the Actually, stuff. The the whole way we designed HPKey was specifically"
  },
  {
    "startTime": "00:44:01",
    "text": "to make it super easy to add things like, new chems, new ADDs, new KDFs, to provide it, they they satisfy the the security contract, the HPP. I'm not suggesting saying, like, don't do this, but I'm saying, like, don't do this. But I'm saying, like, don't do this. But I'm saying, like, what's like spend less of the group's time on things that could be dealt with in an email. I hope you don't mind if you I I ask you to hold my hand in the process, but I guess -- Of course not. Okay. Right? Right. So very good. Thank you. Thank you. k. Bjorn, next Okay? So thank you. I'd like to give you an update on the decays draft, which deals with symmetric password authenticated key change. Next slide, please. We've just uploaded version 8 which is essentially unchanged since version 60 and quite stable in our opinion. So I'd like to recall the objectives of the last major, right, which was for version 6. So where we focus are focused on the implementer and protocol designer perspective and lot less on the security researcher perspective as we now have very detailed papers. So we the draft tries to to facilitate the integration and existing frameworks such TLAS, which come with a clear initiates responder role and which come with specified message encoding formats. on one side, but we also wanted to provide an plastic encoding, form"
  },
  {
    "startTime": "00:46:00",
    "text": "prescription on on how to use CPAs and your stand alone construction. where which might have been build up from scratch. 2 And coming back to the consequence of the discussions that we had in the pay selection process, as a we've seen that there are 2 to use cases, one use case where we are having a a message sequence ordering, which is enforced by the protocol, for instance, such as in for TLS, But we also have applications. We have had discussion on patients where we have no ordering of them messages from both parties, and we try to cover the this aspect on the also in the draft in order to make it clear on how to use see pays if you don't have an ordering. as in dls, for instance. And, finally, we had added comprehensive test factors. So next slide. In license version 6, of the draft, we have received quite some feedback from people that have implemented and worked with the draft, and have contacted us Unfortunately, mostly, the discussion has not been carried out on the list, but probably, and interestingly, then most feedback that we came back from implementers actually did use work on implementations of the risk strategy and decaf side for speech, which shown on the the draft. And on the other side, we have received some feedback which advocated for rather not pushing we'll just try to handicap Cyper Suites in order to reduce the the complexity and focus on on"
  },
  {
    "startTime": "00:48:01",
    "text": "on less of platforms so that for instance, to give more more focus on on the risk curves and I've done that, standards, short wires, transfer presentations. So We have At in the editor team, we understand those perspective. And we'd appreciate some feedback on how to deal with recommending Safa Suites and what to include in the draft and not include in the draft. we don't see any security issue or on security difference from for the different variants. It's rather policy topic or It's not a security issue anyway. And so What we are currently doing in in the draft is that we include the test vectors and detailed description also for Restacher And Decaf. and I think My personal personal opinion is that it's a good idea to have them included. But presently, we're not adding these type of me to the explicitly recommended list of of staff at Suites. So but we'd appreciate some feedback there, and probably it's a poly as a possible if the policy is issue That will will be both opinions or different opinions around. So next slide, So as we didn't see a lot of objection or or difficulty regarding readability from the feedback we think that we might go further and proceed with maybe an editorial review by some native speaker. We be helpful to get the right up improved And I think it might be the time to start an office for review for by the group to review panel maybe in 1 or 2 weeks so that we"
  },
  {
    "startTime": "00:50:00",
    "text": "get further with this with the draft. So at coming back to one topic of of self contained write ups. I can confirm that it's really helpful to try to have all information better either needs in the draft, for instance, My plan is also to add test pictures for all the building blocks for the recommend selfest suites also in the sea paste drop. For instance, to add also test vectors from the hash to curve Suites, which we use and recommended Salesforce Suites Also, in the CPaaS draft and not only referred to the has to cliff draft because it seems that at these interfaces where between the different components, that seems to be an true for audit or difficulty for the implementers. So probably, it's a good idea. to have the information somewhere relevant and have it of the same 3rd content so that the implement finds any test factor for all the building blocks the entire final protocol in one draft So that might help help implement those and we had some this some some feedback on questions, which melt with this interface. so so so And similarly, we are planning also to ads, Jason, load test vectors because it might really help some implementers Probably, we will be adding it not to the draft, but rather to the reference implementation which we use for deal handling the class pictures. So thank you. Chris Wood, on the Restrado decaf question, You said it, like,"
  },
  {
    "startTime": "00:52:00",
    "text": "of the feedback was that it introduces additional complexity. did you mean to say that the the complexity is that the tech is longer or the document is longer, or that using Restrado and decaf somehow made the protocol more complex. I assume it's the former, but I'd like to I think it might be both. It might be both. obviously, if you're helping people which don't like your structure of the idea of the concept of your structure so much they also will complain about a longer document. I I think it's somewhat, it's difficult. We just received the feedback oh, maybe rather make the document shorter and easier to read and leave out your schedule. But I think now that you are using the structure also for opaque. I think it's a good idea, and and that's now that the structure and data is more as far in towards a real RFC, I think it's something which probably should cap. That's my personal opinion. Yeah. Yeah. That would be my suggestion as well, and that's a good segue into my next comment, which was, you know, we have these 2 different drafts that are both specifying some form of, like, pick. It would be fantastic if we use, like, various consistent terminology, notation across both. hopefully, we other we have this other group draft in the doc or draft in the group that that that that Alright. Alright. Bye. Talks ABOUT How TO present things in a consistent way. Let's like followed the advice of the of this document that we just adopted that we we think is good and and know, make sure these 2 things are unified with respect to, like, terminology notation and stuff like that. you So, like, as a concrete example, how you express, like, scalar multiplication and in the opaque document should be exactly the same as how it's expressed in C PACE. I do not care which one it is. I don't have a strong opinion, but, like, let's just"
  },
  {
    "startTime": "00:54:00",
    "text": "please make sure that they're consistent. So there's 11 feedback that I'm having also to this well, to this original draft regarding the wrap up. because I am having sometimes the impression that we have different perspectives on the intended audience. So some jobs might be really targeting the research community. And others might be are they focusing on on the implementer. And I think but but we might not always have the same understanding of the of the reader audience. And so we have might having different different different focus on different aspect, and this might also to be something for them. This overall an RFC or draft, which describes on how to write up specifications. So to get a more clear picture on on the audience, that we are targeting. I I I think the one of the thing that's in the document is that there are audiences for our document. There's 1st and foremost, they're implementors because that's why we're here to, like, implement things. And then there's also people to who would like security researchers who would look at it to make sure that it's correct and consistent with what's actually been proven. So I I I think that's already in the document. and and like, for my perspective that, like, targeting that audience should be our, like, the the first priority because if we can't specify something in a way that's, like, implement correctly, then we like, we've already lost the game. That's it. Thank you. Chris Patton. I just I just wanted to quickly double check something. You in CPace, we don't actually use the group operation. Is that right? Okay."
  },
  {
    "startTime": "00:56:03",
    "text": "in in in CPaaS, we don't use a group. Yes. We are using just the Scala multiplication and You don't need a a a a full group operation. Yes? Okay. That might be I mean, I don't disagree with Chris Wood, Consistency is is the main thing. But if folks wanted to cut Restreto and decaf, x25.19andx448 would probably be good enough. if we don't need the group operation. And that's what we're currently having as recommended cyber. because it's also one of the the points is that it's it's less overlaps, and it's easier to implement, basically, for very small targets, and that's where CPaaS is coming from because we have a had a cortex m0 with only 1 kilobyte of ram for the crypto operations and what it wants to get good security amps, if you're adding so small targets, them, also, the overhead for research and decaf is apps on some complexity and implement and and codes size. And that's But on the other hand, it's it's much easier for the implementer because you get the the mapping delivered with abstract some layer. And so it's easier easy. If you implement it for PC based or larger system, there's virtually no difference. Cool. I think that's a great place to land. Thanks. Erbanda Faz from Telstra I think I I can volunteer to do, like, a quick revision between getting consistency between opaque and CPAC, And yeah, about the group operation, I think it's the slight differences because you are using"
  },
  {
    "startTime": "00:58:02",
    "text": "operation in the on the x line versus Sinopake doesn't use that. So I can provide feedback to that. Actually, I'm I'm quite Mhmm. they're quite convinced. I'm convinced that also it will take could be implemented without group operations I'm I'm sure. Essentially, you need the same is for the mapping operation, which is the invertibility of the map and the probabilistic and the virtuality of the map. So you could also implement opaque and and using x25519 in unconvinced, but it's not yet right wrote up, and we we cast whether to write a paper on that. but we didn't find the time or didn't focus on that. Yeah. Okay. Yeah. I think that That suggestion reduces to make OPRS on the x line. Okay. Thanks. all right? Thank you very much. K. Then next, we're click update on OPEC. Roberts, So I guess this is already a discussion about OPEC, but I'll kind of go over where we are with the current size of Jostch. I'm Kevin Louie. I'm representing the authors of the opaque Drafts, Next slide. Okay. So I guess for those who are unfamiliar, OPIC is basically a protocol, which takes an OKRF."
  },
  {
    "startTime": "01:00:00",
    "text": "hash function, a memory heart function, and and something called an authenticated key exchange protocol or AKE. and turns that into something called a strong, augmented take. And this is in contrast to c PACE, which does symmetric pakes as opposed to asymmetric or augmented is what they're also called. takes. And as an example, are we have a set of recommendations of configurations, which I recommended, which our blow, and we include Vistretto, That's one of them. This is actually inherited from the peer peer of draft addition to p226. Next slide. So in opaque, there are essentially 2 faces, there is an offline registration phase. where a client you can think of know, similar to when you're registering an account for to to a web server, you enter a password, and you register some credentials with the server. And then there's the online login phase where you then expected to enter the same password. And this is where the authentic k key exchange portion comes in. And for opaque or for this draft, we're specifically focusing on a specific authenticate the exchange called 3dh, And we know because we got some feedback at early on, know that, you know, that in the future, we could support different kinds of AKEs and kind of have limited the scope to focus specifically on 3 d h for for this draft. Next slide. Yeah. So the last time we presented about this was about 2 years ago in IETF 111 And since then, there have been a couple changes that have been made to the drafts. One is that we've made a separation between"
  },
  {
    "startTime": "01:02:01",
    "text": "peer reputation versus the group that is used for the authenticated exchange portion. So previously, we assumed that the this would always be the same group because why would you ever make them different? but we've got some feedback for use cases which prefer to use a different group for AKD. So we kind of supported the flexibility to have these be different groups. And I believe we don't have currently, in our recommending configurations, it's always sees the same group. But but theory, someone could extend it to have the a k group be different. In fact, I think we support yeah. So the the next bullet point is that we test vector support for the AK group, specifically being different from Theatal Care Group, and in those test buckets, I believe, we have the OKROC group being, like, Orstretto, but the AK group being curricio55@19. We're at the key exchange function is x25519. And then another kind of measures change is that In the last IT presentation, we did we talked about the introduction of this this on the lope mode concepts, where we had this class of internal versus external. So internal was, like, normally and In in the OKRF like, you can use the output of the OPRF to derive a secret key that you then used for the AKE portion. that's considered in interval mode. external mode is like, you can bring it in your API private key from somewhere else and just use the opioid of derivation to, like, wrap or, like, add a layer encryption around it. And we've decided to actually get rid of this layer complexity and just focus on focus on supporting internal mode for this draft. and again, with the idea that if there are other implementors who would like to have the external version where you bring in your own API private key, that this would be"
  },
  {
    "startTime": "01:04:04",
    "text": "an extension to the draft and that we've specifically written a draft in a way that allows for this exception. on then some minor changes are, I guess, just keeping them line with, viewer the viewer career of drafts, the latest version since it's at a pendency. and a bunch of editorial improvements, which include clarifying some of the language around the security properties that you can get out of opaque how it's used in practice, things you have to watch out for, and so on and so forth. Next slide. Yeah. So I think at this point, we are We've addressed most of the feedback on the get her page, But, of course, you know, if if if there's any if anyone needs to draft and wants to delete more feedback, we we are usually needed list or the issues on the GitHub page for to kind of talk about that. But at this point, I think we're ready to start a crypto review panel. And, hopefully, we also would like to move towards NRGLC. way. the document, the document, and that's it. Thank you. Any questions for Kevin? any comments on unifying CPACE and opaque from your perspective, Kevin? Have you had a chance to Oh, yeah. In terms of the Yeah. It's been a while since I've last read through it, but I mean, I I I think I I agree with Chris in terms of, like, trying to at least Have the draft read similarly. instead of using, like, you know, different notation for for things, I think that would certainly help."
  },
  {
    "startTime": "01:06:04",
    "text": "Yeah. I I so the the discussion that was following the previous one about, like, support for Australia, for instance. I mean, a little different because we support our show on okay because that's just what's done in the video here. So, like, it would be a little seems like it would be weird to not support it. I don't know If Or I I guess I can't really comment much on the complexity of supporting that for C PACE, but seems like it would be nice, at least from from the implementation perspective to also support Restritto. That's just my personal opinion, I guess. Okay. Thanks. So we still haven't been able to get a hold of Frank Dennis, but you are the name if you I've heard from him. I've sent him an email. We're gonna continue to Joe Harvey. Alright. Good afternoon. I'm Joe Harvey, and I'm here to talk to you about mode or MTL mode signatures. We were looking at this from the perspective with post quantum, impacting many different things. We need to think about can we do things slightly differently, a key agreement? 1st Quantum key agreement, can we do cabins? signatures, what can we do there to make this, you know, use the things we have and make it more efficient. So next slide, please. Right. MTL mode is a it for reducing a signature's operational impact on a expanding message series. What does that mean? Well, there's a bunch of data series like certificates, or DNS sec where you signed a bunch of things. And over time, you add more things to that set, But at the same time, you want to send the the signatures out so that multiple verifiers can later"
  },
  {
    "startTime": "01:08:03",
    "text": "those. It's not necessarily right at the time of signature, but it's sometime in the future. So we need a way to do that and do that efficiently. for the signer, for the verifier, and for the protocols. So how does this work? We create a node set. A node set is essentially a Merkel tree, but it's the complete binary sub trees within that Merkel tree. The root of the Merkel tree will keep evolving, but those binary sub trees are gonna stay the same or slowly evolve as the message share grows. you know, login growth of the tree versus constantly changing. if we take a the leaf node in that tree and trace it up to one of those roots, we have an authentication path we can verify that the message is within a tree. and we have a a root that we can verify against. If we collect all those roots of those sub trees, which we call Rungs and put them together in a set called a ladder, We now can verify all the messages across all the binary subtrees using 1 of the wrong the latter and the authentication tab. So the latter then lets us assign the tree to sign all the routes and use them for verifying our messages. The nice thing is because the trees are evolving slowly. If you have a ladder, you can verify all the stuff that you have now, and you only need to go get be louder if there's a new message that you didn't already have covered in one of your sets. So it gives you a nice kind of backward compatibility. and you only have to go fetch the ladder if you need it for something new. That might sound a little scary. You have to go get the new ladder. but we've done some studies about how much you have to do to go get that. If you look at Bert Kalisky's presentations from this and for the CTRSA, he talks about endurance, which is how often you actually need to go get the matter. And for things like DNS sec, it's actually not as often as you might think Alright. And just to explain why the mode comes from and here, we are thinking about how do you couple these things together differently, kind of like how Block Cyphers had different modes of operation. You had different encryption. You kinda plugged them together in different ways. We're taking different signature schemes. We're aligning them with hashing functions to MTL's hashes"
  },
  {
    "startTime": "01:10:02",
    "text": "for cryptographic separation, and so that's kinda where the thought for mode came from out of this. Next slide, please. Thank you. Alright. So the benefits of MTL Mode, It's a hash based scheme, so it gives us some postquantum safe design. we're evolving a tree there as a state, because the nice thing about this is it's not like stateful hash based signatures where If you lose your state, you could compromise your private keys. In this case, if you have a issue with the state, you might get an additional preimage attack because you might reuse one of your hashes. So it degrades very gracefully instead of being a, you know, security issue losing your private key potentially. The hash functions are available in many different hardware platforms. So from performance standpoint, there's a lot of optimized hardware and libraries that can do the hashing. So if you had a concern about, for example, the floating point math in Falcon, only doing that once in a while when you sign the ladders that haven't do every single message that you wanna sign in the series. The proofs are typically much shorter than the PK signatures. So in our studies, the things we looked at, the signature sizes for the authentication pass were 200 to 400 bytes. in the ballpark of what we can handle today with a lot of different protocols, you know, RSA. others are, you know, a couple of hundred bytes. So the signatures are short. they're easy to store a memory. There is a transfer across the wire, and it's easy for a validate or to check those. And only ever occasionally, do you need to go get the ladder and the sun the pq signature, which is the thousands of bytes. We can also make it them together. If you're signing a couple hundred messages, you can build the notes set all at once. and then sign in the end. So instead of having to sign, a 100 messages, with with a with a post quantum algorithm, you can do the hashes that are fast and do one signature. And that also has a benefit for hybrid signatures where you could sign the latter with multiple things. So you're signing once with multiple algorithms instead of having to do you know, 44 algorithms, a 100 messages, 400 times. Okay. So so it makes it easier for the signer to sign a store."
  },
  {
    "startTime": "01:12:02",
    "text": "it'll it'll potentially fit in UDP packets, like, for DNS, And then also the validators can store these in memory and cache and uses a lot less memory to do that. So some of the benefits of Alright. Next slide, please. Alright. Looking forward to the the guidelines draft. I read through a whole bunch of CFRG drafts. I looked over the Zet and put the together, but those guidelines are helpful, especially for things like the entertain and the the the symbols that you to use and all. So see in this draft, we talk about kind of the general constructs, how to put it together. to use the different elements In sections, 789, we get into the specifics of the bytes, how to arrange it. the algorithms work to to do the different operations. Section 10, talk about how to align it with sphinxplus So we need to ensure that a lot of the signature algorithms hash when they first get the message. need to make sure that the hash is gonna be cryptographically separated from the hashes that are happening in MTL mode. we went through and did that for SphX Plus because they line up nicely together being too to HSA based systems. So that's that's explained in 10? How do you use the PRF? How do you use the different hash functions? Section 11 talks about some related work that's in the area. and also the references section at the end there has a a bunch of the things in the document, but also links to those research papers that I talked about from Burton. Now there's a talk about the security proof's in there. and it talks about the different things like Endurance and how some of it all plugs together. Next slide, please. Alright. Intellectual property. So we do have a declaration for our no obligation about intellectual property. we would like to see we would like to see this become a standard, and we recognize that, you know, we need to to explain the attentions and how we see that. So there's also a blog post as well about this. You can see those documents for specifics or contact information if you have questions about specific elements. and next slide. this"
  },
  {
    "startTime": "01:14:01",
    "text": "Alright? And next steps. So thank you for giving me time to talk today. Thank you for in advance for any feedback you have on the draft. CFRG mailing list is a great place for feedback. But if there's other ways that are good to feedback on this, I would appreciate that input as well. We're working on open source library that will combine MTL mode with SphX Plus So there'll be a a a implementation of it. That will include tests. I know that tests have been a big topic here in the last couple of IETF meetings that I participated in. So, you know, there will be tests in there. They'll give examples that help, you know, verify correct and help validate it. Validate it. We are gonna do a Internet draft on using MTL mode with DNSX, so that'll kind of a use case example of plugging it in. The plan is to take that the DNS op. But, again, if you know of other groups who might be interested, that input would be interesting as And finally, I tried to match the style of the pseudo code as much as I could to other documents, but we actually made the pseudo code in Python so we can validate the doing exactly what we said is doing. If you look in appendix a, we have collected all that together. So, basically, you have a Python version of the high level concept here. appendix b includes stubs for the underlying signatures and Python tests so you can actually see the operations play with it, experiment with it, and see exactly what we're talking about. So if you're a hands on person, you can do that as well. see what's in the draft. So with that. I'm here all week. I'd love to talk to you if you have questions or would like to learn more about it, and I'm happy to take questions. I Mike. Go for it. my gams worth. So I'd I'd comment and then a question. Mike, comment is sort of equally addressed to you and to the authors of the Merkel Tree certificates stuff, for this right there. and the other one's over there. these two drafts sort of superficially look fairly similar. You're batching has to I I I Yeah."
  },
  {
    "startTime": "01:16:01",
    "text": "know that they are different. I would love to understand how they are different. I don't know if we can facilitated discussion on what the similarities and differences and benefits and you know, between these two MTL And MTC. m Yeah. And my question, is I've already put it on list. So I'll just read what I posted on the list earlier has to do with your benefits slide. So I don't it's not sort of immediate clear to me who gets the benefits, whether it's the signer or whether it's the verifier and under what circumstances they get the benefits. Is it only if you're doing large of signatures or only if you're verifying large amounts of signatures, and which IETF protocols in particular sort of work in those modes where they benefits. Okay. So both the signer and the verifier can get benefits. because you're only storing you only have to store the authentication pass and one ladder. So for computing and for storing that in memory, uses a lot less resources to do that. So from a signer side, it's easier to sign once and hash a bunch. From the verifier side, again, you know, being being from Veracy in our perspective, a lot of things is DNS. So, you know, there's already things being cached. If you cache the ladder in your resolver, you're verifying. If you've already checked that signature once, then you only have to take those smaller auth paths and verify them back. You don't have to check the additional signature you've already cashed. So, again, you only have to store the latter ones. You only have to store the 1. So it saves resources and computation both for the signer and for the verifier. So is there a tipping point then after if you verify a single signature, you're taking overhead, but your x you're benefiting? Yeah. So if you look in the the research paper and I can I can I think Bert actually sent something about that on the list. we talk about how many how many times you can verify versus how often you need to fetch collateral. It's the discussion on Endurance. If you look, you can see kind of that benefit of know, there's there's rates involved. Right? Like, how many times you're gonna query versus how many"
  },
  {
    "startTime": "01:18:02",
    "text": "things are published in the meantime. So if you look at those trade offs, you can see some of the the math and the to drive. Okay. And then protocols. So you mentioned DNS sec. Is there other places in IETF that you think this would fit well, well, well, Probably, I mean, as part of the feedback we're looking to to get is where do people see it? fitting well. Hi, Phil Hanbaker. Yeah. I I like this stuff. I've done similar with the data at rest envelope And sequences, It's the way that we should be doing things like distributing software. So you can have a distribution and sign every little file in that distribution including the ones that, you know, be executable for the Mac that you've not got because you're on the Windows box. And so there's a whole host of stuff like that that's really useful. in the other Eric pulls into and, you know, Keytran didn't meet this time, but it's adjacent and they're doing something slightly different. they've got a a log file This is so then They're resigning it. But one of the things that has always struck me about when we get into the first ones and signatures, There's 2 types of signature I'm interested in. One of them is for I have I want to be able to update the code running on this machine. So that if, you know, I I wanna move to the Post Toronto and crypto, that comes out in 10 years' time So that's one area. The other area is non repudiation and signing stuff that somebody's gonna trust a signature in 10 years time. And when we looked at that, you know, 20 years ago,"
  },
  {
    "startTime": "01:20:00",
    "text": "The reason we didn't use blockchain technology wasn't it hadn't been intro invented. Hubro's Donetta and invented it in 1990. Thank you very much. there was a patent on it And it strikes me that if you're going to care about a signature 20 years' time want to verify it in 20 years' time, You probably want to having to notarize signature. So in when you're thinking about this sort of technology, working a way into turning it into a notary scheme or interfacing to a notice scheme is probably also worth doing. Thank you. Watson led from acquiring Technologies. So Rocletree enthusiasts. So I I'm not sure I got a great this understanding of what what you're doing to start the idea. We're signing this root, And then so long as you know as you have a chain somewhere up to somewhere in the root you seen as a client verifying this. you're fine, and maybe down the line, you'll see another signature. that's claiming a chain up with something you haven't seen, and then you go grab the big signature that's sitting off somewhere. Is that more or less it? Yeah. Yeah. So you can verify a set of messages. And if you if it's outside, then message newer than the message, then you need a newer overarching set of the new signature to be able to verify the new stuff. Yeah. So one of the things that I think your awareness is sort certain you work out as we develop the draft more sort of that ultimate signature, you also need to worry about size. If you have a size constraint, other things at being in terms of, like, what the web environment where you have a privacy concern when the browser is going out and fetching something from a third party dependent on the certificates. This Mhmm. That is a problem that would also need to be addressed to apply it there."
  },
  {
    "startTime": "01:22:00",
    "text": "Okay. Thank you. You know? is a Yeah. Joe I'm one of the coauthors on the draft, and I would just encourage people that questions, to reach some of the reference material at the end of the draft and There's some good stuff that covers the DNS sec use case. explains, which is a a very good use case for the for we think for for MTO mode. and you'll see other similar use cases, you know, that there are out there. And I'm gonna and and you'll probably recognize them. And, also, Joe and I will be around this week And because we know it's it's kind of a different model and we're here to explain it to people who wanna learn more. Thank you. all right? Thank you very much. 2. Correct? Alan is can combine us. growth. Yep. Hi. This is a very brief update onto the campaign by the draft. It is draft but combine cans for hybrid photography in the postmortem setting. Next slide, please. So we have done a few changes from 3 that was presented at the last ETF. and we removed the hashing step because this makes it lighter, significantly lighter. we turn around the parameters so that there's"
  },
  {
    "startTime": "01:24:01",
    "text": "the construction can be used as opposed to streaming data. We prefer the K MAC based constructions because they seem to be lighter attend the shaft lead based construction. And we well, teach to the term that I I made up multiple PRF for a more formal sprint sprint tprf. Next slide is So we still have these three issues that are open from the feedback we got privately or on the wrist And first of all, we rely heavily onto the random oracle assumption for catch and we should probably of clarify that better in the draft. then also we should gave some guidance on how to choose the Kmart key. and especially give some default values that do not overflow block size as we been recommended. but we need to understand whether it's it makes sense to keep a default value at all or whether we should just guide implementations how to pick 1. And the last one, it's a bit the most complex one, is whether we can consider HVAC a chart to base constructions given a certain amount of constraints and assumptions that that this this I invite everyone to check out the issues and the repository and and make comments there because I we found a nice paper, but I'm not sure whether it can be actually used. Next slide is So this is the current construction we came up with. we have it it is combined with s p 8 156 c. and that's why it has this this shape. But then the the way we changed it is basically by adding the side effects followed by the length decide for text. Right? condon so that we do not know the length of priority and then followed by the shared secret so we can"
  },
  {
    "startTime": "01:26:00",
    "text": "read the ciphertext as we're passing it to the as we're passing it to the algorithm that will generate this shared secret, and this will Also, we just need to keep the hash state. without having to keep the hold. cythetics around to hash it later. and this can be done for multiple cans And as we decrypt them, one one at a time and followed by some fixed info to this protocol specific. what what what I hope we can try to get adopted after we've been after all this other proposal other RCCs might it may have come out or gone into it's Chris and our thoughts are sealed to project. Any questions? Doesn't look like there are any questions on the list. or questions in the queue. So With that, any other business, we have 2 minutes left. don't have an update from the presenter for Aegis. We this point. The slides are online. and they have a lot of information in them. hopefully, we can get get a hold of the presenter. Okay. Thanks, everyone, and thanks, everyone, for coming."
  },
  {
    "startTime": "01:28:01",
    "text": "Actually, last minute, we do have opportunity. The the presenter just has showed up. last minute. So if folks want to Stay, we can do a quick presentation from Frank. We do. So, hi. I'm fine, Denise. I'm gonna give you an update on edges Just to let you know, we're we're right at the end of the session. And if you want to delay this to next time, that would be that that's something we can do. Otherwise, like, a one minute summary is is sort of what we can squeeze in. Okay. Let's try to do one minute summary. So, Ed, this is a Cypher for high performance p k applications. There's some interesting properties missing from the current standardized ciphers, Cypress, Next slide. So next slide. Yeah. So we addressed all the feedback we received, which was mostly from people writing implementations. we didn't make any breaking changes. So the current version of the document remains compatible with all existing implement and deployments. there's been additional analysis that gives us confidence in the construction and the parameters are currently specified. We just made an incremental addition to add the ability to use larger authentication tags that has particular advantages for some protocols We added guidance on how to use edges in TDS, DTS, and quick. And, you know, as I I notify you also, possible to add edges to this protocol today and clarify that implementations can enter it. Next slide. So there are a bunch of implementations today for all major languages with an independently. So we are quite confident that the draft as it is today contains everything needed to write an implementation from scratch."
  },
  {
    "startTime": "01:30:01",
    "text": "Next. So Edith has also some real world deployments. and it's even supported out of the box by your TMS stack. Next, So edges everything you will on the AS forward run function that a lot of CPUs implemented natively But some more recent CPUs have the ability to do that operation on vectors. So the next revision of the draft is going to specify 2 additional optional variants of edges. specialized for this INCPUs. is not going to require a lot of changes to a draft volumes are built on top of what we already have. and share exactly the same properties. Next. Next. So these new variants are super fast on this specific CPUs that can take advantage of vectorized AES, and Edge is twice as fast when using this vector insolutions. Next. So even on recent alliance CPUs, we 512 Bitters in Victor Richsters, pretty much all VES based on restrictions can take advantage of the new vectors. However, a generic implementation remains faster than the fastest ASG cement implementation today. And if we could take advantage of the large vectors in edges as well, then the performance doubles again. Next, And even the 256 beats variance, of adjacent AS GCN, getting advantage of that. but with edges, the performance triples. So next, the main change that we are expecting in the next revision of the document is the addition of this specialized variants. Otherwise, no major changes are planned. The confusions are unlikely to change."
  },
  {
    "startTime": "01:32:02",
    "text": "and the document should soon be ready for review by the crypto panel. And the HLC. That's it. Okay. Thank you. That was a speedrun and very impressive work. We can do one more question and And and if not, I think we're over time. So thanks everyone for coming. you. like, one category of"
  }
]
