[
  {
    "startTime": "00:00:08",
    "text": "okay there is john john do you want to test your mic okay it's perfect yes perfect thank you okay so i guess since we have an hour we might uh get going um you know more people they'll miss the untrolling first couple of minutes so we do the adventist review so welcome this is the lake meeting at age f-112 my name is stephen farrell and my co-chair is militia so they've got some links if you meet them uh they're not well this is friday of the night effect you've seen this a lot of times you should be aware of it and in addition people you know like to behave well so doing that is good again if you kind of keep an eye on the code you know bear in mind the code of conduct and behave appropriately but i don't think we've had a problem in this group so uh here's our agenda uh minnesota we're in the middle of that um there's a an update on the on the kind of you know the way we want to try and interact with the academic cryptographic community to get kind of analysis done this year we'll cover uh there's the new draft on traces that we had consensus on adopting um i think militia and i are not entirely clear on on what final destination people really want for that in our exact scope so there's a couple questions on that uh and then they will hand over to john for handling issues with the main spec of ed hock and next steps planning whether we want another interim before the holidays etc any agenda bashing uh take that as a no um we have a minute taker thanks timothy and uh in jabber uh myself and militia will keep an eye on"
  },
  {
    "startTime": "00:02:01",
    "text": "that so if you want if you have audio issues uh then you can feel free to type into jabber and we will be able to bring your comment to the microphone okay so with that we'll move on and uh militia over to you i think you're going to share a screen right yes i will so we i'll just give a brief update on this so as we agreed during the last itf meeting we will uh launch a formal call for formal analysis of the specification as it is now in a pretty good shape and we feel confident that it is ready to go uh i've been working with karthik and the co-authors of the ad hoc draft on writing up a letter or like a short paper uh summarizing ad hoc that would be like the first point of entry for people who were not familiar with the ad hoc standardization process mainly targeting uh the the crypto community and uh so essentially this i was hoping to have this published for the today's meetings we received some comments from critique that i wanted to address before putting this online so uh i will just go skim through like what this is all about this is right now like a six page letter uh in ieee format that summarizes the protocol it mainly uh as i said it like it tries in a pedagogical manner to describe the protocol to give a summary of the different uh things that are relevant for security analysis and uh one of the big parts there is essentially the security goals requirements that we agreed on as the first step during the working of the standardization process in lake uh so these are noted here and then so yeah so let me take a step back so essentially the document is split in three parts first one is like the security requirements that we agreed on in the in the requirements draft the"
  },
  {
    "startTime": "00:04:01",
    "text": "second part is the protocol design essentially uh introducing ad hoc to uh the first comers uh this includes some figures on uh the key schedule on the uh parameters that uh constitute an ad hoc cipher suite uh and then how the different constructs in ad hoc are instantiated and how they are defined uh this includes for instance the ad hoc exporter interface the ad hoc key update function etc etc so this is nearly done uh i am uh main i hope to be able to publish this uh on mon beginning next week essentially what is right now pending is uh is a table that we want to uh where we want to summarize essentially translate between the different security goals agreed in the requirements document and then map this to the papers that have already done some formal analysis on the specification uh improved the different properties so it is this table so essentially we reference here the properties that were approved and what we would like to see proven uh during this six month period that we will trigger uh that once we agree that this specification is ready and good to go and then of course there are a bunch of tables summarizing the the algorithms that are used like everything that people can find in one place not to have to go through the different specifications in the itf but obviously the any itf documents have precedence if there are any inconsistencies with the document and the id of specifications but we make every attempt not to be any so that would be it as i said i will uh give it a go and"
  },
  {
    "startTime": "00:06:00",
    "text": "publish this on open archives during the next week and uh send uh send an email essentially to the mailing list uh inviting the formal verification community to uh to start the analysis in the following period and we as i said we are doing this in coordination with karthik who will help us to reach the teams around the world who are who have expertise in this kind of uh studies so that would be it on on my side regarding this uh this item do we have any questions so yeah i guess it's you know it's a good time to jump on the queue if you have questions i i have a couple yes so so i think i think this is great work and it's a really good idea to try and lay it out this way that's friendly for people who want to do the work that's that's really a good idea i guess we should clarify this isn't really this is not a working group consensus document right so we don't need to no we shouldn't think about it that way this is like an invitation to the community to a different exactly do some work right so i i don't think we need to kind of run a call on this or or whatever but on the other hand i think it would be useful to get you know to be open to modifying producing a second version of it if there are comments from the working group uh yeah so my goal is essentially uh yeah i will put this online or like next week hopefully like monday tuesday and then i mean we can this will be published in open archives for the time being uh we can just like iterate and great yeah so so i i think that's perfect so so if we yeah if you guys uh finish this open i think it's a great piece of work and i've got a really good idea and then maybe invite people to comment on it and issue updates as as clarifications are needed or whatever that would be super cool um so my second question was you said six months how do we know that that's the the right period so this is something we discussed i think during one of the previous itf meetings uh well i mean this was like"
  },
  {
    "startTime": "00:08:02",
    "text": "yeah we came up with six months as a period where yeah it is enough time but yeah again again if if people if working group participants have opinions on that i think it'd be really good to hear them or if there are you know if there's a workshop at a particular point in time that it's important to try and get feedback from and that's you know six and a half months or three months that's useful information to have um so uh i mean i guess as chairs we probably will put this out there and and the suggestion is that we'll kind of you know wait six months to see what happens uh as a default hopefully something happens and then we don't have to we can stop waiting but uh yeah so i hope to get from critique some like really actionable feedback from the different teams if anyone has will start working on this and as we will try to reach out to specifically to the different individuals yeah great so yeah like and ben says in the chat that you know tls and mls have done that before so that's that's fine those are my two questions but again fantastic idea and good work john six months is like uh first shot then we before this the document processes we always have to have a discussion so if if the working group thinks something is worth waiting for or not we can decide that later okay so everybody seems happy with six months uh i assume everybody is happy with it with the idea of this document it seems obviously a good idea to me anyway if anybody has any comments uh now's a good time before we move on okay so we look forward to seeing the link to that militia when you're when you think it's ready and then people can comment on us and and off it'll go into the world sounds good it's kind of you again on the next agenda items though so yes the next agenda item is on the"
  },
  {
    "startTime": "00:10:03",
    "text": "draft traces i suppose so let me just see okay do you want to share or should i uh ted i already see it's loading yeah okay good uh that was me loading it then okay okay there we go there you go yeah okay yeah so this is just like a brief wrap up of the adoption call we had on draft traces steven can you go to the next slide uh so we launched uh the working group adoption call and on 18th of october for two weeks after the initial agreement during the last interim we got feedback from uh three implement uh so essentially from marco stefan sean uh and john who is also a co-author general feedback we received is that uh people support adoption there is there were no opinions uh that this should not be adopted and people support the publication as an informational rfc uh there was one uh remark brought up by sean who would uh who stressed that we really want to ensure correctness of this specification which uh really makes sense by verifying the test vectors that are that are uh presented there with multiple implementations then one thing that is not really clear yet is on the scope of the document so i i discuss this more in the next slide uh so currently the scope of the draft is essentially the uh draft covers methods uh signature signature and static static with cipher suit 0 which is the"
  },
  {
    "startTime": "00:12:01",
    "text": "x25519 based suit suite there was interest expressed for the nest curve p256 uh we uh i think marco and stefan uh raised interest around having test vectors on cypher suites two and three specifically so what we would like to hear now from the working group is what are your opinions on this i mean first if you object to this document being published as an rfc and then second what are your thoughts on the exact scope should we be exhaustive and cover each method with all the cipher suites that are defined so essentially we select a set of cipher suites like for instance uh zero and then two which would cover the nist curve and the edwards curve or just be selective and do with the different methods uh like as john proposed on the email mailing list so yeah we are really looking to for your feedback here do we have any comments on this so i so timothy yes so i don't we will still have uh like a github page where we have a lot of other test factors and i i don't think we should be exhaustive and in the draft and just have them um as additional support and then on the github page we can have much more test factors and be much more exhaustive but it would be difficult to have an exhaustive list of all the combinations in the drafts"
  },
  {
    "startTime": "00:14:01",
    "text": "yeah so i mean to be clear i mean i was not implying that we should have like all the cipher suites just yeah no no no yeah so this is just but it's uh i think i heard this comment during the last uh interim and i i can't remember who said it but it's difficult to decide like where to stop of course this could be the discussion we're having right now is what should we include and whatnot so specifically which cypher suits and methods would you like to see there i think i would have all methods and maybe cipher sweet 0 and 2. okay all methods but does that mean each method which both ciphers with zero and two yeah okay so okay okay let's have that in the minutes then do we have any other opinions john my idea would be that they have a lot of test vectors basically no limitation in json format on github and then my proposal would be to select quite few for the drafts with a lot of explanations i think if you want to check your implementation against something you probably do that with a json-based test vector if you want to understand more about why things are like there is and walk through test vectors then you look at the draft so i think beyond like two three traces i think there's you don't get increased understanding if with the uh with the explanations in the draw so i think for correctness case i would say two to three traces and focus on making this correct"
  },
  {
    "startTime": "00:16:00",
    "text": "there's a lot of work built to write more traces and also to check them so yeah i mean and it also reflects that the comments in jabber there so that you know that sounds like a plan that people are happy with um i guess the action would be to create a place in github for traces to be posted and then to at some point select from those to which goes into the draft [Music] stephen that there are already test factors in in github um oh okay sorry pardon me some of them some of them are in the traces okay so so we're inviting people to submit prs uh with with new ones is that right yes we actually have a new contributor um who's going to do cypher sweet two and three um and we'd also be becoming a new co-author of the tracy's draft great so that's marek sirafin from assam block good stuff marco i see you're in the queue yeah hi uh for the draft i personally find ideal a compromise between what timothy said basically and what is in the slide now as as selective so basically methods zero and three for both ciphers with zero and two but yeah just my preference and i'm just reiterating what i wrote to the list a few weeks ago but do you mark okay yeah mark would you like to see also methods one or two one and two i think zero and three can be sufficient at least for me i can understand someone hoping for them too"
  },
  {
    "startTime": "00:18:03",
    "text": "okay so let's continue this discussion on the mailing list okay let's uh let's take an action on on making a concrete proposal based on this input and then get back to the main list with that great okay uh we're we're only a couple of minutes behind time so that's that's pretty good um so i think we're we're ready to move on to the next agenda which is john i guess uh so john if do you want to hit the share slides button uh so if you hit the the the piece of paper thing to the left of the join the cue button at the right is joining the q button then we can give you permission just to control the slide deck yourself i have already asked for others i see that there you go so okay so you're running the show yeah so these are the next three items on the agenda status open issues and also reduce uh thanks ben so this we have five minutes for the state to see us going through that quite quickly all the changes from series 8 to 11 was already discussed at the interim uh it was we made an effort to do try to do all the all technical changes until 11 so we could have up-to-date test factors that we can implement uh so there's changes to the key derivation made a lot of simplification also fixes um then some changes and simplifications to the negotiation of cypher suites added the mac length to the ciphers"
  },
  {
    "startTime": "00:20:02",
    "text": "instead of relying on the siphon aad we made this combination of the d y and ciphertext2 to match this to meet this 45 byte requirement [Music] cwt and ccs was added support for these they are named k cvt and kccs to indicate that these are cyborg web token and symbol claims that with a key inside them uh they work like certificates main changes to the ead type there was quite a lot of restructuring and then quite a lot of fixes so then 11 to 12 this was or has been done after the interim uh there's basically clarifications there's no technical changes that affect the test vectors so the codes cosi has sender parameters we added a clarification that because it does not use this or i don't remember but the exact language but when you use the header parameters in ad hoc they always identify the sender then there was a discussion of pqc so it was added a clarification to the document that pqc chems could be added later to method 0. [Music] no technical change this cannot be used straight away at the moment then the clarification that all"
  },
  {
    "startTime": "00:22:00",
    "text": "cozy signatures are supported um the current plan is that the adhoc supports all signatures from cosi that includes hash based rsa and wall not not i don't know if anybody wants to use them but they the plan is to support the whole future there's some clarification about cypher c suite we made updates to the mti section it was based on the discussion in the year in the interim uh basically must support kid for the other parameters that was to do we just added that it's up to the implementation to support uh whatever they want this aligns with the other parameters of this type um then the cozy processing was moved to an appendix to shorten the body and then there's some internal references that was fixed um any questions on this status how do we why do we move to issues yeah no hands uh then according to the agenda we have 50 minutes four issues i think there's 12 left so this is a short list of all the open issues um excluding test vectors and the reviews we have done some minor cryptographic explanations mainly in by this paper we wrote that malaysia presented and also some comments from implementers clarify that the it is actually a technical change the mac must be at least eight bytes um"
  },
  {
    "startTime": "00:24:02",
    "text": "clarified where compact representation is used uh other clarification that the norms also provide a binding between the kt update and the message that triggered the key update or it can do that and then an explanation why ad hoc is not using a running hash and the reason for that is that that's not supported on many constrained platforms a new issue on adding privacy consideration based on the model t discussions and the link here is documented by yellow article and stephen farrell this would not be any technical exchanges but considerations that if you use the same sort of get to several servers or clients they can work together and see that you connected to all of them um then in issue 193 question about adding hp e algorithm for method 0 as i said there was a clarification that this could be done later after that there is a new draft in cosi that adds hpk e uh algorithms there's discussion in cosy whether this will just register as subset of algorithms or if it will support all future hpk algorithms and also discussion whether this is the way to do key derivation in cosi in the future or if it's one way to do key iteration in the future i think the only reason to do this now would be if cool c already now decides that hpke is how we will use pqc chems in the future then it would be worth adding and this would not be"
  },
  {
    "startTime": "00:26:00",
    "text": "it will not change any of the current methods or test vectors it would be gx and gy you would put a different byte string in these when you use a pqc chem but currently that is not specified that will require some some new draft in the future that's probably the best thing to do with the new cypher suit [Music] then the information about non-repudiation was wrong said that you needed to save the thermal key that's not true you can save all the input to the signature function and then you can prove that the other party um took part in the protocol this is similar to i i think as the the information is encrypted in ad hoc in tls 102 the thing the signature is i don't in some protocols you can prove it by just looking at the information on the wire in ad hoc the other part needs to save things it's not visible from the wire and then we have an issue about optimal padding that's blue because i have a separate slide on that 186 is a discussion about the ead internal structure um and the api this was based from comments from implementers where this seaboard encoding should be done and how um and also a bit unclear still how other protocols will will use the ead interface uh my reflection for this discussion is that we probably need to specify it as"
  },
  {
    "startTime": "00:28:01",
    "text": "we cannot have any we need to specify as a byte string to make sure that the data is correct cyborg it does not affect the security of adhoc as such but you could imagine that some other application assumes that it actually is correct seaborn and then it should be um but i think this this needs more discussion and then there is security consideration for two fiances that done in ad hoc or in cosi and too many words there is regarding compact representation there's a draft in cfrg that suggests that for hpke um don said he didn't get any did not get positive feedback for that i wasn't there when he presented but i sent the mail to cfrg asking if there was any need to do any alignment um if see if audrey thinks so i guess we will do that otherwise probably not um then we have effect of limited randomness there joran has made a pr and it's a very short period that's a reference to an appendix in oscor as discussed in the interim see that we have uh here's a slide about optimal padding the issue here is that uh ad hoc security consideration so privacy consideration doesn't currently does not say that adhoc reveals the length of your identity and also the length of ead i mean and"
  },
  {
    "startTime": "00:30:03",
    "text": "190 that adds security consideration for this and it also had a padding mechanism tls and i cast padding mechanisms for this uh unclear how much they are used but my proposal would be that we add this as an optional feature you don't have to implement it if you don't want but we can and padding would not be needed for several of the identities you can choose a fixed length identifier instead uh but i think this is a useful feature to have and it doesn't affect anything else if you don't implement it you can ignore it would be any comments on this before we move on to test vectors [Music] resolutions for most of these um what's the best way to close a bunch of them that we think are ready to close just maybe send one mail to the list with a you know listing all of the issues you propose to close and then just giving a giving people a few days then going ahead and doing it yeah okay so so i think that's the plan so at the point do you think it's it's best to do that in the next short while if you send a mail to the list then say you know issue blah propose resolution close and so on yeah people a few days don't forget and do it yeah so if you have any comments on any of these issues please um please be active on github or send an email to the list of course"
  },
  {
    "startTime": "00:32:00",
    "text": "good then there's issues about test factors i think these we have already discussed earlier in the meetings at least 167 the content of the traces document 188 is an issue about um it says missing suits are but what is proposed is to have a list of supported the cipher suites both in the initiator and the responder um this would be something different suits eye and suits are only have meaning in the actual messages they might be they they might be truncated from the full list of supported ciphers um i haven't we it's not completely trivial we had this before but that then that led to confusion also but now we have simplified the discipleship negotiation so it's simply more straightforward it's probably worth giving this um shot again and add such a list another consideration is whether we should add test vectors for a message flow with an error so message one and then an error i don't uh support i don't i support a better cipher suit and then message one two three again that would probably be useful but it's also work of course but um that would probably be good to do yeah uh thunder suggestion to have a table of content in the test vector uh"
  },
  {
    "startTime": "00:34:00",
    "text": "document i don't know if it was for the traces or but it should definitely be there for the json test vectors there's there are i don't know um probably more than 10 test vectors and there's no information what what's in them so it unless you look at the source code so there are a table illustrating that what is definitely very needed and i think we will add that and there is more sweets i think we already discussed i think everybody agrees at least that we should have the p256 ecdsa yeah and that's ongoing there's all there is uh test vectors coming very soon for that um i think that's this is the general issue about test vectors editions 12 of the twenty ten of the twelve things are done here might need to update this but you should also have the real certificates right now they're just a sequence zero one two three four five uh they should definitely be a real certificate with real public and private key that you can test this will also be added quite soon i hope in the coming months any questions about the issues or comments before we move on to reviews i think we are just on time [Music] uh so at the i think it was at the interim uh there was a request from the cheers and also from the authors that to get people to review the document because we feel that we are"
  },
  {
    "startTime": "00:36:00",
    "text": "getting closer at least to the finish line yeah and we have gotten four reviews that's excellent and all the the four reviews has been added as their own issues in github so it's easier to see and discuss them i think the plan is to fix all the editorial issues in them and then if some and as much um technical things also and if something we need more discussion let me open a new issue for that topic and maybe close the general big thanks to everybody that has reviewed i think the comments are general positive quite a lot of small editorial things and and some technical so these discussions are only the bigger technical things that or might be worth discussing um marco is not here because i think all his comments were more editorial i think a lot of them has already been addressed so comments by stefan [Music] ead who is supposed to encode the code erd application or implementation um and my high level answer right now i think i think the api needs to be changed i think it needs to be in them by string and then they probably the ad hoc application do a simple encoding of the int and the byte string but in the under i think the ad hoc specification should not um not specify exactly how this api looks like that's up for the application might look a bit different in different programming languages and so on"
  },
  {
    "startTime": "00:38:04",
    "text": "uh then error handling steve asked why a success error is needed he doesn't see a useful one and he says he does a lot of logging but it doesn't have eq so success was some suggestion from iot ops i think that was one of the clearest suggestion they had i think if you don't want to use the success or don't want to implement the success it's optional to implement also so i think if you don't want to use it you don't have to but it was a strong suggestion from iot ops my suggestion should be that we keep it in as optional um i don't really have any answer on when or exactly how you would want to use it then mandatory um mti cipher suite this we have discussed and agreed to discuss later uh steve found suggest that we should change the text from zero and two to zero slash one and two slash three he doesn't think it makes sense to make a difference between the truncated ccm and the full ccm that's the only difference between these episodes i think we can discuss that when we discuss the mandatory to implement cypher suit sweet question later um that we said we do when we have a working group that's called and more question comments from stefan about the revocation [Music] uh and then it's should what you should"
  },
  {
    "startTime": "00:40:02",
    "text": "do here and what you can do and um i think current answer is that airtalk doesn't give much guidance regarding this you can use if you use x509 you can use crl and you can use ucsb you cannot use ucsb stapling because it does not support ocsp stapling at the moment if somebody wants ucsb stapling and that was for example suggested by dkg during the cozy meeting that that might be a good idea to have it mass staple uh then we would either have to introduce it in cosi or in in ad hoc would be possible but you need to have some standardized way of transporting the ocsp information uh comments by kathleen um so kathleen discusses comments on the i anna considerations and she asks what documentation is required and if we should also have specification required um this we discussed that in the ream i think it was happy but i don't think there was a lot of comments so this might if i think if people think we should have specification required instead do that otherwise there might be a need here to explain what the documentation is required to more guidance to the experts"
  },
  {
    "startTime": "00:42:08",
    "text": "and are there any questions in the chat i have not been following that i guess you tell me if there is uh some discussion about uh p256 versus two five five or nine and i guess the upshot hopefully is that uh i don't know dkj if you want to speak to it now that's probably a good good moment if you can send audio hi there i think i can send audio um yeah i was just uh suggesting that having too many options leaves implementers in a position of having to make decisions that they generally don't know how to make so the clearer we can give guidance the better it sounds from the discussion on the chat that the um strongest reason for including p2v6 and ecdsa is hardware implementations or constrained devices that want to you know they have that have a hardware constraint um and so maybe we could just add some guidance to the document that says you know use 255.19 unless pre-existing hardware constraints force you into using um ecdsa or something like that just as a way to you know the more guidance we can give to implementers so that they don't feel like they're making choices they don't understand the better and having having you know a clear reason to choose one of the others is the right way to go yeah i think there are already something something similar to what you suggest that was suggested by stephen farrell uh but i think some some more guidance might be good might also be it might also be good to give some more explanation what what the difference between different options would be"
  },
  {
    "startTime": "00:44:03",
    "text": "yeah a guidance that explains the difference is fine but guidance that just tells a lazy implementer what to do is probably better because we're the folks in this group are going to understand the situation better than the average implementer i think that would be some default choices if you're lazy would be a good addition i think let's try to add that um so moving on to steven's comments so first connection identifiers um and stephen uh as that you might be able to track a client if you look at this and he asked whether they could be derived in another way and if this has been considered and this has been considered i think we have an earlier version of the draft degenerate these in a random way but then you also need to have a much longer due to collisions um so it has that was moved right now it's up to the clients initiator and responder to choose them in any way um that party so you you can implement any way but they're not hidden in any way they're sending clear text and you want to add anything stephen yeah um and again i'm not entirely sure what the potential value here might be because connection identifiers could be a connection could be obvious uh to somebody looking at the traffic anyway um"
  },
  {
    "startTime": "00:46:00",
    "text": "you know we do have the issue with threats like if you have a a light switch that's activated when a person enters a room just being able to detect that the packet comes in that light switch is probably revealing regardless of any encryption and if my concern is that these connection identifiers if they kind of leak over to something else into other protocols like um and if there's some kind of proxying going on or multiplexing then these these could allow that kind of attack to happen if somebody only has visibility of the link where the multiplex packets from many switches for example are being sent so yeah i'm not sure if if doing better with connection identifiers in ad hoc would enable a good solution for that or would be window dressing um but it's i think it's a concern if you can you know if you can just correlate the the key exchange with the with all the later packets um that's that'll label some trend yeah right now the idea is to use the same identifier in ad hoc as in scores you would be able to see that this it's the same client sending these things um typically you would be able to do that anyway from the lower layers um i don't know two options here maybe they're more guidance or considerations to add and maybe there's something smart we can do technically it would be happy to see any contribution on that but i yeah and i get i think the answer probably also depends on how likely we think a configuration would be where changing makes a difference"
  },
  {
    "startTime": "00:48:00",
    "text": "so as you say if you can always tell from a mac address which which packets come from which light switch yeah changing the connection id wouldn't make much difference but if we do think that links uh on which most packets will be multiplexed from many devices will be you know will be common then the connection identifier would be what's allowing an attacker to identify the traffic as being from one specific source yeah and that seemed undesirable but yeah but i personally i just don't know what the common uh topologies for deployments might be like no i think i guess a common deployment would be that you it's very visible and you don't really change who you talk to and you you stay in the home where you were deployed or the industry where you were deployed but it might not be i think i think there's definitely would be good with some more consideration to spell out that if you use the same connection identifier in different places for example you can be tracked and then a simple solution would be to run adhoc again if you change uh like if you change your access network for example um and negotiate a new connection identifier and you cannot then you cannot trace the client between these two networks yeah i i that that's true and definitely worth pointing out i guess though i have heard a number of times people saying that they only want to do the expensive protocol like ad hoc very rarely um and that might be just when you unbox a device or after a power cut or"
  },
  {
    "startTime": "00:50:00",
    "text": "something um so it's a concern uh again maybe if it doesn't if it doesn't resonate with people that's fine um if people think it's it's worth addressing one way or another that's also fine but i mean i i suppose the other argument i'd make for trying to think about this now is that it's not something that we'd find easy to change if we decided we wanted something else later i think that's true right yeah yeah so yeah so um i think for now at least consideration and then i don't know it would be very happy if somebody have some if you have some ideas technically how to make things better please be active on github um yeah i i think that's fair um yeah personally i mean i think what i was when i was looking at this i thought you could maybe come up with a scheme where you send an identifier at the end in message in the first message um and then derive have a way of deriving a more stable identifier from that but that you only need this visible identifier in one single message and the rest of them could be derived um i think it should be possible to do it but yes uh having a concrete proposal seems an entirely reasonable request yeah it's definitely possible i guess it's very simple is to drive something long and random it will not collide with anything if you want something shorter it probably requires some more thinking um right and without consuming more bites in the in the in the original handshake pretty much yeah so there's yeah i i i'll have a look and but if other folks were willing to have make a concrete proposal if they also have this concern and that would be great yeah sounds great"
  },
  {
    "startTime": "00:52:00",
    "text": "uh then terminology stephen asked if cdl or english language is normative there's a mixture i think the answer is that the problem needs to be a mixture i think but it's not clear i think it needs some clarification i think all the cddl is normative but yes the cddl is not enough you need some normative english text to tell you the details of how the fields inside cddl is structured not some things you could do with more cddl but i don't think you can get away with only cdl and it would make the cdl very much more complex and hard to understand also but i think that the cdl is what is normative clarification of what is normative is probably missing uh then more comments by stephen um comments if do we really need to support has base things um we talked about that before uh i my my idea would be that we support everything that courses approach a doctor and also support for example walnut dsa which is not recommended and rsa which would be very large but the hash base will also be large i guess the change in the recent version is that those questions are pqc and we added a note that hash basics can be used um do you have any comments i think yeah i agree with you that they're unlikely to be interesting but they do have a different property of being stateful that you you only get so many"
  },
  {
    "startTime": "00:54:00",
    "text": "signatures and in the context of you know long-lived devices that um if some device is long-lived and does ad hoc frequently then you might run into an issue but it seems unlikely but it also seems a bit unrealistic to claim it's really supportive ben you're the cube i just wanted to respond to one of the things that john said live which was i think that we sort of assumed that ad hoc is going to support everything that cosi supports and i'm not sure we should make that assumption like from the cozy perspective at least my understanding is that uh when you have an application that uses cozy uh you're sort of assumed like the cozy authors are sort of assuming that your application will be profiling things down and that there may be some algorithms and cozy that just don't make sense for you and so we probably don't want to assume that anything that has a code point in cosi is going to make sense for ad hoc that's a slightly different question from the specific question of whether or not hash based sigs may question make sense for ad hoc but i just wanted to toss that out there that we probably do want to filter what's available from cozy down to what makes sense for ad hoc yeah i think it's hard to filter out there's one thing to filter what is currently specified without specif filtering out future algorithms that would make sense to support that's that's true yeah so we have to be careful about how we write this sort of guidance to be future compatible thanks [Music] then it's seven discussion about"
  },
  {
    "startTime": "00:56:01",
    "text": "using kdf to derive public output i think that should should be added a consideration regarding that i think nist is has very strict rules regarding this but i also see in a paper by krakchuk where he says that very much complains about this nist requirement and says it doesn't make any sense unless nist have very very low trust in their cryptographic constructions but i think i think it depends on how much public information you derive having some considerations on this could be good along the line that steven suggests might make even more sense for the extra where you might export much more material and it's unclear how you use them i think that was the last slide i think i'm out of time also great thanks uh i don't know militia i think it was having some audio issues i'm not sure if this are they sorted or uh it should be good now it's yeah that's working there okay yeah um sorry about that but yeah thank you john so uh we only have three minutes to go so let's maybe just briefly discuss the next step stephen uh and i guess having an interim uh in the next couple of weeks before the christmas holidays would make sense to does the group have opinion on this well yeah so so that i think opinions of that would be welcome also but i'm assuming the answer will probably be yes because people always like interims uh but i think also to be useful to get opinions from those who are not authors about whether they think we should begin to think about working group last call because i know the authors are keen"
  },
  {
    "startTime": "00:58:01",
    "text": "that we start doing it on that line and so i'd be keen to have um input from from other participants on the now are on the working group list um as to where they think we should be heading towards working with glass calls soon because we are getting close i think so and based on the reviews that we received it seemed as we could do such a thing right i mean we we did not receive only editorial issues but not only substantial changes sure but now we yeah we did have to ring promises to do reviews out of people at the last interim though so we we kind of said he forced him a bit but that's okay um again if there's other people who are not who haven't expressed an opinion yet about how close they think we should be to the working robust call that would be useful input i know the authors and the team essentially behind that uh are keen that we start a working blast call soon so if you have opinions now's a good time or on the mailing list if you if now it's not a good time for you people don't seem to be joining the queue there is euron you're on good um no i don't have a strong opinion here i i think that this is great that we got these reviews um thank you very much everyone for for contributing and we have a good had a good discussion today i think um i i would imagine that this this would trigger even more abuse if we do the working group last call in uh uh january or yeah something like that so that would be a way of pending the uh did the potential crypto reviews or i mean we know that there will be some crypto reviews coming up uh to get some input in the in the meanwhile which probably won't be overlapping with the crypto review i think if we ask"
  },
  {
    "startTime": "01:00:01",
    "text": "yeah and i mean if there's if we assume that other cryptographers are going to spend effort on this we kind of owe it to them not to keep changing the thing during that period um so that's another reason to have a relatively stable for that period um so i like the way you implicitly suggested we did working through class call in january so that was nicely snuck in there and so and you know i'm guessing that that's the kind of thing that seems to make sense if we have an interim before the holidays try and tie down to as few open issues as possible and then kick off a working group last call that would seem to me like a sensible plan and but uh we could do you know we'd be happy to get uh comments and input on that i guess we're out of time uh so send those comments to the list uh unless you want to jump into the jabber room where it'll still be recorded thanks for your time uh well i guess we'll schedule an interim for some time in early mid december but we'll discuss some of this thank you all thank you all and thanks to timothy for taking good notes that's great you"
  }
]
