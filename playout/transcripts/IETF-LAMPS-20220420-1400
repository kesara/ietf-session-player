[
  {
    "startTime": "00:00:09",
    "text": "hello everyone it's uh time to get started i'm struggling with uh how to upload slides for the interim and uh and now getting help by jabber from from robert but uh the agenda is available in text form people can see that if you click on the meeting materials so i'd like to go through that this"
  },
  {
    "startTime": "00:02:18",
    "text": "okay finally success um so the um sorry for the the wasted few minutes there we have a pretty full agenda but we need to start as always with the note well the uh please if you're going to contribute make sure you understand your responsibilities under the new well this is the agenda and it's not the agenda how did that happen i'll fix that in a minute this is the agenda so apparently the first half of the agenda from uh itf 113 was on that slide but this is today's agenda and so um the slides for all of these are posted under ietf113 i will copy them over now but sean if you can i think you're the one who's going to talk is that right sean here we do not have sean okay is somebody else going to gonna gonna talk about the kem certificates okay"
  },
  {
    "startTime": "00:04:00",
    "text": "ludwig you want to start uh i'll get your slides up in just a moment so it's uh julia pratt which is going to give the talk yes absolutely so um okay so should i start or yeah i'm uploading the slides okay okay"
  },
  {
    "startTime": "00:06:14",
    "text": "hopefully you're seeing slides yes great okay thanks and i will uh upload the other decks uh now as well so while you're talking okay okay so uh hello everybody uh so i'm pretty new to this group so uh first let me introduce myself i'm julia pratt uh from kryptonite security uh and so we um with ludovic pereira from crypto next and nikon swerf we wrote this draft rfc to propose a solution to use the post quantum cam in the cms so yes if you can switch to next slide please oh yes it's the the the summary of the presentation so maybe we can switch to next slide so uh yes as i said the uh purpose of this rfc is to present a solution to allow the use of encapsulation mechanism uh within the cryptographic message synthetic syntax so the issue here is [Music] is relies on the on the the specification of the key encapsulation mechanism because"
  },
  {
    "startTime": "00:08:00",
    "text": "according to the specification and especially especially according to the sterilization process currently uh ongoing at nist level a key encapsulation mechanism generates a session key randomly which is an issue in the cms context because the general use case for cms encryption is to randomly generate a sec a content encryption key and then to encrypt this key with an s with a an asymmetric algorithm and this uh sec is used to encrypt the data to be protected so here's the issue that the current chem well don't allow this kind of things so we will try to propose a scheme to uh to follow this i mean to trans to transmit a content encryption key which has a fixed value so then for this scheme we've tried to set some requirements so here i mentioned the main the two main requirements the first one is that the keytransport mechanism should be secure against quantum computers and then then that's what i said the key transport mechanism should be able to take the content encryption key as input so that's the reason why we defined this chem trans mechanism which is basically an adaptation of the already existing rsa cam coming from the rfc if i remember well 5652 so"
  },
  {
    "startTime": "00:10:00",
    "text": "next slide please so yes just to as a reminder um here we remind the what a key encapsulation mechanism is so it's a cryptographic algorithm allowing secret sharing and it consists of three functions a key generation mechanism an encapsulation function and encapsulation function and as i said previously the the problem comes from the encapsulation function which outputs a random shared secret and then it's impossible to encrypt a fixed content encryption key with with a with a cam as defined here so next slide please thank you uh then so yes uh the the wall mechanism will actually be a combination of uh three algorithms so first a cam a key encapsulation mechanism then a kdf so here we remind what uh exactly is a kdf so it consists of only one function uh taking as input a data and a size and outputting well new data of the size defined as input and the next algorithm that we will need is the wrap algorithm which is defined on next slide here thank you so yes the the wrapping algorithm uh it's so it's basically a symmetric cryptographic algorithm protecting data in confidentiality and in integrity and it will consist of two functions"
  },
  {
    "startTime": "00:12:02",
    "text": "wrap functions and non-wrap functions making the invert operation so next slide please so the the wall mechanism is defined in this slide so it's what we named the chem trans mechanism so which is the combination of the free previous algorithm that we that we just saw so the well the mechanism is here so it's really an adaptation generalization of the rsa cam algorithm and thanks to this mechanism well we will allow the transport of the king data anything that data actually so including the cms content encryption key and we will be able to make this mechanism quantum safe by using actually a chem algorithm a quantum safe cam algorithm so this will make us well using a cam quantum safe algorithm will make the wall mechanism can trans quantum safe so that's it for the description of the mechanism and next slide please thank you so uh after defining the meccan is a cryptographic mechanism then some fields in the cms have to be clarified regarding this new mechanism especially"
  },
  {
    "startTime": "00:14:00",
    "text": "so the recipient info type in cms must be set to uh quitting quick trends recipient info and the following values have to be set i mean the algorithm must be id cam trans oid so it's a new it's a an introduction of a new oid for the the sorry the game trans mechanism and then the different sub algorithm will be defined thanks to a value of type generic hybrid parameters and then next convention uh is about the certificate convention uh and so uh in the certificate we will make mandatory the key usage extension that should be set to key and cipherman and also the subject public infor of course should be a short match with the [Music] the k the or id of the the cam so that that will be a quantum safe or even a regular uh a classical game so that's it for the for what the rfc introduces and then there are still open points to be discussed uh regarding this new mechanism so there are those points are on the next slide thank you so still so there are still some open points to be discussed uh but"
  },
  {
    "startTime": "00:16:00",
    "text": "mainly minor points so the first point is maybe the the the way to communicate uh info about the key trance mechanism uh which is used so it can be used as we propose in this rfc thanks to the key trance recipient info as it is done currently in the rec game but it could be also done by introducing a new top level recipient m4 called chem recipient info for instance or as well we could use the existing over recipient info and define an instance of this over recipient info as a camera recipient info and then the other open points are about the certificate conventions so maybe that will be [Music] discussed in the shen rfc maybe and the other points are so obviously the new ideas to be defined uh so we have two types of id that should be defined the idea of the cam transport mechanism and also of course the cam algorithm the new quantum safe cam algorithms and then the last point is about the algorithm limitations so as i said all the free sub algorithm kmkdf and rap can be chosen can be chosen so do we want to limit the algorithm to the quantum safe for instance cam or do we want to enhance the possibilities to also support legacy algorithm so maybe it's"
  },
  {
    "startTime": "00:18:02",
    "text": "what we can discuss here and so if you have some view on that we will be pleased to to discuss this so maybe that's it for this presentation before i open the queue because i was struggling with the slides i failed to recruit a note taker do i have a volunteer who can do that in the in the tool before the discussion of these slides begins somebody do that for us please tim are you in a spot where you could do that not easily foreign something strange really just happened um i don't know what's going on my guess is that medico is trying to"
  },
  {
    "startTime": "00:20:00",
    "text": "help us with the chat room and something was just reset russ this is jonathan i i can log into hedge doc to take notes thank you very much that would be a huge help okay let me put slides back up and i think the one that people will most likely have questions about thank you very much jonathan and mike you have a question audio test audio test you hear me we could hear you but not well it sounds you're you're very distant perfect uh okay ah here we go i put my i put my hand up uh when you asked if someone wanted to talk about sean's draft oh i'm sorry i didn't see it at all uh we'll come we'll just swap the order then i'll have you uh up next sure um yeah i don't have any comment about this one i think the the chem stuff is pretty good and straightforward well done okay uh yuri all right uh i completely agree regarding chem i see it as an extra overhead using wrap in fact it is trivially simple to extend chem into something that sends a pre-generated key"
  },
  {
    "startTime": "00:22:02",
    "text": "i i'm not sure what's the best way for me to explain how and whether this is the right time and place to do so but it would require instead of a whole key wrap one xor operation on the sender side and one xor operation on the receiver side and uh sending over the wire can you sketch that for us i mean you're saying um i can't i'm arbitrary yes yes i i certainly can i'm just not sure uh how to best do it here with the with the tools available basically over the wire it's another bit or byte string of the size of the either shared secret or desired target shared key and operation wise xor on each side and of course the sending side would have to generate the key itself that it wants to share would you like me to to post it later to the mailing list or uh struggle in attempt to maybe uh present it here um if you can quickly put together uh a slide uh during the next talk i can post it and we can come back to this topic understood thank you"
  },
  {
    "startTime": "00:24:00",
    "text": "[Music] uh email it to me uh mike got it so if i i think what he's going to present what yuri's going to present is basically an xor wrap but you still need to choose a kdf question mark um the the thing to be careful of here is we do not have a guarantee that chems produce a whitened shared secret i.e like rsa chem may have group theoretic structure or you know the first bit maybe static or something like that so you can't i think in general directly x or a chem key but if you kept the choice of kdf and then you xor the derived key that's probably okay but yeah let's let's see that sketched out so we can bash it go ahead yuri one question when when we say kdf if a standardized uh post quantum chem would include a real kdf can we here uh say that our choice of kdf is what's in the specific cam or does it always have to be outside of cam regardless of what that him is doing i mean yeah that that is the question right you use the word if in your sentence so i guess we need to get to the bottom of that if saying is in other words we could assign an old km uh with kdf bar well i think i think for the post quantum ones it probably is true that"
  },
  {
    "startTime": "00:26:00",
    "text": "they're whitened at least starting with round two or round three they all include like a shake as their last internal step so i think anything coming out of nist will have the property we want i just think we want to be careful that in general like chem like if you make an elliptic curve based cam it might not have the prop the same property yes exactly um what i want to see here is the ability to specify that chem is the one and implicit [Music] by the that kdf is done implicitly by this specific cam so i specify a cam or id abc and the kdf oid a def and that id means explicit kdf is null operation uh output of chem is kdf or i specify kdf xyz which implies that for whatever reason i'm not happy with how chem whitened its output and i'm applying external explicit kdf to it yes basically that's that's the case because some of the well current cams output uh for instance 256 charge bits shared sequence while overs uh output uh 5012 bits so maybe we have to we mandatory to have a kdf afterwards to align the size and to be to make it independent of the symmetric algorithm that will be then used for"
  },
  {
    "startTime": "00:28:00",
    "text": "encryption i mean as such we we can't assume on the shared secret size that will be uh resent by the game algorithm okay quinn quinn can you hear us we cannot hear you you need to push the microphone at the top left of your screen to unmute yourself there you go um sorry i yeah i did not click on the icon on the left corner um so i would like to add more information to the discussion so currently um the the camps we have um they they will come out with a share secret of 256 bit likely likely that is going to be um so whenever you run the the encapsulation then you would have a 256 bits of shared secrets and that and if technically if you want to use that as a key for aes 1 256 then you can use that to encrypt the data that you want"
  },
  {
    "startTime": "00:30:00",
    "text": "and then you need to send along the cipher text along with your encrypted data that would be enough for the recipient to decrypt it the recipient must have the private key and that privately with the cyber tax would be enough for them for for the recipient to re to generate the share secrets and access secrets is a key which were used to encrypt data and it would be enough to decrypt data um in case if you use as128 to encrypt your data then you can job you can you can do the truncation you take one that can be a bit of of the output but knowing that you by doing that you basically you won't have more than 120 bits of security from your whole scheme so it's it's it's different from from the golden icemaker that's what you have so very very likely the standard going to be the share secret to be 256 bits for a cam mike so clarifying question quinn um so i know the the earliest version of psych the j invariant was not um like didn't have the avalanche property so is it now is it now safe to assume for all chems that you can use it directly as a symmetric key is that a guarantee that you're building into the competition oh at this moment i don't remember all the details about spike in my head but for the final lattice finalists three of them um they they they all have 250 bits of jazz secret [Music] perfect thank you yeah so uh"
  },
  {
    "startTime": "00:32:01",
    "text": "i i think site is it's the same for for the cam but i just i just don't remember exact uh sure about details but the cam for psych is going to be to be the same it's around it's going to be 256 bits i think because for all the cams basically at the end step you do the uh the hash on to generate the shared secrets and the hash is to be 256 bits more or um or 512 it depends on the hash you use so that that's that's why you have a fixed output lens share secrets for for for a camp because you do the hash and the last step to produce the share secrets so yeah so we can do um so yeah we can we can do a wrap no you know too big uh to have the same logic that we've been using with isa but if you we don't want that we can you can use the the key straightly because every time you run the cam the encapsulation you have a fresh new shared secret even though you yeah yes excuse me but i think an issue in cms is that if we want to send a message to several receivers uh usually the encryption the encryption key will be the same to uh for all the receivers but we have to encrypt them individually to each recipient so meaning that we have to be able to to to communicate to communicate a fixed key that's why this key is in my opinion the cam cannot be used as such because the cam generator as you said a"
  },
  {
    "startTime": "00:34:01",
    "text": "unique [Music] shared secrets but then uh well we cannot we it's we cannot we use it uh for instance to encrypt the data to several users that's not the problem i think let me try to recap um you would like to send to multiple recipients what uh what unique key for each recipient that what you're trying to do yes exactly uh no i don't think that's what we're trying to do we're trying to send the content encryption key to all of the recipients yes uh yes you're right that's what uh and and if if with that is the same functionality with using ski straightly so even in the case if you would like to generate unique key for each recipient but they are generated from the same shared secret then the recipient can can generate the keys belong to the order the other recipients uh you know by by we run the hash because every recipient gets the share secret and from there each discipline can generate the other keys belonging to the other recipients if he or she wants to go ahead mike really maybe we should take this to the mailing list like your you see yuri's suggestion and then discuss whether it actually accomplishes dms's goals maybe you should take that to mailing list yeah i think so too or we won't get to the other uh briefings um so um i have not received a slide from yuri yet so i'm assuming he's still working on it hurry go ahead"
  },
  {
    "startTime": "00:36:08",
    "text": "the slide is on the way and using the simple approach depicted on the slide which by the way we used uh a couple of decades ago using that approach you can use you you can a a use post quantum s mime at the cost of additional 256 bits per each recipient eras please let me know when you receive my email it just arrived i now have to upload it all right of course with the post quantum cams sending email to for example 100 recipients with hundred different public keys it doesn't seem all that i'm just imagining with the email cap usually being 20 to 25 megabytes it's possible that yep yeah i'm sorry i i i took it back uh yeah i i got confused so recipient um must be only the one who got the the private key"
  },
  {
    "startTime": "00:38:00",
    "text": "so if if you do multiple recipients then you have to do your own multi-book encapsulation separately yes because you got to use a separate uh public key for each recipient right or you you really got it right yeah i got confused uh a way around in my head no problem whatsoever so in that case um yeah we um you we can do a pdf or or or we just use the key straightly um but the kdf is very cheap so but um yeah so okay yuri can you see your slide yes i can and what a beautiful is in in in a way you can consider it a wrap but uh i betcha it's a simpler wrap that then what you had in mind and from theoretic security point of view it works claude shannon would agree and i conjecture that you do not need anything more complicated here just well but one point i think that the"
  },
  {
    "startTime": "00:40:02",
    "text": "the this rfc only provides a framework meaning that for instance you can you you can consider a kdf which would be identity and the wrap algorithm that would be sore so it's exactly what you are describing here you're also assuming the cek and the shared secret are the same length which could be an okay assumption but needs to be stated yes and well for a post-quantum camps it is the correct assumption and if if you use a rsa cam where you can send pretty much any uh reasonable size of shared secret it just doesn't make sense to send for example 257 bits or 254 bits when what you will need is 256. it's possible but it is an opposite of smart okay tim but yes that assumption needs to be explicitly documented of course go ahead time you're muted okay quinn is that an old hand i've been thinking a little bit um"
  },
  {
    "startTime": "00:42:01",
    "text": "i've been thinking i it's uh you know yeah oh the equation disappeared i was ready to move to the next thing okay i'm sorry um it it it looks okay right now but uh i i i can't say something with a short tone you know in a minute or something like that when they look at something um yeah i think we we we need to to to think about it uh uh over the the email list and and then come back to it uh whenever we we later come to it later but it looks okay it looks okay to me okay i hope that the final draft and the final rfc will provide identity kdf and identity wrap and i personally hope that it will provide this wrap as an option yeah because in in this construction um practically it looks okay uh but uh we have to think uh so for example if the attacker can control the uh the random ce key and you know try to mark it in a round a little bit try to figure out the the the s and the sensitivity and something like that we we need to need we need to it's isn't it we need to think about it"
  },
  {
    "startTime": "00:44:01",
    "text": "uh it well as i said this is not a a new idea it has been analyzed and deployed before so if you assume that the attacker controls your ck or whatever key you want to use then of course a result of your key exchange will be you arrive at the key uh i desired by attacker [Music] i i'm not i'm not saying i'm not saying there is a problem i'm just saying i would like to think i'm not saying that there's a problem i i say it looks okay to me but i would like to think uh about about some something a little bit new i'm not saying there's any problem i'm not i'm not saying that i i said it looks okay to me but i would like to think about it from different perspectives different angles different attack scenarios and before i feel comfortable about it i'm not saying there is problem i'm saying it looks okay but i would like to think about all possibilities that i could think of before i make myself feel feel happy about it i like the expression all the possibilities please feel free to get back to me well when you have thought about all the possibilities all right look we have a person at the queues but way to go out to go ahead yeah yeah so um i actually agree with yuri uh this is actually perfectly fine in a perfect world um the problem is uh when people start like making small modifications to these profiles or they combine it with another poorly defined protocol"
  },
  {
    "startTime": "00:46:00",
    "text": "uh this is the sort of thing that causes us to get into trouble from time to time so i think it might be prudent to use something a little bit stronger than an xor especially because there are things that are a little bit stronger than xr that are pretty darn cheap so i would be a little hesitant of just using a barracks or here even though it is from an information theoretical point of view you're right it's perfectly fine okay yuri this is i'm going to close the queue after mike and then we're going to move to the next briefing i want to emphasize that from a cryptographic point of view it doesn't make a difference what kind of wrap you use if your cam is fine and your cek is fine then whatever secure wrap you use will end up okay if either one either your cek or your chem are vulnerable then regardless of what kind of rap you you use the attacker ends up in in control especially if in the end you do want to arrive at the same ck so by doing something a little bit more expensive and more complex will not buy you anything here from security point of view spoken as a cryptographer dixie i closed the queue julian okay mike put a word on i think what quinn and tim are are getting at its protocol composition attacks what if you use the same shared secret public key here and in some arbitrary other protocol i think is the analysis we need to do there"
  },
  {
    "startTime": "00:48:01",
    "text": "yes exactly okay um we're going to go on to the uh first presentation which mike said he could do for sean and it's this one okay mike dawn slides very well um there's only five of them and one of them is the title um yeah so he i mean this draft is basically very simple he's just he's just creating a placeholder draft define uh cms lloyds peaks oids for the nist whatever whatever chemists come out of the nist candidates so the draft right now is full of you know algorithms covered are candidate tbd1 the encoding for the public key and private key are also provided so it's just a placeholder draft to stick lloyd's public key and private key encodings um and then the open clash yeah he's got open questions defining oids in front of parameters you need to find key usages and i think sean has made some opinionated decisions on a couple of these points like key usages in particular i think sean's made some opinionated decisions yeah as is put on that yes if you certainly go back one point go back one yeah so there's his duty prohibited usages it prohibits signing keys if we pick key and ciphermint uh then should we probably say must not key agree and cipher only decipher only so we have some choices to make there"
  },
  {
    "startTime": "00:50:02",
    "text": "but otherwise this draft is pretty much just a placeholder so we have a draft in the pipe where we can stuff woods for the nist algorithms as they come online i think that's more or less all there is here so um yuri go ahead i i personally am uncomfortable with the nest's choice on key encapsulation only and considering that there were candidates that provided a difficult like exchange like side which evolved into psych i would prefer not to kill key agreement in hope that maybe at a later stage of nest competition nest would wisen up and accept something like side perhaps for ephemeral only use so so yuri i don't disagree with you except to say that the charter says any algorithm we pick must be vetted by some process such as nist or cfrg and so what what this draft is saying is for the nist approved algorithms we're going to use them as key transport not as key agreements i i haven't lost the hope yet that nist would finally uh eventually wisen up and standardize a diffie-hellman-like exchange but it"
  },
  {
    "startTime": "00:52:01",
    "text": "would be a different algorithm is the point yes but it would probably if it would would probably come as an output of this post-quantum competition it would come from this same effort just not at the end of the round three tom i'm i'm sorry uh an idea just came up to my head regarding to ori's construction i think there is security that degradation for that construction um very very simple you losing about half so for the uh the c e key k key the encryption key and the cipher text the share secret when you do xor uh in this security you need two things basically you need you need encryption key to be secure and for the encapsulation the sales secret need to be secure so when you do x or two bits together and you review the result that means you're losing half of the security from either one of the two so for example i look at the the result number one a bit with one then i know either one of the two x or got to be a zero and a one so if i guess the bit for the set uh the bit for the chassis that uh wrong then the other one got to be correct so either one of the two losing value losing that security so and that's how you lose half of this a bit of security from from the construction so you cannot use excel you have to do encryption i disagree and the security okay we're not going to debate this now"
  },
  {
    "startTime": "00:54:00",
    "text": "let's take this to the mail list please all right okay tom you had a question about this briefing okay he left the queue so all right any questions i i think that we should wait uh to adopt this when there's actually some meat in it because we expect nist to announce some things uh very quickly but i have no problem with this being the place that we put them and then adopt it okay so mike i think you're going to talk about the hybrid composite next wonderful yeah i'll try and keep this fairly short um so let's fly through what's new with the composite draft since i last presented go ahead next so i sort of got a couple categories here so this this just the submission status of the drafts we haven't really done much but we have a bunch of changes that we've been working on with our authors group so i'll i'll tell you what changes are coming with composite keys o2 i'll tell you what changes are coming with composite chems 0 0 which we haven't published yet and then finally let's talk about terminology and whether the word hybrid is problematic next so these are the current this is the"
  },
  {
    "startTime": "00:56:00",
    "text": "current state of published drafts compositekeys01 explicit compositekeys01 so that's the completely generic stuff in any oids you want at runtime version versus the define oids for explicit pairs version um composite 606. that's the one that we've has been in the queue the longest and then composite encryption o1 we did uh sort of is much newer i figured we should cover content encryption also so these are the currently published drafts what we've got in the cooker if you go to the next slide we've got a keys 02 the major difference being that we've rolled in we'll get to the major difference in the next slide but we've basically rolled explicit and generic together into one draft and there's a few other changes thanks to our co-authors at d trust composite sigs i don't think we have immediate plans to do another revision of that although we do need to do some minor work to sync it up especially once we roll in explicit we'll need to do some minor work and the k of n mode we'll need to cover also so we will need to do some work to sigs and then we're going to drop encryption and we're going to rename it as composite cam and i'll get to that in a few slides next so keys changes from o1 to o2 we tried to keep this backwards compatible i know there are some vendors entrust included who are starting to have commercial offerings that include composite and so we've tried to keep it backwards compatible that keys produced under the o1 draft will still parse with the same semantics under the o2 draft working copies in github but the link below feedback is absolutely welcome so here's the big changes so we've merged dtrust had an intelligent composed algorithm draft from what was it may 2021"
  },
  {
    "startTime": "00:58:01",
    "text": "so it's been out for a year it's almost identical like i think i think our draft and detrust draft would almost be binary wire compatible they're so close and so the fact that two groups not aware of each other's work came up with the identical solution i think is good news that we're on the right track here so we've we've included dtrust in the authors group and we've merged their ica into our ietf draft we've merged generic and explicit so they now share a wire encoding and i've got a slide later on showing what that wire encoding looks like we have tightened up the combiner modes so and or we've added any we've added k of n and we've added custom the one of the goal here goals here is to differentiate i think or mode meant when we said or it meant different things to different people and we probably still have some work to do to clean that up so does when you say or for a signature does that mean the signer is allowed to only produce one signature does it mean the signer has to use all their keys but the verifier is only is allowed to only verify one signature does it mean the verifier has to verify them all but as long as one passes you're good so i think or the semantics of or is still not totally clear and when i hear presentations different people seem to refer to it in different ways so we're trying to we defined any to try and differentiate any in custom to try and add more differentiation but i think we probably haven't quite got to the bottom of that and we've also added the k of n mode which is out of d trusts intelligent compose algorithms draft so k of n would say you know here's five keys you're allowed to use three of them and we would specify that in the public key next so why are encodings"
  },
  {
    "startTime": "01:00:00",
    "text": "the in so now the the wire encodings that are shared by explicit and generic will be in the upcoming draft in both cases they are a sequence size 2 to max of subject public key info for the public key the private key is a sequence 2 to max of one asymmetric key in the generic case the top level algorithm identifier is id composite key which we're just going to define and then the component algorithms can be anything at runtime the difference with explicit is that is that with an explicit explicit composite the top-level algorithm identifier is defined by the algorithm so you would have a draft that says this is you know rsa with sphinx and then the component algorithms must use the algorithms defined by the explicit algorithm hopefully that's clear and then i have the wire encoding on the next slide so here's a bit squinty and meat echo but here's what this looks like on the wire so your generic case the top top algorithm identifier is your id composite key params we're currently using params to carry the combiner mode so i've here i've done it's mode id composite or and then the composite public key is a sequence of subject public key info so you just stick in your normal ec public key and you stick in your normal rsa rsa public key and there you go explicit is uh identical the only difference being that the top level oid is now an explicit oid and it's the client's job to check that the inner keys match what's expected okay next so a little more detail on the combiner modes [Music] we've chosen to specify them through an algorithm parameter i know we've tried so hard to stay away from parameters on the top leveloid but"
  },
  {
    "startTime": "01:02:01",
    "text": "the k of n mode needs to carry a k you need to carry that integer and so we need somewhere to put that and so that forced us back down the path of needing a top level algorithm id parameter so here's here's our current proposal is and is implicit via an absent parameter so if you leave the parameter absent it's assumed that it's the strictest and mode and then we've defined oids for or any uh k of n carries an integer which is k so n is n is implicit that's the number of keys and then you specify you're allowed to use some subset k of them you specify what k is and then custom mode basically says if you wanna do something that's not this feel free but get off get off our roids do you want to speak now russ or don't wait to the end that's the questions on this slide sure how often different than replacing the top leveloid so i'm imagining that that would be a like proprietary policy like you might say policy dictated by nss for example might be uh okay but from a interoperability point of view if you encounter the topoid as composite and then you encounter this customoid you don't know what to do so finding out incompatible at the top at the top level seems uh like you'd be able to bail out earlier and it's probably it probably is the same result you encounter annoyed with a parameter you don't recognize right yep just food for thought"
  },
  {
    "startTime": "01:04:03",
    "text": "um it's a thought question maybe this looks this good work um the this puts the policy in the parameters with the key which is um which means that i mean the key belongs to the signer presumably which seems odd because it's i think it would be the recipient who would want to assert a policy right if this is done for authentication the recipient cares how many algorithms are being used uh not the signer but if this is if so if this policy says this is how the signature was done then obviously the recipient needs to know that but if the um but if it's the recipient who gets to decide what it cares about in terms of how many signatures are applied this doesn't help yeah that's a fair question does the signer or in fact the ca issuing the signer's key have a right to specify this policy that's a fair debate question the the real motivator for putting this in the public key though is this cms encryption use cases you go fish someone's encryption cert out of a directory and you need to know are you allowed to send a top secret payload with only using one of their public keys so it's really it's really the cms encryption case that drives putting this policy in the public key fair enough cool thanks but i agree it's a bit weird for signatures open to open debate go ahead panos i wanted to echo michael's um suggestion"
  },
  {
    "startTime": "01:06:00",
    "text": "that you know that maybe it's mostly on signatures this comment that i'm gonna make but i think adding this logic here this logic that we have not done before or any or k of n adds a lot of complexity and we shouldn't do it i think this should be up to the very fire to decide if he wants if he sees two algorithms and he only wants to do one you know may the power be with him but it should not be part of the of the public key or the signature in my opinion so we debated quite a bit i mean we've gone back and forth whether the absent the implicit by absent should be an and or an or or a do whatever you want um panos would you mind starting a mail list discussion that's probably the right place to discuss this i'm happy to change the draft however the community wants panos are you willing to start that thread for me well i could start a thread yeah i i think you know i mean the drafting is good the composites are a good idea because we may not trust some algorithms for some time but i think having this logic you know complicated a lot unnecessarily so yeah so i think that suggestion then also solves a second debate which is what do we mean by or and or probably then has to mean the signer must use all their keys in order for that sort of the verifier can choose what they want to work the signer doesn't get to do a subset yeah i think there's a lot of quality there that you know we may be missing if we add this so yeah and the the counter use case i think is max palace use case where he wants to be issuing devices that may or may not know how to use all their keys yet like he may want to issue certs to devices that haven't been patched yet yeah but but maybe that needs to get off the ore"
  },
  {
    "startTime": "01:08:01",
    "text": "maybe that's not an ore maybe that's an annie okay yeah let's let's discuss on main list good good questions since uh signature verification is completely in hands of the verifier and what to do with the signature is also a verifiers business i agree with those before me who said it's not the signer's job to dictate the policy your policy to sign is x my policy to act upon validation is why they do not need to match as long as the signer has provided enough data for you to be able to do your policy yes not otherwise you just otherwise you just reject it okay yeah let's let's discuss on the main list i think these are good changes but let's see them written out and then i can incorporate in them to that like those like verifiers like policy things like uh even hms even for the seamless things like um policy may change over time right like sometimes some algorithm can became weaker so like i'm i'm not quite sure about to embed those kbn or any oro things into the like at the time of the signing process or before signing procedure so those questions may change after signing and yeah"
  },
  {
    "startTime": "01:10:01",
    "text": "uh we may be better to how to say about some mechanism to change policy after the signing at least i feel like it might be on the time of the verification but um yeah yeah that's my like yeah comment yeah perfect yeah let's let's take this i think there's sort of a few directions we've suggested we've debated this a lot we've suggested a direction here other directions are we change what the default is what's implied by absent to one of the other ones another option is this doesn't belong in the public key at all maybe these modes the modes obviously belong on a signature algorithm to state what you did we also need to think about the encryption case how do you convey to an encrypter that you only want to receive data under a certain mode you know don't don't send me data using only my rsa key yeah that's these are really good suggestions let's take this to the list and yuri no way you can enforce what the sender sends you you may choose to process it or not based on the metadata or whatever sure you could you could suggest you could suggest but yeah you can't enforce obviously a protocol should be enforceable testable and enforceable yeah i mean since the discussion on this k of n mode continues here um i just want to say the words"
  },
  {
    "startTime": "01:12:01",
    "text": "uh to this as designer i or the issue of public key or signature i want to make sure under which conditions my signature is valid and i think this is important information that needs affair that is needed by a verifier and that's why we need to put it here just by the text and continuous onto the waiting list okay the next two slides are actually yours yan if you want to explain the kfn mode okay russ next okay i mean as some guess already we explained alright this is i think um not sure um if this adds any more information or we have an and certain number of keys n and uh a certain number of uh keys used which is uh defined by says this is a k so um we can talk about how this will be used but uh from my opinion i think we can let's go to the next slide for example for uh for for signatures in pkis ask can you go to the next slide thanks so this k of n mode is so the only way to to make an agile pki so um i sketched the use case here so we have like three algorithms one is the"
  },
  {
    "startTime": "01:14:01",
    "text": "uh our pqc algorithms and uh now we issue uh a certificate with all three algorithms and uh then at some later point uh we realize there's an attack on one of these algorithms that makes them unusable so make a render symbol so uh with the k of n mode uh we we can combine the flexibility of an end mode with the security of an or mode so we still have like two signatures that needs to be verified in order that the signature is valid uh but if one of the signage of the three signatures is uh broken because it's quite uh we see a with a pqc algorithms uh to this uncertain future um we still have some some way to uh to to verify uh uh our signatures with the same security level uh uh as before so uh i think this is this is our point uh if he trusts how this should be it should be handled for for to make an pki agile and lasting okay thanks yuri what if the recipient does not care about one of the signatures specified either doesn't trust or doesn't want it but uh i mean that's the same"
  },
  {
    "startTime": "01:16:01",
    "text": "that's the same issue with any signature i mean if he receives your your certificate and uh doesn't care about the signature so what what's the case that i mean that's not the point in signatures right and signatures what i mean the receiver wants to trust uh it's uh exactly his uh his intentions that he really wants to make sure that this certificate is valid and it's designer or the issue that needs to uh makes uh the effort to to ensure that the recipient can do it i think that's it's another thinking uh uh i think it's a um okay i can get it that's also this encryption it's it's another way around that's my point i'm trying to understand the logic you specify uh k of n two of three one of the three appears a broken but one of the remaining two i do not care about and do not trust what should i do why should you not trust them i mean that is the first point i mean we cannot trust the third one because it's broken for the sake of the arguments and using the slide presented falcon for the sake of the argument is is broken ecdsa i do not trust by the logic of your draft do i accept the signature because xmss verifies and i accept it or do i fail it because out of the two provided"
  },
  {
    "startTime": "01:18:01",
    "text": "only one is good for me i mean who defines which algorithm is trusted or not i mean usually an receiver relies also with this decision on some other uh catalogues for example and if i think about this ecdsa is valid and xmss is valid why you should not trust them i think that problem already exists today i can send you an s mime email signed with rsa 512 and the signature is valid but you can choose not accept it yes absolutely and in that case it it would be my choice to either accept the signature and trust the document or say the signature is not valid for other reasons so do you want me to make the same choice here i'm i'm okay with that i just wanted to be explicit yeah i think that's outside the scope of this document whether if you don't trust the algorithms that the signer has chosen that's okay scott [Applause] follow some of the i don't quite understand the logic behind at least in the signature method um suppose that we have a composite signature with uh with say rainbow and falcon and then we later decided that oh we read this paper that falcon is is is i mean rainbow is not trustable uh this allows us not to trust it but uh the verifier basically still if the signature is still there we trust it then why don't we trust it i don't see the point of being able to omit the falcon signature because i mean the rainbow signature because we don't trust it anymore"
  },
  {
    "startTime": "01:20:09",
    "text": "yes that seems to be more of a spot of a practical matter than like something of a security issue i think deprecating algorithms has always been hard um definitely and this is usually also now not done in in pki structures so that's not uh i think the scope of this group most probably but there are ways that something is still deep created for example national catalogues for algorithms at least in germany this is of course done and sebastian yeah i have a question so we have three signatures here and you talked about pki and does this approach also defines how to put these three signatures into a certificate i think this is could be done with a uh uh uh uh draft of the signature draft we put in place right mike correct yeah we're just talking about public keys okay so different modules here and if i'm interested how to put different signatures i could have a look into the other draft and get it from there that is the idea yes i heard florence um i suppose my kind of short thought statement is i think this adds an awful lot of complexity um and therefore risk of like implementation and logic errors um i think it's particularly hard to follow when it's"
  },
  {
    "startTime": "01:22:00",
    "text": "because of kind of what we're talking about earlier because this is tied to the key rather than to the signature or the certifica or the chem um so it's a little bit hard to kind of understand what the security flaws are um i suppose i think the example was given here of um if an algorithm was found to be broken then you could not reissue certificates and so like you could just use the other two algorithms um and i suppose in that case i think it would be easier to update the certificate than to update both the server and the client say that a particular algorithm is broken so i think i'd need more convincing that this is um this is worth the extra complexity and risk okay so maybe we should i am i think maybe moving this to the signature document would be also okay let's uh discuss this maybe on the mailing list yeah and it so i agree about the complexity and besides that we always only need one good signature with a good algorithm so if we send uh three signatures because we're not so sure about the algorithms then um it should be a local policy that i have to verify say two of them or all three uh rather than just one it just seems weird to me that uh the signer is going to dictate to the receiver that uh they should verify two of the three to any any two of the fee and this the motivation for all this is the post quantum algorithms which are new and even this uh k of n it doesn't offer you a way to play at least one classic and at least one"
  },
  {
    "startTime": "01:24:00",
    "text": "i don't think it's very useful it could be left to local policy maybe i want to add uh that it's not only because of the pcoc highways we also had uh experience uh before where we like needed to uh how to say a switch ptis because one key was bad or something like this and i think this is a way to avoid exactly these uh hassles we had there right maybe we need to explain it i agree but uh we've never went and defined such a thing before it only came up now okay so i i think if i'm going to continue the presentation the summary here let's let's do it on the list so it's available to more than the 32 people in this meeting but it sounds like for signatures it doesn't make any sense and for encryption use cases it there's not really a strong need and so it really shouldn't be in the public key seems to be the consensus here so let's take that to the list and we can update accordingly you disagree with that uh uh synopsis go ahead we can't hear you so yeah hear me now yeah yes uh yeah so i just so i guess i've been hearing a lot of the argument that the relying party is the one that really cares whether that really decides ultimately whether they trust a signature and obviously i"
  },
  {
    "startTime": "01:26:01",
    "text": "think that's true but there's the i think there's a counter argument maybe for the the non-repetition aspect of signatures right where we the i guess if i hold a key pair then i want to make sure that when somebody thinks i've signed something i really have and i don't want you know things that are not my signatures and i i so i guess i'm thinking that the ca maybe when it puts a public key in a certificate wants to be clear whether it's you know the combination of the keys that matter that need to be used or not i just want to kind of kind of put that out there and see yeah so to accomplish that does it need to be in the public key or can you attach it to the signature to achieve that now i guess that's the ca i don't think you get to control which well i guess you can pick the algorithm yeah so so it's possible yeah so i guess maybe you say you you have a key pair that is the combination of algorithms and then you say and this is a you know ecdsa with sphinx keypair and picanoid for the signature that is a yeah so maybe that's you know maybe that still works because the the sort of example today is a ca could certify an rsa key and then you could go use it with some absolutely stupid padding scheme yes ca has no control over that yep so i think that makes sense uh it makes absolutely no sense to put any policy information in the signature because a signature is what we do not trust [Music] all right yeah that's true but so so i guess i'm thinking so i guess i've been looking at"
  },
  {
    "startTime": "01:28:02",
    "text": "and not maybe it's not the right way but there you can so what in the key you say this is an rsa key or you say this is an rsa pss key and i think that's the difference right that so so we can imagine in the key saying this is a key for rsa sphinx in and mode right as opposed to saying this is just a collection of keys that happens to be rsa and and sphinx and you can pick whatever signature algorithm you want i want to leave time for uh dr becker after me okay so you want the next slide yeah let's move this along so last two topics i have one slide each so composite chems i mentioned at the top that we have a chems-0 that we haven't published yet looks like this it's we're basically going to define a composite composite content encryption scheme and we're going to wrap it up to look like a chem and so then it should fit with fit nicely into the draft that game presented earlier and we're i think doing the obvious thing here so we presented a encryption draft a few months ago where we had three different variants and there was good public discussion that was good so we've chosen one to move forward with and wrap it into a chem type shape and this is this is using the nist 856 cr2 kdf combiner um we do have a couple we have a couple open questions maybe i won't burn time going over them here i'll leave that to the reader if you want to look at the slides but i think this is fairly straightforward and an improvement over what we presented"
  },
  {
    "startTime": "01:30:02",
    "text": "earlier so we'll get this polished up and posted um next i do just want to comment that your point three is interesting i think getting more eyes on a particular approach would be good and if it's the same approach we got a better chance of getting more eyes on it so we'll say to that point um to my eyes this is in sync with um the tls hybrid chems work i believe it's in sync i mean with the differences that it's got it it's got to transport a predict like a predetermined c c e k whereas tls just rolls into the key schedule but i think uh it's as synchronized as it can be uh douglas stabila has looked over it and didn't have any meaningful feedback for whatever that means but yeah i think we do need to keep these in parallel yeah and i understand the communicating peers versus uh one to one sender to many recipient issues so finally uh terminology hell uh hybrid and dual are the terms that nist chose way back at the beginning of all this and hybrid key exchange is sort of arguably non-ambiguous but now that we're getting into cms content encryption the word hybrid is like fully colliding and it really is super annoying so um i think if i'm not speaking for you florence d has softly volunteered to try and shepherd corralling our language into a good direction go ahead i can i can speak it's fun thanks thanks mike um no you're not speaking for me um"
  },
  {
    "startTime": "01:32:01",
    "text": "i'm happy to check this um my plan was to try and get something out in time for uh next itf and then we can have a discussion there um i don't have a particular opinion on what the right answer is um i think the all the words um that sort of fit are overloaded um so eva will wake up some new words or we you end up with some quite unwieldy sentences like post quantum classical multi-key algorithm signature or something like that um which doesn't seem great either so if people on this call do have particular opinions i'd be really keen to talk um about your thoughts um and hopefully we can get something that everyone agrees on and go from there yeah i agree that the the term ebridar duo is overloaded but at this point they are still way well they are now widely used and so i'm afraid that it's maybe too late too late to change the terminal but still uh yeah i'm agree is what you said but i'm just a bit afraid that it's no it's too late i heard you say it sucks but we're stuck with it we'll see if that florence agreed to leave we'll come up with a better answer go ahead florence um i think it's actually fine if we end up with we've decided the like worst option is to use the word hybrids um but at least if we've talked about it and written it down then hopefully we don't have to kind of keep keep having a conversation"
  },
  {
    "startTime": "01:34:10",
    "text": "okay seeing no comments uh i'm done thank you all so um i'm not sure who's talking about these last two i know we don't have slides they just wanted to give us a heads up about a few things hi can you hear me hello so i'm gonna just talk about both of these sort of in conjunction so we wrote two drafts uh there's an informational draft and a technical draft and the informational draft it just it formally introduces a concept that ali discussed at the last lamps interim uh which is basically a framework for hybrid solutions that that we're sort of looking at all of this um with um and so sort of breaking hybrid solutions into two categories one composite and one what we're calling non-composite solutions and so composite solutions you know we've been talking about um for a while um non-composite solutions are sort of an alternative to composite solutions um and so the way they work is um instead of um changes being made within cryptographic libraries and with the format of these cryptographic structures uh changes instead are being made to protocol logic and so maintaining the structure of certificates signatures keys um and instead specifically it's sending multiple"
  },
  {
    "startTime": "01:36:00",
    "text": "certificates multiple signatures and so on keeping the format of each individual one the same and so of course with the exception of things that need to be altered to accommodate the chem structure which is going to be the case and so what the informational draft does is it just talks about the solution space a little bit uh with a focus on authentication uh specifically on certificates and on digital signatures it identifies some use cases for composite versus non-composite solutions it gives an overview of a couple issues that might arise with non-composite hybrid solutions and then we also take a quick look at how non-composite hybrid authentication can work with ikv2 and tls 1.3 um and so that's the informational draft i guess i'll pause and if there's questions about that before moving on to the tactical draft go ahead mike i think this work is really good by the way i think this is really like you you called it that it's complimentary to the composite and i think it's it's good to define both i'm glad you've come along and done it um and i i sat rather than speaking twice i sent a big blob of comments on the mailing list back to you yesterday yes um so we did we did see that um and i think should be able to to get a response back pretty soon lots of good questions thank you for that um all right well um if there's nothing about the informational draft i can just uh quickly talk about the technical draft um so what this draft does is it focuses in on an issue that we sort of"
  },
  {
    "startTime": "01:38:02",
    "text": "mentioned in the informational draft and it introduces a mechanism by which certificates can be linked at the pki level and so the certificates that would be linked are the certificates that would be associated each with a distinct digital signature that would be used in non-composite hybrid authentication and so the use case we had in mind for for this draft is to link a newly issued post quantum cert to an already issued traditional cert where both would be used in the same protocol in the same instance for non-composite authentication and so i guess i probably don't need to go in too many details about this draft but if there's any questions i'm happy to to answer well the drafts were both posted during the itf week so i don't even know how many people noticed they were out there but uh if nothing else i hope this encourages people to read and post comments to the mail list yeah we would love to just get a sense of if there's any interest for this approach and maybe try to get a better understanding of use cases for this approach versus the composite approach go ahead yuri i want to express my support for this approach because i believe the protocols should be able to accommodate non-composite and it should be a policy matter which of these submitted search to accept and use and which not to"
  },
  {
    "startTime": "01:40:01",
    "text": "so once again i support this work thanks go ahead mike dear the non what you're calling non-composite or what's previously called multi-cert um is i mean it's good i think it needs to be defined so it's great that you've defined it um in some cases it's probably fine for the two certs to be completely decoupled come from different cas blah blah blah the client can handle that the binding mechanism you've defined i think also probably has value in some cases where you'd want to assert that these two certs belong together in some sense i imagine we don't need to hunt very far to find use cases where that's adding value the debate that i've read through on the mailing list particularly from ryan sleevy and a lot of my comments are to focus on the same is there's a lot of edge cases there's a lot of sort of sharp and pointy edge cases with the bindings what if you bind what if you bind a key exchange key to a signing key what does that even mean what if you bind keys from issued under very different cert policies what if you bind like i i think my general comments are it's probably a useful mechanism but i think there's a lot would be restricted and tightened up quite a bit to remove the potential for sharp edges yep that sounds good um definitely uh we're really appreciating all of the comments we're receiving um and we're uh working on incorporating them into a new version of the draft go ahead yuri as i said i absolutely support non composite i am not sure how much value does"
  },
  {
    "startTime": "01:42:00",
    "text": "binding add because one of the advantages of non-composite is that i can treat the certificates either together or not depending on my policy and i do not need uh to know that they are bound by some explicit mechanism i haven't thought a lot about it but off hand yes so um so um i i agree um this draft is definitely not uh intended to be uh required um to perform non-composite authentication uh it's just um intended to to give an option um for that additional um sort of um assertion uh that the the certificates are linked um and so um i think the the intention is that this would be a matter of policy whether or not to use this mechanism but definitely it's not intended to to be required to perform non-composite authentication go ahead yo um so i think the sharp edges that mike mentioned um we're bound to get them they're always there and the real question is whether we want to handle them in the pki part or in the protocols tls or mike and that's a good question i'm tending towards the icon tls which points me to non-composite but i think that's really worth a lot of discussion definitely and based on some earlier discussions we've had"
  },
  {
    "startTime": "01:44:01",
    "text": "there seems to be maybe a benefit in different use cases to doing this type of decision making in a protocol versus in a different area and so i think iqv2 for example it seems like a very good place to bump this to the protocol and so there there is another draft actually in the ip second me working group which discusses how to do non-composite hybrid authentication in ikv2 if anyone is interested in looking it it doesn't explicitly use this binding mechanism but there's nothing that precludes the binding mechanism from being incorporated the close like protocol approach um well um it's like only for like single like no competitive or single protocol right like we are not assuming like you are not assuming to use same key or like seven different protocol but like this discussion is for example like use like two certificates for single protocol so not discussing about like close protocol things and that is outside the scope of this document i'm and i'm understanding that and i think that is how to say a bit a good way to do that because like as leia slippy was saying like there is some"
  },
  {
    "startTime": "01:46:01",
    "text": "discussion about close protocol attack or whatever but like those cross brought like um i feel like it is better to like to be at the outside of the scope about about the cross like protocol like attack things so yeah did you get my like thing i'm not quite sure like what you mean by a cross protocol sorry so so like for example if you are using same key for different protocol it will be like um there something wrong might be happen but like if you are using different key for like single protocol like like usually it usually doesn't matter so um like my understanding is use like this um document is saying about like use different key for same protocol and for example and and then uh using the same key for a different protocol is auto outside the scope of this like document right yeah it's outside the scope yeah yeah yeah and like by stating that uh it might be easier for people to how to say think about the security things like uh security discussion became should be much easier or if you state that yeah that my point is something like that yeah yeah so we often see in certificates the use of extended key usage to identify which protocols the key should be used with um and and i would expect that would apply to these certificates as well"
  },
  {
    "startTime": "01:48:02",
    "text": "yeah yeah go ahead yuri uh i was going to say that uh in the current environment i don't think uh across a cross protocol attack is valid and applicable the latest reference i see is a cross protocol attack against as a tls dropping down to ssl version 2. i strongly doubt it it would apply here if i'm wrong feel free to to correct with the actual proposed attacks i'd love to see them go ahead mike an example of cross protocol i've i don't know if this is correct i don't know if this is good form but i've seen certificates that have both the tls and the adobe pdf signing eku's on them and that's right there you've got a cross protocol so i don't know i don't know what the theoretical or the literature is but i think it does happen uh i'm i'm not talking about search using formula one protocol i'm talking about cross protocol attacks yes i i sign pdf with the same key i sign email fine do your best attacking it show me results right yeah i i still think it's sort of useful to"
  },
  {
    "startTime": "01:50:01",
    "text": "do though what they call composition analysis you know just to sort of you know might as well convince ourselves that it's safe to combine arbitrarily if we if we can whether yeah whether there's actual practical attacks that come if you don't have that security analysis fair question i see the queue is empty um so i think uh unless somebody joins quickly we're ready for the next topic all right thanks rebecca so i'm pleased that we got through all of this in two hours uh sorry for the stumbling at the beginning with the uh slide uploading um i'm pleased that we got through all of this and um i am really pleased to see that we've identified some topics to take to the list i think that will set the direction for the group is there any other wrap up then thank you jonathan for taking notes you did a great job okay hearing none i think we're done we're finished a few minutes early thank you all for your participation [Music] and we'll talk again at itf 114 hopefully some of us will be in philadelphia [Music] all right thank you have a great one"
  },
  {
    "startTime": "01:52:00",
    "text": "bye bye"
  },
  {
    "startTime": "02:00:13",
    "text": "you"
  }
]
