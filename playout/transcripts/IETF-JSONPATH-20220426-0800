[
  {
    "startTime": "00:00:21",
    "text": "uh this let's give it a couple of minutes well while we're waiting is anybody taking notes so it's just simple i thought we'd probably do what we usually do which is i'm not making notes out of the vod i'm not sure i got this right you are very echoey at the moment so i'm always i'm always echoey"
  },
  {
    "startTime": "00:02:00",
    "text": "unfortunately uh i've not yet put um dampening up on my walls yeah maybe you can simply get closer to your microphone ah it's a conference speaker mounted on a wall oh there's stefan excellent i personally think we're unlikely to get anybody else at this point james if you agree you can take it away anytime yeah i can stop um i'll just do the formalities really quickly for the record um so good morning folks or afternoon or evening this is jason palette room for april may no well this is an official atf interim meeting so the the usual rules disclaimers and procedures are applied please know well uh administrator note takers uh folks are welcome to take notes but i will probably do what i usually do which is make notes out of the vod when it ends up on youtube probably at some point in the next week or so uh blue sheets are automatic javascribe i don't think we need i've got the chat open we can look off anybody wants to chime in on that that's fine um this is the agenda uh do we have any agenda bashing yes we do um"
  },
  {
    "startTime": "00:04:03",
    "text": "draft status oh update on issues i guess all the things we wanted to talk about have issues so we can nominate the issues as they come along so i guess just a few words on draft status we got greg too excellent hi greg um i should turn my light on here um there we go um greg are you in north american time as well okay no i'm in new zealand it's um 8 p.m fortunately i had this yeah 8 p.m on tuesday i may originally had this meeting set two hours from now so i guess i got the time zone wrong it's weird i'm glad you made it okay um so on the draft status um the number of issues that uh still need to address is is growing fairly small um in the usual last minute fashion you know when we went through when we started talking about this like 48 hours or actually was last friday i guess we started talking about this or thursday um uh the the the number has grown in our conversation in the last 48 hours but um the number that i uh called out from the existing issues list that i thought we should talk about was was quite small so i think um we are getting close to being can you hear me please yes we can hear you but can you see me um no no"
  },
  {
    "startTime": "00:06:01",
    "text": "somehow i lost the sidebar with the controls and everything in it [Music] bring that back up okay hello everybody hey yeah so um so so so i i would hope that um we could take this to um a working group last call in the relatively near future and uh assuming that goes well to iatf last call um prior to the next iatf which is when somebody know end of july and it's like oh sorry so i think we should be able to do that so that is uh speaking you know as an opinion under my under my chair hat um i think that you know last time we did this we agreed that we would take uh uh the question of adopting iregex to the working group we did that we did not hear any significant pushback we did not actually uh announce that or declare consensus but unless something surprising happens at this meeting we will i think we should go ahead and do that and move the draft over from karstenster uh land to um to to our own to our own github so any comment on that first of all does anybody disagree with adult with declaring consensus on adopting irax moving it over okay does anybody else anybody disagree that uh we'd be able to take this to itf last call before the next ietf oh yeah excellent so i'm glad about both those things excellent um so now uh as i said i lost my sidebar do you know how to get it back"
  },
  {
    "startTime": "00:08:03",
    "text": "yes at the top press the leftboard leftmost blue button it's called presentation view that one yes ah i got it back okay thank you okay did anybody prepare a list of issues aside from me and email ah excellent thank you so much james oh i've had at least one other two yeah so i've based this off of uh what we've been talking about in the mailing list last sort of 18 24 hours so if there's others you want to cover we can obviously do that okay we got one three that's fine shall we normalization and just get it over and done with yes please so i guess as glenn pointed out there's nothing in the spec right now that um that that says uh that comparison is by is this by uh igf character by character is that correct yeah my understanding was at the last meeting we kind of all settled on this uh adding some text and um it just needs to be added so we have two places where we need to discuss comparison one is the actual comparison operator and the other is where we do a member selection and compare the the given member name with the actual uh member name so i think these are the two places where we need to"
  },
  {
    "startTime": "00:10:01",
    "text": "explain that we do not do any normalization okay so i think we have consensus here um i will volunteer to do a small pr to do somebody else unless somebody else wants to okay excellent uh next uh jason james can we have your list back right so at the current time we do not require parentheses per the uh text of the most recent draft and the examples reflect that i believe greg you were uh arguing the other side of that that we should um require them yeah um for me it's not a it's not a technical issue i guess from a um parsing perspective you know with or without them it's it's feasible to parse the expression however i think from a readability standpoint from an authorship if a person who is is writing a path includes the um the parentheses i think it's much more readable um and also in stefan's original blog post as i mentioned at the bottom uh he does include the the parentheses there as well which tells me that the vast majority of implementations will require them so by having them listed as optional"
  },
  {
    "startTime": "00:12:03",
    "text": "i don't believe that's actually a backwards compatible change or rather a change it would be compatible with existing implementations are there any implementation aspects that you see for having parentheses in the expressions in the filter expressions or is it purely the the the readability from the user's point of view it's now i i i think it's a readability issue um i i think a parser could figure that out figure it out without the parentheses fairly easily so but visibly when i look at look at it with parentheses i can isolate what the expression is much more easily than um than without the parentheses i see so rehability is a very subjective thing the other thing you said was interesting to me i have no idea if it's true um are we actually going to get greater interoperability across existing implementations if we do require parentheses does it i i did what's his name uh bergman um test that everybody who wants uh to have a parenthesis can can have it can write it down and if i remember correctly there may be some implementations who uh who don't need them is this correct"
  },
  {
    "startTime": "00:14:04",
    "text": "that's the question that was asked i don't know if we actually have that in um in the test or in the comparison suite i think that if your implementation does require a single implementation who doesn't uh uh explicitly require parenthesis maybe yeah stephan i think that that's that's not quite what we're asking i think um greg suggested that partly because of the of your original blog that a lot of implementations would require them so if that's in fact true if there are a lot of implementations that do require it then for interoperability that's a pretty strong argument yes i just i just skimmed the comparison project and i think all the examples uh have the brackets in so if if all of okay so we haven't tested without the parentheses that's that's the first thing and then secondly if an implementation such as mine does require the input does require the parentheses giving it an expression that doesn't have the parentheses will not parse it's a syntax error yes i see so [Music] i'm fine with the majority what's what what uh do you do the maturity thing democratic vote i'm uh for me for my point of view the missing parenthesis is a more general case"
  },
  {
    "startTime": "00:16:00",
    "text": "and there should be no backward compatibility issue if we leave it out in the spec but everybody who wants to have it can write it i see your aspect correct that your implementation does require it it's hard-coded so i think i think i think i think the the argument that's being made is not the specifics of of greg's implementation it's that there would be multiple implementations that have this behavior that require the parentheses and if that is true then that is an argument that we should require them just because our goal is to maximize interoperability so adding we have two different terms where we need to be sure we use um there is backward compatibility and there is forward compatibility and backward compatibility means if you have an existing json path expression will that be accepted uh by the json path standard and i think that that is the case here uh what we don't have is forward compatibility so if people write their adjacent paths to the to the new spec they won't necessarily work with existing json path implementations so um i think it's pretty clear we don't have forward compatibility with at least a sizable chunk of the existing implementations even though i don't know um that that in the bugner test there's actually a test specifically for this uh question we probably should should add that um so basically i think if we we want to ensure forward compatibility um increasing um forward compatibility"
  },
  {
    "startTime": "00:18:01",
    "text": "we have to stick with the parenthesis um on the other um issues here um well i can definitely write unreadable json paths today and it's a little bit on on the writer of the jsonpath um query to to write this in such a way that it's readable and i think it's a mistake uh to to try to change the language to only uh allow readable instances so if you you want to have a certain style you can just write that style i think that's what what stefan already said i'm actually old enough to remember the time when when in the c language we wrote the thing that comes after the keyword return we wrote that in parenthesis and that was a style that actually died out at the end of the 70s and it took a long time to die anyway so um i think the the the there is no technical argument except for the forward compatibility um argument uh the stylistic argument is really one uh where we think it's it's up to the the rewriter to write readable um uh queries and um uh the the procedural argument uh we we i think we already have uh discussed that so i i'm not going to comment um on that so i think the the question really is is this change worth reducing um forward compatibility and yeah i think uh we we will have to accept that uh we are reducing forward compatibility here and we probably shouldn't do that yeah my reading of our charter that if that you know a plurality of the"
  },
  {
    "startTime": "00:20:01",
    "text": "implementations are are doing one thing then we should do that thing yeah okay i think we need to actually put this as a a test in the comparison suite and find out uh get data on what actu what current implementations actually do yeah i know my my implementation will fail but i can't say that for others yeah so i'm not a gambling man but i bet that the all implementations will not support this new syntax and i think to some extent it it could be perceived as a kind of gratuitous implementation hurdle for implementers of jsonpath so if you want to adopt the standard then it's just an extra thing which you know it's very hard to justify to them i think i would like to agree to uh greg's uh proposal to test it with the bulkmast test suite and get a feeling about the number of implementations that don't require the parenthesis i see the point of backward for forward compatibility i if the majority wants to have them uh part in in the spec i will follow the vote okay is that easy to do to so let's wait for a test and uh a small statistic uh result how many implementations really uh accept leaving parenthesis out"
  },
  {
    "startTime": "00:22:02",
    "text": "so right now do you well we could simply ask kristoff to do this um so um just just one comment we don't usually vote on things in the ietf you know this is actually something that could be called a bike shed issue where where flipping a coin would be as appropriate as as voting so this is not a big thing um but yeah let's let's get kissed off to to make this uh run yeah and and in this case that's we're not really voting on the working group members we're suggesting a vote of the implementations [Laughter] so in the past i've added i've had tests added via issues or prs um i don't know if any of us have access to to just merge prs directly into that um i can do that glenn you do can you can you add a test case or two that um that covers this and we can see what the results are my problem is i lost my environment so i can't um i can't generate the um um for pr currently i can make the source change i don't think it can generate the full uh works does it not generate on build like like on the pr build if it does then it can do do that for sure yeah i'll have a go okay all right thank you okay so okay i i think our takeaway from here um is that if it turns out that a high proportion of um the existing implementations do require parentheses then we should change and do that if it turns out that's not true then we need to argue some more because it comes back to issues of readability um which are imponderables but you know we'll deal"
  },
  {
    "startTime": "00:24:00",
    "text": "with that if we have to but i think most of us agree that if a high proportion of the implementations require that we we would then go with parentheses does anybody disagree with that takeaway okay okay all right so glenn thanks in advance let us know how it goes i'm super interested actually oh boolean literally i'm happy for filter expressions to contain any and all complete json not just literals but using literals we can start small yeah i think that that's really the interesting question here um this is an addition that that may be useful for for some diagnostic purposes during testing um but it doesn't really do much and um if if people want this in as a foot in the door to put the rest of jason in there as well um i would be inclined to say no because we are not putting the rest of jason in there right now unless we completely change our direction um here um so i think the the only argument that that really holds water so far was i would like to be able to go into a json path expression and replace something by true so i can test the rest of the adjacent path expression and that's a weak argument for me but certainly one i'm willing to consider are you are you saying in a debugging scenario"
  },
  {
    "startTime": "00:26:01",
    "text": "yeah okay so i have an expression and that's not returning anything and i'm wondering why so um i have two branches of an all condition or something and i i um replace one branch with true where i could take out the entire o but then i have to juggle parenthesis and and all that so it's easier to just replace the the branch by true and that's a convenience which i wouldn't want to dismiss but yeah same question do existing implementations tend to support this mine does i can't speak for others it's consequent to have them you you can always write 2 equals 2 instead but that's somehow crazy glenn i have the feeling you have the uh bergman in front of you um yeah do you see anything we should know about i i just tried to post something into the chat um yeah there we go um so it looks like there isn't a consensus get a variety of results what's the path here it's at the top of the page"
  },
  {
    "startTime": "00:28:01",
    "text": "oh key is greater than zero and true yeah so it's using true as a predicate uh which one which is exactly what we are discussing right now i believe yeah it's interesting that some give non-numeric resp non-numeric results hmm okay really needs a standard does this thing doesn't it shouldn't that read or true well he is testing and through maybe to also test whether the comparison fails for non-numeric uh values uh but i think the the end truth is is about as expressive as a test as our true would have been okay there's another one which has got and false which is going to alter i think try that what would be really cool with this website is if you could put in a random path and just have it run all of the implementations for that path yep when you've set up the development"
  },
  {
    "startTime": "00:30:01",
    "text": "locally and there's even a container you can use to run it so it's not too bad if you if you like docker yeah so i think it's it's just looking at this i get the impression that there are a lot of implementations that do not support this if i'm reading this correctly at all so so my instinct would be to not introduce a new thing that's not widely supported in existing implementations so when you say this you you mean filter expressions without parenthesis no no no no i'm talking about true like the the jason glid library there says not supported are there quite a few that say not supported well there are a lot that don't even support filter expressions so um that's a bit of a problem with the presentation style here that that you don't know why it doesn't support this so you have to actually compare a similar query that just doesn't contain the the ampersand eps epson falls and you have to do this manually i mean the correct if we believe in this the correct thing should be what you see from for example well um the the what's the first the from cpp um uh the jason cons so that is what you would hope to see and i'm just saying that there's a lot that are not doing that they're doing other things whether it ranges from errors to james can you scroll down just a little bit so you can see the cpp you can just click on that thing it's easy to pull that page up okay the link is in the chat"
  },
  {
    "startTime": "00:32:12",
    "text": "oh but as somebody said there's a lot of them that just don't do um so do we have a link to for just the the same thing with the filter expression that just says at dot key greater than zero just looking strangely enough no there isn't that one i would like to point out that all the dot net implementations are in alignment [Laughter] i mean there's a few that do we would expect i guess yours accepts also just key true so it uh it regarded shall i add a test for a bald true just to see what we get you know regardless of our decision-making process quite interesting you could the two or fours uh by two equals two uh that should work or one equals one yeah one one"
  },
  {
    "startTime": "00:34:01",
    "text": "equals one is probably the one that people would be using it's the same number of characters as true so uh i i don't really have strong opinions on this is there somebody on the call who wants to make a strong argument for yes or no on this the only practical use i see of this is that debug scenario i i can't think of a practical use where you would want to include this in a production environment yes um the only uh other this i'm scratching stretching around for scenarios but the only other thing is if you're doing predicate logic and you've got a complex filter expression you can uh do the usual thing of spotting the summing in brackets is say um you might have keys greater than zero and key is less than zero and you might replace that with false as a kind of refactoring step um but then you'd end up with temporarily an invalid json path and you have to get rid of that keep going so yeah that's still authorship of the path and deep debugging and you can use one equals one and one equals zero as your sentence yeah absolutely yeah so so i i suggest that on the grounds of minimalism um that we just not do this i'm fine with that yeah i think that the same forward compatibility argument can be made as with the previous one it's weaker but it's still an argument so the only living wall"
  },
  {
    "startTime": "00:36:01",
    "text": "go ahead so the only literals that will have are numeric values i guess literals so literally a numeric value so the only literal that will have is null then they will have numeric values and strings right you can make a case that it's sort of annoying to have literal null but not literal true and false having said that literal null is something that you would use all the time in production looking yeah that's useful so so not hearing anybody you know wanting to wanting strongly to preserve true and false i suggest we uh adopt uh what's that question scenario if go ahead if if we do uh if you're searching for um if you're searching for not exists but specifically properties that are items that contain properties with the value of true or with the value of false can you do that without the literal yeah we have two terrorisms allow true and false so it's not true that we don't have literals for true and false the question was just can we use them in place of a boolean expression yeah yeah no so okay let me type this into the chat real quick you you you uh you must uh compare it with true or false if you explicitly want to know if the value in question is or has that value yeah so what i've typed into the chat"
  },
  {
    "startTime": "00:38:00",
    "text": "can you do that without the false literal but we have a false literal we just decided not to be able to use it in the boolean context it can be used in a comparison so if you look at the grammar where is that comparable equals number string literal true false null singular path good morning okay so you're saying it's it's valid in inequality but it's not valid in a boolean operator yes yeah oh that's weird no we're currently separating the domain in which json values uh can occur from the domain in which we are making boolean decisions so just as we can't add we cannot add two integer values um because that would be crossing that domain the expression language doesn't allow you to use a boolean literal that would be a json value in a place where we want to have a boolean value on the json path such so that may be a weird thing but it's very self-consistent okay so we're considering true and false as basic literals not actual boolean values yes okay you cannot evaluate true or false you can compare it but it's like null i mean null is also something that that cannot be in a boolean expression um and maybe not more natural to have true and false there but uh it's not what we do right now"
  },
  {
    "startTime": "00:40:00",
    "text": "okay that's gonna be an interesting one to clarify in this fact but yeah a single one or zero isn't allowed uh singular one or zero is not as a boolean expression but true and false are so there should they should be boolean expressions or interpreted as such i think no right now the current grammar doesn't allow you to put true in the boolean expression context okay i mean the literal true you can put one equals one there which is true but i think it's it's a very healthy thing to have a separation between the the things that the json path query expression operates on and the um json values themselves which occur in in comparison expressions yeah so that we're interpreting it as a json oh yeah yeah i see i see okay not as a boolean value yeah okay i we will need to be very i i'm fine with that but we need to be very um clear with how we state that in in the spec well i think the grammar is not ambiguous the grammar allows you to you know compare things against true or false or null in a straightforward way which does not allow you to put them in literals in boolean expressions um that's fine i i think i think that's fine i i would suggest that"
  },
  {
    "startTime": "00:42:01",
    "text": "this particular case given the nature of the true and false english words um maybe may deserve a note i don't know we probably should explain this domain separation and use this as an example can you say that again carson i uh he broke up we probably should express me explain the domain separation between json values and and the boolean values that jsonpath uses itself and use the the false um an expression with false in in such a boolean context as an example okay does that uh so so i think what i hear is that people are saying let's leave the leave the grammar the way it is and insert a note explaining the difference between boolean expressions and things that your match values that are matching yep sounds right sounds like a simple change okay should we move along we've gone through the three issues that i put on my slides is it worth us with the time that we have now just quickly going through the any other issues and perhaps clearing them out or does anybody have a particular thing they want to bring up kirsten should we have an argument about security considerations sure go ahead"
  },
  {
    "startTime": "00:44:02",
    "text": "i don't think they're necessary [Laughter] yeah yeah okay so we maybe have to to put in a little bit of uh um knowledge about this this idf thing that has been going on for 40 years and people really like to have security considerations in specifications um and generally the the trend has been to be on the inclusive side in what should be explained in the security considerations um so uh this first item here um i don't know if you can show the the the actual spec maybe slightly easier to read um the first item in section what was it 5.1 um is is i mean we know that we all know that but that's really the problem with security considerations that um actually the people who are writing the spec often know all that but since we are not writing down that information an implementer may actually never come come upon this information because they are just reading the spec and all the security implications that that the spec has may not be available to them so i think we we give an ietf tradition and given the fact that there there will be implementers here that are not necessarily used to thinking in terms of implementation security um i think we really want to be on the intuitive side here now whether the text actually manages to do that can can you maybe increase the size a little bit um whether the text actually manages to do that we can discuss that just increasing enough that"
  },
  {
    "startTime": "00:46:01",
    "text": "so concretely um we're having uh kristen and i are having an argument um in which i am suggesting just dropping the first paragraph here under 5.1 um the thinking is that you know so nor in a lot of protocols you have json okay and whenever you are processing json uh you should never use eval of course because you know if you're in javascript you should never use eval because all sorts of terrible things can happen and and in in the case where you're writing an ietf rfc you should say that if you have if you're handling json you should say please do not use eval to process the json and i believe that is more or less what um the first paragraph here in 5.1 is is saying actually that's not not what this it is trying to say it's not about json it's about the expressions in the json path so you may be reading this with more information in your head than the actual person addressed by this text will have so as a potential we should let greg in here in a second but uh as an implementer i i really have trouble understanding what this is telling me to do or not to do yeah so let's fix the text instead of deleting it so greg i i i don't come from a javascript world javascript um i i can read the language and and write it a little bit but i don't have a lot of experience in it and i don't understand what running eval on jason data is why that's bad because to me json data is just json data right because evo assumes what you pass it is is code and it evaluates it and runs the code"
  },
  {
    "startTime": "00:48:02",
    "text": "and okay that makes sense i thought you were just passing it jason which is just data so jason is valid javascript code um but the difference is that you know when you mix up data and code things can go wrong and that's why we're sort of taking this very dogmatic thing of you shouldn't do you shouldn't even let you shouldn't execute jason you should pass and if you are a new and if you are in the world of javascript it has a very it has a perfectly good you know json.parse thing if you want to actually parse json and turn it into you know a nice set of live live javascript data and that's safe uh i believe generally so carson so can you explain help me understand what you're telling people not to do here or what to do well essentially what what i'm trying to explain here is that uh taking an attacker controlled jsonpath expression and transmogrifying into something you send to your interpreter is bad that feels very general and non-specific in my original implementation i pragmatically reused the underlying scripting engine and i indeed uh he pragmatically used eval and evil is evil because it simply runs the code in which which it sees and it's in fact"
  },
  {
    "startTime": "00:50:02",
    "text": "source or possible injection attacks but serious implementations shouldn't should be aware of never ever use evel in javascript i don't know about the other languages i can't imagine that c sharp allows to without critics uh evaluate any code i don't know but i'm not sure if this first uh sentence is first uh should we i i see it addressing the javascript i don't know if this is really necessary to have it inside secondarily we're not we're not building this on the underlying engine anymore we're defining in our syntax what the expression content can be as such i don't know that there's anything that i don't don't see an instruction that could be passed to any kind of underlying engine that can be executed if you're doing nested paths maybe you could construct a very deeply nested path nested json path um that effectively doses a server possibly but i don't think that we're doing nested paths that extensively we've got a open discussion in the emails apparently kirsten"
  },
  {
    "startTime": "00:52:00",
    "text": "greg your argument boils down to nobody would be stupid enough to do it that way we are one yeah and i definitely can tell you that yes people will be stupid enough to do it that way no what i'm saying is that it's our our language is not based on any programming language it's explicitly defined by us and would need to be parsed yes but people do write parsers doing regular expressions and regular expression substitutions so in in the issues uh comments i i gave an example of how how that might look like in an implementation and this is essentially just a warning for for people not to do that um so um actually what what i was going to propose but now that now the text is gone uh what i was going to propose um was the um maybe getting rid of the third sentence because it's kind of redundant um and i think the first two sentences can contain all the warning that's needed yeah i mean uh it may be slightly different but it's this is similar to my concern about regex's if we allow arbitrary regulators outside of our iregxp and someone could do a um a cpu attack by exploiting an implementation that takes a long time on a particular regex so it's the same kind of issue isn't it so you're saying don't feed this to some let me see feeding parts of the query to an underlying programming language engine eg javascript so in this case i i you know if i were implementing jsonpath in javascript i would definitely feed the expression to to javascript"
  },
  {
    "startTime": "00:54:02",
    "text": "code to parse it uh using the parse constructed hand constructed parser or parser generator so i so what are you telling me i shouldn't do one you shouldn't run you shouldn't run right as javascript well of course okay to write code but it's not okay to inject attacker-controlled text into your programming language engine the difference is in your your example you are writing the code and in my example the attacker is writing the code i'm just looking at the issue here so kristen did write a long comment on the issue so historically what people are doing is they're taking the the content of the the expression in a filter and running that as the underlying language and what i'm saying is that we're defining that and it's not based on any underlying language it's defined as json path and so there's not going to be an engine that necessarily supports that expression well we're not sure if you're passing that to the underlying engine then the engine is would be expected to fail greater than 3.5 you know so if you have a adjacent path that's you know dollar dot a question mark at sign"
  },
  {
    "startTime": "00:56:00",
    "text": "greater than 3.5 that okay sure you would you might pass greater than 3.5 to your interpreter um [Music] that's bad yes i mean we could uh imagine um a language which had a subset very similar to the filter expression language in jsonpath and should such a language come along in the future we wouldn't want people to delegate bits of this um syntax to the engine so if it's fully validated yeah absolutely um but you know uh the exact example of jsonpath i think has has changed because we don't have expressions in the same way that we used to have uh or it doesn't talk about delegating to the underlying scripting language the way that the original the original blog post did so i think things have changed but i think the principle is still there yeah i wouldn't want to underestimate the the ability of programmers to find places how they can reuse the underlying scripting engine for doing the implementation so this this is essentially what i would want to warn against okay well if you if you want to continue to put that warning in there i guess that's fine it doesn't hurt anything but for me doing something like that is such an extraordinarily bad idea that i wouldn't expect any serious programmer to do it this will not only be implemented by serious programmers so so greg i think you're you're in a minority there i think you know the culture is to uh be super aggressive about"
  },
  {
    "startTime": "00:58:00",
    "text": "highlighting things that could be insecure even if they're dumb um i guess my complaint here is i guess maybe this is just an editorial issue i'm just i'm just arguing this paragraph is not helpful enough and so i'm saying okay remove it and carson's saying no and prove it so um let's see if we can improve it okay um anybody want to talk about this one further well okay so this particular issue aside of of not passing portions of the expression to the underlying engine um are we going to be editing the spec every time we come up with a new um new vulnerability or so how are those going to be managed well we have a list there is a limitation to what we can do but we already know this problem and if we don't write it in now the isg will make us do it so we might as well provide good text for that now and yeah it can be shortened yes it can be made more useful so let's try to do that i just don't want us to get into a rabbit hole of trying to search for vulnerabilities and just so that we can keep them in respect every potential vulnerability we just have to answer to the ones you know we find you know some some absolutely crazy stuff um the heart bleed of jason path for example then you know we can publish additional documents about that or uh business spec we just need to do the best that we can do with what we know now that's that's the only requirement there's no no exhaust for example if you look at that same section 5.1 if you look at the second paragraph it just points out that since"
  },
  {
    "startTime": "01:00:00",
    "text": "we have regular expressions if you're going to allow attackers to submit arbitrary regular expressions then a smart attacker can probably uh do a denial of service attack on you with a pathological regular expression particularly if they control both the the json data and the regular expression in the path and that kind of thing yeah that kind of thing has to be in here um okay now the second since we're since we started this i'm going to say let's talk briefly about the issue i raised on the second one 5.2 here um which i i which once it occurred to me struck me as a real issue which is that um if you if you require i json which is to say uh j doesn't allow duplicate keys and it doesn't have numbers outside of the ieee 754 range and doesn't have totally broken unicode you should get pretty deterministic results but if you don't require that if you allow those things a security policy based on jsonpath probably that just doesn't work very well because people can send you a broken json that will provoke non-deterministic behavior so i think that's what section 5.2 is really trying to say yeah i think it's not limited to that specific case what do you mean by deterministic behavior here do you mean by particular implementation or across implementations yeah so you could write a json you could write if you're using jsonpath to enforce a security policy you say you must not process a message that has you know source russia in it"
  },
  {
    "startTime": "01:02:00",
    "text": "okay but you know if you allow bad json where you can have an object containing the source field three times well depending on the implementation sometimes it's going to see source russia and sometimes it's not yeah okay i hope i hope i haven't offended any russians also sorry i do know that there are languages that um the parser itself is non-deterministic in in those duplicate key scenarios we have experience with that in json schema well it's absolutely the case there are some that take the first one there are some that take the last one there are some that uh throw syntax error um there's some that take random like yeah you run it it's a lot of times and it'll give you a different one that's why i json exists to give people who want to defend themselves against that expect to point to okay the question is where the json path implementations will always be used with validating i json parsers and of course the answer is no um so i think this security conservation here is needed the question is how many examples do we actually have to give in the second paragraph um so um do again do you actually have the spec we could so we could look at those paragraphs so we're talking about 5.2 right yeah yeah and i think the the first paragraph is the way it should be"
  },
  {
    "startTime": "01:04:06",
    "text": "yes i agree the the second paragraph is specifically calling out the order of json objects of members in json objects and i'm wondering whether what i wrote is actually true so i'm having i had a problem with that so i could easily understand how if if if you didn't have an ijson uh enforcement you an attacker could send things that would be likely to you know non-deterministic behavior um i didn't really understand how ordering of object members could be used to work around security policies or our creative vulnerability yeah the example is actually one where where i json filtering is not being done and the protective application uses one order to resolve duplicate keys and the the protected application uses another order right so the protective application makes sure that that foo is not set to bar but fool's actually said twice and the protected application happens to pick up the other one right so i i would generalize that that essentially all of the failure modes that are explicitly forbidden by ijson could be used to to to look for vulnerabilities um you know huge number of parsing toxic etf-16 surrogates etc"
  },
  {
    "startTime": "01:06:00",
    "text": "yeah so you would propose to replace the second sentence with the pointer to i.json a little bit of text saying that you know in particular here is a well-known set of uh sources of inconsistent behavior that sounds good okay once again i guess this has come down to just an expression of editorial concern not anything where i think we need to search for consensus i think you know we underst we agree reasonably what we're trying to say um okay any uh that that that's all the things i know about what does anybody else want to raise another issue for the interim meeting to discuss my concern about the irig xp spec and its handling of non-ir regexp expressions ah okay so the issue here go ahead carsten that's actually just an instance of the general issue that we haven't really said how an adjacent path implementation should react to to extensions yeah i'm thinking of it in the context of the iraq xp spec itself though because i feel that i'm missing something in terms of uh carson's statements about it being just quotes just to format and we don't need to describe what happens when you step outside the uh the subject glenn's point is that you know if suppose i i i offer i offer a an iregas and since we're jason path let's say this in the context of adjacent path they offer an ira filter and it contains some horrible gnarly pearl pcre back reference"
  },
  {
    "startTime": "01:08:00",
    "text": "explosive thing um so first of all uh uh it's dangerous secondly it's not interoperable because a lot of implementations would presumably follow our rules and simply just not not take that and so it would be reasonable to re in in the iregas to say that implementations must report things that are not allowed by iregafs and the argument we were having is that is that a good idea yes i think we can all probably agree that's a good idea so should that be a must or a may or i should um carson i haven't heard from you on this one uh yeah i think i sent a few messages but um i think my main point is that um we're having the same problem we're having at the json path level that's why i would like to discuss this together um so right now i i don't think a lot of people are arguing that the json path implementation must reject anything that isn't standard json path because that would essentially uh kill a backward compatibility so um i think we we we have to be careful uh what what we ask uh for here um so if if we say jsonpath implementations only ever can accept uh valid unextended json path then we ask all the the implementers of jsonpath uh to to implement a special mode uh that does all the checking and of course about 5.5 percent of them will actually do that um so that that's the one end of the argument the other end of the argument is of course the the one that is made in the draft iab protocol"
  },
  {
    "startTime": "01:10:00",
    "text": "maintenance document that it's actually good to have checking implementations so you want to be informed about an interoperability problem as early as possible um so that's a conflicting set of goals and i think we just need to define for jsonpath what the right compromise between these goals is and aspect like iraq needs to be flexible enough uh that you can accommodate different users so if if i'm going to to propose a version of ctd output 2.0 that uses iregex i will probably want to be rather open to other w3c regular expressions for reasons of compatibility um so uh an existing ctdl spec that that uses uh uh character subtraction character set subtraction may not be particularly useful uh but yeah making it invalid uh right now on all implementations that do implement that is not the right thing to do so it's really the the job of the referencing specification uh to say which level of compliance checking is appropriate what we could do for iraq is actually define terms such as a strict or a checking implementation i think that's actually what we should do also to to alert users of the irex specification that they have to make this decision i'd be uh comfortable with that uh provided we could say something in our reg xp security section to say"
  },
  {
    "startTime": "01:12:00",
    "text": "uh something about non-strict implementations you know about the the downsides of non-strict implementations good point i mean the uh the the value the reason you know i recognize is apt to be useful is that if i write if i'm careful to to write an iraq as opposed to you know copying and pasting from some perl code i expect to get the benefit of interoperability and it would improve the interoperability if the implementation could yell at me when i paste that in um and it says you know that's probably not going to work in many implementations so so i think it's the the the the i think so i think we should do more than what you said karsten i think yes that's a perfectly valid way to go it is to define implementation classes you know strict and non-strict but i think there's a place for a little bit of preaching here and encouraging implementers to provide the the syntax checking and reporting um i i wouldn't go as far as a must but i think it's it's it would be beneficial for implementation to do that we should say so that echoes my suggestion as well in that um an implementation should implement just what's in irejects which um you know it yeah just this subset uh anything out of that to me should be an option that is enabled by the consumer of the implementation um you know the implementation can be free to to support syntaxes outside of iregex which is fine so long as that support is hidden away behind some option or regex or if it's just a a generic regex library say"
  },
  {
    "startTime": "01:14:00",
    "text": "nets regex built-in system um you could have a compatibility mode setting like there's a like the dot net regex you can set it up you can give it an option to run it as a javascript regex or various other flavors of regex it supports three or four and so you can tell it which particular flavor you want it to support and irregex could be one of those i mean that was my starting point i thought well actually i thought reg xp should be straight it must be strict but i was then thinking about should be strict and tim's counter to that was that um the implementation cost with any putting an implementation cost on every implementer who follows the should requirements so we can need to make and it lets them off the hook slightly um and uh and the interop is uh is an issue isn't it so um oh yeah so so the point being that if we say should essentially what we're saying is every i reg xp implementer should write a parser or generator parser for this uh this subset i'm julia julian is in the queue maybe we should let him speak yeah julian please uh we don't hear you uh julian are you trying to speak we don't hear you can you hear me no okay oh yeah yeah now i hear you hello good morning uh sorry for jumping in but just one thought about rejecting or not ejecting things that are not in iraq ex [Music]"
  },
  {
    "startTime": "01:16:01",
    "text": "we had we as in the java content repository working group ages ago when we defined the language that looked like sql but wasn't sequel struggled with this problem that people wanted to add extensions that are like sql from somebody else and um [Music] the problem being that um you close extension points for the future if you allow extensions to be made outside the spec so if you say um iraq x by default configuration should only allow what's in the spec and you actually should force people to reject everything that looks like an extension to be rejected just to state the arguments right because in people you can have annotations that get ignored but if people start relying on these um this extension point is essentially taken away from future versions of iraq if that ever happens so this is a pattern in very languages or [Music] things that look like strings where people could interview things and um and can get away with that and if a conforming implementation just ignores that later on you want to define something that it what it means then you're in trouble so um be careful in how you define the potential extension points in the future unless you are absolutely sure you won't don't that you don't need extension points in the future so it's a tricky path between having a strict syntax and then allowing people to support more than that because"
  },
  {
    "startTime": "01:18:01",
    "text": "that uh you might be unable to standardize that in the future when implementations diverge so just sorry for jumping in but i just had that thought crossing my mind i think that that's a pretty good point and um i also think that there is a slight difference here um because when you do a sql extension you actually are sitting down and extending sql when you are writing a iraq implementation that isn't strict you're probably saving work by by just handing over stuff to to the regex engine that you're using and the question really is do we want to put the the owners of nudging people to only use interoperable jsonpath queries do we want to put that onus on every implementer of jsonpath or is that something we just recommend uh people to do but the json path implementation doesn't get wrong by by not catching a deviation and of course we could make another argument that says you should not willfully put in deviations [Music] at the moment you know just based on listening to the discussion this feels to me like a should uh not a must and and i would certainly be friendly to uh both for iraq and and jsonpath saying you know implementers should uh report on strings that do not comply with the grammar here um you know"
  },
  {
    "startTime": "01:20:00",
    "text": "with the ex with the understanding that would mostly be extensions and supersets and so on must seems like too high a barrier and and would probably scare off some implementers um but you know this is clearly something that i think would be beneficial to end users so if you put in a should you always have to explain when that should doesn't need to be heated so what's your definition of when that doesn't need to be heated if you don't care about interop wait wait a minute wait a minute the thing is still interoperable it just doesn't help model excuse me query writers to write interoperable queries but the thing itself is interoperable that's a very big distinction i mean realistically the answer to that question is when it makes the implementation not cost effective because i just can't face the thought of writing writing all the test data um that's not a good good answer is it i was thinking about the test testing side and um if you generate the um the parser from a uh uh something that's kind of can be compared to the abnf in our egg xp then you should be in pretty good shape without testing i think testing is going to be a a bottomless pit in this area you know i've seen technologies where you could you could take that abnf and generate a fuzz test from it um but yeah yes so kirsten if i if i understand you you would not really be friendly to a should"
  },
  {
    "startTime": "01:22:02",
    "text": "i think i'd i'd rather simply define terms that allow you to to distinguish an implementation of eggs from a checking implementation of eggs or a strict implementation or whatever term we come up with and explain why it actually is a bonus to have a checking implementation and then let the market sort out whether people will want to be able to advertise their implementations as checking or not i'd be okay with that tim where exactly do you propose to to [Music] i can't see where in the context of regular expression i regrets that there is no should or what what what should or must are we talking about so i think the answer is is roughly the same for the two specs one for iraq x and the other for for json path and um it would be uh quite high up near the front of the document saying you know we we divide uh uh software implementations the process x with our xsi regas or jsonpath as checking or non-checking and explain you know what that means and then say that checking provides the following benefit it allows you know a a writer of these things to have a higher assurance of interoperability"
  },
  {
    "startTime": "01:24:02",
    "text": "and the security implication of checking as well yep can i just check while we're together uh a kind of meta uh discussion that came up about whether this kind of language should go in our regexp as well as jsonpath because carson was kind of pushing back and saying arrogance please just format we should keep this kind of language out of there if i understood correctly so i was pretty against uh actually uh making a single decision i think what tim just said is exactly what i plan to do in okay perfect yeah i think the the approach is it it kind of um it matches reality what was going to happen in practice and so we can then talk about reality in the spec rather than putting ourselves out on a limb one way or the other yep okay are there any other subjects or a good investment of our time at this point any other issues that nobody thought about that we should we should talk about do you want to talk about functions i think we agreed that um they're not going to be in 1.0 that's fair um does that mean that length isn't going to be in one 1.0 because that's pretty common i i believe under the current shape of the spec length is not supported correct that's correct yeah yeah"
  },
  {
    "startTime": "01:26:00",
    "text": "well there are two things missing first of all we don't we don't have that extension point and i think that actually may be a mistake and the other one may be defining length and we definitely could fill a whole document on what length actually means um probably not so much for arrays but definitely for for objects and for strings and certainly for numbers um yeah so uh maybe we want to define the extension point and use length as as uh our exercise uh to do this uh but um length itself actually is pretty difficult to define i'd like to know whether the length of false is greater than the length of true um we already restrict comparisons to a certain domain so we want to restrict length to a certain domain as well and the question is whether we just want arrays in there but or whether we also want strings in there and if you want strings in there this is a very very big kind of font yeah not really you don't unicode characters you count them um but so the real question is can we solve this in the next 30 minutes well i think there's something we can talk about which is that as karsten just said on several occasions people have have argued that it would be good to in the 1.0 json path identify what extension points are and that proposal that idea has been raised several times nobody has ever written a pr saying what what that might look like and whereas i think that's perhaps a desirable thing to do um i i i'm not gonna write the pr and unless somebody else does i don't think we're going to do anything about that"
  },
  {
    "startTime": "01:28:03",
    "text": "yeah i'm definitely not going to do it okay it's above my pay grade so i think i think uh uh greg i think you know the the current time the working group can live with not having length in there all right it's recorded tim said so okay the floor is open for new business so what did you decide i'm sorry i didn't get it sorry karsten what did you say what did we just decide we agreed that the spec currently does not uh allow length that for the moment the working group my my my perception is that we're okay with that um and that nobody has yet submitted a pr to define extension points i'm sure if somebody did we would look at it and think about it but um i wanted to know because i might write such a pr sure i'm sure if you did some of us would look at it what about at index do also extension points for that and don't include that in 1.0 say again i didn't index what at index to uh to address keys uh all right in in in filter expressions uh there are two points with that first of all we need an extension point and if we use the same extension point we use for length it would be index open parenthesis edge closing parenthesis"
  },
  {
    "startTime": "01:30:02",
    "text": "which is uh yeah okay but uh yes and the second observation is that we are violating the don't look up uh property that the the processing model currently has um well we are looking sideways not not really up but so far we only could look down and i think that that's a decision that can be made at the point in time extending that processing well it's a decision that can be made at the point in time when we actually put in index but having the extension point in the syntax i think that that's actually valuable enough uh that we should do that now okay we talked about this at the previous meeting and then the direction that the conversation went was we need to reconcile the changes to the processing model like carson described before we can uh include it into the base spec but that itself would be a bit of a can of wounds yeah if you include the the current object key or the array index that you're processing within a filter expression context as part of the the processing model then i think some of that is resolved i don't know that you're really looking up per se you're just widening the the scope of the context we can wait with doing that when we actually find that extension"
  },
  {
    "startTime": "01:32:06",
    "text": "i suppose the the point is that the um if we allowed extension points then they are not limited in future to just looking at index and length they could generally look up as well yeah if we decide to change the processing model for such an extension that that's true so we could have an ancestor access like in xpath and have all that fun such an extension point we do mathematical operations as well like minimum and maximum and you give it a list of things yeah and so that that's actually interesting because we if we define this this functional syntax uh we have to define what goes between the parenthesis uh yeah so that's interesting let's let me see your focus yeah in terms or in in regard to the the index being what we think or or even the length being uh like index open parentheses at close parenthesis um i don't know that we would necessarily need to do that i would suggest and i think i've written this somewhere i would suggest um having an empty parameter list and the the the app would be just part of the context that is implied it's kind of an implied parameter i wouldn't necessarily include it i don't know that's an idea yeah we don't have to design that now no we don't"
  },
  {
    "startTime": "01:34:00",
    "text": "just planting a seed yeah the passing that explicitly uh opens the door to passing other things explicit explicitly like dot x at dollar sign or uh um index dollar sign which would just be very confusing okay folks um barring any other things being brought forward i suggest we're finished yep should we plan when our next uh our follow-up interim meeting is noting that next itf visit towards the end of july so first half of june perhaps um just so people are aware i'm on vacation for most of may um we're away from keyboard so um that's a limitation for me perhaps perhaps we should do something uh weeks starting either the 6th or 13th of june yeah i would propose the 13th because this isn't public holidays for myself being selfish so the 13th of june we could do a doodle on that yeah if you could continue to send out the we're having the meeting right now emails that'd be great"
  },
  {
    "startTime": "01:36:00",
    "text": "yeah i just missed this because this is historically about 2 am my time but then the giant time change and it started at 1 so okay and historically 10 at my time and now the time changed and it's eight gotta get the whole world running on utc you know then everything will be fine i'm happy with that okay folks thank you for your time um uh we made some good progress and uh see you next time oh uh one one minor note that this group should be aware of um i am in the process of interviewing at postman for their open source uh division with my work with jason schema um they are also tangentially related tangentially interested in my my work here as well so i i may be soon representing postman a little bit as well going forward uh news to come but i thought it was worth mentioning to the group cool well good luck thank you okay all right thanks everyone thanks everyone you"
  }
]
