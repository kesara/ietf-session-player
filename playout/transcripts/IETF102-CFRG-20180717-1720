[
  {
    "startTime": "00:01:20",
    "text": "[Music] [Music] [Music] good afternoon everybody sorry I was I was waiting for the chairs place in the wrong room so that\u0027s why I\u0027m a bit late but let\u0027s get started because we don\u0027t have enough time right so I hope you\u0027re here for the C FRG meeting we only have an hour we\u0027re lost do our sessions so hopefully we can if we\u0027re a bit late we can stay a little bit longer but not for very long so I "
  },
  {
    "startTime": "00:04:29",
    "text": "hope you\u0027ve seen all the note well by this time we have a note-taker anybody wants to look in jabber room and just come back to the mic of the running questions should be a big thing Thank You Steven so I\u0027m one half of this FRG coche co-chairs Kenny cannot be here you might have heard that we will be looking for a third co-chair to help us with the load quickly so there was a request to move one of the hashing to curve to be the first first presentation because of a conflict so I\u0027ve updated the agenda for this any other agenda bashing it doesn\u0027t help that I don\u0027t actually have a slide with agenda so write quickly document status we have to RFC since London update to church at twenty and Polly 1505 and X MSS no documents in RFC deters Q there are four now five documents waiting for document Shepards for one Paul Hoffman volunteer to help progress cash base signature thank you to him so we\u0027ll draw away a trying to figure out with others and what the process is going to be for a shepherd who is not a research group chair but I\u0027m sure we can make tools work with that there was a bit of a backlog and this was waiting for me and Kenny to review various documents I think I reviewed three out of four sent comment on are gone too and we\u0027ll be sending comments on the other two shortly questioning jabber is what about that Pete extra pkix draft yes I need to follow up on this I also got requests to progress aspect - "
  },
  {
    "startTime": "00:07:31",
    "text": "so I\u0027ll be trying to deal with this shortly after them Montreal we have several documents active vrf fresh new curves randomness improvements and transition to quantum think that\u0027s it okay let\u0027s get started with the first presentation about this alright everyone my name is Chris would be talking to you about our draft hashing to elliptic curves just a quick update because I\u0027m only mostly trying to work through the many outstanding to do is we had in the first revision that was submitted and now we\u0027re in a good state where we can actually start you know iterating out within the research group so some quick background this the main goal of this was to sort of go through and survey all the different algorithms that we could use to hash to look the curves that were spread throughout the literature and used them a different particular applications Pakes being one of the primary use case here and just write them down so it\u0027s easy for employers to actually get it right and correct and so on and so forth so after London the initial version was adopted and it contained a couple issues that were pointed out on the list thereafter in particular it convoluted some terms like encoding serializing and hashing it just said everything was hashing and that\u0027s not the case so it took some time to do a couple of these terms and make it more precise and it came with three detailed algorithms and accompanying stage implementations upon outstanding to do and we have filled that to do in the latest version so the main updates are as follows like I said we separated encoding civilization and the random Oracle instantiation which is essentially the hashing to curve functionality and now there\u0027s two sections in the document one for map to code which is the deterministic encoding function the other for hash occur which is the random Oracle functionality which is required for depending on your application we refactor the algorithm recommendation tables such that it\u0027s clear you know I hope that is clear if you have a particular use case for particular application for a particular "
  },
  {
    "startTime": "00:10:32",
    "text": "curve which algorithm you should use of course we\u0027re open to recommendations or you know suggestions for improving that particular table and that format and also the recommendations in general I think once we get everything can\u0027t nailed down and the algorithms you know actually flushed out the recommendations may may likely change and we also took an action last time to work with Karthik and people in the aspect team to create implementations of each map to curve algorithm so now the appendix contain these and we\u0027re trying to help drive that effort forward because I don\u0027t know how much you recall from the last meeting x-pac is this basically attempt to create a language to produce formally verify cryptographic implementations and we felt this was a good candidate to sort of prototype that prototype that particular technology and it\u0027s worked out well we found some bugs in the actual hex back library but all in all it compiles and runs and it\u0027s pretty great so just a quick overview on these particular changes like ice was saying the maps of curve functionality which has its own dedicated section is as I said earlier basically a function that takes an arbitrary input into turistic and maps it to a point on a curve and the algorithms which we include are the same as last time the cards SW will not remember the names so bear with me the simple the simplified us to view that works for specific curves and then elliegator too and then we have a dedicated section for the hash to curve functionality currently and it specifies the hash and code twice implementation which is effectively map to curve twice by taking the hashes or giving an input hash it twice ash to the base curve twice using two different hash marks and H 0 and H 1 in this particular case and then map to curve each of those values and then add them together and output is something indistinguishable from a random point in the curve we are currently considering replacing with the hash encode base point technique which as you can tell requires less map to curve function our computations one instead of two and it also works for and we believe it works for all of the curves and algorithms and consideration particular the hashing code twice we\u0027re not entirely sure if it works for alligator two but we have pretty it\u0027s pretty easy to prove that does the hash encode base point function he does work for Alligator too which is something we really want to support moving on so the recommendation table looks something like so you have various applications you might want to run or in this particular case we just cited various papers which have protocols that you might want to implement the requirement therein for these particular applications and then some additional details about the curves or the particular case and whether or not the curve is very friendly or works with bring friendly curve or super seeing other curve and so on and then we also have a secondary table which this for each curve and for each of the requirements be it an injective "
  },
  {
    "startTime": "00:13:32",
    "text": "encoding like map the curve or hash to curve random Oracle which specific algorithm you should use and a pointer for a pointer to that particular you know that particular algorithm in the document so as an example if you wanted to implement a fake from the BMP 2000 paper on P 256 which requires a random Oracle we recommend you\u0027d end up using the hash to curve functionality with SW because that works for any curve and p226 being one like I said we can potentially change this recommendation later on depending on what all the cryptographers tell us so we are more than welcome to take are more than happy to take suggestions on that particular front and like I said again we had a tax back because we want to drive it forward we think it\u0027s good and the implementations and being pretty concise and pretty clear and you can reason about them mathematically and it\u0027s essentially just you know appreciate for a Python code that you can compile to see or whatever else you want and it\u0027s good and comments welcome on that as well there are currently a number of outstanding issues that in the document itself and I\u0027m sure other people have some issues that may or may not have been raised so the first one in particular is adding support preparing from the curves there\u0027s an open pull request to do this we just haven\u0027t gone through and actually verify that the algorithm specified is correct it references paper and it\u0027s in my cue to actually read the paper and get through this this was raised last time as something that would be good because pairing friendly epic or bearing based at book bearing base crypto rather is becoming more popular these days so why not have support or at least a way to do this for this but applications another item is all that you okay writing the cost comparison table which you know breaks down the efficiency of the computational complexity of each particular algorithm and so if you are an implementer you can sort of weigh the pros and cons and choose one that fits your needs provided that you know meets the particular requirements that are outlined in tables above or at the beginning of the document there\u0027s also an open the item to write the curve transformation function so most of the algorithms assume like the point that you\u0027re hashing to is represented and a fine is an alignment coordinate with an x and y value but you might want some map to Jacobian coordinate or what other application you want and so we just need to sort of write that down as that\u0027s an implementation detail that might matter for a particular application so there are some open questions I\u0027m hopeful that the research group and help us address in particular what generic hash to curve construction should we select I alluded to the two we\u0027re using earlier the first is the fashion code twice and the one that we\u0027re potentially leading towards it\u0027s the hashing code base point which does work for all the curves specified if you\u0027ve read the document I\u0027d like to know or we would like to know if the structure can be improved at all for usability for readability for whatever ility you like and then a sort of open question is whether or not it\u0027s even appropriate zoom clued hacks back in a document of this particular nature this "
  },
  {
    "startTime": "00:16:35",
    "text": "is an experiment we\u0027re trying to see if people are in favor of it and I cannot tell based on looking out if this is a good thing or not please nod your head or shake your head or so yeah like I said any feedback on that particular issue would be you know very welcome all right like rationale for including is that if you wanted to go and just you know quickly test it out here\u0027s an implementation you can quickly grab and if you like wanna run it like your application is built and see you compile it to see and you have it you don\u0027t have to actually spend the time to go through and get it wrong and it also serves as a very concise reference implementation for people who want to you know verify their own customized implementation of their own optimized implementation and what have you and has all sorts of nice cryptographic properties about the generating code so that\u0027s nice that is it are there any questions nope all right maybe one student just I mean historically you see frg documents that have any options generate tremendous confusion later on is it your intention to try and get rid of all of the optional things and just have one thing it\u0027s unclear right now I do ideally we have you know for each curve and for each you know type of requirement be a deterministic encoding or hash curve there\u0027s one variant and like that\u0027s what everyone shall use and whether or not we keep you know the other permutations accommodations document is you know unclear to us at this time I think we\u0027re including them all because as we flush it out and you know move it forward towards publication we want to make sure we serve the design space is exactly as possible but yeah if the precedent is that you have exactly or the right thing to do is to include exactly one option so there is no selection and I won\u0027t be done yeah okay noted Rob lost just one bit of feedback to your third point so long as it\u0027s clearly labeled that in case of a conflict between the specification and the example the specification wins obviously but as long as you\u0027re clear about that I think actually having the reference implementation there if it fits is a good idea great okay I\u0027m all about reference implementations so thank you and if you think that\u0027s good thank you thank citroën yeah good evening good afternoon I am Leo raison Boston University going to talk about the updates to the vrf Draft and "
  },
  {
    "startTime": "00:19:37",
    "text": "mostly ask for feedback on various issues that are outstanding so just a very very very quick intro what\u0027s the verifiable random function it\u0027s like a hash function but with a public key and a secret key the hash sure has the secret key the verifiers have the public key so the verify provides that input to the hash sure the hash using a secret key can provide a proof to the verifier what is this proof do the proof allows the verifier to do two things one is convert this proof to an actual hash output using a proof to hash function and the other is to check that this was the correct output using the verify function okay so it\u0027s like a hash in that even if the hash here is adversarial there\u0027s only one possible output it\u0027s unique and it\u0027s collision resistant but without the whole verification thing the verifier cannot actually know what the hash will be so it\u0027s like a secret key hash so the verify if the verify just gets the hash without the proof will not be able to tell if the hash is right or wrong in fact it\u0027ll look entirely random to the very part there\u0027s a variety of applications I won\u0027t talk about but that\u0027s where we are and specifically I want to talk about updates to the elliptic curve PRF in the draft it\u0027s gone through an iteration so how does it work the first thing we do is hash the curve as the previous talk talked about so we hashed a curve then we do have two hash two curve we actually construct a proof of three things this hash value raised to the secret key and a couple of helper values cns now I\u0027ll talk about in a second um what is the output of the whole thing the proof two hash just takes this H to the x value and outputs it so how do you know that this is the correct hash you know it because the prover will prove to you that it has the correct exponent that H was raised to the correct XOR X is the secret key so you can approve equality of two discrete logs how do you do that there\u0027s a bunch of algebra which I won\u0027t go into but it\u0027s essentially the same as nor signatures or EDD si if you\u0027re more familiar with that so you generate a nonce and we\u0027ve specified deterministic nonce generation it should be a pseudo random nonce essentially you compute some hashing and you get some algebra and then the very far does some algebra does the hash to curve the input and then does the verification okay so the takeaways are that we have hashed a curve and we have non station and we can talk about those for this talk some features so the values H to the X is a curve point so it\u0027s going to be like 256 bits s is mod the fields that\u0027s going to be 256 bits C is short because collision resistance is not needed it\u0027s only under 28 bits so this is useful for short applications where space is an issue we added future proofing so the first thing we hash is the cipher suite ID so that if cipher Suites change we can update the cipher suite ID and not have weird hash input collisions where the same input represents the different things this was a problem in RFC a t32 the EDD "
  },
  {
    "startTime": "00:22:39",
    "text": "si RFC where they had to do funny things in order to avoid hash input collisions what has changed since the last iteration we added a new non generation it\u0027s deterministic and for the P 256 NIST curve it\u0027s identical to the e CGS a deterministic draft RFC 69 79 so now we have deterministic noise generation in there the hash to curve in this cipher suite the P 256 curve is just try and increment you hash you hope you got a curve point if not you increment account rehash again you hope you get a good point we have a cipher suite with curve 25:59 sorry 25 5:19 which looks a lot like EDD si in many ways nonce generation is deterministic based on eg DSA the hash function used is sha-512 and then this cipher suite sort of has two variants one variant where hash to curve is just try and increment you try you hope you get a girlfriend and the other one is alligator alligator squared which is a you know a time invariant way to do Hastur curve what we\u0027ve added is domain separation to make sure that you know hashing is used all over the place in this thing if you look just at the design and I want to make sure that two inputs to the hash different hashes for different purposes are never the same because if you have an input hash collision you get an output hash collision and that can cause all kinds of problems and the way we\u0027re gonna do it is two things one we prevent the cipher suite everywhere and two we just have a bite that tells you which use of the hash this is 1 2 or 3 we do that everywhere except nonce generation we cannot add it to nonce generation if you want to be the same as other standards because they don\u0027t have it but nas generation is not an issue because it uses a secret that\u0027s not used on URLs so the adversary can\u0027t make it collide with anything else a decision that we\u0027ve made but if people really disagree we want to hear about it is that we do not do something called pre hashing so 80 32 ETDs there is EDG SA RFC does pre hashing if you have a really long message you first hash it and then you do everything on the hash value the reason they need to do it is because the message participates in the process in more than one place so if it\u0027s a long message you\u0027re gonna have to chew through it more than once we don\u0027t have this problem because the hash to curve the age that you see on your left already acts as a pre hash everything else is based on H not based on the input this is the only place where the input goes into the scheme so once we have that it doesn\u0027t seem to make sense to do on top of that I pre hash right so that\u0027s essentially the design of pre hash media TSA does not have a hashed occur step so it doesn\u0027t get to take advantage of this we do so we don\u0027t have apprehension we have as I said three cipher suites one with NIST P 256 curve and two with edy 2255 1/9 "
  },
  {
    "startTime": "00:25:43",
    "text": "it\u0027s not clear that we need to 255 1/9 cipher suites one has the hash to curve which is trying to increment and the other has elliegator and we\u0027re not sure we need to keep it we can kill it we\u0027re seeking feedback on that we\u0027re seeking feedback also on nonce generation so with the nonce and these schemes is very important if you don\u0027t have a random nonce you a lot of trouble you could kick and leak it\u0027s been sort of relative consensus of the community that the way to do it is to have pseudo randomness generation the question is exactly how what RFC a t32 does it has three options the reason has three options because it has pre hashing and/or context and the options are here in the screen the second and third are kind of weird because they\u0027re trying to avoid essentially domains up to create domain separation we did something similar to RFC 1832 but not identical because they have an input and we have the hash ticker of the input in there now switching back to the NIST curve the way deterministic ECDSA RFC 69 79 does it is by using an H MACD RPG that requires 10 applications of a hash function to get a nonce it\u0027s not clear that\u0027s the best way to do it and it\u0027s subject to a tiny probability of a timing attack because if you don\u0027t get a nonce in the right range you redo and alternative is to use sha-512 but the suite doesn\u0027t have sha-512 in it it\u0027s only based on charge of 56 do we add that and so that\u0027s a decision to be made do we really want the 10 applications of sha-256 also seeking feedback on various minor knits we use exponential notation H to the X because that\u0027s how groups are written do you want to loop the curve notation x times H what\u0027s better do people want support of contexts a context is something like a message but not a message RFC a t32 has that we do not minor knits what\u0027s the best terminology for take a hash and then take a few bites of it first doc that\u0027s last doc that\u0027s leftmost rightmost what do people prefer and if people like the way we did domain separation for this vrf the draft specifies one more vrf which is our essay based we will do the main separation the same way if if people like so I think that\u0027s all I got thank you very much turn it as much laughter - bro thank you very much for this walk I really think it\u0027s very interested in mr. Luke and as I draft has significantly improved since London now there is much more clear section about secrecy of input against dictionary attacks like new formulation so much and the question "
  },
  {
    "startTime": "00:28:43",
    "text": "I have is if I understand correctly the vrf notions of security are in some sense more strict than for the domestic signatures and for signatures we do have at least two good constructions that have quant resistance its ex MSS and LMS constructions have you sought or have you seen any ideas of how to move these ideas of air base signatures to various it it seems that such a way can exist and do no such works or maybe a thought about it so I haven\u0027t thought about it I don\u0027t know about it I know some people have been thinking and ladders based tariffs but I don\u0027t know of any results I just know that people have been thinking about it thank you for the question I underline H based signatures because for have a signature we do have good security proofs and for legislation we do have some potential issues with them so maybe you should think about it definitely a worthwhile project yes thank you yes of course but yeah thanks for the talk this is great just a quick question regarding the new hash to curve stuff that you\u0027ve added to Stevens Point in their question during my talk it would be great if we could somehow converge on whatever we happen to choose in this document X because otherwise we\u0027d have two competing hash to curve implementations or algorithms for in two different documents which would cause great much confusion I think right not be advisable so I don\u0027t know how you want to do that so I think somewhat it\u0027s a question of timing because they\u0027re dependencies on this fear that need to happen but we have flexibility because we have cipher suites and so one way to do it is whatever the gnashed occur of draft converges on change that into a cipher suite okay probably that\u0027s probably they approach that I simply because of the dependencies that sure we can talk more yeah we have choice yeah thanks thanks so just real a burned-down Harkins he says is it possible to make this generic and plug in an e curve and have a hash algorithm depend on the size of the curves Prime yes it\u0027s possible to make a generic in the description is somewhat generic but it\u0027s not fully generic right now and you instantiate it with cipher suites but they\u0027re for specific curves you\u0027d have to do different things a little bit of course we again real quick question I noticed in the draft that there\u0027s an outstanding to do to add potentially more general hash tag orientations are you just gonna remove that or axe that in order to move forward I think it depends on the timing yeah so if we moving forward in terms of getting working cipher Suites seems important but also adding so I think we made yeah I don\u0027t know the answer sure "
  },
  {
    "startTime": "00:31:45",
    "text": "okay thanks hi Robin Wilson this is probably the least cryptographic intervention at they\u0027ll stay tuned feel questions three they\u0027re about first n objects lost to n objects would it work to specify an offset and the number of octaves so as long as you don\u0027t as long as you\u0027re sure you\u0027re not going to overrun the end of the hash value that would allow you to specify different offsets well sure sure right it\u0027s just the question of what is more convenient for implementation do one take a 0 through 32 or 33 for 64 and how do we specify to make it clear and all the sort of concerns about little-endian and big-endian so that people don\u0027t get confused about which ones it\u0027s more of a language issue than anything else again one more question shehram spoke about some plication Slyke I\u0027ll grant application of various maybe do you have any new applications of that could be interesting to do no stray the technology because I think the main questions about the refs are applications because it\u0027s a new kind of primitive kind of view and algorithm is a good example of application where it is really applicable we have any examples so varis already being used in key transparency projects and connects that sort of thing they actually implemented and used there is a signal implementation of vr af-s there you write an algorithm also possibly reverse is using it and also and SEC v which is a dns Janicek piece is also using the RFS or wanting to use VRS a thank you and they\u0027ll be happy to provide a security review where you will be rich thank you Stanislav Lennox imagine tonight\u0027s last mascara Pro and I\u0027m presenting I joined to work with Cass Kramer\u0027s liber8 annex 11 and Christopher wood the work is randomness improvements for security protocols as this draft was adopters safer G draft London meeting and I did eight about this document and I\u0027ll outline the questions that we have now I should have a view so basically the motivation is obvious most security protocols rely on 100% good entropy and "
  },
  {
    "startTime": "00:34:50",
    "text": "in real world PRNG can fail you can break because of bark because of backdoors all of us know example because of hardware failures of the entropy sources that I used to fade as a initial state of parent G and system entropy pool if it\u0027s joint can be impacted by as an attacker so developers all over the world use solutions to [Music] support the heir-apparent G\u0027s to have some safety net and the motivation of our draft is to prepare a good solution with quite a good analysis that can be used in majority of applications that need such a backup the idea is based on Nexus trick so that the idea is very simple to mix in the private key if you have one in some secure way and this idea issues and problems both technical problems both 50 problems so the way how to mix as a min is quite tricky and we try to understand how to be better so we try to consider a sainted issues and most of them are outlined in the previous verses versions of the draft and we hope to find a solution such that any call for entropy can be replaced with with this one so the construction construction acid is now in the current version of the draft it has changed slightly so that G is output of some sales PRNG and you know construction we change it we replace it with the mixing in with signatures wait with some secret key please a tag one which is unique and environment specific string and all of these is mixed in with function extract which is basically a period for KDF and then expand it using tech tool which is basically notes to the output X top one here is a constant range which is specific for device and protocol or environment and tech two is a nonce actually that can include a timestamp of counter that must be unique the changes from the previous version are the following first of all is a construction itself it has been generalized so now it "
  },
  {
    "startTime": "00:37:51",
    "text": "has lengths of n of the same length as for initial says PNG so it\u0027s based on hkf notions of stretch and expand moreover we think about fixing the construction from hkf RFC and we added some clarifications about security considerations about the ground attack - and dead McGrew in his recent opinion about the document has mentioned that we should stress something about tag one more and use it so namely tag one is the control measure against many possible vectors of attacks including the edge that follow from clone in virtual environments or several machines using one HSM with one secret key and we\u0027ll try to clarify this point in the draft more specifically in victory is a timestamp that ensures that outputs are unique you saw that it will be reasonable to define target security properties of our construction first two of these properties are properties that guarantees that replacement of any says PNG with our construction won\u0027t do any harm so it won\u0027t be worse at least so first of all that if sister Angie works fine in some security model the output of this construction will be good in the same security model secondly we don\u0027t harm the private key so we don\u0027t increase as a probability of compromise of our private key maybe only for some visual advantage and so the property our aim and meaning no fusing this construction that if says PNG is broken or even controlled by anniversary or even just degenerates to constant string along the output of the proposed construction will remain in the thinkable in responding security model we relaxed signature scheme they were very strict they required the scheme is deterministic though actually it doesn\u0027t need to be deterministic it just need to use its own entropy source why we solder this taxation is needed because if you use HSN with its own internal entropy source "
  },
  {
    "startTime": "00:40:55",
    "text": "and then it\u0027s okay the problem is only when you use the signature scheme which is not at the monistic that it uses the same entropy source S which I into page so the is clarification was added to the document some minor issues based on one of opinions in least were added about comparison to C 69 79 actually the construction can look more or less comparable to the construction from RFC 69 79 but it has completely different semantics and meaning for example if you have an HSM who is a private key used inside of it then the construction of 69 79 it can be demented inside the HSN and our construction uses its it from outside so who uses calls to Z HSM as I stated plans actually its own for his today\u0027s message to the list because it reflects most of our current plans so first of all we must obtain up-to-date security assessment because once we have little outdated and we showed specifications to the draft spare specify our construction and add recommendations some of them were a legend in the slides and some of them are the same that was in the mcribs letter and we think that we should add these clarifications there\u0027s a document itself and we should refer in security considerations more to be stated explicitly so that we can cover most of stations that we wrote about which can lead to what usage of his construction so our reason and our aim to is to provide constructions that will close a lot of possible dips and of course we want to close as many of them as we can and we hope to get a new version addressing these issues until then thank you very much thank you for attention questions comments thank you for the document in the presentation of David micro Cisco so I have a like a question just to like informally talk it through so one of the assumptions in the security analysis is that the the signature of tag 1 isn\u0027t obtainable by "
  },
  {
    "startTime": "00:43:58",
    "text": "an adversary but the conventional you know security model for a digital signature is you can assume the the attacker can you know to you know obtain signatures for chosen messages so there\u0027s some I think you just need to like explicitly state that as another another case in your case analysis and say well you know if your if your PRNG is no good and the attacker can do a chosen message attack well you know your your game is up but it would have been anyway or something like that yes agree with you and yes we should add this it\u0027s basically moreover it was issues that we try to address as well as possible we had discussions all sorts about how this tag 1 should be chosen in a way that it can\u0027t collide in real world with plain texts that are signed of course it\u0027s it can be it and it may not be fully formal but of course we shoot our what\u0027s the security considerations and we\u0027ll do it and thank you very much for attention to this issue it is really important and in fact we should add some some more text about that that this construction is still good if these conditions are satisfied and it breaks completely if any one of them is not satisfied yes because they will use it thank you very much for comment thanks more questions thank you yeah "
  },
  {
    "startTime": "00:47:07",
    "text": "good afternoon I move a craft chick I\u0027m going to present about this protocol we called opaque it\u0027s a head-fake passer authenticated key exchange and a symmetric one in the sense that it\u0027s not two friends that share a password it\u0027s a client and the server the client has the past all of the user has a password the server keeps a image of that these based on recent work that we presented in Euro Crypt 2018 and I written a draft about this which I will submit officially right now a week ago or something like this I I sent an email to to the message to the list with the pointer to turn right up of this draft again I\u0027ll do it it submitted officially the next one okay so an asymmetric page the requirements are first that it will be PKI free not to be based on PK I not like for example the current practice of sending a password over TLS that depends on the security of PKI so we don\u0027t want that and the other thing that we want is that the server will never see the password the only way for the server to learn about the password of the user is to run an offline dictionary attack something that is unavoidable once once you have the image of the password under some one-way function so compared to Lu TLS in TLS the server sees the password when it decrypts the TLS and of course there all kind of other points were that this the password is visible in any termination point middleboxes but Els dealt I mean they pass over TLS does one good thing which is it uses a secret salt for the hashes which makes the work of the attacker as hard as possible meaning that not the only point in which the attacker can start running an offline and dictionary attack an exhaustive dictionary attack is only when it breaks in to the server now since APEC has all these requirements and doesn\u0027t need PKI you would assume that all these apex by the way is for a symmetric or augmented the both terminologies are used so you will assume that apex are always better than TLS a password over TLS that the next one they actually the this is not the case it\u0027s kind of surprising but all all APEC protocols known to this date those that are you know the practical one the "
  },
  {
    "startTime": "00:50:08",
    "text": "impractical ones the proven ones the unproven ones none of them can actually use a secret salt in the in the hashing so either they don\u0027t use a secret salt either they don\u0027t use salt at all or if the use salt they have to transmit it in the clear from server to a to the user and again that is common to all the apex that you have heard about like SRP spec 2 + oktake and any of these protocols next so you would you could think that maybe there is something inherent here that for example if you want to do a PKI free APEC then there is no way you can also do secret salt and the answer is and this is not the case next one and this is what we actually show in this protocol is the first one to be secure against pre-computation against pre-computation so if if you don\u0027t use salt as we all know then you can build Universal dictionary before you break into the server if you use salt but the salt is no to the attacker then at least the attacker can build a targeted dictionaries against a user and immediately when it breaks into the server it confirmed the password so opaque will have the property that this is not possible it is secure against pre-computation and also is a formal proof of security and there are a strong strong definition at the inside that it was written there but it\u0027s important to note that there were provable or proven fake protocols under under crypto formal models and even those were not secure in this sense and that\u0027s because these models actually allowed for pre-computation attacks which basically goes against the very basis of very basic requirement that you would like to have in these protocols okay so a opaque is build on on the basis of this primitive called oblivious PRF oblivious to the random function what\u0027s on oblivious pseudo random function so a pseudo random function we all know it\u0027s a function that if you don\u0027t have the key to you don\u0027t know the key to the function then it it behaves like a random function indistinguishable from a random function what\u0027s an oblivious PRF on a blueish PRF is a PRF with a protocol between a client and a server the server has a key to the PRF the client has an input to the PRF at the end of the protocol the client learns the the value of the function from this point on the X which is the input of the client while the server does not learn "
  },
  {
    "startTime": "00:53:10",
    "text": "anything it doesn\u0027t learn about the input of the user doesn\u0027t learn anything about the output so he generates the output but doesn\u0027t learn anything about it okay and this is going to be very very useful in this case so again your f is a interactive PRF service that returns PRF results under the key that the server has that the server does not learn the input or output of the function next one so the idea of OPEC is very natural once you think about an oblivious PRF what you\u0027re going to do is that the user will take it the password a PWD and will exchange it for a strong key produced by the o PRF now since this the server can provide the the value of the PRF on the password without learning the password or the output then basically the user getting some magic way it replaces its password you know it\u0027s low entropy password with a strong key where the entropy comes from the key from the the OPF key of the server but again without the server learning anything not about the password and not about the key that was returned by the PRF so now the user has a strong T and now everything is simple what the user will do it will store at the server an encryption of a strong private key will retrieve during login the private key from the server decrypt it using the output of the OPRS and now server and the user or client can run the key exchange with the regular private key for the user private key for the server so essentially what this does is give you a compiler a transformation from any key exchange to a symmetric take and this compiler since it\u0027s very very general actually will give us flexibility in choosing what has the best key change protocol that we want to use in a given situation next one here I\u0027m showing one implementation of the of a PRF these just blinded the diffie-hellman a very very simple transform I will not get into the details of the the function again it\u0027s simple but I don\u0027t have time I only I want to highlight the performance issue here the server apply requires one exponentiation for the server for the client is one fixed base exponentiation "
  },
  {
    "startTime": "00:56:10",
    "text": "and one variable based exponentiation and this is just a single round message from client to server and from server to client that is also I should have I\u0027d like to actually rushing into into a group into a curve now change these two messages actually if you have an implicitly authenticated key exchange like HM QV you can at this is the whole protocol what you see what you see there just one one message each direction if you want explicit authentication from the client then you add one more one more message next one against this is very fast and just to give you an idea of course the details need to be read more carefully but it is just to give you the general idea the the cost that you have is the kick change cost plus the OPR F cost which as I said is one server exponentiation to form the client if you use opaque with hmq V which is a particular is a very efficient implicitly authenticated take change then you basically get the full protocol the full opaque in two and a half X pronunciations for each party this is a more or less similar to speak to class which is one protocol that has been or is being proposed exactly for this for this functionality the difference is that spec 2 plus is insecure against pre-computation attacks against because again because it cannot use a sacred salt and also speak to Plus does not have a proof the draft but define spec 2 plus says that there is a proof but no there is no no proof it was proposed in a paper by David cash on victor Shoop and John Kemeny sh but I check with the with the author\u0027s the paper doesn\u0027t have a proof and they don\u0027t have a proof there is not even a model in that paper but maybe more more essential is the fact that that protocol cannot accommodate secret salt and they opaque can by the way I\u0027m a music agent give us an example we have to say that since H MTV has a patent my name is even though it doesn\u0027t belong to me but but what I do want to say is that if "
  },
  {
    "startTime": "00:59:15",
    "text": "there will be interest at some point of interest and arising up a quiz HM TV the most probably that will not be obstructed and cannot promise but I think that\u0027s what will happen now what I think is most important in these symmetric pegs is to find ways of integrating it in TLS because of these things that OPEC is actually a compiler from any K exchange to a page it means that it\u0027s very easy to integrate it with TLS all you\u0027re going to do you are going to use the LPR F to change the use password for a signature key okay and now you can use that signature key as a client in client authentication in TLS if you want if you don\u0027t care about encrypting the user ID when you contact the server then you could do the whole thing exactly in the same three flights of a regular TLS if you want to encrypt the account information then you either need to use a resumption case you have it or you need to add one round trip to two TLS but again everything is very easy to integrate because of these just general paradigm of take my password give me a key and Alton do is that T whatever I want so epic security it has been shown to be secure against pre-computation attacks and is PKI free it it has forward security and something I didn\u0027t mention you can do make it harder by doing iterated hashing as we usually do in regular password protocols and these hash iterations are actually offloaded to today to the client the next one so to summarize opaque offers a symmetric page that is efficient probably secure does not rely on PKI the server never sees the password actually even at the registration time the password the server does not have to see the password it uses private salt against pre-computation attack uses hash iterations on the on the on the user or client side its friendly to TLS integration and two things I didn\u0027t mention is since the user is actually storing it\u0027s a private key with the sick with the server you can be used exactly the same mechanism to store other secrets you know your Bitcoin key if you "
  },
  {
    "startTime": "01:02:16",
    "text": "want or any credential or anything that you want to store at a server and finally if you want to make your server even more secure you can make it know into a threshold you know like two out of three is that you have to break into two servers before you can even start running a dictionary attack so if you are looking for strong are we the topic seems to be a very good fit particularly if we want to integrate with TLS 1.3 it is not clear to me hey well what is really this the sentiment with respect to really building something like this into TLS 1.3 this is much more secure than what we the password protocols that we use now it has even some some advantages in particular its while now what we are doing is protecting passwords with TLS doing something like this protects TLS against PKI failures so there is some very valuable this value here so if people are interested in pursuing these please let me know and we will try to build is something more detailed for for for actual implementation okay a few minutes overtime but very quick questions all right Chris what Apple thanks for bringing this this is really great I definitely want to see this happening in the CFR G two quick questions number one they\u0027ll pure up that you specify is that the same like two hash diffie-hellman OPR that you and stars use in the password-protected vaults paper or has that changed the only change in my in the specification here is the paper we use exponential blinding and here we use multiplicative blinding and there\u0027s some technical issues there yeah yeah second question you should mention the compiler works for any key exchange protocol that really means yeah resize is not every kiss every protocol with the KCI property okay which is most protocols and protocols that don\u0027t have case here you shouldn\u0027t use them in the first place yes yes it\u0027s a technical issue but it\u0027s significant it\u0027s the there are several technical issues here that show how you know sensitively thing is to and the proofs actually show you what you meet that yeah and then the third one really quick there is an existing draft and entails working group on integrating generic cakes into TI 1.3 that Richard "
  },
  {
    "startTime": "01:05:18",
    "text": "burns is driving I don\u0027t know if you\u0027ve spoken with him at all but no I haven\u0027t I want anyway I want to talk to Richard generate burns so whoever sees him to him you know I thought I thought he will be here but it was told that he has some conflict yeah I mean this prior especially thank you very much for bringing this I really think it\u0027s very important work just small clarification if I understand correctly that we can modify any castle secure key agreement to the password of syndicated key agreement with immigration our private key to the server and hit the play but if anniversary has a full access to the server occasionally it can not mount only dictionary attack on the password but also on the private key itself so if I understand correctly that we should not use the same private keys for different servers in this case if you don\u0027t believe you don\u0027t trust any one of the server\u0027s so if our if one of the server\u0027s is compromised is there not only our password there is no reason to use the same private key because you don\u0027t have to remember it so it\u0027s not that you\u0027re doing you\u0027re keeping it somewhere or something you of course if the user starts from no memory only no speed bus yes if we start with opaque as a complete protocol of course but if we treat this psittacosis as of the way of moving from our private key identification to the Bekaa station that that can go a mistake of reuse which of route keys and if if you if used to store credentials then you are trusting that server or at least I mean if your password is strong enough here this is not going to be found but yeah okay synchromesh maskers is she consulting you know the link that I just tried did not work to get your draft say that then I just tried the link for your draft and I got they an error okay so a PDF works oh okay the text doesn\u0027t work or work okay thank you I gave them a crew Cisco so you go this is this is really good stuff thanks for doing it thanks for bringing it here and I\u0027m sure Richard will be Richard Barnes will be interested to talk to you more about this I just wanted to encourage you to keep this up and I want to say the there\u0027s let\u0027s say a way to use passwords to authenticate to servers such that you don\u0027t have to trust the server would be really meaningful because of the you "
  },
  {
    "startTime": "01:08:19",
    "text": "know there\u0027s it\u0027s very commonplace nowadays for you know phishing attacks to steal people\u0027s passwords right that would be a really meaningful improvement in the security of the internet if we could eliminate that trust in the server in the last slide actually if we use everything we know the state of the art which is very practical in with passwords password would be much less insecure than they they are now I mean still the password 1 2 3 4 5 6 will be insecure but yeah we need to be careful them to make sure that we don\u0027t bring all the problems of passwords into any future designs but it sure we\u0027re doing picky comment so there are three drafts presented today they\u0027re all elliptic curve drafts we\u0027re all taking things to the exponent hashing to the curve and doing things so we\u0027ve all written things a little bit differently if you look at like the the way that our draft the vrf draft by the way I\u0027m Sharon Goldberg I\u0027m one of the co-authors of the vrf draft that was presented before the way we\u0027ve written it in the way you\u0027ve written it they\u0027re pretty different so we should probably try to make the notation consistent because the actual operations are not the same but they\u0027re very similar it\u0027s the same set of things so we should try to converge also with you guys on like how do we write this in CFR G and let\u0027s just you know nail that down and be done so we don\u0027t have to keep having different Jaeger speaking from from one of our co-chairs I just threw you three drafts and they all use different notations as well and you know this it\u0027s it\u0027s sort of hard to make people you write it to be the same but you know I I encourage this sort of collaboration of course yours is the right way okay thank you yes hello everyone I\u0027m very gift from rabid universities in other hands I\u0027m going to quickly make a quick update about why we should actually become go 1200 as an RFC so kangaroo 12 is an interesting function because well it supports arbitrary output length so you can actually use like to derive entropy from a source with 128 bits of security and there is no Arab see that provides such functionality so far it also provides hashing with Verizon as cannibalism which mean that your outputs "
  },
  {
    "startTime": "01:11:19",
    "text": "your input lengths grows then the degree of paracin that you can use is actually increasing and you don\u0027t have to specify specific parameters like I want to use this function with I don\u0027t know a degree of parameters of per reason when I am actually calling it also it\u0027s based on the shari permutation so kernel 12 is a hash function or excellent level function it\u0027s not a construction with generic properties it\u0027s really a hash function that you can use instead of shattering for example and it\u0027s based on j-3 so from that we can reuse the code of katuk we use the v8 instruction that are currently implemented there and also it\u0027s like at least twice faster than shattering and because it\u0027s based on sha 3 well yeah then it\u0027s public design and it really have the same cryptanalysis of Shia 3 this mean that we have at least angels of cryptanalysis on it and that\u0027s about 35 papers that have been published on it which is actually more than sha-256 and sha-512 papers where we actually counted only 21 through a print and other sources so it\u0027s really really secure design and not just something that is new because the construction is based on proof for the Spanish construction for the secretary construction so the pair ISM is proven correct the special instruction is proven and then you just rely on the security of sha-3 so if you don\u0027t trust a3 then you cannot trust conlou 12 but I don\u0027t think this is a point here also my current best attacks are like creation of five runs four shot three and we have stream prediction over eight runs with a word cloud of to the / 128 there is shrimp prediction over nine runs with a workload of two to birth 256 but that\u0027s way above the security requirement that we want and so we only have this two attacks over five and eight runs and can go 12 has 12 rounds so we still have a 100% security margin for the collision and at least 50% of security margin for shrimp prediction so for that it\u0027s still really really secure and not just diminishing the security of sha-3 so in the end why is it interesting well as previously said it\u0027s an open design result of an worldwide competition it has a long-standing scrutiny from the crypto research groups from France on all over the world it it doubles the speed with respect to sha 3 it has proven to like security and thus carries the prism is actually scalable and not just limited to 8 cores or 4 course thanks for your attention "
  },
  {
    "startTime": "01:14:20",
    "text": "and if you have questions Jeff thank you have a chat question now there is a process in I saw it see 27 of any amendment on hash functions do you have any plans to bring in this to ISIL because they just have the process of vision of hash functions now and maybe it will be a good chance to bring new constructions are I didn\u0027t heard about that process so I actually will have to take a look at it and maybe then maybe it would be a good idea to try to have a say-so but now there is any amendment being repaired and when you have any amendment you can discuss I and I hope that the time is not in the pasture of the deadline of edenia factions and maybe it\u0027s also a good way to go but of course in light AF it\u0027s a good way to proceed also thank you very much thank you for watching ok thank you well chess we\u0027ll follow up with you thank you I think that\u0027s concludes here fargy enjoy the social if you are going to the social and your other things if you\u0027re not [Applause] "
  }
]