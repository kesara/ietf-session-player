[
  {
    "startTime": "00:00:23",
    "text": "okay should we get started or wait maybe a minute or two uh maybe a minute probably if it's time just asking people to volunteer to take notes yeah we definitely need that so would it be like to volunteer to take minutes no need to get into excess utilities action items either in the mutico um hedge dock linked here or any other means you want in emailing us as you like but we will need this so volunteers are encouraged and treated perhaps or maybe uh we'll have to draft somebody yes so behave or you will become the note taker stefan are you interested in taking notes"
  },
  {
    "startTime": "00:02:00",
    "text": "so usually i even volunteered to do so but today uh starting in half an hour i have to juggle two calls oh okay i apologize no do we have a volunteer for notetaker okay i will give it a try well thank you very much thank you very very much okay well why don't we get underway so uh in case you just stumbled into this room by accident we are the avt qr working group and we're having a virtual interim uh for two hours we've got lots of stuff on the agenda um just a few tips you enter the queue uh with a hand icon i think that's still true um and that you need to enable audio or we won't hear you and you do that by muting and you disable by muting you can also do videos separate from audio it's encouraged but not required a little bit about the meeting the agenda is up there on the data tracker the notes are accessible from mead echo in the note tool which i think you can probably find um i guess we're using zulip and not jabber um i think i think they're bridged actually so it's the same oh they're bridged right yeah and it's the chat here so yeah and we don't need as a result we don't need a jabber scrub right but we do have a note taker yeah but i mean i would i guess the only thing is if somebody isn't able to uh use their mic for whatever reason if you know due to our family or whatever you can comment in the chat and um it'd be good if we had somebody who's was actively watching that but we as a tear as well try to watch it to see if somebody wants to say something that they can't say in the mic but please use the mic if you're able so a little bit about the notewell it's"
  },
  {
    "startTime": "00:04:00",
    "text": "a reminder of itf policies in effect on things like patents or code of conduct it's just to point you in the right direction by participating you agreed to follow these processes um and there are disclosure obligations and definitive information is in the documents that are described in the link here also we have a professional conduct policy as defined in the itf guidelines for conduct anti-harassment and procedures in the output stream etc they're striving to maintain an environment where people are treated with dignity decency and respect and please don't do anything outside of that if you believe you have been harassed you can talk with the ombuds persons so i guess we do have itf 114 plans it's a hybrid meeting um i i don't know if it would be useful jonathan to get an idea of how many people are attending in person we did have decent attendance at itf 113 as i recall um so how do you want to do a hand raising i mean i don't know if people want to do a hand raising or just comment in the chat um sure okay comment on the chat's fine if you're playing i guess if you're planning on coming in person comment in the chat um it'll just give us an idea i guess how big a physical room we would need and things like that for the variety of 114. so we'll just take a minute and then we'll move on okay all right so here is the agenda for today uh we're gonna start out with administrative stuff uh then cryptex frameworking uh skip rc 7983 this uh some quick uh presentations on uh web transport liaison i guess uh will you'll you'll handle liaison because johnny bar has coveted um"
  },
  {
    "startTime": "00:06:00",
    "text": "and then uh stp for quick and then a v3c and then we'll wrap up and figure out what to do next so lots of lots of items on the agenda okay so here is the status i think where we're at um so the two most recent items we published vp9 is in the rfc editor queue i guess cryptex we're gonna it has finished itf less call on the fifth and and uh sergio will talk about the items to wrap it up uh bbc just completed itf let's call today um and uh we will be i guess talking about that on the list uh stefan um it's not all the reviews have come in i guess i think that's still true uh and and then mo we'll talk a little bit about frame marking where to go next um we have completed working group less call on skip um and we'll have some slides about that and then we have two drafts ebc and 7983 bis which are adopted um one thing which has come up with cryptex i think you've probably seen this on the list as an ipr declaration has been submitted from qualcomm and i sent a notice to the list on the 7th and so we are required or suggested to ask on the list whether there's any concerns relating to that ipr declaration or let's just say uh are there any objections to proceeding um with publication we have not heard any objections on the list so far uh i guess there's no one in the queue right jonathan wants to speak up no i don't get anybody okay so we'll assume there are no objections all right um so we'd like to turn this over to sergio to talk about cryptex"
  },
  {
    "startTime": "00:08:04",
    "text": "hello so i will quickly go through the status of free test so this is like this hearing you you know you don't hear me now i hear you i hear you yeah yeah so we have reviewed the uh received the reviews from the sec the section gennady art and we have a bernal created one issue in the in the github repository to track each of the of the reviews the first one from the section was just bullish and nadia's that are i have some well let's go to the next slide so either the feedback and then that has been taken and the remaining things that need to be approved so the first first one is a additional about the sdp declaration that we currently say that the sap the attribute takes no value and they complete that why no value so i try to find the definition that it was in the in the in the sdp in the uh when we define the sap attributes and it seems that it is a an [Music] attribute a technology is a property attribute so i have two proposals to to change this and this to clarify it a bit further so i'm not sure if which one of both is more appropriate so if i mean we can do a quick if anyone has a quick fit but now we can take the the action about which one would be best and if not we can just if you could comment it on the on the issue it will be great"
  },
  {
    "startTime": "00:10:01",
    "text": "so the first one is just changing the calling it appropriately attribute so meaning that and i'm just referencing the their c for what that's mean and the second one is is adding a bit more test that as it is a property attribute it takes no value so i'm not sure if anyone has any opinion on what would be the best way to go forward some they sound pretty similar to me yeah i mean this is just as well we are not very yes i don't i think that probably the second one is is good enough anyway i will let the issues here and this is so if anyone has to provide any further comments you can do it in the indie and if not i will take i will just merge one pr with one of both of them so the nsa feedback is a that is when we talk about the encrypted region and it was not clear what would mean the the rayon for them so i just replaced the the region to agree by the the term that it is using in stp that it is the encrypted portion so we use the same name that it is defined in the in the in the in the rtp rpc so there should be no no ambiguity now and there is a pull request there's just two waiting for to see if anyone has any comment on that but if not i will just merge it so next slide and this is a was is well it's a a change in the wording that when when we explain what should an implementation do if in case that that the"
  },
  {
    "startTime": "00:12:00",
    "text": "that that chris said well it was negotiation was not negotiated but it was considered as mandatory for the for for the implementation so we said that then we should reward this so i have proposed this this alternative word link just to make it more clear that what that is a recommendation to implement so this is again in the pull request so if anyone and has any feedback about if if it is okay or not i am i will proceed with it in the following days yeah just one comment sergio this is in receiving right so it's saying if the receiver rook is requiring cryptex not the sender um for both i would say yeah on the sender side at least in the api right if it's required if cryptax is required and it's not negotiated then it's it's not good it's gonna negotiation's gonna fail um i don't recall well i i will check what you can do what you mean and i would say in the api there's just two settings right require and negotiate negotiate allows it to go forward if it doesn't negotiate it require requires cryptex yeah but that would be in the in the w3c api right right right so so i mean i think that this is way to explain what happens if you put negotiator required and and it cannot be negotiated yeah it's just similar like if you consider it specification mandatory it just could be a little bit more clear like if it's mandatory to use then it's mandatory to use and it can't it's not going to send right if you see what i'm saying"
  },
  {
    "startTime": "00:14:00",
    "text": "yeah anyway i think i think the terms are a little bit a little bit confusing yeah i will review it and see if it is affected in the sender and the receiver or both and and i will clarify it a bit further so next item is the next slide please and there was a feedback about a typo in the in one of the diagrams that has been already fixed and then a comment that if we should define the enchronics for srtps src and csrc and the other ones i don't think that it is needed at the s8 if you are looking at this surface and the last one is a typo that has also been fixed so this is all the so necessary please so this is uh there are a couple of them next slide so i will um if i don't hear not hear any feedback from the issues i will just merge the pending prs and i will review the item that we have just does just discuss about the latest clarification about the mandatory to implement in the or how to use in the center and the receiver and when it is the and i will then create a new draft and unpolish it so we can continue the process okay thank you sergio okay thank you too oh okay can you hear me okay yeah all right uh so uh this is the current status of the uh frame marking draft um it's gone through uh uh last call and uh"
  },
  {
    "startTime": "00:16:02",
    "text": "received mostly um editorial and meta uh feedback from from the area reviews there's a i didn't include the text of um of all of the reviews or the text from the draft that was being referenced because they were mostly editorial and meta level comments um there was just only one that's slightly substantive that i have a quote in here from from martin that we can we can look at but basically uh the gen art area general area wanted to clarify the scope of the experiment its timeline goals and ionic changes i looked at other experimental drafts none of that is in any of the other drafts so i'm not sure why it's being requested here um we can add a blurb of you know very general vague language i don't know if it really does any good um the larger issue here though it's more of a meta question but the larger issue here is that um i don't honestly consider this an experiment i don't consider people are experimenting with to see how things work out and then change something you know promote it to propose standard if not people are either going to use it or not use it maybe more fit but that would be a totally new draft you know a different version of the header extension with with new semantics um so i guess the question for the for the work group is you know do you really all still consider an experiment and if you do do you have any input on what the scope goal and time of the experiment should be if not i'll add some very generic language yeah i i think i i agree i don't really consider an experiment either i think there's a tendency to use experimental to mean you know i don't think it's good enough for proposed standard but we still want to publish it but i think maybe we should say informational instead um if we meet if that's what we mean um"
  },
  {
    "startTime": "00:18:02",
    "text": "possibly we should talk to our area director about this unfortunately he's not here who's very directed the major distinction of an experiment is it could be become a proposed standard in the future whereas informational would wouldn't be promotable but this idea that has to be a scope and time doesn't make any sense i've done multiple experimental rfcs that didn't have a scope of time and a goal i mean yeah i guess if we want to just say well let's ignore this and see if the see what the um my ihg says i'm fine with that um yeah i mean one thing about experiments is you're kind of admitting that things may change you know we've done i counted at least four of these exp these kind of rtp header extensions forwarding extensions right so it's not like this the whole thing is settled and we understand that that's one could be one interpretation of experiment yeah like i said i can add very generic language you know maybe mentioned that you know you know experimental um you know uh implementation and deployment experience with this and other header extensions like the av-1 dependency descriptor and you know see the pros and cons of each i can put some very generic language around around that in the draft if people think that's useful um people are using you know some sort of frame markings whether it's this or their own or newer ones that are under development um so i don't think it's uh i i don't think it's going to be a concluded experiment in that sense people are going to keep evolving you know how they're working video payloads um but they're obviously they're they're not all tied to this document because they're multiple documents"
  },
  {
    "startTime": "00:20:03",
    "text": "but um yeah i mean it's it's hard to give it structure like i don't want we we don't have a charter item in the working group to write up a review of all these kind of documents right and what we learned from them it wouldn't be bad to do that but yeah i see stefan in the queue so i i have seen you know a little bit of tightening uh around this experimental status over the last few years um i think you guys have seen that probably too i'm not surprised that this comment comes up i would not recommend to go into informational with something like this you have to rewrite a good part of the document so i think more suggestion about putting some blah around to keep the procedure gurus happy and or even if they are not happy but to to address their concerning quotation marks and uh and then you know ship it and be done with it is i think the uh part of the least resistance thank you okay so how about propose the text on the list uh propose the change on the list and see if that's agreeable to everyone and that'll go into the next version for or negotiate would be nice just negotiate with them and then go to the list isn't the same people as the iesg and it's the iesgu you ultimately have to make happy so okay so i think i'll i'll propose some text and send it to list to close that one out uh upstairs purely editorial i'll add some stp reference there uh security directorate uh same i'll add a reference to um rfc8285s comments about header integrity protection"
  },
  {
    "startTime": "00:22:00",
    "text": "inside of the security considerations um uh martin had uh some comments um in the art review uh about the wording in one section uh being better than the wording in the subsequent sections uh so i'll i'll go ahead and just make the wording for tit and lid more uniform to match the first section 331 it's just a little bit more verbose but um it's a short document anyway so we won't extend the length much um the only one thing that's uh semi-substantive is that uh he thought that the the statement about the header extension values must represent must match uh the rit payload he thought that was unenforceable um i don't have a strong opinion of whether or not that sentence should remain but i mean obviously you don't want someone shouldn't be misrepresenting what's in the payload by adding you know bogus data in the header extension maybe that doesn't need to be said um but this was just uh trying to get at if a sender knows its payload it should uh you know mark the header extension properly to match the payload uh or if anyone has a view on whether that's just an unnecessary thing to say it's obvious it's a reasonable thing to do right i think so yeah i mean the only thing i could think is that you know like i can imagine cases where like you know the you know it's actually more complicated than that this is a simplification but it kind of matches it's still a reasonable thing to do you know if you know if what you're doing is more complicated than represent which is you know honestly often the case but um which i think it's um i don't think i mean maybe it's enforceable i mean i don't know what unenforceable means since we don't have enforcement for any of this right but basically if you don't do this it'll break so that's the whole point where we"
  },
  {
    "startTime": "00:24:01",
    "text": "could simply yeah the whole point of a must is do this or things won't work right right and that says exactly do this or things won't work right so yeah there's also the question of who is it enforcing right because there's the sfu which is may not even look in the payload right so it's just doing everything based on the header extension values and then there's a receiver and are we saying the receiver should check that they're the same i don't know the receiver doesn't even may not necessarily even look at the uh header extension right it may just look at the payload yeah like i said i think that they do it or won't work right not up somebody has to enforce it for security reasons or anything like that yeah um so i think it's i mean i need to look at the context to make sure maybe it's confusing in context but i think it's you know as a requirement on its own i think it's a reasonable one yeah so um the the only thing that i would say maybe uh would appease everyone is that the uh we can clarify that this is that the sender should uh make should write the header extension to reflect what's in the payload right um unless it would have enough information sometimes we wouldn't so why wouldn't you and then they're going to ask why when wouldn't you so that's what i was saying should and then unless you're unless you're unable to um unless you don't know uh the contents of the pillow well enough to mark it that's that's reasonable short unless you don't know seems reasonable so that that would make it unfor enforceable and clarify that's the sender that's doing this not receiver enforcement or sfu checks okay so that seems like a reasonable way forward on that one and then others were just editorial and nets so on security will mention you know the privacy and traffic analysis implications of having this uh um in in the clear"
  },
  {
    "startTime": "00:26:00",
    "text": "um and some knits on formatting uh and maybe uh people have an opinion about whether or not the title of the document should reflect that it's a video frame marking header extension um starts to get long but if people think that's a useful clarification i'm okay with adding video to the title it's not really applicable for any other media as currently written well you know once you hit once you hit keyframe you should kind of realize it's video but whatever so no objections i'll just add video to the frame marking title video frame marking to the title um and and that's it next slide so there'll be i think just one more slide on next steps uh so i'll propose the responses on the list and make sure everyone is in line with it since this meeting is not uh doesn't have that many attendees um and then assuming no review uh feedback um i'll update the draft and we'll submit version 14. sounds good hi this is mike fowler we're presenting on the rtp payload format for the skip codec been here before over this my colleague and i dan hanson will go over some of the concepts and the comments that have come up from the abt core working group last call next slide please the intro is discusses the organization we represent"
  },
  {
    "startTime": "00:28:02",
    "text": "we've been around a while um the indented second bullet is probably the most important concept to understand that skip is an application layer protocol which uses rtp as a transport for negotiating secure session capabilities um the next discusses the problem that it often doesn't make it through some of the network equipment that's out there uh the last bullet discussed introduces the comments for the working group last call next slide please this is really the heart of what we're trying to get across to the the people who will find our traffic on their network that we have registered two uh media subtypes audio skip and video skip with ayanna the format of those to transport traffic over rtp is shown at the bottom with the mapping of skip slash audio skip slash 8000 and video skip slash 90 000 these are the transports of which we will we'll do our work the next slides will go over the comments and then you can take it from there okay uh first question was referring to some of the uh language if you will of end-to-end security and what exactly that means in the context of skip versus other contacts bernard i guess you had this question regarding in reference to s frame we didn't we don't feel that s frame is under consideration for skip at this point only because uh that's kind of outside the scope of skip if you will it's um skip is what we will be a point to multi-point when using you know using a trusted uh multi-point control unit mcu uh for what we're gonna be for for multi-party video conferencing so"
  },
  {
    "startTime": "00:30:00",
    "text": "that's kind of where where we are with that and that kind of leads to the second question there of seeing uh you know application layer security while i believe we're clear in that in the section two where we say it's an end-to-end security at the application layer so unless there's any strong feelings otherwise i think we're going to stick with that um bernard if you have any questions that you probably it was just it was just that it's at least the way the term has been used uh it refers to going from one endpoint to another endpoint and since the mcu is trusted in this model that that's not really the case for skip um i mean you can use the term it's just it's just helpful to for people to understand that the model is is not that of an untrusted mixer right that mr mixer's trusted so the mixer is the end point when you use the term end to end that's that's the only confusion right and we didn't really have in in under when we came up with the text we weren't really thinking necessarily of the the multi-point video mixing situation for that guy normally skip's been primarily used for at this point is is end-to-end user to you know endpoint endpoint at this so there really hasn't been a central mixing unit if you will to at this point um so it's kind of where we tend to tend to go with end-to-end security at this point so we consider that the social security association will um be a point-to-point type of communication and there if there's or into a conferencing mode um depending upon what was negotiated in this session it'll depend on how it'll be handled but from the networking perspective which is really"
  },
  {
    "startTime": "00:32:01",
    "text": "where this this rfc is trying to focus um they will not have any uh knowledge of what's going on other than the rtp payload types we addressed in the previous frame so all this should be occurring transparently over the network okay any more questions on that or we move to the next slide okay um yeah so the term bit and then bit integrity um i guess we're sort of looking maybe some suggestions like so we can um maybe remove that that term from the uh from the text as it is i guess maybe solicit some suggestions about you know for example changing it to no transcoding and no lossy compression techniques shall not be performed on the skip payload so i guess if there's any recommendations for better text just to say don't don't modify don't do anything to our data just let it pass through no transcoding none of that stuff i don't know if there's recommendations for any better terms to use for that that we could that we could use no transcoding and no lossy compression or anything to that extent so okay uh next question was about uh"
  },
  {
    "startTime": "00:34:01",
    "text": "audio and video multiplexing at the application layer um again we hadn't really considered that in at this point and it's kind of also i think beyond the scope of this skip rf uh the skip request if you will because that can be implemented independent of how we declare uh declare skip at this point so i think our position is we it's kind of like i said that's kind of outside the scope of this of this and similarly for the reference for the bundle the rfc 9143 it's the same idea that it's kind of outside the scope of of skip at this point so we hadn't really considered it and if you want to implement it i think you can do it without any changes to how we've defined skip at this point so okay yeah so it's not these things aren't forbidden they could be you know in future it's possible they just negotiated like they would be in any other so they could be negotiated in the future it's not like inherently incompatible correct i mean like i said i didn't see any i didn't see any i read through those real quickly and i didn't see anything that could possibly interfere with skip at this point how we've declared it so i think that they are beyond outside the scope of this and shouldn't interfere with uh what we've defined yeah actually uh that does remind me do um uh i guess jonathan would there have to be like an indication of whether uh typically when fungal can be supported you have to indicate the the parameters of it like is it transport or identical you know not for payload types i don't think not for payload types okay yeah so that's fine yeah"
  },
  {
    "startTime": "00:36:00",
    "text": "okay uh next slide um and additionally uh rtp and rtcp multiplexing again that should be something that should be in can be independent of the skip protocol and should be outside the scope of this rfc again there's um from what i was looking at reading real quickly on the rfc there's nothing in there i mean these devices can support you know doing rt pc or tcp on different ports you know using the the a line for rtcp for specifying different ports rather than the normal plus one that type of stuff but there's that rfc also references and i think that's outside of it shouldn't have any effect on how we do how skip is defined at this point so yeah so the overall point was just to indicate that uh skip doesn't prohibit any of these things they can be negotiated separately as they were you know uh that was the only thing i was wondering there weren't there's no inherent incompatibilities there correct correct and additionally again the same basically the same thing also applies to the additional extended rtcp feedback messages in rfc 8888 um again that's should be outside the scope of skip at this point so you know for using video and things like that what you probably normally would use in an h.264 session or compatible codec like that should be transparent and use those same methods within skip so yeah um i guess is it is it assumed that you always use h.264 within skip for as a video codec is that the only one you could use or could is it possible in the future that there could be other ones"
  },
  {
    "startTime": "00:38:02",
    "text": "um there could be other ones in the future that's the only one we've really considered at this point um it's something that we can define which hopefully should be outside the right we can define internally or just yeah you could just say that for feedback messages the underlying video codec applies whatever that is well it's a negotiated yeah it's a negotiated video session within the the the items identified in the rfc um so it is within the skip standards there's profiles that are some have been developed some will be developed later but the transport path is what we're really looking for in the rfc okay well i think that pretty much wraps up the the questions and responses at this point so i guess next next slide i don't know if mike you want to wrap this up here yeah um i think it's a the problem statement there to be beginning is really why we're here because if people don't recognize the uh skip audio and video skip um rtp decorations then it can often be stripped out in some settings it's even unintentionally stripped out because the particular network product doesn't have a setting the pull down menu if you want to call it that that says skip in it so in in coming forward and then bringing this to light that this what this protocol does and and the community that's out there that supports it and you establish products that are already out there that are using this um we need some way to get this this"
  },
  {
    "startTime": "00:40:02",
    "text": "globally accessible reference material out to them so on this particular draft rfc the last call ended on the 8th and we've tried to address the comments that we've received so as we move forward with this where each time we we move another step closer so we're here to ask once we've made the minor adjustments to the the rfc that the draft rfc we've presented what is the step after that well the next step would probably be to kick off a number of directorate reviews including like the sdp directorate so you may you'll get reviews from these various reviewers like what you've seen from the other presentations so far and then after that would be itf less call or publication request okay well that's helpful um to know that too our first step is course to get those changes in place and get them up there and once that is done um i assume it's the co-chairs take uh on the role distributing this to the the other principal people that need to know uh well we'll i guess we'll jonathan and i will talk but we'll probably initiate the directorate reviews and the the publication request form is changing but so i'll probably do that first and hopefully it'll settle down um and then we'll start looking at the pub wreck after the uh directorate reviews are done yeah yeah i guess we probably want the revised id before the directorate reviews oh yeah yeah definitely yeah yeah yeah we'll get we'll get that out to you next week so"
  },
  {
    "startTime": "00:42:02",
    "text": "sounds great all right thank you is there any other any other questions anyone has okay stefan this is not a question this is a comment um uh i i see i have observed something that i can that looks to me like an orchestrated campaign in showing support um for for the various stages that's really not necessary to that extent yeah that's that's just blowing up me to making this traffic uh you know you don't have to do that it's likely to me it's annoying and it doesn't add anybody yeah so i probably don't do it thank you steph and i agree with you um it's been a little annoying to us too but we at the beginning of this we were asked that uh that we involve our working group uh community into this um so we did uh if you're right i think i think beyond it was helpful for the adult to make the decision for adoption but at this point the process doesn't require that kind of level of um communities of uh external community support so long as it's clear that there is a community for this which is clear so i agree all right thank you okay uh so this is a presentation about rfc 7983 bis um just a little bit of overview that's an update to 7993 section 7 documenting quick multiplexing"
  },
  {
    "startTime": "00:44:00",
    "text": "and basically adding that to the protocols that can be multiplexed and it also updates the dtls content type field to reference the nuabc but no other change is needed so just to remind everybody about how the multiplexing works it basically works like this i would emphasize that this is how it works without the quick spin bit we'll talk about that in a moment uh sorry without greasing of the quick bit sorry uh spin bit is irrelevant um basically so the if you have a quick long header it's from 192 to 255 so above the range of rtp rtcp and then if you're talking about the short header uh it basically can overlap with a turn channel but otherwise it's between dtls uh and the rtprtcp range so that's the scheme that's being proposed now in terms of the recent changes from o2 to o3 we looked into the compatibility with quickv2 uh it turns out quickv2 doesn't introduce any changes that affect the multiplexing so it's fine with that we updated our reference for dtlsv3 um then for o3 204 we were made of aware of the quick bit greasing draft which does have a major effect upon this because it essentially allows the second most significant bit of this first octet uh to to change right that's what the greasing is um so if you are negotiating quick bit greasing as a transport parameter and quick uh that is incompatible with this multiplexing um and it's incompatible in a fairly major way because if you look here if you remove that second bit set it to zero then the quick long header will overlap with rtp or tcp and similarly if you remove if you set that second most significant bit to zero in the short header then you will overlap with stun and zrtp"
  },
  {
    "startTime": "00:46:02",
    "text": "and dtls so it's it's a it's basically makes multiplexing uh infeasible it'll it'll break everything um so we added a paragraph to section one basically saying indicating it's compatible with quick v2 but not with quick bit greasing and so basically the idea is if you want this you have to not negotiate bit greasing so you don't indicate support in a transfer parameter you don't negotiate it so you won't break multiplexing we also added a note in section three just saying that you can't negotiate bit greasing if you if you want this to work so here's the a little bit of text from section one of the itf quick bit decreasing document uh describing what what greasing is um and uh and why um there is a reference to dmox that is a reference to 7983 not to this document which is a little odd because 1793 doesn't talk about quick but presumably that was done because this document was not had not advanced sufficiently enough to be referenced so uh i'd like to open it up to working group discussion uh you know are we done are we ready for working group last call uh if people have concerns uh what do you think i think it's i don't know of any open issues and i don't think anyone else has any so i'd say it's ready for last call and you know if we want to try to encourage the quick grease draft if it's an"
  },
  {
    "startTime": "00:48:00",
    "text": "appropriate state to reference this it may get a cluster it'd probably be a good idea but it's not necessary if they don't want to that's not our decision so yeah i'd say working for classical person and i guess since bernard is the author i would need to be the one to do the last call is anyone else in working with have any thoughts on on the greasing issue [Music] i think the thing is you know it doesn't work with the amount of liking so don't do it is probably the right answer but you know we might need input from quick stack people to say hey can you do you have a knob to turn this off but yeah that was that was my that was my question it's yeah it's not there is no such knob at the moment but yeah i suspect we should probably um um we should probably uh uh forward this to the quick working group to say hey we're doing this reviews would be welcome for working with wesco yeah i think the multiplexing graph is uh fine uh the way that you mention all the issues makes makes sense uh personally i think the uh bit greasing will die even if it's published i don't think it'll ever be used and we have we have many instances of this where exhaustify the first version defines something and"
  },
  {
    "startTime": "00:50:01",
    "text": "it just uh you know lingers forever and i think it's too late to already think that you're going to reclaim that bit now by greasing it and make it you know available you don't even know what you're making it available for so in all video payloads you know we have a similar thing we have the forbidden bit in mpeg um you know it's a relic and yet you know it still lives in almost all of the video payloads i think we'll see the same thing at the transport level with the quick second bit okay i think that's it for this item thank you hi hello can you hear me okay so i wanted to talk about congestion control about rtp rtp real quick i've been reading the paper from matisse and gilbert on the year and next slide and for remainders this paper investigates how to do proper congestion control for real-time media over quick but an rtp mapping earthquake and do some experiments to test a combination of conjunction controller algorithm for example especially scream over quick with a neoreno and to compare with a screen over just udp or screen over quick without new"
  },
  {
    "startTime": "00:52:01",
    "text": "winner and to to see if we can avoid a duplicate signaling between our tcp and quick statistics so next next slide next slide please so i was looking at their results and um the result about scream on top of new window was uh caught my attention because uh when you decrease the link we can observe that the transmitted between drop to zero and even if you increase the link capacity back it never recovers so i decided to investigate a bit further about what was happening so i tried to reproduce the experiment from the open source code within the same network emulation with tc commands and docker containers and the next slide please um i reproduced this behavior but it was not only happening for screamover new we know it was like randomly happening um for other test cases as well uh even um just scream over udp every time scream was involved there was this behavior happening randomly uh so i considered this case with a constant rate a constant link limit and we can see on the figures on the top right that the the target keeps decreasing over the time which was uh kinda well will so i was thinking there might be a bug in the implementation next slide"
  },
  {
    "startTime": "00:54:00",
    "text": "so i displayed the all the screen statistic i could and i observed in the that the rtpq delay was really high once we we did we decreased the link capacity so the rtpq is where steam screen stores in rtp packet because in the according to the rfc screen does not allow to transmit directly the rtp packet over the network it is enqueued in the eq before and this screw is being cleared when it switches a dv max value which is computed from the rtt estimated by a scream and then that's that is what was uh happening and this queue has been cleared over and over again and that is why we we have um like a zero mega percent betrayed um because on all the rtp packets were being discarded next slide so in the implementation when you are using screen you need to to call a specific method to know if you can send a packet on the network or not which is it's okay to transmit it will it will return you like minus -1 if the rtbc is empty so you can't set anything or the congestion window is full so you don't you it doesn't allow you to to send any packets otherwise it's not a new time if it is less than one millisecond you can send packets otherwise it is above one millisecond this is the"
  },
  {
    "startTime": "00:56:00",
    "text": "pacing mechanism so you have to wait this amount of time before sending the packet and when you decrease the link limit this time written by this method was always over one millisecond so in the implementation in the implementation of the experiment when it was over one millisecond you never dequeue the packet which mean the attitude was always full and was eventually clear so by taking into consideration this last scenario this last return value i had like new results so next slide and we can see that now we have like a no more abnormal behavior for scream that even for the constant hitting capacity it is um always around the link capacity and it's no more decreasing over time i'm also looking at the and the quick statistic from the q log file and then we can see there that neurino when you use neurino it is always limited by the application the condition window estimated by new we know is never reached by debates in flight and there is no loss event so we can say that whether you use neurino or not on quick it will um maybe it will be the same behavior and that's what and we can see this next play next slide we can see this here so"
  },
  {
    "startTime": "00:58:00",
    "text": "the individuals look like really similar whether you use neoreno or not uh next slide please so just in conclusion uh i've been reproducing this quick condition control experiment and i think i found it back in the implementation and after things in fixing this i could see that the behavior of screen on top of neurino is like really similar to running screen alone because neurino is always application limited and as a next step it could be interesting to to find a network scenarios where we can't see neurino react like what it could take to to make a loss event or make new we know reach the congestion window and also testing other quick implementation and congestion control algorithm i'm also working on the on a new experiment towards the webrtc traffic from a web app on chrome through a quick channel to do a network email email emulation than this so it is still in development and i hope to have some some good results about this so that's it for me so if you have any questions it's a spencer yeah uh thank you thank you for doing this work david uh i really appreciate it and it was on a uh pretty important topic for uh discussions that uh i've been involved with certainly um is there a place where"
  },
  {
    "startTime": "01:00:02",
    "text": "you describe the uh environment for the experiment a little more precisely like you know what bit rates and thinking and things like that uh that you're using no i didn't publish like the exact environment i was using i tried to reproduce the same as was described in the paper in the origin okay okay okay good good uh and uh like i said i just wanted to thank you for doing the work a lot and i look forward to seeing uh your continued results enjoy your idea thank you it's a yogi um yeah i mean there's something in the kill comment i mean i guess sort of the two take away from this is that um scream because it's keeping low delay basically limits you more than neurino and nurino is essentially not doing anything is that sort of the neurino is always application limited so it'll always say yes like does not react in the in the experiment okay yeah and i guess sort of um it's the interesting thing is you know as you know we've always had the intuition that you know rtp over tcp is terrible but i guess the lesson from this is that's because of head of line blocking not congestion control so that's an interesting takeaway well also keep in mind that this was a single stream experiment so simulcast would behave a little differently depending on what level you're doing this is what the screen is conduct what could scream suggest controlling but yes"
  },
  {
    "startTime": "01:02:15",
    "text": "can you admit uh i see york in the queue i guess i'm sorry i'm not sure who's for who can you hear me yeah yeah ah all right then like first i think you're just got to lower that i have a question to i think it was like 36 um because i think this fix it presented might include one fix we already presented in february 2 which was that we sent a lot of rtcp feedback which caused the contrasted feedback link and in turn resulted in a bad bandwidth estimation and here on the slide says the receive bandwidth in the blue line so i assume this is rtcp on the yes received by the sender um and on this slide it's like something around 800 kilobit i think if you go to the results right after this like with the fix i think it is like 200 dish or so so i think this might include the fix we also presented in february and i was wondering if you have results without this fix included because that might be interesting when you look at different pacing mechanisms right because you have running a screen pacer at the application layer and if you disable this with a list which is kind of what you did i think"
  },
  {
    "startTime": "01:04:01",
    "text": "if i understand it correctly then you only have the new obama passer below and might be [Music] interesting to see the results if there is a difference between running both or only one of them and i think that might be interesting to one part in our draft which we're going to present later yeah so first thank you very much david for this video and i think that this also matches my expectation about how i expect any delay based congestion control versus a low space one like neuro so i think that it would my good feeling is that it doesn't matter how much even a small castle how much pervert we send in with the screen that the key is going to see what happens when when new renault key is beginning because for example you're sending a file with a quick stream and and there is a screen a screen screen going running simultaneously and i think that this is the the main thing to see what is the effect of of a new reno uh over the stream but new reno is kicking in because there is another it is sharing the link with other with other lost base congestion control do you mean sharing the link or sharing this congestion state like something else i think that it will be kind of the same i mean i think that both i think we need to test both the scenarios but i expect the same behavior to happen"
  },
  {
    "startTime": "01:06:04",
    "text": "but yes i think that we need to to test first what is a uh the what happens when when we have a new reno or two one screen stream and one quick stream with a that it is a competing about the bandwidth of the on the same new reno transport and having a one transport with a new renault and the one transfer with a with a stream alone about this uh yeah and so i am not sure if i understand correctly but if it isn't correctly your suggestion is to measure that we uh when exactly kicks in and stops the screen control traffic from sending and test this um once with only sending media over screen over neutrino and runs with sending media over screen over your window and in parallel send another stream which is only controlled by a nuvenal right so we have some tests on that and i think we have presented that in february too i'm just not sure because in that case what we saw is that um as soon as we start sending data which is only controlled by the renault controller for example on a quick screen next to the datagrams then the stream basically takes up all the bandwidth because yeah it just uses all of the congestion window in urinal and scream sees growing cues and then just degrades the target rate but if the implementation has the back that david has discovered i mean the"
  },
  {
    "startTime": "01:08:03",
    "text": "it is likely that the screen going to zero is is also maybe because the book so i think that we should revisit this this these results anyway okay so anything i'm gonna say anything else otherwise we should move on to this new york's conversation presentation i'm sorry yeah hi uh so we have not done any new experiments today we just like to present an update on our draft which we implemented last july and um we have basically done a couple of restructures in the last weeks and months and two versions and i would like to talk about the main sections we have on the draft now um uh so the first one is about encapsulation and i think the biggest slide we have added is that we included a version for rtp over quick streams now and previous versions was only datagrams and that was also what we had in the tests we presented the last two things and the version for rtp over quick streams now specifies that"
  },
  {
    "startTime": "01:10:00",
    "text": "one stream is used for one application data unit so a sender can put one application data unit in an rdp packet and send that over a stream and as soon as it's done um close the screen um you want to go ahead just now or [Music] yeah yes i was wondering what is an application data you need and how do you map rtp packets to quicker streams what what we have from the layer path is that we have some uh i guess types which are different for different types of data and um when we want to put that into an rtp packet and to the quick screen we just say that there's or that we put one of the units which comes from the player above into the rtp packet and only one rtp packet on one stream and then afterwards the stream has to be cancelled does that answer the question basically treat this as an rtp packet with an infinite mtu so basically put whatever the largest thing that's useful is one packet so like ideas like for a video frame you put an entire video frame yes exactly okay um yeah then uh exactly when the [Music] package is no longer needed at the receiver or the sender says it's too late to transmit this again for retransmissions for example it can cancel the stream at any time and that way we can use the same encapsulation format for datagrams and screens for both all mappings because if you remember we had the encapsulation for datagrams which included a flow identifier and then the following rdp packet until the end of the datagram and now we use the same thing for quick streams prevent the data the rdp packet with the flow identifier and then"
  },
  {
    "startTime": "01:12:01",
    "text": "fill the rest of the screen with the packet we will get to rtcp on a later slide and on that later slide we will talk about how to reduce rtcp overhead as much as possible by reusing quick statistics which are present at the connection and one thing to keep in mind for rtcp for stream based rtp transmission here is that we try to use as much as possible quick statistics because if we use the rtcp which is of course mapped to quick streams in the same way rtp packets are then there might be um wrong statistics coming from the rtcp because of underlying quick retransmissions and yeah so this way we should hopefully be able to use click connections also when no datagram support is available in the implementation next slide please so now for our tcp um we allow all rtcp by default like usual and can send rtcp packets in either datagrams or streams as described in this previous slide and then we try to provide some guidelines for how the most common rtcd packet types can be mapped to quick which means that the data which is usually transmitted from a receiver to give statistics to the sender can be inferred from the quick connection statistics and um yeah got received by the sender about using rtcp and for that we have a section which now um describes in more detail than i did before for specific feedback types how this feedback can be extracted from the quick connection instead of using our tcp this mostly"
  },
  {
    "startTime": "01:14:01",
    "text": "works for receiver reports next ecm congestion control feedback and some parts of extended reports and then of course in the future if there are more rtcp packet type definitions that can be extended by future mappings and for a few other packets one second it like read sender reports for example and a lot of application layer control packets this cannot easily be mapped too quick um and in that case we of course don't need to use rtcp what is the issue with yes oh i mean i mean they cannot be represented from quick information is what you mean they need to be yeah exactly so when the sender sends sr to the receiver or the media receiver he basically does that to provide some timing information and we cannot easily map this timing information to quick connection statistics and of course the sender report also includes receiver report afterwards then that is the same as the receiver report above then one open question we have for this section is whether we actually want to just map 101 all the rtcp contents to the quick connection or whether we actually want to use all the quick connection statistics because there are probably a lot more data points from the connection and quick than just by mapping the rtcp itself then next slide next slide i'm still seeing the old one thanks um for congestion control we also restructured a bit and added more information about how congestion control can be done for or in different options"
  },
  {
    "startTime": "01:16:00",
    "text": "um we give the sender the choice how to do this and the first option we included is to do congestion control only at the quick layer and that quick ideally lose use a low latency delay based congestion controller and possibly one of the rn high proposed ones and then expose a bandwidth estimation from this quick connection to the application to allow the application to configure the codec and in this case the application doesn't have to do any bandwidth estimation itself because because it can carry this from the click connection and then the second option is to use the conduction control at application layer this could be useful for example if there's no low latency congestion control available in the quick implementation or if the quick implementation does not expose a bandwidth estimation for the application to use and in this case we could use screen or later or gcc on top of the application there is a quick implementation and as we have seen in the presentation before and in our results in february we [Music] saw that it is possible to run scream on top of uh and um this seems to work with application limited traffic as long as the traffic is application limited and of course there may be other congestion control algorithms running in the quick implementation for which this might not be true so in that case we still added a sentence explaining that it may be useful to disable quick congestion control completely when it is done at the application layer for the rtcp feedback for congestion control we did not include anything in this section because this should all be covered by the rtcp section before"
  },
  {
    "startTime": "01:18:01",
    "text": "next slide please so then we have some signaling we included in our first draft 0 last year section on sdp signaling which we have not updated since and now there's also spencer strat which is going to present later so we didn't focus on updating our section on this anymore that's that talk to spencer about what actually need to be signaled we have a few issues or a list of things which are included in our zero zero version and which we need signaling for so the things we included in our zero zero draft are in this slide and um this is basically connection setup and removing adding flows from a connection and then of course the media flow id mapping for the flow id and the encapsulation and then one thing we realized recently is how zero rpt or what zero rtt might have or what implications your rtt connection setup might have on rgb over quick and signaling and this might be for example useful for avoiding clipping and connection setup then the second slide on sdp signal please there's one more yeah thanks um this is mostly issues we have not included in our zero zero version and since that we'll probably go to spencer's route and i think he included one or some of these already in the presentation today later or in this issues list um of course since we now have streams and datagrams it must be chosen somehow which of those to use uh one option could be that the receiver indicates some capabilities to the sender and the senders and chooses but still we need some baseline to be"
  },
  {
    "startTime": "01:20:00",
    "text": "defined then for the rtcp statistics replacements um we need some capability signaling which says that a receiver or sender is actually capable of using quick statistics and wants to turn off rtcp for certain packet types and congestion control itself can then be done by the sender unilaterally but of course he still needs to signal the correct feedback or negotiate the correct feedback mechanisms yeah sergio let's see one thing that i initially should be considering this draft for in the sdp how this um especially i'm thinking about the the identity of identity identifier how that interacts with with ice i mean if you are thinking about using the multiple flow within the same quick transfer how does it work with with the using ice is something that we should consider uh how to solve it here or not yeah i one i think you're talking about both in the same connection right i think that was one idea actually why we kept the flow identifier not only to demultiplex different rtp streams but also to demultiplex between different applications running on the same application and one question we have as a discussion point in our draft is how this flow identifier can be managed efficiently between different applications because i think http 3 datagrams also use the flow identifier and if everyone defines their own way to demo detects different flows"
  },
  {
    "startTime": "01:22:00",
    "text": "that might be a problem but yeah that's also discussion point in our craft so you mentioned that do not use timing information from rtcp reception so does that mean like sometimes rtcp also supports feedback messages such as custom feedback messages such as viewport information and other stuff so sometimes we may also have information like we probably need in a viewport from certain time onwards or something such kind of timing information may be incorporated into the rtcp custom feedback messages so is it just like you just ignore the rtcp packet receiving time or even the time information provided in the rtcp packets also was we try to map the contents of the rtcp packets for example for congestion control feedback which says that one specific rtp packet arrived at the receiver at a certain timestamp and we try to map this to connection information from the quick layer so if the quick has information about that a certain packet arrived then we can get that in from the quick connection instead of sending another rtcp packet containing this information it's not directly about rtcp packet timestamps okay so anything in the timing information is part of the rtcp package still be considered can be considered by the application that that will not be discarded yeah i think so okay um then spencer probably on signaling"
  },
  {
    "startTime": "01:24:03",
    "text": "for the presentation as always uh looking at slide number 47 uh i just realized uh i didn't go i didn't know quite what these words meant uh i had looked at them previously but um if you're looking at slide 47 which is i think as uh sdp signaling two maybe the next slide uh when you were talking about uh exporting uh statistics from quick are you talking about exporting them up to uh making them visible to the application yeah so we need yeah the the quick connection needs to expose them to the application somehow and if that is possible the application might want to signal to its peer that it is possible to use the quick connections and no need to use rtcp okay cool thank you so much yeah you're welcome yes so i guess uh let's talk about the next steps yeah that's the last slide we have um so we would do a few more updates we have which we mentioned above and then security considerations and ayanna registrations are still missing and then the next step which would be maybe the working group adoption is something uh yeah we would like to ask them to get into discussion if that is something that might want to adopt okay so you're requesting we run a call for adoption after you uh submit the update okay i think jonathan we can take that as an action item right um yes so please note that in the notes yeah i also see a several people in the queue though are you speaking to that"
  },
  {
    "startTime": "01:26:07",
    "text": "york or i guess it's a spencer also can you hear me yes yeah okay good um i i believe the the the question for working with adoption actually since we are talking about the minimal security consideration section uh and in diana registrations mostly plus some minor updates i wonder whether we can actually get a get a sense uh right away and i'm not sure whether we actually do need to wait for an update of the draft since the fundamental aspects don't change of course certainly fine if we uh take some extra weeks until we have updated it and get it get people got more time to read but i i don't think these two things do necessarily have to uh happen in sequence yeah thank you i just wanted to say i would encourage you all to do the uh call for working group production earlier rather than later uh just because uh people like me and uh other people are kind of looking at this uh individual draft as if that uh is going to be kind of the baseline but since we haven't adopted this draft or any other draft uh that's not actually a good plan for them uh so my my from my point of view this draft is certainly in shape for us to use it as the basis for the working group to work on it um so i would encourage you guys to ask the question earlier rather than later thank you"
  },
  {
    "startTime": "01:28:01",
    "text": "and i may also infer that your personal opinion is that should be adopted oh oh oh yes absolutely all right uh i guess uh bernard i will talk about that but yeah we will sounds like we should do a call for that um sure okay all right so i guess we're going to turn it over to will law uh because janaevar has pelvic ooh yeah good morning can you hear me and see me before i launch in to the ether yes okay thank you so good morning my name is will uh my co-chair yaniva was going to do this talk but he got covered yesterday i got covered three weeks ago so i am the lesser of the covert inflicted in our group so i'm going to do this so thank you very much this is we're coming to you as the w3c web transport group so this is a group of people who are charged with creating the apis for a javascript client to be able to use web transport and most of our use cases are satisfied but the use case we care most about is the one that's still the challenge and that's exactly what we have here today it's me talking to you low latency audio or video and the problem is the client in sending data up to the server doesn't have enough information to know when it can apply a multiplicative increase in the send rate so to recover from congestion and ramp up again so we really want to know if rtp over quick can satisfy this use case and if the answer to that is yes then what measurements need to be made available"
  },
  {
    "startTime": "01:30:02",
    "text": "withdrawal be required so mattis's prior presentation is actually very very relevant to these questions we have additional slides and then we're going to come back to these questions later so if we can go to next slide please so just you know as a reminder we're dealing with web transport from the point of view of a browser-based api so web transport built on top of http 3 built on top of quick it is not coupled tightly to the quick stack so the the javascript has no access to quick there's copying happening there's queuing and buffering happening from the the the streams that the what wg streams say that might come from a web codex implementation into the send queue uh for web transport into either streams or or datagrams and the api is no visibility into the transport layer we have an interface for streams we have an interface for datagrams next slide please we this is just documenting our open issues so our open issues are about congestion control bandwidth estimation and also the notion of pluggable congestion control and i think bernard here also linked some of this work groups uh relevant discussion points on the same subject so yeah we uh well we just put down here two things which we thought might be relevant uh to your request one was the information that's in rfc 888 section three describing inform for example feedback info that was relevant potentially to these low latency congestion control algorithms and you see here packet arrival times ecm markings flows and then draft angle bart which in its o2 version section 5.1 also talks about metrics that they were using to compute the bandwidth estimation which is potentially relevant"
  },
  {
    "startTime": "01:32:01",
    "text": "some of the same things uh you know departures arrivals rtt estimations from the quick stack uh nacn so these are some of the things that we're going to be suggested as potentially relevant okay and here we see what we have today in terms of stats accessible to the javascript client so it's it's at aggregate level bytes sent packet sent in total packets lost number of streams by century siege you'll notice we did actually copy out the the rtt variants aside from the latest rtt we do have smooth rtt variation and min rtt with the same algorithms used to calculate those and on the datagram side we just have expired outgoing dropped incoming lost out going so what we're missing is any explicit congestion notification ack info the latest rtt and information about packet arrival and departure because we're we're observated away from the actual protocol next slide please so these are our core questions and maybe we should just do them one at a time um do rtt measurements need to be adjusted i i guess the bigger question here is is it actually feasible that a javascript application will be able to either apply its own congestion control or work in cooperation with a browser user agent that is actually managing the quick connection and it seemed from what matters just presented that the answer might be yes that you could you could have a default congestion control working on quick the given enough information the application in this case javascript could implement scream or another protocol and be able to meet these requirements is is that in fact feasible if the application is javascript in a browser"
  },
  {
    "startTime": "01:34:04",
    "text": "does anybody want to give their opinion to will or i'll make it a rhetorical question if there's not actually an an easy answer mattis um so i think it's hard to answer specifically for javascript in the browser um our tests used not javascript we did like we had access to the quick stack and everything in a separate application so maybe some tests on this would be good to experiment with the javascript application in a browser with their specific environment can implement this and whether this works as well as it did for our experiments and the ones they represented earlier that would be very interesting and in fact that is our request we do not have experimental or research access within our group and they're they're individuals and and organizations within this group would do so it's a clear request to make and to use the web transport it's available in chrome today uh and there's also a a server implementation uh to see and in the short term basically provide feedback as to what would be the necessary minimum uh information to be relayed to the to the uh via the browser to the javascript application so do rtt measurements need to be adjusted i i assume we could send the latest rtt and make that available uh in addition that would seem to be a good idea packet arrival and departure information is that also something feasible to relate to up through the browser to a client"
  },
  {
    "startTime": "01:36:07",
    "text": "i'm not sure if rtt measurement is that helpful anymore we included that in the first version of our draft but i um it's been now not that sure anymore if that is really that necessary we included it because we thought if the congestion control algorithm running on in the application only uses the other information to calculate their own rtt then we can give it directly from quick but i think what is more important to these algorithms now is to have information about packet departure and arrival or maybe even something like one-way delays between departure and arrival that could also work i think but maybe some people with more insight to other algorithms congestion control algorithms i can say more about that okay thank you roman from uh kind of independently working on the congestion control algorithms not necessarily quick related uh you can do it from javascript you just need to get the aggregate information about packet arrival you either as a set of uh inter-packet arrival delays as an array or if that's too complicated you can even get away with getting the like sum of squares and sum of uh and basically in the in the average because that will let you calculate uh essentially like a standard deviation etc for any given interval but that's uh like that can be used for like uh uh essentially uh estimate a bandwidth estimation et cetera so so you can uh uh but i the actual like array of inter-packet arrival is probably ideal for the"
  },
  {
    "startTime": "01:38:00",
    "text": "uh okay sorry i'm just taking notes uh thank you mo yeah i think uh if if the goal is to allow application level or javascript level uh media rate control i think that's still a little bit different than than congestion control i think browsers will always have some sort of congestion control on the on the connection whether it's quick or whether it's anything else there'll be some level of congestion control running on that connection and so you'll need to expose what that congestion control is actually sensitive to not just what the javascript wants to use as the parameters that govern its media control media rate control algorithm but also it's going to be fighting with some some lower level congestion control and it needs to know what the stats of that congestion control are so that if for example um you want to try to find the bandwidth estimate the underlying cc may have already found some bandwidth estimate and if and if you don't want to conflict with it you obviously can't exceed its bandwidth estimate or the underlying cc is going to uh you know withhold your packets so you need to be able to understand what does the underlying cc uh in in the browser um what does that what parameters does it already enforce and you need to surface those because the javascript algorithm is going to have to work around those so that's exactly our last question on this slide which is okay we we realize we're gonna we have competing or not compete we have congestion control that's already present and we've thought about having a constructor in the web transport uh sorry an argument in the web transport constructor that would hint to the user agent that's managing the connection that we wanted to shift to a different mode of congestion control perhaps a native one perhaps one that's more conducive to us than"
  },
  {
    "startTime": "01:40:00",
    "text": "uh modifying or understanding the send rate so that the last question there is should there be a default one one specialized for low latency perhaps or even a circuit breaker one which is one that gets out of the way completely unless things are going haywire in which case it trips and uh it tries to restore the connection or something else completely applications would love that circuit breaker approach but i'm very skeptical that popular browsers would enable that much freedom to send uh to send without limit it seems like a perfect amp attack uh uh vector for for anyone that has been the feedback so then assuming there's which are there candidates for a congestion control that might be more amenable to a javascript application running on on top of it like uh is gcc or what is there an obvious candidate there already that we could our trouble is we need to we need to put something into the api uh at this point it's what's holding up our candidate release that we don't want to constrain it too much we can make a generic entry called low latency and then later on through experiment we could determine that it's a certain algorithm but if no algorithm is likely to ever satisfy that requirement then we don't want to bake in an api argument at this point that we would then have to remove later that would be that uh i think first of all let's define okay do you have a comment stefan yes thank you uh so a lot of things have been discussed already now while i was in the queue but i think first of all mo is on to a lot of things that that i was"
  },
  {
    "startTime": "01:42:01",
    "text": "thinking about where it really matters what the congestion role inside the browser is and of course i think to to build an application level congestion control that is really working well a circuit breaker would be the best option i'm i know that it's possible to to get it to work also with something like neurino underneath i've tried it myself with web transport and gotten the gcc algorithm to work reasonably well what i was missing was primarily the packet departure and packet arrival information so i think the getting that on a per uh percent uh basis in some sense uh would be very useful when implementing at least gcc um i what was i thinking um i guess i'm not sure how valuable it would be to be able to specify a low latency congestion control i would imagine that most applications that want to use web transport to to essentially replace webrtc would be wanting to experiment with their own congestion control algorithms i think that's that's one of the more valuable things i think this transport could expose to to the application writers the experimentation would have to happen at the javascript layer is there didn't"
  },
  {
    "startTime": "01:44:01",
    "text": "seem to be consensus that javascript would be capable of that even if given the right information that they would there would still be a need for some underlying congestion control to be present right are you arguing from the latter that in fact javascript could do it given the right information of of packet arrival time yeah so i i think it's it's possible to to get that to work well on the application layer and to decide uh at what rate to send based on on the arrival times and and the departure times that that i think it's is feasible of course it you might end up in situations where uh where the application is running a bit too slowly and therefore you're not able to maximize the throughput of the link but i don't think that that really matters because if the application is running that slowly it will have bottlenecks anywhere else anyway okay thank you sergio i yes i think that they are regarding the implementation of the different uh congestion control in the browser i think that the idea is to be able to instead of for example as we have seen before the experimentation between screamer neurino to be able to have the the quick the quick transport to use a more friendlier er congregation controls that it is not lost based but latency base so i think that this is idea so based on the on the on the experiment below maybe it is not needed but i think that it is still a good idea to be able for example to be able to configure a different one like bbr or copa"
  },
  {
    "startTime": "01:46:00",
    "text": "for quick and be able to to implement a stream on javascript okay thank you uh roman uh typically the real-time congestion controller is more aggressive than the like a normal congestion controller unless there's like some anomalies so if everything works correctly the uh real-time congestion control will limit the bandwidth more than what the default implementation should do so it it will be more restrictive uh the second thing like if it's feasible to implement it in the javascript level it is uh we kind of played with that a bit and it did work uh like the only issue is like you need to expose essentially either aggregate information or exposing from like you you don't expose information about each packet individually you need to provide essentially in uh sufficient chunks so that you uh so that you you can batch the processing up and then the javascript is provide sufficient performance to perform to do the canvas estimation is that is the batching the batching uh the time base for the batching or the count of packets over which you're applying your averaging would that have to be flexible in other words should that be part of the api to say i want my average packet arrival time calculated over so many packets or could the browser yes hey yeah we define a metric that will work for everyone well one again one way of doing this is to expose as i said dispose the metric where you calculate the sum of inter-packet arrivals and sum of squares which gives you uh like at least some estimation like a second order estimation but even having access to an array of like x elements last x elements"
  },
  {
    "startTime": "01:48:02",
    "text": "it will probably even more detail but instead of just essentially instead of just looking at the last inter-packet arrival you have an access to some sort of an a buffer of x last elements to process and to do the uh bandwidth estimation yeah uh uh soon we're getting cut off okay sorry bernard but we can definitely follow up on the list also right people if you have any other questions well okay well thank you very much for adding us to the agenda you're welcome thank you okay uh spencer i think we're we're may have to uh be uh pretty uh utilitarian with respect to time but go ahead spencer uh yeah i'm i'm shooting for uh shooting for five minutes does that sound excellent nice uh so basically i'm just reminding people that i'm keeping track of a specific a individual track specification uh that is defining the stp for rgb over quick and then i am so that's a minimal specification and i've also got a separate github repo that i'm doing broader uh issue tracking where we uh i'm trying to limit uh the first the first the work i'm doing on the on the first specification to boiling a small amount of water uh so i've got i've got uh feedback in this presentation and uh i'd like uh for some of the issues that have popped up here and my goal is to issue a zero one of my draft and uh whenever we adopt uh a draft for rtp over quick i got like i said i'm trying to run uh aligned with them so"
  },
  {
    "startTime": "01:50:00",
    "text": "uh next slide please uh so this one this one has been a lot of fun on the mailing list and uh i've i have a suggestion um but the suggestion is basically we know we need to do quick rtp adpf uh at a minimum and the secure uh avp profiles are ambiguous and i've got some details there uh about whether this is you know that actually means double encryption or whether it doesn't mean but uh this seems to make the most difference when uh quick uh rtp over quick traffic hits the middle box next slide please so uh we could do like i said we could do uh uh that one now uh and we uh you know that i've got a pr that even does that uh that i was waiting to apply before people could look at this and think about it a little bit more i've got some solutions for what to do with middle boxes or proposed solutions for what to do with middle boxes but none of them require anything in the sdp or in actually or in the rtp of a quick specification next slide please extremes datagrams or both um i i am not seeing any convergence uh about uh about people saying we're only going to use one or we're only going to use the other and being able to convince people so my proposal right now is to include both stream and datagram and the sdp uh and uh like i say that's where that is uh and uh"
  },
  {
    "startTime": "01:52:03",
    "text": "like i said i note that i'm using the inglebart uh draft as uh the basis for my work so adopting it would be awesome soon next slide please uh so am i getting close so we talked about congestion control so uh we have we have basically uh a lot of bad ideas that i've even crossed out already and where i think we are right now is exploring whether uh signaling anything quick about anything we need to do differently at the quit level for congestion control is a problem in practice uh you know admittedly limited testing it hasn't been if we find out an additional testing we can come back to that one um i think that is uh all of mine yeah so like i said i'm looking forward to input in uh either in github repo for issues or for uh for uh on the on the mailing list thank you and thank you all right thank you all right so we're going to turn it over to lori thank you very much i'll try to be fairly quick as well hope you can hear me okay so uh we can let me just push on so a quick background so we introduced this topic first in february and as a reminder the v3c is kind of compressing the video scene into different bit streams uh once encoded with video encoders and ones with encoded with d3c encoder which is just an encoder for the atlas metadata and it found it very closely uh resembles how video is uh used as well like in terms of the high"
  },
  {
    "startTime": "01:54:01",
    "text": "level syntax it's also based on now units next slide please next slide is yes please yeah thanks um so for the video components we can already stream those using the existing rtb payload specifications but we're missing the rtp pilot specification for the atlas data and that's what we are defining here so in addition to the rtp payload specification for the atlas data units we want to introduce a couple of d3c specific payload format parameters that will allow us to kind of identify the streams and figure out how to use those in in the streaming context and also introduce a grouping mechanism for these different video streams and the atlas data stream and then lastly but not least we have this rtp bundling rtp stream bundling opportunity that could like allow you to stream a bunch of these different streams in the same part next slide please so from the previous meeting we got a little bit of feedback to align more with the vvc instead of hiv crtp payload format and we did that by removing the multi-time update aggregation packets and cleaning up the payload from parameters section we also looked into the stp but based on the discussion that took place on vbc stp examples and such we felt that it's uh fairly okay to be very limited in that regard and if people want to see more examples in in in the stp that for the sdp that'll that's just fine let us know we also received a little bit of public feedback regarding the missing acronyms and that we also reflected in the next version um next slide please"
  },
  {
    "startTime": "01:56:00",
    "text": "for the next steps we appreciate a bit more feedback and you can do this directly on the github that's linked here on these slides and we will be continuing to update the draft based on this received feedback and we're also looking for additional authors or contributors and definitely with value input from the rtb payload format experts as this is our first time looking into the into this topic what we are familiar is it is more of the the v3c side of things and the system sites there and just as a last we also introduced this topic in 3gpp to see if there's some interest and we did receive some feedback which is not yet reflected here and that's that any questions or comments if anyone wants to work on this project with us just feel free to drop me a line and we can arrange some offline discussions to see what we can do what can be done but i'll put them on somebody might do the queue can anybody hear me uh i uh i guess i can't as we uh mr zao are you in the queue yeah yes can you hear me though obscures yeah we can hear you yes go ahead okay that's great so just question further what's the status in hpp i'm assuming you're gonna be safe working group right uh we should stop working for pm and what's the status in there i'm sorry i"
  },
  {
    "startTime": "01:58:00",
    "text": "i actually missed all of the discussion or questions it seems that i can't hear anything when i have my audio uh yeah the question was about status in 3gpp sdk gtp is that part of the proposal or whatever discussion paper will be put into a permanent document i'm not familiar with 3gb that familiar with 3gbp so i don't know what it when in practice that means um the decisions have not been taken anything on that it's been just still under the discussions okay thank you so it's obvious all right thank you okay are there any other questions relating to this item we're almost out of time uh and so i don't even know that we have enough time to talk about wrap up the next steps but uh hopefully the notes contain all the action items and next steps uh for various folks uh and we will as usual update the action item list and send the minutes to the list and all of that good stuff any final comments jonathan no i don't think so other than that there has been some discussion of things in the chat that wasn't raised at the mic so people should review the chat that's you know which i think should be archived somewhere on the atf site"
  },
  {
    "startTime": "02:00:00",
    "text": "um other than that i don't think so and uh i think we will figure out our uh spencer just going to suggest that you uh cut and paste that into the bottom of the minutes uh i've been encouraging working groups to do that it's been very helpful uh because there's sometimes there's a lot of discussion there thank you okay yeah that would be a good idea okay well then thank you everybody we will see you again at itf 114. stay safe um [Music] hey bro uh i so do we need to copy the jabber conversation in the notes is that what are we talking about"
  },
  {
    "startTime": "02:02:13",
    "text": "you"
  }
]
