[
  {
    "startTime": "00:00:16",
    "text": "all right good morning everyone thank you for staying until Friday for us my culture Descartes was unable to make it here so I will have the show all to myself and let\u0027s start and please notice the note well everything we talk about is covered by ITF IPR rules we have a minutes taker we have a job and while we\u0027re at it I\u0027d like to thank outgoing ad who obviously took an early flight home and welcomed our incoming ad Ben and let\u0027s start so since the last meeting we progressed the first working group document a set format document to isg should be going into ITF last call soon and today we will spend most of our time discussing their delivery draft slash drafts if that\u0027s what we decide to do but first like to ask if there are any questions about the agenda so okay can you please speak to the mic we yeah we we do have one remote participant Annabel Backman Amazon uh there\u0027s been some discussion on the list just in the past couple days about the exp claim in set and whether that should be not recommended or recommended do we want to make five or ten minutes for that so I was planning to do that assuming we have someone who can I represent Mario\u0027s concerns on that so that would be you I think I can make a stab at it all right "
  },
  {
    "startTime": "00:03:16",
    "text": "and then I feel asked for a slot a again if we have some time remaining to say a few words about SSDP the new proposal that is submitted just tonight so again if we have some time remaining after we speak after we finish talking about the main meat of the meeting so next is Mike thank you I\u0027m Mike Jones from Microsoft and one of the editors of the security that token draft I have two slides one of which was the title slide so let\u0027s go to the second slide this is just recap of status we have published four drafts since we last met our heroes in Singapore there\u0027s been a lot of productive working group discussion that included some consensus calls that didn\u0027t result in actual ITF style consensus and then some follow-up discussions both in person and on the list that eventually did so I\u0027m happy with that outcome I think we have a better result than we would have had we just proceeded in December so thank you you\u0027re on among other things we tightened up the claims definitions in numerous ways partly due to input from Annabel and dick we added risk examples that marius supplied us and i\u0027m happy that we\u0027re now in a state where we\u0027ve sent it to the is G and we\u0027ll have ITF last call it is scheduled to be evaluated by the IES G on the May 10 tell a chat so those of you who may not have been around this process as much before expect to see a number of reviews from special groups in the ITF such as the security Directorate the Operations Director at the applications group will send us reviews that are sort of ITF wide that often contain a lot of really useful content as well as the number of the area directors will submit reviews and the editors in the working group will get to resolve those comments probably continuing to improve the draft that is all unless people have "
  },
  {
    "startTime": "00:06:17",
    "text": "discussions they want to have on that topic now otherwise I will yield the remaining 12 minutes or whatever of my slot to more productive use thank you thank you now that works a PS so it only works with that yeah slides will need to be manual and about Backman Amazon can are you talking about the set token delivery using HTTP draft just currently one draft and as yarn alluded to may or may not end up becoming two drafts next for those of you who I haven\u0027t necessarily read it aren\u0027t necessarily familiar with it what we\u0027re talking about is a protocol or actually potentially two protocols for delivering sets from what we\u0027re calling an event transmitter the party who has the set probably the party who generated it to an event receiver the party that wants a set we have two mechanisms for this one that focuses on we\u0027re calling it HTTP push the transmitter is making a request to the receiver to send the set to them the other is HTTP pole where the receiver is making requests to the transmitter to retrieve the sets from the transmitter the next it\u0027s gonna walk through these real quick as I said with HTTP push it\u0027s a transmitter sending the set to the receiver they make a post the receiver replies with a 202 if they accept it or 400 if they don\u0027t just could quickly walk through what these look like at the protocol level you just keep step through these quickly yeah it\u0027s nothing too surprising the 400 and 400 we have an error body with an error code and a description for the for the transmitter to consume next the other side is HTTP pol receiver is making posts to the transmitter and retrieving zero or more sets depending on if there are any sets available for them in the initial request they\u0027re going to make a post they\u0027re going to they can optionally specify a number of sets they want back a maximum number they can also "
  },
  {
    "startTime": "00:09:17",
    "text": "specify whether or not they want to do long polling via the return immediately parameter there mm-hmm the transmitter replies with a 200 that may contain some number of sets it may not on subsequent calls the receiver in addition to requesting sets they can also acknowledge receipt of sets they got in the previous request so they can send this ACK parameter that contains a list of jdi\u0027s from sets that they accepted next they can also send this set error parameter which is a map of jdi\u0027s to error responses for those for those sets so you put that all together this is what a request from the receiver might look like they can specify max of n so you can say if they want long polling they\u0027re acknowledging they\u0027re specifying errors and hopefully they get back some sets from the from the transmitter so where are we at with this we had a new draft published just a few weeks ago two big one minor open issue one major of an issue the the minor open issues there is a recent question around how do we want to handle status error codes for the in the the push scenario currently the spec says we\u0027re just going to return 404 everything do we want to do something different the other open issue is we have two protocols in one spec which one\u0027s nti what are we doing there well we\u0027ll get into that as far as implementations go Google has pushed implemented Amazon is working on a push implementation should have interrupt with Google on that probably this summer I understand from Tony that Microsoft is is or has implemented pull I don\u0027t know if Mike can clarify that Mike Jones Microsoft Microsoft has needs for both Paul and push I can\u0027t speak to the state of our current implementations but I know that we\u0027re implementing for and using forms of both so we need both ok so let\u0027s talk through the error open issue real quick we saw this briefly in the are the protocol examples but for both push and pull we have this error object has an error code and a description you\u0027re next in the push use case requests by the transmitter are gonna be responded to by the receiver "
  },
  {
    "startTime": "00:12:17",
    "text": "with either a 200 or a status code 400 regardless of what the actual error message is I was raised on the list that maybe we could be more specific with our status codes here a couple of things came out of that discussion so far namely that for two of these we could actually specify a 403 this error is probably actually not needed and we can get rid of it but that still leaves everything else is a 400 so there\u0027s kind of still an open question is it worth doing any of this do we just want to stick with 400 for everything and be consistent or they\u0027re actually other status codes that we\u0027re not thinking about that we could use for some of these use cases Phil hunt document editor and from Oracle raise a caution here that this is similar to issues we\u0027ve had with redefining jot attributes for a different purpose what happens in 403 is you\u0027re redefining something that HTTP is defined it also causes a problem that you can\u0027t tell the difference between an authorization error and a JWT error so I\u0027d advise against redefining 403 in this way Thanks I\u0027m Dennis Google we actually ate a similar question come up with the device flow draft you know where we had like a slowdown that could have fit into one of the HTV ones we ended up just keeping the 400 in that case and some of the reasons were that you know this is a Jason reply anyway so it\u0027s kind of like it\u0027s it\u0027s machine readable so I think the thing about status codes in HTTP is that if it\u0027s if it\u0027s an HTML response it\u0027s really the status code that\u0027s kind of telling the browser like what actually happened so the browser can display perhaps a meaningful message because the HTML while kind of machine readable is not really machine processable in this we don\u0027t have this problem here so I think each of these error messages are very explicit anyway yeah the other thing was adding the separate for I think was like a 410 or something you just made like it just adds more branches to the client code kind of more places people can get things wrong so yeah I would probably advocate just keeping it as the 402 yeah I think that\u0027s a pretty compelling argument I also think there\u0027s something to be said for leaving the other status codes at the sort of HTTP level and not getting into the application level that\u0027s running on top of the HTTP protocol here could you explain why Duke was the stricken out I\u0027d have to go back to the email thread but I think that looks like phil has a better answer than I do it was because when we talked about possibilities for a failed delivery the transmitter needs to have the ability if it thinks that the receiver may not have "
  },
  {
    "startTime": "00:15:18",
    "text": "received it to send it again and it will keep within some reasonable period that it\u0027s able to to do that until it gets an acknowledgement back so a duplicate is now a normal condition as was the issue so I think we don\u0027t have I think the draft does not currently make clear that that\u0027s the case and so that\u0027s probably something we need to update is to add some language about idempotency of sending a set to a receiver I\u0027m pretty sure it\u0027s clear it\u0027s just that we\u0027re all remembering from the past that\u0027s that\u0027s really the issue that\u0027s possible other question push versus poll should one of these VMT I should the other BMT I should they both be empty I should neither of them be MTI this is the big question of the day we\u0027ve gone back and forth over this issue in several meetings and I don\u0027t think we\u0027ve really made a lot of progress on it there are arguments for both protocols there\u0027s legitimate technical reasons people have given for preferring one versus the other I think the biggest concern that\u0027s been raised for polling why people would not necessarily want to use polling is there are skilling concerns there on the other hand for push the enterprise space has scenarios where they maybe don\u0027t want to open holes and firewalls so opening up an endpoint that transmitters would push sets to doesn\u0027t necessarily work for them it\u0027s a big technical reason hole there\u0027s no mandatory requirement to persist sets it is obviously slower if you\u0027re polling cycles are long whereas in push you can get rid of it relatively immediately so you might be talking about retaining the set not persisting it for a period of minutes rather than then milliseconds so that\u0027s that is the trade-off so there is but it\u0027s not a permanent requirement that\u0027s what I want verify yes it\u0027s not yeah as persist that\u0027s not meant to imply permanence of that but it does mean that the the transmitter has to hold on to the set all of their sets for potentially a longer period of time whereas with push they generate it potentially they push it immediately they got a 202 back or back and they\u0027re done with that I\u0027m wondering if you want on I\u0027m wondering whether there is you have to think about a little bit the MT I for the client and the server here or the sitrep sender and the receiver and it might be asymmetric so you might sort of try push and have a have text in the specification that says how you fall back to pool if that fails right or what the expectation is on the sender and receiver to make it so to maximize your "
  },
  {
    "startTime": "00:18:19",
    "text": "chances on interoperability you know it\u0027s just a thought William Dennis Google and I apologize for the OLAP analogies again but well there\u0027s kind of my background when I\u0027m when I analyzed the MT and I sent a couple of emails yesterday on this topic the two good examples I found from all three having Intel really helped was when it was kind of like a recommended way to do something and then like an inferior way for like some subset of kind of constrained clients so in a number of places we mandated the superior way and then we made the inferior way kind of optional that has been extremely useful for clients because if the client is capable of the superior way they can just implement they\u0027d have to worry about you know working out what they need to do it was Eastern the available in this case I feel like these two things they\u0027re just completely diametrically different so to me these this is just kind of two aspects of something it\u0027s kind of like again the Olaf analogy you know we have the code flow we have the implicit flow and I don\u0027t actually think either alike MTI there\u0027s also like client credentials and various other kind of all these optionality in the spec and people can\u0027t have to you know each had its own use case and what I\u0027m sort of seeing here is that there is very explicit use cases for each I don\u0027t see how empty I actually would aid the development of clients and you know there was the option of like splitting the spec maybe don\u0027t need you that maybe it\u0027s just like like other specs that we have just document two options and there\u0027s discovery or something that people use to work out which one of these it seems like this is a really kind of big topic that people will choose and not so trivial like are using Shire or using like something else where it makes sense that\u0027s just that\u0027s my opinion I think I think I\u0027m speaking for the team there on that I\u0027d like to make two comments one is well one is working group sure and one is the individual is working group sure I I believe very strongly in the in the value of having a single MPI I think in a few years time when there\u0027s less clarity actually about what we thought of as the appropriate use case for each one people will need to open their documents and find out what to implement what to implement first what to implement for smaller libraries for smaller identity providers that want to interact with larger guys so I think we need to give them one direction about that even if that means that some people will some people in this room might even start with the other method because that makes more sense for them today but still we need to have one preferred option and then as "
  },
  {
    "startTime": "00:21:21",
    "text": "an individual I think so I don\u0027t really believe the every one thing I think they\u0027re saying in German that they can\u0027t hear you so as an Virgil I think the question of will holes is not as problematic as it\u0027s made out to be here and and so I don\u0027t see a problem with having push as the SDM Ti but again as a working group sure I just want one I don\u0027t really care which one it is so just a flipside to something you said there is a you know talking about a few years down the line when a lot of these conversations and these arguments are forgotten the flip side to that is a few years down the line we\u0027ll have a few years of implementation experience and I think a much better idea at that point of which of these protocols make sense in what circumstances ultimately the the answer for the little guy who wants to work with the big guy is they\u0027re gonna implement whatever the big guy implemented nine times out of ten yes but where we\u0027re going to have multiple big guys and we still want to send the same signal that\u0027s what standards are about once again there\u0027s a lot of cases I think we\u0027re considering mainly that are due to Federation those cases when I look at log out are relatively simple when I look at other cases we\u0027re talking about interconnecting highly proprietary and highly secure security system so we\u0027re in ER we\u0027re naturally talking about an age of sharing security signals between security centers which the methods behind them are restrictive they\u0027re the keys to the castle that everybody has and I\u0027m expecting severe Network restrictions another category is that many people are classic business customers who are on a trend to close firewalls further not open them there their argument is if we\u0027re moving services to the cloud what\u0027s left inside our castles even more important and they\u0027re reticent to open it so regardless I see Network challenges on that the last category was there are some Internet of Things cases that come up gate weighing issues you see TLS one three issues that limit choices so push seems simple now and I "
  },
  {
    "startTime": "00:24:27",
    "text": "agree it\u0027s the more performant one but in terms of agility about usability I\u0027m worried so so I\u0027m thinking in terms of applicability and agility in general and trying to balance the needs of saying let\u0027s just solve Federation and scope it to that I think if we\u0027re here at the ITF solving Federation\u0027s not the majority well its current majority but it\u0027s not the long term use case and I think we have broader use plans for it as well Thanks that all sounds to me like a really good argument for not trying to institute a single MTI set delivery spec as as you noted there I think there\u0027s not going to be use cases for a set that for which neither of these make sense and and and for which they may not be using any delivery method at all you mentioned IOT I think that\u0027s a great example of where push and pull both are probably not going to work in their current design correct um Phil again I think my hesitation is not based on like I agree with you my imitation is what will the broader IETF community accept and based on what Williams told and in my personal experience over the 10 years we can say we want something all we want but my concern is people want to get it done taking a chance by having two optional things and having it thrown back delays of significantly and if if we can come to a single method that would be the ideal case that would be the fast fastest case that I see it\u0027s still problematic because there may be a lot of changes required to adopt a single method so we\u0027re kind of in a quandary I don\u0027t know what to do about it and this is where I have to go back to the chair and the ADA\u0027s recommendations to say you know you\u0027re wasting your time or not to pursue the multiple method approach it\u0027s just my feeling based on experiences that that people want libraries to be developed and the libraries would generally work with each other when people try to use it I think leaves comments are important about client option versus server options you have to kind of all we have to get that clearly meshed together thanks my feeling is you don\u0027t get what you don\u0027t ask for if we collectively as a working group agree that one or the other is you know the right technical choice to move forward with if we think that\u0027s the right answer then we should let the IETF fight us on it yeah I definitely agree with that comment I think um I think it\u0027s our job to put forward the best document we can kind of a point of order I\u0027d like to ask the chair like I don\u0027t quite understand how you can sort of say it\u0027s like there should be MTR with your chair hat on to "
  },
  {
    "startTime": "00:27:28",
    "text": "me that\u0027s more of an individual comment I\u0027ve not heard of a chair kind of requiring an MPI in aspect so I actually think that that\u0027s it you know it\u0027s just experience right ISD will bring this up right it\u0027s but but it\u0027s also Annabelle is absolutely Tori I mean you we don\u0027t you know it doesn\u0027t mean you actually have to use by that right so you can use you can if they\u0027re working past consensus they\u0027re working past consensus right a well-documented concerns was saying there there\u0027s there\u0027s like good reason to have to write a loss has multiple methods multiple flows in it for a good reason and that\u0027s standardized yeah and in that example like they were very explicit use cases for each of those two and I think that analogy applies here so you know I know if we had the JavaScript clients we had we had public clients we had confidence not very different MA right what my observation here is that when I sort of saw that argument between the two groups like we won\u0027t pull me or push it just seemed like they were just completely separate ecosystems as well sort of you know a bunch of people doing something say with risk implication they\u0027re a bunch of people maybe do some B\u0027s skim and I think if you go back to like why do we want empty i-it\u0027s country improve interoperability and simplify things but it seems like there\u0027s no interoperability issue there so I don\u0027t I don\u0027t sort of see how like or seen one method on a group of people that don\u0027t want to do it that it\u0027ll kind of happy with your Interop helps and and yeah I do think there is precedent for documenting two equally viable methods so if I suggest will be let\u0027s take that forward and and if there\u0027s significant pushback can address it then and I think there was probably an action item there for for those of us who of the draft to add more context around what are the use cases here what\u0027s what\u0027s motivating you push what\u0027s motivating poll I think that\u0027s something that you do see in 67 49 that isn\u0027t really present in this draft and that might help clarify and give that context for why we both of these methods make sense Mike Jones Microsoft I think there\u0027s plenty of evidence in the room and on the list that both methods are going to be used for good reasons in different use cases that being the case I think we are procedurally better off to keep them in one draft and you know have discussions about whether one is MTI separately than that but if I were trying to take two drafts to the isg and I would then expect comments like pick choose one or the other whereas if we have one draft that clearly lays out for these kinds of use "
  },
  {
    "startTime": "00:30:28",
    "text": "cases this method works for these kinds of use cases this other method works and for this other set of use cases either could work then we\u0027re not gonna start having discussions about delete one or the other like you\u0027re stealing the Thunder on my next two slides here okay please proceed everybody just one more thing so first of all I\u0027d like to to echo what left said said about my my previous comment coming from experience and about the working group ultimate decision on whether we want to go with a single MTI or not it\u0027s it\u0027s my advice to have a single empty I and the working group can decide otherwise if it wants to and then back to the discussion on on which weather in which so I\u0027m I\u0027m a bit worried about when I hear that they\u0027re going to be additional methods proposed for various use cases so are we so if we start with having two methods that are both sort of optional sort of were describing which use case for which what do we do and when the third and fourth ones come along and then when I hear that that we have clearly defined use cases or well that kind of conflicts with with the whole firewall whole notion so if I have a firewall whole that\u0027s a clear use case no is it really it\u0027s just a matter of getting hold of my IT guy at the good time or something it\u0027s not really a well-defined use case so let look at a bunch of slides about what we just talked about so briefly before we get to the ones we actually just talked about one additional option that\u0027s been brought up particularly for the kind of the firewall use case is the idea that a lot of those those clients may actually be operating through sort of a service provider acting as a proxy between their systems and the event transmitters that they actually want to get a signal from so as you can see in this example we\u0027ve got transmitter talking push to the proxy service provider who\u0027s acting as an intermediary receiver on the other side you have the receiver polling the "
  },
  {
    "startTime": "00:33:30",
    "text": "proxy service provider to get those events so in this scenario you\u0027re still doing push and you\u0027re doing poll but it\u0027s a question of who\u0027s implementing what the cert the transmitter is only implementing one of these protocols the service providers implementing both but they\u0027re implementing them in different directions and the receiver is also only implementing one of these protocols so you eat even with two protocols and people wanting to implement different ones you still got ways to bridge between them that you know if the use case is there the industry can provide I saw this posted on the list and my reaction it\u0027s fill hunt by the way again was it doesn\u0027t address the interoperability issue because you still have interoperability for the receiver it has to be standardized it does I think it\u0027s a natural consequence though as a negative of having two methods that then we can expect complication and network architectures of needing mediators between the methods so I see this actually more as a problem than a solution I\u0027m not sure how I it I think it describes the problem more than it does a solution and I\u0027m I guess I\u0027m stumbling because I\u0027m not sure where we go with that on that one thank you I think if I remember correctly I think Adam Dawes was probably the first person to bring up this this approach and if I understand it correctly he\u0027s putting it forward not as a replacement or a reason why we don\u0027t need to standardize poll we would want to standardize both push and pull so you have standardization on both of these links but the proxy service provider acts as a bridge between the two so you know people have made claims that well everyone\u0027s gonna have to implement poll anyway you know with with the intermediary service provider solution that that may not actually be true so other option we\u0027ve already talked about splitting the draft we could do that there are consequences though which we\u0027ve also already talked about thanks Mike if we split the draft what happens when we get to IETF thank you there\u0027s concerns yarns brought them up we\u0027ve talked about them at length I think by now that\u0027s something we have to think about so kind of summarize where were I think where we\u0027re at with this I think it\u0027s worth is considering some stepping back a little bit and considering some lower level questions we talked about wanting a single speck for MTI a single emptyeye spec for interoperability what do we mean by "
  },
  {
    "startTime": "00:36:32",
    "text": "interoperability is it reasonable for us to say that everyone or a significant consensus of implementers or users of set are going to be able to agree on a single delivery method for that I think it personally I think at this point was probably too early for us to say but you know we can talk about that separate from from that question of whether you can we are if we can do we need to does IETF process mean that we have to what\u0027s the consequences if we don\u0027t yeah it\u0027s all I\u0027ve got anyone else have any other questions on set delivery I think we can move on to the next set of slides I actually think that we do need to to get to closure on this otherwise we will waste another ITF cycle and maybe and maybe before we move forward like I will ask cliff and maybe Ben to give their opinions on on the issue at hand so if you want so all we it is the working group clear on what the question is at this point again yes that was my comment on on client asymmetry I like stuff like that I mean if if we have that analysis in hand it may actually be easy to answer this that question but you know you know skipping over that issue I would say that you know I hear you\u0027re the chairs recommendation but I actually think the working group should recognize the fact that the major implementations are already said that it will do both and write that as recommendation in the in the draft that you should expect and you know with the explicit analysis on what the client should be how the client should behave right understand there\u0027s being here\u0027s what you should expect and here\u0027s what you need to implement in order to achieve an interoperability and it will be both and I would advocate keeping it all in one office Mike yeah William apologize for going back to it but I think both is actually a good a good model to look to here as far as the value in the need for different methods been Caidic speaking as a D so I mean you\u0027re honest right that is frequently useful to Ryan push for a single di solution that\u0027s best for interoperability in general it\u0027s of course also true that if the working group has good consensus to do something else that will go forward in the process and generally the iest review stage is "
  },
  {
    "startTime": "00:39:34",
    "text": "only going to object to that strongly if there are actual technical flaws with it and they\u0027re supposed to reject the working group they\u0027re supposed to respect very different respect the working group consensus in this particular case you could perhaps think about it as being that the set is a information model and there are different applications that want to use the information model which require different MTI protocols and so if you frame it in that way there\u0027s perhaps less of an objection but I am NOT super up to speed with you know the actual use cases here so I can\u0027t confirm for sure that that\u0027s what\u0027s going on that\u0027s actually something that has also been brought up I don\u0027t think week any one mentioned it here but set is going to be profiled by applications you know risk is profiling it oh I de C log out is profiling it others will and those profiles can and likely will mandate one or another delivery method as MTI for different use cases and for different contexts so I think that that speaks to your point that set really is is the it\u0027s the information model it\u0027s a format here we\u0027re talking about how we\u0027re delivering that that naturally gets into the use cases for that format the applications are being used within and I think that\u0027s where we do get into a lot of risk trying to say it\u0027s all gonna be one way or the other I guess thinking this way might make one tempted to split into three documents but I also assure summaries that that would not go terribly well in practice and questions or comments on set delivery before we move on take that as a no what the next presentation yeah no so I suggest that you take a seat we will take a few humps and then we\u0027ll move to the next one Thank You Anibal so my whether ambitious plan is to take three harms one on whether we want a single empty eye method well if the answer is yes which one it should be whether push-up ople because these are the two ones that we actually have on the table and then a harmon whether we want to split the draft comments objections questions i will clarify their arms more as we move "
  },
  {
    "startTime": "00:42:38",
    "text": "into them but case so John Bradley as it was pointed out I think one of the speaker\u0027s the MTI doesn\u0027t necessarily need to be symmetric for both the client and the server so it\u0027s confusing to me your question are we is this that there should be a single MTI for that both client and server must implement I think there\u0027s more options than what you enumerated would you like to enumerate the options we could come on them I\u0027m not sure I can do it sort of standing up but but I think you actually have to sit down and do a little bit of analysis and think about sort of the various scenarios in which you know push and pull can fail because I think that\u0027s where people are going to go from from push to pull and pull to push right just follow-up I mean there\u0027s also you know we always get into the tangle of what is mandatory to implement versus what is mandatory to deploy and they wind up not being the same thing well it is a confusion at least in the minds of potential Hummers okay well okay mandatory to implement that\u0027s like ITF religion but mandatory to implement does not mean that people actually turn on the functionality which means that you may not actually get the interoperability so desired correct so you know the difference between a open-source project must include the functionality in a library they distribute verses it must be enabled for a particular implementation yes they\u0027re not the same thing regarding client MTI versus server MT I I I don\u0027t think that\u0027s actually a relevant distinction here because client and server are dictated by the protocol you\u0027re using what role you\u0027re in and what you\u0027re doing each of these protocols is unidirectional so if we\u0027re talking HTTP push the transmitter is acting as a client making calls to the receiver who is hosting an endpoint if we\u0027re talking about poll its flipped around that I mean that\u0027s sort of the fundament that\u0027sthat\u0027s that\u0027s the question no like it you you can\u0027t say one is MTI for transmitter one is MTI for receiver because they must necessarily have to be functioning in the appropriate role within the protocol they transmit are implementing push is only going to be able to send messages to a receiver who\u0027s implementing push in the receiver role same thing for poll "
  },
  {
    "startTime": "00:45:42",
    "text": "just enricher so um I think that we could approach this hum in a couple of different ways it\u0027s we may want to take a hum specifically from the perspective of the transmitter say should push be implemented should push be MTI for transmitter should pole be an MT I for transmitter if we wanted to we could take the same hums from the perspective of the receiver in addition to those I think those two at the very least are necessary and people can hum for both if you think we should have both or you can make that a separate a separate option that both should be empty I - Annabelle\u0027s very salient point though the receiver doesn\u0027t really have a choice here this is not the kind of protocol where you can like try one and then negotiate the other when it fails it\u0027s it\u0027s either going to be there or it\u0027s not because they\u0027re drastically different models from each other that\u0027s the whole confusion about client versus receiver and stuff like that right so I think in my view of looking at this that MTI from the clients perspective is dictated by whatever sorry see I\u0027m doing it now MTI from the receivers perspective is dictated by whatever the transmitter supports so I think that we should at the very least get a sense for what people think should be MTI for the transmitter to support if we want to do all of this other stuff for clarity on top of that sure but I think this is the fundamental question and it\u0027s a narrower question than what we was being asked before so transmitter fill hunt here transmitter and receiver or you know the a player concept the way you have to look at it or I look at it is that at the receivers perspective they have a choice it boils down HTTP are they able to be an HTTP endpoint or not so if you\u0027re a mobile app probably not if you\u0027re an IOT device behind a number of gateways and security things probably not you have a hard choice this was not a question of MTI you\u0027re either able to be an HTTP endpoint or not the server the transmitter if they want to share events to both of those classes of custom clients that are straight receivers that receive events some of them can be an HTTP endpoint and some cannot so I think what will naturally happen is major issuers or transmitters "
  },
  {
    "startTime": "00:48:46",
    "text": "will have to do both but certain clients you\u0027re building an IOT device you\u0027re only going to be able to implement one because that\u0027s that\u0027s all you have to work with so clients have the option allottee but not really they\u0027re driven by what they can do and so MTI becomes a bit nebulous and that\u0027s why we\u0027re having trouble with it I also then just to make people go tilt I\u0027m seeing a lot of use cases that are bi-directional anyways and the whole problem repeats as you reverse transmitter receiver rolls so that\u0027s something to think about about how this evolves and where complexity lies but in general those that are behind some network restrictions are going away I understand by the way yearns comments about the firewall I was that way two years ago when we started and was behind push all the way I\u0027m finding it\u0027s a hard note they won\u0027t do that it\u0027s a little bit like TLS one three they\u0027re getting rid of things that support man-in-the-middle that\u0027s now hard no so and it\u0027s the same thing that are happening with many firewall configurations well the device and the standards support it the deployers you know so we have to worry about that so I think a lot of what she\u0027ll said it\u0027s actually about the confusion between mandatory to implement a mandatory to deploy and in practice mandatory the deployer is going to wind up with you know everything it\u0027s you know that\u0027s what people will have to in order to handle all the use cases I actually can come up with something else but I find myself agreeing with Justin I think that it\u0027s a good question to ask but you know to hung on man Authority implement for the transmitter because I think that\u0027s that\u0027s sort of the core library function that everybody has to has the support another option is to do a hum on whether we actually want to to try to avoid the MTI discussion by saying both and do that hum first but I\u0027m sort of am in Justin\u0027s camp here and say let\u0027s harmone Mediterra meant for transmit Annabel Backman Amazon um I think we should be careful about making assumptions that transmitters are going to have to implement you know both protocols or all protocols implicit in that is the assumption that every transmitter is going to have use cases that require both and that may or may not be the case there may be transmitters who don\u0027t care about and don\u0027t have use cases for getting events from clients who can\u0027t act as a HTTP server there may be applications for set where that concept just doesn\u0027t apply so it\u0027s it\u0027s a little "
  },
  {
    "startTime": "00:51:46",
    "text": "presumptuous at this point to assume that regardless of which is MTI that everyone every transmitter is gonna have to do push and pull there qunit you pointed out i UT devices and if you think about the MT ie that\u0027s actually the IOT devices there is very important because that stay where you want to grow minimal implementation you want to do what is their smallest possible implementation what to do and then you want to only implement the empty I am algorithm and nothing else and then if you implement an MPI implementation in your end and you probably associated ITT you should talk to some a bigger device the bigger device can implement both or whatever it wants and I don\u0027t know actually what the IOT devices are going to be using are they were useful to use the pool or push for them I don\u0027t know depends on the application that\u0027s actually makes it very hard I think to understand which one would be better for them but usually having single empty is better than having multiple because that make it easier and even if you say you do not have to deploy it but if if the code isn\u0027t there you can\u0027t even change the configuration to get them to work together unless you have one single emptyeye that is implemented or at least one singular in painter at a three-bladed Potence will cut the loan after William Annabelle Backman Amazon um I think for the for the IOT implementers there are a lot of strategies that they tend to say I I\u0027ve seen them employ and working with them you know in in our context that protect them from these sorts of decisions frequently we\u0027ve seen you know what regardless of whatever protocol whatever standard protocol we want them to be talking to us with inevitably they\u0027ll plumb everything through their data center so their IOT devices are all calling home to their systems that they can control and they can update and then they\u0027ll talk whatever protocol to us so yeah it\u0027s just some extent I think as far as the device side code is concerned they\u0027re largely insulated from these kinds of discussions William Dennis I agree with that viewpoint I think I think this comes down to again the kind of the application of this set delivery and that there are different applications for it so I don\u0027t think we have like an ID use case that\u0027s sort of a generic set delivery to use case that anyone has been discussing so I think again there\u0027s just it\u0027s application specific and therefore the the usual kind of interrupt concerns don\u0027t necessarily apply because it\u0027s kind of constrained to their application domain anyway I think we\u0027re expecting that there\u0027ll be profiles of this so as you said risk will will likely have a profile that\u0027s with risk you know we\u0027re using set we\u0027re using a bunch of events that have been defined by set wagon a mandate push for that particular profile and so that\u0027s "
  },
  {
    "startTime": "00:54:46",
    "text": "the application that you know that governs the Interop for that you know that group of people and any IOT device using risk you know can they rely on those on that profile they\u0027re mandatory things specified by it okay so I think it\u0027s time to move to a hum the first time will be on the question of MTI for transmitters thank you John so if it\u0027s a yes means yes we think we need a single method to be empty now for transmitters if it\u0027s a no it means we don\u0027t think we need an empty rifle transmitters and we as a group believe that we can that we can specify we can define use cases and the actual usage scenarios for each of the two methods on the table yes John Justin Richard Justin um John gets credit for most stuff I do anyway yeah so in any case I would actually recommend and requests that the hum be between multiple discrete options and not a yes and no hum as opposed so MTI for both mt i for pull mt i for push you know pull alone push alone and then maybe need more info or I don\u0027t care so I would no MPI I suppose that\u0027s entirely off mic Annabelle said that the results depend on the answers to those depend on the results of the other questions that that may be true yes let\u0027s stick to that so yes or no on MTI first okay and then I will need your help so please hum if you believe that we need a single method to be MTI for transmitters okay please hum if you think that we do have a clear enough definition of use cases for each of the two methods okay so the group not too many hums but well enough I think so so the group believes we can go with no emptyeye and that we can actually specify in the graft please go "
  },
  {
    "startTime": "00:57:52",
    "text": "to the Marc Justin you see this is why I was asking for more clarity in the hum and I hummed for two MTI and not zero MTI I think those are different options neither of which is one MTI which was the first option that didn\u0027t get any so that\u0027s why I was asking you to make it explicit yes Annabelle Annabelle Backman I think that the follow-up hum then should be who thinks both of these should be MTI and a further following also losing know when to back yeah fair enough so please hum now if you think that both push and pull should be MTI and please hum if you think that near that we should not be specifying an empty I method and basically both of these are good and maybe any others to come along so please him now sounds sort of half and half to me nincada I think you should ask the people who hummed for the last one if they could come to the mic and say a little bit about why and Mike Jones Microsoft Annabelle made a point that set is profiled and that profiles are likely to specify particular transport methods as well and that actually probably argues for no MTI define the methods and leave it up to the profiles Annabelle Backman Amazon have agreed with Mike agreeing with me also the reason I I hummed against making both of these MTI and their real reason is that because I think we should split the spec which sort of makes them both MTI for each use case so it\u0027s a little bit weird to say they\u0027re not both MTI basically what I\u0027m against is keeping or what I\u0027d prefer to see is separating them so if you\u0027re doing HT push you\u0027re doing HTTP push that becomes MTI 482 e.push if you\u0027re doing HTTP poll obviously HDPE pole is MTI for that if you\u0027re doing set that doesn\u0027t necessarily mean you\u0027re doing either one of them just enricher given "
  },
  {
    "startTime": "01:00:54",
    "text": "Annabelle\u0027s comment just now I would agree that if we do split the spec then yeah that does sort all of that out you know fairly cleanly that\u0027s I can expand that to make splitting the spec is there a procedural yes so you slick us back then the then you don\u0027t have one document that says you need to do both documents you\u0027re compliant with the document by doing everything that\u0027s in the document and you can ignore the other document that you\u0027re not implementing it\u0027s not just procedural so in any case I hum for both MTI again assuming that they stay in the same document because from the perspective of the transmitter I think it would be better for Interop and better for kind of you know the ecosystem for transmitters to support both because every single comment that I have heard about constraints and being able to support something and not support something has always been on the receiver side oh this receiver won\u0027t be able to do that or this receiver won\u0027t be able to do an endpoint follow of law whatever transmitters for set for the most part aren\u0027t going to be as constrained it\u0027s not universally true I know there was for the most part there are exceptions to every rule and so that with that in mind it may be wise to split this into two things that are different but keep the same syntax checked over the wire in a different way and about back Amazon just to make you know good points are up regarding the procedural Nisour not of splitting the speck it to add on that right now you know we have a set draft that says nothing about delivery methods so people can do set and not do set delivery over HTTP as it is so we\u0027re already in a world where people can and will do set and not use either of these delivery methods the best we can do at this point from a MTI standpoint to say this these are MTI for people doing set delivery over HTTP person I don\u0027t really see a lot of value and argument for that I think following the the OAuth model here is going to be another better direction for us to go my concern about making both MTI is we run the risk of trying to tell developers that they have to implement something that makes no sense for their use case and I think if your standard is starts doing that your standard starts getting ignored and you know that\u0027s by far worse from a an "
  },
  {
    "startTime": "01:03:54",
    "text": "interrupt standpoint William Dennis um the reason I\u0027m against the both being empty I uh I think theoretically it to me it just seems like we have two different groups that that can have their own applications and be quite happy in that world and then practically and this is something nml mentioned earlier there are some concerns around scalability for example so from a practical sense the two teams from Google and Amazon that\u0027ll work on Interop are likely not going to be implementing and likely not going to be implementing pull so from a practical sense it\u0027d be good not to mandate something we don\u0027t actually do so I mean at this point I would advocate if there is a strong consensus for both being NPI to me that\u0027s actually indication that we do need two specs otherwise I think neither there be my position so John Bradley I think splitting the specs in sidestepping the issue is probably the best thing as Phil pointed out there are a lot of cases where we may have bi-directional by directionality and because of network topology a device acting as a receiver may only be able to accept may only be able to do pol but because of the same network constraints it can only do push when it\u0027s acting as a transmitter and trying to put empty eyes in is just it\u0027s going to be wrong yeah for it from a deployment scenario in probably the majority of cases so I think it\u0027s just simpler to let the profiles deal with it and split the spec so before we have on that let me ask if we have editors for both both specs if we move forward with this Annabel Backman Amazon I\u0027d be happy to edit the push spec we miss I\u0027m sure someone from my team is happy to be an editor on the push spec if they\u0027re not then I would be happy to volunteer Mike Jones Microsoft part of my concern with splitting stuff is there ends up being when you\u0027re specifying multiple delivery methods a bunch of stuff that\u0027s common between them and then it makes it harder for developers to read both if you duplicate the information and try to keep it consistent with which is a nightmare or if you only put it in one place and refer to it from the other both become harder to read than a single spec so I\u0027m trying to think you know "
  },
  {
    "startTime": "01:06:54",
    "text": "what can we do to make developers lives easier and I don\u0027t think we should split it benkei doc so Mike do you think that still applies even if there\u0027s three documents and so the common parts are and a single standalone document that is hopefully easier to read yeah I mean one of the biggest complaints about the jos work was that we put all the algorithms in a separate draft than the places that uses them so for instance all the signature algorithms in our in 75 18 even though the generic signature is in 75 15 and it confuses the heck out of a lot of people so my experience is no don\u0027t do that again Anabelle Backman Amazon I think if you look at the two delivery methods and the draft now the 99% of the overlap between them is set so it\u0027s already in a single place the only other thing I can think of that the that both methods use is like the error signaling and most of that I believe is coming from Jha anyway so I if that\u0027s the concern I\u0027d suggest we go you know look at the draft and see if there realistically is actually any significant overlap between the two at this point that isn\u0027t already standardized somewhere else channeling now yes he\u0027d be happy to stay editor of push and also wants to comment and currently there was a little commonality between the two methods Annabel Backman Amazon um if need be I\u0027d be happy to edit poll as well since we have a bunch of volunteers for push I think it\u0027d be better for somebody who is closer to those use cases to do it but if we don\u0027t have any volunteers I\u0027d be happy to do it if it means that we can move forward Thank You Annabelle do we have anybody who\u0027s closer to the poll whose case was willing to edit Mike Jones Microsoft we\u0027re gonna build both we have business cases for both so I\u0027m willing to work on one as long as I\u0027m also working on the other because my goal would be to keep them as consistent as possible thank you okay with that in mind I would propose a hum on whether to split the draft into two please hum yes if you think that we should split the delivery draft into two documents one full push on one foot pole please hum please hum if you think we "
  },
  {
    "startTime": "01:09:58",
    "text": "should leave it as one document so kind of rough but I think the room is in favor of splitting the documents and unless the objections I think this wraps it wraps up this discussion so no emptyeye to documents you implement you as a transmitter implement one or the other or both on either and with that thank you everybody for working through that it\u0027s nice to actually move forward on that topic okay so this is a little bit different some of you may recall around the beginning of the year there was discussion over whether we want to change the format of the security event token and one of the elements of that alternative design was this idea of subject identifiers types at the time it was discussed hey maybe we should this is something we should standardize within set but you know not move forward with a totally different set draft that was discussed on list never went anywhere I thought I would bring it back up here show what we\u0027re doing with this in the RISC working group and kind of toss it out there to see if people want to pick it up lift it out of risk and into set into second vents so from the risk standpoint a risk by the way for anyone who\u0027s not familiar is a risk and incident sharing and collaboration or cooperation I can\u0027t remember which one it is but the idea here is authorities for identifiers or for an identity can communicate security events about that identity to providers or to two services that are relying upon that identity so we sort of have two big use cases for this so we have to think about the first is the explicit reliance scenario where you have a party that\u0027s actually acting as a relying party to some kind of identity provider you know it using some protocol where you\u0027re getting you\u0027re actually walking through some kind of workflow to establish that relationship so kind of "
  },
  {
    "startTime": "01:12:59",
    "text": "canonical examples would be the open ID Connect relying party and the open ID provider or you kind of in the sam\u0027l world the service provider depending on the enterprise directory mm-hmm the other scenario we have are the implicit reliance relationships this is somebody like Amazon who depends on everybody\u0027s email provider implicitly and we don\u0027t have formal oo auth based relationships with them but you know we use your email as your recovery as a recovery mechanism so if your email account gets compromised and that potentially impacts other accounts so there is this implicit dependence there the the challenges presents for risk is in all of these scenarios we are identifying the subject in very different ways in the explicit use case you have typically some kind of shared identifier between the relying party and the IDP and in oh i DC it\u0027s an issue or the subject and sam\u0027l it\u0027s who the hell knows whatever it\u0027s specified in the the the metadata on the implicit side it\u0027s probably something like email address and phone number theoretically it could be other identifiers the point is that there\u0027s a lot of different use cases here so how do we within risk make sure we have a consistent way of saying what kind of identifiers we\u0027re talking about how we\u0027re identifying these subjects the the salut we have four that is something we termed subject identifier type and it\u0027s basically just a simple way to define a set of claims that we are using to identify a subject we\u0027ve defined four types within risk email phone number issue or in subject and then the fourth one ID token claims which I\u0027ll show in the example will help explain what that one is so we can step through just some quick examples in risk what we what we have within our event definitions if you recall and set every event has a capability of having a event body with with additional metadata within that within risk we\u0027re using this subject claim within that body to represent the subject of the risk event this allows us to have this kind of multi-part subject where you know we have n different claims that collectively identify the subject one of those you can see a subject type that tells us what kind of subject identify our type we\u0027re working with and then everything else within this subject object is the claims for that type so step through that phone "
  },
  {
    "startTime": "01:16:01",
    "text": "pretty self-explanatory issuer and subject again here you can see we\u0027ve got both issuer and subject claims here so you know who we\u0027re talking about importantly note that the issuer here could be different from the issuer of the set that\u0027s why we\u0027re specifying it here there\u0027s no guarantee that the system that are the entity that is generating the set is actually the issuer of the identifier mm-hmm it could perhaps be the relying party who is transmitting events back to the identity provider and in that case they want to communicate who they\u0027re talking about what subject they\u0027re talking about in a way that the identity provider is going to understand and the best way for that is this existing shared identifier that they already have [Music] the last one is this ID token claims this is a use case that is important for the in the explicit space as much as we would like as identity providers for all of our relying parties to be performing account linkages based on issuer in subject the standardized identifiers x\u0027 that doesn\u0027t always happen a lot of times they will just use email or phone number or some other what other claim that is theoretically unique to establish those linkages and if that\u0027s the case then they\u0027re not necessarily in a place to be able to use just issuer and subject so we introduced this ID token claims type as a way to say here are all the claims I know about this entity about the subject I know you\u0027re using one or a couple of these to identify the subject so here\u0027s what I know I\u0027ve shared with you you figure out whatever makes sense on your side so the question or the reason I\u0027m I\u0027m presenting this as I said we we talked about this earlier in the working group in the context of a different token Draft we opted not to go that route risk has since pulled this concept down to our working group it\u0027s in our our draft of the risk profile of set currently people had expressed interest in the idea so we want to raise the question should I just do we want to take this work back up into second and make a say second vent subject identifier type draft something along those lines and I\u0027ll note within risk we did we are we are defining this in an open way we we have a we\u0027re defining an ini registry for these things so theoretically we could standardize it and risk and other people could use it but it might be a "
  },
  {
    "startTime": "01:19:01",
    "text": "little bit weird Mike jones microsoft / the in person discussions at Cisco when we had the editors meeting I would be thrilled to work on this with you because I think it\u0027s of general applicability you actually just made an argument why it has to be in the ITF that you may not realize you just made because if you\u0027re defining and I on a registry it must be an RFC that\u0027s a good argument vacations cannot do that they can\u0027t define an arrest you at all hmm but you can but you can specify third-party specifications can register values they could not establish registries but you can define processes for managing the registry that don\u0027t involve the IETF right what can you I mean not you honey I know you can do the ladder because I read the RFC so say you can alright you think about the expressing native expert thing yeah that process for editing the they\u0027re going to be altering the registry they\u0027re gonna be appointed by the IOC anyway designated experts tend to get approved by the IAS GE are there other there are multiple registry rules that you can put on the registry some of which are more flexible than others I believe there is even a first-come first-served which doesn\u0027t require anything doesn\u0027t it expert is you know most of us most flexible yeah our specification required which also comes with an expert I believe that generally when you\u0027d use specification required they want an expert so it to interrupt I think we\u0027re a little bit in the weeds here because there\u0027s a proposal on the table it is to actually have it as significant document yeah I asked him up here to support us I think it\u0027s a it\u0027s an excellent idea and I should be expert review policy I think we\u0027ve Dennis I also support moving this to the IDF and on the I on a registry one thing I\u0027ve noticed a lot of the OpenID connect aspects I think they\u0027re registering using specification required so that that seems to work so John Bradley I\u0027m involved both places I\u0027d be happy to work on this here I think it\u0027s a useful thing yeah it\u0027s just easier I think because of the I on a registry issue otherwise it probably wouldn\u0027t make very much difference which place we did it so other any objections to having this as a "
  },
  {
    "startTime": "01:22:05",
    "text": "working group document run and whether there isn\u0027t a draft for just this right now so I don\u0027t know if we can ask exactly that question just from a procedural standpoint but I\u0027d be happy to make an ID that is focusing on this and then submit it for that so so you were planning to take it out of draft back man yeah I I already took it out of draft Backman sacrament token and put it in whatever the name for the risk document is right now I\u0027m happy to pull it out of there and put it in something else and put it in its own document okay so I\u0027m not hearing any objections Anabelle please publish an individual draft with this material and we will probably progress a to working with document oh we can yeah so so let\u0027s do it like that from day one cool thanks thank you okay I had two things that and the remaining 35 minutes we probably don\u0027t need all of that and Annabelle would you like to speak about the expiration claim and valve acumen Amazon so for context the expiration claim the jot expiration claim in the set draft today the guidance on that is not recommended and the the rationale behind that is the statements being made about about by the the security event or token about the security event don\u0027t really expire reality doesn\u0027t expire um which is generally hopefully true and and so putting an expiration on that doesn\u0027t necessarily make sense mm-hmm the counter argument to that is expiration plays an important role in indicating to the recipient of a jaw how long they need to worry about cashing JT is for collisions and honoring the the the the the jaw in general on the the further argument is that the expiration is not a statement about the data within the jaw it\u0027s a statement about the jaw itself so the by say by putting an expiration in a security event token what you\u0027re saying is this token expires this token should no longer be interpreted or accepted "
  },
  {
    "startTime": "01:25:05",
    "text": "after this point that has no inherent a statement about whether or not what it says is still true but I think I think Marius made somewhat different claim about cashing of identities yeah that\u0027s the that was his original motivation here yeah that\u0027s the the first the first time I I brought up that if we\u0027re yeah if you\u0027re trying to validate whether or not you\u0027ve seen a job before you\u0027re probably doing that by tracking jdi\u0027s that you\u0027ve seen you don\u0027t want to hang on to JT is forever so what\u0027s your TTL for that cash basically Mike Jones Microsoft I replied to marius about this on list at the beginning of our time but he\u0027s proposing a layering violation the set should be valid and the same no matter how which transport is used he is proposing adding a claim or using a claim in the set in a transport specific way if the transport protocol uses caching as a cache lifetime hint whereas if you look at most transport protocols that do support caching HTTP being probably one of the most well known the caching information is provided as protocol headers not in the content being communicated so you don\u0027t add stuff to the HTTP body about caching you add stuff to the HTTP headers that\u0027s specified by the transport similarly we should not be injecting transport specific information into the set because that\u0027s a layering violation so the spec already has it right fill hunt I was just gonna say the same thing Anabelle back man Amazon I I think we\u0027re missing the word caching here yeah I think it was using in the email thread I don\u0027t think we\u0027re actually talking about caching here we\u0027re talking about the the record of which jdi\u0027s you\u0027ve seen and therefore which sets you can throw out or which jot syndrome generally we can throw out of which guts you shouldn\u0027t necessarily trust you don\u0027t want to have to maintain JT eyes forever you don\u0027t want this endlessly growing database of JT eyes that you\u0027ve seen you want to be able to expire those records otherwise it doesn\u0027t scale the question then becomes what\u0027s what\u0027s your expiration "
  },
  {
    "startTime": "01:28:07",
    "text": "time on those records how long do you have to hang on to a JT eye for before you can safely get rid of it with expiration baked into the token that gives you an out because after that expiration time you\u0027re gonna ignore that that jaw whether or not you see in each 84 cuz it\u0027s expired so you that that gives you an upper bound for what your your expiration time I or a lower bound for your expiration time needs to be so yeah it\u0027s called cashing it\u0027s not really cashing a concern I have here is that sets are statements about state changes that occurred in the issuer we\u0027re not making commands we\u0027re not making security assertions and we\u0027re trying to treat them as commands and assertions which brings up the issue of how long do I keep it for how long is it good for the reason there is no expiry as we\u0027re saying something occurred in the past so the past doesn\u0027t expire it\u0027s a statement of record that was the key reason we started SAC was to differentiate from access tokens in this regard in a very strong way so I but that said people are free to use it however they want but I don\u0027t see if if family animals saying that where the Interop issue it\u0027s it\u0027s up to the receiver based on how they\u0027re using it to decide how to mitigate the problem at the level the spec is written I can\u0027t see how he would solve this in an interrupt way or a specific use like this so caching jdi\u0027s doesn\u0027t make sense because the premise always has been you get a trigger you throw it away you\u0027re done but do we care at all about replay protection I don\u0027t think so but it\u0027s not the same kind of a damn \u0027putin so you would expect because it depends on what the receiver decides to do that and in the introductory text we may be clear that the receiver decides their own actions and therefore the consequences of their actions determine whether a replay attack is possible or not that\u0027s how I read it because we\u0027re not issuing a command we\u0027re not issuing an assertion like like a log on assertion this is a different animal so there shouldn\u0027t be a replay attack because we\u0027re not asking somebody to do something we\u0027re not changing a state explicitly the receiver is the one that decides what to do and what action to take therefore the actions they take could trigger a replay attack but that\u0027s of "
  },
  {
    "startTime": "01:31:07",
    "text": "their own making do we foresee reasonable receivers doing stuff with sets that we need to help to help them with replay protection we\u0027ve already provided the j-team that mike jones microsoft we\u0027ve already provided the jti value such that if they want to detect replay they can do so so we\u0027ve done that I mean that being said and again I said this on list but since we\u0027re discussing this in the room I\u0027ll say it again because sets are factual statements about something that occurred we would be architectural II in a very strange place if we were to encourage deployers to make up an arbitrary expiration time about something which remains true forever we should not be like encouraging sort of random values to be generated now particular use cases and transport protocols probably can and will have time values that are used in particular ways but it may not be expiration it might be based on the issued time which again is a true thing that doesn\u0027t change there\u0027s Delta\u0027s that lots of protocols use but it would be a layering violation for us to try to jam that into the jaw I have Charlie Marius again transport was used as an example to guide the value of exp expiration no transport injection was many such replay attacks real issue regardless of transport method Anabel Beckman Amazon I think it\u0027s dangerous for us to make any claims that replay attacks aren\u0027t going to be relevant yes theoretically a receiver could keep a record of every GTI they\u0027ve ever seen that won\u0027t scale there\u0027s a reason expiration is in John and not ID token uh it\u0027s clearly intended to be there for more than just assertion token use cases I think the the use case we\u0027re talking about here is very much in line with what is described within within John itself John Bradley I\u0027m gonna disagree with Mike slightly you know the the reason why we added JT I was to be able "
  },
  {
    "startTime": "01:34:09",
    "text": "to detect receiving the same token multiple times without having to sniff through lots of different fields so that you know sometimes that\u0027s the security concern sometimes it\u0027s just you may you may wind up having processing errors processing the same thing twice the expiry is intent was intended to be you do not you should not receive process this token if you receive it after this time not that the content of the token is invalid which is I think that that the information in the token is no longer valid which I think was the the point that that some people were making but if you don\u0027t have some period at which point you will no longer process the token based on time then as Annabelle points out you have an infinite list of jdi\u0027s that you must keep in that just as impractical from a deployment point of view so there is you know when JT I was created in in light of having the expiry time that the interrelationship of those as pointed out is that it\u0027s not a layering violation it\u0027s how long do you need to keep that list of jdi\u0027s to successfully detect duplicates I think that\u0027s a perfectly fair use for it I think we may need to be clear that you shouldn\u0027t interpret the expiry as being the information contained in the in it\u0027s no longer valid it\u0027s just that you can\u0027t receive it anymore for processing reasons which is sort of the way that we sort of simplified some of the many fields in sam\u0027l not not on or after in various other things into expiry but this is expiry is intended to be the top the processing time for the token not when the information expires Mike Jones again and again I said this on list but it\u0027s fine for profiles to say that they\u0027re going to use the expiration claim in a particular way including the way that John or Marius are describing but the reason I\u0027m reacting so strongly is Marius was proposing making it mandatory and there\u0027s plenty of use cases where that\u0027s the wrong thing to do I\u0027m not against using the field I\u0027m against jamming it down people\u0027s throats we already got it right profiles can already use the field if they want to Anabel Backman Amazon I think my concern with that is currently the draft says it\u0027s not recommended um I would I would honestly say let\u0027s just strike the content in the draft that "
  },
  {
    "startTime": "01:37:11",
    "text": "refers to exp and and let the the text that\u0027s in John stand as guidance for that what Mike responding directly that one of the problems was striking that is there\u0027s other places in the draft where we had working group consensus to use the lack of the XP as one of the ways of clearly breaking any ID token implementations so that there couldn\u0027t be confusion even in the absence of explicit typing and so if we\u0027re going to keep our ID token differentiation rule we have to allow this to be optional Anabel Backman again responding there\u0027s also other mechanisms for differentiating those in some cases providers probably have to use something like exp omission to protect against the the ID token mimicking scenarios I think other other scenarios they won\u0027t need to I think we can have that guidance without saying that exp is not recommended you know full stop for for sets I think it\u0027s it\u0027s primarily that not recommended language that that I\u0027m objecting to and I can\u0027t speak for Marius on that whether he\u0027d be fine with just removing that and I would be fine going as far as just saying it\u0027s optional but making it must that\u0027s just wrong I\u0027m on board with that benkei duck so I guess I have a question there\u0027s someone hypothetical but perhaps interesting to consider so if we consider the case where exp is present and it\u0027s used to you know for the replay protection purposes and I as a receiver know for some reason that I have not processed this event before perhaps do the issuance time and I have been processing for a while if I trust the expiration claim and I should not process that event but I know I have not processed it and perhaps I want to what options do I have yeah I think that\u0027s a good reason why we shouldn\u0027t use it that way at all so one particular path would be if I could give it to the set issuer and say is this still value can you reissue it with a later expiration time for Myers so recommending against is the issue and yes differentiating against ID tokens is an open issue I did not ask for extra to be a must will cut the lawn after Anabella Mike the reason I said he was asking that it be immersed is in the email thread Marius asked should we require its use that\u0027s a most the other "
  },
  {
    "startTime": "01:40:18",
    "text": "potential alternative is to have an explicit expiry of the jti which could be a new claim which would then solve the be more explicit about solving the confusion about what expiry actually means so that should also be considered as as an option and might would let us say something like if you\u0027re sending a jti you should say how long you need to maintain that jti for before it\u0027s I\u0027m not going to send it again so there are potentially other solutions that could be looked at the reason exp was not recommended was a group decision and a time the group decision was is that we were not using it the way JWT defines it and nor would we redefine it we\u0027ve made a lot of changes to stop redefinition of JWT claims so I would as your editor counsel strongly against changing that text at all I would prefer if we have to put it in a set a new out to be be defined for this new purpose assuming we can come to an agreement on it but also this strikes me as more of a transmission issue and I think it maybe should be in the HTTP layer as part of the caching header record it\u0027s not really part of the set we\u0027ve also we\u0027re in the publication process and yanking it back doesn\u0027t seem to be that smart cuz we just opened the doors again and we\u0027re not finishing and we\u0027re not moving ahead let me let me clarify this point so the document is going into ITF last quarter where everybody can make comments including ourselves of course we would have liked or we would like the document to be closed as far as the working group before that but we we are free to make smaller changes without interrupting the flow without interrupting their workflow if we make larger changes and it\u0027s our decision we might need to start the process in you I think for a small change around the single claim we can just do it in Australia it\u0027s not ideal I agree yeah so yeah I wanted caution about that I feel that the replay and the caching things are gonna be different from push then from poll and that Mets why I would prefer it and an HTTP header because you may have a different recommendation you expect push to happen delivery instantaneously so if you don\u0027t process it in the next "
  },
  {
    "startTime": "01:43:20",
    "text": "few minutes you should probably ignore it where it\u0027s poll if you\u0027re only picking it up every once an hour then it\u0027s a different expectation so it seems to have you have more flexibility if it\u0027s an HTTP Thanks if I understand it correctly a lot of it\u0027s about the the policy on the receiver side being able to say based on a jti how long they want to remember those in order to not duplicate process things in order to policy a replay prevention or whatever and using X breeze is a pretty well-defined pattern for that in other context like single sign-on but I don\u0027t think it necessarily is necessary here are applicable here where there\u0027s already sufficient information I think in what\u0027s provided to accomplish the same goals based on the policy of the receiver and that is the the jti is there and the IAT the issue dot value is required in the token now so a receiver could set up its own policy based on whatever its needs or profile is to say that I will only accept tokens or accept sets you know that have been issued within the last hour two hours whatever is appropriate for the delivery mechanism and then expire them would not expire them purge remember the the JT is for that period of time so I think that that there\u0027s sufficient information already available to to implement the kind of policy that mario\u0027s is looking for through the introduction of XP without using the XP at all but but relying more on the the issued time of the token itself and and maintaining its own internal policy around how to do that and that also takes any Onis off of the sender to dictate to the receiver how long it needs to remember things or anything like that it puts all the the role of the policy and the needs on the system that\u0027s going to be dealing with it and about back when Amazon just to clarify again since apparently there\u0027s still ambiguity around that no one is advocating use of the exp claim in cashing systems whatsoever no where nobody has suggested that if the word cashing has been used it was a misuse of that word we\u0027re not talking about cashing on that note I as far as I\u0027m aware HTTP has never been concerned with issues of replay attacks that\u0027s that\u0027s not something that we try to address at that level and bear in mind we\u0027re not introducing expiry here expiry was introduced in John what we\u0027re saying is there are valid use cases for using expiry as it\u0027s defined in John with sets the question is then is there actually a "
  },
  {
    "startTime": "01:46:21",
    "text": "strong argument at the set level to say no you can\u0027t use expiry oh no you shouldn\u0027t use expiry as its described in John when working with sets and I I don\u0027t really see that here Charlie Maris again two separate comments first time separate claims sounds good JT exploration is not transported with specific claim that defines data exploration belongs next to the JT I not in a different layer and the second thing your transmitters have transmitters have retry strategies and periods that the receiver cannot easily take into account if it decides on its own for how long to to track JT I all right to conclude this discussion I don\u0027t think well we obviously are not ready to take a ham on anything concrete I think it\u0027s clear that the sense of the room is that there is an issue and we\u0027ll take it back to the list and make a decision and the decision may involve a small change to the document while it\u0027s going through is reprocessing last on my list of optional things to do Phil do you like to say a few words about the document you submitted tonight okay Phil here I was thinking about this problem that we spent a lot of time today talking about with regards to MTI a week ago so I looked at how do we change optionality of methods to solve the the problem of httpclient who can be client who can be server so I took the draft that we had and merged the two methods into something that\u0027s now called that I\u0027ve called symmetric set Transfer Protocol it actually turns out that a lot of things peel away and simplify at least the draft is smaller it\u0027s symmetric in the sense that the parameters used in requesting response are the same regardless of which direction you\u0027re sending we also end up with the possibility of having not only push mode pull mode but now you can do push pull which means if you get to the point and we have a lot of cases for bi-directional communication you can have that the key benefit though is we change optionality in the spec from two completely separate methods to one method that from understandably from the standard perspective of push is slightly "
  },
  {
    "startTime": "01:49:23",
    "text": "more complex because you you have the ability to send more than one set in one post but that\u0027s really the only change in the previous delivery draft the air signaling remains the same from the delivery draft everything else is unchanged it\u0027s almost 95 percent backwards compatible for pol the one parameter I changed I simplified one parameter that was there the max events was changed to return events so it\u0027s a boolean now nothing else new was introduced so I\u0027m not saying it\u0027s the solution but it might be a compromise that gets us to a single method that can be deployed in both cases your choice here is to choose whether you want to be a client or a server or not which protocol you use so information can flow either way in independent of which HTTP mode you\u0027re running in so that\u0027s one possibility and I throw that out there you know I understand that the push people aren\u0027t that thrilled with it so but it does get us to a cleaner single MTI I think so it\u0027s there and it\u0027s on the table and I invite you to look at it it\u0027s now published yeah and I suppose people not lining up and I suggest we do not discuss sstp now it was just now just two yesterday submitted and we\u0027re not ready to discuss it now even if amilia with it even those who are familiar with that because the room needs to be familiar with it for an effective discussion can I give an advisory comment please don\u0027t I do want to apologize to the group for not releasing it earlier there was the closed zone time but I wanted the discussion to proceed on the current draft I still support the delivery draft going forward if it can and I did not want to distract but a number of people in urged me yesterday to get it on the table so there it is anything else any other issues if not then we\u0027re done thank you very much "
  }
]