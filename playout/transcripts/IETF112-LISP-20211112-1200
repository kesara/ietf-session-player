[
  {
    "startTime": "00:00:23",
    "text": "foreign i will still wait one or two minutes just for later arrivals and then we will start okay folks"
  },
  {
    "startTime": "00:03:11",
    "text": "so hello everyone i hope you hear me loud and clear welcome to the lisp working group in this itf 112. uh we are a couple of minutes late but was a little bit impossible to wait a little bit in the meantime you got more familiar with the note well that applies here the very very very short summaries that whatever noise you do during this meeting is a contribution to the ietf however there is also another little piece of not well that is important to detail is the fact that we have a code of conduct detailed in rfc 7154 now lisp i think that"
  },
  {
    "startTime": "00:04:00",
    "text": "we behave okay and this is important it's important to respect uh each one another and that we have discussion based on technical argument not nothing else okay and we we struggle to find global internet solution and all in operational environments and we contribute to the ietf as i said in lisp i think we we behave okay unfortunately it's not in every in each working group that is going that way but um it's important that the the same behavior you have here please spread it in the etf bring people to be reasonable and respectful okay as for the business and this is the usual pointer i'm luigi uh joel alpern is my co-chair he's also online padma house online is also our secretary she will take uh she will provide minutes offline later on as usual the usual links are here for the charter the job room audio stream mythical and the agenda and slides okay a little bit of an update uh since one one one uh the developing uh a few documents that have been pushed for publication so are now in the hand of alvaro our responsible id which is also online okay um so we are making progress in a certain way and i say in a certain way because if you see on the your right hand side there is a lot of red meaning that there are documents that are sitting there for a while okay"
  },
  {
    "startTime": "00:06:00",
    "text": "now um the bottleneck is lip sack okay is the the last piece of work that is missing in order to unblock a lot of other documents including by the way uh the lisp introduction okay which has been updated by damian susan de mental this has been done just to to because the document was so old all that there were references to the experimental rfcs which i mean make sense to to to update it and put the right references there which has been done uh between 1 11 and 9. okay uh as for the lisp sec the status is the following i'm shattering the document so i already prepared the write up but because i had a few [Music] i would say small issues on the document uh just to to clarify things a little bit i i i wrote my review i sent it to the outers um as you know albert is the one holding the pen and making the changes usually and managing that he is [Music] a little bit busy this period so he was not able to make any progress on that side so recently contacted back damien which is willing to to take the pen and try to solve the residual issues that are in the document i will work with him to bring him to speed about the latest development hope i hope that we are able to to finish this document before christmas okay however i invite all the co-authors to be a little bit responsive because any change that"
  },
  {
    "startTime": "00:08:01",
    "text": "damien does has to be validated by the other routers okay as for the other documents we have the young model i think this is quite ready and after we unblock the lisptec this should be good to go as well and go for the last call we have lisp vpn and lisp l2 l3 mobility which will be discussed later on today they are on the agenda um and then we have a bunch of working group items that so basically are working documents that were sitting there for a while and it's time to to pay attention to them and review them so what i suggest to everyone is to have a look to them and review them we will go over each of one of them in order to see whether or not we want to publish them or not okay because at the end every publication is the product of the working group so we have to agree to to to move it forward if there is interest in the document uh in looking at the charter there is one one and only piece of work that is missing is the traversal document okay but we have a good candidate that was around has been around for a while so the lisp not traversal um so this is something also to consider in order to make progress for 113 okay so as for the agenda we have two working group items presentation so as i said before this is lisp vpn and lisp eid mobility okay and there is a presentation about our known working"
  },
  {
    "startTime": "00:10:00",
    "text": "group item which is the map server reliable transport and we will conclude with the list fix okay and this time we have enough time to discuss so we we shouldn't be short in time so i invite everybody to to ask question clarification just discuss this is what we are for here why we have a virtual meeting this time maybe physical meeting next time let's see let's hope okay so anything anybody has questions or remarks on the agenda or working group documents take it as a no so the next three presentations are from mark mark you can share directly the slides your yourself in the sense that they have been uploaded on the mythical and uh if i stop sharing you can ask to share and say oh yeah you're not sharing this time or do you want me to i i can if you wish as you like yeah it's fine yeah if you share i can go okay let me let me choose the first is yeah d mobility as far as i remember so this one is the first um thanks lizzy yeah this is mark uh work at cisco um yeah presenting three things today but yeah hopefully uh i'll take uh hopefully i won't take too much time for them um two of them as lucy was mentioning are leave mobility and and these vpns these two are working group items um"
  },
  {
    "startTime": "00:12:03",
    "text": "we have been using them for quite a long time and would like to to recover the discussion around them and and make some progress on on these two documents okay the first one is this one eid mobility uh so yeah the title is l2 s3 id mobility using a unified control plane um questions when when you say we are using them for a while means that uh it's it's it has been uh there is at least one implementation and you are yes using it for yes for the next two slides or also for the third one the the reliable transport actually the three of them yeah we we we use them a lot actually yeah it's we have yeah to be honest we have a lot of interest in this studios because they constitute the bases of most of what we do these days okay so yeah starting with this one if you can go to the next slide so these drafts essentially uh provides a list of methods for using a common control plane to concurrently support layer 3 overlays and layer 2 overlays both with eid mobility um with respect to layer 3 overlays the the draft mostly focuses on mobility i mean it provides some forwarding descriptions but but the most important part is what to do with mobility and with respect to layer two overlays it it goes over everything right the unicast and multi-destination non-ip and ip inter-subnet it also talks about"
  },
  {
    "startTime": "00:14:03",
    "text": "how to optimize urban nd resolution using lisp nexus live please with respect to layer 3 overlays what the document describes is that without mobility what you need is basically already described in in the rfc but in addition to that it gives some guidelines on how to support mobility with lisp as i was saying right the the idea there with mobility is it has registered prefixes that are locally attached um eads it considers locally attached to the ids then it describes how to support traffic between sites again here all the rules are already described in the rfc but then it puts the focus on on what to do when eids change location and um if you want an important part here is what to how to update the the network when when these changes happen right and and it proposes two methods one is data-driven smart and and the other or pops out uh notifies okay um next slide please so the next three slides try to illustrate this with a picture uh what to do with l3 overlays and mobility the picture starts with what we already know let's say we have multiple sides and we have two endpoints let's call it a and b uh and point a is connected to side a and point b is connected to set b and and they are talking to each other right um so essentially what we will have is the"
  },
  {
    "startTime": "00:16:01",
    "text": "xtr on each one of the sides register these locally connected prefixes we use statuses 10 1 1 1 and 10 2 2 these two prefixes will be registered with the mapping system and then when a is trying to send traffic to v the xtr on on site a will have resolved a map cache uh with for for b with the r log of of side b but this is basically now nothing new here um next slide please and and now we go and what happens when when a prefix moves so let's assume now here that b moves to from side b to side c um [Music] now side c what will happen first it will detect the presence of of these uh endpoint and and the xtr or the etr on on this side will now send a new registration to the mapping system updating the vr log or the location of of these this node now what the document proposes or describes is that um the mapping system must send a map notify to the old location the the the previous etr that registered this prefix and when this xtr or etr receives this magnify it will create what the document calls an away entry that it's basically a local registry that hosts or an eid that was locally present at the atr now it's not there anymore this is what the document calls an away at this point the mobility detection has completed but the problem that we have is that map"
  },
  {
    "startTime": "00:18:02",
    "text": "caches or that have been stored all around other sites in the network are still staying next slide please and this slide talks about how do we update these stalemate caches and we the document proposes two basic options i'll start with option one option one is okay we we have on on this remote side we have the steel map guys so traffic is still being encapsulated to the old site traffic will will be sent for example in this case from xtr inside a to steal etr in in side b now when site b the xtr receives this traffic it will see that it's destined to uh knee id that it's it's in the away end so as a reaction to this or or to this discovery what what this site will do is send an uh data driven smr to to the original side basically this smart is telling the other side hey you're sending traffic to wrong location and and following this smr the original site will will refresh its its mapping entry will start a map resolution process with a mapping system and and find the new location of of the host or the id and start encapsulating to the new location this is option one we call it data driven smart the second option is take advantage of the procedures described in the pops up drafts and and [Music] whenever a site learns a map cache also subscribes for it so um the mapping system will send i'm"
  },
  {
    "startTime": "00:20:00",
    "text": "notified as a publication an update to all the sites that that that have this stalemate guys okay um next slide please so this was for layer three right as we were saying for wording in layer 3 is all rfc mobility is what's different in this in this draft when it comes to layer 2 overlays the draft goes a bit more specific and and it talks about um [Music] what needs to be registered what it's all about right and and it started by saying okay either is in l2 overlays or mac addresses as you all know but then what the document proposes is that in order to separate or keep layer 2 and l3 uh separate in in the network we dedicate a specific instance like this for for l2 and l3 purposes okay so all the mappings for l2 and l3 or particularly for l2 will be iid scoped right and and these mappings will be mapped to our log mappings and i mean the way we use instant ideas to segment the two types of overlays or all these christ in the vpn draft that will come after this one [Music] then what the document goes is into talking about how do we do unicast traffic handling uh yeah bomb traffic handling um rv and nd support and mobility support and and the next slides go a little bit more on detail about these things next slide please so first mobility um mobility with l2 as described in the document is no different from what we do"
  },
  {
    "startTime": "00:22:01",
    "text": "with l3 right so the idea is that in in this case mags are moving within a broadcast domain or xtr is connected to common broadcast domain but but the concept of mobility is exactly the same right and the way we update web caches it's also the same data data-driven based sms or or pops up one specific node with respect to forwarding and l2 is that ttl handling changes from what we do in layer three so the idea is that even when traffic is crossing this l2 overlay the ttl header of the inner package should not change okay next slide in order to support broadcast and multicast traffic all participants of an l2 overlay must join a common group right so that we can broadcast this information across all participants the document document reports two possible approaches to these when multicast underlay is supported in in that case all participants must join a common group this common underlay group let's say multicast group and and this multicast group will be associated to the particular instance id that they are participating in when multicast underlay is not available then this document takes advantage of the signal-free multicast target and and proposes that all the members register to a very specific group right as for zero and and the group is uh and group all ones okay and and the same right uh following the rfc uh"
  },
  {
    "startTime": "00:24:00",
    "text": "the map server and and the participants will will compile a list of all the participants that so whenever there is traffic that needs to be broadcasted it will be it can be replicated to all of them next slide please okay there's one specific thing in in l2 overlays is that normally arv and nd traffic are uh represent a lot of traffic in the network so one thing that we normally want to do is limit the amount of this traffic that that floods the network and this is something that we can also uh deal with with with lisp okay and in this particular sense what the draft proposes is that we dedicate one instance id to to to these mappings um the idea here is that um xtrs can register with a mapping system pairs of ip addresses we consider the ids to our logs mac addresses so whenever an xtr wants to resolve one ip to mac binding instead of running the network what you can do is just query the mapping system and try to gather this information yeah from the movie system okay next slide please this is still work in progress but this was one one of the last remaining eating items that we discussed in the group that was needed for for the document um the idea is how do we provide multi-homing services um one discussion that i'll open to to the group is that we're having is whether this is something that we want to to document in in the draft or we want"
  },
  {
    "startTime": "00:26:00",
    "text": "to [Music] keep for a separate document okay but but yeah let me talk about how we are approaching this and but again we are still uh experimenting with this and seeing if if this works the proposal so far is that we use an id to to identify a segment that is multi-homed uh with with multiple xtrs okay and and the idea here is that all xtr that are part of this l2 multi-homing group register this segment id with the mapping system with with two specific flags right the one they always use the merge request bit um so that through merge semantics the the map server consolidate consolidates a list of our logs belonging to this group and they all also set the one magnify bit so that all xtrs are notified with our log list that the map server is is compiling with this we achieve two things right for example uh when when when we need it right and and and a designated firmware that needs to be selected uh for this group the the map server can choose one out of the consolidated list right instead of having to implement that distributed algorithm um between xtrs to to make sure that they all choose the same um for example when we need to apply split horizon uh the same right based on on these map notifies all xtr's men know all the other participating str's so they can they can apply it they have the knowledge to apply this okay uh next slide please and finally yeah uh"
  },
  {
    "startTime": "00:28:03",
    "text": "some other documents call it aliasing we still need to decide if this name makes sense here but but the basic idea here is that um when multiple xtrs are participating in in one of these groups they register eith with with an additional attribute that is this um segment id and and then we we use pops up procedures as as described in the drafts so that members of the group they are all notified about uh yeah these that are detected by other members of of that group right with these all all xtrs are able to learn the other ids preemptively learn let's say all the other ids add them to their local databases and and and send the common mac registration to to the market system now one node or one question that we have with the group is whether you think that we should be using side id for this or or or creating a new segment id tag to support these use cases is the the right way to go and yeah next slide that's the last one open two questions yeah um as i was saying right we have been using this quite a lot um it's it's working right in practice [Music] are there any questions uh i i have a couple of just for the clarification so so you you basically use the instance id in order to distinguish distinguish between l3 and l2 overlays basically right"
  },
  {
    "startTime": "00:30:01",
    "text": "yes so and you you but you do not reserve any specific value to the iid i mean is just by configuration somewhere you say this value of iid is for l2 is that yes yes exactly so basically at least how we support it is in configuration you go and and you start defining instance ids and then you say okay you locally on the router normally what you do is you bind an instance id to a vrf or to uh to to a vlan right and that's the way the router knows right whether to link it to an l3 domain or an l2 domain in what about lisp gpe because we have the other other headers that could be used to to to um yeah to encapsulate and you can natively use different um l2 l3 other things inside basically yeah yeah i mean the the actually the draft has a section for encapsulation and i need documents right that [Music] you can combine these with least gp and and it fits right [Music] actually interestingly with vxlan header right and i mean you need an and a header that is able to encapsulate l2 and l3 um and also segment right that's that's where the instant id part comes into play and just uh last two things is um so it makes more sense to me instead of defining a a a new segment id"
  },
  {
    "startTime": "00:32:02",
    "text": "maybe to use the site id in order to to but i mean this is just personal opinion i mean and um instead as a chair i have to say that you should revise the the document in the sense that i just skimmed through it and it's based on the old uh rfcs so so he is good to update to the beast document and make sure that he's coherent with the set of documents that we have now i didn't check but maybe also because um lispsec is mandatory to implement uh maybe think about what if there is any implication or whatsoever on that side on the lip side okay okay okay these are good points yeah um yeah to be honest since the draft has not changed much we haven't been paying enough attention to this but i'll i'll make sure that that we are good thank you okay uh so let me stop sharing this one and we'll go to the other one that should be this pvpn here we go okay so unfortunately victor couldn't make it today he was going to present this but i'm taking over um i'll um this is the other draft that it's a working group item um and and the same that we said before right this is extensively used in practice and and we'd like to bring by the discussion on these drafts and make sure that they move forward next slide please"
  },
  {
    "startTime": "00:34:02",
    "text": "okay so this code of this drive is all about segmentation right segmentation in particular of of the iv space and it talks about how to use instance ids and extended tids right doubles of instance ideas and aps to to to segment uh our our network right it it goes into how what are the implications of these for control plane procedures how do we deal with this at the data plane and forwarding level okay and it addresses for both of them yeah unicast and multicast support the document also includes some considerations on segmenting the art lock space um from the perspective of the document most of the the the attention is on eith space the the segmentation of the airlock space is can be considered more as an opportunity right and how to deal with it but the important part is is the id space next slide please the draft also provides some guidelines or some tries to address the the methods to to to support cross vpn communications or most commonly known extranet and and for extranets it it talks about how to deal with unicast and multicast traffic and and what are the implications when we do cross vpn for for example pub sub smart generation or lock probing okay now the document uh proposes a particular encoding for home ids and this this is relevant for extranets right um and and this is the encoding right at least we"
  },
  {
    "startTime": "00:36:00",
    "text": "first item that says this is the home id and the second item it's just the alcav type 2 with with the instance id value and you you will see next that but the home id is always encoded as an art lock as a proposal here okay next is like please okay the the next slides try to go again a bit through packet flows here um i'll describe them very briefly not to go too much into detail but the the basic idea when we want to provide segmentation is that we do iid scope registrations and and resolutions right and yes luigi was saying right this in some sense applies also to to what we were saying for l2 and l3 right so the idea is that now we scope everything within the context of an instance id uh wait what do we mean by scoping is for example if we focus in the map registration let's say that our network is organized so that we have a couple of instance ids and and we have endpoints associated to each one of these instance id locally on on each side this instant id can be translated what we were saying to a vrs to a vlan or whatever we we decided associated with um the idea is okay now we have an endpoint for example in this picture side v will have an endpoint let's call it endpoint b that is associated to instance id1 and and decide we'll register these with the mapping system we using these extended eid right extended the ids is nothing else than registering as an eid the tuple instance id plus plus the eid"
  },
  {
    "startTime": "00:38:01",
    "text": "and and this will register with the associated data of the set now if we turn to map resolution site um the same right we make use of these instance id so let's say that endpoint a in instance id1 wants to talk to endpoint b means id1 so so what it will do is when this traffic hits the xdr the xtr will also use this extended eid to to express interest for for for that particular destination right and and the same extent that the id in this case is instant id1 and and the destination eid um once map resolution completes all these is stored also using the segmentation in in forwarding let's say or in the cache um and and again right there using this this tuffle or instance ids and id and and this is the basis of the whole segmentation when traffic is forwarded we do the same right as we were talking before um on the header of the forwarding of the encapsulated packet we will stump the instant id so the the egress node the etr knows which segment this this traffic is associated with okay next is likely extranets work a little bit different here but basically the idea is okay what if we want to allow traffic to to cross segment boundaries okay um so the idea here is that okay it all starts extranet assuming that we have a policy uh in the network that says okay uh traffic from this instance id can be leaked into this other instant id um how this is structured following the document is that the etr uh will always"
  },
  {
    "startTime": "00:40:01",
    "text": "have this policy right and and for example using the the example in in the picture we have a site v that sorry we have a side v that for example locally connected it's only spawning instance id3 okay but it has a local policy saying okay you have to allow traffic from instant id 1 and instant id 2 to to reach your destinations in instance ac in order to do this the xtr what it will do is is replicate the registration [Music] with with extended eid let's say 3v but but now in all other instances right so what what it will do is is replicate this registration we've extended the ids of all the target instance ids that it won't it wants to allow to communicate with with this knot something that is particular about this registration is that it carries the value of the destination instance id in this case three as an additional attribute of the registration and this is what the draft calls as home id um [Music] now if we turn to the sending side let's say we have this endpoint a that wants to talk to endpoint b the same traffic will hit the itr on site a and but this traffic is coming in instant id1 right so at that point this xtr uses um the vpn methods to to resolve destination and we'll send this this map request let's say with ins the extended id one b right because at this point this idr doesn't know that this is an external as a reply to these map requests the the"
  },
  {
    "startTime": "00:42:04",
    "text": "the mapping carries this home id and this is installed into the map cache okay and this is the important part yeah with respect to the streamers now traffic will be encapsulated with the destination instance id right so traffic send on side one instant id one will be encapsulated with uh instance id3 right so that when side v receives this traffic directly delivers to the end point in the appropriate vrf or vlan or the proper segment okay and next slide please and then yeah the draft also addresses how do we deal with extranets and and multicast it uses signal free multicast for this the same as before um [Music] in this case everything more or less works the same with one mine or not is well not minor but an important note is that um well let me go through the flow and maybe can can explain the difference at the end so the same as before right if we start from the destination sides the destination sides now what what they will do is oh they they see some local nodes um joining a particular group or expressing interest for for a particular group because they have this extranet policy what they will do is register this interest in the multiple instance id is that that the policy is saying that that they should replicate this registration okay and and this is what's happening in this crowd right so um [Music] um receivers bnn or or are expressing interest in in in having um traffic"
  },
  {
    "startTime": "00:44:02",
    "text": "from source a to one particular group b we deliver to them okay now the important thing or the important difference here is that when site a in this picture tries to resolve the list of our logs that it needs to replicate to it will receive these replic this list that has been learned through through signal field procedures okay now this reply also carries this home home ids but um replicating to every destination instance id would be a bit prohibitive in terms of cost right at the sending site so so in this case what changes with multicast and external is that the source will still encapsulate with the source iid uh to destinations and and it will be the egrecides the etrs and the sites to to decide to do this conversion between instant id right so that they will re receiving traffic from from instant id1 in this case and and they will be the responsible to locally replicate to to the corresponding instance ids okay next slide please the same as before the draft has not had many updates since it was adopted by the working group in practice it has been working for quite some time now we've been using it in practical deployment yeah most of the procedures here and and the only last addition that i could find with with respect to the draft is that it it included some considerations on how to calculate negative map replies when"
  },
  {
    "startTime": "00:46:01",
    "text": "when we are using extranet okay and and in order to include the home id in in this replies but but yeah it's a minor note in the draft so that the rest of the contents haven't changed so much next slightly and as i as we were saying right so the vpn's really constitutes the basis for everything that we're doing these days for segmentation and extracts and the solution has been out in the field code is stable um yeah it's it's it's been validated quite a bit right so the authors would like to request a possible write the working group to to make a last call for this document since and okay i think that's well as one no comments always we can leave this one so before going to the last call uh question are there any questions from the audience i go ahead let me switch between so uh here you say um afi is a distinguished name and i look to the document it's a distinguished name type but then doesn't seem to be defined anywhere it's just 17 right i think yes yeah actually that's the point i think we use 17 right for for uh distinguished names but this refers to the uh dinos draft about distinguished names yes yes but yeah i think"
  },
  {
    "startTime": "00:48:01",
    "text": "victor and dino were debating how to provide this yeah okay um if you're going to use distinguished names then you're going to need to put in text about how they are distinguished what keeps them separate because your example is just an arbitrary name that seems to imply that they're going to collide in the mapping system uh that's not good but if you can keep them separate then specify how okay okay i will also start putting the document in the reference because it's not in the reference list and again update them because um look if you go on here you still have a reference to rfc 6833 so this is a general update that you need to do on documents i guess i had uh another question here in the the extranet i mean you show how how it goes in one direction uh uh i kind of understand how it will go also in the other direction um what if there is any mismatch uh uh to you do you discuss that yeah that that by some reason um you you you do not encode you did not encode all the ids or something this can happen when you do an update or something you see yes did you discuss yeah i'm i don't think the document discusses it but it's it's a very good point because in practice i mean it's always a challenge i i think the problem is similar to when you have several xtrs and then you want to update the mapping"
  },
  {
    "startTime": "00:50:01",
    "text": "is just up to the let's say to the operator to make sure that you up update all the extras at the same time in a certain way so that the mapping is coherent and you you should know that the issue is not the case you have trouble so you you just need to to add text that on that i think okay i just went and looked at the draft the use you're making of the name would make me very nervous please think very carefully about it a you're creating a dependence on a document that is not yet working group adopted and b what you actually say is that the name provides semantics names don't provide semantics so be very careful about whether the name is really what you want for this okay okay um okay yeah i can talk to victor and dino and see if in light of this these comments that we gave you i would suggest that we go first for uh the document and then we can certainly discuss our last call okay okay yeah i mean i think the last call was more related to that there had not been too many changes right but yeah but it's a good point right then we still have the bottleneck lispsec but uh and we need a revised version of this document because there is a couple of of things to to to update and fix i guess okay okay okay unless there are other question or comments i will switch to your last presentation this one here we go"
  },
  {
    "startTime": "00:52:00",
    "text": "okay um yeah the last presentation i probably said that i let others talk um the the the same right [Music] none of the others could be here today but i'm presenting on their behalf but again the these this is kind we we have yeah vested interest in in these drafts and you'll see you know at the end i'll make another call to to make it a working group document and and the reason we have this interest is because we have been using these in in practice and it has we've gotten a lot of benefits out of using these these procedures here and um so i'll go through them and give some background on what we have been doing and and and yeah let's let's hope we can have a debate on this or restart the debate on whether this should be part of the working group or not okay next slide please so just some background the map server reliable transfer is is as i was saying extensively used in okay let's say our deployment right um [Music] the the reason we have these is because when when we start experimenting with it uh it showed very quick benefits to scale the least deployments and and we consider that it's been key to support operation at scale for for very large users right um so this is true when we have for example a large number of vids or or when we have mobility that what we were discussed describing in the first draft at large scale and and also for example when we try to plug lisp"
  },
  {
    "startTime": "00:54:01",
    "text": "systems with other systems and we need to do redistribution of database mappings this also provides some stability at scale um in practical terms since the draft proposes message reuse for many things uh it it was ideally implemented as an extension of the registration process that that it's well documented in the in the rfc okay next slightly um so what this document all about is this idea of moving from periodic registrations to to using a reliable transport to support the registration process so as you always know no well sorry um the what we use originally or at least uses by default is is this periodic udp communication between the xtr and the map server to and this is to maintain some soft state right between these two entities in the network um but yeah when doing experimentation especially at scale we had some right there were some practical concerns on how to do this right um and especially yeah when we are handling a large number of eid records or when we have to do redistribution mobility and and something that for example you can see very quickly is that this constant communication creates some load on on the control plane and and for example if you start attaching thousands of records to each xtr this this means a lot of traffic and another area of concern was this lack of flow control right between when when xtrs and and map servers uh span multiple network hogs and and our network grows right so we we wanted also to to get some some some of these right in in the"
  },
  {
    "startTime": "00:56:01",
    "text": "interface and excellently so um what's reliable transfer so the the what what the document provides proposes is to establish a tcv or http or to be honest any uh session that it's considered reliable in some sense between the xtr and the map server right and and then use this reliable session to communicate the id to our lock mappings right and also mapping notifications back from the the map server to the xtr the document proposes these always a as an optional alternative to udp phase registration right and so udp mechanism must be supported this is not trying to replace anything but but it's always an alternative that that can be used if available next slide please so the next three slides try to put picture and how how the operation proposed it's meant to work right so the idea would be something like you have the etr the map server and and dtr starts with the usual periodic udp registration with the mapping system okay and this periodic udp registration will continue as long as no reliable session is established let's say one reliable session is possible let's say these two guys can't establish a tcp session then it's it's when reliable transport operation kicks in right next slightly so once this happens let's say now we have a tcp session available what the map server will do is send the registration refresh message to the idea right um what this resistation refresh message"
  },
  {
    "startTime": "00:58:00",
    "text": "does is is trigger um ddr to send a new refresh registration of everything that it has in its local database but the important thing comes from here right from that instance all these registrations are considered active as long as the session is up so in some sense we we link the phase of the registrations to to the state of of this session between the map server and the etr and thanks to these these registrations don't need to be resent periodically anymore next level now when when we have this this idea of sharing state between the two and linking the fade to to the session now we need some additional procedures on top of of the resistance process and and this is what the document it's all about right but the most important ones is one that now the map server can reject registrations and tell the etr that it's rejecting registrations when it's not ready or i don't know let's say configurations or policies don't allow them okay and and the registration refresh message is is actually used as a way so that the map server can notify the ttr that hey things have have changed for example now the policy that rejected your registration is not there anymore and and you can try again to send me these registrations um one this is one of the last additions that was made to the document is that these resistation refresh messages can can be scoped right so the map server can specify i want i i would like you to refresh everything that you have only what you have in this instance id or or just send me this specific prefix that that for some reason i lost state for it okay"
  },
  {
    "startTime": "01:00:02",
    "text": "next slide please yeah from here the rest of the slides is that what i described was the basic idea behind the draft right um what the next slides go is just okay which are the specific details behind all these um for example right with respect to registrations uh reliable registrations or our messages are exactly the same as udp registration so so we do message reuse here the only thing is that we package them in into a tcp or reliable session packet [Music] because now the two entities are sharing state right and and linking this state to the status of the of the session now the maps the map server is is given the facility to give positive or negative acknowledgement to to provide explicit feedback to the xtr and what we were talking before and now the map server has this ability to to actively request for for information to to the to the the xtr um one interesting thing is that if you think from uh from a reliable transfer perspective mapping notifications are actually not needed anymore unless there's there's information to be conveyed from the map server to to the xtr right for example if we use merge semantics um maven notifications would be needed right or or for example for mobility my big notifications would still be neat next is lively map server operation um yeah repeating more or less the same but but important things here is that now"
  },
  {
    "startTime": "01:02:02",
    "text": "create update or delete state so there is no timeout anymore on the mapping system uh as long as the session is up the registrations stay so on on the other side what this means is that the xtr needs to explicitly delete mappings to get them removed from the mapping system another interesting thing that the document provides is that registration state is not the start discarded when the session goes down so basically if let's say the session goes down what the map server does is is fall back into timer-based mode of operation so all the registrations are it activates uh a timer to to let them expire as as they would in the udp model okay and these users registrations can be rejected for a number of reasons but mostly is either either authentication or or policy of configuration limitation threat um [Music] and and what we described in in the flow right the the registration refresh message is basically used as a is a tool that the map server now has to obtain initial state or request um a specific refi registrations when when something changes in its configuration its policy its status okay next slide please from an etr operation perspective um okay the the the document provides a tail state machine and transitions between states but the important thing to to remark here is that what we have been repeating right the the idea is ddr starts in udp"
  },
  {
    "startTime": "01:04:02",
    "text": "registration mode now if a session is possible the etr will try to switch to to reliable transfer mode and but this won't complete until the map server sends uh this registration refresh right that's the that's the the key element in in this whole process that where both both the etr and the map server know that that now they they share state and and they have linked the the fate of this state to to the status of the session okay nexus live please um some implementation nodes uh as as we were saying right um we have vested internet in this because we've had code running and very stable for a long time and and it has been very very effective to to support large deployments um one important implementation node is that since we reuse messaging um all these was implemented as a okay let's call it minor extension to to to the registration process right so that it could run over over tcp and and as i was saying before right this doesn't need to be linked to tcp ctv right it can use any transport that we can consider reliable at some point in this in the working room we were talking about using quick for this that's always a possibility one thing doesn't doesn't collide with the other next slide please and yeah our usual calls with respect to his wrath we would like to request an option for this document"
  },
  {
    "startTime": "01:06:00",
    "text": "in the working group um yeah and that's the one last one yeah questions okay before going to this question let's see if there are any questions from the on the room i would go for a no but there are two two small questions um uh yeah you say uh we we always start a registration with with udp and then when there is a session up then i i switch to the other now to me it's not clear how we understand that we can set up a session is that an explicit signaling or is just by configuration and we wait that it comes up so what we do and now we are talking about our implementation i guess um we could all do different but what we do today is we use the we send the the the etr we will send the map register um we'll set the one mum notify okay when it receives the mum notify it understands that it can try to to establish a tcp session right it understands that okay i've been because my registration is authenticated okay i've been authenticated with the server right it's allowing me to do stuff so at that point it tries and the way we have implemented this is is back off mechanism right so if the map server doesn't support tcp then okay fine okay is i try and fail in the sense that i i send that first message i see on the other side there is someone answering and is somehow authenticated"
  },
  {
    "startTime": "01:08:00",
    "text": "so i try to to speak tcp or stp or as you say i try quick and if it doesn't work i just continue um with udp i mean you can add text in the document saying we you can try with this system as a simple policy a more complex policy or say or you know this by configuration other methods are out of the scope of this document at least you have a basic thing that says how you you go from one to the other i mean because otherwise it reminds remains to me a little bit fuzzy because i if i read the document that i said oh you you can go from this to that and i have to implement it i will scratch my hands and yeah yes but what is this that tells me when i should go on the other side you see what i mean yes that's a good point okay a good um another personal observation is the fact that you authenticate the nodes you're using odp but you don't have a security layer and now as a chair i would say that we had a lot of issues about security with the main specifications if we move this document forward uh chances are that that security review will come back to us and say this system is not secure so i would suggest to look at how lispsec applies or to to to this system or you say i don't know you set up a session and i put up tls or in quick you use a quick security i don't know but just authenticating the other side"
  },
  {
    "startTime": "01:10:02",
    "text": "then obviously other people can can have a different opinion but okay sorry no that's a good point i i'm not sure if the draft now has a section i haven't there is a security consideration is but it's only about authentication of the other side and you use basically tcp authentication or stp options there is not that much so i i would encourage to to to go further on that um also the the references i guess that are uh still and actually i think this one has expired so i think this one exactly i was coming to this point i mean yeah you know that the answer to the the the request for adoption cannot be issued if the the draft is expired we cannot adopt an expired draft i'm there are few updates that that you can do to this document again uh uh on a personal side no no no chair head uh i like the document because um uh uh i i think that with a reliable transport uh you can do a few interesting things on the map registration and on the mapping system basically so i i like the work basically as a chair i told you my my concerns and um yeah i think the trust should be revised and i don't know if it's clear but the priorities lisp sec so um"
  },
  {
    "startTime": "01:12:00",
    "text": "because you you the co-authors of this set of documents overlap with the authors of lispsack you can deliver the message that as soon as we are done with one we can move the others [Laughter] so it's so pressure i i mean it's it's uh it's fair enough i mean we we we put a lot of energy and this is just the last piece piece that is missing and we'll unblock a few things and give a lot of work to alvaro but anyway this is how it works okay okay any other comments from the from the audience i guess that's not so thank you very much mark for all these updates and we will move to sharon sharon i will share your slide if that is fine for you you can continue this way thank you luigi see the slides yes i see i will uh thank you i will jointly present with the aviv haskell um uh we're presenting here um list fix uh this is um a second example of using the existing lisp rfcs and mechanism established for a use the use is for compute first aggregation of large amounts of data that has to be quickly propagated based on change an exception or an anomaly so i i like the hexagon rfc which is a draft which is also like that which is in production and in"
  },
  {
    "startTime": "01:14:00",
    "text": "publication here we are still we just prototyped this thing and we are gathering uh inputs for draft zero zero um also a it's interesting to note that uh this use of list for data aggregation and selective propagation is like the opposite of cdn um in a sense that uh there's a lot more data production than consumption uh it's push versus pool and dns indirection is less applicable because of cash coherency or latency aspects okay another pre note is that the qualities of using lisp the formal specification the breadth of the rfcs the multi-vendor interoperability are becoming clearer to stakeholders in each domain for example in vehicles or in cyber as time goes by and they see how this basis has more benefits than initially uh was anticipated so specifically for ipfix so this uh a proposal has to do with uh a change in the traditional role of ipfix if we if we thought of ipfix as some kind of built-in wireshark to log and debug the network it's now becoming a critical sampling tool for networks so uniform sampling uh with ai outperforms a probing with ai which outperforms probing we're using"
  },
  {
    "startTime": "01:16:01",
    "text": "traditional rule-based systems so we know that now uh based on research this is a domain which aviv is expert on so i would let him explain explain in more in depth why is that the case um but and of course something is a lot simpler to deploy than probing uh putting something in line or pushing agents to various points in the network so sampling is is outperforms and it's much easier than anything else but uh the catch here is uniform sampling so uniform sampling of a small sites the like hospital school district is very easy you just ip fix the firewall and the core switch but uniform sampling of a large virtualized environment is difficult and at least can solve that so and next slide please okay so i will hand it over to our view yes thank you so much thank you for the intro um hello everyone so as shown described just now the advances in network sampling over the last years is incredible i did my phd research this specific problem how to infer from one percent about the one hundred percent uh developed some uh regardless uh mathematical theory about it and we see more and more companies in this field today in the stamping field specifically the combination of sampling and ai opens many possibilities for not only efficient but very accurate network monitoring and flex prediction in scale in any application as an example take a look at the ai architecture you see in this slide the"
  },
  {
    "startTime": "01:18:01",
    "text": "autoencoder architecture you see here let me describe this data flow going from left to right so it's basically four steps the first step is network samples just usual network samples arrived in our auto encoder the next step the second step is that the autoencoder tries to reconstruct what is the expected input and it outputs some some loss because it's not a perfect construction of course and the loss is the deviation between what was the input center and what was the autoencoder reconstruction very similarly to achieve signals the third step is that the loss is normalized to one single statistical distribution across all different client networks this is the key here the normalization and why it's so important because in the last step in step number four the normalized loss of each and every client is forwarded into one single global metro anomaly detector that's doing pattern matching against known threats in the normalized way so this approach that you see here this example of losses normalization with small network samples when compared to full network probes analysis it found out that this approach the sampling with normalization is significantly outperforming the probe of the 100 of the network not only in terms of performance but also in terms of its accuracy you can see in the table below the f1 score which combines the recall and the precision together the true positive false positive together and you can see a comparison in column three denotes uh forbes solution and uh column five you know it's this sampling and uh normalization"
  },
  {
    "startTime": "01:20:00",
    "text": "and also in the first quality which is under the recall the second row much better results so not only in lab simulations this approach that you see here is currently deployed in hundreds of network sites with radically different network environments in volumes sizes and architectures however in all of these deployments in order to do the uniform sampling we can do it very simply we just need to activate the standard ipfix in one core switch one firewall because the sites are very small but when we go to a bigger virtualized multi-talent environments we need a better way to aggregate the standardized fix in order to achieve this uniform sampling okay so next slide all right so we understood sampling is is good uh and we we take a look at virtualized cloud native environments and which any process can run on any kubernetes cluster on any server the network facilitates that by having uh lots of links between any iraq to an iraq probing is is is really not an option and these links are very high speed and and probing all of them is just impossible resorting to agents increases the attack surface significantly and in in each server right in the soft belly of the os so that can and has been used to compromise the cloud environments so um what do we do so next slide so if probing is not an option server agents increases complexity and attack"
  },
  {
    "startTime": "01:22:01",
    "text": "surface and the default ipfix collectors on the switches will not result in uniform sampling of any of the apps running on the send on the on the data center environment um we would like to introduce a list specification that will solve that so next slide please all right so what we suggest as a specification for uh exporters ipfix exporters and also collectors as an interim step um is the ability to steer traffic to eid uh collectors which are logical and will result in uniform sampling based on a specification of group membership which is efficient in space meaning a sample gathered in the exporter would be matched to a group member test like a broom filter or a regular expression or algorithmically to an eid based on the headers as deep as we specify in the sample and therefore will steer the sampling to analyzers which are per application resulting in uniform sampling pair up distributed in the data center using an overlay which is built into the center the the network aggregation itself the iphix aggregation can be provided by the infrastructure provider and the eids will hide the the equipment form the sampling analyzers the sampling analyzer can be a cyber provider that provides a service to detect anomalies uh for the application anomalies can be"
  },
  {
    "startTime": "01:24:01",
    "text": "preparation for ransomware trying to disrupt and trying to leak information uh under an ex something which looks like a kosher exchange all right so this is uh the ask uh appreciate any feedback i know it's hard to give any feedback in these online sessions but offline are very welcome and towards specifying a zero zero draft for this next slide okay here we just uh summarized something is good uh something in virtuous environment is hard uniform sampling list can fix that okay any questions yes that one go ahead hi can you hear me yes yes all right thank you hey um that's a very interesting um a very interesting study here i wanted to ask you a question about um as you are actually um making those samplings and i can see that you are actually talking about reduction of how much of sampling is done however i wanted to ask something about the priority of the packets those sampling all these seen as control packets are all those seen as regular packets for the apps"
  },
  {
    "startTime": "01:26:00",
    "text": "yes so this is using the standard simple protocols and ipfix is uh the itf standard and they're also the net flow of cisco and s flow um standards as well we we get one out of x packets either as a full packet without its payload or summarized by the connections by the flow themselves so we discussed about we're discussing about usual ip headers either as a full details ipad or summarized connections is this answering your question oh kind of you know i'll follow up offline with you um you know i had a couple of questions about you know the competition between that much that amount of sampling as control traffic and how would that work but a whole lot with you offline on that one i i think the question is um after the sampling has been gathered per application the sampling records are the high priority traffic just to protect the the the process of ongoing uh sampling so analysis will be uh you know protected uh and i think we can answer that online and that's a great point thank you yes of course mark you disappeared from the queue no more uh question please go ahead yeah no i think um yeah this is a bit more specific i don't know if you guys saw it later but um could you give an insight of how how are you structuring the eivs or how do you see eith being structured to to support this"
  },
  {
    "startTime": "01:28:01",
    "text": "but that's a great question so currently you know it's a private space of cyber cfn network uh but that's a it relates to your presentation also mark and there's about space conservation uh do we match a specific id to any uh group testing or do we simply algorithmically generate eids and use um the mapping system for a longest match for the best collector for this you know these are good questions okay okay okay yeah and just trying to try to map you know to comfort zone for you know even okay if there's no more we can move to the next topic okay so uh so this is more mature this is in production and currently in deployment the list in hexagon in in in thousands of drivers in new york city and also now by industry consortium in tokyo that's been under construction right now servers have been allocated but the other cities in the us it's full production uh i'd just like to give a quick uh brief learnings of what we we see and what the stakeholders in the industry see from using lisp for this mobility in terms of vehicles use cases next slide please"
  },
  {
    "startTime": "01:30:02",
    "text": "all right so what we achieved using a lisp is really uh take uh the full spectrum of uh mobility networks which were very split between vehicle to vehicle which are based on geospatial networks like in ipy or dsrc for stuff which is immediate and very transient versus uh vehicle to cloud which is like you drive for a couple of hours and then you upload overnight what you collected and then you know the cloud crunches uh fresher maps so using uh the hierarchy and the layering we are able to unify using one architecture all these use cases and also all the use cases of stuff that fell in between so what you see here is an example of using um uh the hierarchy and layering for a detecting parking which is something that has to be done quickly uh and previously had no answer in v2v or v2 cloud also understanding the cycle of traffic lights or you know doing some kind of patterns on the curb activity in an area so all these things fell between and really the the use case uh transience is really determined by a the the the mobile network uh how much do we have in terms of capacity what is the density and what is the latency um this the this layering uh works when let's say uh toyota wants to find parking for its customers its drivers based on its cars so there are some cars of some toyota cars are finding parking for other"
  },
  {
    "startTime": "01:32:01",
    "text": "toyota cars using uh a ead abstraction of uh of the geolocation uh provided by toyota but it also works when let's say toyota and subaru have an agreement to jointly uh collect uploads using an h3eid and then have agreements with the parkopedia or bosch parking services using other h2ad same h3 64 bits different eid and then parkopedia has an agreement with the city not only i mean it detects parking for drivers but it detects permit violations in construction for the city so this is again using the same mechanisms the same rfc and you know people are seeing uh you know that this basis is good to build on um so next slide please all right so as we described uh the key for unifying the use cases in one architecture is by uh obstructing the geospatial network into uh your special eid's it's virtualized instead of physical network uh and these geolocation services they utilize areas based on uploads but that introduces uh key issues um to the industry uh which lists answers uh in a very elegant manner uh one is since we associate vehicles to geolocation services not randomly load balanced but based on where they are then depending on how much traffic there is you need to dynamically"
  },
  {
    "startTime": "01:34:01",
    "text": "um set the resources and you have to do it transparently to the vehicles because that's a mass market so by using eids we can do that we can switch geolocation service to from one server to a server with the 10 of those to server with only two of those and and that's using eid the second key issue which as a result of this obstruction your special abstraction is your privacy it's unlikely that because i'm using a parking service the parking provider knows where exactly i am every point of the day so again here the eid layering solves that the the the network is aware of eids uh the geolocation services were yeah this but the aeds of vehicles are ephemeral and changing and these are not ip addresses uh so i have ip geoprivacy also because i'm driving between geolocation areas i'm switching context to where is it that i'm subscribed to or upload to and that has to be seamless cannot be done with via dns it takes too long and again using eid's uh h3e ids here solves the problem uh and the fourth item is um while i'm driving my reception may change between att and verizon or kddi and ntt uh but i i must maintain my identity a a for the subscription to hold therefore i'm not using ips because ips will change i'm using eits"
  },
  {
    "startTime": "01:36:00",
    "text": "so these are things uh that you know the industry begins to see uh begins to see that it's good that it's specified as a standard as a multi-vendor standard and and can be leveraged in multiple tiers of the application last slide all right so what we see is that using this uh specification and use of lisp um we are able to uh scale a crowdscale actually a processing of uploads uh we're using we are able to propagate information based based on change or exception or anomaly uh using a signal-free propagation and we are able to facilitate the latency because we pre-select our logs for h3ids to places where the latency from the ip anchors is or is known and controlled so why is this important it's important because uh i mean human reaction is a long latency so that's not the point the point is more um when a car is driving in 20 meters per second if i'm my latency is high i'm missing a lot of meters and therefore i can pre-select the rlox and then move the geolocation services the h3 eid geocaching services based on a load of traffic so that's it that's the update it's in publication uh i wonder if we can get some kind of indication on when the rfc is going to be published it's very hard for industry outside the itf to work with any kind of draft so it would be good to know"
  },
  {
    "startTime": "01:38:02",
    "text": "it thank you are there any questions from the audience i have a simple one these are two interesting use cases for lisp um the question is uh in order to to to solve these use cases um do you think that there will be any modification or extension to the lease protocol per se or i think uh right so it may be but so far not so far the specifications uh give enough flexibility i mean sometimes you have to think what exactly am i using and how before i mean how do i allocate the ideas as was asked before and you know how do i what meaning do i give to things and how do i use signal free to um partition themes and subscriptions and what does it mean for a replication which xtr's to use a v-switch or a you know full-blown hardware that that can do it can handle uh like cities but so far the specification itself has been good enough okay okay any any other question from your audience"
  },
  {
    "startTime": "01:40:05",
    "text": "mark so in in practice um with signal free and replication um have have you seen any scalability issues when deploying this and i don't know if you have to replicate to too many sites so yeah that's a good point great point so actually for these networks where there's a production a lot of production of data routed to somewhere close for reduction and then propagation based on a subscription uh usually it's a lot of channels of very few subscribers so signal three is really good for them oh okay and i think in the last slide you thought can you go just one back one slide back yeah just um sure um yes so these um preallocation of our locks um are you doing priority here or are you just doing a a selection of so you you have a list compiled from from signals free registration right and and then you get all these lar logs in the list and and then what you do is filter down that filter them down uh okay so here's um the the situation on the ground is like we get a few our locks for h3 services let's say from uh the oracle cloud from wavelength and we know they all meet the requirements of"
  },
  {
    "startTime": "01:42:01",
    "text": "latency between them and the mobile carrier uh ip anchors okay okay but it doesn't it doesn't relate to where the car is because that even though the car is moving as far as ib anchor is not moving it's uh mostly related to i know that if i put an h3 ead service there then the car can upload more data per meter so i'll have more coverage i can get more out of any car so now i have to put the eids on the airlocks based on load of the current compute commute situation and and but i know the the sla of [Music] utilization of per car ahead of putting an eid service there oh i see it i understand okay yeah i had gotten a bit confused i thank you any other question okay so thank you very much uh sharon so this brings us at the end of of the presentation that we had in the agenda at this point the the mic is open for any question already thing people want to discuss related to lisp obviously"
  },
  {
    "startTime": "01:44:00",
    "text": "okay seems that everybody is more interested in starting the weekend rather than discuss with me okay folks thank you very much i think that this brings us to to the end of this meeting thank you all and see you again in 113 bye-bye"
  }
]
