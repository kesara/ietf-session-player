[
  {
    "startTime": "00:00:20",
    "text": "dang mike left i was gonna pick on him mike takes nice notes too jenkins of course okay my two private chats did not work okay i can pick on ned i can bribe you later can you help take notes yay i i don't know if that's a good thing or not hank like highlight and it's very dark yeah okay i think we're all set and it is one minute past so we shall go ahead and get started welcome to the trusted execution and environment provisioning uh working group if you are not expecting to hear teep you're in the wrong room um let's see thursday so by now you should be well aware of the note well um so i'm not going to go through the standard practices for the ietf um you can read them on your own i have been asked to reiterate um the meeting tips so make sure for those especially who are"
  },
  {
    "startTime": "00:02:02",
    "text": "here in person to sign in through the meet echo so you can either use the on-site tool or the little video icon and that will give you um the ability to to get the blue sheet sign in if you will do get on the queue and meet echo because that's the way we can respect those who are remote as well and i can honor people on the queue that way keep your audio and video off so that we don't get double uh double audio and then make sure that you're wearing your masks even if you come up to the mic so the only ones that can choose to take their mask off is those that are coming up to present for the remote participants um make sure that your audio and video are off unless you are in the queue and you're recognized to speak um and it's recommended that you use a headset just um to allow for the audio to work better okay so quick review i don't know why the pdf next time i'll i'll turn the powerpoint to pdf so it formats properly um key points of the code of conduct i mean we're a small group we're all friendly here but um this is just to say treat each other with respect and courtesy while we're in the room keep the discussions um professional okay so with that um thank you to our ad and tinnette for helping take notes i do encourage others also to look at the hedgehog and and doc and help us if you see that um our our helpers can cannot keep up with"
  },
  {
    "startTime": "00:04:02",
    "text": "the discussions and and to capture it um okay so for the agenda today um we're in the agenda bashing portion um so dave are you going to cover for ming if he's not 30 i don't see him on okay great so we'll spend some time on the comment resolution that has been happening in the architecture as that is now in the 80 area review process um then akira you'll present the updates on the hackathon and then dave you're back on to uh discuss issues on the um well not really well issues but also progression on the protocol specification and then um pengling i think you are remote um gave you some time to provide the use case that's coming from confidential computing yes i'm remote thank you great okay so with that any comments updates to the agenda if not does that fill up the entire time uh i think there was if i did the math there was ten minutes a slop yeah i've learned to leave like five to ten minutes just because of transitions because i'm like 30 seconds over my slot okay so with that um if there are no comments dave you want to come in and okay my name is ming for this presentation"
  },
  {
    "startTime": "00:06:00",
    "text": "and since i'm on the x i'm going to be able to breathe sorry all right [Laughter] okay go ahead next this is the architecture document um all right so as a reminder of the timeline right we've gone through working group last call uh we've had ad feedback from ben that was then uh updated in draft 16 and 17 and 18. and you can see various other reviews that have happened thank you to all those who have submitted reviews next slide all right so uh section 3.3 was one that had a comment in it that we made a change to since working with last call um that one said uh weak security has been proposing threats to critical infrastructure uh russ had a comment about suggesting minor edits to help the reader understand this is not talking about network infrastructure so you can see draft 17 since last ietf was updated with the wording on the bottom um which talks about proposing infrastructure i.e assets that are essential for the functioning of a society and economy and i think russ uh act that that was acceptable so yeah nodding okay great next it's just confirming working group consensus that we didn't break working group consensus right that's what we're doing here so um 9.3 it said it compromised might drop or delay messages and russ pointed out that it should also mention replay and so we add that in there so it says drop replay or delay messages next um roop ca versus trust anchor okay so 9.4 said a root ca for tam certificates might get compromised or a certificate might expire or a trust anchor other than a root ca certificate may also expire or be compromised okay russ said what's the difference between a root ca and a trust anchor they're usually synonyms explain if there's a difference here right and so you see a"
  },
  {
    "startTime": "00:08:01",
    "text": "little clarification exchange between ming and russ there when it's a certificate it doesn't have to be a root certificate it could be an issuing ca while it isn't common practice and russ pointed out i think the point of a root certificate in all situations is not very helpful please add that to the document and so the text now says uh adding the point in bold it can be a non-root certificate when it's a certificate right so it's a certificate if it's a certificate but if it is it doesn't have to be a root certificate okay so rest nodded okay next yeah yeah so raw public keys or certificates when they're certificates they could be a root certificate or an intermediate certificate yeah all those are legal ways as long as you have something in your trust anchor store that you can chain up to okay next okay um all right trust anchor definition uh trust anchor represents an authoritative entity via public key and associated data the trust anchor may be a certificate or it may be a raw public key okay so we're just talking about carl commented and the main part is in bold there where he actually suggests uh alternate text right where the trust anchor may be a certificate a raw public key or other structure as appropriate might be better to leave open the possibility of contain of constraining a trust anchor right so you can see commented on you know associated data and so on so 17 says the following the trust anchor may be a certificate a raw public key or other structure as appropriate it can be a non-root certificate when it's a certificate right and so if you have something else that fits into the same overall bucket as a trust anchor that you can chain it up to that has some security principle associated with it then that's okay you're not constraining trust anchor to it must be a certificate or a public key even if those are the only things that we actually use right now so okay all right 4.4 personalization data"
  },
  {
    "startTime": "00:10:00",
    "text": "old text implementations must support encryption of such personalization data to preserve the confidentiality of potentially sensitive data contained within it and must support integrity protection of the personalization data okay now talks about integrity protection why not say that an implementation must support mechanisms for the confidentiality and integrity protection also it seems like the suit firmware encryption document um it actually talks about that and should you just reference that okay uh ben rad commented on uh the draft 17 version we may want to split the confidentiality integrity protection guidance into separate clauses or even separate sentences to be clear about what behavior is required and so we did that and so 18 actually has two separate sentences implementations must support encryption to preserve confidentiality of such partialization data which may contain potentially contained sensitive data implementations must also support mechanisms for integrity protection of such personalization did it right so the addition of the first sentence was in response to russ the splitting into two sentences for clarity was in response to ben okay keep going okay other knits rests into a bunch of other great knits that we incorporated uh some of those are covered here i don't know that all of them are and i think we covered typos and stuff um so we broke up a long sentence into two sentences um the need to address okay so i guess you can read the wall of text russ has already done this but um these are at least the first one was just purely editorial uh you can see the fixed in 17 there's the new text there the problems in the bullets above the other hand require a new protocol the t protocol this is the motivation text in the in the introduction right the key protocol is a solution for dees that can install and enumerate tas in a tee secured location where another domain specific protocol standard that meets the needs is not already in use right so that's the the updated version there uh russ had a comment about app store versus trust anchor store"
  },
  {
    "startTime": "00:12:01",
    "text": "this is an app store a place where apps are stored or a place where apps are purchased right because that term could be read as both ways especially if you're not a native english speaker the term seems to be used both ways and in one place the document's very general by saying an app store or other app repository and elsewhere the term trust anchor store is clearly a place for storage of trust anchors so we added in the glossary an actual definition of app store which is an online location from which untrusted applications can be downloaded meaning it's not the purchased definition in addresses uh it's the storage example right so in that sense the term store is the same meaning as trust anchor store right now you may also be able to purchase stuff must store but that's not the definition so all right threat modality section one said tes are typically used in cases where a software data asset needs to be protected from unauthorized entities that may include the owner or opponent or possessor of a device now just some history behind that sentence right there that sentence originally appeared in a confidential computing consortium white paper um and actually had extremely positive feedback from uh people including say uh gartner and stuff that just loved that sentence that how that one was phrased and so we said okay great we'll we'll reuse that same sentence in the teap architecture document but then uh brendan didn't like that comment and and freight and suggest a different way to phrase it and since we didn't feel strongly that way we said fine we'll use brendan's wording that's fine or his point is the threat modality is important the user identity is not and so we rephrased it with brennan's phrasing uh teas are typically used in cases where software data assets need to be protected from unauthorized access where threat actors may have physical or administrative access to a device so you can argue his definition is actually more precise and so that's why we accepted brandon's proposal okay next it's not me it's just slow i don't think that's the last slide i"
  },
  {
    "startTime": "00:14:00",
    "text": "think okay maybe this is the last slide okay um those are all the changes to the architecture document we believe we have completed ad review and everything uh and that there are no remaining issues on the document including from ads or ietf or anything else and so we believe it's ready to advance to the next stage if you go all the way back to the timeline slide i forget which stage it's currently sitting in the data tracker maybe nancy remembers well we we have the shepherd write-up yeah and it is so ben was the id at the time so we'll we'll look at our our look at our ad to say yeah yeah our current ad yeah yes paula um so i will just look over what ben did but like if you resolved all of ben's issues then i'm assuming we'll just move the document forward so okay so please throw it in my queue okay okay next up akira i'm getting there too many clicks there we go you were well under time nine minutes so um oh i think that would like pull it out pull it out oh yeah yes um this is about a hackathon report on saturday and sunday um i'm really relaxed talking now because most of the stuff covered is we already had a good progress and then most of the description and the slides is also covered in david's slide so yes um yes next please"
  },
  {
    "startTime": "00:16:01",
    "text": "[Music] um yes the objective was getting the stuff changed it from one last iedf113 to until to the hackathon started and initially there was a few lists on the github and next please so the first one um was many of the discussion from the update from the last iedf10113 was related to corset or eat and this is the cypher suit how to handle cypher suit between the tab and device by reading the draft and the first one was uh if the site uh query response have a selected cipher suit but it it was it's it's option member so it could be empty and then what the time could uh think about it and yes this is uh was updated to the pull request so um the conclusion was with the four or five people in the hackathon by or who were implementing the tip was just uh tam will have us able to select one of uh one of them the times have sent in the credit request and next please um the technical details will be repeated in the david's slide um this one uh this yes so um this was how to under identify ti information of the tip agent or deep device and this was also went to uh yeah two or three iterations many of the discussion"
  },
  {
    "startTime": "00:18:01",
    "text": "and i mean any of the um improvement during the hackathon hackathon was went to many iteration so this please ask the details go through the details and david slide for this one and thank you next one what was this oh yeah yeah yeah so um the draft until one iedf113 was explicitly was saying the uh um in the text of the query response as a evidence but in the use case it could we we have a passport model and we also have a back uh background check model to uh support at the station and we wanted to accommodate both so uh change the evidence to more generic name as a attestation payload and then up the another member adding at the station payload format to have what kind of attestation payload will be inside of uh at the station payload could be evidence or it could be uh at the station result and yes this this was a bit from many people's discussion whether a test station could be local authorization remote attestation and how to put everything in the credit draft and details will be in the davis slide right thank you and um yes so um we we need we need a t t hardware property and t firmware property"
  },
  {
    "startTime": "00:20:00",
    "text": "in uh for the tam to distinguish what what is uh uh implement in a device site or deep agent side and uh yes we the discussion evolved many way in the two days while everybody was working on improvement and portion is in the dave's slide too it's uh so it will be using uh manifest and also software version and uh yeah so what uh to detect and not detect but um distinguish what's the implementation of the teeth agent whether it's using opti or whatever is it has a sgx or what kind of the firmware have booted correctly or not yes and oh um i think i said a little bit too much but about it but yeah it will be please cover uh let's go through it in the davis slides and this one is um yeah we we we wanted to make a cypress a more generic way and was keeping from the last time the discussion was getting more uh precise and then at the end of the discussion the two days was getting more generic but um only end up specifying how to sign on the cose okay and next please yes um this is the place i need help so um suit manifest github and also uh in the tip protocol i copy the way how the suit manifests suit manifest github"
  },
  {
    "startTime": "00:22:02",
    "text": "splitting the cddr format in the draft in a different file from the markdown because that will be easier to run it with the cddo tools and and uh and then it was it helped a lot to catch many of the cdo for format or for cdd grammar era with the cddo tools and i put the how my way of the running the cdtl and appendix i think it's page 13 or 14 in the slide but i'm not really sure what is the right way to use the cddo tools but at least the my way of using it what did catch few things in the cd of in the deep draft and also the suit manifest draft and i we made a pull request akita do you want to take uh brendan is in the queue yes yes yes go ahead brendan uh hi um so there's a uh there was a point raised about the suit manifest draft um that uh essentially said that suit uh didn't define a bunch of the cozy structures it uses uh there is actually a note in the suit draft which explains that you need to concatenate the suit or sorry the cozy cddl to the end of the suit cddl in order to make it a valid grammar i'm not sure if this is the right way to do things but that's the approach that we've taken so far if you've got any feedback on on that approach or you'd prefer a different way to do it then please do let me know hello yes so i'm concatenating with the corsair cdl at end of the either of the suit"
  },
  {
    "startTime": "00:24:00",
    "text": "manifest cdd or two protocol cdo it should work i i have tried it on both and it works um and also another c file everything is dependent in these two many cdfi for the suit report cdl and some other one had to be concatenated and for example suit report is does not have a github repository containing cddo files so i had to make it manually so i really don't know what will be the right way but for the suit manifest just the kose tags was only required for line which is used in the suit manifest so i just added manually so about it yeah concatenating entire courses cdd is also fine but i oh yes but i i think it would be nice to put it in the somewhere in the read me or somewhere so that people could reproduce the procedure i'm using or brandon using it okay um i guess i should mention as well that um the the cozy uh draft does actually have instructions for how to extract the cddl from it um though it is a little unusual i haven't seen that approach in any other draft okay and yes next you have pengling and michael okay hi yeah yeah yeah can you hear me yes i think the problem is not about the definition of the course and this question has been sometimes i can't remember it very clearly but i think the problem is not about how to define the course because i i defined the course in the end of the cdl but it"
  },
  {
    "startTime": "00:26:00",
    "text": "seems it's not work well yeah okay yes yes yes i agree and you're the person who filed the issue on the github first yes michael richardson so uh what i'm hearing is a couple of things one of which is that we're lacking a clear include mechanism in the cddl and i think that that's um you're not the only one i think that's well known uh in other places um the way that i've dealt with this is that uh yes put the cddl file as a separate file include it from the markdown there's a markdown mechanism to include put the generation of your complete cddl in your make file from the markdown you can append to that okay and for the things that are in other repos well use curl grab it down put it in your own thing concatenate it together that that records all the process and then you may want to check them in because you might not want to depend upon suit having not changed you might want to explicitly update it or the way around up to you but that's what i've done in the past and so far it's better than uh trying to pull it out of the file just leave it on the disk and there's also some cddl tools that will produce uh c header files for instance which i found really really useful yes um for the procedure what do you just describe um some of the cdd of our is not on the github or any places so just to go after the data tracker and read the draft and then extract inside the cdl definition from the draft so um and that's what so so michael again what i'm actually suggesting is that when that happens that you go and poke the people in the other place to do the same thing right so that said everyone back has a cd dfl that you can pull out of you know"
  },
  {
    "startTime": "00:28:02",
    "text": "get raw user pages or something yes and you'll get the right thing uh and i don't think that's a terrible thing and everyone will be like oh yeah that's a good idea yeah and then everybody will be happy yes and also when the con when before running in the c cdo tools need to concatenate all the cddf file and how to order the cdda file file in the order it changes how to catch the grammar mistake too so that's something um i i i need to yeah we need to think talk with the people in the cdto2 that's my impression and so the summary is yes we really got a lot of changes in first two days saturday sunday this idf114 so great progress many issues 11 issues was improved nine pull requests was made and and as far as we know we haven't tried all the implementation yet but probably it's okay like at the moment i could see corsair supporting course and e and t protocol is pretty much should be okay yes and the appendix has uh some few things i did you want to cover the um now to go through just showing what's in it's in the page yeah this is the my my this was my my procedure was running during the hackathon so it's yes probably need to explain do have some of the explanation and somewhere in the documentation in the future yes yes that i think that's it that's it yes okay great thanks thank you we're doing good on time okay"
  },
  {
    "startTime": "00:30:06",
    "text": "you're up next i don't know why i have to like click click click click click there we go uh oh you're not named what's that you're not ming i know my name is oh it might have gotten turned off accidentally accidentally [Music] don't confuse me with that other guy named ming who looks a lot like me i will say at the hackathon uh i i think we have six known implementations uh from six different implementers five of them were sitting at the table uh ming being the sixth one who is not at the table that we know of um and so that means that uh we spent a lot of time talking about what we want to do and we even made a breaking change here because we all agreed to break our stuff right that we would all change our implementations and so it was very productive um and uh i think for the first time when i posted this the list um it usually what happens at a hackathon is we come out of the hackathon with a bunch of issues to discuss and try to figure out what to do given that we had all the implementers there at least one of them there we actually spent a lot more time talking about what the fix and the spec would be and generating the pro requests against the spec so for the first time ever we walked out of the uh hackathon with zero open issues that didn't already have text in the spec in the github copy okay never happened before um the disadvantage is we spent less time on doing the actual code for the what we did in the put request but it does mean that uh we actually now of course that was a statement in time because since then we've had three issues come up right and so we'll talk about those two but i just want to highlight that we had we felt like we"
  },
  {
    "startTime": "00:32:00",
    "text": "accomplished stuff and we felt like we were gonna make progress and we felt like this deck was stuck with the spec was becoming a lot more stable because we were able to walk out of the room saying i don't know any open issues right now and then we filed three later okay so anyway the hackathon was a great hackathon all right it was great and then thank you and and ken for providing the link so if you look at the document draft and the data tracker we did put links to some of the githubs and some of the implementations there for you we're trying to collect more so if yours isn't on there yet send it to yeah so send them to uh if you have an implementation that you want to share send them to uh my brain's not working keep chairs at iutf.com yeah since some are implementations of the tams some are implementations the tp agent and so on since there's multiple roles right okay this slide is the things that i am not going to talk about although akira talked about some of them um in the hackathon stuff these are things that were already discussed last meeting that we had resolutions that we agreed on during the last teep meeting and we did those so i'm not going to repeat those in the interest of time we're going to talk about the things that we didn't already have agreement on as of last meeting so but if you have any questions on these that was in the hackathon where uh akira talked about at least three of the ones that are on here so okay so next slide now we're going to get to the ones that are uh the new issues since last meeting some of which came up during the hackathon some were previous to the hackathon the first one was ayanna did the early review and his earlier view said hey we see the uh the audit consideration section has a section that proposes a freshness mechanism registry um which protocol page on the internet site has a list of registries right a list of uh pages where each page can have multiple registries on the same page and they say which page should this go on i said well there's not currently a tea parameters page although they probably will be because we're asking another one um but it's at the right page so before responding to ayanna we discussed as the table and i discussed it with uh one or two"
  },
  {
    "startTime": "00:34:01",
    "text": "other folks in the uh rats but not in the rats working group so far which is should this be a teep page or is the freshness mechanism actually more of a rat's thing of which teep uses a couple values out of it okay this notion of fractions mechanisms we said may not actually be a t protocol specific thing and should we have a common registry and t can just use values out of that registry just like we do for say cose types and algorithms and things like that where we use values out of another registry and so uh option one is to respond to iana and keep the text the document as is to say this goes on a new page for t parameters and we've got more than one registry there anyway and option two is to say let's move that and so the proposal that hank made was let's move that to the reference interaction models and then in the brett's working group meeting on what was it tuesday or whatever we actually just was monday we covered this in the open mic section of the rat's working group okay and so uh what we did is we posted a per request that removes this freshness mechanism registry from the t protocol and instead adds a reference to that draft that it doesn't yet appear in okay so that's in the github copy okay which is kind of a dangling reference waiting for the same text to be added into the reference interaction models in rats to then make it be complete so the information isn't lost so that is the proposal the draft isn't posted yet the intent is that we agree that the things that we've talked about is the proposals that are sitting in the github copy are right then we'll post the internet draft that matches what's the github copy if we say it's wrong then we'll fix what's in github and then post it so okay so the proposal here is to move it to the reference interaction models document oh crap okay unless we hear objections since we had uh all but one of the implementers at the table and the implementers thought this was a good idea um then as well as uh the author of the reference interaction models which is the same table thank you hank um sorry"
  },
  {
    "startTime": "00:36:00",
    "text": "i lost my connection there for a second all right so we'll go on to the next slide then i'm not hearing any objections there next one should be on okay so now we're going to get into the attestation category of stuff since a bunch of the implementers were starting to work on actual attestation so one of those issues is this one that's caught in the in the github repository the issue was labeled may require one more message for attestation and to explain this one i want to go back to a slide from ietf105 so the little thing in the box is the actual slide from that presentation and so you'll see some old old labels where it says otrp right here right that's way back in the day where we're using that acronym that's now deep here okay but uh this was a example flow that is not a by uh constraint this is to say here is a way to compose people with other things right as an example okay and this way of composing stuff right uh you attest so in between the verifier and the tester so this part right here is a passport model right sorry this part right here you send it this is a background check model i misspoke right it says the tester sends evidence through the relying party which is the tam off to a verifier the verifier sends back an attestation result which says yep you're good or you're not good if you're not good then of course the tam kicks off remediation steps to go and do appropriate installs or updates or whatever okay but in the case that says yes you're already good there's nothing for you to do what happens okay here we said since you're using this in the in in this mode here if you can pass back the attestation result that says you're good you can then present that as the passport model to other aligned parties that's what this example is showing okay just a way of getting the passport model for this one with the tam as being an intermediary in one leg it's just a way of composing a hybrid and using two different protocols together if you wanted to do this okay you need a way of carrying this attestation result back okay and what we observed is that there's no messaging to do that okay even though we talked about that we could do this in"
  },
  {
    "startTime": "00:38:00",
    "text": "iutf105 right so that's what this issue was so next slide okay so what did we do to fix this because we all agreed gosh this would be possible this would be a good thing to do this originally came up in the context of somebody implementing local attestation with sgx but we decided it's not specific to local attestation there's a slide that had exactly the same problem at 105 right so so here's what we did so this is in the update message okay normally the update message saying here's something to install or uninstall okay but you'll notice that the manifest list here is optional which means you can send an update message with no manifest list what does that mean they said ah well we can just use the update message to say well then you can just include the attestation payload and use the existing message okay just put this instead so you can do this you can do them both okay you say you're good but then here's something else to install too right and so this seemed to be the natural way to do it and so we added these fields here which match um how it appears in um the query response message when you're sending stuff to the tam okay and so we took the same definitions for these and copied them into this message and we said yep this seems to be the nice simple way to do it that does not require adding any new messages you're just now able to send a message that you couldn't send before right okay so that's what we did in the github copy of the spec if you look there so i just showed you what the main difference was okay next one um and akira i talked about this one a little bit as far as what the problem was which is um uh can you go back for just a second to the ietf 105 slide um just because i can point to the diagram there for a second so that's two slides back um in there um the thing that goes back and forth between the teep and the tam and stuff was either okay i guess you don't have to was either attestation result or evidence depending on whether you're using at that station i'm afraid it's going to crash again okay don't worry about it you can use the there we go you can use"
  },
  {
    "startTime": "00:40:01",
    "text": "the background check model through here in which case you're passing evidence through okay you can also use it in a background check model right just pretend that this was a tam over here and you're passing an attestation result to it and so how do you how do you specify which is the case okay you can go forward now back to the slide that we're on slide eight yeah okay so and the spec didn't actually say right you can kind of infer right but it wasn't explicit so we added this text and so here's the rule that we agreed on that says okay uh there's the attestation payload format and attestation payload payload format is a media type plus parameters right it's like a content type in http for example right okay so you can look at that and if it contains something you recognize and as an assassination result then it's an attestation result if it's anything else it's evidence to pass on to a verifier okay and that's because the uh tam is going to get attestation results at the end of the day either he gets it directly from the heap agent or it gets it from the verifier so he's looking for an active station result in a particular format okay so he says if i've already got what i need i'm done if i don't have what i need i'll ship it off to a verifier and ask them hey can you translate this in the thing that i need an attestation or something so that's what the text now says okay so once you get the attestation result okay then we added in more explicit text as to what to do about that okay when you get the attestation result response from the verifier there's three things there's three states you could be in okay if the attestation result response on the verifier says the guy is bad okay in which case you can't trust the rest of the query response right because it came from a cheap agent that could be compromised or could be out of date okay so that means you can't trust the list of trusted components that's in the teat message you can only trust what's in the attestation results okay so in this case well you could try to trust it but there's not good security considerations and accepting something they just failed attestation right so you can't believe it okay so in that case you can try to update the teep agent and all the dependencies even if the deep agent claims to be up to date okay if there's information inside the attestation result that tells you which"
  },
  {
    "startTime": "00:42:01",
    "text": "pieces are good and which pieces are bad you can use that okay but you can't use it just because it appeared in the deep message okay so that's case one case two is where the verifier said the type agent is good you can trust them meaning you that according to the verifiers policy he's good and trustable and you can then choose what to do with that information right you can choose to trust him okay but the information the teat message says that he's out of date like he's missing some things he should have or he's saying i'm done with this thing that i was using before and so then i can just accept the stuff that's in the team message and do updates according to that okay and the third case is where attestation succeeded and the t message also just passes policy nothing to do okay so in both of the first two cases you're going to send an update message but what you put in there is based on different pieces of information this one is based on the attestation results this and it's based on the cheap message number three there's no update message necessary it's nothing to do other than perhaps pass back that attestation result as shown in the previous slide okay if you're in that mode make sense okay that's that was issue 224 next um so we had this discussion and i think we even uh pinged uh brandon uh brendan um during the i think it was during the hackathon uh who was online uh the suit component identifier isn't unique is what the label of the issue was okay i forgot daniel's on the queue the q you want to go back one i'll take daniel yeah so actually it's just a question that raised into my mind and i apologize for not reading the document yet but when it says when you recognize the payload as an attestation result do you mean you have to pass the payload or do you have an explicit thing that says it's a brazil anti-station results or it's an evidence the specific media type will say that it's an attestation result so in this case the specific media type the there's a media type and parameters the and this uh references in rats"
  },
  {
    "startTime": "00:44:02",
    "text": "there's a document that's proposed as a working group document that i on behalf of the t protocol implementers said please adopt this in rats right it's lawrence lundblade's document about eat media types and so the media type itself is you know e cwt or whatever okay and then there's a parameter that says which profile it is okay and cheap document we specify any profile and so the full attestation payload format is you know application slash eat dash dot cbt semicolon profile equals the name of the e profile and that means it's an e profile for attestation results right so that's the one that's well known you could define another well-known one in addition to that but that's at least one example and so in the implementation we said if it's equal to exactly that string then call our e-code else ship it off to a verifier okay all right so let's go forward uh okay so in here um what was in the t protocol well you can see the old right there was a list of components which each had a tc info structure the tc infrastructure is here in the lower left corner of the slide which says here's a suit component identifier and a management sequence number okay and so we said well consider the case where somebody gets a new component on the device such as via sneakernet it didn't come through the tam right okay and so it replaces a previous implementation one example of a suit component identifier is a file system path okay so let's say you replace the component sitting in a file system path with an alternate implementation say you replace my implementation with a curious okay it's a different component right it may have the same manifest sequence number out of the other numbering space right as the other manifest sequence number or whatever so if it goes in the same file system path and it has the same version number of the other manifest then of course if all you do is report this combination here the tam can't actually distinguish between the case that it still has the thing that input there versus been replaced by something else that happens to have the same values as we said that's bad okay we need to fix that okay"
  },
  {
    "startTime": "00:46:01",
    "text": "and so instead we said well we looked at the suit report document which we already referenced and it has system property claims with the stuff on the right there okay which has a system suit component identifier and a set of suit parameters okay which includes the ability to have things like a digest but ah rather than us defining our own thing let's just do what we're already doing in this in the seat reports draft which we're already using anyway right less code copy code from here call that same thing okay so that's why we replace tc info with system property claims here and when you're reporting in the teep message here's all the other tas that are installed on my box okay nobody in queue okay i'll keep going issue 189 um akira mentioned reliably getting te hardware properties this is the way it's called in the github issue and so to summarize what this one is there are four different ways to get that you could possibly maybe get properties of the te and a career response and so properties of a tv mean things like oh is this running you know sgx or trust zone well if it's sgx is it sgx1 or two right or does it have you know monotonic counters or not because there's different variations of trust zone and so on so where do you get that information from okay well there's four possible answers today first one is you could get it from attestation results okay if there's actually e claims or if you're not using eat if you're using say sgx reports as a custom format you could get it in there if it's in there okay and of course that answer for the tam to get it means it has to be in the attestation results okay not just the evidence so it means the verifier has to be responsible for copying the information out of the evidence into the attestation result just so the time can get it okay that's absolutely possible but it places this extra dependency on the tam doing things that may cause interoperability issues if you're trying to use a tan that doesn't do that okay or perhaps on on a different um uh administrator of the the one that's administrated the verifier versus the administrator the tam okay so that's"
  },
  {
    "startTime": "00:48:01",
    "text": "possible right but it's this extra burden says this case there way to get around that second possibility is you could get it out of suit reports right because you can pass that in uh you know when i boot up and i pass stuff to the to the tam as uh you know here's my current state and so on i could put in the suit report okay well this is great if you're generating suit reports as part of your boot sequence right which a lot of suit implementations do that especially in iot space right brenda's design and the suit reports is to accommodate people who do explicitly that right as to say if i had an error booting or whatever i can generate your suit report that says that okay but doing it here says well now i've got to require that all te implementations generates your reports at t at boot time or you know launch time okay uh boot is not necessarily the right term for like sgx right at launch time uh load time um and so that may be too burdensome for some teas like sgx for example and by the way uh draft 009 of the heat protocol actually said to do this one and we said maybe that's too burdensome especially as we had sgx implementers at the table that said gosh this is really hard for me to implement so we said okay maybe that's not the right one either the third possibility is uh neither of those but there's a different field that's the tc list that's the one i showed on the previous slide but that's meant for components that can be updated by via teep right that's trusted components it's not for the hardware right so it'd be kind of maybe arguably a misuse of that field because if you can't update it then maybe it's not a trusted component we didn't define trusted component as being something that was hardware we said it's something that can be updated okay so that's probably not the right place either so that left us with some new field okay and so that's as the implementer as we said this is going to be the easiest one that's the most extensible because it doesn't have these other dependencies it works in all these other cases and so we came up with this one and it reuses that system property claims that we just showed in the previous slides we had a new field that said you can do this directly and put it in the system property claims even if you're not doing a full suit report you just have that one little snippet that was defined by the suit report spec but it's not really specific to suit reports so that's what we did uh and the"
  },
  {
    "startTime": "00:50:01",
    "text": "implementers other than all the implementers who were at the table anyway said yeah let's do it this way you've got michael on the queue okay great michael michael richardson the mic so as i understand it it was too burdensome to do suit reports at boot time so you're doing a subset of suit reports later on because this new system property claims is out of supports right um the system property claims we're saying is technically not really specific to suit reports okay yeah i get that but it was defined by that gosh yeah you're right okay i i wonder if you or someone else could elaborate why it's two birds burden some what is it that's making it hard i just want to understand the decision better that's all uh you're talking about this yeah why is that so hard to do uh for t sgx um is is there something i'm missing about this about i wasn't one of the people implementing that and so i wonder if anybody else i'll ask on the list then but i'm just i just i think that there's some valuable uh insight into what's going on that might be uh it's worth worth worth having a deeper understanding behind this decision for later on uh because i'm sure we'll have someone that goes you know from risk five or something well that's silly we just do it that way i mean you know but but but there's probably something deeper there as i just think we need to capture it unfortunately we do have a risk five person at the table so oh okay i don't know so yeah so some new new new processor yet to be invented okay um yes uh the suit working group is later today there is a suit hackathon report on the agenda i don't know that this point is on there but probably should be to your point michael so because i'm sure the suit working group would love to hear that um uh feedback to say is there something we"
  },
  {
    "startTime": "00:52:00",
    "text": "should do in the shoot reports document right is it already applicable as is do we need to have an applicability statement or is there some way easy way to modify it that would be applicable all great questions yeah go ahead brian so generating a suit report as as the first thing essentially implies two pieces of information uh the first is that you are booting your device use or or invoking an image using suit using a suit manifest if you're not invoking your image using a suit manifest then it's probably not the right answer um and that that would be a good probably argument to to look somewhere else um that said i would hope that if you're not using a suit manifest that you can get attestation results because i'm not being able to get the this information and attestation revolt results is a bit surprising to me um now to the other point about uh using system property claims um that also seems to be a slightly strange choice to me uh because those system property claims are they're they're the direct result of the suit reporting policy that's exactly the reason that they exist um and and so i'm not certain that that is quite what you're looking for i wonder if maybe i'm just borrowing attestation claims from rats even if you're not using the attestation results might be the right answer you couldn't see this but michael richardson just had a shrug that everybody in the room saw that you couldn't say so okay okay uh i i i agree with the first thing that"
  },
  {
    "startTime": "00:54:02",
    "text": "uh brennan said that makes sense about you know that if you're not using the suit directives to do the load or whatever then it doesn't make sense to have a suit report to report which which directive was an error so but why you're not using the suit report to put as more interesting questions so all right so i see the queue is empty so i'm going to go on to the next one which is very similar except for this one unlike hardware this one is reliably getting to e firmware properties so this one is an updatable component okay but otherwise it's very similar that you have the same four possible answers of agitation results your reports tc list and some new field to get uh firmware properties okay because often you have a trusted application that depends on you know particular version of firmware being installed either for security purposes or for functionality purposes that add some capability that you need okay so the same four things exist um attestation results um what the draft did before meaning draft o9 the one that's posted right now is it had uh two things in the eat profile it uses software name and software version during the hackathon we observed that those strings are defined as being human readable strings right they're meant for human display and therefore they may not be reliable enough for machine processing to say is this thing up to date or not i mean you can certainly do a uh byte for a byte comparison or something like that but even that could be error prone if say you patch something and the human doesn't actually change the version string so it's not like it's a digest or whatever so if they don't change it or whatever then it's not reliable so we said if it's not really designed for human processing that's probably not the right claim and uh we had hank at our table and he suggested the manifest claire sorry lawrence was at the table and he said yes the manifest claim was the right one so we said hey that one looks great so uh the manifest claim is great for machine processing although today it's written in a way that we think and we didn't have like brennan at the table or whatever but we we thought that that one seemed as"
  },
  {
    "startTime": "00:56:00",
    "text": "defined right now to require the entire manifest rather than a reference to it and by the way the details on this one are in the suit working group hackathon report and so we'll cover that in the meeting later today about that part so if you have questions on that make sure you're at the suit working group um other possibilities are the suit reports for getting the firmware properties um this does have the same constraint that says uh you can that requires a generating suit reports at say firmware you know start time that could be too burdensome for some tes like you know sgx which does have firmware but uh but draft209 allowed this too right and of course we didn't remove the stuff that was allowed right so he could still do that but maybe not saying that that's the only way to do it so the tc list okay um unlike the hardware properties right that didn't apply to there because tc list was for things that could be updated and firmware can be updated so that one you can do but only if the cheap agent is healthy because otherwise you can't trust that list right and so if the firmware is out of date then you can't look at that list to tell whether you need to update the firmware right because you can't trust it so uh really the manifest part here inside the attestation results seem to be the best answer out of all those and so that's what we changed the document to do so next slide you'll see the details there okay in the eat claims okay this is the the teep profile for attestation results using eat in cwt format okay so this is the set of claims that are uh talked about in the uh eat profile so draft 08 this is as of last ietf meeting right it looked this way and we still had one reference to an in into an individual document okay because there's nothing to point to in the eat spec at that time okay draft oh nine references uh the last eat document as of the internet draft deadline where a couple changes were done there's now uh hw model claim in draft 09. well i'll talk about that in a second here that actually does put in what we need okay so that means we could"
  },
  {
    "startTime": "00:58:00",
    "text": "get rid of the individual draft reference and reference the working group document okay so that one is a different claim it's the now the one in the document that didn't exist before and then you can see that's the really the only change between node 8 and 09 the changes between 09 and the github copy okay well hw model is the label in the uh json okay which we don't use json at cbor right so we fixed that to be the longer version guys the json is off an abbreviation for the real you know claim name if you will so the claim name we use like the the seabor label right which is hardware model so that one is just a simple you know text change in the document doesn't affect implementations okay chip version and hardware version okay the eat document since changed to have hardware version the chip version was now that that label was gone it still has the same meaning right but that changed in the document since you know the the since we wrote draft 09 so we just updated that one to retain consistency with the change in the document and the last one is the actual semantic change okay where we change the software name and version to the manifest one right and that's what i covered in the previous slide right so the github copy we think is now the correct list and uh 09 is now the incorrect or at least out of date list of the labels so okay next slide which is the last one on the same topic inside the profile okay it has it every profile can specify what's the required claims prohibited claims and additional claims or optional claims okay as a reminder today there are no required claims okay meaning you're allowed to say attestation results are good or bad you know you can use you know the air for si and just say you're good you're not good and if you're good that means your teep agent is healthy and you can trust it's it's it's uh it's uh information messages you know it's query results curry response okay and if it says no that means you can't trust anything in the core response you can do that okay that's why required claims is none okay if you want to be more detailed though there might be some reasons to do that"
  },
  {
    "startTime": "01:00:00",
    "text": "okay and so that's why these optional claims are in here and the text that's in the architecture document that we have consensus on talks about what types of information should be in there and that's where the list of optional claims comes from because if you want to be more efficient okay so these are for efficiency not correctness okay so the claims in the previous slide everything on that whole table is for efficiency okay and so that as a tam you can do uh you can not update things that don't need to be updated okay so the attraction result says you are bad do you have to touch the teep agent and the you know the secure world operating system and the trusted firmware or only some subset of those that's where you can use these informations that we're talking about here okay and so this is just to say uh and so these are text that was added to actually say that into the spec okay that says uh uh if you have these and then attempt to update the keep agent and all of this dependencies or only update the specific components that are out of date okay so the optional claims let you do the bottom part here the absence of them forces you into the top one okay so just explaining that wasn't explained before as to as to why they were optional and this actually says what you do in implementing a tp and when what you do when implementing a tam with that information so we put this explicit into the ten behavior section okay next slide and this is you're trying this isn't coming by okay go ahead okay cipher sweet negotiation this was actually one of the large topics that we had because we were all implementing cipher suite negotiation at the table once we ended up with a whole bunch of things and so this one is kind of the laundry list of everything that we hit in implementing exactly that same functionality so first it wasn't clear whether you must must support that this is the agent side which could be a constrained node okay when implementing cozy do you have to support both sine and sign one or just one or the other do you get to pick and you the spec is ambiguous there was two different cdls around what cipher suite equals the cdl protect"
  },
  {
    "startTime": "01:02:02",
    "text": "production right what the body of the document said and what the full cgl section were different and so which one do you implement it was uh unclear which cipher suite combinations were mandatory for the dam it was clear which algorithms were mandatory but like you know the suite is a set of operations and so that's on the next slide here requiring encryption on mac seemed overly burdensome for cases that might not need that especially given you have payload encryption like suit firmware encryption the document that's in suit there was a couple cases that akira pointed out that had incorrect cddl we had errors in the in the cdl tool and uh there was no defined way to specify the order of operations so let's say you wanted to have two cypher suites one that did you know sign and then encrypt and one that had encrypted and signed or some other you know signed twice whatever there was nothing that said how you specify the order right you could specify the algorithms but you couldn't specify what order they went in and if order mattered okay so there was no way to do that at least there wasn't a written down way to do that so this is the list of the problems okay next slide all right so here's what we did to fix those things okay uh first we made cipher suite be a socket meaning you put the dollar in front of it which means it's okay for other specs to extend it take other specs or other implementations it's extensible fields so we fixed that part um to just to make it be explicit that that's intended to be extensible we removed the mac and encrypt algorithms from the body of the document given that it's extensible since you can define a type extension that puts them back in okay um we're trying to say how can we scope down the document of the main thing to make it go to rfc faster just like we did for the suit manifest we took a bunch of optional stuff and moved it off to different extensions without saying it's bad to do we just said that's a different document do the same thing with mac and encrypt we say we're going to move that out of the main document into future extension documents uh same thing with cos a sine okay we said we're at the simplest form it's"
  },
  {
    "startTime": "01:04:01",
    "text": "just sine one there's only one signature um and so we only talk about sine one in here without precluding the use of sine because you can do that in extension by adding another cipher suite it uses sign we fixed the cdl contradiction by saying the appendix was correct the body was wrong and lastly we specify that the order of operations within a cipher suite is meaningful and so you'll see that on the next slide okay go ahead next slide okay so there are two mandatory cipher suites they happen to use the two mandatory algorithms for the tam okay so the way that it works on the tam is that the tam must implement both cyprus both cypher suites these the two algorithms the type agent gets to pick any one of the mandatory set that it wants so you have guaranteed interoperability but the constrained node only needs to do one so for example the one that he might have say hardware offload for for example okay but the tam has to support both so that it works with all of the different um uh agents that might exist at least right now so these are two cipher suites you can say each cipher suite is a set of operations the two mandatory cipher suites only have a single operation each but there could be other ones that have multiple like sign and then decrypt or encrypt and then sign or whatever so this one is just sign and so in the two mandatory ones we happen to have cases there's only one entry in the array of operations okay and this is an ordered array of operations it says you sign and then you do nothing else right but you can imagine you know sign and then encrypt your encrypt and then sign or whatever other sequence that you want and that would be in the in the uh cypher suite sine 1 es256 the operation itself is one that says use sine one with the following algorithm okay and of course this is not necessarily just two things in there because you know cos a sine might have multiple things in there and not just sign one so all the ones in here right now the operation only has two values in the in the internal array but in general it can be more than two right because you know sign one means exactly one right or side means you can have"
  },
  {
    "startTime": "01:06:01",
    "text": "a variable number right and so that's where these two came in there and so we said these two are both mandatory implementation detail eddsa is not yet in lawrence's uh t cosi implementation so i couldn't implement the second one yet um but i think i wasn't the only person asking lawrence for that so where so right now the first one is implemented in a couple of the implementations but i don't think the second one is yet out of the implementation table so um okay um just i want to mention the bottom point on there just to reiterate go back one the last point was that uh just as a note okay these two do not do encryption and so that means security considerations we have to say something about that especially since we already had text that says anybody defining a cipher suite you need to explain why you don't have encryption so we need to make sure that was in there so here's what we said okay we said we don't do encryption of the t player okay but you do encryption at the suit payload layer and we now reference the suit firmware encryption document in in the security considerations section saying if you want to try to protect the payload you don't have to you don't have to encrypt the team message but you better be encrypting the payload and here's the document that says to do that okay i'm just thinking of dependencies okay yeah same thing with dependencies right yeah you can encrypt dependencies too so personalization data is the most obvious case of using firmware encryption but it's not the only one okay so that's what we did for the mandatory cipher suite section okay 222 we're still in the cypher sweet section of stuff a bunch of these are related so this one said supported cipher suites uh was previously an optional field you can see in the red blob there it was previously in there which meant that it could be absent and so the tam could send a message that did not include which cipher suites it supported now what the text used to say is if it's not there it means that it supports the two on the previous slide okay that's what it previously said um and but that means that on the deep asian the constrained node you had that"
  },
  {
    "startTime": "01:08:00",
    "text": "code to deal with both cases okay and you had to hard code the fact that the absence meant those two things he said well what happens you know five six years from now where there's a weakness in one of those you know let's say es 256 has a weakness and we need to move it to what you know es 384 or something like that okay and that means that you still have to have code in the constrained devices that have the old obsolete thing okay and so how do we make it be more robust to the future and uh ken was the one that pointed out that uh you know five six years from now you might have other ones that become mandatory by then too right and so uh at some point in the future you're gonna have to deal with the case where there really is no useful default right so let's just make it mandatory now and all the implementers said yeah sure let's just go ahead and make it be mandatory now because this one is a breaking change okay so we went around the table saying anybody got a problem with this nobody got a problem with this nobody had a problem with it everybody said let's do us we did it as implementers we said okay because the only people are going to object to breaking changes of the implementers and we had five six of them at the table so uh so this one we made a breaking change this one is a major breaking change but we did it and this makes it be mandatory and we think it actually simplifies the code in the cheap agent and makes it be more future-proof so okay next um so it so we updated that and here's the example in the in the um appendix with the examples and so you can say uh here's a particular message of supported cipher suites and you can see it looks like this when it comes across the wire at least in the diagnostic form and you can see the 18 minus 7 and 18 minus eight is what the tam fills in because that's the two cypher suites that we have the previous slide sign one with the s256 and sign one using edgsa is what the tam should be including in all this message this is mandatory currently so so it means that your query request gets a couple bytes longer and your agent implementation gets a little simpler okay next so there's a question about so which cheap messages are protected with which"
  },
  {
    "startTime": "01:10:01",
    "text": "cipher suite so here's what the text says in the internet draft posted version after a query response is received the selected cipher suite is used in subsequent messages install success and error that means you can't protect this career response that's what that text said we said that's probably not right okay because by the time you're sending the query response you've already finished negotiating the cipher suite so shouldn't you be able to protect the correct response too okay um and it's also ambiguous it says does that mean that you have to use the same cipher suite in both directions right is selected means selected that what the type agent does for its operations when composing always has to be the same as what the tam agent is doing so if it's doing sign but not encrypt does that mean the other side has to sign but not decrypt okay and so um right now we said the answer is we couldn't think of a case for in the short term or saying it was bidirectional was a problem that was kind of already implied but it wasn't explicitly stated so we said the least change was to just explicitly state the fact that yes it's bidirectional [Music] and if you need to do different than that then leave that to a deep extension document don't try to address it in the main document because we think it is extensible an extension document i see a nod from the back okay good thank you for the positive feedback all right next slide same issue second related question i just mentioned about the query response okay so the query response it could be protected because you're just you're going to send back in there which cypher suite you selected okay now this is a question that i need somebody that is uh more of a cozy etc expert than i am um the selected cipher suite is inside the teat message the teat message is meaning it's inside the cose blob okay which means you can't get to the selected part without having to parse the coset blob to begin with so as cozy blob is itself described that you know it's safe or sweet it was the time you're decoding the cipher without the blob without having to look inside it i'm hoping the answer is yes can somebody tell me is that this case"
  },
  {
    "startTime": "01:12:00",
    "text": "i've seen hannah's nodding okay good good okay good uh so that was the question here can a receiver figure it out from a cozy object and parse correctly as long as the answer is yes and there's no problem with what we did um can the attestation payload be encrypted can suit reports be encrypted are all questions that arise when addressing this question i think the answer is today can eat be encrypted by using the eat spec i think the answer is yes but we're not sure hank no the answer is no okay can suit reports be encrypted by using the suit report document brandon somebody know without looking these are questions that came up afterwards so that's why i didn't know the answers because we didn't talk about these three during that i mean it doesn't say no um but there's no explicit mechanism enabling that yet i think it says that they're supposed to be uh authenticated because that's kind of important um but i don't think there's anything that says anything about encryption so far okay um so i guess the teep feedback would be it might be nice for the student reports document to say something and this gets back to the question of um if you cannot via the spec then it means the teep cipher suite might need to do encryption assuming that there's sensitive data in the suit reports right i can easily imagine that there is sensitive data in a suit report okay and if that's the case you know just to give you considerations then it should be encrypted somewhere either by the transport or by the suit report itself i'm just curious as to what the um what the key exchange mechanism would look like in that scenario that seems like a really um challenging environment for a key exchange i agree i don't know the answer that's why i came up as a question so so what we're saying in teep right now is that uh teep does not solve the transport layer without an extension and it leaves it up to the payload and it could just be don't put sensitive information in the suit report if you're not going to encrypt it right just put"
  },
  {
    "startTime": "01:14:02",
    "text": "so which directive failed might not be sensitive information right so at that level you should have a pub key for the recipient right yeah okay yeah it should be doable okay okay thank you um again those were questions that are i think are more i hope are more questions for the suit reports document and not for the t protocol document but happy to be wrong so all right um last question um does it mean that an error sent in response to a query request cannot be protected okay because if you had a query request that was malformed and i'm saying uh or for example it was saying a set of uh supported cypher suicide did not include one that the teap agent supports okay which technically that should never happen with a compliant tam but you got to be robust to non-compliant tams or maybe future tams that uh within with a current agent right a future one that changes the set of uh which ones are are you know more secure or whatever so could you send an error message in response to that and the answer is yes right now we did that but could you protect it with anything okay um and in some cases you know the suit reports could be considered sensitive so here's an example of what we might say this one i don't think is in the github copy right now it says uh here's an example of what i thought we might say if the teep agent was able to select a cipher suite from among the tim's supported cypher suites and that wasn't the problem in the in the in the query response right then use that to protect the error message right because you can get to a key then right you can get to a set of operations you know the other guy can't you're going to plan about something else like uh wrong version right would be an example right say here's the seriously requested version and i don't support that version or any other things you know unsupported extension that type of thing okay so if you can go ahead and protect that otherwise protect the error with a mandatory cipher suite that the tp agent supports okay and if the tam can support it great if not well you weren't going to get communication anyway so uh but specifically don't include"
  },
  {
    "startTime": "01:16:00",
    "text": "sensitive information with a cypher suite that doesn't encrypt okay so my proposal is we put those three sentences in there and call that good enough i see a nod from russ and uh akira is getting a cue okay i'll forgive you you're supposed to get on the queue but that's okay oh no no go ahead yeah um we we also talked about this in the during the hackathon and probably talked in japanese um there was one more one more choice we had it was uh not responding the any error message because the error message with uh some anything uh could be used for the attacker to sense the implementation how to go go work around um yeah there's a complicated issue there that actually overlaps the meeting i just came out of which was me right before this was the the edm uh program of the iab which is the the contentious document about uh the robustus principle considered harmful and this was actually one of the topics so uh yeah so there are considerations there meaning there are arguments to do both um uh my personal opinion is uh you should send an error message when you can and i can tell you the authors of that document have reasons why that is but it may not be 100 applicable to your point so so maybe there's another sentence we should add to clarify or whatever but in most cases um sending the error actually is uh helps to tell the other side the fact that it's doing something wrong because otherwise it will keep doing the wrong thing if you don't tell them at least that's that's probably the argument so um that one is hard yeah okay so um oh this is the slide deck that doesn't have the last slide in it so i'm going to do that verbally which is the one that can post it i can push the button finally michael richardson so um just about the"
  },
  {
    "startTime": "01:18:01",
    "text": "last point i think we have enough enough enough bad experiences from ikev1 for instance where you know the error about not being able to uh select the cipher suites was on on was never transmitted and you never could fix problems and and you know uh you know what it telling telling telling the attacker the list of cipher suites that you might support is just not that big a deal they can enumerate them and and we were really anal about that at the time and it did not contribute to interoperability or debug ability so um if that's the reason for not sending an error don't do that please so it sounds like you don't have an issue with the bullets that are on here right now i don't have an issue with there yeah i don't have an issue and if someone thinks what i'm saying is i think we should be really clear about that and not not accept any you know i don't disclose my policy because it's a security problem because i think that just leads to people turning all the off i can try and reload yeah if you want to try to reload because i added one more slide so uh the other day ken posted the message to the suit list that i then responded to and added the teep list onto there because it's a cross type suit issue uh that we both ran into in our implementations but we didn't explicitly discuss i think we came up with the hackathon but then we kind of forgot about it until afterwards until this message came up there so uh let's see if it's in here so it should be the last slide i'm trying yep yep it has to do with how do you delete a component okay is it so it's in the meeting materials yeah but it's not in the folder interesting very interesting so i don't know how to i i have it on my laptop but i would"
  },
  {
    "startTime": "01:20:01",
    "text": "rather let somebody else deal with it so then we can leave it up here i see countdown clock gallery view if you'd like to be av tech support yeah yeah russ step out of the box here sir else can come here on the top right i see nothing i see oh middle okay so i'll start introducing it to distract from the the the man behind the curtain over there the the question that came up and sorry for those that are remote i'm not on mike right now or not on camera right now you can watch the tech crew over there and just listen um the question comes up when you have a number of different keep agents that are being managed by the same tab okay and let's say one of them no longer needs a particular trusted component i can come back now awesome okay out of the type agents that atam is managing some of them want to keep using a trusted component and some of them don't need it anymore okay and so this situation results it's still not there it's not there all right um what's in the slides so it is in the meeting material it is yes all right i'll just talk to it if i can remember it and then somebody else can call it up and and tell me if i'm missing a point okay so all right back up repeat all right so you have a bunch of different type agents some of them need a contrasting component some of them no longer need it it's one of the optional ones that says the teep agents can have it in this example the t pages can have it when they have something that depends on it right it may vary right so whether think of it as phones and sometimes the user has an app installed and sometimes it doesn't all the phones are authorized too if they want it right so cam is perfectly fine as long as as long as the tp agent would want it that it could have it so this means it says okay one of those devices says i don't need it anymore the user uninstalled it okay so here's this just example okay so now i need to"
  },
  {
    "startTime": "01:22:01",
    "text": "but i don't want to delete from all the other ones okay so what we have in the protocol right now the other two pages you got a bunch of different devices one of them doesn't want anymore so i want to delete it on that one but i don't want to force it to be deleted on all the other tp agents all the other devices are still going to use that component okay okay and so what the tam has is he has a set of teeth manifest of suit manifests or perhaps references to suit manifest stored in other repositories okay and so what we did in a previous version the teep protocol is we removed like a delete message and we said we're just going to use the update message to do all types of updates okay the update message today allows you to specify a list of suit manifests we showed that on a previous slide here okay that means to do a deletion you got to pass down a suit manifest that has the delete directives in it okay so if you're following the logic here that means that if i have some that need to be deleted some type agents that need a deletion and some that don't i have to have a version of a t of a suit manifest today that i can use to send to just that one that's different from the suit manifest that i'm sending the other one okay that means i have to either construct one or get one from the author depending on who the sign or the suit manifest is okay so either i have to construct one where like i'm the signer and i resign it to whatever and so there's an extra burden here okay it says well what ver what manifest no what manifest sequence number do i put in the deletion manifest okay right but what's one plus because you know the the the manifest that i sent to you and to hanus would be different ones they both have the same sequence number right not that you know that that's fine right but that means i have two different versions and who's incrementing that and is it the tam or is it the manifest author or is the tam a new manifest author that wraps the original one or whatever so that's the kind of questions that come up okay second problem with that with that thing is to say um what happens if there's a component that's on there there's your slide thank you"
  },
  {
    "startTime": "01:24:00",
    "text": "yes thank you i just did it okay yeah so here's the manifest list that exists right now okay uh in the update message okay and i've just been talking about what if the tam has it manifested a third party do you like encapsulate it and resign it as a new signer whatever what if the device has a component that the tam doesn't know about all right the query response said i have this other suit manifest thing here's my component id the tam says i've never seen that before how do you delete that if you've never seen it before it's not really specified in suit right so you said well is it we could do this with suit maybe if you come up with a way to do it but is that the right mechanism okay so this what if a device has a component that showed up there it was installed by you know sneaker net or something maybe it had a suit manifest that the heap agent has but the tam didn't know about it before he's never heard of it before until you sent the the the you know component id and digest and stuff and attempt says i don't know where this thing came from please delete it you're not authorized to have this right um so you gotta have a way to delete that and so ken proposed uh let's have when we install with a suit manifest right whether it comes to the tam or not okay what if because you have installed directives and says here's the suit manifest and here's the steps to to install or to boot or whatever right ken's proposal is well let's also add when installing whatever and by the way for future reference here's the uninstall here's the opposites here's how to clean the stuff up okay and so that gets packaged in the original install one so i'd have to bump the version number all the uninstall directives are in the original one so however you got the original one you have the uninstall directives around and by the way both software packages that you installed today on platforms already have the uninstall mechanism in the installer package right so it's kind of consistent with that mechanism that's kind of where the idea comes from so this idea that says what if the suit manifest had uninstalled directives so you don't bump the version number if you just want to say delete that thing i've never heard of he said you know that thing you told me about follow the understand the uninstalled directives please"
  },
  {
    "startTime": "01:26:01",
    "text": "here which is if suit puts in the uninstall directives as ken proposed then we could go back to this update message right which right now is a manifest list and we could put back in here a way to say just delete by id right here's the id i'm not going to give you the full suit manifest because i may not have it right you have it or you would have told me about it just follow the uninstall procedures you already have okay so that's kind of the summary of this thread that kev and i were starting on the list here and we wanted feedback from the working groups on this because we're not going to have time in suit to talk about this because we're already you know at the hour or whatever so this is the only time we have if you have comments well you've got two people on thecube brandon yep totaled this yet you're sorry have you threat modeled this yet oh no it's a message on a list as of two days ago so yeah so so i'd be really interested in exactly what the threat model is here because it sounds to me like you're introducing an unauthenticated command to remove a component no the tam is authoritative for what software what trusted components are running in the teep agent's tee that's the definition of the tan it's the trust of the application manager of that device now here's the second question um what exactly do you okay i'll come back sorry um no i need to finish that that thread um right so how many tams can one device have and how do you divide up their uh areas what happens when there is a mutual dependency between two tams how do you make sure that one doesn't forcibly uninstall something that the other has is depending on yeah the answer to that is if we go all the way back to the otrp document it used the term trust domain which came"
  },
  {
    "startTime": "01:28:01",
    "text": "out of global platform world meaning the meaning that global platform defines for trust domain and that there's one ham per trust domain and that's why ken's proposal is to talk about this in suits trust domains document because the assumption that there is one tam per crest domain unless um a tam explicitly delegates another one like personalization data or something like that there are cases on a particular suit manifest there exists only one uh you know thing that would be the the controller of it so that means that dependencies across trust domains are forbidden yes well i don't know what dependencies i would say uh on non-explicit dependencies across trust domains no no i'm talking about explicit dependencies across trust domains because then the second tam has the ability to break the dependencies of the first tam uh i understand what you're saying and uh i i think that you can do that and so yes if you're delegating to say tam one has a dependency on something for which tam two is authoritative then and you consider that to be acceptable when defining you know tam one's the manifesto is pushing out and tam one is saying yes i'm agreeing that tam two can always yank one of my dependencies and kind of override my ability to work right yes that's possible okay left pad here we come all right then the the other point is what exactly lives in those uninstall instructions because that is really unclear to me is it just a list of components that you don't need like what is it um i i think i don't know candace and coming up to the mic so i'll attempt to channel what i think that we would say is the the installed directives are an explicit set of steps that you follow in order to do the install right you copy this component into this you know disk space or whatever it is and it should"
  },
  {
    "startTime": "01:30:01",
    "text": "in lowercase should be the exact opposite of those now you're pointing out what happens if it's not and that is uh dangerous right and i get your point brendan so i i would really like um speaking as a a suit author i would very much appreciate a few examples from the teap list of exactly what would go in an uninstall directives sequence because unless we have that i'm really not sure what we can do the obvious ones that i can think of is because if i look at um uninstall equipment directives in other formats not not t but you know what um msis on uh or inf files on windows and similar things and you know apt or pip or whatever it's like delete the following uh component from the following from the following directory or repository uh for some definition so like in windows you have a registry or a file system you have a file system directory for holding libraries or includes or executing you know your bin directory or whatever your install direct your install directive say copy this thing into the bin directory and then delete says delete uninstall says delete it from the bin directory the same thing but it better be the same thing or you've got a security problem so but yes deleting things from specific repositories whether those are disk space or some other database that's resident on the system so in suit parlance could that simply be a list of indices of component ids do we need commands at all you probably know better than i do so maybe okay um i think any further should probably go to the list i think i've got a good overview thank you yeah but that was why we started this thread on the list thank you ken for kicking off this thread because it really is a cross-deep suit discussion although um my belief is a lot of the answer is in suit and the t-pass to follow whatever suit directs but uh suit only has an hour and this can't be on the agenda because we've got a full hour or so"
  },
  {
    "startTime": "01:32:01",
    "text": "list correct right so a lot well we want to kick it off here and then different knowing that's correct michael michael richardson so i had two things i have two things to say now i have to listen to brendan um the one that i almost forgot was why do we wind up in the case where we have something that the tam doesn't know about and actually i think a very reasonable situation is um there is a problem and with the components and the um user has been given a adequately signed debug version that the tam is willing to to accept but you don't normally give this out it runs for a while and and then later on when you know the bug is actually found and fixed and things need to be upgraded then you know what some component now gets deleted that was the debug version of it and that's why the tam doesn't know about it because it arrived through you know other other means and i think that's a really i think that's a really good thing because uh it means that we can both debug but then remove the user from the debug situation uh later on so i think that's really good okay i agree as for the other concern about trust about different domains and whatever the only reason why domain a with tam a would ever be sharing any component with domain b with tam b is because you are seriously limited on space okay that's to me the only reason you're another reason they're not delegating to each other they don't know about each other first of all there's an example it's in the architecture spec okay and the example is uh the code comes from one tam and the personalization data comes from another tam fair enough that that's the example that's in there okay and and so in fact the personalization data could be used by multiple entities and it's because you know the the the tam with the personalization data does not trust"
  },
  {
    "startTime": "01:34:00",
    "text": "the first tam with the actual personalization data right so you might have fair enough it doesn't change my subsequent comments which were essentially that well if the reason was disk space but you've just given me a different reason okay um then you know uh reference counted hard links are 50 year old technology okay and um we that's to me just one of them unlinks it and the other one says well i still have a copy because underlying i still have it okay i just don't think that's fundamentally an argument against this okay i think that is a great point and i think that's exactly why brennan would use the term unlink in the suit manifest document as for similar reasons so i think that's a great answer to your question brandon is that's what unlink is and you can't make it go to zero you can just drop it by one okay i don't know how we're doing on time but i told you i was gonna take all my other time back so you did okay you did all right i think penguin yes so penguin see if i can oh that's rude all the slots are taken what i'm trying to unshare and reshare there we go i'm living on the edge i keep getting these networkers okay so okay so sorry i have to join this meeting remotely so is my audio on the video clear yes okay so this is the draft about the tip"
  },
  {
    "startTime": "01:36:02",
    "text": "tip use case oh sorry i lost oh here it is here is the tv use kits for computational computing network and i also shared these drafts in the competition computing consortium so next slide please now here's a motivation and we all know that the computational computing is the protection of data in use by hardware-based trust execution environment but when using this computational computing in network or in a remote environment so i think there are some issues that need to be clarified so first is that what is the architecture of what is the instance of competition computing in a network and the second one is that what kind of oh sorry i lost the yeah i'm trying to reshare because somebody soren mentioned that the slides are not being shared so for those that are remote can you see the slides now claims that i'm sharing them yeah i can't see it okay i can see them looks good here okay okay thank you so the second question is what kind of application package a network user should use would it be a trust application and personalization data are banned together or not the third question is what kind of steps a network should we follow to deploy application packages i think that the tip architecture has defined a lot of uh components like the active agency broker and etc but i think these questions especially from the perspective of a user or network user i think we need to clarify this so this drafter try to use this tip architecture and the protocol to illustrate this configuration computing in network and this includes the notion architecture the relevant package type of application and the"
  },
  {
    "startTime": "01:38:00",
    "text": "deploy steps so next slide please okay here's the uh i think in general this there are three kinds of competition computing instance that could exist in the network the first one is a trusted process which could be in a virtual machine or could be in operating system and the second one is the trusted vm which is based on a hypervisor and the processor process process and the containers in this trusted virtual machine are also confidential and third one is the container so the container could be in a container engine including a virtual machine and this container is also protected by the te also so in general these are three instances that the network user could use when they want to say that i want a te and which kind of key is it so it me it may be a process a work machine or container so next slide please now here's the notional architecture of the of this draft so we added the two components first one is the network moc which is network management and orchestration center and the trusted application manager is inside the network moc and the second is a data owner or the network user as a network user who also owns the personalization data and the trust replication and also the unfaster application there are also some components like the trust application and fast application and tip broker tip agent this has been defined in the chip architecture so next slide please uh here is the application uh package and the deploy steps so i think there are two principles to"
  },
  {
    "startTime": "01:40:01",
    "text": "deploy packages in the confidential computing environment first one is that the personalization data can only be processed by time after remote attestation and principle two is that the personalized data must be transferred securely and i mean security is that this package could be encrypted or during some secure channel like a remote addition tls or just the way it talked before the course formula or some some other formats so the table shows is one example one case case one in this case the uata and pa and pd are valued as one package and in the second column shows that the process in a physical or virtual machine this could be uh supported by the chat zone or sjx and in in this scenario the steps should follow uh in like in the table first of all the network will attach the tip agent to see if the tip agent is trusted so after verification and and the the network user will transfer this package to the tip agent and then tip 18 the world will decrypt or unpack this package and then the trusted application will be loaded to the trusted process and then the personalized data will be loaded to a trusted application and in the end the untrusted application will be loaded to the ring so this is a basic principle of the logic i think we should follow and the third column shows the steps in the container for physical or virtual machine and the last column shows that so the step of how to deploy in a a virtual machine next slide please there are some other different packages"
  },
  {
    "startTime": "01:42:00",
    "text": "like this package mode is the ua tier one package and the personalization data is one package all the uata and pd are separate packages and in this scenario the ua should be deployed to the reforest and then the ta is loaded to the trusted process of trusted container or cluster vm then will the network user will will test the tip agent after verification the network user will trust the te then it will transfer its personalized data to the test application in the process or container of virtual machine and the lower table shows that oh some forms mistake i think uh this scenario i think it is that the ta and pd are one package and the ua is another package and so the steps should be the ua first load to the re and the zone there is a network remote attestation and then the t and pd will be loaded to the trust process or container or virtual machine so next slide please uh these these tables they are also also uh different uh cases this one is the upper one is that uh pa and pd are separate packages and the lower one is that the ta and pd are the same package so they also have uh steps to deploy this package and they may be a little bit different so yeah these are all the cases i think uh involved the next slide this now here is one interesting scenario that is not inside the draft but i think it is very interesting to share with you guys and in this scenario that with this use case and the tip and the computer computing could be interested introduced to different scenarios like oblivious transfer which belongs to the"
  },
  {
    "startTime": "01:44:00",
    "text": "private computing and the original obliques oblivious transfer is that the collector which i think is a network user could query a certain information from the data center and the data center cannot know the specific query information and in order to do that the ot algorithm will create lots of redemptive query results to password the data center and this will cause lots of natural overhead to transfer this redundant data result to the collector for example if the data center has one gigabit of information and the collector only want to query 10 bits of information so the ot algorithm will have to create a more than one gigabyte of redundant information and transfer to the collector then the collector will decrypt all these information until it gets the correct query information result so when we use computer computing and combined with ot algorithm i think things will be more easy first we deploy the ot algorithm which is also the trust application to the data center and then we'll transfer the personalization data which is also the query information to that ot algorithm then the result is that it could replace the network overhead by memory access and only transfer the correct query result to collector because that the company computing could protect the information inside its environment so the uh it uh the the ot algorithm could uh process all the information and uh until it gets the correct query information and just to transfer the 10 bits of information to the collector so this is just one very interesting scenario scenario uh next slide please i think that's it yeah here's a summary this use case is trying to use a tip architecture architecture and protocol to illustrate how to use"
  },
  {
    "startTime": "01:46:00",
    "text": "computer computing in the network and list out the relevant steps and the package mode and since this could get the network user a remote user to use this technology and then there are there are some issues that remain open or not in this draft scope i think for example how to process remote attestation and how to create a secure channel i think there has been a lot of discussion in these issues so i'm not sure if this is a unicorn i think they may be covered by other groups like the right group or the how to create a motivation i think it's based on the hardware architecture like use the quote enclave or secure process processor um in the end i we would like that uh this draft to be adopted as a working group product i think that would be very very appreciate oh i have a highness on the cube yes so harness yeah i think um the work that bingling is doing is is quite important because in in the way we described the terminology and the architecture was course uh predates sort of all the excitement on confidential computing but it still has um the ingredients in there like what we refer to as personalization data is often for some people working in a confidential computing space um difficult to associate with some of their confidential workloads because the names are so different and some of the others so i i personally see that there's a possibility for us to um sort of describes on how to map some of the confidential computing use cases and uh there are different sort of models that springling was just talking about um to the uh the deep architecture and i think explaining that and potentially motivating with some examples on how you do that how how what that means like um"
  },
  {
    "startTime": "01:48:02",
    "text": "with applying deep protocol uh and and its subcomponents i think that could be quite helpful for readers who stumble over the work or i want to come up with a standardized way in um in supporting some of the confidential computing use cases okay uh dave dave famer uh so i think there's uh two things that are in uh penguins presentation and draft that i hadn't seen in any other uh draft or presentation and i think are valuable contributions to the t discussion one of them was uh in the use case form of where is the tp the device the cheap agent right because the cases that we've talked about in you know architecture and other drafts and things were the type agents in some device like an iot device or something like that or a phone or a laptop or whatever and the case where it's in the cloud okay this is a use case where it's neither of those okay it's some middle box in the network such as you know the network operators you know router or switch or something like that and so it's like a cloud except for it's actually in the local network okay so it's just a variation of like a local cloud whatever it's just another use case that says you can use the same technology to do with the cloud you can do that with the device here okay and so that part is just an interesting yeah this too okay um but the other thing that that this talked about that um applies to the cloud as well that we didn't explicitly cover was um in the architecture document we talk about the bundling where we have like the untrusted app the trusted app and the personalization data and that's where you cover all those like different cases and stuff right in the cloud and in this case right there doesn't have to be an untrusted app okay if you think about the the trend towards you know confidential vms and combination containers and so on there's only a trusted app there's no untrusted"
  },
  {
    "startTime": "01:50:00",
    "text": "app on the whole device right and so that's something that that i think does come up and was talked about in penguin's draft that didn't wasn't mentioned in any other thing unless you know the absence of an untrusted application is also an interesting contribution to the discussion so uh thanks penguin for bringing up both of those cases i think they're both uh worth making sure that we're thinking about when we're doing drafts and implementations and stuff is to say what if what if there is no untrusted app it's just the trusted app running inside of a tee and the only thing that's using it is something across the network right and you have some network path whatever that's provided by the tee that's not the untrusted app per se is not involved so there is no such thing so i think that part is a useful contribution and the oh yeah when talking about things without a user interface right it's not just the cloud as we classically think about it with cloud confidential computing with like you know azure and aws and gcp and so on it's also things like network operators is an interesting use case we want to consider too i don't know that chain may has any changes the protocol okay but i think it's an interesting use case in particular the lack of a ua i think is a good contribution so thanks thanks thank you thank you dude yeah so danielle we go the mic um hi i'd like also to support if if we have a document that illustrates somehow some of the discussions we're having this working group i think that's going to be helpful for people watching at us one thing i have the impression that we should not try to be um to provide a complete description of everything that can be done so um if we can target that just as an open illustrative discussion i think it's um it's reasonable but we don't want to end up with a book at the end yeah i mean that's what we tried to do in the architecture or the authors of the architecture as well right um so what i'm hearing is that this is a useful addition for another model right um i guess the question that i have is i"
  },
  {
    "startTime": "01:52:01",
    "text": "see that as a standards track document although i don't see it making any changes so my question as a chair is does it need i see it more as an informational as opposed to standards right so as a chair that would be my recommendation um dave you're back in the queue yeah i think yes um i'm trying to think um what i think might be useful i i'll think on the fly about uh nancy your question um informational not standard track to that question because this is about use cases um i'm thinking that it may be useful if we can combine both the cloud case and the network case into a single use case document that covers both because i think this notion that says there are use cases that don't have an untrusted application and here's two of them they're very similar there's different types of operators but the technology wise right they're almost identical um other than that you know the things that go around tea brightens but a lot of the same considerations i think it might be useful to have a working group documents informational use case that covers both cloud uh and uh network which are cases that don't have a ua okay that's the common thread i'm confused i i thought this draft covered both but then i've been this draft that penguin is presenting is called uh confidence for the network and for that he's talking about cloud is already covered there we're talking about in your local network or whatever and i'm saying if you broaden it to say and cloud two and say take penguin's document add the cloud stuff into it too then i think it's actually even more applicable because we don't have a document that says you can have cloud confidential computing cases without a ua just like you can have never accomplished your committee cases out of ua it would be useful to put that in one"
  },
  {
    "startTime": "01:54:00",
    "text": "document and not try to just try to say we don't need a whole bunch of documents right combine them into one document says use cases without a t without a ua and penguin's case and the cloud cases uh have a lot of the same text that you'd want and so just put it in the comment section so that's what i would say is if that is done then i think it would probably be useful to have another informational use case document whether it's done as a working group document or not i i don't care either way i think it does make sense so okay so do you want to wait until that inclusion is made or do you want to adopt this i'm trying to figure out how to well i see daniel and q and i want to know if he would change my opinion so yeah go ahead uh no i don't i don't know so so in my case i don't really have a strong opinion but i had in mind more some something informational yes informational but um i mean i'm not strong so i might change my mind somewhere well so pengling as a chair my recommendation is given what we just discussed is that it's not a standards track document it would be an informational document so if we were to adopt it and it moves forward with adoption i would have you change it from standards track to informational okay my first thought is informational but somehow the draft is standard yeah okay okay well yeah technically i'm not out of the cube oh yeah all i was going to say is um i i i'm looking at our a.d and stuff but i i think it's within the realm of the working group decide how many documents a milestone gets split into and if you consider this to be like an a a separate thing that we didn't cover in the architecture document because it's not core it's like an addendum and we could use that without having a new uh any charter updates as long as the ad agrees with that and i don't see any issues with saying yeah we could have another milestone or something like that um i just want to confirm that there's no charter issue here i don't think"
  },
  {
    "startTime": "01:56:01",
    "text": "there is and i see you nodding so okay good okay oh thank you i i didn't think so that was going to be my last question to to rad whom i can't see because of the cameras but yes i'm too short so soren you're in the queue what i would like to help here is that in my opinion there are two interesting use cases that i hope they are included in this targeted that one the the first one is uh the the fact that we will use containers it could be a problem for the container security uh and that that's why i think that it should be a different use case or the normal use case i'm looking to the clouds mostly right that's the current uh direction for my thinking so uh i'm i'm worried about the security issues of that a little bit so can you hear me yes yes because i think i i lost it for a second okay so uh so that that will be my i think i would like to to to show the two cases being one cloud proper and one containers in the cloud that's my point and i i will be very interested to join the draft okay thank you um chris hi so i'm i'm reacting to soren and i'm kind of curious about what he means by kind of container security um and complications and so i mean i i understand a little bit and and i'll give you a little bit of background in that uh you know carnegie mellon university we have some research project going on that's actually rewriting kind of the c groups of linux in with formal analysis tied into"
  },
  {
    "startTime": "01:58:03",
    "text": "um secure hardware you know root of trust with a hypervisor that's already written in formal language so it would have formal proofs of correctness from the you know secure execution element up through the virtualization stop so i'd be very interested in understanding what your what your kind of definition of what those risks are yeah sure okay sorry so so from a working group point of view if this is in scope as well you know if you want any input on that right um so in the interest of time we've got two minutes left what i'm trying to assess his readiness of adoption for this particular document versus waiting to get inclusion at least dave you made it clear if the applicability of the network use case and the pure cloud use case and so i would i was trying to craft a poll it really sucks to do everything parallel so i was trying to craft a poll to see if there was interest in waiting for the inclusion of both or so let me just start the session and i may not have worded it perfectly but let me just move it forward as a poll and it's basically i'm asking the question do you want both use cases included before we adopt the document or can i ask the question to just adopt this document as a seed and we elaborate moving forward so the first question is do you want to wait for everything so let's go ahead and i'm going to give it a few more seconds because we're going to be running out of time pretty soon"
  },
  {
    "startTime": "02:00:04",
    "text": "so i will need help from the aedn it's not overwhelming consensus so i could help with guidance there honest well let me i'd like to get the ad to follow the city so so i don't think there's a big difference in between doing it before or after the adoption call if you're if you if you plan on doing it anyway you'll get some discussion anyway if it doesn't happen so either is fine with me okay and and that's pretty much what i where you were interpreting the result as well for that reason yeah i mean there there's the consensus of leaning towards let's just do the call so um let me start the poll okay please hang on network you can do this um i usually ask a set of questions um you support adoption uh the and peng help me in real life um time the name of your draft again use cases for confidential computing in network yeah i think uh dave's idea is is better we can adopt it first and then add it to the continuous case in that okay i have started a poll to support adoption for the draft that peng just um presented since we're out of time and then we'll confirm it on the mail list so"
  },
  {
    "startTime": "02:02:01",
    "text": "okay so we pretty much have unanimous consent here which is good we have strong support so um ping ling what i'm going to ask you to do is change it and i can if i forget just remind me change the draft to informational and make it a multi-draft and then you can submit it okay okay okay so with that see this is why i always leave a few minutes buffer because we're two minutes over with that um thank you to the authors and presenters ping ling we're making good progress i didn't get to ask the question so i'll ask it on the list whether we can do an early review for the protocol draft and readiness working working group last call so i'll do that on the mail list dave right now my plan is to go ahead and post the github copy and then keep working on the issues just because that gets a whole bunch of them out of the way and now we're down to like the three that we've been talking about recently and not have to wait for those of the three just so we get an update so that any question of whether you wanted to put another ref before i do the question of readiness for working with last call well we know that there's three open issues and so that's up to you i guess so i mean there's three issues we discussed that don't have github pull requests already merged right so all but three of them meaning ken's which doesn't have a number and i think there's two other ones that we discussed the last three slides or the last three topics for ones that don't already have text merge into the github copy i'll just take a snapshot of what's in github right now push it up there and that will allow us to close all the other issues and only have the ones that were in the middle of discussion here that we talked about proposals for um i'd like to do that before it gets too long just so that all the implementers are using the same copy okay thanks thank you everyone"
  },
  {
    "startTime": "02:04:12",
    "text": "you"
  }
]
