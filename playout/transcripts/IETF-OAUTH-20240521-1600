[
  {
    "startTime": "00:00:28",
    "text": "e e test one two can you hear me yep hey Paul yep great R are you sharing the slides or should I do this uh I I'll start with the just um the chair slid first uh I can share it from here and I can probably hand it to you so you can drive it for from your side right okay let's just wait few more minutes because uh just to give people more uh"
  },
  {
    "startTime": "00:02:00",
    "text": "more people to CH want to join yeah yeah of course I just wanted to check in on the procedure y oh I think I'm set up now what kicked out a sec for a second thanks Anis thanks thanks for taking notes appreciate that we'll start we'll we'll start 1205 so let's give people two more minutes think get going e"
  },
  {
    "startTime": "00:04:28",
    "text": "e e okay let's get going welcome everyone uh this is uh this is the not well as as you know probably already um this applies here um and it is important that you understand understand the not well and the implication of that the not well covers everything that we do at the ETF so it's important that you understand this if you're not familiar with this already um our schedule uh we had two meetings FM to1 today we'll talk about atation based client authentication ER and a reminder that next week we do not have a meeting because it's identity ver week so"
  },
  {
    "startTime": "00:06:01",
    "text": "there's no meeting next week we will pick up on June 4th with Pika so that's our schedule um any comments questions about this okay I may share Paul slide here and Paul let me see if I can hand you the slide control can you you should see kind of some pop up there give you control over those SLS are you do you see that um I don't think so um oh hold on I I think I passed it to somebody else let me see how about now yeah it says refart passes the slides control to you but I don't see a pop up that was the wrong one stop slides did I stop the slides now yeah but do you have control over like you should be able to share or share the slides you don't have to share the screen you can just use the okay let me see try again selection can you see the slides I can see the slides yeah can you control it see if you can control no I don't see you pop up do you just want to click through the slides that's fine I can I can yes okay I Tred one more time I think now I can yeah now I can see it okay great perfect yeah perfect okay okay um then H let's start this um so this interam calls about um a draft adopted by the O working group it's called adastation based client Authentication"
  },
  {
    "startTime": "00:08:00",
    "text": "and in the beginning I will walk walk you through the status quo what's it about and what's the current status and then afterwards we will go into the main discussions around this draft and try to get some feedback so as a refresher what's the motivation for this um the main motivation is originating from the yeah verifiable credential ecosystems that are arising and using uh oo mechanism especially with the open ID for BCI um the typical o models that um for example torson tried to apply um to this when we started the discussions about two years ago where that or mainly using authentication through a backend channel uh um but this uh causes quite a lot of privacy concerns in this model as the um as the um authentication provider so in in in this regard the wallet provider would see um all attestations or all credentials that are being shared and this is something that we wanted to avoid and therefore um we uh acknowledge that it might be worth to see that uh the client back end May generate some authentication statements um and pass these to to the front end um and then the front end can give these attestations themselves to the issuer and therefore you have a kind of an authentication flow that runs through the front end so the front end is communicating with a third party and not"
  },
  {
    "startTime": "00:10:01",
    "text": "uh the back end at the same time we have a number of available platform and key attestations that um are quite mature um and they can be used in again the issue holder verifi verifi verifier model or like the verifile credentials ecosystem um environments that traditionally has been seen as public clients so mainly native apps um on Android or iOS um have these platform and key attestations um and this enables them then with this um authentication flow um to to to use these um attestations towards the back end um and this then enables this authentication flow uh running through through uh the front end and this also is a motivation that we have a lot of different platform and key attestations uh that are often vendor specific and um the motivation was also to have a techn technologically neutral uh attestation that we can then use um towards the authorization server so that the authorization server does not need to understand all the different adastation formats but we can have like unified interface that yeah is more stable um and that these platform adapations are usually not intended to be used for uh third parties and so mixing this all together um and also having some motivation that's mainly coming from idas uh so I don't want to talk too much of this but"
  },
  {
    "startTime": "00:12:01",
    "text": "we have some use cases that need the issuance of high Assurance credentials mainly the PID uh which is assured for person identification data it's kind of the national ID card um credential equivalent and um we wanted to prove the authenticity of of the wallet and we wanted to prove authenticity and and level of assurance of the of the keys that these credentials should be bound to um and there's also discussion that relying parties should be able to verify that the wallet instance is authentic so these are all lots of use cases that would make use of this so how does it look like uh first of all we differentiate between a cent Cent and a client instance so a client is kind of the wallet solution as a whole and the client instance speaking in Native app terms is then one specific deployment one installation of an app um and we want to enable that client instances can authenticate towards authorization service and therefore the client instance generates um client instance key that's living on the client instance device um and it can then send this key together with some attestations to prove its authenticity to its client back end client back end can verify uh this information and generate a client adastation sending then this client adastation back to uh the client"
  },
  {
    "startTime": "00:14:00",
    "text": "instance and the client end station is signed by the client backend and then if the client instance wants to authenticate towards the authorization server it can make a proof of possession with its client instance key and then send the client attestation and the client attestation proof of possession here in Step six to the authorization server so basically it's a keybound client adapation Json web token um yeah that is sent to the authorization server um important to notice that um this is the general model um but the draft only focuses on certain aspects of this on purpose especially steps two and four are out of scope so specifically how a client in instance authenticates towards the client back end which platform ad stations or key ad stations it's using is out of scope um it is more important that the client adastation jot is defined by the draft the client adastation prove of possession is defined by the draft the communication how this is being sent and generated is is defined by this draft but um yeah these mechanisms in turn four are not um and also the the trust mechanism how the authorization server trusts the public keys from the client back end that are being used to sign the client attestation jot uh is also out of scope so that people may use open ID Federation or trust list or whatever they want we don't"
  },
  {
    "startTime": "00:16:00",
    "text": "um want to make any choices there yet uh or do not intend so until now um other points so this is a slightly different um architecture um graphic it just symbolizes that this key for example if we have this in a native app scenario we have the app then um probably living in a TPM a secure element secure Enclave there's many many technologies that can make use of this um this is one of the main intentions to use Hardware bound keys or protected keys because then the client backend can be sure that this client adastation jot can be used securely in the future um yeah it is using in its current state the um framework from RFC 7521 uh so it is a client authentication method um there's also some other benefit it may be used in conjunction with depop um to give better assurances about um the depop key that's being used to secure the access token so you could use this key or embed other information in the client ustation on the key that's being used for depop um and yeah it enables um a direct um authentication scheme between the client instance and the authorization server in a frontend pattern rather than a backend pattern"
  },
  {
    "startTime": "00:18:00",
    "text": "um and there's also there was some discussions about how this could be used uh with DCR so this can be used um similarly to DCR but can may also work in conjunction with DCR um and that was one of the points that also led to one of the discussions later on because DCR is a client authentication scheme um more on that later on well um there's some question some discussion on the chat there P do you want to um kind of go off mic and ask a question here sure let me try um so thanks for this Paul I guess first question was the client back end uh is that always sort of in the same execution environment so it's always on the phone or is it sort of I guess collocated with the client front end or is there a network connection and I I just want to clarify I think there's a comment from Oliver but maybe you can just clarify that as well yeah so in the scenario that we mostly have in mind uh the the back end is um um a server that is being run by the the client so that's why we call it client back end and the Cent L instance is a native app uh that's being the front end I think that is the usual pattern that most people have in mind that want to utilize this um but you can also put this in two directions if you have um a wallet a browser wallet um basically both things are kind of a backend component or you could also run this that if you have some very high secure"
  },
  {
    "startTime": "00:20:01",
    "text": "key storage this might also work as the client back end itself in this scenario so it could also be both um Mobile on the mobile app but okay the main I think the main architecture that people have in mind is the client instance is a native app and the client back end is a server and and what is it that the backend then attests to right is it just yeah I'm I'm curious what the basis of attestation is yeah so the ideas are that you want to attest the authenticity of the client instance so that this client instance really is a front end or an instance of this client you want to attest especially this key that is running or controlled by the client instance because this enables the client instance to make the proof of possession and use and and prove the legitimate ownership of this client adastation jot to the authorization server um because this public key of the client instance key is embedded in the client attestation jot uh so you're sending the client attestation jot and the proof of possession with the key where the public key is embedded in the client attestation jot and therefore the authorization server can check that the client instance is is is making a proof possession for this client atation jot do that make it clear enough yeah that's helpful Paul and and I'm curious um"
  },
  {
    "startTime": "00:22:00",
    "text": "how do you think about authentication versus attestation in this case is that signature that's presented to the authorization Center uh server is that really an authentication event I I I I wonder if it's just a terminology thing or is that tration that's happening yeah and the I think this will also be one of the um it will be discussion number two so I I may I'll postpone the answer to this um and and we'll get into this I think it it fits very well your question later on okay thank you for clarifying yeah thanks Peter umon was in the queue is I don't see him anymore so maybe hes yeah I I want to phrase uh a few things that uh were mentioned in a slightly different way um the uh the server site is essentially is plays the role of a um it's a separate entity so you probably unless in very specific architectures you want to have that as a separate entity because it needs to um it needs to possess a couple of different information Elements which relates to Peter's questions about at at the station versus authentication um in the attestation case you want to also verify certain properties of the system uh you want to know whether it's running the software you intend uh it to run which means that you that entity needs to have information about typically hashes of software uh different layers of software from the bootload all the way up to the operating system and so on so that makes it different to authentication"
  },
  {
    "startTime": "00:24:01",
    "text": "um so in that sense it's not just a pure terminology thing where you do a find and replace of authentication with attestation but there are of course similarities uh and that brings me also to the key attestation where the important thing is not just to know to demonstrate ownership of the private key corresponding to the public key because that would would be something that you get already with a regular certificate signing request um but it's the issue is that you need to demonstrate that the key the private key is stored in in in a specific compartment on the device and is cannot be exported U there are specific terminology uh that the pkcs uh series sort of established with this like specifically pkcs1 and there's there's some text about this in a in some other documents IDF documents that uh one can reference so Hest just maybe Qui question you talked about the boot boot processes is that represented here in any form or shape in that in that attestation I like at least my understanding that's not the case right uh it's represented uh here in the in step two uh exactly uh so that would be abstracted away in this model uh so the rats architecture of course is the passport model um so this is kind of what uh Paul mentioned is outside the scope uh um and and that's fine uh different attestation Technologies exist uh that represent this stuff differently so uh let's say Android uh uses a different attestation technology than let's say TPMS and that's why okay okay"
  },
  {
    "startTime": "00:26:02",
    "text": "okay thanks helus okay I'll continue from here um let's see how an client adapation could look like uh so it's a Jason web token uh we have the issuer um which is the the client backend or in other terms in in other scenarios or like let's say like this in most scenarios the client back end is um is the is the issuer of the of the client adastation jot um and the subv value is the client ID um there may be some scenarios uh where people buy or share um an adastation service which is running this so in some circumstances the ISS and the sub value could be different but in most scenarios that we imagine the the wallet provider um speaking in Iris terms will be the one who's verifying its own um client instances um we have some validity data um and most importantly we have the CNF claim that contains the client instance key that is being attested to the client back end and this key will then later be used for the proof of possession um if you want to um add additional things that um where the where the client backend can make statements about um the authentication that the client instance did and and what uh security uh or properties it processes um the client B can add"
  },
  {
    "startTime": "00:28:01",
    "text": "additional data this is an example from the high Assurance interop profile um from open ID that's uh using this and that would make statements about the key that is being used as the client instance key um for example this is a key from strong boox and it shows what user authentication is used um with this key and um what level of assurance um an authorization server on a credential issuer could achieve by using this key um but this is then domain specific so that's why uh currently these um values are then in a profile making use of this draft this is how the communication would look like between the client instance and um the authorization server so um the token we intend to send this in the token request currently we're using the RFC 7521 framework for client assertion uh we have a client assertion type and then the a client assertion is um two jots concatenated by a tiller character the first jot is the client adastation jot um that is provided by the client back end and the second jot is the client adastation proof of possession using the key that's in the client adastation jot and then the authorization server could um read this uh validate the client attestation see that this is that he is trusting"
  },
  {
    "startTime": "00:30:01",
    "text": "this client back end that issued this and then he can check the proof of possession using the client instance key from the CNF claim in the client ad station if there's no more discussions questions to this I would um move to the discussion points that we currently have at back okay then the first discussion point that we have um has an open uh PR and has been extensively discussed also at the o o security Workshop in Rome I think um a month ago um and let's dive into this one so we got a lot of feedback um already at ITF 18 um that um there's an interesting mechanism and it may be also um usable for other endpoints for example the resource server or other things um and people may also want to use this with other client authentication mechanisms like DCR um this led to the discussion whether this should be a client assertion um and and um we came up with a proposal to move this to um a header based syntax so um moving it from the body to the headers um the changes in the pr very short I link the pr also in the slides is that um we Define two new headers are the oo client adastation header and the O client ustation pop header um we remove the usage of the"
  },
  {
    "startTime": "00:32:00",
    "text": "7521 um assertion framework for client authentication uh giving a yeah the the modified abstract of of this um I think you can read yourself but it's an extension to the O protocol which enables client instances uh to include an attestation and interactions with the authorization server or resource server so we added that one also here um this new method enables client instances involved in a client deployment that is traditionally viewed as a public client to be able to prove an attestation in order to authenticate um also it was mentioned that yeah we should Define the client instances because it's it's quite substantial to this we've seen that this is client instance already defined in the um what was it Dynamic was it in DCR defined I think so um yeah and we can have a look what this looks like so this is what the token request look like um with a new proposal using headers so the RFC framework is removed and we have two new um headers getting getting rid of some wigly also and the first one is the client adastation jot and the second one is the client adastation pop jot yeah the pr is almost done I would say so um if you have feedback for this I would um I think you need to put it in in the next in the very next days uh we're almost ready to merge this one so looking for some last minute feedback um here"
  },
  {
    "startTime": "00:34:02",
    "text": "yeah anyone has feedback on this oh Justin yeah so getting the uh attestation stuff out of the client Authentication and out of the way of client authentication I am absolutely all for uh which I've uh tried to bring up um multiple times and I'm really uh so if you're saying that this is this is the direction that we're looking to to go to merge it then I am very much in favor great anybody has a problem with this approach okay I don't see any we already had a long and Lively discussion in in um in Rome so I think we we have a lot of um consensus on this one okay so yeah even if you just want to approve um feel free to do so um to back this decision for for what uh for those who went in Rome at the workshop uh like what was the contentious or the the the discussion point on this one I think we clear a lot of misconceptions about how this relates to DCR um and we got a lot of good feedback um how this could be used in other um um at other endpoints other than the"
  },
  {
    "startTime": "00:36:01",
    "text": "authorization server um that convinced some people that uh didn't believe it was necessary um and we went through all the arguments I think the only argument that was not entirely resolved or is that like the remaining one and that's also um added as um implementation consideration is that um if the oo client adastation um contains a very long x5c chain you may run into trouble with some web servers that have limitations on HTTP header sizes um but the consensus in the group was that this is good enough and the benefits outweigh are this um consider ation and we added this as implementation consideration thanks okay then I would move to the second one this is something that has been coming up um especially from torson um is a naming discussion and this is also Peter why um I wanted to postpone this discussion um to to this one um the word attestation seems to trigger a lot of people um for example from from also from the contents of of rats um especially for rats we like due to the fact that we're coming from oo or the very fellow credential ecosystem we use some different terminology that means"
  },
  {
    "startTime": "00:38:00",
    "text": "kind of the opposite things sometimes if you compare it to Reds um so we were planning to put in some text how this relates to the the rat's vocabulary um there's an issue for that that kind of makes a mapping and we intend to put this in the introduction um there were people also at ITF 1119 that says adastation is something different um and shouldn't and should not be used in the context of idas atation is actually pretty much exactly what we're using so again it depends on on the context people have lots of different vocabulary for the same thing and they use the same thing for different things the same vocabulary for different things also um so it's yeah it's it's a bik trading discussion but it seems like a very important one to um um a number of people um so Ton's proposal was to rename this and to remove the attestation word um and there is an open issue for better naming of this draft uh issue 71 Thorson's proposal was keybound jot CL authentication um yeah maybe Peter do you want to do you want to um continue the discussion here or bring up your point again yes I was actually typing uh but I can save time and speak uh I'll finish the typing as well my perspective on this one is uh first just thinking about keys and key usage um an attestation key is a very different thing from an authentication key right and I think if the terminology leads us to be confused between those that can create problems so you know as"
  },
  {
    "startTime": "00:40:01",
    "text": "you described the diagram earlier on um that first step right where you go to that client backend to me that feels like that client back end has an attestation key right it's making some sort of a surgeon based on the properties of the client uh instance that is interacting with it but then the client uh that key that's been presented and the attestation that's been provided that key is then used in an authentication context right and I think just like this language that you have like Ton's proposal I didn't read the issue but the keybound JW client authentication to me that seems far less confusing uh and I immediately feel less anxious right uh because when I see people using attestation keys and using them for things that isn't attestation um my concern is always that there's going to be abuse of that signature so I'm kind of I'm I'm in favor of like this kind of language much more because it makes it does give me uh like it makes me feel like there's this or or it makes it clear that it's really a different purpose for which this key is used but would you agree that the client back end attests something um to the client from what you've described right and I you know it sounds like the client instance is presenting some information and the client backend then reasons over this in some way signs some ass suron uh one of things that gets signed or attested to is the key I presume there is some kind of key Providence maybe you're looking out some additional information about you know this key is generated in Hardware uh it's a specific image right the"
  },
  {
    "startTime": "00:42:00",
    "text": "software that's running the the application it's a specific image that's running Etc um and then based on that there's some kind of assertion right um now in even that may not even be an attestation right that may just be what certificate authorities do right effectively not so much issuing even an Asser or an attestation but really issuing a client Ser type uh or a client you know a token that the client can use to go and um authenticate so maybe the thing that it actually does is it issues a client um authentication credential now that I think about that yeah a for the meeting minutes um I was trying to capture sort of um whether you're in favor of what the was is proposing or you want to have something entirely different or you against it uh that I couldn't quite figure out are you're not sure yet well the key bound J client authentication I actually want to check with Paul that terminology is it is the proposal that that is used for the interaction between the client instance and the authoriz ation server or is that about the intera or is that the terminology that you want if you want to use the the terminology for that I'd say yes I think that proposal looks good but I have to go read the the I haven't read issue 71 uh but I think in terms of the yeah so so what where what does that apply to I guess is the question uh not sure if I got it correctly like our reasoning was that the client"
  },
  {
    "startTime": "00:44:00",
    "text": "backend attests that a client instance is a valid client instance right it ATT tests it in such a way that the client instance can show this attestation to a third party e the authorization server and this key calling this A keybound J client authentication is that the terminology that you're considering for when the client instance presents this proof of possession that's associated with this key to the authorization server I think that keybound do client authentication also is is not a bad name either uh and as you said it it it it depends from the Viewpoint uh because there there's basically three parties involved we have the client back end in my opinion the client back end attests the client instance if you look at the communication between the client instance and the authorization server it's definitely more about client authentication uh so I think it's just a it's just a point of view but like both are correct from my view okay but I'm still unsure right that terminology that you're proposing for which interaction is that is that for all interactions or is that only for interaction between the client instance and the authorization server you mean the terminology from torson well that's a proposal for the whole draft name we're looking how how to name like yeah maybe that wasn't clear from the slide here oh well in that case yeah I would definitely say that's a better name for the draft as"
  },
  {
    "startTime": "00:46:00",
    "text": "well okay hes no beta just asked a question I was I'm going to ask I see okay I thought I thought you have some comments okay anybody else has any thoughts on on this which which issue number was that put it into the me meeting minutes 71 issue 71 okay thanks okay then I would move to the third discussion point which is the Deep of integration um so many use cases where we intend to use yeah sorry like if you can go back to the previous one sorry I just just to make sure like you got some feedback from Peter that he's in favor of this like just wanted to to make sure uh there is a decision here or or are we making a decision here and is the the work group comfortable with this right so and anybody has an objection to keep bound jot client authentication as a name for the whole document right now right swapping that name into this one I'm not having an opposition but I would at least give Tobias the um the chance to to express his opinions on this one also okay so maybe we can always change uh like we can always change our mind but uh it's kind of uh what a working proposal and then we yeah"
  },
  {
    "startTime": "00:48:01",
    "text": "not not a big drama right yeah re question is anyone objecting or can we get more feedback yeah more feedback is always work yeah will uh people will see the the meeting minutes anyway and so on and so on so there's a lot of chance to change okay and hopefully to buyers will see it and kind of chime in on the mailing list right yeah okay perfect yeah keep going Paul thanks okay uh so discussion point three was on optional depop integration uh a lot of use cases where we expect to use this draft are for higher Assurance use cases and it is quite likely that you will use depop in these cases because you make a a lot of effort to prove that you are a legitimate uh a client and uh you probably don't use bar access tokens then um and uh most cases that this will be used people right now are expecting to use deop and um as I've said in the beginning we also have a potential to improve the security of depop um because we can make some statements in and the client adastation jot about uh the key the client instance key that's being used uh for for the pup and uh so you could use the same key um to make to use this one for for depop uh which would give better assurances actually for the depop key um and therefore if you want to do this right now you would have two proof of possessions for the same key um and therefore it was um discussed if"
  },
  {
    "startTime": "00:50:05",
    "text": "we could reuse the depop pro possession syntax um for this draft uh there's an issue 69 open for this and what this would look like um right here so this is what the current status then probably looks like if you say well you're using DP uh combined with this um basically using having two proof sessions the depot proof session here and we have the client adist station jot and then we have the client adastation Pop um for uh for this and um then both the orange part and the depot part maybe using the same key and we have to proof possessions um which might not be the nicest thing so the discussion is that optionally you could use if you use this with deop together you could um leave out the O off client adastation pop and only provide the depop um header which also works quite nice because now both things are headers um and that would yes bar you of of some complexity um yeah that is a current proposal uh which we will discuss once the header um PR is merged any feedback on this right Peter okay um so Paul I I think I gave some of this feedback in Rome as well and I'll repeat it here um it's really I I'm quite worried when we start"
  },
  {
    "startTime": "00:52:02",
    "text": "using the same key for different purposes um on the one hand you you have this let the draw authentication key right that is used to do one thing um and now when you start reusing Keys you're turning this very valuable key into a signing Oracle right because with deop who knows what what that non is it's that comes back right dep's going to let you sign nonis the authorization server hopefully you can trust it but you're you're you're turning this thing into a signing article and who knows what that signature could be misused for so I would say please don't do this um it's the sort of thing that we end up regrading later uh and there's a long history right in the world of in the cryptographic world when you start using keys for purposes that you shouldn't it opens the doors for all sorts of attacks so I really caution against it I think the other observation is given that you have this interaction with the key with this um uh what do you call it the client back end uh why not just get a second key ATT tested and use that for deop right the um it would be great to have such a high assur key available but reusing keys in this way just feels like we're going to I sort of feel like I can write the security incident right 10 years from now it starts with if only we didn't use the same key so that's my uh that's my contribution uh please consider I love that you're trying to optimize but I think we're going to regret that yeah thanks uh thanks for this"
  },
  {
    "startTime": "00:54:04",
    "text": "feedback um Ryan the just to sort of put the other perspective on what Peter just said that the what's happening here though is using the same key for effectively the same purpose the the non signing Oracle mechan m is already going to be possible first of all it it's a little suspect that that's a piece because it goes inside of an assertion or a jot that's signed with this key and it's the server to whom this is addressed that's providing that data um and the same mechanisms are going to be fully possible through the the non mechanism that's yet to be defined for um this Cent whatever we're going to call it now this client um J keybound I'm sorry JWT I've lost track of the assertion whatever this is here we already have the same thing yeah and this key is used to create proofs that go to the as not the RS but they're audienc as such I I'm not entirely sure that I got your argument Brian are you arguing that it is what Peter described is not a problem yeah or that it's overstated and that this is to I guess to Justin's Point here that this is not this is an opportunity to optimize in the case when you're already presenting a jot based proof of possession to the"
  },
  {
    "startTime": "00:56:01",
    "text": "authorization server not to have to do it twice it and it's not a requirement we've moved away from trying to make this the only way because I don't know largely due to concerns that have been expressed here but the proposal here is to allow this as an optimization of both the payload and the signing activity and so forth in the case that you want to use these mechanisms together the doop proof becomes uh can be used in place of the oo client attestation proof or whatever that will be called yeah yeah so there might be some scenarios um where maybe signing with this high security key um is a little bit more pricey uh so so that could be one argument that you maybe you want to avoid this maybe you need to make a network call or you need some expensive um Hardware Key operations then sparing improved possession is not the worst um but yeah at the same time I see Peter's concerns um not entirely sure if they are applicable okay we we just a time check here we have two and a half minutes uh so let's give people in the Q chance to talk about this but I my feeling is probably we need to discuss it in in Vancouver to this this topic Hest yeah I I'm trying to understand Peter's concerns I think uh if if I summarize it here I I think I get it is like the key with the client attestation uh is used primarily with"
  },
  {
    "startTime": "00:58:01",
    "text": "the as versus the deop key is used with the As and the RS and so if we combine the keys then suddenly the the station key would then be used with the also with the RS and that's that's obviously very different usage is that is that a fair summary what you're saying Peter yeah that's that's a that's how I understand and the risk that I see with that um and I mean even with interactions with the as I would start getting worried but the fact that you're now talking to the RS as well when you present these proofs uh you're you're turning your attestation key into a signing article to sign nonsense coming from an RS right which could be structured anyway okay thanks for the clarification okay um Paul maybe do you want to kind of wrap up here because we have one minute here and uh but I believe this this is a good discussion for Vancouver so yeah yeah so just so maybe give the Outlook in the last minute because Brian touched it all already the last discussion point was about non fetching um in the draft currently we advise to um to do replay uh protection or replay attch detection either by using jti or explicit nonsense and and we recommend nonsense that was a long discussion in open ID for VCI issues um but right now we actually don't give a mechanism how to fetch Anns and um this will be one of the next discussions as well okay awesome okay thank you Paul appreciate that let's continue that in Vancouver thank you very much thank you all right and reminder we don't have a meeting next week"
  },
  {
    "startTime": "01:00:02",
    "text": "okay bye thanks a lot bye"
  }
]
