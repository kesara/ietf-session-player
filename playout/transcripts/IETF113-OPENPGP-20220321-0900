[
  {
    "startTime": "00:00:14",
    "text": "okay i guess we're out time so good morning all this is the open pgp session of the first hybrid ietf meeting so we'll see how it goes um we have about 30 30 odd people in the session we have about a dozen in the room um so um tkg you want to say hi hello uh i'm daniel gilmour so tkg is remote uh given that this is the first session of the week in the first hybrid meeting we expect things to go weird but uh so just logistics and so on um there's a place to take notes there's jabber there's also a chat session in the the same chat session is in java and in my deco next one is yep oh oh yes sorry if you yeah if you're here um please do log into the data tracker because that signs the blue sheet is that correct thank you paul um so again yeah so if you're in person log in to the data tracker and in theory yes in theory you're supposed to join the message the mic line via the data tracker i'm not sure how well it's going to work in practice but we give it a try if it gets funny we can manage it so if you want to go to the mic the theory is if you're present in the room you should join the queue and then"
  },
  {
    "startTime": "00:02:01",
    "text": "get to them go to the mic at the relevant time in practice as paul just did uh in practice we'll see how it works um and again if you're in person then again keep your audio video off for remote participants uh hello and i hope it's all working for you um headsets are recommended as it says and i guess everybody just be patient because we're all trying to figure out new stuff um and it's the first session of the week which is the traditional session when things go wrong the note well this is an itf meeting um there's a whole bunch of things you should note well they're all up there you'll get fed up seeing this during the week i guess the only thing i'd say is in addition to that you know please read that be familiar with us if you're not get familiar with us and again be nice to each other our agenda so we're on the first point just administrative and just to see if anybody has any agenda bash to suggest then we'll have about an hour to talk about the chartered work i have a couple of just a couple of things to say about the design team that's been running and then justice if he manages to get into meat echo fine i think we'll hopefully have him present the difference between the latest draft and the previous one and then there's a few issues that the design team felt would benefit from discussion with the working group participants more broadly and then we have a couple of presentations that again the time may kind of shift if those take longer um falco is going to present some work that's starting on a post-quantum approach to pgp uh is falco in the room i'm sorry i just forget right now for if that's a remote presentation or not"
  },
  {
    "startTime": "00:04:02",
    "text": "okay when we get there we'll see falco i'm a remote you are remote okay um thanks for being here remote um mallory i'm pretty sure is remote um and it's an awful hour of the morning for her as it is for other people in her time zone um i don't see her in the room right now but it's it's a horrible time of the day uh and then aaron uh has a presentation who is his here and uh aaron hope hopefully has agreed to help us with taking notes i would like to get a second taker before we proceed the meat echo tool has a way of allowing you to take to collaborate taking notes in an ether pad like thing okay pete resnick is helping to take notes for the dispatch meeting but that just popped up on my screen so could we get somebody a second person to help with aaron take notes and if not we'll just stop here until we do okay no worries just as much okay so waiting for a notetaker get a second person in the room to help i guess that would do thank you so you know do you know how to click the button in the in if you if you're using lead echo not the site i think you have to use the click the video on to see the note taking button great thank you okay so that's our agenda i mean agenda bashing uh so in particular i guess we have on the on the agenda we have the latest id where uh i guess daniel will go through some of the changes that were made"
  },
  {
    "startTime": "00:06:01",
    "text": "uh as he does that i guess it'll be just i hope if there's any clarifying questions you ask them if there are things we want to kind of put for longer discussion later that daniel mentions during that presentation then that's a that's a reasonable option to take rather than going into too much detail immediately so basically we can take some topics in the latest idea and push them into the issues for discussion as need be okay so don't anybody remote who wants to bash the agenda now is the time to jump in the queue for that observing that it looks like this has joined okay so uh yeah great okay so just as we we can try to move over to you in a minute okay so uh yes we have been running a design team basically to try and there was a whole bunch of work done in the past before the working group was recharted so we have it was quite a bit of work to do catch up on that um the design team has a mailing list that's there the archive is public you can actually subscribe to the mailing list and receive mail and but not post um or you can see the archive those are the members there we we have uh the kind of chairs paul vader's has been helping as an editor and then a bunch of people who have pgp implementations uh which has been really helpful to try and sanity check what we're doing um i guess werner was only actively taking part for earlier meetings he just had more conflict so couldn't uh continue um we met kind of most most weeks about 29 times i think it worked well it's productive we're hoping to kind of declare victory on that process pretty soon um and ideally then have a draft that we can start a working last call on and by pretty soon i hope that's within"
  },
  {
    "startTime": "00:08:01",
    "text": "like weeks not months um and if you know as as and if the the the working group has recharted to do more work i think that that process worked kind of well so the chairs would be probably adopted again um so if we do continue and continue to do more work there will be an opportunity for people to say they'd like to help out there too and with that we move on to the current drafts now justice do you want to take control of the slide movement or would you like me to do the next slide stuff for you i i don't know how that works maybe you can drive the slides okay so uh whenever you want me to go to the next slide just tell me right so this is a brief overview of what we changed or what we are proposing to change in openptp and next slide please first of all we'd like to oh you removed the slide uh did i maybe i skipped who who read actually draft so i don't know how i get a sense of that but maybe the room can get a sense of who read the graph yes uh so who's read the current drafts oh okay i don't know if your audio can be higher or a little bit low in the room uh so i guess we can use the show of hands tool where's the bloody show hands still oh thank you dkg so again there's a there's a poll happening at the moment if you've read the drafts indicate so"
  },
  {
    "startTime": "00:10:05",
    "text": "okay so that seems to stabilize we have about eight people who are kind of up to speed in the draft and just in the room for my own sanity because i like that too how many people here i've kind of read the latest drafts four two of whom are on the designer okay okay all right so about eight uh up to speed justice next slide i guess all right yeah next slide so let's talk about the exciting changes and maybe the most important thing is aad we had aad support in the this draft but we changed that up a little and we decided to go with the version two of the side d packet rather than specifying version two of the this aad packet um because we thought it would be weird to come out with the version two packet as the first version i i get a little bit of echo from the room can you turn that down uh i i cannot sorry okay so compared to the first version of the site d packet we actually have fields on the packet that specified the cipher and aed mode and we also include a salt and then we introduced a key derivation step using hkdf and that gives us two things first it authenticates the context as in the cipher and ad mode so it provides key separation between different ciphers and aad modes to prevent downgrade attacks and the per message salt gives a simple message key so in the future if you have a open pgp message"
  },
  {
    "startTime": "00:12:00",
    "text": "you can always reply to that message by reusing the isometric key material and using a different sort next slide please so i'm going to go into a bit of detail because if you want to look at anything that we changed please look at this yeah how do i get rid of that um so we start out with the session key and that comes either from the pk esk packet asymmetrically encrypted or from an ske sk packet symmetrically encrypted and then we used that as input keying material for hkdf we get the sword from the version two side d packet and as input parameter for hkdf we use the pack attack the packet version cipher and aed mode and the chunk size and out of that we get a message key for the cipher and part of the nonce for the aed mode next slide piece so let's look at the how we use aad first we derive the message key using hkdf then it derives the leftmost parts of the nons also using hkdf and then the lower or the rightmost eight octets are big nd encounter starting from zero as additional authenticated data we use the same data as we gave to hkdf as the input parameter"
  },
  {
    "startTime": "00:14:02",
    "text": "then we do chunked aad our chunk sizes are powers of two ranging from 64 bytes to 4 megabytes a message contains at least one chunk and only the last chunk may be truncated every chunk is directly followed by an authentication tag and the last chunk is the final zero size chunk which also includes as the aad the plaintext length that's like these so here you see sample 4 and 5 messages on the left you see a version 4 message within sksk packet and notably it contains the the cipher used for the site d packet as plain text in the encrypted session scheme so the version 1 side d packet has no fields besides the version and it only knows the cipher mode to use or the cipher to use from the esk packet and in that you find a literal data packet and an mdc packet mdc packet is opt's legacy way of authenticating cypher screens in contrast to that on the right you see a v5 message where you have the cipher mode and aad mode in the safety packet as well as the chunk size and the salt"
  },
  {
    "startTime": "00:16:02",
    "text": "so the metadata is in the packet where it belongs in that you find the literal data packet and the padding packet which we will come to in a minute and previously we kind of relied on the non-malleability of the ske-sk or pksk packet to prevent cross-grade attacks in cypher or ad mode whereas in the new scheme we use hkdf products all right next next slide piece so what's the status nibir has implemented that in the branch called nupg and i've implemented that for sequoia and generated test vectors with that i can report that our support for eax is good gcm is a bit problematic and ocb is not as widely supported as we'd like because it used to be covered with patents when we look at the ecosystem we will start to think you need to start to think about a message api so if you have an open pgp message you want to be able to reply to that next slide please let's talk a little bit about packet versions and how they can be combined because we've seen that with the site d version 2 packet we moved cipher and ad mode to the to the site d packet so it no longer is in the session key"
  },
  {
    "startTime": "00:18:00",
    "text": "so obviously you can no longer use the old kind of pke sk and sksk packets with the new sight d packet so um likewise we defined a new signature type and that can only be created with a new kind of keys and that leaves the question who can use what kind of packets are features and we use the same established signaling mechanism where optp certificates can have preferences and the feature sub packet and we can advertise feature or support for the new version in the feature subject next slide please yeah so just to note on the previous one there in uh in a jabber werner just points out that uh navy's loopy g implementation is is not a uh what do you think he said that what diva did our experiments to understand the new things it's you know it's not an official implementation he just wanted to point that out i guess right so that's true all of our support is not in the main line branches yet and when i say interoperable i mean we've demonstrated that it works once um because we start with symmetric encryption let's stay with symmetric encryption for a little while because we use the same mechanism the we've seen the ske sk packet which is a symmetrically encrypted session key packet in v5 we also use aed there and we use the same scheme using hkdf to provide key separation and we change the syntax a little bit"
  },
  {
    "startTime": "00:20:04",
    "text": "and can now robustly parse this packet even if you don't understand for example an aad mode or string to key mode next slide piece and the same applies to secret key encryption so we use the same construction around hkdf and because we align the layout with the skesk metadata we can also robustly parse this packet now or secret encrypted secret keys next slide please when we look at the key material packets there is only a little change we added an octet count to the public key material and that has the advantage that given that we can that we have an e5 secret key we can convert that into a v5 public key which is needed if you if you want to compute the fingerprint because the fingerprint is only about the public key parts so you need to know how much public key material is there so that you can skip the rest next slide piece we also introduced the new version of the pkesk packet not much changed there except now there is a recipient fingerprint instead of a recipient pid and as with the sksk version 5 packet we no longer include the cipher in the encrypted session"
  },
  {
    "startTime": "00:22:02",
    "text": "next slide please we also added argon 2 id um as the new method to derive a key from a password argon 2 is specified in rc9106 it has three parameters the number of passes the degree of parallelism and the memory parameter and we expose all those parameters in opengdp and both nib and he have implemented that and who are able to exchange messages next slide please we did a bit of an update for the signature packet we notably we have a prefix salt so there is a salt parameter that is hashed as the very first thing and there are kind of three reasons for that first we defend against attacks on the hash functions collision resistance we used sha-1 for too long and saw that degenerate and adding assault actually protects against attacks against that adding a sword also helps against evil web application attacks where"
  },
  {
    "startTime": "00:24:00",
    "text": "maybe then you can say something about that and while we were specking this out there is actually another attack where this project helps against which is a concern where ed dsa is used to compute the same signature twice and in the second run there is a fault injection attack and that can lead to [Music] secret key recovery and by making sure there is thought in the signature you make pgp signatures non-deterministic so you never sign the same message twice there is a related change for the one part signature packet if you want to do a prefix salt you need to have this information early on so you need to include it in the um one pass signature packet so there is a another change we also use a fingerprint there instead of a key alright next slide piece we included a padding packet the padding packet is ignored like the marker pack packet but it can have an arbitrary length and it can appear anywhere but we give guidance for where to put the packet to increase compatibility with the legacy implementation the body of the padding package should be random to protect the padding from any compression layers um like like in the transport protocol"
  },
  {
    "startTime": "00:26:03",
    "text": "next slide please there are a number of general improvements so we defined how to use mpis multiprecision integers to encode non-integer data because modern ec algorithms um produce and operate on octet strings which are not necessarily integers we hope pgp has two ways to express packets the new and the old way where the new wave was introduced in 1998 and the old one deprecated in 1998 and we kind of uh made the next step in the deprecation process by calling the old one the legacy format and warning more sternly against it we have an intended recipient packet in in signatures so you can bind a signing context to an encryption context and this has been proposed for quite a while and we included it because it is a graphic refresh thing we changed how certificates look notably they are now valid without a user id previously certificates had to include one user id but there was no requirement on it being actually bound by signature and now we made the user id"
  },
  {
    "startTime": "00:28:00",
    "text": "optional but there is ongoing discussions and daniel will talk more about that we also switch two chains we now operate on markdown we use one sentence per line and we or the design team worked mostly in gitlab and that worked well for us we introduced a lot more tables and try to bring more structure to the text in general next slide please algorithms so for public key algorithms there is only um you have to do eddsa and dcdh you have to do ed25519 and ecdh using curve25519 that's openpgp's version of x25549 and you should implement the same using curve 448 if you look at cyphers the only mandatory to implement algorithms as128 we added the camellia ciphers and strongly deprecated idea triple death and classified the only mandatory ad mode is ocb and we also added gcm because it's a fips approved aad mode nothing really happened to the hash algorithms so chart256 is mandatory and that's also used for fingerprint calculations um md5 sha1 and drive md are strongly deprecated next slide is"
  },
  {
    "startTime": "00:30:06",
    "text": "kds and fingerprints so version five fingerprints are the output of share two and uh 32 octets and the five kids are the left most eight octets of the fingerprints this is an area where we spent a bit of time on but didn't really make any progress the worry is that the fingerprints will be very long and even less ergonomic than the four fingerprints with the we don't really have a solution for that but [Music] the the consensus is don't display fingerprints to use those next slide piece and with that let's talk more about areas where we are working on or need guidance or want to open up the discussion yeah so let's um so i think diana's going to start with that but let's first see are there any topics that have come up that people wanted to talk to on this and i think there certainly is one that verner raised about aad so werner do you want to jump in the mic line or just send audio yeah hello so hey um well i have some concerns so let me quickly uh um tell a bit about the history so in uh i think it was in summer in summer or late late summer i dropped out of the design team um because uh for one um i had some time resource problems and technically um we have finished all"
  },
  {
    "startTime": "00:32:02",
    "text": "the uh critical the critical um questions why this design team had had been set up then and so everything was was fine at that point at that point and only a few things had to be done for example for example uh mpi easy how to describe the parameters in a bit in a better way and so on and some change some wording and these well more editorial things um and things what i've now seen is that there are large change large changes changes which um yeah so in 2018 in january 2018 four years ago four years ago we have started to deploy deploy aaid because on an internal agreement in the in the working group that this is the way we are going with aed and this has been overthrown by this new ide that's not good that is bad for the reputation of openpgp because it's not reliable cannot be seen as a reliable working working group if things like this um happen these are my main concerns uh having gcm is bad but i suggested that anyway um because of uh getting the certifications well and there is currently no way to have ocd in in flips and also not in the next few years okay that's for me so let me see if i can just understand the concern correctly there um you so your main concern is that the the current draft specifies aed in a way that differs from the deployed implementation in canoe pgs is that the main concern are in blue including and in rnp and we did inter-operate testing on we"
  },
  {
    "startTime": "00:34:02",
    "text": "had we had in the working group we had we had content that that this is the way to uh to go and this so this is the reason why it has been impla it has been implemented uh now last summer things seem to have changed then in particular after i dropped out of the design team if i knew about that so i would not have dropped all of that okay let's not worry too much about the who and when i think it's more interesting the you know the what and you know the output of the design team is input to the working group so if there's things that need changing or fixing that's that's perfectly normal um so i'm trying to understand can you be a little bit more specific as to where in the current draft needs fixing from your point of view well you you added new packets uh deprecate duplicated the old aid packets changed and changed the entire structure are so in particular it's about aeid which is was one of the main goals which have been chartered are here and that's that's a real concern also adding a new um new kd kdf is also not a good idea um from the mentor's view adding complexity so i see daniel in the queue you i guess you get to stand at the microphone even daniel does this thing work uh can can remote people hear daniel from the room no does it work like this can you hear me well okay good yeah so um i think some of the changes that were made um to aad were a result of"
  },
  {
    "startTime": "00:36:01",
    "text": "and i i thought i would just comment since uh that was partially my proposal um so there there was an attack that lara brisagini who is one of my colleagues pointed out which is when you have a gcm encrypted message you can do a downgrade attack by converting it into um a message that claims to be cfb encrypted given that cfp and gcm are very similar modes [Music] you can then sometimes even successfully decrypt the message as cfp if there is a broken implementation of mdc which has happened in the past this can [Applause] lead to a decryption article or rather if there is a decryption article in cfb you then also have a decryption article in gcm so the the concern was that if you can convert a message between different modes also you know cross-grade attacks between different aad modes even though we're not aware of any they might happen in the future so this is the main reason why we added key separation and um eight and adding an hkdf was the method we landed on uh in the design team in the end there are other possibilities such as putting the aad mode inside the encrypted uh public key encrypted session key packet or the secret key encrypted session key packet"
  },
  {
    "startTime": "00:38:00",
    "text": "um i mean yeah i don't know how much you want me to go into the details but this is mainly the reason that many of those changes were made was a result of adding gcm which in turn was a result of wanting to um add a fips mode uh if that makes sense so i saw dkg briefly in the queue then jumped out but vernon i think you should feel free to respond there too if you wish um well okay so the better solution is not to have a way out to choose an algorithm so um now without without the pattern problem problems in ocb i would suggest to drop everything else and use only ocb and nothing nothing else and then better wait for for fips are to get straight and allows it i can't see that right now but i've i've seen that the brain build curves are also or will also go into flips so um there's there is a possibility to have lift and fibs in some time so again just so i understand you're suggesting to kind of revert this change and on the basis that ocb doesn't have the attack problem that daniel just mentioned yeah that that's right it's um that's one reason and it is in general better not to have not to have a way to choose between algorithms and we know that ocp is a good algorithm uh i can't see that there will be any reason to replace it they may and um as we talk about this gcm gcm has still a lot of problems um so okay put another packet into if you if they really want want to do this as an"
  },
  {
    "startTime": "00:40:00",
    "text": "optional thing to have gcm with a id but for everything else for everything else we could just live with cf with cfb plus are one thing um which is also a solid way of of authenticated encryption also not standardized but this works and it can be flips approved be fips approved can be a part of fibs approved implementation okay and do we have other people want to talk at this time dkg i think you're are you in the queue you are yeah yeah i was in the queue earlier but i think uh daniel wiggins said what i was gonna say about the the cryptographic justification for including that um i want to say i i think i um agree with werner's general sense that fewer options is better but i just want to know that that would itself be a major change from the draft that existed as of 4 years ago so you know no matter what any of the approaches either the one that's currently in the draft or the one that verner is proposing would indeed be different from the thing that we never managed to get out the door this person would never manage to get out the door originally so you know the the changes that we're seeing are a result of additional grip analysis thank you to lara who daniel mentioned and potential changes in the environment around cryptographic algorithms verner you mentioned changes to the asymmetric choices available for fips my understanding is that chips has no current plans to review uh symmetric cipher modes i would love it if they did but we're not working in that world right now and so these choices i think are the product of sort of where the world's at the moment um to try to ensure that that open pgp has a robust mechanism going forward both for people who require fit compliance um and not"
  },
  {
    "startTime": "00:42:01",
    "text": "okay um do we have other people want to chime in on this topic so would we again just try and clarify my understanding of this would it be fair to characterize this as verner as you're saying that ocd is good enough and we while we might want the ability to support different cryptographic algorithms having the same level of flexibility for modes is something you don't think we need uh yes that's right we put eax into it and they choose up modes um just because some folks uh had problems with the pattern status of oc ocp but uh as i said back five year five years ago was there well about this time of the pattern the plan and we have expired and we are now at that point and uh for uh or phil even uh dropped paying the fees for for the patent yeah okay um so i guess i'm thinking what's the best way to kind of try and figure this out is has anybody got a suggestion for the best way to resolve this to maybe would somebody be willing to create a merge request for the gitlab repo that would allow people to see the effect of change or is that just too much work i i'd have to look at i'm looking at paulie as the editor no i'm not asking you to make the merge request i'm just asking would it be a lot of work to make the merge requests reflecting what brenner is talking about i'm not sure if i'm in the queue now you're in the queue now it's another screen so i'm not sure if the audio is on but yes now the room audio is going okay great okay i just want to make quite like i think this is an item for discussion before we do a merge request because okay it's like we don't need the exact text right right now it's the issue that"
  },
  {
    "startTime": "00:44:00",
    "text": "we need to understand better whether we want to go with option a or b i don't think presenting text will add clarification to the discussion at this point fair enough since you're since you've been in the editing i bow to your knowledge so so is the right outcome here just for the chairs to start a thread on the mailing lists to see do we prefer what's in zero five or do we prefer uh what verner is kind of proposing i'll try and burn it out i might drop uma and see if i can properly characterize what you're saying and then start a thread on the mailing list does that sound like a reasonable way to proceed yeah okay uh vernon says okay just as i had okay so i guess if the people taking notes would just make sure that there's an action on the chairs to check with werner and create that thread on the list okay any other topics on the current text or draft five that people would like to raise for discussion just now that are not going to be covered in this other list on the screen not seeing anything anybody in the room anybody in the queue no okay in that case daniel do you want to jump up and i think the right apparently the the box here is where you should be it's got the box has gotten smaller since the last in-person itf very specific so does this work as well i guess i'll assume it does until people complain um okay so as um eustace uh hinted that there has been uh some discussion and uh also some proposals within um the design team about how to structure a"
  },
  {
    "startTime": "00:46:01",
    "text": "a public key or a certificate um what elements to have there um so i'll i'll talk a bit about that next slide please can i also do so oh uh i'll try here no no it's not there no no you have to ask me okay does that thing work no okay all right um so yeah just to um summarize the the current situation um there is this uh convention let's say uh in open pgp to require a self-signed user id where you also store various properties about the key uh such as the expiration date the algorithm preferences um etc um and um the there there are some use cases um for not having a user id um for example [Music] you're talking about for example uh case.openphp.org has been publishing keys without the user id when the user id has not been verified yet um thank you um in addition to that um we at protomail also would like to publish keys without a user id in order not to reveal personal data for example if it contains their full name and people import their key they might"
  },
  {
    "startTime": "00:48:00",
    "text": "not expect us to publish it and in addition to that uh we have been getting some attacks let's say where uh people try to enumerate um protomail addresses via wkd for example so we would like to hide whether a certain email address exists or not for also for privacy reasons and again this is easier if um if there's no user id in the key um because the the user id might contain uh you know very specific details that make it obvious that it's not an auto generated key for example um next type please yeah so um rfc480 the the preview or the current let's say open pgp rfc required a user id but does not require a self signature as users also said but by convention let's say some implementations did in fact require a cell signature which has some advantages um such as being able to express an expiration date without an attacker being able to remove the self signature for example um since that would invalidate the key but this this has not been documented in the spec um the crypto refresh goes in the other direction by also not requiring a user id so there has been some discussion about do we need to uh require for example"
  },
  {
    "startTime": "00:50:00",
    "text": "um a direct key cell uh self signature to replace this self signature um but yeah next slide please so uh before i get to that indeed um first the question is do we need a user id um so um [Music] when encrypting to a key you might think that you want a user id to know whether you're encrypting to the correct key um but i would argue that you anyway need a separate mechanism to verify that either you get the key from wkd and therefore you trust that the key belongs to a certain email address or you get it from a key server and it also has some third-party signatures if you like the web of trust model or there's also a proposal for key transparency which aaron will be presenting about later or you can you know verify the fingerprint in person uh or you know call them up and say hey is this the correct key in any case just trusting the user id is not sufficient because anybody can generate a key with any user id they like for the second point when verifying a signature using a key um it's a bit more tenuous because you might argue that uh you want to know that um the the key owner uh claims to be that person that you think is is sending you a message for example otherwise in theory someone else could steal a public key"
  },
  {
    "startTime": "00:52:01",
    "text": "and a signature and send you an email um and and pretend that uh you know they they signed it and they came up with it i mean you might argue about whether this uh this is even a valid attack since they can also just you know sign the same data but okay another solution would to this would be signing the email headers or you know repurposing the the signups user id subpacket even if you don't have a user id in the key and finally you might argue it can catch some mistakes uh if you have a user id for example if you upload the wrong key to wkd then you know the sender can notice that they're using the wrong key but in general there are not many um let's say cryptographic reasons for uh having a user id i would argue next at least then to the question of do we need a self signature um [Music] i i would argue yes we do need it because if you have if you generate a key for example which says i prefer as256 and then an attacker removes the signature then an implementation can only assume that you support as128 because uh you know that's the only mandatory to implement algorithm and so you know there's a downgrade attack there of course you might argue then why don't we make as256 mandatory to implement uh but in the future the the same argument still goes if you know uh a stronger algorithm"
  },
  {
    "startTime": "00:54:01",
    "text": "or mode um is is added to the spec we might want some robust mechanism for signal signaling support for that um to prevent downgrade attacks um and similarly if you generate a key with an expiration date of one year for example in the future then an attacker can't remove the signature and remove the expiration date if you uh require um having a self signature in order to use the key as you know some current implementations uh do require but uh you know it's not written anywhere in the spec so the question here is should we write that in spec and if so should it be the the user id self signature as it is today or as an alternative proposal should it be a direct key signature next slide please yeah so here is a let's say a tentative proposal it's it's not even uh there's no merch request for this um yet but um this is just uh a proposal for discussion here so the proposal would be make user ids completely optional also make a user id self signatures optional as the current draft indeed does but then require a direct key self signature in order to have a place to store key expiration dates and preferences that can't be removed and then if we care about sender identity sign it as part of the message for example in the email headers"
  },
  {
    "startTime": "00:56:01",
    "text": "then um you know um yeah everybody can uh look at the direct key signature uh for the for the key properties you know this would simplify what a certificate let's say looks like in openpgp and simplify usage but with some potential downsides if we care about um for example user id specific uh preferences um so you know that's that's part of the topic for discussion uh next type please um hang on a second daniel can you just um can you just go back to that proposal i just wanted i think it might be missing some context um is this for all openpgp certificates or just for certificates with a v5 public key right exactly that's a very good point yeah so this will be for v5 keys and indeed that's also part of the reason why we're discussing this now um is even even though you might question is this even uh in charger right is this even relevant for the charter of the crypto refresh and uh certainly the answer might be no even though some of these parts are um let's say crypto adjacent um but uh since we're releasing v5 keys now um it might be a very good opportunity to say okay we make a clean break uh v4 keys had this convention and v5 keys um you know look differently and we kind of have a more uh strict and more clearly defined uh certificate structure uh going forward yeah thanks for that point um so yeah the the questions uh to the"
  },
  {
    "startTime": "00:58:01",
    "text": "working group um are yeah first of all you need or is this even in charter do we want to solve this problem let's say of course the the status quo is that you know we have some convention that is not documented that requires implementations more or less to generate a user id with a self signature even though the spec doesn't say so and i would say my worry is that you know if we don't do anything then probably that convention will stay for v5 keys as as a sort of default um and then we still have this undocumented convention another option might be we we document the convention but we don't do anything else or another option is we try to change the the the convention or rather the the practice uh by documenting some uh alternative certificate structure that we prefer and so yeah some of some of this is crypto adjacent um such as the algorithm preferences so you might argue that it's in charger some of it certainly is not i mean as i said v5 keys are a nice opportunity to fix all of this but certainly also uh you might argue that it's uh it's not in charter and that we should uh fix it in in v6 or or whenever then the second question is do we care about user id specific preferences because so the the tentative proposal would be to only look at uh direct key signatures uh for preferences and expiration dates etc um just to make"
  },
  {
    "startTime": "01:00:01",
    "text": "implementations simpler and make make openpcp simpler certainly a criticism has been that openpgp is too complex and um that you know there are too many differences in what implementations do and um certainly i think it would be good to simplify things um but you might argue that you know if you have a key that you use both at home and at work you might have different preferences for the algorithms that you want to use on those computers i would argue that you probably should generate a separate key in that case but again yeah this is a definitely a topic for discussion and then the final question is do we care about situation situations where you typically don't include the sender in a signed message uh do we care about someone else stealing uh the public key uh and the signature you might argue no we don't care about it because you know someone can just steal the data and sign it themselves so perhaps it's not relevant if we do care about it we could use the signer's user id um yeah those are mainly the the three topics um i had in mind for discussion but if anybody else has any any other concerns or questions then of course feel free to bring them up okay so just if people want to talk onto this then jumping in the queue now is the right thing to do um just to summarize then you have the you know the tentative proposal was applying to v5 public keys yes and the defaults"
  },
  {
    "startTime": "01:02:01",
    "text": "if we can't figure it out the default is kind of just stick with what we have i would assume so yeah okay um and i guess yeah the reason for raising this is that the design team weren't kind of sure what people really wanted bkg hi there um i'm just speaking with no hats on here um as a implementer and maintainer um the complexity of per user id preferences is a lot and i really like the proposal that's on the table here for the sake of simplicity of understanding i think there's a lot of room for there's even with this proposal there's a lot of room for potential misunderstanding of open pgp preferences but the idea of dropping user id specific preferences is very appealing to me from a simplicity perspective and i've never actually seen a scenario where i've found the user id preferences were particularly um desired or desirable or reliable so i you know if this is this is simpler and cleaner so i i'm a fan i'm in favor of it okay are there opinions i i mean i guess i can paraphrase werner from the jabra i'm guessing he's kind of not in favor our favorite the status quo i think is what perhaps he did raise the point that hadn't been raised but i think i guess derek atkins had a use case where there was no room for user ids and that's that was other than that i think werner would argue that they should be a must um i see so that's that's another argument and again if you want to jump in and send audio that's fine to do it um yes go ahead yes"
  },
  {
    "startTime": "01:04:00",
    "text": "we had one idea one idea um on where there was no requirement uh requirement for the for the user user id and that was ex particularly to eric uh derek atkins uh requirement so he put it he put it in and this was just a discussion thing and uh later i think he retracted this that it's not really needed and i think basically he could have lived without uh are being 100 compliant with your pgp specs so i i don't know what what what the outcome of this project so it's couple of years now that happened yeah so maybe just to point out even rfc 480 even though it did indeed require a user id packet didn't require a self signature on the user id packet which i mean if you have a user id packet without a self signature it doesn't um really add much i would argue of course implementations um require the user id uh self segment or some implementations required it so i mean certainly another direction we could go is to put that in the spec right require a user id and require a user id self signature if we think we need them but um i i don't know if you have a specific argument warner for what whether we need them or what's your opinion on that uh so yeah so in the java chat he did raise a couple of reasons why he thinks that they're they're needed um and then most recently about a pgp 263 ia requiring whatever so i i think the action on this we're not getting too much more information here in the room"
  },
  {
    "startTime": "01:06:00",
    "text": "so i think the action on this is again to create a thread on the on the list okay um and i guess the choices are this tentative proposal or the status quo and if the status quo we might want to document it a little bit better than previously was the case yeah uh either documenting the cisco or even requiring the status quo in the document could be an option okay so okay so i think that that's a reasonable outcome for that one paul do you want to take the next topic or do you want me to i made the slide but you raised the topic so uh so to paraphrase the issue here is that the problem is that when people are checking each other's key um the minimum security requirements to do this securely is more than the vast majority of humans are willing to invest to do this process and we haven't really come up with a solution and we don't really know what to do but that is really the problem uh or we came up with too many solutions none of which worked no because all the solutions either require either don't require enough work by the human and are therefore insecure or requires so much work from the humans that they won't do it which makes it insecure that's what i kind of meant by don't work so so yeah so so we discussed this a couple of times so we couldn't really come to something of a solution so we definitely need working group and boot from this so tkg you're in line yeah i think you could provide a little bit more color uh for this problem um i don't think there's any uh concerns within the working group about the on the wire use of the fingerprint"
  },
  {
    "startTime": "01:08:02",
    "text": "and for the changes that have been made in the crypto refresh document there's no place in the modern formats where the key id itself is used on the wire or in calculations the full fingerprint is always used um you know for people who are interacting with v4 you know rfc 4880 compliant clients of course we can't avoid the eight octet pid because that is baked into the v4 pkesk packet but otherwise on the wire we're just talking about full fingerprints and that's not an issue the issue here is for the scenarios like paul said where humans are in the loop for verifying a primary key martin hey so i'm martin arts i work for the dutch cyber security center and i have a question around this uh topic for this question so if you say don't recommend any specific form uh would the implementers represent the design team expect there to be multiple competing perhaps or different implementations surfacing in the user interface because i think well at least our experience has been that it's been hard enough to get people to use pgp in general so i was wondering what your thoughts are on the effect of this status quo or recommendation so we agreed that the effect would be bad because there would be no universal way in which humans would actually be able to verify their keys so we're not saying that's a good solution at all but we just can't come up with anything that was acceptable"
  },
  {
    "startTime": "01:10:02",
    "text": "so yeah i understood that i was just wondering if uh in a dash in addition to not having a good solution having multiple bad ones would be one step worse yeah and i don't know but i was just wondering it's given this recommendation what implementers would choose to do uh and whether having them make different choices based on the uh so so you're right and all of this came up in these discussions and but we just couldn't come to an actual solution i'm afraid i don't have anything useful to complete other than raising this question sorry take too much time though because although i don't see mallory in in the so we may have a bit of extra time so go ahead yeah just to say so just for the for the uh recording if you stay here said your name before yes so this is daniel hilkins again um so my position on this is that we shouldn't show fingerprints to the user and we should uh come up with something else entirely which could look something like you know showing a qr code in order to make it easier to verify that you're using the the correct key of course it's not a suitable solution in every scenario but i think in my opinion it would be valuable for this working group or a separate effort to look into solutions like that and that that's sort of indeed why i would"
  },
  {
    "startTime": "01:12:00",
    "text": "prefer not to put a solution not to put the suboptimal solution in in the spec now um in order to you know keep room to uh think about the um the problem more broadly if that makes sense so we have uh mallory um yeah i just wanted to follow on actually from that comment mine is very similar which is i think their important user experience or user interface for this it might be very worthwhile looking at messaging and direct messaging implementations of encryption because users are already being trained there and following on from what the what users expect actually might get you the most even if it's not a perfect solution it will achieve i think harmony with again good user behavior and that verification actually happens so what i'm seeing in signal and other places is actually a long fingerprint in addition to a qr code but that long fingerprint is visible so you're saying that they're using the full length hash output as the only non-qr code fingerprints in various instant messaging things but i presume they're all doing it differently or with different inputs as well right yeah i mean i'm suggesting actually uh looking through um all the primary messaging i mean i think that that was probably the largest in terms of user um base so coming up with a sort of survey of all of the larger ones and figuring out a solution that aligns with that because this is a youth experience question"
  },
  {
    "startTime": "01:14:01",
    "text": "um i think that um martin yeah so this is martin again um so i didn't consider point daniel just made and i think that makes sense to me that if if there's no if this is out of scope for the current effort and the solution would be something that needs more work separately and i can understand why you would not make a choice here it's just well the point i raised was made so yeah thanks okay so from okay so i think the would it be fair to say that the sense here is that to be able to be confirmed on the mailing list is that the the suggestion of the design team to not recommend a specific form is maybe the closest we've still got and but it would be worth looking at say what is the messaging apps and someone are doing since anything anything better might just exist so um this does require that there's either a recharging or continuation where we pick up that work right because it's currently not in charter but well so not recommending a particular form is just clarify that's just adding some but if we're not recommending anything and we might not read charter then we have the worst solution of all one would yeah i i would like to see this working group reach harder to take on this topic but i can't yeah i can't you know just click a finger and make that happen no i understand i'm just saying that there's there's a dependency here i think there's a there's a less optimal outcome possible here but i i don't think i would argue against making it a dependency that we try to recharter before we finish this work"
  },
  {
    "startTime": "01:16:00",
    "text": "so as far as being in scope um you know security area ads we'd be happy to receive some guidance on that um paul obviously you're you're uh potentially one of those um but the current charter might have it be in scope to say when presenting this to humans we believe that x number of bits of the fingerprint are are sufficient for human verification or something along those lines even if we don't specify how to present those to the user right because there is still this you know historically people have used the short pid which is just four octets which we know to be uh insufficient right so there is a question about cryptographic usage here that might be in charter even if we don't get to the human representation just wanted to point that out roman hi everyone i just pulled out hop on the mic and i just cut the non-existent view uh with my ad prerogative uh so just to clarify two things but first procedurally uh paul uh paul and i have been splitting up the working groups and i'm gonna be the responsible for for for this working group so they're going to be seeing more of me uh and to repeat what i said in chat i don't actually know the answer and i would like to be very decisive in this meeting to help the discussion but i'm just not up to speed on where we are with the working group to make a call here so i i want us to continue the technical conversations but i would like to defer the in-scope at a scope decision uh until a later point so i can have a chance to to speak with the working group chairs and figure something out thanks thank you okay so so right again i i so i think what we come down to is the you know it's not a good position it'll be great if the working group recharges later on to try to figure out a better answer uh meantime i think we can"
  },
  {
    "startTime": "01:18:02",
    "text": "we could document some of the security issues around people using shorter ids and maybe what we don't have an ideal solution to recommend which is roughly what's on the slide and was that our last one okay dkg you had one more topic yes um sorry i'm not showing video just because uh my laptop will overheat if i do um so one of the things that's come up that is uh pending a potential change to the draft is to sort of um mr rhett khan shah won when i say retcon that's a term from like uh i don't know online fandom where people talk about a storyline that has been changed retroactively to mean something else um so we all know that shot one is on the way out we would love to see it removed but as long as we have version four public keys in open tgp sha-1 will be part of open ppp as long as we have version one safety packets shot one will be part of open pgp um because it's used in the mdc packet there it may be legitimate to use in those places but it still seems potentially problematic because we know that there are collisions and we don't know what else is going to go wrong and so the thought was that we might specify in the draft that everywhere that sha-1 is used uh should use something like sha-1 collision detection and there's some links on the slide here if you're interested in learning more about this it's not exactly a fully specified center but basically it says we can detect known mechanisms for collision creation and when those happen you can either create a explicit failure right there's no such digest for this input stream um or you can return a subtly different"
  },
  {
    "startTime": "01:20:00",
    "text": "result which would make implementations potentially break and make collisions not uh collide so we can in the draft say hey in the cases where you still have to use sha-1 we recommend using sha-1 cd or some similar variation to avoid the known collision uh attacks on shot one i just wanted to flag that that's there it should have no effect for people operating over legitimate data and it will just make a noisy uh failure for implementations that end up having tackle data that's potentially made from one of the collision attacks that we know about great thanks so i does anybody want to speak to you know liking or disliking this idea or to yeah we see i see a thumbs up in the in the room um i guess that we should just raise this as a thread on the mailing list and say do people want to go this way and if they do then we can figure a text yeah and nobody disagree okay i think that's yeah that the action is to create a thread for about this okay so then the last slide uh before we move on to the other presentations is we'd like yeah again the design team we've been kind of operating well also our editor has gone off to become a security area director which is a you know unfortunate future for him but um but we can we won't be able to expect as many cycles from paul even though it's it's relatively it's relatively straightforward to push buttons but nonetheless it requires a bit of thought um so we would like to try and get this finished pretty quickly um there's not many remaining merge requests in the github gitlab repo there are tons of issues um but not all of which are amenable to being represented or not all"
  },
  {
    "startTime": "01:22:00",
    "text": "of which are in charter so we'd like to the chairs i think would like to to try and get to a get some implementation experience with zero five and then probably have another draft at least that uh we think would be ready for working group last call so the issues we called it for resolving today we'd like to do those as part of that i'll ask people to implement things and check it out that's i think our plan for the next steps any input on that nobody thinks it's crazy um and then what you know i think once we get a working group last call started uh i think it might yeah depending on if that doesn't far you know fall down in flames then i think it might be time to think about recharging but let's not do that till we have a document that's a working group last call at least and with that that's our current status and back to agenda um so i think the next we have presents where's the agenda me there's teaching oh there's the agenda there we go okay so now we have uh falco then mallory and then aaron and we're we have 35 minutes so i guess you know if you guys could be a little bit quick that would be appreciated so falco did you want to drive the slides or did you want me to i can't okay well i should stop sharing and you need to hit the share slides share pre-doted slides button and you'll find your deck as one of the options i have to upload it first yeah no i've already uploaded them okay so if you click on the share pre-loaded slides button rather than sharing a screen ah"
  },
  {
    "startTime": "01:24:01",
    "text": "i see slight circumstance no yeah maybe you share them i don't figure it out something well i think that's me okay so just say when you're not the next slide okay yeah thank you so yeah my name is fargo schlensky i'm presenting uh to your project which um should be of interest to the working group because it's um uh one of its uh aspects is that we're going to do standardization efforts and for post-quantum cryptography in open pgp so this project is contracted out by the german federal office for information security on the side of the bsi on on the side of the bsi stavros is leading the project on the side of the contractor mdg together with the technical university of eindhoven i'm the project manager so next slide please the background is um yeah as i said it's contracted out by the bsi in order to progress on the post-quantum standardization the timeline is uh we start at end of last year and it goes for three years till the end of 2024 so we are doing uh we're going to do standardization um so i'm speaking and you have to understand i'm speaking in from the perspective of the project what are actually going to happen in the working group that's not our influence of course but we have this this job to do um to do uh to drive forward the standardization of post-quantum schemes based on the selection by nist that we are waiting now anytime"
  },
  {
    "startTime": "01:26:01",
    "text": "and also do proof of concept implementations we are aiming at multi-algorithm um [Music] key encapsulation methods and signature here for the implementation it will be lattice-based we'll implement it in thunderbird via rnp and botan is the cryptographic library but we'll also make implementations in gnupg and libgrypt next slide please so and for the motivation why do i address it now uh already so that's the well-known problem for the crypt for for public encryption the store now decrypt later which people might be facing today in certain applications but also for signatures we have some applications where signatures cannot be redone efficiently so the long-term security for signatures is also required and we are observing that post quantum cryptography is already entering generally already entering the standardization phase now so this contest is coming to an end and other standardization efforts which i will address in the next slide also in progress demand for pqc is observed in the field maybe not like it's people want to use it now but they are preparing for it i think and the demand will grow as soon as standards are there and the integration has started also in protocols next slide please so this is just some examples of uh drafts uh i don't think we have to go into everything in detail some rfcs already based especially in the context of the firmware update the conscious binary"
  },
  {
    "startTime": "01:28:00",
    "text": "object representation and yeah lamps is considering to adopt a number of drafts around coast post quantum key signatures and encryption binary data formats there's also a draft for for the icon1 encoding for hash b hash based schemes and etsy iso also have the activities publishing documents on this giving recommendations already so everybody has it on the screen so this just says a bit of more background summary for for the motivation okay next slide please maybe one more slide please i'll reverse the order here so the design criteria just as a summary we we are only starting now we don't have any content to to present now what we are going to do but the aim is of course not only to have pqc but to have this what is sometimes referred to as hybrid but more accurately probably as multi-algorithm scheme so we want to be able to have keys different keys which is of course already possible in an open pgp certificate so you can decrypt encrypt keys uh encrypt messages with multiple keys of a recipient you can perform signatures with multiple of your own keys and so in order to provide this fallback if the new pqc screams turn out new pcc schemes turn out to be um not as secure as expected we want to orient towards existing proposals standards as far as they exist"
  },
  {
    "startTime": "01:30:00",
    "text": "and that makes sense for open pgp and we also aim at backward compatibility so for the key formats and the signature formats especially where it's possible where it should be possible we want uh the new formats to be ideally processable by uh existing implementations that don't support the new pqc standard okay one slide back please so the timeline here and the the whole project plan and a very brief summary we are now entering the phase where we make the design a proposed design also more or less in parallel proof of concept implementation we target to produce a first draft version in the last quarter of this year towards the end of this year but in general our standardization efforts last until the the end of the project which should very well cover the this standardization phase which as they announced is this announced it as i understood it should last until the end of 2023 so by then we should have the standards only by then of course it makes really sense to finish the um the open picture piece standard as well um but there are many things there there are not many things uh that will be that are left open now i i would say more or less it's the parameters nist will have to specify maybe the apis as far as that is relevant but otherwise of course it's possible to already start with many specifications at this stage already"
  },
  {
    "startTime": "01:32:00",
    "text": "okay then uh next slide please yeah then uh of course the most important aspect and this is why we're pre presenting here is that we of course seek the cooperation with the working group we are well aware that there is no charter for this currently but in any case as i said it's a project it has a timeline we have work packages we'll do these things and the more we have cooperation with a working group the more i think of course this project will benefit so we are open for any kind of input or contribution and yeah currently our plan is to work on a draft which is hopefully later adopted by the working group that is from my side thank you for your attention thank you for this opportunity to present the project here uh yeah and i'll be happy or we'll be happy to answer any questions you might have great thanks michael um florence hi i'm flo uk ncsc um i was wondering if you'd given any thought to algorithms yet beyond um beyond lattices um also thanks was really interesting presentation um yet regarding the algorithm choice for standardization we plan to orient towards the next decision so basically we would like to standardize all or consider all the missed schemes that are selected for standardization also for standardization in openpgp it's only that the implementation that we make in the project is restricted to the subset of"
  },
  {
    "startTime": "01:34:03",
    "text": "one encryption scheme and one signature scheme there's of course an interest of us that there are other contributions in all these efforts that hopefully there is some some more contributions of implementations maybe of the other schemes as there are already existing implementations of all schemes that shouldn't be too difficult to to have a proof of concept implementation of each but yeah this is something that would require more um cooperation with other people thanks very much thank you i can also open my camera i totally forgot and also at protonmail we are now trying to consider an experimental implementation of post-quantum cryptography and we have looked at the schemes he also proposed on the on the mailing list they they look practical and convenient and we have already we're starting on right now onto um let's say uh proof of concept implementation as well we would like to let's say have a chat and probably interrupt like develop something that is interoperable probably yeah yeah oh very good yeah then we should get into contact yeah okay great thanks thank you for the presentation yeah thanks falco uh so i guess this would be definitely one to consider at rechartering time so [Music] okay i don't see anything else in the queue so uh mallory if you'd like to jump in do you want us do you want to you want me to share the slides for you or do you want to do it you're doing it yourself i think i can manage"
  },
  {
    "startTime": "01:36:20",
    "text": "i'm not sure if you have to approve my request you want me to do should i do them from here um i've requested oh sorry yes i have to click yes yes i do okay great it doesn't like that um for the sake of time maybe you should oh right oh i think that that's me doing it now that's fine i appreciate it all right hi everyone um so um i'm mallory notal i'm one of the authors on this draft um the it's a definition for end-to-end encryption and uh next slide um i wrote it with a few other folks um that you'll see here i'm not sure if any of them are in this meeting but if you are feel free to jump in um or correct me in the chat things like that don't see anyone i don't see them either that's fine um next slide so the goal is really quite straightforward it's just a definition of um into encrypted um systems and encrypted communications you know that that second part um is swapped around throughout the draft but really yeah that that's the it's really intended to be very straightforward uh next slide um so why we're presenting it here um so the history of the draft the first version we were working on in"
  },
  {
    "startTime": "01:38:01",
    "text": "messaging layer security um but when we discussed it folks made the keen observation that this would apply to other working groups in the ietf and so it probably should be dispatched we did that and the the outcome of that session was the security area directors are really kind to give us a mailing list to work on this draft so you can now review the draft at e2e ietf.org there's been a little bit of discussion there we got new issues out of out of those discussions um but then in needing to progress it i think it does also make sense to um for me to come to you to the working groups that this actually might affect um and ask for reviews so that's what i'm doing now um i don't know that that this should be adopted necessarily in any of these working groups but um more abuse is always required so uh next slide please to get more into the substance now um the outcomes that we're hoping for with this draft um is that it makes it more difficult to call things into inter-encrypted when they really aren't and actually we do see this tendency maybe it's not so much in engineering spaces like the ietf but you know encryption um has landed in the mainstream and the more public discussion about user expectations on the internet and apps they use and we are seeing a tendency for that public discussion to discuss things that are not actually indian encryption as if they are it would be very useful then to have sort of a plain language explanation of what intent encryption is from an authority like the ietf so that's the first outcome um"
  },
  {
    "startTime": "01:40:00",
    "text": "i think it might also be useful and this is a question i guess through the group to put sort of definitional text in one draft so that it doesn't make your other drafts very long and you don't have to worry about being really specific what you mean when you invoke things like deniability or other kinds of concepts related to this um and then the last one um is maybe a goal i'm not sure this is maybe a question for those sort of working across these spaces in the ietf so area directors essentially but like you know if there's a possible goal or if it is a desirable thing to try to harmonize a sort of norms or principles driven approach to um encryption in particular although transport encryption might also have some overlap there so those are the three outcomes there may be more those are the ones we articulated when we are initiating this work next slide please um the the also an important approach that we wanted to be clear about from the beginning is that we didn't want to write a draft that explained what end-to-end encryption is not that would not have been helpful although there are very many examples out there that we could have used we wanted it to be a definition that stands on its own without counter example um we yeah and to that point also then invoking threats as a way of explaining what intended encryption is would be a common tendency and a lot of documentation sort of out in the wild talks about threats when it's trying to talk about encryption um we also didn't want to invoke a threat model into this discussion at all um and then the other thing which this baby is difficult to avoid we have no control over it is that if there seemed to be a lot of disagreement within an engineering space like the internet engineering task force that could be counter to our goals to try to come up with um you know harmonization on what"
  },
  {
    "startTime": "01:42:01",
    "text": "is indian decryption so if we all sort of disagree about what it means then that's actually counterproductive and you know considering ietf meetings and mailing lists are well documented um that would maybe not be useful but we again can't control it and if we're totally wrong about what is intent encryption then that might happen um okay next slide um this should be the table of contents yep so um the this is what the table of contents looks like now it did not always we've added quite a lot into the formal definition piece so it's a three-part draft it tries to define intimate encryption in three different ways and we believe in aggregate that is what is required to actually come up with a full definition the first way of course is a formal definition what is an end what is the end to end principle what is encryption and then can you summarize that in one or two sentences and we do that in the first part but then i think it's also incredibly useful to look at what are the features of indent encryption and then what are the challenges that features or implementations are trying to overcome um when looking at systems design so the second part is from a developer's perspective what is into encryption and then finally user expectations should matter quite a lot because if the users are not um aware of features or they are not um sort of making choices we were talking before about user behavior around checking signatures like all of that actually matters quite a bit no matter what the tech is it's underlying it because at the end of the day um users are the ones writing these messages and receiving these messages so user expectation tries to lay out um sort of when when a when a user hears that a messaging app is indian encrypted what actually should they expect um and does the technology fulfill that"
  },
  {
    "startTime": "01:44:00",
    "text": "next slide so um the draft is now in o2 i think so since the first draft um we had to really expand the formal definition section it was too succinct and there was a lot of question about what is an end that was a really interesting discussion because it's not maybe just the device if you have for example proposals that um say if you just scan the device before content is uploaded then you could do some degree of content moderation in indians and encrypted systems we kind of feel like that's a violation of um the promises of confidentiality and privacy and end-to-end encrypted messaging so then what is it into the device is it the operating system is it the person you know what is that so we we dealt with that um after the first version and then the um version we're at now has changed um again like a little bit more work on the definition the the formal definition section um and also having to grapple again with this identity versus endpoint um piece so that's those are the changes actually it's mostly been in the sections i think the pieces around you know what our users expect and then also what are some of the possible features for indian encrypted messaging implementations have not really been touched but that actually might be the ask for you all if you check a look at this so next slide please we're hoping to close a few of the smaller issues in the next version that they're not terribly thorny um the there's a i think that it's worth looking for people who really are working on the sort of metadata reduction angle which sounds like a lot of you are with respect to getting rid of user ids and other kinds of things um"
  },
  {
    "startTime": "01:46:00",
    "text": "that could use a nice sweep over for folks wanting to review like are we treating the metadata problem enough as far as i remember it's just like one sort of subsection in section two um thinks i think that um we have other features in there like perfect forward secrecy backwards compatibility issues um disappearing messages deniability but we want to make sure that that's complete actually even if not every implementation has those features we want to make sure that um they're all there and yeah just if we could have more reviews i'd really welcome that um next and final slide gives you all a pointer to where this is happening at github but again and i should have put this on the slide i'm really sorry you can email um e2ee ietf.org for uh with your review um and it would just be really great to have more reviews but open to your thoughts and feedback now as well if you have any great thanks mary any comments or questions i guess how many people have read this draft or you know just in the room no no okay so i guess we're encouraging people to read the draft it's the next step really um i don't see anybody in the mic line so yeah yeah again i'd encourage you to read the draft and please comment to on the e2ee list thanks a lot great thanks mary and aaron this is your box oh thank you so uh i'll be presenting the transparency that is a project that we've recently been developing at protomail but it's also something that in my opinion is very important for the"
  },
  {
    "startTime": "01:48:01",
    "text": "whole community to have an idea uh to propose an alternative to like to verify other people's keys in an automated way so the base principle is the fact that when you get a key this key might not be authentic and trusting the user id is not just sufficient to know that he belongs to someone um this is especially relevant for wkd because wkd servers might uh like serve the key and also handle the the delivery of the email itself so you have a single point of failure or some where a malicious actor might inject a bad public key read the message and silently re-encrypt it to the recipient that might not even notice that this is happening so oh no that's too many slides yeah too many clicks i don't spoil the content so uh what do we have right now is for is mostly um either a key signing parties or um the the web of trust the we have seen that this has worked but this not always works so we would like to propose an alternative or at least to look into an alternative that allows people to automatically do this without any manual intervention next slide please um what do we do is basically create a screenshot of the of the various key in a point in time and you would basically check whether your keys are into the screenshot and you and if if you see your keys correctly everyone else sees your keys correctly this is i mean based on to the comics paper that has been published in 2014 and also google's key transparency"
  },
  {
    "startTime": "01:50:01",
    "text": "project so it's not nothing let's say terribly innovative but it is still a good application to open pgp so the general principles is the fact that we return you some information when you try to fetch a key and we return you also um i'd say a revision a proof and this if everything matches then you can use this information to verify that what you're getting is what everyone else is getting there or there is also something needed is like uh auditors that verify that we um publish consistent ebooks and we don't cheat in publishing several uh ebooks at the same time like basically branching off next one so and i just added myself to the queue to ask a question uh oh yeah in in this slide here who is we so as of now it is protomate but the idea is the fact that everyone could run their own implementation of key transparency there could be uh let's say um any kind of um like anyone who wants to participate into the project might want to register their own merkle tree into oh it's falling the content okay go ahead go ahead go ahead um okay so protonmail or somebody similar yeah exactly like also i don't know keys.openpgp.org might want to do the same okay and how do we do it is miracle trees basically this is a compact way to simply ensure that um users can verify their own path without having to download the whole tree and auditors can verify that the tree is consistent across ebooks we use the verifiable random functions to derive the part of the leaf"
  },
  {
    "startTime": "01:52:00",
    "text": "and so that you can map a single address to a single leaf and we cannot cheat by assigning uh an address to multiple leaves and well here we this is an idea but there might be the fingerprinter that states which key do you actually want to use as primary key we in our implementation are considering using actually not the fingerprint but a list of keys because a keyring might be more interesting so what do the clients need to do is to verify that their own path matches to their own key so that to ensure that everyone is seeing their key if the verification fails this should be displayed to the user somehow but this is also most likely left to the to the client implementation and the auditors must verify that the epoch ids are like consecutive they're the chain does not branch and via gossiping that the chain hashes match so they should pretty much ensure that the tree is consistent okay so um how does this fit into into open bgp it's mostly i think this is uh an augmentation of like of wkd it's something that automatically with wkd could provide us a better key safety and maybe one day could also be integrated into keys as as an additional signature or additional information saying this key is into key transparency at keys.openpgp.org or some information like this like tls is doing with tls certificates that they say this certificate has been released um is there actual question uh so we have dkg in the queue and then"
  },
  {
    "startTime": "01:54:01",
    "text": "paul and then me probably uh thanks for raising this um it's uh i think this is uh interesting work um i'm curious about your choice of fingerprints being at the leaves of the tree as opposed to full certificates um basically because as we've talked about already today the openpg certificate format is composable and one thing that a malicious wkd server could do is serve up the wrong combination of packets associated with a single public key um for example they could serve uh say an encryption capable sub key that they know has been revoked because it's been compromised but not serve the self the revocation signature and this wouldn't identify that that particular combination is no longer valid right so in our implementation we actually consider this i this was a let's say a toy example uh where we use the fingerprints but actually in the in the let's say final draft that we're trying to implement we do uh have a science list where we specify also all the sub key fingerprints and not just um and also the the usage of the keys so if a key is revoked or if a key is used to be encryption only or signature only etc etc etc so sorry let me is this this is a whole new data format then that you're defining is there a reason to do the whole new data format it's an arbitrary data format as of now but i mean as soon as we can get to standardization uh let's say um as if we can get this into uh an rfc we probably won't use our proprietary standardization our property is standard"
  },
  {
    "startTime": "01:56:01",
    "text": "but we will try to look with the community what exactly is needed in the different use cases so the i think the only thing that um i mean we already have a standard for how certificates look the one thing that's missing for your purposes here i think would be a canonicalization of an existing open pgp certificate right a transfer public key form or are you thinking that it needs to be something else yeah i mean at least our specific case has also like a little bit we need a little bit more flexibility so that's why we implemented this format but we're willing to let's say adapt to what the community then requires okay i don't i want to get out of the queue here but if you could describe at some point what specific flexibility you need that's not in the already too flexible open pgp public key format uh that would be great because i don't i don't understand those differences maybe a a stupid example could be um we have uh external addresses that are not meant for email use and we want to specify this directly into the miracle tree so clearly this could also be uh like this can also be set into the key flags but the key flags are not specifically into the into the miracle tree and therefore uh i don't know whether this uh notation would include that information directly into the merkle tree okay uh paula speaking so my question is about so i understand the merkle tree and the append only uh properties and those are great but who says that the latest submission is actually the real one like we have a whole spam problem in the key servers right now where anyone submitting stuff like without confirmation so how do i know that like the poll that knoweth that ca last entry in the in the tree is"
  },
  {
    "startTime": "01:58:00",
    "text": "actually the real key and not some fake key so first of all this project as a whole detect like doesn't really prevent someone from like faking keys but makes them identifiable like makes a problem clear like makes a like gives accountability um the fact that the only the people like if we use wkd if we bind it to wkd and not to the to the key servers that would actually give us um a lot of let's say flexibility disorder in this direction because wkd you have already an authority like the who owns the domain can choose what goes in there not everyone right but so who owns the domain is and that that was my next question actually if you if you link it to the domain then you have at least a guarantee that whoever controls the domain hopefully is also within that domain controlling the key and you get the right person so if a domain is sold to somebody else somebody else will run dns and point to another wkd service where you can get the key of course if you do this that i'm the author of the open pgp key rfc you can also just put it in dns and protect it with dns segment you have to the same property of having the current domain owner clearly owns that key that they currently publish and it's valid and it is the latest key because that's the key they're currently publishing and you would avoid these uh at least these moral three things and having multiple keys with wkd i don't like it because it adds an additional problem or an additional step where a web server can be compromised and other content can appear i mean this also provides the fact that this lets you look into the past and see if an email in the past was already let's say was was faked and also would allow you to see if someone else has published a key on your"
  },
  {
    "startTime": "02:00:00",
    "text": "behalf without you knowing like like you can audit yourself that's the whole point of the of the thing is you should audit yourself into the miracle tree and spot if there's any inconsistency so we're we're kind of about time okay so in fact we are a time okay so yeah i guess this is a topic that ct was interesting there might be a useful way of making this work and in that case that would be interesting i think for to you know having a worked out thing like this at the time we started talking about recharging might be kind of quick it's something comfortable yeah great so thank you um thanks to aaron and to florence's for for taking notes um for those of you in the room uh you you should hopefully have signed into the data tracker and click the on site for this thing so that's that's how you sign the blue sheet so i won't be doing the traditional thing of running around the room with blue sheets at the end as normal and with that thanks for coming um and we'll have some discussion on the main list and go from there and thanks to all the remote folks for turning up as well especially if you're in a painful time zone and i think we're done thank you okay oh one of the nice things about certificate transparency is"
  }
]
