[
  {
    "startTime": "00:01:30",
    "text": "Yeah. It's Okay, folks. We're still having a couple of people trickled in, but what are we started with the administrative side. 1st, not exactly administrative, as you know,"
  },
  {
    "startTime": "00:02:00",
    "text": "Ellen likes us to have a sports mascot for each of our things. You're This is the sparta mascot for a c sparta sparta dot CZ if you want to go and, visit team. I will note that the check version of Spartan Customs seriously different from Hollywood's idea of it. A lot more clothing involved. Probably makes sense given the local weather it does look like, start to have a game on Thursday. Unfortunately, for us, it's at Ebrox Stadium, which is on the south side of the mercy. So not really cycling distance, but if you left our meeting got on a plane and headed straight for Britain. You could probably still make the 9 o'clock start time. We we certainly encourage you to to check out the team if you happen to be around. The next up is the note well. I think many of you have seen this or earlier today, possibly, or in past loads. This gives you information on and pointers to, the IETF processes and policies which you agree to. In order to participate today some of those, relates to how the standard standards process works. Some of them relates to what contributions you can make without disclosing IPR, and some of them relate to what you must do to disclose IPR if you do make a contribution I'll also draw your attention to the code of conduct the IETF code of conduct is, basically there to make sure everybody feels safe and participating, and we encourage you all to read and abide by the code of conduct. Meeting tips, if he wants to follow the chat, you can use Zulip pound MOC or meet echo, if you were, remote, you no doubt, have signed in to meet meet echo, but you are local, we also need you to sign in to meet the echo, but it has taken place of the old blue sheets. It is how we take attendance. It is also how we manage the cube. If you are going to speak"
  },
  {
    "startTime": "00:04:02",
    "text": "please do speak into the microphone. This is a hybrid meeting. We have by the number of participants who are here, via, the remote facilities. So make sure that they're part of the conversation by speaking into microphone if you do. If you're a remote participant, please use the the queue function, and we'll call you from here. We have multiple different screens so we can make sure that you can be seen along with the slides center the agenda for day 1, subject to Vashing is an interrupt readout that'll be pretty short. The summary of M OQT changes since 00. Ian will, walk us through that, and he's role as editor. Then, discussion of Matt, m o q t object model to transport that will be Alan, and then we'll go through the subscription issues focusing on the name space slash track character set subscription IDs, resource limits, updating subscriptions, and the ever green topic of who picks the track ID. So, many, many thanks to Ali who volunteered to be our primary scrub. It would be great if we can get some backup for him. So if there's anybody like to volunteer to be a backup scribe for today. Oh, thank you very much, Emily. We really appreciate that. Anybody is, of course, welcome to dive into the tool and help Ali and Emily out, and we encourage do so, especially if you have spoken to make sure that the minutes reflect the points we were trying to make. At Mike's remember you're going to the mic. Or we could even remember that? We also need somebody to act as a Zulip relay, which is essentially somebody who watch watches the Zulip channel, to relay into the room in case there's somebody who's having some connectivity problem and can't join the queue in a regular way. Normally, I"
  },
  {
    "startTime": "00:06:02",
    "text": "I lean on my former Jabber people for that, but since we've moved away from Jabber, that seems a bit please, please. All that means is you're watching the the the chat. So their chairs can do it if nobody else volunteers. But if you'd like to take that duty, please let us know now. Okay. The chairs will just watch the queue then. And with that, is there any bashing of the agenda seeing none. Why don't we go ahead with the interrupt, you know, Oh, yeah. I I think we have a very cool slide that next right. There's like a Yeah. So, we for the interop readout. We're still working on getting in right there. A lot of people are implementing the draft, which is good. Think there's 5 or 6 implementations the a lot of folks were not able to make it to the Hack on over the weekend, and so we're planning to do, an additional hack on day tomorrow up on the mezzanine level in the code lounge. Stop by in between your other sessions or hang out all day. And then we'll hopefully have a little bit more interop readout to go through it at our second session this week. I will say I think that the sum total of interop between different implementations. I think the record is Martin Duke and I have exchanged set of messages. People interrupting with themselves have maybe got, I've gotten farther just talking to my own implementation, I think others probably have as well, but we're We're getting there. Appreciate everybody's work, and we'll and for inflated more to say. Next later in the week. Okay. So we'll do the interrupt readout again on Thursday if there's no something new to report after 2 state of work. But sweet."
  },
  {
    "startTime": "00:08:02",
    "text": "Keeping into agenda day 2, which is not where we so the next bit is summary of Moku changes since the 00. Ian, you're walking us through that? Other sites. Just sent your sides for this. It's okay. I not right now. Unfortunately, I just got a flight about, 35 minutes ago. You're good. It was it was a little close. And so I very much apologize. So a number of changes were made. Mostly to fix things that I think we all probably wanted to be fixed. So Martin Duke, hopefully, clarified what version and extension negotiate, neither station might mean in 2.95. Doesn't some way it's real, but some sort of so named it to Set up was split into 2. There were quite a number of at aerial fixes. And subscribe hints were added, which is a very substantial change, which added a huge amount of functionality in terms of, like, what you could subscribe to and how. And so thank you for to us for that. Also added subscribe in. Subscribe reset messages defined a control stream. So, that's implied a number of things. And closed a huge number of issues. Miss Sandthing in Britain. I'm gonna I'm not remembering off the top of my head well. I think that was with the critical issues. We clarified something that was I've been clear before, which is MOQ has no TCP fallback directly."
  },
  {
    "startTime": "00:10:02",
    "text": "One wants to use MOB over to speak, Then one can use book transport. So Thanks. Bob's here for now. I'm being spotty about this. So somebody in the chat has asked meet echo if they can, Raise the volume on the streamed content because it's pretty low. So if anybody from media co is listening, Can you check, the output volume on the streamed content? Thank you. Okay. So Yes. If you can put them up, and drive low. I will ramble stem. And my client keeps disconnecting. So my plan to share the slide screen, like, this object model to transfer. Yeah. Yeah. Yeah. Instead. Hey. So I'm stepping away from the chair's desk. I I like this. I think the presentation is largely independent, but just in case, consider it an individual fusion. So mapping the object model, to quick or quick streams. So at the interim, you know, we spent a lot of hours talking about this, and people have very, you know, strong opinions. There's, I think definitely have consensus that when an MOU publisher is sending objects or tracks through a relay. It should be able to tell the relay in some way how those objects ought to be forwarded on subsequent subscriptions that that control belongs with the publish someday. I think was agreement there. That's good. So, relaxing consensus on how the publishers are gonna convey this. The signal. And Given how the rounds of discussion we had then, I I'm sort of an opinion that Now I'm not sure anybody's gonna be convinced that their position is that they're convinced to change the the position. So the question is like, how are we gonna move forward? So Oh, walk through your dead. Different different different different"
  },
  {
    "startTime": "00:12:03",
    "text": "options, next slide. Okay. So, some people like the idea of this is signal being implicit the way the publisher signals to the relay, how to forward something is how it chooses to place an object onto a stream. So if it wants off X1 and 2 to be on to be forwarded over a single stream, it will send them to the relay on the same. Streamstream and so the relay is gonna serve objects to subscribers in exactly the same way they were received. So this implication is that if your relay is a cache, that cache has to remember how those objects were received so that that information that can be replayed later. This can allow for a very arbitrary mapping of object to a stream. You could have 17 streams for a group and Stripebop across them, there's not really a limitation on how it does what the happenings could be. So that could be, fertile ground or innovation, or it could also be very complex for really to have to capture those things. So there's trade offs there. And things, can get strange maybe if they're a reconnect So you might have the way thing the way objects are received into relay may look depending on the network conditions and how many times the track had to be reconnected. But there's no additional wire format overhead messages. We need to, create So that That is sort of what we mean when we say implicit, this is what we're talking about. I'll just, like, pause for a second. Maybe as a clarifying question and make sure I captured what we're talking about. I don't see any. Okay. Next. So there's sort of a subversion of implicit signal, which is with a one to one mapping between groups and streams. So that means that in addition to signaling how the relation forward there's an additional restriction, which is that you can only ever put objects from the same group onto one stream."
  },
  {
    "startTime": "00:14:00",
    "text": "You cannot mix them, and the end of the end of the stream means the end of the group if you want to have every object in its own stream, every object needs to be in its own group. So, that might be restrictive. Like, if you wanted to have different priorities within a group. It's some input implementations to really support the idea of changing the priority of a stream in the middle of the stream. So that can be complicated. And that maybe there's a larger overhead for when we make the number of groups very large. So for example, audio has been brought up some deposit again to see if it does even does that, like, a fairly good capturing of what we're talking about. We're talking about using doing a group per stream. Okay. Next slide. Okay. So than not implicit signal, but an explicit signal. So means that mock messages are gonna carry information about how the relation forward So there there have been a couple of different proposals around how this could be done. One is that it was subscribe. Okay? Tells you that, like, there's gonna be a mode or, there's been another proposal that puts some information into an object header. That tells the relay what to do. So, This creates the possibility of forwarding something in a way different than the way that you received it. So is that a bug or is it a feature So you some people think that that is a bug that the relay should have to do exactly what what the peep I would say the implicit camp. Likes the idea that If I sent it to you over one stream, you gotta forward over one stream. Here, I can send it to you over one stream and have you forward it over and different streams. And so is that a feature, or is that a bug? So fanning out from one street might be a neat neat thing to do. For example, if you ever will link inside your data center. Maybe the One stream is fine, but then you want to have Steve, you want a fan out of the relays. Like, maybe that's something you wanna do. Then fanning in might doesn't sound as fun if you have, like, oh, I received"
  },
  {
    "startTime": "00:16:00",
    "text": "objects from this group and 10 different streams, but they're all told me they wanna go out on the same stream. So now I need to figure out how to merge them together into one stream and that may create buffering problems. So when you have explicit signaling, it means that the mapping has to be something that's defined in the specification. And that limits us the the possibilities for innovation are limited to what we can come up with in in the document and then any new mappings would have to be implemented at relays in order for the system to function so that may slow down evolution of the signal. I correctly capturing? Because you may wanna say more about explicit. Okay. Next. Okay. So how do you wanna move the working group forward? So, this is my observation that, you're using implicit, an implicit signal can be observed if the draft is defining an explicit Right? If you're sending you both signals are visible, if you add explicit signals to the draft, The converse isn't really true. A place to put an explicit signal in the messages then the only thing you'll have simplest signal. So, is my proposal, which is that we an explicit signal, to the draft now, and we're gonna gather implementation experience in data, and we're gonna find out if that meets, can we build the applications we want to build using explicit signaling, And, we can reconvene, in 4 or 8 months and confirm or reopen this decision based on data and exterior implementation experience. So if somebody's implementing a relay, and they really don't want to implement this case where things are forwarded differently where the implicit and implicit signals do not match. We can make that we could allow that to be an error think that might look at this potentially hurt interoperability, but it at least"
  },
  {
    "startTime": "00:18:02",
    "text": "it may be a way that we can move forward down. And not be stuck in the traffic circle. I see, oh, the queue filled up fast. Yeah. Look at that. I think the next slide was about are there clarifying questions on this slide or, there's only one more slide. So I I actually want to make clear one thing that I think you intend, but maybe didn't quite say is that There are multiple proposals now for how to do the signaling. And so what will go into the draft is a single proposal for how to do the same thing. And one of the things that we would revisit after implementation experience just like we revisit all things when implementation experience guides us in a way. Is whether that's the right signal even if we stay within the explicit signal path. Because we might say, hey. It turns out this mode thing as an explicit signal has some downsides that the object thing doesn't have. Let's switch from mode to object or vice versa. So that's part of the analysis that needs to be done over this period of time. So do you you wanna take these or do your list? I just if is there anybody on a are they clarifying? Are there, again, there's only one more slide. So unless I'm tempted to just go on and then open the queue. Because I think the next slide says, like, let's join the queue. Okay. So next steps, everybody join the queue, let's talk about how to proceed. I don't think we should spend too much time having technical arguments about implicit for that we spend many hours of the interim doing that. And so I don't know that doing so is going to change anyone's mind. So we, would like to eventually get to a place where we can do a show of hands, seeing are we willing to move forward with adding explicit, signal to the transport experiment and gather data and then look again. And then if there is consensus on that, then will designate a small group to write a PR to add a signal, and we can discuss"
  },
  {
    "startTime": "00:20:01",
    "text": "Ian ran to the mic, so I'm gonna assume that that is a clarifying question. This is a clarifying. Oh, sorry, Ian, but Google. That's quite a lot. I was gonna ask if there's a PR for the signal that is being proposed. The only There isn't a specific p there's one PR that's open right now. I think think, which is you asked us one on, forwarding those? Is that or that get closed. Yeah. Actually, there's not an open PR that has any modes right now in them. So we're not offering a specific proposal to merge, right, at this time. We're just talking about this an acceptable way forward that we're going to add an explicit signal to the draft where people are okay with? With that with that. Think you're about to is the question about Amexplicit signal or the predicted? Amexplicit signal. Okay. Thank you. I mean, and if this, I'm sure this queue is gonna drain lightning fast, and then people are like, yes, we're gonna do that. I mean, it's maybe we have some time today. We could talk about, because there's which one, but anyway, Colin. Okay. But I'm moving So if anyone's clarifying questions, jump ahead of me. K. So first of all, my mind has changed towards the interim. I realized I was wrong on several cases and I'm much more things. It maybe happened to other too. So there might be more, you know, be your consensus today than we think. So okay. But, I think that one thing is going back to the bugger, the feature on the implicit, not matching the explicit, I view that as a bug, and I think that makes it much easier for get the consensus on some of this as well, right, because it means it would be valid, not just for the next couple months or whatever, but for the final protocol, it seems reasonable to me that if they don't match to return. And the reason why I think that's the right thing to call it a bug is because you never really know how many layers of these things are or what's happening at layers for you. And if this isn't the right signaling for 1 of the layers, there's no reason it's the right signaling for the next"
  },
  {
    "startTime": "00:22:00",
    "text": "I I just there's no one's brought up. I really it's one of those features that has come up as Yeah. We could do this cool thing, but no one has a reason that they really need it. So I think it should be a bug feature feature if we later identify that we need some sort of feature on that, we will explicitly signal the ability to do different things at different layers for different types of networks. Can I just pause real quick and say if anybody disagrees on that point, please join the queue to say, no? We it's a feature and I need it. Doing it right now, but go ahead. Just wanna make sure that viewpoint gets captured. Greg. Okay. So that sounds pretty good, bug. So I think that that brings things a little bit easier, closer together here on, as soon as you have that. The the, you know, the the next thing on the, explicit signal. I mean, like, I think there basically is fairly rough consensus on explicit signaling. Now on the the the issue that was sort of handwaved a little bit On the implicit signaling, there is reconnects, and we know that that's a use It's been our use case forever. You know, somebody goes through tunnel, disconnects, reconnects, Whatever is done with implicit signaling and errors has to not have the system totally break if you reach, like, if you get disconnected and reconnect again. That'll be obvious things. I'm sure as we implement this, we'll figure out the implications of that. Right? I don't think it has I don't think it breaks the implicit or explicit I think it just means we need to think carefully. It means that an error where you joined partway through to pick up where something had disconnected is valid So we'll need to work a couple of details out a little bit what the errors are when the implicit doesn't match the explicit but that seems easy to do. I'm seeing problems there. On the explicit signaling, I think that when we start thinking about things like we wanna do, like priorities per stream and a bunch of the use cases that we've done. It's relatively clear that I think we need to put this in the object, not the subscribe. I think it's and we could now we're into the discussion of how we do it, which maybe we should just kick that down 20 minutes in this meeting to a little bit farther. But I I I think that this is"
  },
  {
    "startTime": "00:24:01",
    "text": "you know, really clear. It's like explicit. There's a fairly clear starting point for how to do that. And and then we should end up that can match the implicit and that there's actually when I think about what everybody's positions were, that what I just what I just described is fairly consistent with a lot of people's positions. So so the queue behind me, but I would like to sort of try and move forward with that. And I'd like to try and have that whatever we put in the draft, There is rough consensus for it at this point in time, and we will reevaluate that 119120, but I don't want to put stuff in there's no consensus for. That's my preference. Thanks. Okay. Thank you looks like Moe. Yeah. I don't have a problem with, going forward with some some explicit signal, as as long as we do required to match the implicit. I think it's important to, back up and mention the consensus that we had earlier wasn't just around publishers should, should decide this. It was more around subscribers are not allowed to, dictate the behavior towards them and force the relay to fan out to multiple different subscribers in multiple different ways. That was the fundamental decision we reached consensus on. And I think if you look at that and the reasoning behind it, didn't want relays to have to conform to all of these different subscribers. But now at the same token, we may consider forcing relays to remap things based on publishers, It it doesn't seem like, those two those two aspects don't gel very well to me. So I think we'll end up concluding the same thing again. Realize won't have to remap according to publisher preferences either which ends up becoming this this case where it's a bug, and it's not a feature. And so you must send to the relay the way that you want the relay to send on. So then you end up with implicit and explicit agreeing with each other again, it brings up a while. Would you bother to sig signal it if you're already knew the way that it came in. I think Will's argument for all of that was that we wanna have the state"
  },
  {
    "startTime": "00:26:00",
    "text": "of of the delivery in the object itself so that for caches and realizing things downstream, the state is already there instead of some other you know, some other staple structure internally. So I think that's really the argument for having the explicit signaling in the protocol itself And I'm fine with that, and I agree with it. Okay. Thanks, I think he was like, sir, maybe Ted, can you is it Suhas? Swas. Thanks, Alan, for bringing this I I support the proposal. Having explicit is useful. And I I also feel that there are stronger instances in the interim for visit. And good to experiment and and bring bring the results back to the working group. And also on the point of, the there's there are only few ways the mock object model can be mapped to the transport because there are only 3 or 4. Concepts in the object model that can be mapped to the transport, and they can be done only 3 or 4 ways. So I don't see, with an explicit signal, there will be for the point of, you know, we have to keep updating the spec to get the release implementation. There are not many There are a handful of them we can define. And at some point, as we progress into the working group, we can remove some of those things which are not useful. On the other hand, on the contrary for the implicit signal, it becomes really hard because any publisher can change any between the object header and really needs to make a guesswork. Are not just that every other relay has to do the exact same in case work, and it becomes very relay, relay implementation defined. That's one of the reasons why I'm strongly supporting this proposal. On most point on should subscribers influence, delivery preference. There are some use cases where they would like to, influence like, if you're recording server or if you're a real time or a live edge desktop, we want a different preference. We might at some point down the road, think about it. But but for this discussion, we we can focus it as on publisher side of the preference setting. Thanks. Okay."
  },
  {
    "startTime": "00:28:00",
    "text": "You us will. Will loekami. I am very much for explicit signaling. I think the implicit is quite brittle, And as we build complex systems, differentiating or the an error condition or a retransmit from an intentional signal from an one is gonna be very difficult. So the explicit is definitely the way to go. It's a very small overhead over the wire. Right now, you either put it on a new stream or you don't, which is one bit. Think if we introduce data grams, then we can go to two bits and we might throw a whole bite in there if we want just for future extensibility. But is is not too many choices. The concern about having a revised relays once they're deployed. To support new modes is is a real one. So we should be very careful. We want very few Mark transport updates, and we want a lot of streaming format updates, and we just want to build a system that can handle these And Moe covered my earlier point about preserving state Right? We don't you you assume that data's coming and going out, but I am one of the enthusiasts for using this for Ford it might have come in 2 months ago, and I don't wanna have to create 2 records in the database. 1 preserve the state when I'm already saving the object, I think it's easily done. Okay. Thanks. N, n I'll just, yeah, the only reason not to do an explicit signal is I I mentioned some Hawaiian trackers just because we don't really know what we're doing. So we're gonna probably have to change it later. Not supposed to tell people we don't know what we're doing. We definitely don't know what we're doing. We are very clear about that. So we're gonna have to change this litter. But if So it's basically, like, get experience with the UPLUSiting or the explicit thing. So, I'm fine with Whatever. But I think that that would be the only argument against it. I just wanted to, like, throw that out Thanks. Okay."
  },
  {
    "startTime": "00:30:01",
    "text": "That's one of the reasons why I'm just making it sort of, like, we're gonna continue to revisit this. Like, we we reckon it much like priorities got merged earlier, like, We're just we know there's a lot of degrees of freedom here, and we need to build real scalable applications on top of this thing to make sure that is not preventing us from building the applications we wanna build. 10. Oh, Yes. Chair cage fight. I can't take you in. Sorry. So I I just wanna point out here that well, I'm totally fine with us saying at the beginning that implicit must match explicit and that I'm very much in favor of it being explicit. I don't think we can then trust that the system will always behave from the relay onward obeying the signal. There are gonna be cases where when the relay gets the signal, may not actually have the resources to fulfill the request. And the obvious one for the is if somebody sends you something in a mode that's one stream per object, but then sends you objects faster than the stream resources that you've received from the downstream client, you now have a question. Do you wait to get more stream resources because you're doing an object per stream, or do you coalesce? In order to deliver the bits. And I think that coalescing in that instance would be reasonable. It it's probably also reasonable for people to rapidly understand that it if it hurts when you do that, you should stop doing that. But especially at this point in the system, I don't think that, that this is more than a strong hint It's it's the desire of the publisher but the system as a whole may still function better if we acknowledge that the relay may have to do something different if it's talking to a downstream relay or talking to a client. With different constraints than, the publisher understood."
  },
  {
    "startTime": "00:32:04",
    "text": "And, I wanted to say that here because I I think the system gets more fragile, unless we acknowledge it. Pretty much openly that that is the case. Thanks. I do think that maybe there that will be controversial. I suspect there are other people who would jump in the queue and say, You better not do it differently than I told you to do it. The example you gave of coalesce or not to coalesce could also be part of the preferences expressed, which is like, Please send an object per stream unless you can. Could also be an explicit signal I So, I don't know if people but maybe we don't need to just hide that right now. We can wait to have a PR, and we can argue about particular point. But thanks. Luke. Sorry. Sorry. Sorry. I missed the first the 15 minutes because my toddler refused to go to sleep, but, yeah. No. I'm one of those controversial, opinions you're if you're looking for. So first off, I completely agree with Cullen. Like, I just If implicit doesn't match explicit, it's it's just a bug. Like, it is it is either a bug for, like, I accidentally sent over the wrong streams. But I also think from an applications point of view, it's above, like, so Ted Ted's point, Ted was, like, Well, the encoder decided to put them in this one's stream mapping but a relay decides to arbitrarily shuffle things around. It means that the decoder can't make any assumptions about what what arrives. Like, if the encoder says I'm gonna do a stream per group, And then the relays is allowed to say, no, screw that. I'm doing whatever it wants and that you just can't assume behavior on the decoding side, So I think if if you if it's an explicit symbol, signal, really has to do it. Like, it is it is a either drop it or or do it. That's kind of the the, the two lines there. Okay. I just I wanna get your opinion on the the road forward here. Is it okay to merge an explicit or"
  },
  {
    "startTime": "00:34:01",
    "text": "go forward adding and explicit to the draft. And I so I've only heard people so far say they want explicit to match and play that So if it has that constraint as well, is that can you move forward with that now? Yeah. I think the my main problem with explicit is just how you signal on the wire, I think like having Boolean modes is just very fragile And I think when you start making it really, like, you know, this number is the stream ID. It it basically reimplemented quick streams. So I think that have explicit. It's just really hard to get the implementation right, but if we can do it, then I'm I'm for it. Okay. So Let me just clarify it Do you have I I think what I heard you say is that sort of just having a 1 was too simplistic for the applications that you need to build. Is that right? I mean, if we only have a few modes in the protocol, it just means you have to update every relay, every time you add a 5th mode or a 6th mode. I I don't think that's gonna scale. So the the the concern is that you it's not that you have a mode 6 we can't express now, but a worry that we will have a mode in the future we want we figure out we wanna do something differently. Yeah. I I imagine there'll be a world where we just literally tell the relay, hey, put this on stream and give it a number but then you have to figure out how do you know when a stream ends, for example, you need, like, an equivalent fin message. And I think we just go into redoing quick streams, but, Yeah. I just like modes. Boolean modes are just a really hard to update it's okay for experimentation, but I just don't want it in the final draft. Okay. So you so summing explicit signal is okay. Explicit implicit equals explicit, and you want something more flexible than brilliant. Okay. Before we go to the queue, do you have something from the chat, whether a question was raised, whether this"
  },
  {
    "startTime": "00:36:02",
    "text": "proposal is something that must be used by all parties every time or whether it may be optionally present. I hadn't given thought to it. My My first impression is that if maybe there's a nun or an I don't care and the relay just picks what's convenient for it, and that could be okay. The publisher was not opinionated, but if somebody else in the queue wants to answer Okay. They can. Mike, you're next to the queue. Mike, sorry. I haven't formulated any thoughts on the question in chat. So maybe circle back to that later in the queue. So so My, take on on this general question is that it may be a smell that win don't have the right abstraction in groups and objects, or we're not utilizing that in a way that is conducive to layering. And what I mean by that is I agree explicit should match implicit and we should be explicit by using, groups and objects or whatever that primitive is. To signal what the intent of the publisher is. For relays to deliver downstream. So, I'm I'm in the camp that you characterized, I think, as implicit signaling, but the the subgroup, which says we should do group per stream, And in that sense, my take is that that is explicit signaling so long as we fix that in the draft. Right? So if we say, you know, a, a group maps to a stream with the caveats of, like, reconnects and, you know, how we handle that. You know, then, the, the group gives us that explicit signaling. Yeah. So to me, this this is mostly a question about, like,"
  },
  {
    "startTime": "00:38:02",
    "text": "where do things fall between the mod transport layer, streaming formats. And I feel like right now, group and object talk maybe too much about media. And less about the underlying transport to call in, but the intent is for mapping things to that. And so if we can we can make those talk more about what we wanna do with quick streams or web transport priorities, all those things. And less about, the structure of the container format or whatever our media happens to be we can, we can get better layering by by utilizing those to express intent about delivery, and then the streaming formats are free to experiment with different modes or whatever. Just by building on top of that. Thanks. I mean, I think part of my view is that having an explicit signal, like, for example, you're saying, like, can we do everything by saying a group maps to a stream? I think may we it's possible we could get there. If you if we put in several nodes now, and we find that no one uses anything except that one or were down to a very small number of use cases it'll be possible to eliminate it. But I don't think we are now. I don't think we have the information now. Alright. Thanks, Colin. So this goes back to sort of Ted's comment from a while back, but I think I'm very much with Luke here on, I, I think that the relay should do what you tell them to do. And if they can't do that, they should not forward your object. Maybe you find out about that. Maybe you don't, but they shouldn't do something other than Now that doesn't mean we couldn't have a mode, that says, yeah, send us any way you want, right, or something like that. But I I think that with explicit signaling to me definitely does mean that. And it comes back to Luke's point of you know, middle boxes can arbitrarily change stuff on you, it becomes very difficult to build really reliably implementing systems. I you know, there's this comment of, like, the the the groups and the objects"
  },
  {
    "startTime": "00:40:02",
    "text": "are meant to be joined. The groups represent join points in the media where you can reuse resume things and certain other types of operations on fetching nothing to do with how the transport is. I think we should keep that very orthogonal from the transport things. And, you know, people say like, oh, we don't know. Well, I mean, like, this stuff was, like, think we discussed some of this in the rip draft, which was published in 2020. Okay? It's almost been 4 years that we've been implementing and doing some stuff. There is some experience here. It's not like no one's ever done this before. And I think that a lot of that evidence does point out that we need more than a single mode of group per string I think we've sort of come around to that. So I something here and we're think we do need we're coming around to that. And we need, you know, to Luke's point again, flexible mode, we're gonna have to think about this. We're gonna find implement it. You know, as we implement it, we're gonna find little places where, like, oh, crap. Which we didn't do it that way. We'll refactor it or whatever, but I I think that we need something along those lines that is flexible enough that we not only hit the applications we have today but we hit the likely applications that people are going to try and put on relays later without doing the relays. And I, I don't really think there's many options to choose from, so I think it's pretty easy for us to so. Thanks. Alright. Will I can't see other. Will Jonathan Suhas. Yeah. Sorry. Color basically made my point. I I think group per stream we we can't enforce that because group is the joint point. And if you're doing frames, per stream per group now, then you've got an awful lot of groups that you suddenly have to individually index inside your relay. So that that's not a mapping, would support We also the streaming format is going to propose a prioritization scheme that feels is a good response to congestion. So the the streaming format wants to enforce a certain behavior, such as drop older groups. For example, And it it, therefore, needs to control this. So this is another"
  },
  {
    "startTime": "00:42:02",
    "text": "necessary part for for the deterministic part of, I I want every every hop to do this. And it's been pointed out that if you're a Relay provider, you may be wanna some flexibility to do something else because you've got fiber between you and your lines and you're not gonna have congestion. And I think but the trouble is a a publisher never knows if the subscriber it's talking to is the final subscriber in the last mile. Or it's just another node. In most cases. Now in a relay system, we would actually know, like, if if a CDN node's talking to another CDN node, We might just privately agree to go to often do something And I think that's our own business. We can. Right? But the spec should say that every node should forward in the same manner such that it goes to the end user ultimately, in the way that the publisher intended it. Okay. Thanks. Jonathan? Yeah. Jonathan Lennox. I mean, I think I I like the idea of n explicit signal in the abstract. Think the reason I started complaining in the interim is that I didn't like some of the you know, explicit explicit signals that people were proposing in the concrete. That I thought they were far too restrictive. So Part of this, I mean, saying an abstract an explicit signal, great, but need to see what it is before I say whether I like it. So you in Brisbane. Yeah. Or probably an interim given that this working group So, But, yeah, I think what my preference would be an explicit signal that says, you know, basically, the publisher would have liked to map it to streams if nothing had gone wrong. And know, give it full flexibility for that And then, obviously, things can go wrong and why we have this explicit signal know, for the reconnections and whatnot, but that's roughly the scope of explosives at 11 Okay. Thanks. Suhas."
  },
  {
    "startTime": "00:44:07",
    "text": "I kind of want to reiterate the mock object model is very simple. There are only 3 three things in there on the early streams and diagrams. Either we set it as an explicit, was exactly saying how it has mapped or not. There are not many mappings. And also, Mark is so early in this development There are many applications every day I talk to people. They come up with new applications. They want to build on mock. And anytime we've anything we freeze right now, we'll basically hinder the developers. And also at the same time, we need to keep the flexibility option opens so that the relays may not have to keep changing. So my my, proposal would be to kind of go with the few handful of mappings that we have along with another signal that say can relay relay change if if it's needed or not as an experimentation thing but going with the proposal with explicit we can keep it as the standard, but the experimentation would be really about what happens if Reliability maps? That that can be an ex under the explicit mode as Colin was saying. Okay. Thanks, Moe. At Mozeneta. Just to address, Luke and, Mike's point about is stream per group, sufficient for all use cases. I don't think it it is because well, I think it's probably gonna be the dominant use case for video mappings. I can already envision cases where it wouldn't work. Or it wouldn't work well enough for an application because what what it what it forces you to do is buffer at the application. You have to have a reorder buffer get groups out of order. If you want to just linear delivery, for recording or something, then you would could ask for a stream per track. And get that quick layer to give you that guaranteed delivery order and not implement reorder buffers at the application."
  },
  {
    "startTime": "00:46:01",
    "text": "On the opposite extreme, you have a very complex app that can do very complex things with the video, like, restore it on a frame by frame basis, then you don't need the head of line blocking imposed. I by stream per group, and you make ask for stream per frame and do your video repair and concealment, on a frame level. You're willing to implement those reorder buffers at the application level. I think there's not an easy way to see that One mode is gonna work for all or even almost all applications, even if we think that we're gonna start off with 3 per group for most applications today Cool. Victor, Q, So I I I just wanna point out that because you may have loss on the the channel, somebody is going to have to, manage the the fill of any lost streams inside lost packets. Right? And your decision at that point is, as you point out, are they gonna have the quick layer do that for you? And not deliver it up to the application until that's done or you're gonna have the application layer do it for you. Just to clarify that. I wasn't talking about the loss. I was talking about the latency from head of line blocking of the frames even if you're willing for quick to retransmit, and incur the same bandwidth overhead as you would before. You don't want that added latency of waiting for that retransmission, and you can do something to conceal and render good enough video in interim. And so I get those repairs. I agree with that, but what I'm pointing out is that there's another condition where what you have is a situation where you may be missing things and you then have to decide whether you're gonna create the buffer to retain to to restore them at the the transport below MACH T or the application above it. And Whether Mach wants a signal about that, is part of what this discussion is. Right? Yeah. That's fair. Okay. The next person in queue is Victor. Okay. I oh, do you wanna make it long for you?"
  },
  {
    "startTime": "00:48:03",
    "text": "It seems to be kind of petering up. Okay. We'll see. Well, I'm just worried there was somebody who's gonna one more thing. Nice and small Alright. Go ahead. Victor. Nothing controversial. Uh-uh. I'll Hopefully not. I think that we will endeavor the blade change things, but Juan saying, so It's listed in the interest of making progress. One thing I will know is that While we don't, we're not sure about what stream mappings we will need, we kind of have some intuitions that, that's about right. Which of them we will definitely need, and we can start with those and maybe add more later. And that's what I think everyone so far agrees that I'm under impressions of groups per object. It's something group will need to implement at some point. So that might be useful starting point. I'm I'm not suggesting but that's at least one thing that I feel like everyone that risks, we will need that list in some cases. Regarding explicit signaling and matching it, what's on the are I agree with Flow that that that It would be really bad if you take a group and some just split it into objects that start to live it out to further. I theoretically, the opposite is not as bad. And, like, you can just put the entire connect and then put it over TCPs and everything is serialized, but but that said like that still works, but, I don't have a particular spelling case 4, 5. That eyes are. So okay. Thanks, Luke. Yeah. Something controversial. No. I'm I'm just saying I'm getting out. We'll, I I definitely think this is just a try it out and see how it goes. I especially think if you come from an background. It's really hard to So"
  },
  {
    "startTime": "00:50:01",
    "text": "to let quick do more things. And also figure out what you can do in quick. Like, to Ted's point, you can have streams arrive at. You can read streams out of order. The head of line blocking is, is almost like an API decision. In quick, you but you can actually read frames out of order just fine. So I think we'll we'll get more experience. I I think we'll we'll get close sir. We'll try and figure out, and we're we're gonna be open to try new things and removing boats in the future. So I think it's really good to to be flexible I'll have a right answer here. So, yeah, let's let's let's make it generic. Let's make it a flexible Okay. Thanks. Okay. That was the last in the queue. I did wanna read one thing that Mike wrote onto the chat before we take this. And that is the way we currently define groups is oriented in terms of media property rather than transport properties. And I think we should flip that around to get better layering. I I think what we're talking about today is say we we currently have the semantics of group n objects, objects, be related to the media properties. And this is the way we're allowing the publisher to say, how they get mapped onto transport properties. That's core of the question we're we're doing. I think that's a a better way of putting it than I previously heard before, so I wanted to repeat it to the group. So with that in mind, the question I'm asking the group I'll do it in the tool in a second, but I wanted to give people a chance to, bash the question because I know someone will is For the next draft iteration, We propose A set of explicit signals to allow for the mapping between the media properties and the transport properties. And I'm gonna be asking where yes"
  },
  {
    "startTime": "00:52:01",
    "text": "The raise hand is yes. I'm in favor of that. The do not raise hand is no. I'm not in favor of that. Are people okay with that wording? Will, I knew somebody would bash it. Get up. Clarifying that. Is it possible for you to type that? Type it and share your So people Yeah. Can you put it up so we're not arguing over memories? I don't think we should use the words media when we're talking about mock transport. We've decided before that it's it's a binary transport protocol. The media mapping comes Outside of it, the application So, yeah, just take the word media out and make it Yeah. Object model application defined. Just an just an administrative note, unless something terrible happened rather than having this do not raise hand business, you should be yes, no, and no opinion. And be that code now. Oh. Oh. Oh. Yeah. But but but the the system could absolutely make a liar out of me, but what supposedly happened. I was not in a session this morning, so I can't verify it. Oh, Luke has a hand as well. Look. Yeah. I'm just gonna clarify slash whatever. We're not changing the properties of mock transport based on this mode, right? Like, group is always gonna be a sync point. We're not, like, we're not gonna have a mode that changes what transport properties, exist because That that that's where it worries me a little bit. Yeah. I I don't think I heard anybody. I don't think that said was proposing that at Okay. The or no? So, Ted, can you just clarify, is the question, can you live with this design, or is this your preferred design? Because I think some people on the implicit camp would prefer implicit, but we could live with an explosive signal anyway. So it may influence how we The Did you prefer to be in the rough furthest or would you prefer to be a positive it so that you can look at the typed thing and figure out. Okay. Hold on. So who gives you that a second to it's hard to listen and"
  },
  {
    "startTime": "00:54:04",
    "text": "type of reaction. So, in the meantime, I would like to call a, if you please come if you like humming. Now. Oh, now if you don't like humming. I think it was inconclusive, and I like humming it I was gonna have my editor comment that I'll remind everyone, we will revisit this. There is no chance in my entire life that we will not revisit this. Like like like this is not the end. Is the beginning. Feel like I'm in an action. Like, at the end of, like, the SQL Slack being set up. Okay. Okay. I'm gonna try and share my screen now. Let's see. I've unsure slides. Your screen. So can tell he's in the permission dialogue. We're in big trouble. I'd love to meet echo Davis. The new screen has been shared and point the same thing. Yes. Alright. Bash bash again with this in front of you. Any bashing or clarifying questions? Before we don't see anybody in the queue. Will's got a hand up, though. Just say, Bass, Will, we know you're Sorry, Vaish. Is it how just the objects map"
  },
  {
    "startTime": "00:56:01",
    "text": "or how the groups and objects map. While I originally had a media object, media properties, how about if I say But is that is that a mock object? Should it be like capital a mock object, and a mock group. Or, just model. And a mock track. Because that that's our complete object model. So mock groups, tracks, and norm or tracks groups, and objects map to transport properties. Okay. Luke, did you have a question? Yeah. I I guess I'm asking my follow-up again. Are are we these signals, are they changing what it means to be an object or a group. I don't think so. So and the the whole idea is that they've done. Right? Transport properties. Right? Like, what does that mean? Well, so whether they go on one stream or two streams or whether they, Why why would you sorry. Now I'm gonna bash. Even though I thought this was the most best thing I've ever seen in my life, Ted. How about map to quick streams? Instead of transport properties. Or transport constructs has stated ramps or about transport construct? Because we we might have data grams in there at some point. I you're totally right. Yes. Alright. But but, look, I'm I'm a 100%. This doesn't change anything about what a group track or object is in any way whatsoever. I think everyone solid on that. Yeah. Yeah. Like, objects are still atomic, whatever. You know, like, is still still sync points. Yeah. Everything we hate and love about them remains Yeah. It changes a little few things because streams are ordered, but yeah. Any more bashing? Okay. Sharing."
  },
  {
    "startTime": "00:58:00",
    "text": "I know. Where do we's hand tool go? I can't find the raised hand tools. Is it down at the bottom? Okay. Who took the practice session and knows where the show had hands I I took the practice session, and I still can't find the bar graph. So it is. 6 Barbara. Top the, the second icon on the left. Oh, wow. I do not think of this as a bar bar graph in this you're like, they messed up the Cisco logo. No. That's it. That's not it. It was almost there, and then it was terminating. Oh, I've seen sparta. I don't think that's a title. I think that's the question. I am flabbergasted that they managed to implement this and still get it wrong by defaulting you to no opinion if you didn't pick anything. This is in 2nd. So, I mean, the fact that they like, as soon as you guys hit it, everybody who was logged on the blue sheet was automatically no opinion without selecting no opinion. Ultimately defeats having that choice. Right? It's like insane."
  },
  {
    "startTime": "01:00:01",
    "text": "Anyway, we're getting the data we need. Alright. Just for old time's sake, if you click yes, please now. If you clicked no, file a bug report with media echo. If you deliberately clicked no opinion, please go to the microphone and explain why. Alright. We're terminating the show of Hans tool. Thank you, Irvin. It was a productive conversation a decision has been Did someone actually just click no just yeah. Okay. Who wants to was it you? Just to see if it worked or you wanna say, okay. Today in QA Properties, That was an explicit signal as a coincidence. Alright. Okay. Well, I'm okay. So That is good. I we will the chairs will and the author and and Ian will, Find someone to write the first PR, and then we can argue about the exact spelling of the signal. Next. It's 2 o'clock. We're halfway through our hour. The we have some scribe issues. Wanna talk about some scrap issues and then, if we run out of subscribe issues, we can argue more about if people wanna advocate a particular kind of explicit signal, or do you wanna take minutes a half people argue about that now No. Let's let's do the subscribers. Now people Did we figure out I need to try to figure out how to share my Okay. So You're gonna share your screen. Or did you or did you do it again?"
  },
  {
    "startTime": "01:02:01",
    "text": "I have to go under permission. Okay. And flights. Okay. So a screen share is being started. Okay. Let me choose a window, or does it share the whole? It'll let you pick the window. It says it's being started, but it didn't actually Thank you of curiosity. Took some exam. And then Yeah. So now that we have a much more functional version of subscribe, make what was formerly known as subscribe, hints. We now have a number of issues that have come out of that, which are very predictive. I'd like to go through most of them relatively quickly, but one probably deserves. Real thought. And I'm not sure what the working group is gonna decide. So Very simple question. Are the restrictions on track names and name quizzes? And I wrote the slide. My cats are rocking and Gracy. So it can be binary or gonna be no restrictions whatsoever. ETF 8. RC 3986. We need do you need to decide? Ideally. I mean, obviously, we can revisit this just like we will everything else. But it'd be great to decide fairly soon. So Take care. I'm bond of no restrictions because if there are no restrictions, that means you don't have to validate and recess a connection. Which is something you ideally should do if there are restrictions. And in practice, there will be context in which there will be restrictions and we'll put some escapeings like the URL style landscaping, but Sure. Of of even when you use tapes, you have actual contents that"
  },
  {
    "startTime": "01:04:00",
    "text": "is no restriction about, like, that's just since it's a VC user. So you're you're advocating for an opaque sequence of bytes. Cut. Correct. Uh-uh. That's Go on. I'm gonna say the same thing as Victor, but I'll explain them a slightly different I think the question is, are there any restrictions tractions? I I think it's where in the system the restrictions on this. So when we're talking about a catalog format or something, or how things might get done at the sort of layer of, mock transport. I actually think that It's we'll probably end up with option 3 or something. But what I want don't but what I wanna do is can analyze that and put it into a form of what the relays need, And for what the the messages that we're passing in the in the that we're talking about in mock transport here, that describes it. The only thing we ever do is is compares on these. And I don't want to be doing any of the canonicalization type things or UTFA type processing or any of those things at that point in time. So as far as mock transport is concerned, I think that what it should say is option 1, no restrictions. Now something else above that might say actually option 3 that ended up in there. I'm not I'm not against I'm just saying that in the transport, in the relays where I'm matching everything time. Everything will already be canonicalized, and I will not have to do any processing that is slow and painful. And instead I'll just do, you know, bit wise compare. So I'm arguing for option 1 at the mock transport, but that doesn't mean It won't be option 3 somewhere else in the overall mock working group. Just just in in this part. It's it's option 1. Thanks, Scott. Let me just I'm gonna pause for a moment. Is Is that the general consensus of the room Okay. Is there someone who strongly disagrees with that? Oh, Thank you. Do you compare these objects? His names. They currently have a quality comparison only."
  },
  {
    "startTime": "01:06:00",
    "text": "Quality compared to Yep. So, it would They're very sure that you don't get the name from 2 different sources that disagree about con cannibalization. So If, you want to restrict this, better get that jurisdiction in for quick. I mean, DNS is in theory a binary protocol that just case insensitive. It was, design mistake. But, comparison is hard. Yes. I'm very familiar with the issues of case sensitivity. And it's very painful. And do not wear a roof use it. Okay. It's us. Correct. I I think Colin and Victor explained my case here. And I I I at the transport layer, my my one of my goals is to have, a system that does real fast bit comparison and works at the, at, like, millions of connections coming through. And I would not want, string comparison or any formatting of the string to be done to compare to one way or the other way. And I'm totally fine with us with on on you want at the layer above marks, if you want to have more detailed a way to represent that I'm not, posing for that one. Cool. Sounds good. Oh, Nope. Mosenady. I agree with what Colin said too, but I think there's a little bit of devil in the details the spec, I think, would have to say very clearly where escaping happens somewhere else and that it must already happen before the point of checking for equals in some parts of the protocol. Because, like, your your last example, you know, rocket space equals Gracie, somebody puts that escape in one way, and it was published without an escape. The subscribe comes in, escaped."
  },
  {
    "startTime": "01:08:01",
    "text": "You know, the they're equal in the, you know, after canonicalization is done, but They're not equal binary literally. Coming in. So have to very clearly say where you do a binary compare that they have already been processed by something that does the escaping for you. Yeah. I I think the intent here is that the mocktransport would do the binary compare. Be a completely opaque to character sets and all the other things. But you make good point. Yeah. I I mean, this clearly needs an editorial note at the very least because otherwise, it wouldn't have been right up because Yeah. Yeah. Alright. Outlook, outlook, memories. Yeah. I don't I don't know the finer details about all the different encoding schemes, but I will say that the name and the name space are meant to be human readable. They're meant to show up at the URL. And they're meant to be even error messages, I wanna put the the name of the track in there. So think at least option 1 I don't know. Like, it just it just makes things harder. It means that you the protocol supports something but kinda like, So, yeah, I as long as we can find some voting that's easy to do Harrison for. It's this is gonna be attached anyway people saying you're just doing, a byte for byte comparison. This goes into hash map. It doesn't matter. So as long as it's hashable, Okay. Thanks. I will write a PR to that effect. I mean, I think there's a whole another conversation about namespaces, but you haven't really described exactly what the implications are and how it relates to say to the So we've got a late break in Christian. Web object model and stuff. Oh, Christian, are you for the next one or this one? No. For this one, I think I am with a guard on this one. I believe that, the the names should be somehow strongly types."
  },
  {
    "startTime": "01:10:01",
    "text": "Because, otherwise, you have security issues. Example of security issues, a bunch of receivers conspire to get, an equally equivalent but binary different version of media stream. And they forced the readers to have as many copy of that as as they want, etcetera. I mean, zone, I I I think I think you need a storm type. Thanks, Krishna. Think we all agree that that's a concern for for sure. There's a in the Q form. Yeah. Yeah. Oh, yeah. Victor and Martin. In mock style. Yeah. I'm not sure. I I I can like, you would need to have specific attack in mind, but in general, binary strings are strongly tied in facts. This is a partners, the strongest, getting easier. So formats, that too because like there are also the smallest security surface since you don't need to do any normalization or any sophisticated name matching telfort that you can introduce box into, and as we were discussing just that as a chat, but it is fine to introduce any requirements or restrictions on the application level, but on the transport level, you have a string of bytes and you create it at string of thoughts and if your application, youth treats it differently than you get to keep the peace of the stuff. May may I Matt."
  },
  {
    "startTime": "01:12:01",
    "text": "May I respond to that? Sure. Good for you, Christian. Yeah. My my problem there is What happened Eve. The one one client subscribe with the emoji version, and then there's a clients subscribe to the Sketch version. And so you get you get those 2 requests arriving at at a relay. They are binary different. But if you or packet them all the way to publish that we should receive at the other Sam. So You you have you have to explain me what we do there. Oh, I was gonna give you my shirt reply. I I think the answer is one of them wouldn't work. One of them would fail the other one would succeed because One of them was the correct binary coding and 1 was the one not was not. But we have to say that. We have to say that very, very clearly. When I say strong type, I don't I don't Go for it has to be binary orutf16. I said, you have to say very clearly what comparison means what that does to Cisco, what that does, etcetera. Yeah. I think this is a case where, like, memcomp like, level comparison. We're talking but that's my personal thing. Oh, There's a whole chain of that, and and and the DNS Priyant says it may it's not so easy. Okay. Just on the Christian, responding to Christian, I think that the concern is right there. And also going back to you and see your your your your point that the draft is a draft should basically say by the time the name comes to the mock trans what what should have been done with it in a sense that what we are expecting it That way, if if that is clear, then, some of those concerns can be"
  },
  {
    "startTime": "01:14:04",
    "text": "result. Another point that Luke made about, the track names and record is to be human human readable so that it can be useful in URL or for debugging. I think that's a valid point. And in, just to state, in my in in our implementation, we use the track names and track names best to be integers. If not in URL, But earlier, above the mark, we can note it back into the URL. So in that that phase, we we the idea here is that we get interior comparison, auto screen comparison at at that point in time. And and then, are the end end applications of wherever we log, we basically convert it into your offering you all for debugging purposes. So we can that can be done all layer above as well. Thank you. Yes. I do. Thank you. Victor. You are next. Okay. So I think the blessing here is less of what the format is and more of. That we say that the transport should not normalize in any ways the train. And that's what we're saying on the Cesar price rates that the transport should keeps an FS otherwise. That things will happen. Well, Just one concern here. I'm I'm I'm a fan of the binary blob at at the transport layer. But what if when you encode your 2 cat emoji in one streaming format, You get an array of bytes that happen to match the same bytes coming out from a URI based encoding. Our hypothetical case. Now we have a we have a collision in our catch. Right? We have 2 streams that have the same names because we've allowed infinitely many encodings to derive a set of bytes. So is that a concern? And should we go back to the notion? I think what Christian raised, we if we find just one encoding, then if they're the same ray of bytes, well, then you're actually asking for the same thing. So that Not to be difficult, but"
  },
  {
    "startTime": "01:16:01",
    "text": "I believe you're an author they soon to be catalog draft. And so I think You very much have control over this question. Right. I do. I on on the catalog draft. Right? But what if someone else uses another catalog or the point is, a generic relay is gonna see multiple applications coming in and have to cash the content Yep. And and avoid collisions. So You know, how do we prevent there being bit level collisions. For the relay. Unintentional ones. I mean, I think that's a good point. I I think you know, users of relays will presumably, like, do this, I hope, automatically, because people use, like, the catalog draft or some other thing, but I think you make good point. Think that maybe Attackers of relays will likely use this you're you're right. The threat model is the potentially interesting as is about actually a number of these topics, But this has nothing to do with this. This is how do you how do you saw people from using the same track name no matter how you encode them, and the point is is the CDN going to require authorization to use a given namespace. That's the answer to this question, even though I'm not on the sorry. But, like, this this, like, that problem of how do you stop that doesn't have to do with the encoding. Right, right, has to do with people choosing the same name. I agree. I tend to agree with you. Also, the security considerations is either completely empty or almost completely empty. And so if you would like to write a PR, then you're a very welcome Let's move on. But I appreciate everyone's thoughts. I am I think I have clear direction on the editorial PR though, like, if people wanna write scary considerations that'd be wonderful. Okay. Oh, it's us. I think the conclusion that we want exact"
  },
  {
    "startTime": "01:18:02",
    "text": "binary comparison and that the transport should not be aware of the character setting. Otherwise, So option number 1. So it's completely opaque. Sequence of bytes for both the namespace as well as the tracking. Yep. But that that is for the transport layer. We we know that that moves the complexity up and we're okay with them. Yep. Okay. Now the way of subscription hints, very much to ask. We will Very important issue. Now we have a whole another number of other issues we can now, like, go ahead and resolve The first one is multiple subscriptions. It seems like This is an easy yes, but I just wanna run this by the working group. Can an endpoint issue more than one subscribe to the same track? Certainly is semantically possible in the current draft today, but we don't talk about and what one should do. And then we will follow after that. Oh, I already have three people. Victor. I think the answer is yes, but the more difficult question here is, okay, if you're subscribed wise, does it say entrap how does this locus the wire? Because I assume you would want to deliver to get every object at most once Those questions will be following. Luke. Yeah. So like Yeah. This is this is the starter question. We're warm up. Oh, I I I was just gonna bring up Alan brought up another use case where, 2 different subscribers have an off, info So you could have 2 otherwise identical subscribes you somehow need to forward that authoring photo of the origin. So that means multiple subscriptions. And you do need to duplicate the objects that come through. So that's that's one thing we need to decide Like, do you, do you, do you subscribe or not? Yeah."
  },
  {
    "startTime": "01:20:00",
    "text": "A very interesting point. It's yours. Yeah. I I think, we should allow multiple subscribes that the PR on subscriber ID price to do that one. Basically, the idea is that the track alias is the one that represents the full track name that we are interested in. And subscribe ID based courses on which each subscribe with a new ID basically says in the same track where do you want to read from? And I totally agree with Luke that, we need to be we needed to say something about what happens in the case if you have duplicate that's coming, there are use cases where, you let's say you're an elevator and you missed last 3 seconds or 5 seconds, and you want to kind of run that in, 1.25 times the speed versus the live edge you want to be do want to go on the real time speed. In that case, you don't, you want the duplicate to come. Because you want because you lost those things, you want those things to come so that you can run faster and go through some use cases where Luke was talking about where it's, it we stand with, we need to consider that. I don't I don't have answer for that. General, for this question, dance road, yes. Thanks. Well, Yeah. What's the intent when a client subscribes twice for the same track. Does it want the relay to send copies of every object, or is it expecting dedupe to occur? And if do we have to mandate that dedupe must it's a function of the relay to dedupe any incoming requests? I, I think, I think this would be a great moment to move on to the next time, is that was exactly, yes. So unless you actually okay. Can I Move over this one quickly? I go past years? I I'm sorry. I'm scrolling in. No. No. No. That's good. So Basically, we need a subscribe ID if you have multiple because otherwise you can't figure out control messages We have a PR for it. That's in flight. So, you know, feel free to review, but, like, it seems like that's where we're going on that."
  },
  {
    "startTime": "01:22:00",
    "text": "But let's get to the many questions, next slide. Alan, did you wanna coming forward. I just wanted to answer, Will's question about why you might wanna subscribe to the same track. So now that you have subscribed, hence, you could wanna if you're a relay, and you have somebody so you've got a subscription already for the live head and then somebody comes in and they want something older, you might need to issue a subscribe. So that's one reason. The different subscribe parameters. That's one. Another one might be OS. Right, where the relay is not, cannot do auth. It has to forward the subscribe to the origin to do off. This is not a CDN use case. I know that makes you panic. Don't worry. So, like, for a chat, it may be real. And so there need to be cases where forward the subscribe all the way to origin to get the authentic the the authorization check that. Oh, Oh, Ah, okay. I'm sorry. Yeah. So question number 1. Yes. That's exactly yes. So now we should discuss that question because I think that's nick, extraordinarily answered your question. Discuss question number 1 if everyone's okay with that. So if they overlap. Let's assume they can overlap for the moment. Yeah. What happens. Do we we basically and the 2 options have been proposed our the receiver, the subscribe, other, like, indicates information that says, like, I'm only going to give you the parts that don't overlap for this new because you already asked me for the other stuff. Or you know, it's like a best effort. Like, should you do sort of a model? There might be other options, but I'm not sure we're there. 10. Ted Hardy personal opinion, I think the client won't always know that there's overlap. In what they requested. I think the simplest thing for us to do at this stage of the game is to say, it it the"
  },
  {
    "startTime": "01:24:02",
    "text": "The relay gives the client exactly what it asked for because it doesn't know why it asked for it. And at that point, if the client figures out, it's, in fact, getting duplicates it cancels one of the subscriptions in order to deep doop on its own. And if we discover there's some massive use case in the future, where that's not speedy enough or something else is, is needed, we can adjust then. But I would say for right now, that you just gave the client what it told you it wanted. And if it discovers that it's getting two copies of things because of the the way it asked the question in ranges, it cancels one of them to to to stop getting it after identifies the problem. That's certainly a simple option. Ted, can I clarify that so that you don't it's not you didn't want must should or may deduplicate, you want must not? I think Ted wants you get what you get, and you don't get upset. Yeah. You go. You go to bed. I don't think you even need a 2019 language for that. It's like, I told you, give me x and xplusy. And the fact that you get 2x and you get halfway direction, like, Oh, I got Ex already. I can stop this and move on to just asking for why. That's up to you. No. No. Ted Ted, you you you said must not for 1. That's that's not. You didn't say it silent. You said must not is what your choice if if you absolutely insist that there be ROC 2019 language, then must not is the best match. Must not, Paul. No. You won't. Okay. So interesting. I could live with what Ted just said. But it was not at all what I was thinking. So I think that the answer is different for Live Edge versus material that is, I'm gonna call it cash, but old. And what I was gonna propose is that you should deduplicate on I only put should because I think there's race conditions with making it impossible to fully duty if if if if"
  },
  {
    "startTime": "01:26:04",
    "text": "de duplicate. So you should deduplicate on the live edge. But you, what should you should do what Ted was saying must not deduplicate on when you're requesting old stuff that's being cashed because you're actually explicitly requesting something old because you're trying to recover it for some reason that you cost it. And whatever we do on this design, you know, I know we can't have a design that requires the relays to keep track of everything the client ever received. That's that's one thing that we we definitely don't wanna do at that level of state management. So I think within those constraints, we sort of need to figure out the right thing there. So my proposal was, LiveVedge, you, you, you, dupe. And if there's anything that you're pulling out of the cash, you don't need to. Colin may I ask you a clarifying question? What is the differentiation between those two points. It's whether the subscribe arrived before the object or not. So when the subscribe when you say I'm subscribing to group 1000 forward. Or object 1000 forward. And the current object is, at 1200. Sure. 1000 to 1200 are cashed. But, you know, when the but the subscribe arrived before object 12,001 arrived in your relay. On those objects that come on the relay, you look at all your I mean, if you if you look at a relay implementation, It's got a subscription comes in, it goes, Hey. Do I have a bunch of my stuff in my cache that matches this? If so, I need to decide to send that or not send it. And I'd not I would want it not be trying to guess what it had sent in the past when it made that decision. And then it's also it's like, okay. And I'm gonna add the subscribe to some sort of table. And when a new object arrives, I'm gonna run through my table and figure who I need to forward it And at that point, I'd be like, oh, if I if 3 of my entries in my table I need to forward it to to"
  },
  {
    "startTime": "01:28:01",
    "text": "connection or session or something. I don't know the right word to use here. X Steve. Steve. I need to forward to Steve. I wouldn't forward 3 copies. I'd only forward one one copy, but only on the things coming in. So that's that's sort of how I think about it because it seems to be it meets the use cases of not using bandwidth on the live edge. But again, I could live with what you know, you know, Ted said. And it allows you to do something as an application like you realize you lost something for some reason, a networking error or whatever else, and you have a chance going back and getting it, even though it might have been sent. The relay thinks it sent it to you for. You just didn't get Thanks. I appreciate the that seems a very, like, a very reasonable distinction and, like, a totally, like, one that we can write up if if we decide to go to that threshold. Like, for clarifying. Look, Hello. So, I wanna clarify the Relay cash filling example. So let's say they really has an empty cache viewer comes in and asks for the latest object. Our latest group. And then a short, like, few milliseconds later to get somebody else's give me 2 back. And so you have to make a second subscription upstream And then a new viewer comes and says, give me starting from group 60. You're like, okay. Well, that's not fulfilled by either those previous few subscriptions. I have to make third one upstream. And the problem is if that upstream request goes all the way through and you end up getting 3 copies of the object, That doesn't matter that much in the CDN, but it matters a lot for the first hop. You might have somebody broadcasting on their phone, and then all of a sudden they get resubscribe all at once that all overlap. Like, it that's almost that's a should be due. That's it. That almost not a must but Otherwise, you're just gonna be you're just gonna be congested. You're gonna have viewers able to cause, you know, like, viewers joining a stream will basically cause, too much bandwidth on the uplink side. So think we need the I do think that needs to be"
  },
  {
    "startTime": "01:30:00",
    "text": "and opt in, like, using the same track ID or something. I'm not sure why you would ever want separate copies. Of something other than so Relay doesn't have to remember everything. Hey. But, yeah, clarifying question, Luke. So you're envisioning a case when the subscriber on a single connection is describing, say, to the source. But doesn't No. Like, needs multiple subscriptions that might overlap. Trying to tease this out. A little bit of They basically having multiple a link. Oh, not lost you. Just a congested linker or potentially I don't wanna burst. Like, I don't wanna have to deliver the same ice frame 3 times. Because it's just gonna cause user experience issues over suggested links. No. Totally here, but I was just curious, like, why the client or, sorry, why the subscriber would having these overlapping solutions in this particular use case. Mean, you can have a stream and Twitch, for example, has 0 viewers then the first three viewers during the stream, if they don't have an if they don't overlap, we would fit from the viewer at the same time Yeah. X. Sure. Go for it. Here in the discussions, when I that I thought that's the best solution. And I want to support it. Then I heard colon. I thought that's the better solution. Than that. After hearing Luke, I see we need to support that too. So this this is my my my proposal here. It's s for all the three. So So so the use case is the relay on which knows 2 things, which knows the types that's coming from the, endpoints, and it also knows its current cash date this current language for the crack. It can make a smarter decision when it asks to the up up upstream relay, and it can basically they're they're the DTPs needed."
  },
  {
    "startTime": "01:32:04",
    "text": "I think we can add something in the subscribe request to explicitly say that. You know, sending you multiple requests. Right now, I don't know my current state. The state of what looks at is that my cache is empty. I don't know what would happen. In that case, state of the relay since it does not know, it can basically ask saying that, give me I don't, give me, but with, did you enable But for the client on the other side, which that the endpoint client, it If it's asking for duplicates, it wants duplicates. And it it should be given that. I think if we add along with the location or the hints that we have, an indicator that says how the relay or the upstream relay should be should serve the data. That would clarify these use cases. You next time? About to lock the queue. So if you think you're about to have an opinion on the sleep in now, Alan Gonzalez. So I wanted to say that it's challenging to know when things are going to overlap because we have so many different ways to ask of things. And so now we do. Right now. And and and the second point here about then you need to give me some information and subscribe. Okay? Cause if you ask for something relative, maybe subscribe. Okay. It should have the translation into absolute terms. Because you need that information to know even what matched your subscribe at all. Like I would support that, and I think probably that's a reasonable change, but, like, if let's assume that exists. No. I think, I mean, I'm in favor of in not sending duplicates when we don't need to. So I think, like, at least in May in there that, like, you can deduplicate as long as everybody gets what they asked for. And if the client library has to be like, oh, I got one thing in, and I had 3"
  },
  {
    "startTime": "01:34:01",
    "text": "different subscribers that made this API call. I need to go each give them a It doesn't need I don't even have to copy the data. I can just give them a handle to the same object. That that's fine, but we just have to make sure that the mechanism's there for that to work. So just for everyone to clarify, that means that a subscriber needs to kind of debunks and basically dispatch, like, based on track ID, to multiple subscriptions that have that track ID. Well, it wouldn't be the track. It would be the object and group because they all have the same track ID. Right. Yep. Yeah. Sorry. It was. Yep. So I think we really want the determinism that if a client asks for something that the relay gives it what it asks for. The the the notion of a client asking for overlapping or duplicate stuff is gonna be an edge case. The use case of a relay having multiple incoming requests, as Lucas pointed out, and going forward or upstream That's the normal case But the Relay's job is to aggregate. It has to intelligently de dupe those requests and make one request upstream that satisfies all of them, or is few requests upstream as possible. So I think the system breaks if we have these complex rules about is it the live edge, or is it not? It should simply be you I ask for something you give it to me and a relay has to be smart about dedooping. Otherwise, it's gonna flood the origin, and then it's a bad relay. Who's who's last making? Jonathan. Yep. You guys able to hear me okay? Yes. Yep. Okay. Great. So, apologize if this is not in scope for this use case, but one of the cases where we do want duplicate delivery is when we're if we wanna support, make before you break hand off of a of a conference call and, between 2 relays. This is like a common case where, like, a call is sort of our or most participants are associated with relay 1, and we wanna really want to have a service,"
  },
  {
    "startTime": "01:36:01",
    "text": "and we wanna transition it to relay to and and push clients to reconnect where you if you really want truly gapless and real time, always live edge not waiting and delayed. You're gonna support duplicate delivery. Thank you. I'd like to an individual, give my 10 seconds about. We'll just say that and HTTP, like, CDNs, commonly, you know, do this all the time and try to figure out, like, how to, like, reduce the number of requests going to origins. This seems like a problem we've solved quite a few times. I'm inclined to not try to solve it at the transport layer because it seems scary. And complicated and that would imply Ted's direction, but that's a personal opinion. But, yeah, this is definitely not a This is not a new problem. Let's put it that way. Yeah, do we have enough direction to move this forward or do we do the table Colin, I'm behind the Cuba. I'm out. Yeah. I would say a really quick comment here is Having heard this whole discussion, I've moved to, I think, that for the this ver like, the upcoming version of the draft, we should go with Ted solution. It is by far the easiest to specify and implement. If we learn it doesn't, it meets Luke's use case. And if we learn it, doesn't work, like Well, let's fix it. Right? But it's the simplest baseline. Right? So I'm, I'm, I this conversation has changed my mind where we should be. You very much. That's exactly my thought too is, like, if we need more, we can do more. End. But for now, if that's enough, it's We'll find out. Can I make a comment on that? Of course. So if we if we go to must not deduplicate, then I think we just killed track name alias slash track ID. Replaced it with subscription ID. That's what they had. I was just supposed to say that out loud."
  },
  {
    "startTime": "01:38:01",
    "text": "Okay. I didn't say that. I'll talk to you offline. Okay. Alright. Maybe not 10 disagrees. Think about it. I don't think I think we could table that for another day because, like, we just made really good progress, and I'd like to like, avoid, like, stealing our thunder. I do. There's a note taker question. It's alright, boss. Yes. I think, the summary is that when you subscribe to something. The intent is to receive everything that you subscribe to. Even if there are duplicates. And I think that means that Things should be returned I guess it's just in there. Okay. Iran. Yes. Like, e. You subscribe twice for the exact same thing, you will get copy so that I was gonna say something else, but it's not relevant. So was making a further inference. So it's not result. Alright. I was just Okay. Updating a substitution. And point update an open subscription for the same Check name, subscribe ID, and change other things. The perk is it's transactional? And it's potentially possible optimized work. The negative is it's a whole new thing. And we already have unsubscribe and subscribe, and they're already on a control stream. There's also a question I have about threat models because this is not so similar from the recent HP 2 like, issues where, like, I can just issue, like, you know, update update update endlessly and, like, I don't know. I'm not really sure"
  },
  {
    "startTime": "01:40:03",
    "text": "In a few minutes, I can come up with a way that if I can use that pretty well. So Might not be ideal. So People have that's pains. Yes, no. If we're okay with unsubscribe and subscribe for now, we can leave it as that and then decide if we have problems later. That would be my tentative proposal as an editor. But I'd like people's thoughts. Oh. Oh. See who else was in and then you left. Oh, the queues. Oh, Ted the, on the queue. If I can figure out how Ted locked the queue and then Oh, I'm sorry. Is it still luck? I It was. I I am luck a pretty it's a pretty cool move. I really brought was locked from before. So because we we now know that you can have duplicate subscribed. I believe it should be possible to do 2 subscribes and then an unsubscribe in order to get the updated subscribe message. Updated subscribe that you want. And still meet Jonathan's use case of being able to do a make before break. So I think I don't think it's meaningfully different at this point from unsubscribe plus subscribe, but you might do subscribe unsubscribe. Answer answer Yeah. Might do subscribe. Subscribe. Unsubscribe the first subscribe in order to get the update. With and make before break. And and I promise I haven't been day drinking despite the fact that is probably cheaper. Thank you, Dev. Julius scrubber check, that looks just looking at it. It's like this it looks like it's something that is trivial to implement and can avoid unexpected race conditions. So I would say unless it turns out to be difficult to implement keep it in."
  },
  {
    "startTime": "01:42:01",
    "text": "Can you clarify? So unless, update can you clarify what you're suggesting Webster Realty. But I just wanna make sure I understand Okay. That, implementing updating the subscription in the relay is not complicated. It doesn't, I mean, Something can happen, but it doesn't look like something that's complicated. It's a small amount of easy to debug code we might have it in the protocol. On the other hand, not having it and using unsubscribe tribe, might lead to race conditions. That might be complex to the bug that complicates life. Oh, thank you. Can I just interject? Because the slide mentions conditions. Yes. And I put that there. So updating a subscription is Racy with Scribe Finn because I there could be the subscription could have ended, and that thing could be on the way. And then I send an update then I get the thin. But the Fin doesn't tell me since it has the same subscription ID, doesn't tell me if it was the old thing that fined or the new thing. But the 10 solution of subscribe, subscribe, unsubscribe does that problem. Or vented or vented. Lucas or Luke first and then Lucas. Oh, sorry about that. I apologize. Oh, Luke. Yeah. No. I think we should I I think this actually bleeds into the Doop discussion a little bit. The the main benefit of updating a subscription is you keep any state around, like, which objects you've already It decided or skipped over. And I think I I I've had you could probably do it correctly, but I'm a little worried that subscribe, subscribe, unsubscribe, either send you too many objects or you miss or there's a gap or something. Like, I do think that because there's an RTT difference between the subscriber and publisher, it's really hard to do a clean handoff. And resubscribe is a way of doing that clean handoff. Oh, Lucas. Hi, Lucas Pardu, Clyde Flat. You you mentioned HP 2."
  },
  {
    "startTime": "01:44:03",
    "text": "Gonna admit, I'm not that familiar with this draft. So, but is there a limit to subscribe So, like, We have a slide on that. That slide. Concern is mitigated about of of rapid unsubscribes and subscribers is mitigated by limits. So I'll let you go into that one. Yeah. There will be And and that slide describe the mechanism for updating that limit? It proposes a mechanism that's basically identical quick would work. Okay. Cool. Thank you for for sharing my slides. Or, actually. Tell him this counts. Tell him. I I don't have super strong arguments one way or another on this. But my very much gut feeling is that the being able to update an existing description is going to be easier to deal with all of the, the edge cases. So I think I would lean that direction right now. Like, allowing the update. Thanks. Sures. My proposal is also to kind of follow subscribe updates because if I if if I think about Relay implementation, the code path that takes to unsubscribe is more involved than the code that would take off data and subscribe description wherein I I would basically operate my cash pointers. On stream with an update versus its unsubscribe basically go start cleaning up all the straightforward. And if, if the I I totally agree on the case where, subscribe a bit went the stream was finished with publisher, the subscribe update should get an error back. That's the only way. Either I it they might they might race with each other, publishing, the subscriber knows either if it's a or, error. 1 of those things might come under has to give up on that point, at that point in time. So my proposal will be to go to option 1 there. Well, You are sorry about this. It means early. Just I I'm also a fan of updating the subscription. It doesn't seem that complex. However,"
  },
  {
    "startTime": "01:46:02",
    "text": "is the client expecting some notification in the objects such as track ID to change to indicate that these objects are the result of the updated subscription, or can the same track ID if or alias be used. I think that's a great question, actually. I think it's a very reasonable suggestion change the subscription ID because that would actually fix, I think, a few problems. I think that means that an update is an implicit subscribe, subscribe, unsubscribe. It's it's a 2 phase commit. The same as the Subscriber scrap up the Yeah. Okay. Yeah. You know, Alright. For running into it, but I think we're heading in the same direction. I guess one question I would have if everyone is is this something where we want to say we think we probably want this but we don't want it in the next draft because at this point, we haven't had a lot of interoperating with the newest version of subscribe notes. Like, is this a Why don't we say we think we want this right up later, or do we wanna write up the draft in the next rep. Can someone give me a strong opinion that I'm not I don't know strong or not, but I would say writing in draft does not mean that we have to work on and drop for that. Intrope, we can basically say we work on subscribe and unsubscribe. That's it as the interrupt goals, but, draft is for defining the protocol. We should if you're clear on what we need to do, we should, start making a work on that. That would be my may attend to like to put things in the draft that I think people are gonna write code for because ones, we don't get feedback, but whether it works We've done that before. Awkward. Look, Yeah. I'll I'll just say this is easy enough that we can get some interrupt on it. I at least I can implement this. So Let's let's try to throw out some text on this."
  },
  {
    "startTime": "01:48:02",
    "text": "And do a reasonable job of it, and we'll see what happens. And, get feedback. Thank you. That's extraordinary helpful. So the answers we are going to in time to add an update, subscribe, message, I believe. Movies And people believe is relatively straightforward to everyone, which I think is probably Most leisure. And we'll get some implementation experience, hopefully. Great. So all those solutions could cause resource suggestion Lucas, your slide. Yeah. So the TLDR is, you know, once we have subscribed IDs, then we can, you know, make the monotonically increasing, and then we can have max, subscribe ID, and then it's basically just like quick streams all over again. And, we don't have to reinvent the new mechanism we have the mechanism we've used a fair amount. It seems to work certainly better than the equivalent HP 2 mechanism. On restoring experience. Any objections to this? Any thoughts? Sorry, man. My client died. I can do, you know, huge wheels. I lose Oh, well, there's that too. Alright. Yeah. So does web prints not have a a some sort of stream opening limit? That that that that we can leverage here. See what led trans? It it does, but, subscriptions and streams are not tightly correlated. For example, depending on how the object model is, One could have say like a 1,000,000,000 streams that one goes through for a single subscription. Because if you use a script stream for object. Yeah. So they're they're not just This, like, got it. Yeah. Yeah. Now Thank you. we're good. Hey, Lucas Pardo. Limits a great"
  },
  {
    "startTime": "01:50:01",
    "text": "any question that raises with me, what are the different limits across the different hops and intermediaries and what happens when they don't align you know, I mean, I think that's a great question. That's number 2. There's also the question of what happens if you don't have enough bandwidth, what happens if you don't have enough max streams. What happens if you like, a number of resource limits, and and we've really not touched on almost any of that at this point. I think it's a really complex, an interesting question that probably spend like a whole another year on. Once we get this all I think we're I think we're hunting on that. Fine. If if we just put it in a bucket of resource limits to worry about. I I think I think we probably should have a better text that kind of panned waves over it, but I'd I think we're not at the point where we can really prescribe, like, a serious solution, but I think it's enormously important and complex problem. Okay. That sounds good. I mean, that's fine for me. Well, So I'm a fan of the limit, but is it a absolute cumulative limit, or is it a concurrent subscribe limit. It would work like quick stream eddies where, like, your subscribe ID is monotonically increasing. Right. So that's an absolute it's an absolute limit over time, but at the browser layer, it for web transport, we've converted it to a concurrent stream because that's what the cares about. And I'm wondering, do we we do the same here because under the covers, max streams is absolute, but do we care about the number of concurrence grades, or just the fact that if if I've said it to 10, and I've used 10 over the last day. I can't open another one. I think I mean, I'm fairly sure this is just a matter of, like, the peer would give you more subscribed IDs."
  },
  {
    "startTime": "01:52:00",
    "text": "As you close old ones. Just, like, in quick, like, as you close dreams, presumably the peer would be expected. If it's it's trying to maintain 100 open streams on average. It would send you like, a new mass of gravity message. You know, feel free to go back to the mic if you'd like Yeah. I apologize. And we have this, as you mentioned, which to maintain a 100 open at any one time, and we do it by incrementing an absolute count. Which is a contrived way. Why not just say is a 100 open? And manage that and do what you have to with absolute counts under the covers. I I think our, like, there have been a number of recent issues with HP 2, which uses exactly that mechanism. And though it is possible to defend against terrorist attacks against that, it's it's quite annoying. And myth. Manually incrementing the subscribe ID or manually incrementing a stream ID does 2 things. It both limits the maximum number of simultaneous subscriptions, streams, whatever the resources as well as limits the rate of an increase in that resource. At the same time. So it gives the peer the opportunity to do both simultaneously the single mechanism. Yeah. Be my statement. That's a good argument. I'd buy it. Thanks. Sorry. Like, hearing the discussion, think this would be like the hardest PR if I can, say, because at the end of the day, does not matter what the max subscribers is. It basically matched to can that max subsubsubscribe ID when it down to the stream resources can that be supported or not. You might just have one subscriber ID and have all the stream resources to take in a way if someone sends, like, every bite of his chat message on his own stream. It can be done. So I'm I'm not against the limit, but when we write it, we need to kinda think how do we want to"
  },
  {
    "startTime": "01:54:02",
    "text": "kind of be dynamically, just this one. I think you can handle it, though. Yeah. No. I agree. I mean, this goes back to Lewis's point that, like, there's a number of ways resources could be limited in the system and we don't really have text on almost any of them in in part of it because I think In my opinion, we don't have quite enough implementation experience to really break Texas but we're probably not gonna write normative text anyway. I'm not really Anyway, well, I guess you're up. Just time check. We're 5 minutes, 7 minutes from the end here. And there's one more slide on who takes the track ID. So, like, hustle through. What I like to say if you'd only have a minute save it for the last minute. It only takes a So You just wasted 20 seconds. So when I first read this, I thought you were talking about MAC subscribe IDs. For a given track when I read the issue, it seems like it's talking about a global thing unrelated to that. How many so you could ask for 10 tracks and still subscribe ID is limiting whether you can get 10 tracks or not. It's a session level. The resource, I'm then I'm very confused about the resource you're trying to protect because I could I could do another session. Right? And so what what resource are you trying to protect that you couldn't bypass that limit by by doing another thing. That's that's legal. I mean, certainly if the at the limit, like, these things all require memory, potentially stream connections, like other things and so one could imagine a situation where subscriber does not have the bandwidth streams whatever resources to deliver all those subscriptions as asking for and ask for, like, an enormous number of subscription. So, like, That's an example. I don't know. I'm other people can contribute. That's Well, I actually thought that would be a better use case for having this on a particular track. What it makes sense to have a 1000 subscriptions on one track whereas having a 1000 subscriptions outstanding period, may not may not be an unreasonable thing."
  },
  {
    "startTime": "01:56:00",
    "text": "Colonial. Yeah. Yeah. I think the limit we need to enforce is the max some number of concurrent, subscribes that are open the session at any point in time. Now that said, if we do it through if this is the syntax and way of doing it, I can I can live with that? I can see it. But the I I I don't I think this is somewhat different than a lot of the HSP cases because so many of these sessions will be, like, long lived, like months. Type thing, and we'll be doing a crapload of subscribe and unsubscribe So but I think in the end, as long as there's some way of enforcing a concurrent mechanism and for the client to be able to clearly understand what that maximum is. But that's the the key thing and all the rest of, like, how we organize the bits, the the deck chairs. On the wire to get to that point. I don't care. Yep. Thanks. Lucas, you're back? Yeah. To to say, what what's what's coming out to me that, yes, this is all about concurrency, but it doesn't sound like it at all. And for people who write APIs, like, w three c or people who write libraries, we model it in terms of a currency to make it easier for users, but at the wire level in the protocol, we're using this because this is a much better way than saying there's this this limit that is basically a bucket of stuff that goes in and out rapidly and you can pack a single packet with hundreds of messages that cause kind of work to be done that's pointless. And that's what we're trying impact from. So I'm volunteering to help with the text on this when you get to it. Oh, yeah. It's wonderful. Thank you. Terry. Hi, Charlie. Think that we should, use limits always. And this, this seems more that needs to be concurrent because, because the subscribers uses memory. And what we want, subscribers and announce, I see the the, the next question uses memory, and we need to protect that memory. And I think this could be more like a protection against an attack. So put this level"
  },
  {
    "startTime": "01:58:00",
    "text": "put this maximum into a reasonable number, And then, and then, and then, we can handle the load and load balance we can talk about, that in another session. Yeah. Yeah. Okay. Thank you. Do we have One minute. Okay. Next slide. Alright. There's a proposal to rename track ID to track name Elias. Or Traculous, that seems plausible, just to make it clear that is a compression scheme but now that everyone has everything has a scribe ID, and we're going to deliver everything in duplicate what is the track ID exactly or track name analyst? Actually doing Questions? Oh, my house and opinion. We got a yes. Yeah. I'm not sure if we got a chance to read what was on the slide before you put that Yeah. The name, what, that may influence the number of no opinions. Alright. So, yeah, I'd I'd love to go back here. This is sort of a funny waste of time, but could we go to slide. Uh-uh tried to kill it. Don't know if successful. But, yeah, the the the the Yeah. Slide does actually, talk about the change to, allowing for a subscriber for an ultimate ID at the publisher once in. So, So I I mean, I I I'm strongly in favor of us going and doing this. So I think would like, unblock a bunch of other things if we could get to this. So I'd you know, I'd I'd really like to try and I mean, may we need to discuss it later this week or whatever. Maybe we need more time, but"
  },
  {
    "startTime": "02:00:03",
    "text": "if people who have read this bug are okay with this or people don't care, I think the would be a big move forward if we could answer this question. It'd be nice. Yes. Luke. I think just to answer your question, and Alan's question earlier, what's different between Subscriberty and track name alias. It's publisher can choose. Subscribe ID has to be incremented by 1 every time for MAC subscribes. Whereas this alias, checking alias, it's just a VARIN. It's arbitrary. It could be a hash. So they're not the same thing and it still needs to exist. I'm gonna ask a challenging question in the working group and here check this. If you get duplicates for each. Like, you get an single copy of an object for every single subscriber ID which is the current model that we kind of, like, discussed earlier today. Does one deliver Like, are things associated to these subscribe ID or the object or the track ID. Like, how would you differentiate between, like, copy 1 and copy 2 of the same track. Yeah. That was the question I was asking earlier. Do we need to include scribe at the based on the must deduplicate must not do duplicate. Which sounded like it was the consensus. Don't you have to put the subscribe ID into the object message Yes. And then if you do, do you need both? You don't need the track ID at that point because it's just a lookup table. Would argue with that. That was why I was asked to work Sorry. Like, Ted, you want to say something, please? Well, so think it's actually 2 different pieces of information. And at this stage of the game, I think actually do want to keep them as 2 different pieces of information. Because if we don't, then the ability to change it in the future where we've discussed discovered that you know, our our way of doing the object model needs to to to shift, then we can't do it because we've now tied it to another piece of the the puzzle. So I would say at this stage of the game, should remain"
  },
  {
    "startTime": "02:02:01",
    "text": "2 different pieces of information. It's not much overhead and it's kind of a premature optimization to to make one implicit in the other. And if later, we find out that they really do turn out to be It's always the same bloody lookup table. We can take it out. But right now, I would argue leave it in. I I am am fine with that. We have the queue. Please lock the queue just in the interest of time because I know we're at time, but, well, Yeah. It was just asking this question, and you basically just addressed it, which was They may be different things and tactically, but what's the use case where they need to be different? And I heard Mo just mentioned wildcards, and maybe that's it. But if it's not wild cards, I really don't comprehend the use case where we need 22 different things that both increment every time make a new subscribe ID. And it my preference would be leave it out, and then add it back later if we find we've worked ourselves into a corner Thank you. Colin. Colin, some strongly in favor of 2 different things and not if anything to do with wild cards later, even if we ever try and deduplicate, We're gonna have 2 different subscribe IDs which are going to have to have the same track ID. And I think the important thing here is who chooses these things? The subscribe IDs are obviously in this incrementing very simple thing. The track IDs are much more flexible in how they're chosen. And in and we even have some control over which side shows chooses with this. And it might be that implementation, if if the full it might choose the track idea purely by trashing the full track name. In which case, they're going to end up with 2 different subscribes for the same full track name. We'll end up with the same track ID. You might have a different implementation that actually gave them different track IDs. And I I think that we just have to be okay with that. That that's how it works here. Is that that, you know, the track ID is an alias for a full track name that was negotiated and subscribed. And it has really nothing to do with the transaction ID for the subscribe. And I don't think we have to keep those separate or we're just gonna get into trouble"
  },
  {
    "startTime": "02:04:03",
    "text": "I think what you're noting is that if we're gonna keep both IDs, we probably should also have editorial text that, like, they're just different. And don't try to act like they're the same thing. Yeah. Yeah. One is a is a identifier for subscribed transaction, and the other one is a compression identifier for something that has actually nothing to do with the subscribe. It's a compression identifier for an object not even a subscribe message. It's for an object message. It just happened to be transported in a drive message. Cool. Thank you. Sure. Yep. Probably, I'm I'm going to repeat what Colin said. I'll be quick though. So when publisher publishes an object, the object belongs to a track. Not a subscription. Subscription ID or subscribe ID is of a transaction is in Hopayop thing, and, and, it it not may not have to be carried in the object because when the object come to the client. The client knows the object belongs to track and how to organize them and we don't have to have a subscription ID to for the client to tell how what object belongs to what subscription it all belongs to the same track. We are, the mock is about pops up on not on subscribers. So we need to have these 2 things as separate, semantic concepts. Yep. Look. One final wrench. If the subscribe ID is in the object, it's all you suggested the conclusion I I don't think publisher chooses make sense for the. Right? No. I I I I if I misspoke, if I suggested that anyway, that was not it. Track ID or track name alias is the only thing in object. Correct. That would be my error or anything. Sorry. Okay. So so byte for byte, the object for the 3 subscribers you have would be identical. Okay. So the answer is we're gonna do this. We're not gonna make any other changes and we're gonna see it once. Wonderful. Okay. That brings us to the end of today's session. We will see you again later in the week. Thanks everybody. It's been very Thank you."
  },
  {
    "startTime": "02:06:11",
    "text": "I think Helen ended up doing all the work because I think Lee provided on the chairs. I never saw him type. Oh, So the chocolate goes to her."
  }
]
