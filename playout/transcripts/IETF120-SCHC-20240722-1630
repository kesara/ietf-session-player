[
  {
    "startTime": "00:05:29",
    "text": "It's a very short document just asking for protocol type and an ether type Then the Chicago architecture will have 40 minutes to discuss it where we are, where we want to go So basically, it's more complex than we thought because we started sharing on a point to point a very specific type of connection, like Laura or SIGFAR And now we're extending that to shake over the internet And there are a number of questions about how this set up the context. And even there is the question of, is it really point to point or do we have point to multi-point or"
  },
  {
    "startTime": "00:06:02",
    "text": "internet. And there are a number of questions about how you set up the context. And even there is the question of, is it really point to point, or do we have point to multi points? Or a number of questions like this, which the architecture needs to address, which will not represent in its events 4 884 so that's for the work group documents. Access control is expired, I guess yes yes just one point on the she kiver zero energy devices, which is now, of course, with the new name that will be presented by Anna So we had a looking group at the call for the adoption, you know, that ran for two weeks before and then you know with the change introduced name, yes. And so we timed it so that the call, like the call for adoption ends now, like before this meeting and we only plus once so on this one i think we're good to, you know, we have it. It will be a non-seek adoption during the presentation for this document so chic of our PPP I guess this stored as well because it's done for its purpose. But it guess it will be revised once we have the architecture straight. So we can position the work within the architecture and maybe we will have to move things around and do things a bit differently just to fit better in the architecture It was maybe the first example where we did some shake of we will have to move things around and do things a bit differently just to fit better in the architecture. It was maybe the first example where we did some shake over the internet. So it opened some problem the chic over 154 also opened some prime to the original designs and once we have those things straight in the architecture, then we can, I guess, progress on the Shikovar PPP and completed fact, we don't have a presentation on fact today. So that's basically a nature that came up after the discussions with Bob. So using FEC, so for all our correction, as opposed to reactive error collection or in the chic fragmentation recovery And that's"
  },
  {
    "startTime": "00:08:02",
    "text": "pretty much it. So Loja, I will give you the mic okay so for OAM, we issues so two weeks ago, but it fails, so I issue it this morning so it's a little bit late, but it's version 4 of the draft. So we review almost all the all the documents to make it clear to have better explanation for the compression rule and the main part is that we remove the action part which make no consensus on the mailing list and so now we have I think a more consensable document that is doing ICMPV6 compression and introduce also to new CDA and two new matching operator to compress existing rules So I don't know what do we do now if we have to start a new working group adoption Well, I think, I mean, it was, we never actually closed the adoption call. We had the adoption call and we had all these, as you said, about discussions on the mailing list and we had this gray area. And thank you for actually going forward and removing the great item that were that we had this ongoing discussions. So I think that I mean, it is now you submitted a new version, then the proper thing to do is, you know, to continue the adoption call for two more weeks And then, you know, like, and we end the call and it can become a working item. Right. And especially the people that were like against the actions being there, you know, if they can say on the mailing list hey, it works for me now, like plus one, then"
  },
  {
    "startTime": "00:10:02",
    "text": "we know that it's all solved. And you can submit like after the age check, like two weeks from. Yes, I believe people's in time have a chance to look at the new documents, so it's a bit less to make a show of hands right now Let's let's do it on the mailing list If Lorenzo is listening, Lorenzo, there is effectively a huge difference in setting of volume between the people remote and the room. I mean, I could barely hear Lovenzo on the mic, so I had to push the volume on my PC And when Alex talked, it was like an explosion in my room. So yeah, please see if you can tune the volumes differently for in room and outside of the room Lorenzo, if you're asked. Any questions? for Lauren? Lauren? I'm hearing none. So, Lauren, please stay there and we Any question for Lauren? I'm hearing none. So, Lauren, please stay there and we'll move to the architecture discussion And thank you, Laura and for the other to the other authors of, you know, finding the way to move with the OAN draft so that's really that's really nice thank you Okay, so I will talk now about the architecture. So it's not only my work that has been done a lot of discussion between anna about sheep sheep here some yeah some equals mic is open it's okay it's okay pretty idea is to to review the architecture because it's a lot has been published long time ago and the goal if you can go to the next slide, Pascal slide pascal so it comes from the origin"
  },
  {
    "startTime": "00:12:01",
    "text": "of chic because at the origin it was developed the LP1 working group and so SHIC focused on an architecture but with generic and correspond to the different LP1 technologies but now we have to extend this so taken in, so we have the RFC AT 724 that gives the first architecture, then 86, 88, 20 that introduce also a different level of chic but that is not very precisely defined and we have also a young data model for the world and we have also to put this young data model into the the architecture so the goal of the document first is to remove the dependency to LP1 and have something that is self-under understandable with only chic. We are also to focus on new topologies so LP1 was almost a star topology We have six low, we have IPC where we have a mesh network under SHIC so we have to see out to under it. And as I say, before, we have boundaries that appears, but force us to have different level of SHIC so we have what we discovered in 8824 it's a cryptographical boundaries. It means that you have something that is in context and things that are encrypted. So you have to do the compression before the encryption We have also some element in the architecture that can to be placed at some location so we have these different things to take into account and of course to integrate the management and all that stop in the architecture So next slide, please So on the next slide we will have"
  },
  {
    "startTime": "00:14:02",
    "text": "missing something, okay, we have the the old architecture but was from 8724 where we have this strong dependency to have this strong dependency 121 by the name we have the device we have the application we have the network gateway and we have something that was not named in the architecture but implement the chic fragment reassembly and the chic compression decompression so now we are moving to something that is more agnostic to LP1 So the first thing is to introduce a element that was not named with LP1, it's what we call the Chic Network Gateway RSNG which is at the boundary between a chic network network on a non-sheek network so here we don't say IP because she can also appear, for example, at layer 2 with I don't know, for example, Wi-Fi Allo that wants to do compression and we have the regular network. So here we have something that is generic and is not focused on layer two or layer three So from this chic network gateway, we can define give a definition to a device, and we keep the name device because in the rule we have this name that appears So we have to continue to use it in the architecture and so the device is the element that do SHIC with the SHIC network gateway And at the other end of the network, we have the application and it's where the application is the entity the device talk with the application. So when you send packet, you have the anchor compressed part and the uncompressed part. So what we can define also is a chic instance. So the chic instance is"
  },
  {
    "startTime": "00:16:02",
    "text": "two endpoints that are implemented chic and share exactly the same set of wood so here we have this set of rules that is exactly share So then we can stack things and keep going on this definition. So on the blue part we have an instance that go to the SVN but we have a have also another endpoint that go directly to the application. So in that case, since we have name, can you go back back? Since we have named one part of device on the other part of the application, so we continue to name them device and device and application but very is cases, and that's the next slide where we don't have this chic network gateway in the middle so that's the case for example for six low where we are sending compressed packet over the network and maybe we don't go outside to go back to a regular IP or in IPSex or so where we are sending IP packets and these IP packets are carrying chic message so in that case we have to design what is a device what is not a device and here it's the end implementer that will say which is one and this is very important because this way we know what is up uplink and downlink traffic So now I will introduce something that is not so easy to to understand but make us the notation easier It's the fact that when we put a protocol name into parentheses, it means that we are doing the compression of this protocol and this is the result of the compression. So there is no details on the bits that are sent on the wire but say that we are in that case compressed protocol p1 p2 and p3 and they are"
  },
  {
    "startTime": "00:18:02",
    "text": "compressed by different instance of chic so if we had only one instance it will be parenthesis p1 p2 3 and other parentheses here the fact that we have three set of parentheses mean that we have three instances. And of course, it doesn't matter it doesn't explain what you have an the wire. For example, if you have a rule uh an instance where there is only one rule then you don't need a rule ID because there is no prime. And if your compression residue is no, it means that you will have zero bit on what you are sending. But in an abstract notation you are sending this protocol very very compressed so it's what this notation is represented So here, so here we introduce those terminology so we have the maybe I will let you read or I always explain all of that so we can go to the next time. Or you want me to read it So the new things we introduce in the architecture is we introduce a stratum because we didn't want to use layers because we think that layer is confusing because as I say at the beginning when you do compression for example you can compress IPV6 and udp using the same rule so you have two layers, IP and UDP VAT, compress the same way. And when you go to co-op or any encryption protocol, you have a plain text and you have something encrypt. So you need too chic to instance to do this And so if we stay using, if you continue to use the layer, maybe it's too confusing. So that's why we prefer to to propose stratum, so if you agree or not, you can"
  },
  {
    "startTime": "00:20:02",
    "text": "say to us. Alex? I see you're in the queue yes thank you all would you like for us to pose like to questions now or at the end of the presentation? I think you can interrupt me when you want Okay, yes. So yeah, I mean, one of the things is that said, yes, yes, of course, one of the things is that the architecture, like it's, it needs to be something like readable and understandable way everyone. So I imagine that also anyone in the public and also in the in the room can ask questions right? So I have a particular question that we discussed before. So I think this is the right time. So on the previous slide, when you talk about shikins instance uh you know right until now, it's like too chic end points. Like the chic end points are the the pieces of software let's say that are doing the chic manner on the different devices, right? And so the chic instance is the thing that is, you know, covering these two endpoints right And one use case that came up actually pretty very recently is, the multicast, right? So we have in Laura 1 and in DLMS in particular, we have a point to multi-point multicast and it's like standardized in several places. So do you feel that we need to really focus on two chicken points? or you know should we frame it as like two or more and then in the document say well of course, when you have more than two chic endpoints? there may be there other set of problems that are there so probably you know we need to treat them different and I mean this question to you and maybe you can also see the public, the people in the room as well right yes from my point of view it's better to insist on the fact that we have a point-to-point association, because it's really the"
  },
  {
    "startTime": "00:22:02",
    "text": "way Chic is working And so there is two answer to your questions the first one is that if we have multicast in all the cases the source address is not the same for all the notes. So normally, it may that you have different rules to manage the multicast even if you have a multicast address as there destination. So this is first thing. Then maybe we can have some places where we will have the same set of rules for different elements because you are not sending this or ignoring the same kind of information but I think it's better to keep this point-to-point association because this is really the fundamental logic logic to keep this point-to-point association because this really the fundamental issue. So Pascal, I don't see all the queue, so Pascal Yes I think do I say we should in the instance allow for multiple endpoints but describe first exactly as you say how the point-to-point works and then have a specific sections on if you are doing point-to-multipoint, here is what happened is it just point to multi-points do you have multi-point to point do you have multi-point to point How do you point to point and then point to multi point? which now is a multicast? So, and what does it mean? what does it mean in all those cases? The idea being to be, able to retrofit multipoint to points and point to multi point back into the view for each device of a point-to-point. I mean, if the device, for instance, the device, if you do point to multi point, there is once source and multiple receivers but the destination is the multicaskope. If you're just doing,"
  },
  {
    "startTime": "00:24:02",
    "text": "that, I mean, the devices on the other hand, they see a point-to-point conversation. They don't really rely they are receiving a firm update over the air, for instance. That is this distributed to more than one device. They don't see it. If you can say, hey, we define point to point very clearly, every detail, and after that, we go and explain how that can be extended to point to multi-point. I mean, I don't think the architecture should bar it at this point this point last last Basquitz, last night in the hot RFC there's a presentation on the multi port problem, stuart cheshire, the thread work on the multi-cast port, um, um, um, um, um, um, stuart cheshire, the thread, um, work that he's doing. And I look at that, and that's a perfect application of Sheik in a multi-point environment And so we have a specific use case that we can look at and instead of the complex of yet another set of solutions that that effort hackathon efforts introduced say this can be handled through a sheet crew, I believe, I think. So I think it'll be good action hackathon efforts introducing, say, this can be handled through a she crew, I believe, I think. So I think it'll be good exercise for us to look at that work and say, could this be done with Sheik and a cell present? as a counterpoint to that work? and and there is thus your specific uh case for multi-point to move forward forward So yeah, I agree, so that's a good exercise to do So for me, the two things that if we have multi- it doesn't mean that we have the same role because some variables are not the same for all the packets. The second thing is that we have also management and management is a way to synchronize rules together and in point-to-point is quite easy to maintain because we have to be sure about the atomicity of both ends if we are in a case where"
  },
  {
    "startTime": "00:26:01",
    "text": "we have several nodes to synchronize, I think the protocol will be much more complex and it's something we don't have any solution right now So for me, it's better to start with point to points and maybe study how the impact of multipoints on it don't have any solution right now. So for me, it's better to start with point-to-points and maybe study how the impact of multipoints are on it. Lauren I think I said something very similar to what you said, it's just that the difference is let us in my view and I guess Alex as well let us solo the instance to be between multipoint or let's define something over the instance when it's pointing the difference is, let us, in my view, and I guess Alex as well, let us follow the instance to be between multipoint or let's define something over the instance when it's point to multi points, like a multi instance or something And then keep the document exactly like it is the explanations exactly like they are but then have a section for multicast, even if it says a hey, it's going to be another document. But, but something which says, hey, it will be part of it in the end we have to look at there are number of rams be another document but but something which says hey it will be part of it in the end we have to look at there are number of problems maybe in this document we just expose what those problems are or maybe if they are not too big, we just work on them. But I'm like Bob and alex i don't think we should buy it document we just expose what those parameters are, or maybe if they are not too big, we just work on them. But I'm like Bob and Alex, I don't think we should borrow it from our definitions Hi so yeah, so my understanding is that we really have this assumption that it's a communication between two endpoints and that we understand exactly what is the data transitioned between those two ends endpoints. I think it's nice to keep it this way and not to make it more complex because one of the things we went to even if we don't talk multicast but uh you don't say it's a end point where you assume you know what is being provided by one end endpoint to the other one, is that if you"
  },
  {
    "startTime": "00:28:01",
    "text": "think about traffic and you compress that traffic but you know you end up in a chic packet but there is a underlying assumption that the incoming packet is not already a chic packet Because if someone can sense a chic packet, you have two states that are of the same name And this is something we don't want, I mean, it can easily have if we get out of this end to point communication. So I'd don't think we should start boiling the ocean about that But I think it's really important to to keep in mind that when we say it's end to point, it also means we really understand what the communication is about And it's probably sufficiently complex with that Thank you I mean, that's just my personal Okay okay, so maybe just also for interest of time So I think that there are two, there are, obviously something into it. So probably maybe we need to add another name to that or something like to say, okay, this is a point-to-point instance or something. But maybe we should move that to the mailing list, but I think it's really important and also for this architect document and this is the type of this discussion that I think is really important. And thank you very much, Laura Hoff, for bringing all these things here. You know that we have this discussion and with this awareness of, okay, like we are choosing really how to name things, and it's really important that we get these names correct because like concepts that that finally structured the whole work so yeah and very very interesting comments thank you Okay, so let me continue and produce what we"
  },
  {
    "startTime": "00:30:01",
    "text": "need, why we need. So what we will call a stratum instance. So here is an example. So I don't say our IPSEC compression be used that we are stratum instance so here is an example so I don't say our IPSEC compression we use that we will have a presentation just after it's just an architecture point of view. But say for example here you have a device that send IPSEC messages to an application so here we see with the parentheses notation that we have a first compression of the with the next stop that say is chick and then you have the outer and inner IPC secator that are compressed and then you have the data so on the next slide we go to the network, Pascal, if you can go to the next slide. So in that case, so we have uncompressed the first part. So now we have an IP packet, the real IP packet that's the next step is chic and this way when the packet arrives to the application, it can be managed by the chic machine to do the amp compression but the problem is that we don't know exactly what is the upper layer protocol of course we have IPSEC in the rule but it doesn't tell us how to link it so we have either to analyze the rule and say, oh, it's IPSEC, or to put one information in the rule that says the next data is IPSEC. But that's complex. So what we, next slide, please what we propose to do is to add the stratometer that is something specific that use SHIC. And here we will put an information like the upper layer protocol is IPSEC so when we do the compression, so next slide, we still sending an IP packet on the internet, say the next iteration, it arrived to the application. So the application takes all the chic part. So first"
  },
  {
    "startTime": "00:32:02",
    "text": "decompress the first element and learn that the upper layer is IPSEC And then we'll do the decompression of the over layer and so we will have a regular path so So next slide please so this way we can put in IP the fact that is no more chic it's IPSEC so it's a little bit like in IPSEC when you are pointing to IPSEC protocol and then inside IPSEC you say what is a real next header So what we propose to do on the next slide is to make this present all the time, even if there is no bit, I remind you about when you have something in parentheses, maybe there is no bit on the way on the next slide is to make this present all the time, even if there is no bit, I remind you that when you have something in parentheses, maybe there is no bit on the wire, so no impact, is that before each instance, we add a stratum instance that will help us to carry some information that are needed to manage just chic process Okay, next slide so here is an overview in the 3d about the same thing So we have the endpoints in different color that the compression for all the protocol and before that, in red, we have the schick stratum instance that carries some signaling information for Schick And so an endpoint and a Schwarzatom schick stratum instance that carries some signaling information for for shik and so an endpoint and a schick stratum endpoint make our instance sorry make the next slide, make an instance So it's what we have normally on the next side So we have these blocks, but are now what we will manipulate in in shik. So next slide So here is what you find in the draught There is a mistake here. It should be a chic instance and point You're talking about it. Excuse me. There is the question on the discussion about what is the difference between an instance and stratum. So"
  },
  {
    "startTime": "00:34:02",
    "text": "I kind of answered on the chat but it seems there is this confusion, maybe we should explain again a little bit what the instance versus what the stratum is. So a stratum is the group of chic instance, one that is a chic stratum instance, that is for management, and a chic instance that is here to compress or fragment chic as usual so stratum is the combination of this two elements but the instance is this, quote and quote, sessions between session between two and points whereas the and points whereas the stratum is is more like what the layer would do like dispatch, understand what's going on et cetera, et cetera, so one is more more a layer, that's the stratum, and the instances is more like A is talking to B. So it's this relation between A and B Stratum is a location in an architecture architecture Instance is something active where two people are talking to Okay, so we asked to some example after, but very stratum is a block that we are manipulating and is composed of Shika stance and a chic stratum instance So maybe the chic stratum instance is empty but it could be here so the first thing we before going more in detail into stratum, so we introduce also something so the name is not that nice but we call it discriminator and it's when you receive a packet, a chic packet, you have to find to which the stratum in instance you have to send a packet so it's external information. No, we have a question Sorry? Yeah, Antoine which certain instance you have to send a packet. So it's external information. We have a queue. Hmm? Sorry? Yeah. We have a queue. Yeah"
  },
  {
    "startTime": "00:36:02",
    "text": "was Bob. Bob is count. Okay he's back. And then there is Antoine. I just want to say that in a sense this is not a new issue. We had this when we were even looking at DTLS and that inside the DTLS, what compression we have having versus the compression outside of DTLS So this is really not something new to deal with It's just that now with Ivy Second few others we now have more it's becoming more apparent on that that we needed clarification That's all I wanted to say that I was already looking at how is going to do this before so so for informing presentation point of view it's very easy to do because you have always the same mechanism, you are just pointing to a different set of work right exactly just one a different set of rules and whatever love you are at so it's it you know it you're clear clarifying the nomenclature and the architecture, but this is not something that we're just something we were already were doing, is all I wanted to say I had a question regarding the stratum instance and instances So in a stratum, you have instances that are like the data layer and the stratum instance which is sort of management layer. Is the stratum instance common to save instances because in the terminology before you say that an instance is point to point So do you have a couple of instances, strata instance? before you say that an instance is point to point so do you have a couple of instance for point to point to or you have a shared stratum instance that distributes the management information? whatever the instances that belong to a stratum So it's still a point-to-point association. So you can add stratum instance that distributes the management information whatever the instances that belong to a stratum so it's still a point-to-point association so you can maybe pascal can you go on the next slide? There is a drawing"
  },
  {
    "startTime": "00:38:02",
    "text": "and no next two more next. So maybe if it's comes next, I can't let you control. So this one, for example I don't know if it will be clear, but you have for example, in the right and part, of the slide. So you have, for example, some chic instance but are for example electrical meter but are using a non-IP technology to send the information to a concentrator and this concentrator is sending an IP. The SHIC messages. So what the SHIC strategy instance is doing is to add some information to identify which the sender. And so it's the red part. And when you arrive on the other end on the red part so you know using the instance AD that is sent, that you are able to identify which upper layer you have so you have so you so you have one in this case for instance uh you have the concentrator, in fact, in the concentrator case you have a tree structure so it's quite easy but for instance you have the concentrator sending to two routes, potentially you would have one stratum instance with each root and one instance with each root we keep the point point-to-point association. Okay, thank you So let's go back to the discriminatory So the discriminator is something that is outside of SHIC and that help us to identify the SHIC stratum instead we are using. So it can be the idea address, for example, in a six low environment when you receive your image network and you have to identify with sending which rule you are going to use, so you use the source address of the sender to find where to point the information. If you are a node that talks with different nodes, then you will have some sticks for some"
  },
  {
    "startTime": "00:40:02",
    "text": "instance that will be identified by the IP address But it can be anything over things It can be a TLS, DTLS association it can be NPLS labels, or anything that helps you to recognize what is the Shikistotum instance so and the funny thing is that in the first RFC we of course, we didn't have the vocabulary, but we talked about the end of the tunnel, and it was a kind of discriminator To go back to Bob Alexander? Okay it's... Yes, I just Yes, there's just something about you I think it for I think, here it's written chic instance, but it's the chic instance end point, it's the chic end point in this graphic, right? Yes, there is an error. This is an endpoint on all the documents that I will write it too late to change it Can you go back to the previous slide, Pascal? So here we are a case, for example where you have no set of rule, but define your schick stratum instance. So it's empty So it means that you have no context on both ends so you don't care about the schick stratum header It doesn't exist. And you go directly to your chic instance. And in that case, we have the compatibility, and we are in the same case as what we got with we had with LP1 architecture so we have a discriminator for example, this is a tunnel endpoint, and then we go directly to the shik instance element The other case is, for example, what we say for the I IPSEC case. So it means that we are sending the SHIC, the upper layer protocol, and we are using a SHIC rule to define it, and we say a SHIC proto for example, and we have a value"
  },
  {
    "startTime": "00:42:02",
    "text": "if we look at this reg we have only one rule, so no right it is needed And here we are not sending any residue. It means that here we are sending the information to the other one, or the other one knows by the country that the upper layer is IPSEC. So we don't have to send really information for this orbits for this schick spatometer And the last case, so it's the one with the meters, so as we explain, so here we have a rule that defined, for example, here a chic instance is not identifier that is usually on 10 byte, 10 bits, but we are on sending the last 3 bits as a residue. We have the chic proto, but we upper layer, but we don't send. And here we introduce also a series because for example we have eluded the UDP CRC and we want to protect the packet so we can do it by describing this kind of thing on the Schicks atom energy Okay, so here are the definition that I'm not totally convinced, but it's the best we have right now. So, Schixtratum is a fundamental block of the Schick mechanism that can be stacked at different location of the network and it's composed of a chic instance and a schick stratum instance a schick start of instance is used to carry some specific information to control the upper chic instance in the structure This has included, so we say CSC protocol identifier, an instance identifier, an instance identifier, also, for example, to send the MTU you are expected for the fragmentation So all these things are possible. And the magic of"
  },
  {
    "startTime": "00:44:02",
    "text": "CHIC is that we just define a rule to say what we want to send, so we don't have really to specify the format It's the rule implementer that will do it And the rule also forms a series serialization on the link. And so what? we are sending on the link So we are reusing fully all the chic mechanism to do that and as I said before when we implemented on open chic it was just a reference manager that point on different set of rules, but the rest has not changed. So that's the interest So here is, I will say that the You have 10 more minutes plus a few four questions. Okay, so I think it's good because here i will say that it's things that are not so well defined right now We have to discuss on the mailing list so now is to say how we can do the management of the chic rule so the goal is for example to use corco to manipulate rules and change, create new rules or to add to modify some values inside the rules to do better compromise So what we propose right now add a new kind of rule which can be compression decomression rules, but we will not call it compression rule, but management rules on only these rules will be able to manipulate the content of a set of work so to add new rules are to add new rules or to change some value inside the rules. That's why we need also the access control draft to say which field can be modified in the rules. And if we go and to the"
  },
  {
    "startTime": "00:46:02",
    "text": "in that direction can you go back pascal if we go back in this direction with have to say how we will do the core concept mechanism and to do that with the co-op so we have to do security Are we going to use our core? d tls or do we allow all of them So for me, for example, IPVCs can be a very simple IPV6 with two link local addresses, because we are in an instance, so we are pointing association and we can have FEAT column, column one, FEAT, column two and we say that the application has this value and the device has this value, and that's all, and then we put to the we create some very simple comparison for IPV6 to the and maybe a score. And we can carry my management on that and it's really specific to the set of rules we have no confusion with over protocol we are compressed So that's something but of course it's just ideas we have to go deeper. And the other things we have to study and i think it's a little bit more complex for the first one it's about rule provisioning, how we set up complex rules inside a chic environment So we already discussed that in the during an interim meetings so for example a rule can be the combination of different features you have the manufacturer that knows the flow is sending. You have the network provider that knows the IP address is giving to the device and you have the device owner that know the IP address of the application. So when we want to use SHIC, we have to combine all these information securely to create a rule that can be active. So how we name this rule? how we change its values, so it's something we, for my point of view, we have to put in the draft. And we have also to"
  },
  {
    "startTime": "00:48:01",
    "text": "look in the document to global action because I accept to remove it from the OAM draft, but I think it's something very important either for ping or for an other flow management that allows to create dynamic rules, for example, to compress TCP or anything that can be viewed as a flow So there is also a lot of work to do to continue on this document And that's my last slide. So there was also Alex that put some slide after. I don't know if you want to this discuss them well probably maybe if you can take a couple of questions. There's maybe one one slide I'd like to present But take the time for, you know, if you have any questions and then I can take two minutes to present it it So do we have questions? Alex, I guess if you can just tell me what slide number you want to jump to Yes, okay, so you can move forward It's about the okay yeah that was actually yes on naming heads. Okay, well, so yeah, so yeah this is the slide and the next one so basically uh of course one of the things that we've been doing and and and actually, yes, on naming headers. Okay, so yeah, so, yeah, this is the slide and the next one. So basically, of course, one of the things that we've been doing, and it's not a simple task, actually was really to make sure that we name things correctly, because some things were a little bit ambiguous in, and we had different interpretations We are all basically in a lot of things were a little bit ambiguous in we had different interpretations. We are all basically what they are for, but it's like there are very slight cases around the edges that need to be cleared out and also because right now we are really writing everything in your architect There are things that were never really"
  },
  {
    "startTime": "00:50:02",
    "text": "we didn't need to write them down. And now, when we're writing them down then we're okay okay how do we name this correctly? There's one thing that I think we don't really name correct. I mean, we didn't really name it explicitly so next slide please It's actually the chic header right so it's it's it's really like a very obvious thing to say, but okay well the formatting is a bit off but it doesn't matter But basically we have in RFC 8720 we are using the term chic compressed header and chic fragment header and actually there are several types of chic fragment header. And basically both of them are like, well, rule ID plus something, like rule ID plus residue that does the chic compressed header. And ID plus the D tag plus something else, that's the chic fragment header And while we were actually rewriting, like writing the architect draft it's a little bit cumbersome to every to say like SHIC compressed header or SHIC Fragment header So a suggestion and idea and a proposal is to, next slide, please Next slide, Pascal Yes, it's just to say, well, this is the chic header, right? So when we say the chic header, it's this thing right it's the rule id plus the thing afterward And that's where it refers to the compress here header, to the fragment header, or when we have the strata plus something else. Like the whole thing that the bits that go on the wire are the things that we call the chic header So like if you have any feelings about that straw or just don't hesitate to say able well that I don't think but just I think that this is like this is going to the architecture and, and, and, and when we say check header, it's like, okay, rule ID plus the bits. So next slide, please I think that next slide was yes okay well"
  },
  {
    "startTime": "00:52:02",
    "text": "and then another thing, and I'm going to stop here with this one, is that at some point, it was like, okay well how do we actually call the whole thing that we're sending over the wire? Like, it's with a chic header. And and the the payload that go with it, right? um because again in rc 8724 we treated the compressed things and the fragmented things strongly. So a proposal is to say, well, chic packet So that's one thing. That's the output bit stream resulting from the application of the compression on the input bitstream So very generic thing. And this means that it includes the chick compressed data and any necessary metadata for compression and the compression all that And so she packet and then shick fragment so that's the resulting from the fragment Compression and fragmentation and so when we want to use a common term just to say, hey, whatever gets out of the chic machine, like, we don't want to say every time, well, either the chic packet or the chic fragment is to invent a term of the stew, so a chic transmission unit and basically it's like I have a chic endpoint whenever comes out of it like this is the chic transmission unit, this is the stew so this is something new, and it's just to say, well, you know, we are, we have, we have ways to name, like, whatever comes out of SHIC, it's the STU stew. It can be compressed, the compression, it can be found fragmentation doesn't matter right and whatever comes out of shick it's the stew it can be compressed the compression it can be fragmentation doesn't matter right um and we know that it's header is a chic header no matter what happened there like so again it's a this is the all the effort that we're putting in actually naming things like correct"
  },
  {
    "startTime": "00:54:01",
    "text": "naming things in, um, things in a consistent manner and that help us express them shortly, right, in a concise manner so that's for me So do we have any reaction? in those terms? I mean, does it make sense? Daniel, you are going to like? Yeah to me, it makes sense. I mean, um, think it's quite a quite important to have the right names and uh to have a name first and then the right one is, if possible, but the one you're proposed to me makes sense and the answer to questions I i i had while reading the documents so so this is heading in the right direction just a fit So yeah, so I think it makes sense to do this effort I was wondering if just a very tiny comment in instead of SHIC transmission unit, what about SHIC data unit? I have no strong feelings about that, right? we had we were thinking still like the you know that because we said that it puts Laurent likes always saying it outputs a soup of bits so we said like it's a stew, like it played, but it can be, I, I, really know strong points on that and I just like me a soup of bits. So we said like it's just cute, like it could play. But it can be, I really know strong points on that and I just like maybe sent an email on the mailing list and we can discuss that but i i think we need to agree on some it can be, I really know strong points on that and I just like maybe sent an email on the mailing list and we can discuss that. But I think we need to agree on something and it can be chic data unit I have really no issue with that and we put that in the next revision of the draft and from here until the end of the unit universe, it's going to be called skew or studio have really no issue with that and we put that in the next revision of the draft. And from here until the end of the universe, it's going to be called skew or stew or whatever that in the next revision of the draft and from here until the end of the universe it's going to be called skew or stew or you know or whatever thanks okay"
  },
  {
    "startTime": "00:56:01",
    "text": "we'll move to the next topic in our agenda, and that's Mark Karlesk, since you are out next topic in our agenda, and that's Mark, Carlos, since you are close to the mind. And just before you start can everyone in the room, be sure to look into the application? It's important for the blue sheet so we can record who is going there and basically get the right size of the room next year thank you They're nut finding slides file you. I don't remember whether you sent a slide scale Carlos, did you? Oh, yes, that's it. Sorry Sorry, I was not finding it Okay, thank you. So my name is Carlos I'm going to present some of the main updates in the last version of the draft entitled Transmission of Schickcom Compress Packets over 15.4 networks My call for is Anna Nubb. So these main updates have been as a result of trying to the draft with the Sheik architecture document that has been presented by Gohan, especially by with the latest developments there so by the way this is a six-low working group draft. So the presentation will focus more on those aspects which are most relevant to the SHIC working group and then more detailed presentation will be the six-low session on wednesday so be free to attend it So yeah, in this document, we have the goal that's shown in the slide So on the left, you can see the, sorry previous slide Yeah, thank you. So on the left, we can see the traditional protocol stack based on IPv6 over 15.4 networks, which is labeled by means of 6 six law panels, the adaptation layer. And what we want to do in the draft is offering an alternative technique for header compression which in this case would be using chic because"
  },
  {
    "startTime": "00:58:02",
    "text": "we have the expectation that it will be possible to achieve greater performance. Next please So we have other sections 3.2 on the chic architecture concepts on how these concepts would apply in our case So first of all about the chic stratum in our draft, which is that sheik is used to compress IPV6 packets over 15.4 of 4 networks, the chic stratum is located on top of layer 2 and below layer 3 And one aspect here is that the compressed data of the Schick stratum may also comprise upper layer packet headers There are several options here like the chic may be used to compress only IP or maybe IP slash UDP headers all at once or echo up once and so on About the discriminator, in this case, we understand that it would be, actually it's the first field in the 15.04 frame payload, which would be the six lopan dispatch time. So when it's set to shik dispatch or sheet quality dispatch, then it indicates that what comes next is a SHIC compressed data unit Next please We have also introduced a couple of terms in the draft of grown. So this are single instance networks and multiple instance By the way, there's this box on the top right side of the slide which shows some terminology On the left there, you can see the current terms which are being used in both drafts, this one on the architecture draft and on the right is the new terms that have aligned with O'Hanfres as presented and also the ones which are used here So back to the definitions. Single instance networks are those networks where all the notes have a single chic instance for compression and decompression, and therefore each node has a single set of loops, because there's only one cheek instance. And in that case, the chic"
  },
  {
    "startTime": "01:00:02",
    "text": "stratum header, which is what tells what instance needs to be used for compression decompression is less relevant here because there is only one possible chic instance and it means that it can be fully compressed and actually in the draft we require it to be so we say it must be fully compressed so it will represent zero bits sent over the air then also all network nodes have a single chic stratum header and a single set of rules for ship stratum header compression decompression which is like actually empty compression equivalent to compressing a single implicit rule for chic stratum header compression decompression Next please yeah alex oh yeah you go back on previous slide? Just, yeah, just, I'm not so thank you. I'm just trying to, no, no, no, it was the one after So, yes, so here you say all network nodes have a same chic instance. So I, I get the feeling that here we're using it in the sense of one that you can have one chic instance spanning over, like it's more than two chic end points, right? Well, this is basically opposed to having different possible instances. So the idea is each node has only one set of rules for present decompress So yeah, yeah, I mean it makes perfect sense, right? But it just, I mean, it echoes with the discussion we had before with like with is chic instance limited to two chic endpoints or is it like it can be? more. So I get, I get the impression that here is like, you can have like 50 notes 50 notes and they all have the same compression to compression rules and in that sense you say it"
  },
  {
    "startTime": "01:02:02",
    "text": "like there's the same chic instants there on that yeah so that's okay yeah i guess we may align and see whether actually the chic architecture draft will define these details or whether we need to include them here But yeah, it makes sense to consider this, yeah I'm personally, I like it makes sense to me to where you write it like this, but it's just, yeah, we need to make sure that the architecture is um needs to to reflect that but thank you yeah thank you It's a second Daniel wants to Okay, so that's just a clarification question question Suppose you have an IPV6 packets and you have two different compressors one that compress one header extension and another compressor they compress another one So when you receive the incoming packets, I mean you will have in your extensions and you will have a two subject packets in it. Does the stratum will reference to the packet is I mean the packet that is being compressed so the header being compressed, or the instance? of the compressor? Yeah, so I understand that the chic strata header indicates the instance that needs to be used okay compress the packet okay right Because one thing is that these are not protected. So, you know, if I play with the two, you know, just changing the number I mean, it might have something Yeah. Yeah. Thank you Okay. So"
  },
  {
    "startTime": "01:04:02",
    "text": "the point that more general, broader question, and that is, I believe that Sixth Low header was done prior to 154 adding ether type originally 154 did not have ether type at all and and six low had a place games and how it worked. Later as a result of my work in 159, 154 was able to add ether type. So now there is ether type over 154. Thus comes to the question, now when we're talking about having chic as an ether type, how does this work where you're sitting above? the six low discriminator how does this work and how might it work differently? if we had Sheik as the ether type? underneath the sixth low? Does this, no, would we have potentially a broader architecture because then we can deal with? other things over 15 forward? I raised at this point, I was in broader architecture because then we can deal with other things over 15 forward? I raised at this point, obviously I'm just now looking at this and also that my 15-4 work is over 10 years ago. So yeah, so, so far we had basically used the six loop and this dispatch field to then determine what is being carried in the frame 15.4 frame payload but yeah that's an important point we hadn't looked at the ether type So yeah, we also need to consider this along with the well perhaps in the context of the discriminator to be used here Okay so, yeah, continuing multiple instance networks would be those networks that have at least some notes"
  },
  {
    "startTime": "01:06:01",
    "text": "with more than one chic instance for compression decompression therefore those nodes will have more than one set of rules because there is one set of rules for each instance and in this case the shixtratum header cannot generally be fully compressed We will need the Schixtratum header to tell, okay, who each of those instances is the one that needs to be used to compress or decompress data unit And this means that generally it will be more than zero bits sent over the year representing the Schick stratum header in compressed form. Although there's some exception I'll mention later. And also all network's nodes will have a single Shikstratum header a single set of rules for Schick Stratum header compression decad decompression and in this case that set of rules may comprise some maybe several rules for shift stratum header CD. Next please Okay, so in in this six-load draft we have one of the main problems is how can we deliver a chip compass packet over a 15.4 multi-hawk topology. So for that, we have currently three route over modes and we have also mesh under and now we also have to consider single instance and multiple instance networks. So in the interest of time, I will just focus on a couple of examples here and again all the or more details will be provided in the CISO session on Wednesday So what we can see here on the slide is one of the route over modes. It's called street forward route over and it's based on hand the intermediate nodes, the 6LR storing all the rules which are in use in the next So in this case, for example, let's say that host A wants to transmit the packet to host B. It will use Rule ID1 to compress the packet head and then it would send the packet to the next hop which is the upstream 6LR Then this one receives the packet, and here, because there's a single instance networks, there is only one rule ID 1"
  },
  {
    "startTime": "01:08:01",
    "text": "and the 6LAR can perfectly decompress the packet and operate perform its routing decisions, send the packet compressed again to the next hop and so on So the conclusion here is that because this is a single instance network, then the Sheikstratum header can be fully compressed down to zero bits Next please But then what happens in multiple instance networks well we have another example here with two instances I won and I do, and some of them are highlighted in red. So let's imagine that host A receives the sheet compass packet with Rule ID 2 Host A would be wondering, okay, which one of the two? possible options we need to use to decompress this packet? So we need in this case, a not fully compressed, chic stratum header to tell which one of the rules is that the one in instance one or the one instance two that needs to be used to decompress So actually this kind of conclusion applies also in the next the other techniques that we use for route over and even for mesh under with some exception that I'll mention later. So if we can jump to slide number 13, please Sorry, number 13 So yeah, this one, thank you So, okay, here there's some exception in mesh under multiple instance networks because in some cases here a fully compressed shift stratum header may actually be used So, for example, again, we have post A, let's assume that it is receives a chic compass packet with Rule ID 2. So there are two possible options, two possible rules here, one"
  },
  {
    "startTime": "01:10:02",
    "text": "the one in instance one, the one in instance two So here, this is a special case because as you can see in the rules on the right side of the slide, one will have the source of node C The other one, the source will be node D So if host A can tell who is the source of the packet, then based on that, it can determine which is the rule or the instance that has to be used for the compression in this case. And this is possible in this particular case because this is Mechander. And then, because it's Mechander we have a Mesh header which includes who is the origin of the packet and who is the final destination But otherwise, if maybe there is like from the same to endpoints to instances and the same rule ID, then there will be ambiguity and it will not be possible But at least in this case, it is possible even if it's multiple instances networks, to fully compress the Schixtratum header down to zero bits Yes, something I don't understand is a notion of discriminator here, because for me, that's it well because you have addresses and you say so i go to this instance with using this addresses. So, yeah, I noticed that when you presented the discriminator we had like different views and perhaps I might need to update my own. Somewhat I understood the discriminator as some field telling, okay, what comes next is a chic header or a chic stratum header So it is rather in this interpretation about at which kind of layer more specific which stratum we have there or the there is a schistratum present there rather than the parameters that will allow to determine exactly which instance would be used because actually I understood that which instance is used to decompress the"
  },
  {
    "startTime": "01:12:01",
    "text": "packet is part of the sheet stratum header So I don't know, this is my view but maybe it needs to be modified But we have to discuss because that's a very interesting point to to fix the architecture for me it's but maybe it needs to be modified. But we have to discuss because that's a very interesting point to fix the architecture. For me, you have two ways to, so the first one is that the discriminator points on the chic stratumere instance and then inside the instance, you may have another instance ID that points to the right aspect, but this second one is one that is not mandatory okay okay, so yeah I guess we need to double check your understanding of the architecture yeah thank you okay so next please please For the time, you can have three minutes to wrap it up Okay, because there was a question that Laurent was supposed to relay I think, but we can have it in the end from Amanvan. So let's let's your presentation and we'll see if we have time for questions. Please try to give us a minute for the question yeah so next please So basically, we have updated all the frame formats in the draft. So the chic packet, which is the packet with the chic compressed header now is preceded by a chic stratum header which again in when it's in single instance networks, it will be fully compressed down to zero bits over the year. In multiple instance networks it will generally be not fully compressed with the exception I mentioned before and in this case what we recommend in the draft is that the rule ID for that would be a size between one and eight days So the chic stratum header in compressed form would be something like a rule ID and a compression residue Next please. And the next steps, we have to define which is the schick stratum header"
  },
  {
    "startTime": "01:14:02",
    "text": "format and we also have to define something for the transition protocol stack which is an approach kind of intermediate between the original six low pan based protocol stack and a sheet based protocol stack So here, six-low pan would be used to compress the IPV6 header, but she would be used to compress Appalier protocols And in this case, we need to decide, for example, whether a single Schick stratum is enough for compressing UDP and GRAP altogether or whether we may need one particular stratum for each protocol. So this is things to be sorted out in next versions So yeah, that's it. So maybe comments or questions So we have Sorry. Amanvan at these questions about why are we compressing the packets but not fragmenting them using shake and there are a number for free reasons. I see that the thread is already providing about those answers But the design of the fragments in shake is very different from the design of the fragments in Sixth Low And there are things that we are doing at Sixth Law, like forwarding fragments that you cannot do. So maybe in the case of Messander or in the case of a tunnel, you could you could be using the shake fragmentation because the forwarding is not involved in that Also, there is the transition stack which could not be using it because it's compressing robust six low that's what I answered so the basic basically, if you look at the design of the two fragmentation, they are quite different because one was thinking mesh and the other was thinking pretty Yeah, so, um, you know to one of the things you mentioned, one reason why we would still keep the six low band fragment"
  },
  {
    "startTime": "01:16:01",
    "text": "or six-low fragmentation, including your latest RFC on that is also to somehow allow reusing existing implementation existing code as another reason why we might want to keep that However, yeah, there are also, especially consistent your RFC, Pascal about six law fragments with recovery and so on. I had the impression that maybe it's not so different now how there is chican at least compare with the original 6-lopan fermentation, where there was no re-trice for fragments and so on So we have passed the time and would like Marco to jump to the night if Marco you're here Thank you, Carlos. Thank you so much Hi, can you hear me? Yes Good Okay Hi everyone, this is marco tiloca This is an update on a working group document on Yuzikshik for compressing co-op headers Next slide, please Right, as I recap, this was adopted as a working group document and the end of last year, right? after we pushed version zero, then we didn't meet in March in Brisbane. So we are in version 2 now. I'll try to present a consolidated update But the goal of the document was mentioned by the chosen in the introduction is to obsolete 8824. So of course the scope"
  },
  {
    "startTime": "01:18:02",
    "text": "is the same describing how she is used to compress co-op headers. But in this piece document, we take the opportunity to provide a number of clarity the scope is the same describing how she is used to compress co-headers but in this piece document we take the opportunity to provide a number of clarifications especially on on different already existing and new co-op options to be handled by shik on some particular corner case fields like the pilot marker and provide also tons of examples to clarify how SHIC is used with proxies and by no means we intend to change the co-rational and philosophy of how she is used with co-op. It's just clear clarifications and additions. Next slide please So again, jumping from version 0 to version two that we have now, I'll go to through the updates here and first of all, we took care of one of the errata that were filed, I think, last year that got approved but held for document update. So this was about time and right now the the text inversion two is um enforcing what was expected in addressing this errata. There was an example of a sheet compression rule that was using equal one in DMO and the real intention was to stress instead that the goal was to target the first element of the path targeted by the co-op message So what you see on the right is now the resolution of the Aratum as it was intended While working on that, I had a thought if this can even be simpler than this and if TV can simply be element of the path or just any or any canonical while this can even be simpler than this and if TV can simply be element of the path or just any or any canonical wildcard value if we had any I don't know, because it should be clear already from the from the FP with value one that we are indeed considering the first element and yes this is about the path as the"
  },
  {
    "startTime": "01:20:02",
    "text": "field descripton name says So any thought, anyone on this? I don't understand why you say simpler, because in the you just have one element as a TV TV so well you can have multiple elements because the option is repeatable I'm saying TV is redundant here compared to what field and fp are telling you already So maybe just saying any in TV any value present there is just to be omitted and not sent What you can do is, for example, in the document is possible to have two elements as a TV, so you can have slash a style B, for example, and it's view as only one in the compression compression but normally you separate them what is not very well done I will say that you need to have the right number of options in your path to match a rule. And if you there is some tricks, but using a variance or something that say, or a manner, known to to limit the size, but it's not very, very nice right if you have ideas to make something clever, it's I think. Yeah, any value supposed to be suppressed here basically that that's why also thought of the wild card, but I don't know if there's any official wild card defined for chic But if you have ignored, it's like a wild card Sure. That's another way to take it then. So you have a thing is that you can use MSB"
  },
  {
    "startTime": "01:22:02",
    "text": "on the path. So for example, if you have a always the same thing at the beginning, the same letters then you can cut this later and just send the remaining part Okay, that's a bit of a different rule, but yeah, sure daniel So one thing that might help you, but I'm not sure is that in IPSEC we have any and open opaque for matching traffic selectors I'm not sure I would take that path Yeah, if it existed at all my understanding here would be something like any, but yeah, if it's not admitted by 8724 in the first place, I don't want to introduce something that can create confusion either. Okay, minor thing anyway. We are aligned with the intended that random resolution Okay, on this slide, we also had the number of clarifications related to the compression of co-op options in general and the text describing how they are represented in the field descriptor of a chic rule. This is not really changing anything on the process for compressing options is just awfully clear text and in particular the delta property of a cop option is not really, sorry, the type property of a comp option is not really taken into account anyway so it could be easily stripped out from the description for the same of easy understanding, and FID is not necessarily the option number like the text was saying. It's in general an unambiguous identity of the option and practically, as you see in all the examples it is the option name and on the FL the text was saying liking it"
  },
  {
    "startTime": "01:24:02",
    "text": "8724, but it's actually supposed to indicate the option length that then of course if you send the option in the compression residue, you transmit and code it like 8724 specifies. Next slide, please And yeah, again on the options on the criteria for their high-level compression, the delta and the length that are part of the official cop definition of an option do not play a direct role here Delta does not because you still have the sorted field descriptors anyway in the rule a length plays no direct role either because what matters is FL, and of course, depending on the operator you may have to encode it on the wire together with the residue. So just summarizing here the practical ways that as usually you can use to compress the options and the and then again directly don't play in a particular rule and again no change in the practical intended way to compress the options Next slide please Some actual change instead, these were already defined options also in terms of shift compression among others in section 5.5. I'm talking about ITag were already defined options also in terms of shift compression, among others in section 5-5. I'm talking about ET tag and with match. And before, version 2, they were defined only to be transmitted as is, with no compression But actually, even before adoption, we had another option in a similar situation request tag and I think Anna noted and proposed that we could also admit for that adoption to be a processed by a rule with a more match mapping and CDA mapping sent. And I noted, well, the same actually can be done here for these two e-tag and if match options. So it's still possible to see them as is, of course, but if the setup of possibly pre-known values allow"
  },
  {
    "startTime": "01:26:02",
    "text": "you can also go for match mapping and mapping sent. Any objection on this addition? herdred none and yeah in this same spirit of double checking what best can be done for options, I noticed that if none match was also described as to be always sentences, but actually this option is the defining the first place in co-op to be only empty if used at all zero length value. So practically it's about treating it with MO equal CDA not sent, which is consistent with what we do for another co-op option that can be only empty with zero length the ADOC option. Hopefully this is non-controversial too Okay next slide, please. Yeah, I also mentioned you new recent options that are defined in a core working group document They are proxy CRI and proxy scheme now number. They are basically the more compact equivalent to two long existing options proxy URI and proxy scheme. They have the same meaning just in the context way. And from a chic point of view, they are really supposed to be handled the compress according to the same logic next slide please please Mostly thanks to Loran, actually, we finally have a complete first version of the Young Data Model not only floating, but actually included in the appendix A of the document and also available as a separate file on the GitHub repo For the sake of readability, the elements are sorted into sets fill the DM functional length, and even though I got validation errors at submission, if you check now in the Datatracker, it actually success passes validation with P-Yang And of course we keep this up to date if we made any change or add more option or fields"
  },
  {
    "startTime": "01:28:02",
    "text": "Next slide, please. Yeah, to conclude with ayana this one yes something was quite simple and expected to do anyway looking at other Shik related documents the requested registrations in IETFXM quite simple and expected to do anyway looking at other Shik related documents, the requested registrations in IETF XML and young model names. And then with thought of IANA to address an issue that was brought up also in previous meetings We ended up after some discussion with Doran mostly in Paris to propose a new Iyana registry and this is the issue We expect in the future, of course, to have people defining new co-op options or co-operated new Agenda registry and this is the issue. We expect in the future of course to have people defining new co-op options or co-op others in general or updating those and that's fine after thinking a bit it's a bit too much to expect from people that at that point in time, they also define how the chic compression should work for those options and fields. So the two things should be really the coupling. One is defining or updating cooperator fields. One is if there is any interest or need, the final the sheet compression for those. That's on one hand But on the other hand, I suppose we don't want to come back over and over every five ten years, whatever, with a new piece document, realign in the current state of the art of chic and the co-op world. So a possible way to address this is basically setting up an IAN registry as a sort of catalog of existing co-operator fields and pointers to specific that define how those are handled with Schick in any known way Next slide, please Yeah, there's more details on the draft, of course, but this is the gist of the registry, and it's really simple And the catalog with three columns only, field is supposed to be the unique field identity for the co-op header field and it's supposed to be used really as the value of the field column in a descriptor"
  },
  {
    "startTime": "01:30:01",
    "text": "of a sheet compression rule and it's supposed to have a companion entry in the young data model description is supposed to give a simple description of that and pointers to specification where the co-op header is defined for example the co-op rfc if it's one of the original ones. While reference instead is supposed to have a set of references to documents that define a way that has been proposed to compress that co-op header field with Schick. And we are of course pre-population this registry with everything we know about this topic today based on a table that we have in a separate section And I think specification required could be a good fit as a policy where the specification in question is the one the describing how chic is used for that co-operator field. And we have, of course, a guidance for the experts in a dedicated section just a summary of next steps, I think it's better to clarify yet another thing. That's to assume so far on the compression of the tkl field but no change in the be behavior. We need security considerations on the young data model and a few advanced things I'd like to think more, including possible better positioning of some text in different documents at this one This was also as before. And a final administrative point, the sources of this draft now are hosted in my personal GitHub. It started this way. It's fine to me. I believe it's more a appropriate to have those in the LP1 GitHub organization, I think, but I don't have the privileges to create a repo there. So if anyone the chairs can create it, I can migrate the sources there And that's all from my side. Thank you very much. Thank you, Mark We'll take that offline and we create that repo both. We are 10 minutes behind So I think the next is Anna about network susceptible to disruptions"
  },
  {
    "startTime": "01:32:02",
    "text": "Anna, please start. And yes, if you can be quick, that's nice. Yeah, thank you Pascal. So I will present the update of the adoption And the first title was Chic for Zero Energy Devices. And after some discussion in the mailing list, we see that the disruptions can only not only be about energy harvesting but also about disruption in connection or the latency So we try to open the scope and change the title, but not only. Next slide, please So the context will be, again, different topologies, but with different devices capabilities and the most important will be to have this scope with the energy, with preserve battery and the energy harvesting as was proposed first and the second part will be as we have discussed with the Rodrigo, yes. With Rodrigo, we discuss about the satellite networks with Leo that the disruption of connection is done because the satellite passed. So at the end, the result is the same. We lost the connection once because it's energy on the other side is because the satellite is gone So the use case we can present in this document can show these two possibilities and also the LP one for the presentation Battery. Next slide, please please So Cheek will help this connection with the to simplify the operation and saving energy with longer delays for transition climbers"
  },
  {
    "startTime": "01:34:01",
    "text": "lower reliability and also because we are doing, yes. Can you speak? a little bit louder or closer to your mic? Yeah, it's better there? That's better, yeah and then also because she could bit louder or closer to your mic? Yeah, it's better there? That's better, yeah. Okay, and then also because she brings the overhead reduction with Heather compression and fragmentation and we can reduce the padding or eliminate it And also, the chick will give us the opportunity to tolerate the delay and the long latency. Next slide So, the first adoption is this draft is informational to change the title And the objective now is this, we have three uses case, the serial energy the disruption connection with Leo satellites, and the low power for LP1 So next slide So if you agree to adopt this work, the deadline is today, as Alex said We can vote if you want Because you didn't, we only receive two plus one at the Berlin list, I think That's all Thank you very much, Anna So, okay, so Pascal has started to show up hands. So, of course, the point is that the work initially started as the zero energy devices work, where it is specifically based on a document from the 2GPP, and there were a lot of architectural discussions so it is very very like so there's a clear application path for a for for this document and then of course"
  },
  {
    "startTime": "01:36:01",
    "text": "it was like basically adopted had like a show of hands everybody was everywhere voted for that there was um mating confirmation on the mailing list and um, all of that was confirmed. And the now that the two plus ones were basically one who said okay probably we need to reframe it because it's a little bit larger than just this three gpp. right so i mean the way is see it, it's like we have all the plus ones from before We didn't get, like, no one said, minus one right so uh show of show of hands i think maybe we can we can leave it six positive no negative I guess we're done for today so we can got six more positives and like I said, no negative so let's yes confirm that the chart is adopted. Please publish a zero zero as soon as you can, which is probably today Yeah, I will do that. Thank you, Annas. Thank you Thank you. Let's move straight to the next, which is the chic implementation Javier, if you're here Oh, daniel huang a question. I see, are you still? No, please remove yourself I forgot to do it this time Hello, do you hear me? Yes Do you hear me well? I'll try to put my video Perfect So hello everyone, I'm Javier Fernandez I some, I've met maybe a couple of you before I'm an IoT R&D engineer in EMT Atlantic and we're working right now in Lavshik, which is a joint laboratory between EMT Atlantic and Actility So next slide, please"
  },
  {
    "startTime": "01:38:04",
    "text": "Opa So overall we have inherited chic implementation from a company called ACUE And this was a company that further developed SHIC actually made it to possible to have Shik in real life And this was later acquired sorry previous like this was later acquired by Actility recently this year So Actility had control over IPCore, which is a chic gateway it's the compressor, let's say, acts as a gateway between the traditional internet and chic, I'm not sure if calling it already stratum, she can't yeah, so, um shik, I'm not sure if calling it already stratum, she can't. So what we have decided to do is have a joint laboratory where we can open source the SDK the embedded application, and have it communicate, have it interoperable with OpenShik and IPCorps as well so that we can basically accelerate the adoption of SHIC So where can you find it? You can go to our website. It's Lab-shik.fr And I've put a little QR code If you're curious, you can just scan it from your phone or just go to the website there we have three large buttons the first one will take you to the repository Second one is resources Third one, you can contact this. You can send us an email so in the resources button next slide please You will find some resources So first of all, we have the GitLab repository Here you will find directly the code I've also tried to put a"
  },
  {
    "startTime": "01:40:01",
    "text": "comprehensive documentation, so I'm still in, this is work in progress, but the basics part are already there And next we have some documentation links to the business let's say and enterprise chic gateway which is IPcore and let's say the open source very academic implementation of Shik So next slide, please. Actually we have a couple of repositories for this We have not one, but two. So the first one actually it's only the chic implementation So here it's called full SDK So we implemented the full SHIC standard And this is the repository where the compression and fragmentation functionalities live There are some additional bells and whistles there's a DTLS implementation which is actually super cool which, anyway, it hasn't been standardized. And there's a rule implementation called templates. So this basically translates into the real world where we have actually physical devices that share a common chic rule set however they have different properties like, say, their IP address or so And there's a synchrony functionality, which is also being developed Next slide, please The second repository which is the delivery package, integrates the full SDK repository, so assess repository, which is the delivery package, integrates the full SDK repository, so as a submodule. So it has the chic implementation standalone, but it also integrates a couple of more libraries or submodules so for standalone. But it also integrates a couple of more libraries or submodules. So first of all, we have some layer two"
  },
  {
    "startTime": "01:42:01",
    "text": "abstraction layers, implementation sorry. So right now we're just focusing on Laura1, but there's a SIG-Fox and NBIT library For LOR1, we're using LBM mainly, Laura Mara is going to be a it's going to reach its end of life soon if not already, I think. There's a platform also abstraction layer. So right now we support a couple of boards So I have some with me I'm not sure if you can see them. So it's mainly ST boards and also a couple of shields so SX, 1272 and 1277 1276 i had the nordic somewhere here okay i'll skip it for now, but it's meant to be used with the NDIOT technology Then there are some lips, some additional libraries that might be used by the application layer there's a free R2S implementation as well. And there are many examples actually The primary ones are AT modem and the bare metal So the AT modem, it's like a simplification we can just use it from a Python very simple Python application that sends a serial commands And you can try it out like this. There are also some bear metal applications, and yeah those are the two repos in the docks i have some getting started guides some I explain also some concepts that are employed within the SDK. And there's the follow that are employed within the SDK and there's the full of also the full reference manual with all the documentation for the public APIs So next slide, please please So additionally we are using some CMA Seamake to build the"
  },
  {
    "startTime": "01:44:01",
    "text": "applications. We are flashing the device and debugging through Open OCT Of course, to build the applications for the embedded devices, we need the tool chain. We're also integrating the SIMSTEC LORA stack source And for the memory footprint, of the library we can use FP FPVGCC. So here's an example output The library itself, it's modular Actually, that's a very good advantage so depending on which modules are activated, you might get a different result. Obviously, depending also on your application, a specific application But, yeah, here are some data, so over or more or less it's like 20 kilobytes actually quite heavy if uh are some some data so over or more or less it's like 26 kilobytes actually quite heavy if you have like a comprehend like a very complete application, but I've managed to fit it in an l0 arm device so it's actually it fits perfectly also it's okay slide, please uh-huh so how can you participate Well, I'll just invite all of you to go to the to the website just explore a bit play around with it, clone the repo, try it out. Contact us, please send us your question questions And if you want to see a live demo, I'm open for a call and yeah, as I said so this is a work in progress still. We have inner the code, but now we're making it accessible to everyone So I hope it's interesting enough and hope to talk to you soon about it That's fantastic, Javier. I hope you look at the drafts that we have and come out because since you have an implementation in your hand, you can tell us you're doing something that fits"
  },
  {
    "startTime": "01:46:01",
    "text": "in our implementation, or that's very hard to implement or something Thank you so much for this presentation It's huge for this working group. Yes, just just one point because, okay, can you go back just a little? like two, three slides behind? Because I, we have to have here to so where it will, yes, here with the modules, just here, just for a second Because I got, like, we can, I just wanted to ask to say one minute here, something that's really important um and uh uh you see there are a lot of modules and some of them were like proprietary work now everything is open source MIT license for right, from the go. Not everything is fully documented but we're going to do that with the time And of course, we'll be adding drafts just to explain, you know, how things are done, not expected for that to be at the working group but just you know that this code that is there and that's industrial grade work developed, you know, with no dynamic allocations and all that. I mean, it's writing embedded software that doesn't break its very difficult. And you have this quote kind of code. And there's one thing like, the certification part for example this is what you mean for to get the Schick certified over Laura 1 so you have actually certification body today that you can go and you can certify your shick stack with it and you have it here um you have interesting work on DTLS and like and you also have a very easy way to port the whole thing to a new platform so it's the L2 abstraction layer that have was talking about and it's basically like four functions in it's a C file and you have send, receive, and set timer. I think these are like the three functions that you need. And you can port it to any any environment that any any new technology like you can put satellite, you can port it to, to, functions that you need. And you can port it to any environment, any new technology. Like you can put satellite, you can port it to ICAN, you can port it to whatever you want with these three functions so it's it's really a"
  },
  {
    "startTime": "01:48:01",
    "text": "technology a technological miracle Oh, miracle, sorry burkle uh it's uh it's a it's a really a visual. Yeah, a marvel, technological marvel that you have here. And, and of course, as an industry, product, it's not as flexible as a Python script, right? You will be very happy that people contribute and you know that this opportunity is here and i think it's really good. So thank you, Javier for taking care that it all continues and for the presentation Thank you, Hacier We've passed the time So you have a final last word? before I bring in the next slide On my side? No, no, it's okay. Thanks thank you so much, that's that's huge for one working on like here to have a full implement like like this one Maria, my guest Hello everyone and what welcome to this. Thank you for joining this session Today we are going to talk about the ESP header compression profile So that's really hard for just EHCP for compression and decompression of IPSEC and CAP compression and decompression of IPSEC, Encapsulation Security payload, known as E compression and decompression of IPSECEC, Encapsulation Security Payload, known as ESP packets using CHIC And the motivation here is to apply CHIC on different ESP levels so we can avoid sending information which are currently shared on the end and this is a joint with the IPSECME working group in collaboration with IPSEC"
  },
  {
    "startTime": "01:50:01",
    "text": "experts. Mariam, would you like? to change the slides yourself or do you want me to change that? for you? I don't see you, but I hope you, I thought you have your phone with you, so you can decide I can move the slides or you just do it Yeah, you can change it. Okay, I will change that. Thank you So this is the ESP packet structure just to know And the first part is the security department index and the sequence number which covers the integrity and the rest of the fields, the value data padding and the pad length and next header actually covered the confidentiality so here we can see that the security is ensured on the data in detail including the headers Yes, so here we can see the archive that we provided the flow diagram, that we can see here the multilevel compression to ensure the security, the size efficiency through the transmission And note that here on top of the diagram you can see the ESP header compression context is defined by the security system association and the additional parameters we have three main levels of compression. One is the inner IP compression The second is clear text ESP compression and the last one is encrypted ESP compression which we will discuss in the next slides Next slide please So the first is the first we can start calling them stratums strata actually, what you call levels? That's what our strata are for"
  },
  {
    "startTime": "01:52:01",
    "text": "for So the first level happens directly on the inner IP packet which compresses fields such as you force and checksums. And in case no compression of the inner packer is possible, there resulting check packet contains the uncompressed IP package as well and the next slide please So the next level, the clear text ESP compression or CTEC, compresses the field of the ESP payload right before being encrypted as can be seen on the second level here we can see that so the IIP the C here represents the compression so we can see that the IIP is compressed and the ESP trailer known as the padding, the padding leg and the next header are compressed in this level and the next slide please And the last level compresses ESP fields that remain after encryption Typically involves fields such as the security parameter index, SPI and the sequence number, known as N the next slide please So here, in this table you can see the check parameterization for ESP you can see the EHC their possible values which come from those references in front of it from those RFCs And just to let you know that, the TS, the context which includes TS before it shows the traffic selector, which is included in defined by SA and so you can find the variables inside it which are stored there and one more thing that I should add here is that the IP address starts and end in front of the TS shows the starting and ending point of the"
  },
  {
    "startTime": "01:54:01",
    "text": "range of the IP address so we can define the range of the IP address to reduce the overhead here and increase the efficiency Next slide, please my am you have lohoho in vexio um yes just a question about IPV4. It's just a field or it's something that can be compressed as anything or it's so there is some difference between IPV4 and IPV6 or you can it's only the address okay and you can manage it the same way or it's different okay Actually, the examples are included at the end of the draft in the illustrative example You can see them more details So to save more time, we didn't include it here So the next slide, please And so here is the new cheek compression decompression action that is defined in this draft So we can see the actions are lower checks on padding and flow label And we define these are CDAs and want to check this is the proper way to use check And so the lower action is indicates that the value is sent in the packet but not at the expected place. In our case, we have IP in IP and it means that the compressed field of the inner packet is read from the outer packet It can be with different from that. The checksum indicates checksum needs to be computed following this specific rules and the padding indicates padding bits for ESP are generated in a certain way And the last, which is the flow label, generates a complete new flow label the receiving should generates a new flow label okay there is a question from Anna Yeah, thanks for that as you generate the new flow label. There is a question from Anna. Yeah, thank you. I have two questions. The first is about what are you using three levels?"
  },
  {
    "startTime": "01:56:01",
    "text": "three stratums, and not only two The second question is about the padding Can you repeat your question? Is your voice, I think it's Elizabeth. Yes, first I want to know why are you using three levels to do compression? and not only two? So yes actually inside ESB, we have three levels the first level is the IP inner header which is the plain IPA, the present the simple IP packet that we have So in this level, we can compress the IP header itself The next level is where the ESP encapsulation comes into account. That we can compress the ESP header in the, actually, encapsulation level before we go to the encryption and the last level is for the encryption phase So in these three levels, we can ensure that we'll have compression, not only we have compression and efficient but also we can ensure we have this security involved by using ESP as well I hope I could answer your question Okay not exactly, but we can discuss it later And my second question is about, why do you need to compute the pattern? Because normally we are eliminated the padding padding Did you write your voice? I'm sorry I couldn't hear Why do you need to compute the padding? The question of the padding here padding? The question, the padding, yeah. Padding, okay. So, actually, because the padding might be different for ESP"
  },
  {
    "startTime": "01:58:01",
    "text": "So since it is actually not a specific value to be said and it will be determined that the end point. So this is a why we have competing padding to be able to change it in different scenarios So next thing Yes, so this is the one example that we included and so you can see that I IPV6 inside the IPV6 example. The first we can see the ESV headers, which comes before the IPV6 header, and then we can see the PCP ports and the sequence number and the information from that and the last part is the BSP trailer that you can see the pad And the last part is the BSP trailer that you can see the padding and the pad lengths. And so this is an example that you can see how it looks like if we have IPV6 inside IPV6 here and the next slide please so in the next steps we are going to complete some sections in the document which still need some work, like the padding that we want to see that if we are going to reduce the size of it into bits from bytes or remove some of the like the first layer padding or the rest of them to make it more efficient and the second thing is that the implementation is in progress to justify our work and this draft. However, meanwhile, we are more happy to receive any comments from Chica experts to read the draft and see that if this draft aligns with the way CHIC is defined"
  },
  {
    "startTime": "02:00:00",
    "text": "Thank you so much. Thank you so much Mariam. I guess we won't have time for questions. I mean, that you guys can go to IPSEP as well to discuss this This is the official end time for our meeting. We thank you all so much for attention And Marian, thanks very, very much, Daniel for coming and presenting that to us. That's very, very interesting And I feel quite consistent with the way we are doing in the architecture, if you call things strata. So opposed to levels. And I like to your or Eric. Yes just, yes. No, just this, thank you. Thank you very much as opposed to levels. And it's Alex or Eric. Yes, just, yes. No, just this, thank you. Thank you very. And it's really, it's a really important work that you're presenting. And it comes at a perfect time as well for to to able to you don't to include it in their definition of the architecture as well. So, really perfect time Thank you very much and thank you all for being here And the meeting is at John. Thank you Lauren. Yes. Thank you, Lauren Thank you Eric for and thank you everyone. Thank you. Bye-bye I hope we meet in person next time Yes, yes yes have a Guinness"
  }
]
