[
  {
    "startTime": "00:00:14",
    "text": "okay so it seems like it's the time to start the meeting so hello everyone welcome to the meeting of the sixth law working group my name is carlos gomez the other chair is shreta bhandari and our responsible lady is eric klein we are all here and for me to taking we have dominique who has kindly volunteered and thanks a lot dominique once again and nevertheless we encourage everyone to join the collaborative process of taking minutes so don't hesitate to join the link that you can find at the end of the slide next please so this is the notewell this is a reminder that if you are participating in the itf then you agree to follow the itf processes and policies the noteworld contains a number of pointers to documents on several of these policies so please make sure that you have read it next please so this would be the agenda for today the first presentation is the usual chairs introduction that's currently in progress this will be followed by the presentations given by pascal entitled nd multi multicast address listener registration and and the unicast lookup this will be followed by a presentation on the updated version of the draft and title transmission of sheet contrast packets over 15.4 networks after that there will be a presentation by rigi yannoni entitled native short addressing for lln expansion and the last presentation will be given"
  },
  {
    "startTime": "00:02:00",
    "text": "by how you song entitled short hierarchical ip addresses attached networks so as you can see this is a packed agenda so we hope the presenters can stick to the allocated time and uh also as in the last atf we going to dedicate most of the session to presenting and discussing new materials so is there any comment on the agenda okay so if there are no comments then let's proceed to the next slide so regarding the working group documents status we have one document in the rfc editor queue that's the ipv6 measure with ble-links then we have two documents that have been evaluated by the isd the first is ipv6 over nfc and this document was elevated the first time by the asg a couple of years ago then it was updated uh after some time and in the last eight years there was some some conversation about whether the nfc specification would be available to all the intended participants so i don't know if perhaps eric klein or adi would it be possible for you to give some update or some suggestion about the next steps for this document uh yeah i received um the nfc uh specification i think uh i haven't had a chance to go through it i went through some stuff that was publicly available but i think the broader concern that the isg chair had was basically how do we communicate that uh everybody who needed to read the details of the spec was able to read the details of the spec when the working group was was uh"
  },
  {
    "startTime": "00:04:01",
    "text": "drafting the document uh or what it was in last call um i it might suffice to just have a reference to bcp 97 or best or something in in the shepherd write-up or i don't uh i don't know i need it's on me to uh to close on that issue with lars so okay okay thank you then the next document that has been emulated by the isd more recently is ibvc adobe plc so there are at the moment three outstanding discuss ballots and there were several comments the authors have a plan to submit the revised version of the draft in roughly two weeks and at the moment have already replied to most of the comments then the next document is six low use cases draft which passed the second working group last call so the next step will be getting the shepherd write up and finally we have a new working group document entitled ipv6 multicast address this is a registration which was adopted very recently and which uh had pretty good support and by the way this will be presented later today so is there any other comment or question okay so if there is no comments then i guess we can proceed to the presentations by pascal do you wish to share yes that's nice um are you going to to move the slides or can i do it myself i don't know that i can do it but maybe i can"
  },
  {
    "startTime": "00:06:01",
    "text": "you will be the one advancing the slides for me i i'll never get this right slides okay please okay so please let's let's start next slide please okay this is this is a generic intro for both documents that we'll present today so um as you know we now have a family of documents around six lopez nd and it's getting proposed and used in environments which are way beyond the iot right now initially the the focus was on wireless so it at some point we called it wind for wireless nd but now we are proposing it for rift we are proposing it for a vpn so it's it's way beyond wireless and wireless does not and wireless in the title does not really help understand what this is so um recently it's been proposed to to call this family of protocols ipv6 stateful address the configuration as opposed to ipv6 stateless address the configuration that that we know very well so the family starts with 6775 which was extended updated by 8545 more recently we published uh address protection for it meaning that the address that is advertised by 855 can now be protect against address theft and impersonation attacks and we have eight nine to nine which basically um specifies how to proxy neighbor discovery when you have a network where you have legacy and d a and eight five four five which coexist and the most classical example being uh eight five four five on the wireless and eight nine to nine on the wire but it can be any other composition of network and now we have we have two new documents which are being proposed to this group one is still personal submission i will discuss it next"
  },
  {
    "startTime": "00:08:00",
    "text": "and the one that we are talking about now is is the multicast registration so as you know um h505 was about unicast ipv6 addresses and so you could not register uh multicast and if you did register any cash there was no signaling to say hey uh i may i might not be the only one who wants this address and this could create confusion in the routing and only one node could possibly win and that prevents the use of any cast followed balancing purpose for instance so we have this new draft next slide please which is the draft atf6 load multicast registration where we enable 855 for not only unicast ipv6 addresses but now anycast and multicast addresses as well and if you consider the position of an iot device uh in an lln device a 6lb being able to register the that is a listener for a multicast address saves the need to implement mld and as you know mld is expensive in terms of of energy and wireless resources because it's it's based on broadcast but the same reason why we we designed the syslop and nd in the first place to avoid broadcast is also the reason why we want to avoid mrd and and use x8545 for multicast and anycast as well the benefit is that the 6lm goes mostly unmodified i mean all it needs to know is yes i will accept packets for those anycast and multicast addresses as i would accept packets for my anycast addresses and i won't use them as source that's pretty much you know all it needs to know and um we we validate that it knows that because when it registers a multicast on any cast address now there's a new flag"
  },
  {
    "startTime": "00:10:02",
    "text": "associated in the ero and actually in the idaho message as well to to to signal the addresses uh unique unicast any cast or multicast um there's more work on the 6lr side because now it will accept more than one registration for the same address and so for any cast and multicast address the index for the registration becomes the combination of of the address as before and the rover field which is the basically the the information which is used to uniquely identify and validate the ownership of the address you'll find when you read the draft if you have not done so yet that we also um do some ripple related work in this specification we did not want to do uh like eight five four five and a 1910 uh two separate documents because that would take too much effort to just make sure they are synchronized and you know in terms of content and uh take them separately through all the asg process so we kind of decided to make a a unique consistent operation between what six lapel does on on the 6ln to 6lr hub and what triple will do on the rest of the network so we also specify the ripple piece and for that we extend rfc 6550 in particular with a new map mode of operations for for those familiar with ripple a ripple has number of modes of operation one of them is just a tree where you can report data but not get data back the collection tree that then you have a non-storing mode which in case of iot is the more most currently uh deployed and whereby the route the source routing uh down the geodac to the devices we have a storing mode the"
  },
  {
    "startTime": "00:12:00",
    "text": "storing mode with multicast and more recently we have um introduced aodv so which could be actually i'm sorry uh mob five oh well not for our map five we hope is mark four because mob4 was just uh an experimental rfc so far and if that's more for that means that we frame up five for for uh the new non-storing multicast mode that this specification is introducing and for any cast there was strictly nothing all we set for any cast is if you inject the same addresses at multiple places network you should use the same sequence counter now we are giving explicit information about how you do any cast in the existing maps and including the new map that we are defining here next slide please so this this tells you a little bit more on the new ripple map we'll discuss more the the the ripple side at the roll meeting so if you're interested in this document and this multicast operation for lln uh i invite you to also attend the role discussion uh later on this week i think it's wednesday um so the six sellers as i said earlier they they have a little bit more to do first they need to accept more than one registration uh with different rovers and they they will not consider them as duplicate uh they have to pass the new flags saying unicast multicast versus anycast in in the arrow and turn that into dao in the the ripple target option now we have uh the same flags for any caster multicast which which has to have to be set and uh as the 6lr injects that into ripple uh in with the new uh mode of operation the dow from the 6lr flows all the way to the root just as if"
  },
  {
    "startTime": "00:14:02",
    "text": "it was an external destination a ripple and a wildlife and so the multicast or any gas packet back can be tunneled to the 6lr uh with exactly the same tunnel as if it was a unicast packet to ripple a neural leaf the the six large encapsulates that packet and instead of a unicast ip packet it will find any cast on multicast then it will rot them appropriately to the 600 um packets which are generated inside the deardag uh since the only route uh the the only route in the the diode is default towards the route they will just follow the path to the route and it's the root which will effectively uh find that it's multicast or any cast and and do the appropriate processing if it is multicast it will uh perform ingress replication meaning that it will make one copy per 6lr which has listener uh at least one listener for for that multicast so a number of the six lr's will will get a packet over their tunnel and encapsulate and forward to their six senates each 6lr registers only once i mean it just injects one in in ripple meaning that um the root will will have to distribute one packet per 6lr and it's the sixth error role to distribute multiple copies to the six elements um for any cast instead of passing the packet to all the six errors it will pass it to a select one and we don't effectively uh say in this specification which xlr i mean the policy in the root may depend on the number of things like load and this specification does not enter this configuration just says the root can select one and further specification or implementation will decide which one next slide please"
  },
  {
    "startTime": "00:16:03",
    "text": "um so as i said the six error is is modified more than one uh 6ln will will register um actually the 6lbr is modified in the exact same fashion and as we extend the arrow to add the a for any cast and m for multicast flags we also uh change the idah message to to carry those flags and by the way uh we do that using the status field which is the only field that was still free in the other message and which was used for the edac the confirm but not for the idaho request so now for the ida request we set the flags in the same byte actually that will be used for the status on the way back uh so six eleven six lvr must retain all registrations and index them by top or register the trust rover um they as i said they will inject the addresses in repo that can be any of the existing modes including and and that can be the new mode if it was a mod 3 which is storing mode with a multicast support we actually in indicate extend that mode to to say that um the flag uh must be set for multicast if it's multicast or any gas if it's any cast and for any case we we specifically indicate what the new behavior is which is you select one of those children and only one for multicast you basically make a copy per child in storing mode on the way back when the the packet is received from from the parent in storing mode and from the root in non-storing mode uh the 6r the capsulative tunnel looks at the packet and now it can be any cast on multicast so it will find possibly more than one registration if it's any cast it will select one"
  },
  {
    "startTime": "00:18:01",
    "text": "again we don't say by which logic which policy and um the only thing is if the the back if it doesn't manage to send that packet to that selected 6ln he still has the opportunity to select another 6ln which listens to the same anycast address and after some retries uh retry to this other six element for multicast the goal is to deliver one copy to each child and in radio networks radio lens typically it's it is more reliable to do a unicast replication that means send a unicast layer 2 packet layer to frame containing the multicast packet to each of the six elements one by one next slide please so there's a lot of consideration about backward compatibility this document this specification was done uh by the explicit request of ysan which is uh one of the alliance which uh used six six law uh specifications and uh they were effectively in need of having a support for multicast and they needed the spec from the iatf to cover it uh they were you know very pleased that we propose something that does not entail uh supporting mld and so as is the fact the case with h505 uh even for multicast now the device can live without any mld at all um but but there is a lot of of brownfield there's a lot of deployments uh of this alien specification that will need to be incrementally uh improved by with the part of multicast so there needs to be compatibility and deployment considerations regarding mode of operation one in particular which which is deployed throughout so basically what we say is yes you can deploy this specification in a brownfield with map1"
  },
  {
    "startTime": "00:20:01",
    "text": "but the devices will have to know whether a cxlr supports this specification or not and only uh send multicast registration to cxlrs which do understand it so we we we added a flag in the six cclu the capability option to indicate that the cxlr supports this specification effectively and there is also some text in case the 6lbr does not support it so we can still operate if the 6lbr does not support multicast which which is seen by the fact that when we register multiple multicast address or multiple any guest address multiple times the same any cast address um the six lbr would say duplicate duplicative and even though we signal uh it's any cast so in that case it it really means that the 6mbr does not understand the signaling of any cast and multicast and so that's that's how the 6lr can know that the 6br there's no point in in doing the idac with with the 6lbr because it will not understand it um so at that point it can stop doing it and we also describe the incremental operation uh with maps of three next slide please um actually there's one last thing i did not write in there is uh the routing doesn't have to be a ripple right that can be uh all those routing protocols we already support and um as i said we are already working on on using signal pannendi in evpn at the best working group they will be presenting at best about that and so um we basically want to to ensure that what we are the the the uni interface that we are defining defining between the the node and the router can be used for any routing protocol um including bgp in the case of evpn and so we we in the one hand we'll be uh"
  },
  {
    "startTime": "00:22:01",
    "text": "extending um those those other uh drafts to support multicast and as well we are also providing already some other um integrations in in this specification and we discussed in particular the use of meeple which is also quite used in lln so um we basically say hey you can use the new mod of operation for non-storing multicast even if the the routing for multicast is not triple it's not disingress replication by the root instead of doing this ingress replication you can for instance use meepo to to us you know it's a flooding mechanism to flood the multicast message and then the 6lrs will get their copy and they will do as if it was received out of the tunnel voila so um yeah this is a very recent document we are actually trying to work very very swiftly on this one because of this external alliance which which needs it you know as soon as we can deliver it so we are proving actually that the itf can deliver respect uh in in a fast uh space when that's really needed by by our partners so so far we are doing good and i hope that that will get some uh reviews soon so we can progress the document so reviews are welcome and and please think about doing them quickly because we want to have a very fast turnaround on this one question feedback i'm not saying questions yeah perhaps one comment would be that well it would be good to if we could have a couple of volunteers to review the draft there was already some discussion on the first versions of the document but anyway it will be good if we have a couple of reviewers so if anyone wants to volunteer please"
  },
  {
    "startTime": "00:24:03",
    "text": "let us know and implementations as well i may say i see adnan for instance in in the list uh yeah if somebody could look at trying this on on one of the open source implementation of six law that would be really really nice because we could get you know first-hand letters feedback pascal one other question do we have to share this with other work groups who might have feedback on this as well there will be definitely a sharing with raw because i'm presenting at role and at some point we will have to ask our id to to synchronize with alvaro retina with the routing id in charge of of raw to to figure out how we progress this document the the idea was so far that we we progressed at six low and but we must have reviews by wrong and so at some point i guess there will be maybe a last call or something at all as well you know something to ensure that role is is fine with this document because we are defining a new mode of operation for repo in this specification so it cannot be done without you know wrong contribution i was chatting with uh margaret and i think he said him might also be interested in this so he requested that him get notified kim ah okay neat i didn't think about it but yes uh ripple builds a tree for multicast which is ripple story mode which is very very akin to a pm pm3 very good uh for the ingress replication that we are introducing here it's more like what tvpn does actually any any others okay let's let's move to the other spec interest of time so um next slide please shut up"
  },
  {
    "startTime": "00:26:01",
    "text": "so this this now is is a a quite ancient document that we tried long long ago story goes that when we did eight nine to nine uh we realized that now there is uh on the ethernet side there is this knowledge of at least the partial knowledge of the address mapping uh for at least some of the addresses mapping of mac and ip address which can be used to reply to an ns lookup for all the addresses which are registered to the 6 lbr the 6lbr could definitely answer as a unicast request response exchange to an address lookup as opposed to doing the um the multicast ns lookup that you all know ends up as a broadcast on your system so uh yes it only works if the address is registered otherwise you know basically the 6lbr uh needs to say hey i don't have this registration so if you have any other way but at least it can be tried as a quick uh first try before the um the lookup the actual lookup is done you might realize that the 6lbr is is really abstract it can be implemented as a bgp evpn network for instance in the case of the vpn draft you realize that the whole bgp database is effectively the six lbr so it's completely distributed on the other hand it can be implemented as a lisp map server map requester msmr uh in which case it's you know it appears as centralized even if just like dns it can be something complex in the back end so the 6lbr is really a conceptual object what we do with those rfcs is we just provide a handy type of messaging to talk to the 6mbr and so far it was used mostly to to provide duplicate address detection that"
  },
  {
    "startTime": "00:28:00",
    "text": "was the goal in the original rfc 6775 of a whiteboard well we can write all the existing addresses so if there is a duplication we can see it from that board without doing broadcast well with the draft that we are talking about now we are also enhancing the 6lbr as being the uh a registrar that you can query for address lookup and when that works well you have a very fast and uh unicast let's read the value unicast exchange to get your address uh sorted out your mapping sorted out and as you know that's pretty much what happens in a modern fabric right now when you you go to a lisp msmr and and request your mapping and that's what happens as well uh but proactively when when evp and vgp uh exchange the wrought tap five well you can actually have this mapping as well so so basically asking to your six lbr what's the mapping is pretty much asking your router which does the vpn what's the mapping because he has that information in the in the case of vpn it will the router will use it itself to encapsulate in the vxlan but actually you could consider a very same fabric while you don't effectively encapsulate you just ask the router hey give me this mapping i will use it right away on the flat fabric next slide please so this is like i said a very old draft which was published you know when we we kind of were finishing uh the background router document and we just realized hey uh instead of having six lbrs uh all across the networks in for instance within the wi-fi access points you could actually uh consider it as more abstract and centralized uh on somewhere on the backbone and if you do that uh then then anybody can query it and that's pretty much what this document is doing um to be able to query it we"
  },
  {
    "startTime": "00:30:00",
    "text": "needed the uh sla option in the edit message because that's usually how the cxlr which would be all the access points uh are talking to the six lvr which is which is now centralized virtually centralized um and and that that that addition was already done with eight nine to nine so we don't even need to specify it um eight nine two nine already said hey you can transport your uh nd options in the other message so now we are we we are actually leveraging that because the through the diary dac or through the nsna exchange the 6lbr will be aware of the mapping and you can query it uh either on the local link using an sna or even from remote using either idac to to get the address mappings so we we started the draft at sixth low two years ago there was this comment that it's uh it's mostly for the ethernet side so maybe you could try six man so one to six men uh tried and failed to to raise interest and that that can be explained by the fact that we are not maintaining an existing protocol which is really the specialty or that group but we are creating really something new which is based on work which was done elsewhere and so i mean we never really caught up at six men with any of this work and so it's not big surprise that after two years we can say hey we tried but you know what we didn't raise interest so so let's come back to the route and do the work at six low that's pretty much the proposal um i think you have next slide twitter yeah so it's basically what i said uh just summary of the exp of the operation so now you can think that the 6lbr is virtually centralized on the backbone and every information that is available to him which is all the address mapping that we are registered i can also be queried by anybody on the backbone or even further than that and for that we leverage the sla"
  },
  {
    "startTime": "00:32:00",
    "text": "option not only in the nsl uh but also in the other dac exchange and by the way we we we provide this new message which is similar to a dac but the code the the the type is the same as in the redac but the code is is incriminate to say uh instead of saying address duplication remember redac is is duplication bad basically this becomes address mapping so it's it's got one instance of godzilla called prefix one and it really means address mapping so you can use it to query and address mapping and get a response back and that's it this time shredder thank you don't think i have it next time oh yeah so yeah there we go so yeah i can i can improve it a little bit um then i would like to see if we get support in this group to continue this work thank you i don't think we have time for discussion maybe we should take it on the mirror um we should move on to the next presentation which will be carlos okay so hello again i'm going to present the updated version of the draft and title transmission of compressed packets over 15.4 networks my co-author is an amira buddha from maglio next please so first of all as a quick reminder of the motivation for this draft as the working group knows rfc62a2 has been the basis for header compression in six low pan and also in six law it was designed for 15.4 the target technology below ipv6 and it has been adapted or reused several times for the"
  },
  {
    "startTime": "00:34:00",
    "text": "relatively similar iot technologies for which ipv6 support has been enabled and well last year there was the publication of rfc 8724 also known as chic which is a product of the lp1 working group she defines adaptation layer functionality and it includes a header compression component so she has been designed for even more constrained technologies which are such as lp1 technologies and for that the header compression in chic is more aggressive than the one in insecure pan the trick is using static context based on a priori knowledge of head field values so next please so we can give some numbers on the performance that we can get and we may compress the headers of ipv6 udp and co-op down to 11 bytes by using the traditional 6lowpan or 6low compression whereas we could reduce those headers down to a size of only two bytes with chic this is for both mechanisms assuming the best case global addresses and no co-op header options so for battery-enabled devices this may represent some theoretical battery lifetime improvement when those packets ascend over 15.4 by up to roughly 40 even if we include an additional third byte which would be the shift dispatch as will be shown later although a disclaimer here is that the actual improvement will be lower depending on various parameters and features such as the device hardware including the sleep state current consumption mac layer and application layer settings payload size and so on next piece so this document is related with a previous document that tried to define a six lowpan dispatch type for chic"
  },
  {
    "startTime": "00:36:01",
    "text": "sorry however this document has a greater scope it tries to provide all the details needed to enable the transmission of compressed packets over 15.4 networks so today i'm presenting revision zero one which provides some new content an improved structure and it aims to incorporate the feedback from the last idf next please so on the updates in zero one uh here you can see a div of the table of contents so you can see how the two main sections in the draft section four frame format and section five sheet compression for ipv6 udp and corp headers now are more detailed and more complete next please so in section 4 we define the frame format what you can see the figure on the slide corresponds to the 15.4 frame payload when a sheet packet is carried and the leftmost field is the sheet dispatch so in this version of the draft we would use a one byte pattern from page zero the one that's suggested is the one written here to be confirmed by ayanna and this is better than the previous approach where we attempted to allocate a whole page for shik so this is better in terms of making a more efficient use of the existing six loop and dispatch type space so this byte here is one of the not allocated ones currently okay so the ship dispatch signals that what comes next is a compressed ship packet and the next field is the chic header which comprises a rule id and if any a compression residue uh in this version of the draft we state that the ruling this size is 8 bytes 8 sorry 8 bits next piece"
  },
  {
    "startTime": "00:38:00",
    "text": "then in section 5.1 we specify how ipv6 gdp header compression is performed we state that it must be performed as per section 10 of rfc8724 except for one thing which concerns ipv6 addresses and udp ports in the base sheet specification rca 724 there are two terms which are related with the underlying architecture that's assumed where there will be devices like for example sensors here abbreviated as depth and some application which might correspond to some entity uh in charge of centralizing data collection on the network side here abbreviated as app these two terms allow to use a single rule in both directions so there's no need to have one rule for compressing when we send in one direction another rule for the other direction however the problem here is that in 15.4 networks these two concepts do not always apply for example when the two endpoints that are communicating are in a mesh network and are in the same category so for this reason we stated one that if an iid is based on layer 2 header fields then we don't use the compression decompression actions called the iid and app iad instead we use compute iid and then there's another consequence which is that in the base chic specification the terms uplink and downlink are defined by using that an app so if devenup do not always apply the same happens with applying and downlink so perhaps we may want to use new terms the list in some cases which could be transmit and receive as is in version zero one in this document next please so we also have some initial content in the security consideration section uh because the document does not define"
  },
  {
    "startTime": "00:40:02",
    "text": "header compression functionality beyond the one in fc 8724 we state that the security considerations of the corresponding section 12.1 from the base specification apply and also we add that as a safety measure a shift decompressor must not reconstruct a packet larger than 1500 bytes to avoid some type of attack which might want to overload the resources of the receiver the compressor okay next please so that was everything from my side i don't know if there's any comment or question yeah uh dominique yeah um thank you for the presentation i have one question uh what's the reason for choosing that the rule ids will be one byte why why do you need to specify the rule id length and is one byte enough well admittedly this is a bit tentative um so yeah it seems like at least for the use cases that we were considering it bit seemed to be suitable seem to be enough um although this is actually open to to discussion so if there is feedback on these or some alternative ideas we are open to to discuss this and the first person of the question was why do you need to specify the rule id length here why can't you leave it open yeah that's another another point yeah it seemed for the moment it seemed like specifying this uh might make maybe implementations more simple uh perhaps it would be enough but yeah maybe we we may want to have some"
  },
  {
    "startTime": "00:42:01",
    "text": "additional thoughts about whether we might want to have some maybe unspecified size for the rule id okay uh pascal yes uh uh i was wondering um yes this this uh point that you made about uh device two device basically when you i mean i'm a bit anxious about this deriving from iid and and it doesn't seem too fair to to find out that you need to to operate uh in in a mode symmetrical or non-symmetrical based on the trust i'm still a bit confused by that i hope we can discuss and find something a bit different um but the the core of my question is is the lp1 architecture we are writing in this architecture that you have both cases effectively as you described the the asymmetrical and the symmetrical kind of modes and i just wanted to make sure that that what you are presenting here is completely covered by the architecture otherwise we probably need to to adapt the architecture to make sure that what you describe what you need is is also there so so yes basically i was asking hey can we sync this document and the architecture make sure we have the full story and this story of iid doesn't look fair okay okay yeah i mean if if you were talking about bluetooth we could say hey kind of easy right uh if you talk to to the central device then probably you can be asymmetric or if you talk device to device you would be symmetrical um because you know who is your central device but in 154 you don't know who would that be maybe we could just say symmetrical by default do we really need this optimization of being asymmetrical"
  },
  {
    "startTime": "00:44:03",
    "text": "okay yeah so we'll discuss this and consider it for the next update thank you thanks a lot i think any further questions we can take it in the chat and on the mailer moving on to luigi's presentation yep okay um thank you uh i'm gonna present in the next two minutes also an update about the native short address draft so slide next yeah thank you also there are a few things that are new in this document including me as a co-author i'm not the only one that joined the the effort that is also david pegley of china mobile uh one important thing is the fact that actually the the document changed name so this is a revision actually but still numbered 0-0 the the title is now native sure addressing for low power and lossy network expansion just to be clearer from the title of the scenario to which this document applies okay and we we also spent some quite some effort in try to detail uh the scope of the document because this is as i said is about uh lln but with um fixed geolocations so the the kind of mobility that we can have in this kind of networks is mostly related to radio connectivity not"
  },
  {
    "startTime": "00:46:00",
    "text": "physical mobility okay next okay uh for those who knows the the content of the the previous version there is one section which is the nsa allocation so basically how we create the addressing of the different nodes so the the allocation function that does that specific action has been better formalized so that is a little bit clearer to understand and most importantly we added a step-by-step example so that we really can see how to build the addressing and how it works yet at the same time the allocation function is open to be modified if someone wants to okay if by any reason it finds uh something that allows you to improve one aspect of the other the the specs now allowed to let's say upgrade the allocation uh function and we also added further clarification about the nsa addresses itself how they interact with ipv6 and how the what happened what happens with the whis of the routing tree depending on the topology that we have slide we refined also the description of the erotic mechanism because depending on how the how the the addressing allocation is done then we have actually a very simple way to do the forwarding because we basically look uh at the length of the address and we take a decision so if the the address is shorter it means i i have to send it up in in the"
  },
  {
    "startTime": "00:48:01",
    "text": "in the hierarchy of the tree that we we are building if it is the same length i ask i'm the destination yes or not if not i send upwards of if it that the destination has a longer uh addresses and this in the prefix of a certain node he sends it downwards let's say so we we better clarified everything every step and we added a flowchart that hopefully helps in understanding what all these operations next um we revised a little bit the communication with an external nodes so when we go beyond the root of the nsa is building and we want to communicate with the ipv6 destination basically so there is an important distinction to be done one is when someone external wants to contact a certain node so but by in that case it is easy to to set up the communication because at the very end is the route that decides a mapping between the external ipv6 address and a an artificial nsa address that is used to map with the externa the other way around needs more work in the sense that if an internal road wants to to contact an external ipv6 address this decision is made locally by the node right and but the the it the muppet nsa address of this external node has to be decided by the root so what we do is we send the first packet with a full ipv6 address the root takes a decision and sends back a message and specifically a nice cmp"
  },
  {
    "startTime": "00:50:01",
    "text": "v6 message in order to tell the node this for for next packets to be exchanged you can use this short address okay next um the usual stuff in a certain way when you revise a document is to polish the text we try to polish also or simplify the the various figures that are there and i better highlight the benefits that the nsa format introduces the ayanna section has been completely uh revised i mean this is in line with how the the ayanna consideration section should be written so we are asking for the some registry and we start to populate the content of those registries next so this is the result obviously of us the co-authors but with the help of uh different people with which we had interaction and we we wanted to to thank them all for helping us to improve the document and pinpoint some issues that we we try to to address okay and so thank you but further feedback is always uh welcome obviously next so this is the the final slide um we we did quite a thorough work and we are going forward so the last slide was about we the authors think that the the the the document is uh stable and maybe it could be considered to be adopted as a working group item yes to"
  },
  {
    "startTime": "00:52:01",
    "text": "be discussed i don't know if we have time now but certainly maybe later on the mailing list thank you i open for question if times allows yeah so perhaps there's not much time but uh there was one point that raised some concerns in the previous presentation in the last idea about the renumbering and so on when there was this dynamic in the network with links uh changing and so on so it would be good to to see whether the people who had concerns on this uh may have any comments so yeah perhaps it will be good to have some discussion on the mailing list about whether the updates address those concerns uh yeah we proposed a solution we certainly can discuss more on the mailing list knowing that we we consider a rather static scenario but but anyway uh absolutely uh discussing on the mailing list to to to check whether the issue is considered solved with the current television is something that can be done and i guess pascal is asking to comment on that i'm not being told that i can speak but since nobody's speaking yeah if you tell me okay the applicability is uh all the network is built on eight port switches you know ethernet and you know exactly how many parts you have and and the wires will prevent you from trying anything stupid so yeah that will work uh so so if you give us an applicability statement this is for exactly this"
  },
  {
    "startTime": "00:54:01",
    "text": "network where none of the issues and there are multiple ones which killed 80 to the 155 and other stuff apply then yeah why not but um you need to be very very specific on you know where it applies because generally speaking it won't work just the same way 155 didn't work and so you have to you have to provide that i mean yes if you say eight part switches only i'm okay i'm done okay i i mean we we did provide text uh to specify the the scenario but um we can certainly have uh more interaction through the mailing list and see if this is sharp enough or should be improved um yeah that at the end of the day this was our intent uh to clearly shape where this solution can be applied okay thanks so thank you very much thank you so we are a bit running out of time so we may need to proceed to the last presentation and continue the discussion uh on the mailing list so yeah now we proceed to the presentation about my how you song hello uh can you hear me yes hello yes okay um this is houston from future technologies and today uh i'm going to going to talk about our new dropped on the using short hierarchical ip address and edge networks next slides please okay so uh we all know in the iot networks uh the entity communication are"
  },
  {
    "startTime": "00:56:01",
    "text": "highly sensitive to overhead and energy but on the other hand uh we know uh uh the ip this overhead is uh you know uh uh due to patent is due to the heavy um ipv6 uh or header overhead due to the long uh source and destiny addresses um but meanwhile uh most of the communication happened in the edge network actually between adjacent and related entities and these share the same ipv6 prefix so the key observation is why should the entity know the prefix at first place next next slide please so uh if we observe the address we can see uh the entity in the iot network will share a common ipv6 subnet prefix and below that if we further partition the network into multiple levels then each level will own its own network id and finally the entity id is only part of the suffix of the ipv6 address so therefore all key ideas lets the entity only know and use its own entity id and while we delegate all the network id and the prefix matinees and operation to the gateway routers next slides so therefore for the address part of the packet header we can only maintain the length of the source address and the destination address followed by the two variable lines the source address and the destination address in this way we can really compress the address part of the header and for the network and cache architecture you can see we will have multiple levels of the sub networks and each level will have a"
  },
  {
    "startTime": "00:58:00",
    "text": "one more gateway routers we call them level gateway routers so the the network prefix for this level of networks only maintained by this gateway router while other entities in the network will only know its own network it's a node id and there are some other type of routers called intra-level routers which are responsible for packed forwarding within the level network uh those those routers are you know they don't maintain any prefix with them within them next slides please so here is example of a network you can see the external networks i've in the ipv6 that mean it uh allocate um you know 96 prefix bit prefix to this edge network and within this edge network it owns a 32 32-bit address space we can further partition this network into multiple levels on the left side you can see there are three levels of network on the right side there are two levels of network so in this network if in the first case if a node x i want to talk to node y since they are both in the same level of network so you can see uh their source address and destination address are of the same lens and there there's no need to go outside of the level networks they can directly talk with each other with their own short address in another case if node x want to talk to node in so they are they are in a different sub networks and but their common level network is a level one network so in this case the node s need first go out of is a local level two network you can see uh first it will go out uh"
  },
  {
    "startTime": "01:00:03",
    "text": "go through the lg rb a level gateway router b so level gateway router b will keep its own network uh prefix is which is a 16 bit uh bit long so as this router it will augment the source address with this prefix so uh on the left side you can see the example here the source address changed then now the source address and the destination address have the same same length then it came forward in the same level of network and eventually it will reach the level gateway router e and that node because the destination prefix is is no longer needed then it stripped off the this prefix then only leave the node id of the node n and forward into this this is this lower level network and finally um node n receives this package and with only the necessary part of the address next slides okay just quickly uh well we are already behind well the official time for the session has finished so if you can quickly recap yeah okay um that then next slice and so you can so so yeah so basically this is a uh address scheme uh to um how we can truncate or the the you use only the necessary part of the ip address and we have a way to incrementally deploy it in the current ipv6 bit network because it only affects part of the edge network and in the following slides i also show uh that it's a relationship with a current existing um header compression schemes"
  },
  {
    "startTime": "01:02:00",
    "text": "so basically it's orthogonal to those schemes uh those skin can still apply but this scheme alone is a stateless and is applicable to all kinds of networks so so so um the so can you go to the last slides i just want to uh show um yeah yeah so we we are looking for maybe next slides let's just skip this one yeah looking for a collaboration and also future workstations and also we'd like to find the best place to adopt this work and also see if uh um sixth low uh is uh uh interested interesting to this work thank you okay so a quick comment from my site would be that it would be good to check how does your mechanism compare uh against other mechanisms like six lopen header compression or even cheek header compression for example in terms of which would be the resulting header size after compression so that that would be good to know to better assess yeah in previous slides actually have some uh a brief summary uh to for the comparison uh you can look at that but also i can give some other solid number on the actual saving of the overhead so the point would be to see if uh your mechanism would be able to outperform the existing mechanisms or do something or has some particular benefit that the existing mechanisms don't have i think it would be good yeah i think some yeah yeah many uh benefits some it's applicable to and many different network uh environments us and also have some"
  },
  {
    "startTime": "01:04:00",
    "text": "other benefits right but in terms of uh overhead saving uh i i don't think it's a uh it can compete with those other compression schemes because those schemes are based on the context based header you know reduction compression techniques we here we only concern the part of the address and also we can apply the similar techniques to reduce the size of the other part of the header but this is note may concern of this draft here we we care only about address and also show is a benefits to to be applied in many other environments okay at some point the room will get closed so i don't know there's time for any very quick question or comment otherwise we can continue the discussion on the mailing list so all right thank you if there's no further comment or question then let's end the session here so thanks a lot to everyone for attending and contributing and making comments and presentations thanks a lot and see you in the next meeting and on the mailing list you"
  }
]
