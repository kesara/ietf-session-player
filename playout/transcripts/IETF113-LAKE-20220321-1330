[
  {
    "startTime": "00:00:10",
    "text": "so so can you keep an eye on the timings of the presentation yeah okay so okay so that worked there now so the matrix and jabber are linked with the zulu the lip is not it works but it's not connected to the boss typing no indeed but i get insulip the messages from jamba no those are not so these were sent on the lake stream okay so it's working one way yep yeah i'll keep an eye on okay so should we wait or hard to know universe yeah how many people are 35 in me taco"
  },
  {
    "startTime": "00:02:02",
    "text": "so we should just remind them to sign in to meet rico yeah so just for remote people we'll give it another minute as people put down their cookies and coffees and come into the room and then we'll start so hmm i can do that all right good afternoon for the people here good morning good evening whatever it is for remote people um welcome to the lake session at itf 113 we've fairly full agenda today so we'll be trying to keep the time uh i think i'm gonna do some of the administrative stuff but it's just going to look after the technical content but i'll be hassling people if they're using too much time or getting close to their time so this is the note well you should all be aware that you should all be nice to each other our agenda and links are there i'm keeping an eye on the jabber we have no takers thank you and"
  },
  {
    "startTime": "00:04:00",
    "text": "um as far as i can see that the jabra room is connected to meet echo and to the matrix stuff that's no longer supported and it seems to be unidirectional talking to zulup if you're using xulip so if you write a message in zulup i might see it here but other people might not okay so since this is a hybrid meeting it's a little bit different and since it's monday you may as well repeat this so the blue sheets are for the people in the room you need to sign into the data tracker so please do that to make sure you're counted there is a um there is a on-site tool that allows you to join the mic line and to take part in polls uh that's that's a pretty limited interface so you might want to just join that in your phone and be in the other one on your on your laptop if you didn't uh for remote people again usual things make sure audio and video are off unless you're presenting i think the plan is that the militia is going to share the slides but hand over control to the remote presenters because i think most people are remote and again for the chat if you want us to repeat something then just preface it with mike okay so our agenda we've got two hours we're on the first point uh militia will give a quick update we have reports on hackathon some developer feedback uh militia has some implementation feedback as well security updates then we'll be talking about the various pieces of analysis work that have been happening on uh the current drafts uh uran will talk again then about you know some of the issues and and change requests and so on that have been applied to the editor's copy of the draft and next steps"
  },
  {
    "startTime": "00:06:01",
    "text": "so just does anybody want to bash the agenda there's the first part there's the second part i'm not seeing anybody joining the queue or in the room oh by the way if you you know in theory if you're in the room here and you want to join the mic line you should hit the button and then join the mic line just to keep you in the right order we'll see how that you know it's a nice thing to do but we'll see if it's needed okay so with i think that's the administrative done you can pick your next set of slides okay so hello everyone so this is malicious speaking on behalf of me and steve on behalf of me and stephen so just to give a quick update on the status of the working group since the last itf meeting so we have adopted the lake traces draft just after the last meeting we have declared the ad hoc specific specification it's in its 12th version as ready for formal analysis and went ahead and published an article in ieee computer magazine inviting the academic community to study the protocol so the the article kind of summarizes the the protocol and invites the community to study it in its different model and which proved to be a good idea because we already received quite some feedback as you will see during the this meeting uh because of that the ad hoc specification was frozen uh meaning that we did not publish any new versions in the data tracker since itf-112 but the author team was not lazy and then they kept working on the specification in github so currently the latest version is the editors version in github"
  },
  {
    "startTime": "00:08:00",
    "text": "that said we will be discussing the next steps how to proceed and how to get organized considering these concurrent activities that are taking place so we will present uh today's meeting is a little bit peculiar in that we have the chartered items at the end of the meeting the items of the charter of the working group this is because we are giving priority now to the analysis that is taking place and the main chunk of the meeting will be given to the uh to the security analysis uh from different teams that are involved uh so just to give a brief overview of about this article that was published in ieee computer magazine it summarizes i said it summarized the protocol i presented it briefly before it was even published during the last itf meeting uh it invites the community to study uh the protocol in the two models symbolic and the computational as well as the the implement to provide some feedback and code on uh the implementation security so we have eric in the queue eric oh okay just that oh if you sign into the tracker for the session you're in the bushes yeah so the blue sheet is implicit when you sign in for the session yeah and the last point on this one is like if you didn't notice once i was correcting the proof of the article in ieee computer magazine i found out that cosy stands for common open software environment protocol so that was kind of funny so yes we went ahead and corrected but it was a bit it was it was a funny situation with all the details that we've been working on in terms of this article and then the whole the big old the big title coming out wrong so yes that was corrected uh so as i said today's meeting is focused on community feedback uh so we"
  },
  {
    "startTime": "00:10:01",
    "text": "have two presentations from the implementers uh as well as i will give as a participant of the working group give a presentation on the implementation security update that is also kind of implementer feedback we will have a presentation on the symbolic model progress as well as in the computational model progress model analysis progress uh and in terms of the formal status of the working group so we have a milestone that is set for march 2022 to ship the document to the isg so this uh we will discuss during the next steps it is not likely to happen right now as we want to to vet the protocol first before shipping it obviously to the isg and we will discuss this towards the end of the meeting in the next step slots so that would be all on on our side stephen do you have something to complement okay so with that i propose we proceed with the next agenda item and this is marco tilock giving the report on the hackathon activities there's no square started yes so marco just showed next slide everyone can you hear me i suppose so so this is a short report from the academy we had the past weekend uh mostly on site next slide please yeah the focus was very much on development i was even before um testing and especially malicious worked a lot on his implementation for uh rust aspect as part of a bigger project i understood to produce something it was verifiable first of all and and then usable later on also for uh microcontrollers and other environments and this is pretty ambitious indeed and the goal was very specific to produce a runnable implementation very minimal especially with the goal to"
  },
  {
    "startTime": "00:12:00",
    "text": "end up with the smallest possible size for the most critical edit message number two which is something you can achieve considering the configuration summarized here so thinking as initiator only static static defilment and id cred as kid specifically integer trying to avoid any any dependencies and and to use harder acceleration when possible next slide please right the the start was not entirely from scratch something was available before the the hackathon started especially harder abstraction layer in rust and and of course the ambition was to cover the very latest version of edox so the editors copy to become version 13 of the draft and well by the end of the academ everything missing to have something running was actually completed uh so the the protocol state machine and all the uh crypto primitives necessary to process um enoch messages uh basically and this code is now available in the openws and vehicle github on a dedicated branch next slide please so with that say we we were also able to do some testing so malaysia considered is code rascodas initiator role run against my code for eclipse californium as a responder again both aligned with the very latest editors copy of the specification and again we tested the configuration intended for a minimal pair of endpoints and the result was fortunately as expected we indeed could have a confirmation that we produced a message to a doc of 45 bytes in size on the wire and the test was also successful because uh we both produced the same smart markup could interrupt you could just pick for the mic because we're receiving oh"
  },
  {
    "startTime": "00:14:00",
    "text": "better now okay and the test was also successful because we indeed produced the same master secret and sold at the end of the dock execution and next slide please yeah we are on the next steps there are a bunch of few uh more implementations that are under currently update uh to catch up with the latest version of the specifications so we expect especially those implementations and more uh to run more tests in the near future i think it'd be good also to yeah cover a bit more of the traces and possibly the use of message four and of some error messages uh out of the addoc exchange as a possible additional site testing if anyone is interested as a separate documenting core related to edoc that purposes if you want an optimization to combine uh in a single request on the wire the final adopt message three with the first oscar protected request in case i have that implemented so i'd be happy to interrupt that little extension too and that should be it thank you thank you marco so just for clarification this is so we now have nine independent implementations available of ad hoc which includes both constrained for embedded systems and for non-constrained systems so i think that that is important to stress out and thank you for running for championing this hackathon activity thank you for the great work so i propose thank you uh are we good retirement yes so i propose we continue with the next agenda item which is the developer feedback and the first one in the queue is francisco so francisco can you uh can you hear us yeah i am muted okay so do you want me to pass you the"
  },
  {
    "startTime": "00:16:00",
    "text": "controller i will pass you the control of the slide so that you can switch the slides on your own so it should be good now could you could you test yes it seems good okay so the floor is yours okay thank you um yeah so today i'm here to talk about a little bit about our experience with implementing and using ad hoc in highly controlled environments so um just to go through a bit the agenda uh first going to go through a bit about the context and the use case that motivated us motivated us to work with others and our process in writing this network implementation and and using it and so it was a bit about first looking at what was available what we could use what we needed to implement and then take a look at a bit of some benchmarks and the lessons learned during this process and so our contact was this uh cyber security research project at india called rio tfp where one of the research access was around next network security and so the some of the use cases that we were looking into there made lake and nether really really relevant for us and so that's how some of some of the people in our teams were involved in the working group and one of these use cases we had in mind was we are looking for completely different research projects and to uh privacy concerns around uh contact pricing and we have these this use case where we had a couple of contractuation devices which were an f52 ple devices which were communicating with a backend server over an untrusted ipv6 over ble-link and so um we were using ad hoc here to establishing a security context or communication channel between the the contact pricing server and the"
  },
  {
    "startTime": "00:18:01",
    "text": "devices so we're performing a king key exchange between these two um and so just to set a bit of context our goal here was to write a generic implementation of ad hoc that would be uh able to run on a different series of microcontrollers with quad core resources so we're targeting non-memory allocation we're not planning to depend on hardware acceleration so most of the things we're going to see in the presentation are all software only we wanted to support all authentications and this was at the time of drop 05 a little bit so we wanted to target cyprus one to four which at the time uh were mostly uh p five one six of p two five six or c two five four one nine signatures library for example there was no afterwards and no the all the um application encryption algorithm were all iscm so there was no chat at that time for example and we we also wanted to focus just on writing networks so we didn't want to write the crypto libraries ourselves we didn't want to write simple libraries ourselves or cozy libraries we want to reuse as much as as much as was possible not too much uh as many libraries that would most likely be used for our own applications as well to avoid call duplication in the end we wanted to run it all on a series and variety of microcontrollers um so while the just to reiterate it was uh on draft of five and so all the building blocks are pretty evident or it was we needed something to seaboard something for crypto or key generation timing etc we also needed some interrupt interrupt variability infrastructure in the sense of test vector and interability interoperability peers since on the server side we were not running in a controlled environment and so it did not make sense and we probably were not going to run the same ad hoc implementation"
  },
  {
    "startTime": "00:20:01",
    "text": "was something to put it all together so when we started looking around we there were like a couple of seaboard libraries that we thought we could use and the seaboard tiny seaboard both had their advantages and disadvantages but they were designed for embedded and had a pretty small footprint and fast executions uh when we look at the crypto backend there was there's a lot this uh in no means an exhaustive uh list but this was kind of crypto libraries that for our previous work we already had somehow integrated so we knew we could use and the main part here is that like a few libraries were doing everything we needed the ones that were like well necessary or heckle we're not doing it in an embedded friendly way or did not provide an incremental api or other reason that made it not the best choice and the other ones were not doing everything we needed so uh this was our first point to telling us that okay we're gonna need to actually support probably multiple crypto backends and might want to switch among them and if you look at this is just a table that summarizing some some stats on signing but it already tells us that like when you go looking for some crypto library uh it's all it's all gonna be about trade-offs there's none that does everything perfect uh and if you're gonna want speed you might be sacrificing some flash and stack and depending on your use case you might be okay with sacrificing uh a couple of kilobytes in ram to get more speed and and others that's just going to be not possible so we have this interesting noise that we're going to have to use multiple crypto icons and probably abstract them for our own application and then we needed something to put it all together and so for example there was a lot of options up there like riot zephyr embed os my new etc we went with riot because we from our side work we knew it very well and so we knew what kind of package of"
  },
  {
    "startTime": "00:22:00",
    "text": "support it has and how we could use it um and they also some stuff that we identified pretty early that or during the process that we're missing so for example we would have liked to use cozy abstraction ourselves to avoid uh then having code duplication in our application side but sadly at the time there were actually no library we could find that we could use because um there weren't really any any match between all the back ends it was supporting and the cypher suits at the time so sadly we had to write our own cozy function but at the end that had some side effects on on the full application um and also although this cozy abstraction of having a cozy library that's basically doing the abstraction of the all the crypto libraries underneath for us and providing more clean interface to all of that was nice we still realized we were gonna need some direct access to crypto for generating keys hashes etc so we couldn't really get a way of going completely around it on the test vector side uh at the time it was somewhat limited we didn't have like cyborg certificates and the certificates we had were not real certificates like we tried to parse them for example for with an embed tls x509 library we will get errors because we want some fields that we're missing and so francisco does let me interrupt you when you say no real certificates you want uh what you mean i suppose is that the instead of a certificate there was a dummy byte string presented in the in the template okay that's it and and on the interrupt side of the time there was not that too much that we could use so um or not that we were at the time everyone was starting to develop at them so we didn't have too much there um and so this is what we the the end result was we had this c implementation of head hook called ad hoc c uh there's the link on at the bottom and we"
  },
  {
    "startTime": "00:24:01",
    "text": "we use nano sieber then our default backend was time equipped for all the uh piece notification and hashing and for signature we're using an sdh we're mostly using the c5119 implementation from daniel beer and for interpretability well timothy that was working with us wrote by head of edda which was quite useful for us for testing all the time because as i tried to emphasize a bit at the start part of the challenge was actually putting all these crypto blocks together uh and assembling them and on the python side there was a non-issue so we could easily cover most of the cryptosuits methods and parts we also part certificates generate certificates much easier to be then be able to test uh this implementation and as i said we chose right um and just some some now i'm gonna go into some benchmarks some stats of like what what the result is and so um rom was around 10k 9k and ram we realized was actually changing a lot depending on the method we were using so uh there's there's two tables here one one is on meth of zero so uh sign sign and three is uh static dp element on both sides and uh two different colors are two configurations because we also realize that well since uh we're trying to not do uh dynamic allocation we have static buffers everywhere and and since uh in the different cryptographic stages you are using previous information as cryptographic material uh the amount of size you are locating for additional data or for credentials for credential id and ends up being more buffer space you also need to allocate for the eventual uh transcript etc and so tuning these parameters like for example just allowing for one byte in uh one by credential ideal whatever connect can"
  },
  {
    "startTime": "00:26:00",
    "text": "actually have quite could have quite some impact on the actual uh stack usage of the different uh message generation and parsing functions but it was roughly around 4k in the in the worst case with these default configurations but again it was very influenced by the size of the allowed the maximum load size of the credentials the credentials id additional data when you look at the timing that takes actually computer handshake this is again no harder acceleration we run some measurements where we're just doing taking two notes doing some handshakes either either over the wire over 15.4 or ble or everything through co-op and our worst case scenarios or maybe were with a signature very sign sign metal zero where between two cortex and zero is taking up around 20 seconds well uh the best scenario is probably with an m4 where it was taking around six to seven seconds when uh doing a static difficult authentication meeting um but if we try to take a bit of a closer look to understand why it's taking so long it's actually most of it is related to crypto and if there's a paper that i'm referencing at the bottom which were stuttering the the sign of verified times that uh for ed25519 and we can see is basically the overhead is coming from there for if you look at uh on an m4 for example verifying a signature of 32 bytes takes around two seconds and 800 milliseconds to to sign it and so we're doing this twice in the process and so we have like a baseline of six seconds just from the signing verifying but again this just one library as i was trying to put in context first you can also speed it up by changing the library but maybe you're sacrificing more ram or more fresh usage than your"
  },
  {
    "startTime": "00:28:01",
    "text": "implementation is gonna use um yeah and so this is a little bit of some numbers and then we try to integrate it all into our application and we have a couple of things that we then realize in the field that sure initially we we decided just to write our own cosi function because it's pretty simple code but at the end we under have ended up using cosy libraries in our application code which end up ended up having some redundancy so yeah so we have a question brandon in the queue brandon um no i don't i didn't we so the end result we have so far is that we didn't support we only supported at the time cypher stood zero and one so there was no p two five six but uh i do have a table somewhere where i'm comparing them but i didn't do the hog enough i can i'll locate up uh let me see i'll finish and then i'll try to look it up but it's in the same paper that there's the comparison as well for p256 that i'm referencing in slides 15 or 14. um yeah and so we also realized okay a reaction api like the one embed tls was providing would have actually been quite useful in most of these cases because the amount of time it was taken to verify or signatures or signing verifying was actually uh going over the default timeouts we had in for our application so we had to do some special handling for that and all of this could have maybe been prevented with the re-engine api and then just some feedback to focus on the on the implementing the draft itself so again this was just drop five at the time it was quite confusing for timothy who was developing this uh"
  },
  {
    "startTime": "00:30:02",
    "text": "who had the responsibilities of passing credentials how it should be purged since from the ad hoc side what how was it supposed to receive the credentials information uh this buy string identifier that was um uh trying to save this one byte from its point of view seemed to not be worth the extra code completely that i was actually introducing and well now it's been dropped since seven i think uh we got some insights on how we could like also to go ram to get the best out of it there's probably some stuff we could have optimized um and maybe have some work buffers because most of the rams that come from uh static buffers that are allocated for the key streams the cozy keys and stuff like that and then even though we used cipher should 0 at the time it was mostly because what we had available we would probably do cipher two or three but we could also if we didn't have something in our application that was already using iscm we might use cypher suits fund because uh at least in rio chacha poly is smaller in size the accm it's simpler in this business in its implementation and and it's as well easier to implement within incremental api which translates roughly into less ram space that is needed because you don't have to serialize the same information twice in memory while parsing and that is it i'll try to look up the table for the paper where the there's the comparison for d4 pe256 and ct5019 okay so thank you francesco so we have brandon in the queue am i in the queue uh yes you can hear me now oh good yes on page eight i just had a question about the comparison between the uh the different cipher suites um am i to read this correctly saying that you don't believe that embed tls supports aes gcm"
  },
  {
    "startTime": "00:32:04",
    "text": "i think at the time i'm sorry that is not correct okay embed tls absolutely does support aes gcm and i'm not sure about any of the other x's you have there but i think it's worth having another look um just let's i thought i should bring that up thank you yeah i'll take a better rook okay thank you brandon for the clarification do we have any other questions in the room no okay so thank you francisco i think that is a good overview of at least of the uh that gives us an insight into the performance of the of the protocol when it is fully implemented in software when the crypt is fully implemented in software those numbers are indeed quite large but as you said they are allocated to to crypto so i propose we go ahead with the next agenda item and this is uh developer feedback number two uh mark so francisco all right can you hear me well yes so let me just francisco can you pass me back the token yes developer feedback you can skip the first one i can skip okay so there you go hello everyone so my name is mark i'm the social architect within the assabloi and focusing primarily on the iot stack which we call the modular iot platform you can go to the next one thanks so just a super quick uh overview why we why i actually been introduced to this challenge is that the company i work for is built upon number of of companies and divisions and"
  },
  {
    "startTime": "00:34:01",
    "text": "the idea was that every of these divisions are building the stack of their own and and just to unify that i've been introduced to the to the challenge to find a stack that can be then shared across multiple uh multiple companies and multiple divisions and it's just because it's it's the numbers and the scenarios that are so large it's been it's been a hard challenge and uh if we can go to the next one please so the yeah so the challenge i like we got introducing uh was to to find a good modular iot stack that can run on the embedded platforms also mobile and the cloud and um yeah one of the the key challenges and something that we wanted to enable is to device to cloud device to mobile and also other way around and device to device uh secure end-to-end communication where we can go uh over multiple hops with different middle boxes uh and not uh and just keep that uh do not break that end-to-end security just keep it uh all the way down so um and and to have all of that implemented in the application layer so we would not have to rely on on something within the the lower layers and we wanted to work with the formats around the identity like x 509 certificates or maybe using cvts or jvts and then all of it to be backed by standards so we can maintain security more efficiently so we don't have to keep evaluating and and just be the only paradise looking at the issue and uh you know we wanted to achieve that with the with the open source as well and um if we can go to the next one please so the areas that i was looking at and we were looking at was was more complex than just the communication so we had to look on the provisioning so like the generic iot stack the provisioning devices with identities etc the communication which is something i will focus on today and the operations like firmware updates etc"
  },
  {
    "startTime": "00:36:00",
    "text": "next one please right so the solution we have we have been evaluating and we have been using so far was based upon co-op oscar erock we use for identities we primarily focus on the x 509 certificates and more so just to give you a little bit of details on the edoc we are currently on the draft on the latest draft so draft 12 and we are compliant with that next one please right so the architecture of the stack looks pretty much like that so starting from the top so we have our own rpc protocol that we use but it's not a requirement but it's something that we wanted to to keep in in some of the products and then going down we for the for the encryption uh we wanted to use oscor like i said for the key exchange we focus on using error and then we treat uh everything was backed by the by the co-op and then on the transport layer we wanted to like i said we wanted to run on the application layer so we wanted to stay a little bit independent from the transport so we escaped going on the ip networks only so we wanted to use the stack in the mobile phone like device to mobile phone and mobile phone to device examples so on the ble side we we just used the the standard gut with services and characteristic communication on udp we use co-op as intended and then we also introduce some other transports like serial port with with in the same way we use usbl let's say on the we wanted to keep like rx and tx pipe uh on on every protocol that that would support that so on the ble side we didn't have any good use case and we didn't have any good uh example maybe on using on how to use the the co-op over ble uh so we went down with uh leveraging um uart protocol uh on over"
  },
  {
    "startTime": "00:38:00",
    "text": "ble so one characteristics for read and one characteristics were right i can go to the next one and then on the yeah just looking on this one across the different platforms we could we could have or we did replicate that the whole stack over multiple uh over multiple areas so on the embedded we we could have achieved the same stack and then on the tooling side like the cli tools mobile sdks we also completed to do that for the cloud as well and as you can see we just have a little bit different on the on the transport uh back ends so for example in the cloud we also wanted to see if we can fit that uh feed that use case into existing solutions so we we use the message broker when in our case was mqtt we wanted to prove that the communication can run over like uh just any uh any transport so i know maybe it's not ideal but we run it over mqtt so we had the co-op running over mktt just to see how well it can fit into the existing ecosystem but uh and and and just having all the security and the logic within the application layer next one please right so just focusing on the adult libraries uh in the previous presentation there were a few technologies mentioned which uh i didn't put in here but but i i might as well talk about it so we wanted to keep the tech the the code stack to the minimum and to not have like six or seven different or five different ad doc implementations and oscars so we went with this architecture so for the embedded part for the ios and for the node.js which we use for tooling we went with the single c library that is microscope micro adopt library so each of them each of these three free components like on the embedded ios and node.js are just the wrappers or just wrapping the native c library so on the node.js we have a native"
  },
  {
    "startTime": "00:40:00",
    "text": "module on ios we're wrapping the c component with objective c and then using in swift and then on embedded we just use micro oscar micro directly and yes we have as a back-end we have used embed tls which i can confirm uh on the on the previous note on the aes that it worked um but we use embed tls on on nrf on the embedded part we use uh embed tls version from nordic semiconductor that is hardware accelerated uh version so we got the full hardware acceleration on that which are some numbers i'm going to talk about in a sec and then for android and cloud we have our own add-on implementation that for now we keep internal but that might change in the future and just on the top you can see that we try to keep these apis very easy to use and and just with the minimum input from the user next one right so just to give you some details on our add-on use case we are focusing just for now we are just focusing on on adult usage with the certificates and then so we have cas on both ends so we have a responder root certificate on the initiator side an initiator root certificate on the responder side and then for the for the credentials we use full x509 certificate which we then validate so we go with uh our certificates use p256 curve so we go to the with the method zero with signatures and uh suit number two right okay so just on the embedded platform like i mentioned we use nrf52840 with the freertos that's a maybe not not not a main or master three-artist version but we have our own modified version a little bit uh for the co-op we use lobaro uh co-op library and then microscope micro edc and then for crypto we use embed tls that is hardware backed and we have that"
  },
  {
    "startTime": "00:42:01",
    "text": "platform that you can see here but all in all we just as the main we're running this on the standard uh nrf 50 to 840 dev kit next one please right and a little bit about the performance so this is a screenshot from the node.js2 that we use and that node that communication here was running over ble over standard gut so we have our own dongle firmware like a zephyr dongle zephyr firmer dongle as acting as a ble uh as a bli donku that that is running over uart so node.js tools over uh on over standard hci command will communicate with that board and then we'll in the node.js library we have like full ble api to back it up it's actually based on the open source noble library and then this screenshot shows a node.js2 being an initiator communicating with the responder that is running on rf 52840 with our rpc protocol on top of it and as you can see like we do what we do here is we do scan for ble we connect we discover gut we perform the addoc like i said with the credentials using certificates on both ends uh with the method zero and suit number two and then on top of that we do oscor and then we set up our own rpc uh command and then uh all of that is taking less than a second so just for the add-on to complete without the the initiating of the of the rpc layer is about 700 800 milliseconds for everything that i said together with the validating full validation of x 509 certificate and just just for my understanding uh and the clarification of 595 milliseconds what does it refer to okay so that's the first number uh so the first number is where we uh"
  },
  {
    "startTime": "00:44:00",
    "text": "where we con connected over scanned the ble connected over ble discovered got and sent message one okay so kind of ble uh let's say you set up with the first industry okay and 770 is the actual ethical handshake and that's the but that's the total time from the start oh so that's included in the so okay so just between message one and the full add-on it's been let's say 180 milliseconds okay so we have a question from michael yeah maybe maybe melissa michael richardson here maybe melissa just asked the same question and i didn't understand the question the same way um so bluetooth has uh a encryption layer and gat avoids it or yes okay so so you're going clear your your ad hoc messages would in sense be in clear over bluetooth yes okay just want to make sure i understand that yeah that's really cool yeah okay so ad hoc over bare metal bluetooth kind of exactly okay yeah pretty cool and the total so all of that take it takes 770 milliseconds obviously i chose the best one i had one running for 800 something but for the screenshot wise i i choose the 700 milliseconds but yeah roughly we always stay around seven 800 milliseconds so but and that's important to know that this is there is also you are delay because the bridge is communicating over the ble bridge is also running over uart so there's always going to be a few milliseconds here and there of the delay next one please and this is the same this is the same or similar results but happening directly from the mobile phone so [Music] it's exactly the same process so like i described before so scanning connecting discover got certificate exchange with the certificate validation and what we"
  },
  {
    "startTime": "00:46:00",
    "text": "validate for is just so you know we validate for the we validate against the root certificate and then we validate the expiration time that's the for now that's the the only certificate validation that we do and then on the mobile side uh we did avoiding this uh uart part uh like with the tooling site we get a resource in 600 700 millisecond range next one please right so for the future uh for now uh we would really focus on we want to build uh now uh a co-op http to call a proxy for our cloud infrastructure uh that's also gonna be backed and working with the adult and oscar and we can try to stay as much as compliant to the to the co-op http proxy specs we have some things that we are not sure yet but with that with those things we hopefully uh can contribute back to the specs and also the open source uh which we already do for example for the microscope micro reduce library we have been working first with the front offer and then with the author stefan now to uh to also be included as a as the collaborators on the on the on the c library so just as a clarification the new ad hoc and new escort oscar implementations were presented during one of the past meetings by stephan here and he he presented the findings of his paper that includes these benchmarks so yes so we work we we work with stefan on that as well and then uh more on the personal uh activity um i was working with goran on the on the latest test vectors for the traces and and my contribution uh that's going to be uh that hopefully will get up soon is to build a better test vector or more modern test vector generator the current one that we have is is not the best one"
  },
  {
    "startTime": "00:48:00",
    "text": "and and it requires some more love i suppose we will discuss this during the traces draft discussion together with all the updates on the traces yes okay perfect all right and i think that was the last one if i'm correct thank you very much yes so do we have any questions for marek i see no no one joining the queue so thank you marek for agreeing to present today for giving the feedback to the working group it is encouraging to see the the protocol being used in the wild prepared to be used in the wild and thanks everybody for staying on time so i hope i don't have to clamp down on the next presenter so yes but before we go to the next presenter i would just like to uh bring the comment by francisco to the mic where he confirmed that on the slide set of developer feedback number one there was a mistake in the embed tls column where all the all the rows should have been tracked including the asccm primitive which was shown as not supported so francisco confirms that this was discussed in the chat just one more comment that i think the edward curve support is kind of in pr's and not there yet but there's you can get it from them so just for clarification we're still talking about embed tls and the support for x25 uh for curve two two two five five online the addsa is kind of from what i see it's prs and it's towards this year that should be fully integrated but because there's already you can already use it uh i didn't quite capture that maybe if you can release it sorry there's in the in the in the table i had like some checks with some from with an asterisk and those means that it's not in the master branch"
  },
  {
    "startTime": "00:50:02",
    "text": "but you can there's pr or somewhere that's implemented then you can use it and for e25519 that should also be the case for embed tls okay so just maybe as an action point francisco if you can take to update that slide that contains the error that we can upload to the data tracker and have correct record in the itf is that okay for you yes okay thank you oh okay maybe it's better if you share well sorry no but you need to click to press the buttons oh you want to stand up okay sure which one are you okay so hello everyone with my chair hat off this time so next slide please so to give you some context about this presentation uh as you know as we all know at ho uh so as we all know lake uh as a working group targets constrained environments and constrained environments in our context mean embedded systems so many of our implementations will be executed on embedded systems and you're probably all aware that the embedded programming languages today is dominantly c and c is memory unsafe and c doesn't play well with security so uh what we standardize here is obviously crucial to security of the protocol but what what ends up in the wild is uh as important and the protocol in the wild will be as secure as its"
  },
  {
    "startTime": "00:52:00",
    "text": "implementation is so uh the goal of the work we've done was to produce an implementation that has some security properties such as provable correctness of the implementation with respect to a given model provable memory safety and side channel resistance to considering the threat model where the the device itself is not completely trusted so a team from india in paris called prosecco developed a framework called hackspec that is a a framework for uh verification of different implementations that uh essentially for the generation of verified implementations and next slide please this framework is called hackspec so the uh it's called hackspec and uh the specification language is a subset of rust so what that means is that when you write your model your specification you are essentially writing rust code and when since you are writing the rust code this means that what you write the model the formal verification model is no longer some mathematical abstraction of the protocol it is executable code and this specification enables the generation of uh verified implementations which means that it is possible to generate a formally vetted implementation satisfying those security properties from this model and uh this pro this team from india has developed a complete framework uh to type check this rust specification and to enable its compilation onto different mathematical abstraction abstracting languages such as f star and essentially it can be also executable"
  },
  {
    "startTime": "00:54:03",
    "text": "next slide please so in practice what that means is that uh to uh to arrive at uh at an implementation that is formally vetted uh we need to uh write some uh implement some code uh in rust uh in a subset of rust called hackspec and then uh by using their framework to generate the uh to generate the f star model which is this mathematical of mathematically abstracted language of the protocol that allows the the verification of different properties of the protocol against the model so once you arrive to that f-star model you can essentially prove the different properties such as symbolic security on the protocol in an automatic manner so from f-star model which is step number two in this procedure here we go what is necessary is to write and uh to write and verify the implementation in another language called low star against this f star model that was generated automatically and from there on there is automatic set of tools to compile the slow star code to verified c or verified rust code satisfying those properties that we wanted to prove from the very beginning so you can see this kind of flow on the right and i'm trying kind of to abstract it for you and i'm focusing mainly personally on step number one where we are implementing this uh specification that is the model that is going to be compiled to the f-star uh f-star model next slide please so the goals of the implementation are two-fold"
  },
  {
    "startTime": "00:56:00",
    "text": "it needs to be verifiable but in the same time it needs to it targets as lake targets constrained environments and it needs to be executable on microcontrollers so for in my mind that means minimal implementation minimal uh very lightweight implementation of the protocol where we are not pulling in a bunch of different libraries and dependencies and we are keeping the memory footprint and the the code footprint to its minimum as we've seen from the previous presentations software execution of different cryptographic libraries takes a lot of time and we've seen from francisco's presentation that it can take up to uh like uh 50 or 10 to 15 seconds to complete the hand track due to the crypto to the execution of crypto on different microcontrollers in software we want to rely on hardware accelerated crypto so our initial compilation targets are essentially native to facilitate development but then also cc2538 board from texas instruments and this nordic chip that both support uh acceleration of the different ad-hoc cipher suites next slide is so we encountered a couple of challenges on this path and the main one is that we said we want a verifiable implementation but the problem is that this framework that prosecco from india developed relies on rust standard library and cannot be compiled in a no standard environment meaning that it's hard that it's at the moment not possible to produce an executable for microcontrollers second point which is kind of uh a feedback for the uh well not not really a feedback but it's mostly a point to uh to be aware of is that during the this work of implementing the protocol uh majority of my time was spent on figuring out the uh the su not the"
  },
  {
    "startTime": "00:58:02",
    "text": "support but getting around the uh the the point compression not being supported in the libraries point compression meaning that the elliptic curves uh the point in an elliptic curve is typically represented with x and y coordinates in a compact representation you will transfer as we use in ad hoc we transfer only the x coordinate and you're supposed on the constrained device or in the implementation to calculate the y coordinate on the fly and this is poorly supported with the existing libraries including the one that huxpeck uses so a lot of my time during the implementation implementation actually was spent on that and uh finally in rust since trust is uh there is an ongoing initiative on porting rust to the different different popular hardware embedded uh systems the for some boards that i outline namely for ti cc 2538 board the support is still lacking so we are kind of developing it on the fly next slide please so the current status of the implementation is that uh we progressed this during the hackathon uh quite a bit we came into the hackathon as marco outlined with a minimal implementation that passes the test vectors uh different essential unit functions and we came out with the fully fledged minimal implementation that uh interoperates with the java based back end that uh that was used for interrupt testing so this minimal implementation means the initiator in static static mode with ccs and with integer kits essentially instantiating the 45 byte uh handshake 45 byte message two of the adhoc handshake and what is important here to outline is that the implementation essentially uses zero"
  },
  {
    "startTime": "01:00:01",
    "text": "uh external libraries all the seabor and cosy encoding are done inline and it's completely no std style uh developed so uh the as i said the status is that the implementation passes the test vectors on a native machine for now successfully interrupt with uh with the california medha and we are currently working on the build support for different boards that i outlined next slide please so we have a couple of open questions that we want to bring up and discuss with the formal analysis community and this is mainly related how can we ensure that this model that we write is really uh bound to the specification because this is the the one big assumption that the academic community makes when doing when modeling the protocol and when verifying the implementations so essentially they're making the assumption that the model so in this case this rust code that we write is a perfect or i would say ideal representation of the rfc so and this is very open question how we ensure that so this is something we will take as an action point to discuss with the crypto with the formal analysis community and mainly the prosecco team and in terms of the implementation the next steps are essentially to complete the port to these two boards and to publish this as an as a crate on uh crates dot io to be available to the people in open source and once that is done we have our formal model that we need to use to formally prove the verif to generate formally vetted code that can be executable on a microcontroller so i think that is my last slide yes so here are the people that helped out during the development of this in alphabetical order so this is christian here also karthik franciscus denis and"
  },
  {
    "startTime": "01:02:02",
    "text": "marco during the hackathon and during the previous the sprint during the previous period so are there any questions no okay thank you um okay with that uh i propose we go with the next agenda item and this is the computational analysis of the ad hoc protocol and baptist can you hear us yes i can hear you okay yes so we hear you loud and clear so the floor is yours okay so hi everyone so i'm gonna present you the how we will prove the security of the adduct protocol in the computational model so first the differences between the symbolic and the computational security so in computational security we consider the messages as bit strings rather than terms and the primitive are simply functions on uh bits and bit strings in the computational model the attacker is a near probabilistic polynomial time algorithm and the the goal of the attacker will be to learn any bit of information on on the bit strings so where in"
  },
  {
    "startTime": "01:04:01",
    "text": "symbolic security the attacker cannot distinguish when the value of the secret changes in the computational security we uh we have to prove that anata cannot distinguish between a secret key and random value so a bit of context so we have the constraints of adducts a small number of some whole number for a small number of messages small message size and minimize code and memory footprint so this this constraint leads to [Music] to the use of in some in the summer so you have uh need to use a 64-bit security mac and [Music] 128-bit security electric curves defiant and so there's a qualification about this sorry for interrupting you so just as a clarification so this is one particular mode of ad hoc and uh static static and uh obviously the most constrained setting the uh cipher suite zero and two which use the eight byte max that's it so the the idea is to prove that even using a 64-bit security mac we have no no leak of security so our security goals so first we have to define what is a security level of 168 bits so we have to consider the execution time of the protocol and the success priority of the attack so"
  },
  {
    "startTime": "01:06:02",
    "text": "the success probability for the attacker to distinguish between the session key and a random value so with t the occasion time of the protocol and epsilon the success probability we have to prove that t on epsilon is at least greater than 2 to the 128. so if we reach this we can we can say that we have a security level of 128 bits so we have three points to approve so first we have the key privacy so at most both participants know the finalization key so by compromising the long term credential of srp an attacker should not be able to compute past session keys so this is a forward security so even yes even if an attacker gets the information much later he cannot take older keys and get information about it then we have the mutual authentication where executive both participants have the material to compute the final session key and we have to to prove the identity protection so for the the key privacy so that's also known as implicit authentication it relies on the computational development assumptions and therefore it depends on the group side in which we are working and to prove the key privacy we will we'll use the find then guess model"
  },
  {
    "startTime": "01:08:00",
    "text": "where we give the adversary the access to three records so the first one is the descent where the attacker can model um well where the send oracle models an active attack in in which the editorial may intercept the message you can modify it create a new one and you can do whatever you want the reveal oracle where he ran which models the misuse of the sessions keys by a user and finally the test oracle which tries to capture the adversary ability or inability to tell apart a realization key from a rodent one so the idea is that given so an infinite access to descent and reveal the oracles and only one access to the test oracle the attacker have to we say that attackers succeed if it cannot distinguish the session key from a random value so the idea here is to that we will consider the the attacker that [Music] can use as many times the sand and reveal oracles when uh when he will uh he will think that he uh he when we think he can say that the key is either a valid key or a number u he uh use the test record and then uh he uh he wins if uh if if it's guess is a is the good one so the mutual authentication so that's equivalent to the explicit authentication so"
  },
  {
    "startTime": "01:10:00",
    "text": "we we use flags to represent the the mutual authentication so we have two flags the first flag so most initialized eyes at zero is the flag accept so either the initiator of the responder will activate will put the accept flag at 1 1 am when he has the required material and we have the terminate flag that asserts that the uh the other participant has the required material so uh when uh the the idea is to prove that uh both participants can activate the terminate flag with the recurrent security and here it relies on the mac security so i said before as we use 64 bits mac so that's [Music] that's there is a that's there's a mistake so 64 bits max provides 64 bits security and as we want to prove that the we have a 128 bit security we are we will check so the if the 128-bit security is reached after few messages because the idea is we know that we have a sync with a simple execution we will have a 64-bit security but we want to check if after four or six messages so we have other information that will allow us to guarantee to prove the mutual authentication okay so just as a clarification uh just as a clarification in the requirements document we have agreed upon the"
  },
  {
    "startTime": "01:12:00",
    "text": "security level of 127 uh bits and we do include eight byte max in the in the protocol so what what this is referring to is that the 128 security bits uh that they are studying uh if i if i understand correctly about this please correct me that you are studying that after a few application messages that are exchanged we can actually reach the 127 bit uh security uh over the given key even though the macs that were used to authenticate the handshake were only eight bytes is that correct it's perfectly correct so the that's it so that's uh that's the goal thanks for the clarification and the third point is the identity protection so by definition we we have the identity protection if the protocol is secure against active attackers for the initiator and against passive attackers for for the responder and how to represent the security by uh using games so we will give the attacker two identities and an active attacker should not be able to say which one is the initiator and for the um for the responder so also we give two identities one of them will be the responder but a passive attacker should not be able to distinguish which one is the responder and"
  },
  {
    "startTime": "01:14:00",
    "text": "to conclude we have the protocol decomposition so in yellow you have the data used for the key privacy so that are the the difficult man defeatment public keys and mutual authentication will be other value in with the value in in green and the identity protection is ensured by the inclusion so the idea is to study so each of these values for the the security concerns and prove or conclude that the the security is as expected 127 beats or say that using a mac with 8 bytes is not is not doable so this is the the end so if you have questions okay thank you batista so i believe we have scott in the queue okay uh okay can you hear me uh yes we can yeah uh excuse me for for not following us real closely but i believe what you're doing is saying you'll exchange several messages using a 64-bit mac and you're yours and if all those messages authenticate then you hope to get the full 127-bit uh security level is that correct yes uh i don't believe gcm gives you that property uh because"
  },
  {
    "startTime": "01:16:01",
    "text": "uh if if the attacker finds the initial uh message and manages to forge it uh how we perform the forgery will tell them how to perform later later forgeries with essentially no with with essentially no additional effort so you only get 64-bit security uh i can't tell you more because you want to to determine if yes or not but the idea is maybe to be able to say that do we have the we do not have the security before the attacker can forge a value so i don't know if it answers your question ah this is not a question this is a comm an observation based on the security properties that gcm gives you this is specific gcm uh your other authentication uh your integrity program routines uh functions do not have the same property yes the they did we uh so yes uh the idea is more than we know the we'll have 64 bit on the forgery but yes we don't know how to say that [Music] maybe that's not being able to detect an imposter before he has the time to afford the mac uh the the the what attack would do is have to get guests right for the very first very first one so it didn't hit well"
  },
  {
    "startTime": "01:18:00",
    "text": "there's a nico okay uh what the attacker will have to do is basically do a correct guess on the very first um uh mackie's attacking basically doing a blind guess actually you can do a little better than that but not much uh once he's done that then uh and he's done that successfully then he can actually do later uh perform more forgeries for essentially for free so i i don't hear you well there's an echo and i believe you can repeat please okay um if the attacker um uh basically uh for the first message he wants to forge he does essentially a blind guess once he's done that and and if he's successful then uh he can he then he he can forge later messages which means that the security of the later messages of those macs does not increase the security level therefore you're stuck at 64 bits [Music] uh yes that's interesting so just at the interest of time um scott scott is it is the kind of attack you're mentioning specific to gcm or what it also means the ccm no is it specific to gcm so i i don't believe we have 64-bit gcm max in the protocol oh you do not okay good for you thank you very much okay great thanks so uh mark and and if we could can i move on time-wise be great so mark go ahead mark you're in the queue marcolunga"
  },
  {
    "startTime": "01:20:04",
    "text": "i guess not uh okay in in that case batiste thank you um i i guess you're wondering about time go ahead yes so um marx has again asked to send screen mark can you hear us we're not getting audio so we'll have to cut it here oh yeah we cannot hear you we see you but we cannot hear you can you hear me now yes now we can hear you oh i apologize uh microphone problems um i just had a question for baptist thank you for the presentation so i'm from ethioric where we have a team also working on the computational analysis so this presentation is of interest to us and we're just wondering in your analysis when you were talking about ski secrecy what did you define actually as a session key uh for the protocol i also know whether you could give some details on that so maybe if someone else as well could jump on that to give a bit some more detail since we're a bit confused on what should be considered as a final session key for edward thank you so the final session key is the is the key that the common key that both participants share so uh that's the that's the i don't know how to say that [Music] yes that's the the key the the share at the end of the of the protocol so i don't know if it's clear so i believe you're referring to prk4x3m yes in a sense yeah so essentially in in as far as we've been in the analysis"
  },
  {
    "startTime": "01:22:00",
    "text": "we're not able to to really clearly say is the pr key considered as sort of the final session key um or whether there should actually be some sort of final derivation as well to actually extract what should be uh the session key um uh so okay uh some maybe the authors can uh respond to that uh if not i can also compliment so you're on do would you like to comment on this or [Music] yeah i think we should take the next presentation but uh yeah it should be higher the arcade correct we have more derivation so it's cutting on your side so i hope it will be fixed it seems like a bandwidth issue yeah i can i think what what is session key it might be different from the formal analysis we need to define the the concept of a session key and then what is actually used in ad hoc where you we do derive different session keys for for example oscar but that may or may not be covered in the formal analysis but i think we need to come back to that yeah okay so uh so we'll have to cut it here so i propose we take this to the mailing list as this is crucial for the security of the protocol and for the for the for the work of this working group so mark thank you for uh letting us know that you work on this uh on this as well i have a final question for the baptist on the timeline of his work so baptist could you comment on the timeline when do you expect to because from my understanding this is the work that has started but is not"
  },
  {
    "startTime": "01:24:01",
    "text": "kind of completed yet so could you comment on the timeline yes so normally i guess it would not require so much time so i have to check with david but i think yes two months is uh will be enough to conclude the security analysis okay okay thank thank thank you so essentially we should hear back from you for the next itf meeting then which is end of july uh in philadelphia we should have more results okay so i propose we go ahead with the next agenda item and this is charlie charlie we see you can you hear us we don't hear you still yes yeah there you go so the floor is yours okay so hi everybody i'm charlie and i'm here to describe hopefully at high level there's a bit of research we've done on lake adhoc protocol so first a brief introduction to the techniques we've been using for this analysis and we've only been using a platform that essentially we can define we can write down protocols inside some kind of high level programming language where you have a way to abstract the inputs on the output of the networks and then from this specification this high level specification we can ask automated tools to verify some security properties and we can typically use a properly for tamarind that have been used previously"
  },
  {
    "startTime": "01:26:01",
    "text": "in quite a lot of requirements to tell us is a particular secure is the protocol secure or is there an attack um so maybe the single typical slide will be this one which is just to give you a taste of what it looks like essentially oh we model things and what we do is we abstract the function computations by simply specifying which property they should satisfy so typically to declare a decryption and encryption we're going to give this definition that decryption of encryption gives back the plaintext essentially and we're just going to define positively the kind of properties verified by the computation and this will be enough to verify your security file attacks and we can define properties in a very generic way um which is essentially event-based and time-based so we can ask for response so what you're seeing at the bottom of the slide is some authentication property we will say saying that whenever r accept with some parameters typically a pki a public key for the initiator which corresponds to some honest api then it implies that somewhere in the past the initiator did accept so we can specify a lot of properties like that secrecy and everything we want to check essentially on lake what we've done which is a bit different from uh other works in uh in our model is that we're trying to push a bit further uh the modeling to capture a lot of small sometimes unexpected behaviors of the primitives that are not taken into account uh so typically for the field man you have an identity element uh that whenever you're gonna exponent it it's gonna fall back to the identity element uh but you also have lower points that can easily create collisions between"
  },
  {
    "startTime": "01:28:01",
    "text": "exponential exponentiated values for instance our signatures typically can have valuability or you can also generate some yes keys public keys that will always validate for against all messages and typically uh functions like uh 256 have uh well based on the merchandise lens extensions and also some kind of um and we can consider many subtle weaknesses of high functions uh that already exist typically for md5 and show one that's uh exclusions and that will maybe one day will exist on 256 and we try to be prepared if they arrive um so um more quickly uh includes the four methods of authentication that can be fully executed in parallel we include a trust on first user padding for the public key infrastructure we would have confirmation of long-term authentication keys session so everything we also built the plus confirm variant so for the the alternative model with the campbell's variant what we're lacking currently is a fine link of the cypher street negotiation which is a bit complicated to have tracks so that's still not done and we don't have the optional first message as well as the key the queue date mechanism that follows and so we on this model we use the tamarind properly from all the tools to obtain this kind of results so this is just to give you a high level of high level id of what we can get where essentially we check each of the property on the left hand side in different threads"
  },
  {
    "startTime": "01:30:00",
    "text": "and what's interesting is that in the let's say most with a basic threat model everything works as expected so that's which nice for the protocol um but when we can start to consider a stronger threat model that will occur a lot of fun that are less likely to happen but that can still be realistic and interesting we start to find some flaws in the protocol and i will describe those in more details but yeah based on the on this big table essentially the idea feedback is that the protocol provides all expected security properties in many reasonable threat models but when it goes to when we go to stronger attackers there are some maybe improvements to be made and so we want to propose three different essentially class of improvements that ideally won't increase the cost of computation or anything but still avoid potential misuse of the current design strengthen the trust execution environment implementation and ideally also improve the future resilience of color so i'm not gonna disappear quickly those three points but for the details and everything we'll be sending out on the main list with concrete proposals to make it straightforward uh so talking about potential misuse now and it actually ties back to the description that was happening at the end of the previous talk um what we call the session key so prk for extreme actually offers weaker properties in terms of securities than the exported keys typically because if we have a dishonest if you're talking to a distance responder they may have a lot of control over the final value of this prk"
  },
  {
    "startTime": "01:32:02",
    "text": "for instance because they will standards the identity actually match or in the post confirm setting uh an encapsulation that can have full control actually of the prk for x3 and k and also compared to the exported section here this session key is not linked to the execution of the protocol and typically it does not authenticate gh4 and so typically [Music] well an implementer may decide currently from the standard to use a different key exporter than the one specified actually and if they do and do not include the tf4 inside the key which is used then you can break the authentication of th4 because the key confirmation since we have prk for x3m won't authenticate tier 4 of course and even competing successfully because typically yes ccm is kind of viable so in the formal sense you have uh the integrity of the plaintext but not on the side for text you can break the absolute key of th4 um so essentially it looks like it was a protocol would benefit from a clarified essentially final key what is precisely the session key which would be the equivalent of the master secret in class and so typically adding a final cheat elevation where we tie together the prk and the transcript will produce the final key with the best whatever guarantees essentially and typically um this will develop some kind of optimization to remove the tf4 from the star material and the exporter in later"
  },
  {
    "startTime": "01:34:02",
    "text": "times essentially um a second potential misuse of the designer uh so it's a bit subtle it's kind of hidden in the appendices but it's about digital resistance resilience one issue is when the standard specifies that an implantation could stop local state to be able to recompute and resend the last message there's actually an issue with that for the third message because whenever we use aeds it's uh very important in terms of cryptographic guarantees to never use the same key and the same iv for two distinct messages and well at the step of the third message if you store the stair if you store the statues to compute this um this message if and if the signature is randomized which is the case for some of the skills proposed here what you're going to do is compute two different messages because the signatures are randomized entrepreneur use the id came with the same iv and key for both of those different messages and thus it falls outside of the classical use of aed schemes so here's the suggestion if it's simple we should just follow this state storing and just simply uh if you want to listen message you need to listen exactly the same essentially um another point we touch that is it looks like the t the twitter execution environment implementation could be stranded strengthened sorry because essentially so this is a very strong threat model but let's assume that all the authentication authorizations are put inside a clustered execution environment so essentially either the"
  },
  {
    "startTime": "01:36:00",
    "text": "long-term significant designing key or the long-term development chair are stored inside the trusted execution environment and we assume that otherwise the device is compromised so what we would expect essentially in this case is that we don't have any secrecy of course but we would want to still have authentication and so concretely it means that we leak the initiator fmri cage at the beginning and we also leave the second key at the end but we don't give that access to authentication keys so here there's actually any attack which is uh so i don't think i'm going to go through it in details but once you see it it's actually quite straightforward it's uh in the static qualification mode where the idea is that actually the mac key and the station key are exactly exactly the same thing they are the same value so if you look at the on the session key you are licking the mac key and then the attacker can using this mac key use it to produce other macs expected and you can lie to respond essentially and thus essentially in the static authentication mode uh trusted execution environment doesn't really make sense and it's to note that um it's not the case in method zero where you can do everything nicely uh and the secret key if you store this product for the signatures inside the te you don't have this issue so there'll be two things here which is one the static authentication method is in term of te implementation slightly weaker than method zero and we need to think if we want to propose implementations we need to find a way to make those things better so there may be possibilities but it's it's quite uh it's still a question to"
  },
  {
    "startTime": "01:38:00",
    "text": "propose the best interface for people that would want to use a ge uh and finally the last point which is about uh so what about 10 years or 20 years from now will it be still secure and essentially what we want to look at are children to these collisions uh so as i said for mp5 and show one those things actually exist and for statue not yet and maybe never maybe in 10 years they exist so ideally it would be cool if we don't have those if these kind of things don't lead to attacks on the protocol uh and so we have a threat model where essentially the attacker given two prefixes p1 and p2 can compute uh two big bit strings c1 and c2 subject uh z creates a collision between the hash of p1 method with c1 and the hash of p2 connected with cq and using this kind of collisions and the fact that the protocol adjusts may accept the identity element we can essentially create a machine in the middle attack essentially where the attacker is going to break the secrecy of the column and also actually lead to downgrade attacks as the response would agree on which cycle shoot this should use and so the attacker can actually become precipitate um it's actually quite simple to mitigate this thing and typically so checking for lower the groups or at least the identity element and this kind of attacks typically expose the fact well you need to stuff a lot of uh bits uh that respond to the collision bits inside the transcript to be able to create the collision"
  },
  {
    "startTime": "01:40:01",
    "text": "fact that you have those extra external authenticated data as well as the identifier ci and cr so it could be mentioned that depending on the length of those of those values it may weaken the protocol in sense and it's actually quite important for a lot of the specifications of message processing it's actually quite important that there is some kind of typing going on and if an element that you receive on the network is not of the expected type typically the suits are supposed to be arrays of integers and if in the middle of this young counter are a bit strange you should reject these kind of things and so maybe the standard and more strict in a sense or say that if you don't uh bad things may happen um so to conclude uh this overview uh well on the long term we first want to improve on the analysis so typically to include the cube date the first message um we plan to keep themselves up to date so whenever the draft evolve our plan is to keep them up to date and this all the way up to the final lfc so if all goes well when the front goes out in the wild there should be a formulation of the actual standard and maybe we will also look at the computational security inside the profession and that's it for me thank you charlie so do we have any questions for charlie so there was a comment by christian but uh you okay so so he will bring it to the mailing list about future proofing this i suppose"
  },
  {
    "startTime": "01:42:02",
    "text": "so in since we don't have any questions uh yeah we can only thank you for doing this work the this is really great i propose a as an action item for the authors to convert this list of this list of remarks into github issues and that we start with discussing those one by one on github and on the mailing list where necessary and this would be our typical uh working process in the working group but other than that i think again this is great thank you so much for doing this work and just maybe could you comment so could you comment on your future plans uh regarding this work because the protocol is still not completely we might publish new versions do you plan on uh do you plan on updating this model that you did and do you plan to stick around definitely so at least on my side uh i want to commit on that uh hopefully i can bring my curve in also uh but yeah i want to keep uh working on this project definitely okay that's great and one last question is or you i i suppose you plan on publishing this in some venue uh in this work yes so please let uh keep us informed uh the working group or us the chairs and we can forward to the working group about any publication that is that results from this work yes so uh with that uh i would like to conclude the slot on the formal analysis and again uh i cannot emphasize this enough how important this work by baptiste and by by charlie and his team uh is important for the working group and i believe i speak on behalf of the whole"
  },
  {
    "startTime": "01:44:01",
    "text": "working group when i really thank you for doing this and uh uh and also i invite mark who we have just came to be uh we just realized that there is another activity going on that we're kind of not aware of to reach out to the uh to the lake chairs or the lake at itf mailing list to let us know about the plan and the activities such that we can synchronize the activities for end presentations for the next itf meeting so with that i propose we go to the next agenda item which is our chartered items which are typically at the beginning but because of the nature of this meeting we've put them at the very end so joran can you hear us yes i hear you well do you hear me yes we hear you well we here well we're just about to share your slides yes that's the one yes that's the one okay so there you go the floor is yours so i propose to keep it down to like 11 minutes and so that we have time for next steps to discuss the next steps sure okay so i'll be quick these are the yeah this this is about both the drafts that we're working on next slide please next slide please oh you have control here oh i have control fantastic oh um sorry i actually don't know how to change lines should i share myself maybe i need to do it again i don't see any controls for the slides um sorry now i found it no worries okay so um since this will be talking about the ad hoc draft and the trades this drive those are the two drafts and there has been on the terms of publications there has been no changes"
  },
  {
    "startTime": "01:46:02",
    "text": "because we have still the old versions but we have been progressing these on the github and what we've done is mainly finishing off the five reviews and updating based on all those comments and that's completed now we don't have any old issues the all issues are essentially related to test vectors so this will be going through the changes that we made since version 12. first the advoc document and the main changes are an update to section three five which is the section on authentication it's an update to section three eight which is the external authorization data it's an update to processing following the changes in 3538 and it's an update on the compliance requirements which is the next slide and a little bit more on the details so section 35 was about or still is about authentication keys authentication credentials identification and credentials etc one request was to shorten this section and there were also specific comments about what kind of verifications authentication operations that was performed the change we've made is that we have now split the content into section three five and a new appendix d where section three five contains the core protocol operations the proof of possession transfer or credential info and appendix d contains all other authentication related info operations like certificate chain validation identity verification and so on and similarly in section 3 8 we also"
  },
  {
    "startTime": "01:48:02",
    "text": "split the content into what are the expectations on the external authorization data and that specification of the ead value and that's that's from that's part of the body now whereas the append new appendix e contains examples um like we talked about in the previous itf meeting so we hope this is making more clear what is part of the core protocol and what is outside the protocol and things that sort of relate to the protocol but are not strictly part of of of the specification and the update to processing was also to handle the accordingly what what the things that relate to the core protocol is is is stays in the processing and the things that are not in the core protocol is taken out i think that summarizes the main changes except for the compliance requirements which is on the next slide so we've had for a long time a discussion about what are the mandatory to implement cipher suites and other related compliance requirements and this and we had a couple of interims and the last interim we concluded on this formulation so implementations must support cypher suite 2 and 3 but we also have a general precondition saying that in the absence of an application profile specifying otherwise and so that's that's what we have agreed on uh in on the mailing list and i mean"
  },
  {
    "startTime": "01:50:01",
    "text": "following this interim discussion so uh it it wasn't something everyone was uh super happy over but this was basically something that everyone seemed to be able to live with and there is another update on the compliance requirements related to padding and we have now introduced them must be able to parse padded messages so uh it's the ability to handle uh plain text sort of to hide the length of the plain text you must be able to parse padded messages but not all use cases need to actually use this so the must is on the receiving side not on the on the sending side and those were the changes to the compliance requirements i'm rushing ahead now stop me if there are any particular questions the other updates made on the adult document are more editorial and clarification clarifying and the other error handling is clarified there's a renamed error code there is the clarification of cypher suite negotiation there are also a one breaking change here in the terms in in with respect to the exporter label so we have reduced the number of characters in the exporter label to avoid an additional hash iteration in the key derivation as you see here score master secret and oscar master salt is now there's not a shorter label uh and that means that the um that that is sort of new that means that the that's that's the breaking change basically when everything up to this"
  },
  {
    "startTime": "01:52:01",
    "text": "point is the same but when you derive the oscore master secret and salt you would now get new values and the test vectors are updated on this point and another update related to connection identifiers where there was a request that to mention that you you actually don't need to have uh support both integer and byte string connection identifiers an endpoint may choose to select a specific range and specify that in the application profile and there's updates to security considerations ionic considerations and clarifications so that's um the other updates and and with that we have addressed all open issues and now we're just waiting for for the the new issues coming from from the hackathon and from these excellent inputs from the from the analysis we've heard today for the traces document this situation is similar we have a new version in the github and we have no open issues related to that and just a reminder the trace's document the purpose of that is to help implementers to get detailed printouts with intermediate steps so you could go basically line by line through through your code and verify that's been confirmed to be very useful but it's not a complete set of test vectors it's just two specific traces two specific test vectors which are annotated carefully and the change we've made since version zero zero is that we have um as this scene here we used to have two traces we still have two traces the the one with static diffie-hellman"
  },
  {
    "startTime": "01:54:01",
    "text": "used to be curb25519 in the new trace it's actually p256 the signature one is still uh eddsa but we have now included real uh x509 certificates not the dummy ones that was mentioned previously in in this session there is also two more additions there is an example of cyprus with negotiation uh on the static tiffy helmand trace and there is an explicit mentioning of y coordinates which also been requested and we reversed the order of the two traces just an editorial here but basically we have all um all the changes that was requested on the tracer and that leaves us with the test vectors and i can i think i can skip now to the last slide i only have a minute left um so the next steps we propose to now take what is done in the master uh branches the master branch to and submit a new version because that has been we have basically completed all the reviews and all the old dishes and we get comments from people who read the old versions and think that elder 12 is the latest version which it is but it there are some changes now so we think this would be the right moment to actually start progressing the drafts again and after that we'd like to obviously address the review comments we've got and when we're done with that we we hope this is ready for working group last call so those were the documents and then the next step is also the most issues current issues are about test vectors so that's what we want to progress next we should set up a breakout meeting this week and"
  },
  {
    "startTime": "01:56:00",
    "text": "marek has already done a very good input here and he's proposed to to help out with making the test vectors more available so i'm done thank you any comments or questions if we have the time otherwise on the mailing list okay so um any quick comments on the changes or clarification questions if not i guess the the kind of next step is is on here that's the one we were kind of wondering so we had agreed that we'd keep trying to keep draft 12 stable while the analysis was happening so maybe the right thing to do is now that we know that some people are working on doing analyses to poll them and see what it would delay or upset them if we move on to 13 or would they find it okay um we could do that we could just we kind of know who the set of people to work is now right yeah yeah exactly so we know there are so this is four teams that are involved right now and i'm so i think it kind of makes sense to reach out directly and work directly with those folks and uh once again i invite everyone who might we not be aware of that is working on uh the security analysis of ad hoc to let us know such that we could coordinate about this so do we have any objections to this plan or that euron is proposing if we reach out to those teams and then let the list know and then we can okay i was thinking okay i wouldn't worry so john in the jar in the jabra chat raises the draft expiry i guess i i don't think we should be concerned with that drafts don't really expire anymore so i think there's a stable reference versus the work ongoing is the question so stephen just to clarify so essentially you are proposing first to coordinate with this with the teams and"
  },
  {
    "startTime": "01:58:01",
    "text": "then to bring to make a decision on the mailing list uh and to let the mail in this line i i expect nobody on the mailing list will object but we should just yeah we decided on the maintenance that we would do this if we're going to just slightly change the plan we should just do that confirm that on the main list so yes so yes the decision to freeze the specification was until further notice so it is up to us right now uh john do you want to say something yeah i think we in the room here knows what what expired draft is not the end of the world but people outside our diet sometimes believe that means the work has been dropped so i think i think the expiry means something and we should not let it expire i think if the implementers absolutely don't want the new version i think we should just take for 12 version and resubmit the deaths at 13 without any changes just to avoid expiry otherwise i 100 sure we will get people asking about if this has the work has been dropped because it's equipped so if i understand correctly the draft will expire on 23rd of april so that gives us one month to decide uh and to proceed uh with the uh to proceed with the next steps essentially seeing if the teams uh checking out with the different crypto analysis teams whether uh they can update their uh their models and their work to the latest specification so i i think that makes sense do in the worst case john i i tend to agree with you that yes we should keep the draft alive and as it sends the wrong signal to the people outside of the working group so but let's worry about it in the days before the actual expiring not now"
  },
  {
    "startTime": "02:00:04",
    "text": "so so with that uh we are done with all the agenda items do we have any other business um yes yes i just wanted to say i didn't talk about the about the test vectors here so um people who are interested in test vectors pay attention to what's happening in the get will happen in the github now so as we start to make that that seems to buy the last part which is uh which we need to to take some uh action on and there's been a lot of interest in the in particular the json test vectors because that's the bulk of the of the tests that you may want to do on your implementation so we the only thing that's needed i think is to get more structure on on on that and so we will schedule a breakout during this meet this week and if you're interested just let us know otherwise we invite the people that we think are interested interested in that okay thank you eran so yeah do we have any other business so i hear none so i propose we conclude the meeting and keep the work going on github and the mailing list thank you all for attending thanks all thanks to notetakers okay right great okay i gotta go and disappear and do a lecture oh okay i'll take the notes and turn them into"
  },
  {
    "startTime": "02:02:01",
    "text": "minutes fantastic yeah but they seem they seem like a book seems good all right yeah so i guess the thing to do is we could just we need to send them to the various teams this way okay yeah yeah it makes sense really i mean they may not come back and say oh what changes are you playing they will just point them"
  }
]
