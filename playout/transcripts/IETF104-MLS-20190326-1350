[
  {
    "startTime": "00:00:48",
    "text": "power hey with the MLS working group starting at 1350 so that\u0027s right about now so let\u0027s get going get close to Mike okay MLS at ITF 104 thanks everybody oh okay this is the note well let\u0027s just start just look familiar basically whatever you say and do will be held against you later uh-huh there if you participate you\u0027re gonna be recorded and videotaped like you are here if you have any IPR you declare it obviously we\u0027ve got some processes and procedures that you can read about from the list there um it\u0027s about it requests we have a jabber scribe Thank You dkg um what who who who would okay so we need a jabber scribe and we need a minute taker so minute take her X oh you do minute taker all right great and if you have to bail then we can swap that\u0027s awesome um there\u0027s some blue sheets going around I appreciate that if you do that if you do the minutes in the ether pad then other people can link into it as well do you know where that is all right cool please state your name into Mike and as well keep a professional at the Mike here\u0027s our agenda two days they were generous we only actually asked for three hours and they gave us three and a half hours so today we\u0027re gonna do some reviews some interrupts stuff do the interim recap that we\u0027re gonna do and then we\u0027re going to go over our architecture document and then we\u0027re gonna start kind of plowing through the protocol issues that we have open then we\u0027re gonna talk about a new draft that Ahmad started talking about at the last interim four federations and then Sophia has some stuff on deniability and then we\u0027re gonna do some planning for what they\u0027re gonna have a next interim and maybe ways of working as well anyone want to agenda Bosh great let\u0027s go forward I have the power Richard burns one minor agenda bachelor since I think you mad is not going to be here until the Thursday session I might propose taking the simplify key schedule thing which is one of his big care abouts and moving that to a Thursday and moving the identifiers discussion evidence that slot which I think I said she slides for both yeah so that I\u0027ll do the D couple identifier is thing in this slot I\u0027ve got there in the protocols discussion all right Richard come on if "
  },
  {
    "startTime": "00:04:02",
    "text": "you want to come back up and give a summary of the Interop call all right so we get for having the first session after one chance\u0027 turn on all the equipment again so just a brief interrupt of dates we have four or five implementations going raise your hand if you have an implementation of MLS in progress oh oh is that do go there excellent cool good to see it so yeah we\u0027ve got Cisco wire Google trail of bits and INRI all doing implementations the approach we\u0027ve been taking right now is kind of operating off generating test vectors for different chunks of the protocol so we\u0027ve got test vectors for the tree math for the resolution algorithm for the key schedule for the core key scheduler for the application key scheduling for some of the message parsing so that\u0027s kind of the the framework in which we\u0027ve been doing interrupts so far not doing kind of live interrupts between stacks I\u0027m trying to kind of gradually work our way up to that by getting the the core parts the protocol so we we had some calls you may have seen scheduled on the list the first couple of calls we had we realized that it wasn\u0027t really useful to do a real-time interrupt we use those more for kind of planning this and establishing this framework figuring out what worked and what didn\u0027t and then we\u0027ve been doing a bunch of offline people refreshing the test factors and testing against the test vectors that debugging issues identifying issues interrupts issues through the wire channel a kind of async style instead of doing kind of live Interop events bigbang Interop revention and so we have I believe linked from the implementations repo an interrupt matrix now where we are marking compliance where people have are agreeing on the test vectors and we\u0027re getting starting to have a fair degree waiting for Diego to report on something he\u0027s the laggard here but we have at least that the Cisco and trail of bits and wire implementations interrupting and I think Benjamin you used reports um recently as well I saw some green in there for you um so we\u0027ve got a fair a fair you know some some some slots in the matrix filled in so we\u0027re starting to get some inter up on core parts protocol I think the like the tree math and resolution stuff that doesn\u0027t involve any crypto like that you know people have developed their own implementations and and then we\u0027re agreeing on that by and large and they\u0027re starting to ratchet up and verify that real crypto stuff starts to match so by the time we get to the interim I think we\u0027ll we get oh four people upgraded oh four and we should have some questions about interrupts all right thanks okay so now I\u0027m going to do a quick summary of the interim so the the "
  },
  {
    "startTime": "00:07:07",
    "text": "interim meeting we had between the last ITF and this current one was held in Mountain View right next to real world crypto so we did get some other interested parties who were in adjacent conference for real-world crypto who showed up and there were some pretty substantive conversations presentations about the encryption of welcome messages add in place lazy handshake messages proxy rien Krypton for server assists user initiated add a brief update on analysis as well as definitely some some conversation about efficiency and one other thing that was brought up that we will talk about here is there\u0027s the possibility to have a federation component and a federation milestone as well as a document that you might has has published as an individual draft that should become coming up as well there are also alternative tree math proposals made one of which was about a two to three tree so we\u0027ll see if that results in a draft being sent sent forward to be discussed here or not but um I have not seen seen that yet and it was it was a pretty great event because all the people who did show up participated and there was a lot of a lot of conversations that the notes are are available in the on the data tracker for this okay so any questions about the interim meeting great all right let\u0027s move forward to outstanding issues in the protocol oh sorry architecture with venture and first yeah I yes one second is that lazy updates or lazy update is anything I haven\u0027t heard of before okay good there\u0027s the type of well corrupted okay so I\u0027m gonna quickly discuss about the architecture stuff basically nothing has changed much since the last few interims because we focused a lot on the on deonda protocol on the protocol document so one thing that changed across both document is the fact that we are on the architectural document terminology instead of the protocol one that was using something called participants so now everything is using client and the protocol document was moved to effect those changes so really I like like we had before AI a 1 2 3 our clients owned by some users and there are members of a group while c2 funston\u0027s is not member of the group so since there are not too many "
  },
  {
    "startTime": "00:10:08",
    "text": "things to say and I just took the slides from ITF one or two when I when we are go of explicit requirements and goals and and basically we can see that like most of the things we want we currently have typically messages are accepted only member of the group message spading fork efika for protecting against African and is this has been optionally included in the protocol documents but since that\u0027s that still I love all architectural role that our G notification with the authentication of everybody who the authentication service that we still keep abstract nothing changed so that you can do whatever kind of on education he wants the one thing that\u0027s going to be discussed probably on cells there is deniability because it actually many people want some kind of deniability and it\u0027s been very interesting to discuss what what we really want or not and we see and all the main security codes have currently in the protocol document which suppose they are we don\u0027t have a proof yet that ongoing progress but we think that we respect those properties so it\u0027s good scalability we have experiments that show we can actually scale for fifty thousand clients it\u0027s gonna be interesting to see your 3d works feel like on the on the network a synchronicity except for the group operations which are like Karis tricky right now after doctor left deliver service actually say that they are although and we might relax that condition for date messages we are actually interesting discussions on least risk results I am sterically something that we don\u0027t really looked at it yet so that\u0027s one big point that we need to look at and meta data protection is is ongoing work the common framing we\u0027ll discuss this a bit more I guess Federation of using in progress and we are running is something that\u0027s gonna be discussed as well so the previous the quickie open question that you actually didn\u0027t look that frequency of the key update I think that\u0027s something we left to so is that we would click command and updates frequency depending on the number of people in the group exit they are and that\u0027s I think I mean we need feel we need a real that data to be able to actually do these kind of recommendations there is ongoing discussion on whether it should be whether we should do subtrees entry camp or doing protecting the number of device etc so that\u0027s also something that\u0027s being discussed but nothing settled yet and requirements on the south side for "
  },
  {
    "startTime": "00:13:11",
    "text": "when the several elapsed is something right now the the in the Transpac boozy architecture on paula cole the the server doesn\u0027t know anything about the groups membership it might change depending on if we add the services tall nuts so this is the questions concurrency of group operations I talked about it metadata its retention there is an interesting questions that\u0027s probably going to be discussed by a half file about the fact that in the key schedule when you pick when you pick the key to decrypt application messages you have the Sandow in the player which is not the public eats and so strong identifier I don\u0027t you find identifiers but it\u0027s like is the index of the position of the Sandow in the tree which is matrix emitted that for some people it might not be acceptable so we are gonna discuss this as a the common same walk as well a femoral signatures on the abilities so how we\u0027ll talk about it on on Thursday so on the editorial point of view since nothing that\u0027s as change in terms of security artists that we really want for for the architectural draft I mean we are gonna the editors will do a round of actually trying to make precise the text way more precise in terms of security guarantees that we want to achieve the the architectural document is quite a long high level for now and I think it\u0027s it\u0027s a good idea that we actually spend time to detail way more the all the informations in there so will between now and the next ITF will make sure that this is a way more strict and sort in depth obviously there will be the changes due to the existence of the Federation document we might actually outsource to the Federation document some constraints or not or include some the Federation constraints inside the architectural document and we see that data and I think that\u0027s all nothing nothing much happened no so we just need to kind of make sure that we pick the pace up on the mailing list ie sending messages the mailing list so what I\u0027m hoping is that we can do is when you put an issue and github on this you lose that people can you know discuss it there as well as on the mailing list and we\u0027ll try to do a better job of actually driving these four new questions to ground and making sure the editorial stuff is done because at the next IETF meeting I would like to be in the place where we have no outstanding comments on this draft and we\u0027re actually ready to work and good last call it and that would be a working group last call not necessary the final one but at least kind of like give people motivations I guess to actually put their eyes on it and complete the reading of it because I think it\u0027s it\u0027s actually been fairly stable we just have to once we get the terminology straight which is a really funny discussion okay it\u0027s like oh it\u0027s that under costs laughs so I think that\u0027s that\u0027s really "
  },
  {
    "startTime": "00:16:12",
    "text": "good great so that\u0027s it now it is Richard sorry just has a note-taker I notice that the slides are not uploaded on the data tracker I\u0027ll refresh to make sure just wanted to make sure that the plan was for them to be there because I did not include any of the contents of that presentation in your notes all right so we are currently on draft oh four that was published shortly before the meeting due to us and hiccups with deadlines and approvals so I\u0027ll forgive you if you haven\u0027t done a real thorough read through so I\u0027ll provide some summary what we did since since 303 I think was published right before the interim so it\u0027s been a couple months since we\u0027ve graphed then we\u0027ve got a couple of open issues I think all of which have pr\u0027s most of which fpr\u0027s ready and so we\u0027ll kind of present what the proposals we\u0027ve got sketched out for these various issues and solicit input from the community so changes from oh three bunch of relatively small stuff so I\u0027ve been I\u0027m very grateful for Ben\u0027s I you know looking through and thinking carefully through what the terminology should be and making sure it was all aligned so that\u0027s all aligned now consistent between the protocol document and the architecture document so so that\u0027s good there were some things about the application key schedule you know three that were ambiguous and so we got those cleared up and kind of clearly defined so now we have something we can target for implementation where we\u0027ve got some Interop already on you know four we\u0027ve changed front now in this version from using EC IES and kind of a custom define in this draft framework to using a framework called HP ke hybrid public key encryption that Karthik and I have submitted to see if RG will be talking about tomorrow morning tomorrow morning anyway sometime this week but never see if RG is meeting this week we\u0027ll be presenting that draft proposing for adoption there the idea is to have kind of a reusable EC IES like primitive that could be used in this protocol in ES and I and TLS contexts in a couple of other contexts where that\u0027s useful so we went ahead and submitted that draft and so we\u0027ve changed the definition in in MLS to use that down as well we\u0027ve got some version negotiation stuff in there which we\u0027ve got just a very shim thing you know for that we\u0027ll have some more "
  },
  {
    "startTime": "00:19:12",
    "text": "discussion about today added a hash the welcome and the add which there was a thread on this on the mailing list that we had some authentication vulnerabilities do there being not enough tying between the welcome message that is sent to the new joiner and the add messages it announces into the group so adding I know in in the tamarind model I did which you know I am NOT a tamarind expert but I think it was more or less correct in the Tamra model I did having a hash with welcome info and the add message was enough to address that vulnerability so hopeful that the academics in the crowd can help it build some assurance around this I think it\u0027s at least a step in the right direction and then well I\u0027ll take it to two topics I\u0027ll talk about here our key separation with entry chem that Conrad Co Brooke proposed and some this question about garbage collection we addressed the interim and kind of finalized to note for just hold on back for a second from a chair perspective right so they each pke stuff actually does introduce of dependency rate it doesn\u0027t reduce of dependency okay my hope is that I was just talking about this with Karthik if we can get this a dot if CFR g to adopt it now-ish it\u0027s in much it\u0027s a very it\u0027s a pretty consolidated piece of work so my hope is we can work it through CFR gene expeditiously and not cause any delay for this way yep okay so key separation within shriek em so in earlier versions of tree Kem right you you start with a leaf secret and you hash up the tree and the the secret value of the parent node is the hash of the child value Conrad pointed out that you know this this means that you now have some relationship between the nodes in a direct path which I guess is kind of unfortunate it made him a made maybe academics that hadn\u0027t Britta\u0027s nodding here sighs soon yeah academics are unhappy about that and you know we try and keep our our academic friends happy here so this seemed like a low-cost way to do that so instead of having this direct relationship between the nodes what we\u0027ve done instead in this version with as we kind of derive this these ephemeral secrets which are the dashed lines here we start from this the secret value and KDF it over to the leaf value but separately KDF and a successor value and KDF over to the node so that you know once you\u0027ve done this you can throw away these values and once those values are gone there\u0027s no evident relationship between the things of the tree so you have more independence of the values in the tree but you still need to be delivered the things in the dotted box is right yes okay so you can verify that the three subtracting started yeah exactly the idea is that instead of delivering the secret values of the nodes you deliver the things in the dotted line boxes yanks yeah "
  },
  {
    "startTime": "00:22:13",
    "text": "any other questions are coming to this country cat trail the uod deliver the bottom box right no so it\u0027s you know entry CEM style um actually the bottom box doesn\u0027t go anywhere so in in this case the second - box would be encrypted to this guy and the third - box be encrypted to that guy - the same pattern is trick em off our fair are not hash are morally related - no yes they are ok I got it thank you the bold arrows here the solid arrows are our kid yes I forget whether they\u0027re just hash or whether they\u0027re it\u0027s some sort of some chunk of each KDF yeah okay that\u0027s that um finally this garbage collection topic which we\u0027ve talked about a few times we discuss this at the interim you know there\u0027s there\u0027s two cases here you know you want to be able to add people in place which is fairly straightforward you just add them in a slot and blank out their parents just like you do if you got them on the edge the thing that was more controversial was removing people on garbage collecting when you\u0027re removed so this area we\u0027ve got on the right here the idea is we\u0027ve got this this tree where we used to have six members these three intermediate members got removed and we\u0027re left with the two on the left and now we\u0027re going to remove the guy on the right hand side and we\u0027d like to clean up the rest of this tree so that we only have a little tree for the two members and so the algorithm that\u0027s in the doc now which is what was proposed what we discuss in the interim you just wait when you delete this last member you delete nodes from the tree until you get back to a non blank leaf and so you delete everything to the right of that leaf when you when you when you delete the rightmost or delete a member that\u0027s yeah the rightmost non blank member that\u0027s the algorithm when we discussed this at the interim we kind of decided yes this kind of looks good on the face of it if we can convince each other that this tree and barring it still holds remember our tree and Varian\u0027s the thing we spend all our time trying to keep which is that for every node in the tree and for every member in the group that member holds the secret for the node if and only if it is a descendant of that node in the tree and so my one line argument here is that you\u0027ve given that definition of the tree invariance if you simply take a subset of the nodes and members which is what we\u0027re doing when we throw away the tree that invariant still holds and so the tree invariant still holds and so it\u0027s okay to do this this garbage collection in this way so given that kind of loose argument we went ahead and landed the P R and you know hopefully further deeper analysis will bear this out anyone have concert remaining concerns about that I feel like Jonathan Harlan does making skeptical faces at me all right so "
  },
  {
    "startTime": "00:25:17",
    "text": "that\u0027s that\u0027s the status as of o for any further questions comments on on the current draft Jonathan\u0027s I just have a question I mean I\u0027m not I believe that this invariant holds I\u0027m just wondering if this is sufficient to actually do garbage collection and real life you\u0027re actually going to get in that situation where you have significant numbers of blank left nodes as opposed to just a random distribution of likes across the tree yeah no it\u0027s a fair question because and then you know it\u0027s it\u0027s hard to say because you know groups in reality are are sociological things yeah but I mean so I think I think the idea is if you pair this one other thing we discussed is the ability to move a member from one leaf to another and you notice if you combine remove with add in place you effectively get a move on right and so I had sketched something out at the inner I\u0027m about doing that as a combo operation I mean they\u0027re they\u0027re nice I\u0027m sensitive organized way of making sure - you know compact before garbage collection yes that\u0027s possible it\u0027s just a you know a thing you\u0027d need to court the application we need to coordinate given a certain view of the tree so the crypto is there it\u0027s just you need some coordination to make it actually happen yeah this is dkg do we have any sense of how frequently this sort of thing is going to need to happen we\u0027re talking about actually being able to do this kind of cleanup I don\u0027t just I think maybe that we should push off this question about if you know efficient compaction and garbage collection like it seems like we don\u0027t even have evidence this is a problem for a deployed scenario so I\u0027m happy with just having remove it out in place and not trying to make some sort of fancy compound Archy yeah I agree that\u0027s kind of why we started with what we did just defining updating the remove operation so that it garbage collects when you do remove I think in practice should be like your goal BG seeing two or three slots maybe on a given time but yeah if we find in practice that\u0027s you know you need to do some compact compaction before you garbage collects I think that\u0027s something we could do plausibly as a follow-up or handle later and yeah since we know the general outline of what you need to do alright there\u0027s nothing else we\u0027ll move into new issues for draft oh five oh right alright so this is another issue we discussed briefly at the interim so we want to highlight here side by side the identifiers we have for cryptographic things in TLS and in MLS version of for the current version right so as usually 92f protocols we have pluggable primitives and we have identifier spaces "
  },
  {
    "startTime": "00:28:19",
    "text": "that identify either single primitives or combinations of those primitives and the trade spaces we do have to decide like to what degree do we want to have an a single identifier that identifies a whole combination of primitives and to what degree we want to make the primitives plug-and-play so TLS has kind of gone back and forth on this earlier in TLS you had cipher suites which defined a single value to find all of the algorithms in use and now until s13 we\u0027ve decoupled that a lot more so you have separate identifier spaces for signature schemes and use the D H groups in use and the cipher suite now just identify as the aad cipher and the hash function that\u0027s in use so that\u0027s the only combination that\u0027s their current version is current version of MLS is a little bit more aggregated than that so we have signature schemes broken out so you can use say ECDSA together with ex five two five five one nine but the curve the hash function and the a EAD function are all together in one identifier space so the one value defines all of those things and so the question is I think ecker proposed that we split this part that we would have better experience with evolvability of the protocol if we had these Brooklyn separate things so the general question is you know kind of what groupings we want to have here so the first line here is what we have right now in MLS where we have the D H group the AED and the hash all together in one go to fire space the signature in a different identifiers space the second line here is what TLS has we have the groups in one space a d-plus hash and signature space the third line is one that came to my head the thing that is concerning that is potentially concerning in the MLS context is that we are using the hash function to derive D H key pairs or CEM key pairs for whatever we\u0027re doing and now whichever can we\u0027re using to do tree Kim there were Basecamp right so you for instance if you\u0027re using 84 for 8 or p5 to 1 in a high-security setting you might not you might want to forbid the use of shots you five six as for deriving key pair step because you end up in some like low entropy subspace of your big curve spacing you\u0027re not getting the full benefit of that curve so was that you might I\u0027m just proposing you might want to match these things up it seems it seems bad I think the numbers don\u0027t match I guess but I mean I mean presumably because when we you mean you\u0027re like you know you\u0027re you give a 256-bit hash and that was in VC key because inter Vista to hash that has corresponding strength to a hundred twenty one bitty you see you keep ulcer - right fair enough I mean maybe you\u0027d like it me like a you know a a two hundred and sixty bit hash you\u0027re looking for yeah so I mean I think we can we can do any one of these "
  },
  {
    "startTime": "00:31:20",
    "text": "like the usual concern here you here is is phrases level matching here like is it okay to use P 256 together with a yes - five six which is going to so you you\u0027re getting more strengths but weaker keys going into the to the AED you know TLS has decided that this is not worth pursuing like you can you can have that combination with TLS yeah I mean I think that can you about your previous I mean so um like um so I mean it\u0027s worth noting that that if you actually had a level matching three then what would you use the cha-cha write an answer BP 521 perhaps um so I don\u0027t think a lot of magic as coherent never has been um and I think that I mean there might be some like there was a crypto reason why you want to have a much larger hash with with a with a large group but I don\u0027t think I don\u0027t think entropy is the answer unless car facing like correct me here um you know make me be want white or something my impression was like the thesis to be made to go up to a light if you structure it properly what do you mean by wide here like univie if for some reason because you\u0027re need to generate like more than you run the turn if it\u0027s these bits right educate you have concern about it is you want um so I think it\u0027s probably okay um if we treated it like it was okay in TLS I think certainly as far as matching I mean can you go back to the nice light now um I guess um I know this any sensible of a matching story about like the group of the AE ad like that just doesn\u0027t make in some you know um I think maybe there\u0027s some coherent story about the group in the hash which I defer if you know CFR Vigo we do like I would defer to that but I think that the second tour the right other writes out I mean the I think that if I review group in hash I would do we did in TLS for signatures which is basically to commit to one hash for each group like how does that reflected in TLS oh so if you look at so it so if you look at the teal Phyllis ensure things are named as if there was some as if there\u0027s a match but they\u0027re not really namely like you can\u0027t use sexy 56k one along with the shell three before saying ECDSA with p51 is locked yeah we just didn\u0027t we just didn\u0027t define ko points that were like that and you can do a five point nine which hasn\u0027t has an implicit hash please don\u0027t say what it is right so on you know the only reason this first one\u0027s named this way is because like it used to be you could mix and match them right so I think that if you do services that means there\u0027s a degree of consistency in this third option here in which each thing is nailed to a hash you really suck I just I\u0027m just saying I wouldn\u0027t build to come to her smorc explosion of things I would just be like you know who fixes user shot do it to sex yeah but I guess um but I guess I suspect her ended up with like if you like so her for for eight you\u0027re gonna use this all three before you need to "
  },
  {
    "startTime": "00:34:20",
    "text": "shut through to sex uh-huh I guess I would just pick one I don\u0027t think we have to like try to like right so the the question I think the major question here is like how what whether people are concerned about you know shorter hashes being used with bigger curves um and if that\u0027s a concern then how we want to constrain it you know you could constraint it by just saying in the definition of how you use the curve that it has to be used as a hash function that Bruce\u0027s at least X bits of output and you handle that of the application there or you could define these combined group plus hash I kind of nail it up that way it\u0027s like do people have opinions about whether this is a problem and if so how to handle it Martin yeah not on Thompson oh that\u0027s good it may send you may make sense to have a look at the actual units that you\u0027re dealing with in the protocols so the the D H component that you use for this is one thing and that and the ECE whatever the thing is that you\u0027re using for encryption is another thing and and the heydays another thing entirely so rather than saying are we have these groups and we have these hashes and we have these AEA DS have a look at the pieces of a protocol that act on this so you have a CEM and that can comprises of the following group and maybe you need to hash to the to the group so therefore you need to put pair the hash up with that and that sort of speaks to the last one I think it to some extent and you know the last one is just we\u0027re just talking about protection of messages once we have keys so think about that way more than more than you think actually that argues for the because when we\u0027re doing chem we\u0027re doing ECI yes which means you\u0027re deriving your D H you\u0027re deriving and then you\u0027re plugging into a EP right so if you have a unit that does all of those things together then you may be you don\u0027t need to split things out as much in video this is unlike TLS well it is like TLS and that a EAD is presumably getting used for application messages but the the CEM usage is unlike you I mean any less right I mean so I mean at some level like you might it like doesn\u0027t argue for one it argues for one prime which has a third which has a second entry in between the first and second entry is called AED you know whatever is the message I thought we do the bulk encryption with yeah yes exactly so I think that\u0027s the module now like I mean I think because HP key is new like we don\u0027t really have to deal with this question of library people or or like or really people have our fucking oid iady\u0027s to their to their community but I certainly don\u0027t "
  },
  {
    "startTime": "00:37:21",
    "text": "I guess what when I argued about this in the interim my complaint was I don\u0027t think you should tie the bulk encryption to the key key establishment I think the key establishment like if you think if I get really turns out the kids also much more convenient to like tie all this together and fine but I think you didn\u0027t have it together with a bunker sure yeah and I think that\u0027s that\u0027s probably the major point to capture here is like we might need to AE ad slots yeah okay all right well I think it\u0027s a good feedback I will go back and it Ponder\u0027s is not immediately clear to me standing here which of these you know what option all of this argues for but I\u0027ll revise the appearance and that\u0027s the lesson you could we can make a decision it\u0027s nice that we all randomly decided to use the same temper alright so next we\u0027re gonna talk about the server initiated removal and just for context that is something that has been requested by some vendors so just to understand what it is some vendors have made it quite clear that they would like to use MLS but with the server knowing what the roster is so the server knows who\u0027s in a group and in that scenario they wanted the server to be able to remove someone from a group so this means that we\u0027ve been talking about the server but really it could be any external party it could be an administrator or something in a different context and so we started with one proposal and then added another one and I\u0027m going to briefly explain both of them one second so the reason the rationale was for server and shaded removed but it\u0027s because the users were inactive right I mean it wasn\u0027t just like hey I\u0027m gonna get that guy out that is one scenario but not necessarily the only one okay so we yeah for example I curse it because because he\u0027s fired yeah because I mean like a lot of these things are like you know corporate systems and so you know someone gets terminated and you wish to fuck another group or you know as someone said they don\u0027t don\u0027t put their bill there\u0027s like lots of reasons for managed systems to one end in security but still walk control of some group yeah yeah that\u0027s a very good point so the first one just to recap was inactivity to the extent that the server can actually monitor the inactivity which is not quite clear yet it would be one reason and then yeah manage environments in corporate environments is the other one or maybe simply for consumer messengers if somebody closes their account and "
  },
  {
    "startTime": "00:40:22",
    "text": "therefore kind of do any crypto any more that needs to be a way to remove that person as well so first proposal under the codename of external remove so the external party meaning the server can send a handshake message to the group and that is of course not encrypted under the group secret because it is an external party that doesn\u0027t know any of the group secrets but that message would have to be signed in the same way that hand check messages are currently being signed except it will be signed by an external identity and so that is precisely the problem it\u0027s not quite clear what that identity is how that is being managed so none of that is currently linked to the group state we have the group state really only contains the identities of the members of the group but nothing else so that raises the question how can a client trusts this signature at the end of the day and more importantly how can all of the clients trust it because in order for this to to work in a robust fashion all of the clients would have to come to the same conclusion that this is a trustworthy signature and and would remove the person from the group and now the question is these external identities are they going to be managed and that seems to be completely out of scope for the MLS protocol at this point the assumption is that it might have to be dynamic because groups don\u0027t have any restriction on their lifetime so you could probably assume that the server identity or whatever it\u0027s going to be might change over time might need to be a revocation mechanism so the worst case we\u0027re looking at is that if there are some clients in the group that will trust the signature and others don\u0027t and some of them will remove a participant and others wouldn\u0027t and then we have partition of a group and then we have a problem essentially sorry a question then k-tec yeah so I\u0027m not entirely convinced that the clients all have to agree on who to trust but perhaps we don\u0027t like the other options I mean you could say some scheme where the external entities and a new extra move message to all the group participants and if any one of them trusts that external part participant they then like proxy that message sign it you\u0027re you\u0027re too quick that\u0027s the only thing here so that\u0027s gonna be the next slide thank you for the segue mr. Caidic uh yeah I think the upshot of this one is that if we wanted to have this then we would basically need to extend the what is now the group state that is the thing that everyone agrees on by the key schedule and have additional things that the group is agreed on in there and include "
  },
  {
    "startTime": "00:43:23",
    "text": "information about the authorized external parties there which you know is doable but I agree is is probably not worth the trouble yeah I mean we could certainly try and get a list of those external identities into the group state however if it is a requirement that this list is highly dynamic then it might not be good enough to just have it in there because it might change in between so if the epic never changes for whatever reason because the group is completely inactive but you have a change to the identity list then you do have a problem so I mean just just so I\u0027m clear on the behavior here so we have a group of you know four people and some server sends a you know a evict individual a and B\u0026C trust the server and D does not then now you end up with basically do you know D ignores the message and B and C take it and now you have a partition right but they but they know they were Perdition because I\u0027m not sure if I know about the partition at that point I mean they can no longer see message yet message each other because they could okay and you know find out the hard way yeah yeah right I\u0027m not sure I mean hopefully I\u0027m guessing fact this is proposal one meter for littles knows problem huh-huh-huh-huh right uh I I didn\u0027t live with that property catriel we punt on the external identities to the application layer say you know if why I want to stay instruct food to be removed from a group why I must figure out how to tell all of us clients to do that right that could be one assumption yeah I would support that over having to include external identity management as yet another thing we have to do in the protocol but let\u0027s get it proposal to write it\u0027s not quite fear so if we have external identity management or something similar it doesn\u0027t mean that it has to be inside the protocol but it has to happen somewhere so we can debate about whether it\u0027s application error or not it\u0027s not gonna be like proposal 3 ok let\u0027s look at proposal to and then we can debate some more so the idea here is that the server or the external party sends a request to the group that somebody should be removed and then probably the first member to come online and to see that requests will honor it by actually removing the member in question and so that would be done through a normal remove handshake message which is not ambiguous because everybody in the group is going to follow up on that the only thing that is a slightly strange at first is that say if Bob was the one to be removed with a normal remove message the user interface of the messaging system would typically "
  },
  {
    "startTime": "00:46:23",
    "text": "say Alice removed Bob whereas in this case it was requested by server so it would have to be surfaced slightly differently to the user to give some more context of what happened here and that could be achieved by somehow including the the remove request that came from the server so that other clients can interpret what happened correctly unfortunately it\u0027s not just that so many systems have group systems have one or two group administrators and no one else can do can do kicking or removal and so in those cases this simply won\u0027t work at all in this case is your unless Appenzell don\u0027t want to do it but I mean I often they\u0027re like not online all the time right and so you get is you get very very slow removal if any so this doesn\u0027t seem this seems like only a very partial solution what is the concern at which scenario wouldn\u0027t it work this is an area a scenario is you have a group of like 200 people right and there\u0027s two people or min Affairs and only minister is gonna fix people and so like you know um so you know like to take go back to my example right you know I\u0027m fired and they want to be kicked out of every group of the system right and but it turns out that like that the admins for those groups like are on vacation and it\u0027s like nothing happens and it\u0027s like that\u0027s I can really dawn turn mystic behavior so I think the problem is any system that actually any system that wants forcible removal as opposed it\u0027s just like people who are who are like you know who are just like not idle like it\u0027s gonna need the effect of a half version one not version two okay no it\u0027s a fair point this is Daniel con Gilmore I\u0027m just observing that your proposal for how the ux/ui change would look seems super problematic to me yeah like you wouldn\u0027t want to actually say that wouldn\u0027t want to remove the picture of Alice being the one who does the removal if this proposal goes forward I mean yes I agree with you that you would need to that it would be reasonable for it to say bob was removed by Alice at the request of the external party but totally aligning the fact that Alice was the agent of the action would be a mistake yeah I mean I\u0027m not proposing a specific copy here or what I\u0027m highlighting is that just saying Alice removed Bob is not the whole truth in this context and we do have the chance to improve the copy so yeah we have a chance to improve the copy but it is actually the whole truth from the perspective of the rest of the protocol yes right the retrospective of the rest of the protocol it really does like it is still Alice who\u0027s making that call and yeah we can offer some additional cryptographic justification but we could do that in many other types of removal contexts as well if we wanted to Alice could say I found this C RL online that convinced me that this person need to be removed or something I\u0027m not I\u0027m not saying we should do that and I don\u0027t even think we need to take it in it scott reil again just to push back on what echo said a little bit because who can remove is only an application-level policy anyway in as as I understand it anyone "
  },
  {
    "startTime": "00:49:24",
    "text": "cryptographically can remove anyone and the application law enforce our well Alice wasn\u0027t actually allowed to do that and therefore you could have a policy that said only the admins can remove somebody unless they attach an extra remove request message and then you should process it well I thought that maybe I forgotten but I thought that like you didn\u0027t need to issue the request for graphical you mean part of the group either of you right so I mean like I means I guess I understand like the that his entire story is about like authorization the authorization of the request not about the formation the trait so yeah the thing the premise here is that the remove request is authenticated from the vendor right yeah yeah absolutely but I think what catriel saying is you know you\u0027re presuming that the removed policy that the app enforces is these two admins are allowed to remove and no one else like what he\u0027s saying is that you could have a policy that says the people who can remove are these two admins or anyone in possession of a remove request I understand what what\u0027s what constitutes being a remove request and what comes to being remove request it\u0027s assigned by the by the vendor so like now we\u0027re just back to part one the remove request is is at this in that framing is basically a capability to it right like you\u0027ve provided a capability to everybody to evict just dkg what is the structure I can go D let me print run again yeah so maybe taking one step back in my mind at least proposal two is basically saying all of it should be solved on the application layer we don\u0027t touch the protocol as such people are effectively being removed with a standard remove handshake message but the rest needs to be done on the application there whereas proposal one would potentially mandate that we change things in the group state meaning we effectively change how the protocol works let\u0027s it\u0027s like like I think I actually kind of like to catch rails these controls question earlier right it\u0027s like we\u0027re like all running wire and like well you know that wouldn\u0027t it be great and you know and presumably we\u0027re all connected to wipe the wire Update channel for like you know tells me to get a new version of wire occasionally right and so um you know so why are just well perfect will somebody mentioned on that channel that says like listen um you know like this guy\u0027s been kicked out of the system like take every group is in and pull now right and I and every and every user of the system automatically reduce the tree with this guy out of the system and that\u0027s like so "
  },
  {
    "startTime": "00:52:24",
    "text": "much but that\u0027s out of BAM from the protocol entirely right and you mean they like Ruby just spontaneously but president the protocol everybody spontaneously removed like Daniel for the tree right um and um so I mean in that respect you could certainly take it instantly because really not not like you don\u0027t have to find protocol messages for it I suppose um but I think that goes distinguish between like from a from from a sort of a tree machinery perspective this person he pulled out of the tree from a formal occasion perspective you know station about to tell you to do it and like we could define that here we could not to find that here and that\u0027s kind of like a separate question but I think from a tree perspective he\u0027s got a pull out a tree right well the question is also in which order that happens so everybody has to do it at the same time at the same I\u0027d milk right but I mean but like but I mean they so like okay well I get because but but you know you have you right so I mean the I mean is it\u0027s complicated right but yeah but um you know you think in the case of wire because you can do because you can\u0027t roll both it with a thick messaging server and the end up a channel it\u0027s like pretty straightforward right you like say like you know the update channel you say like look at this level at this point like pull them out right I I\u0027m I\u0027m saying that they\u0027re the systems which are both central at which of resent was there like a one monolithic system that have like you know a that have a that have like one administrative system as well as one like as like what a software vendor I have that property I\u0027m an advocate I don\u0027t think um but I mean but you know you know like even a delegate is you know even even the system which is a more open system that has like a but has some central group manager sells us a property right I\u0027m just saying like it that the the thing is the thing the application needs to know is like someone is authorized to tell me to do this told me to pull this person out of the group but I mean just to summarize so that is completely on the application lever what you\u0027re proposing so you\u0027re this doesn\u0027t matter at any change on the protocol layer no not for my side JoEllen so correct me if I\u0027m wrong but isn\u0027t it true that when there\u0027s an update we also have to refresh the secret we have to add new entropy in the secret into the group secret right and so my my concern is where that entropy comes from and I prefer proposal to even if proposal to requires an identity a cryptographic identity for the server whoever initiates this removal because if we go with proposal one that and we actually let the server do that then we\u0027re asking the surface to provide that entropy which getting gets mixed into the new group secret and we don\u0027t want that I mean I don\u0027t think that\u0027s the right way to go I think it\u0027s better if that entropy comes from a user so I actually "
  },
  {
    "startTime": "00:55:25",
    "text": "prefer proposal to despite it still rek you know probably being better to have cryptographic identity yeah that\u0027s a good argument I mean we never took it that far for proposal number one to think about where new freshness comes from but I guess you\u0027re right about that yeah which also means that even if we have a way to synchronize through some external Channel and so everybody in the group realizes okay now we have to remove fob there\u0027s still the question of where that new entropy comes from and I think the only source that makes sense to me is somebody who\u0027s already in the group who privy to the group secret we shouldn\u0027t be taking entropy from outside basically so that\u0027s why I like proposal too good point to them yeah I surprise I sympathize with that but it doesn\u0027t seem like catastrophic because whatever entropy is being provided as being KDF together with entropy that secret secret yeah yeah yeah please repeat the question or come to Mike my reasoning behind why I think this entropy should come from members of the group is because in a PCS scenario so suppose you have a you know the adversary\u0027s corrupted the server and he corrupted one of them group members he knows the state now if you allow the server to also add the entropy during the update it means now the adversary\u0027s second effectively knows both inputs to the KDF and so he knows what the new state is so the Refresh didn\u0027t do its job of cleaning out the state and kicking it verse three off the channel so that\u0027s why you know I wouldn\u0027t allow it from any external party who could then potentially be the adversary I mean yeah so that\u0027s a good point I think that argue is pretty strongly for for proposal to here having us be done within the group by a group member you know a bit on the author is a question question III granted like there are similar authorization problems here it\u0027s a proposal one but actually why I got up here is trying to argue that\u0027s even those authorization issues are equivalent to a previously unsolved problem like namely if you if you have any non-trivial authorization policy on remove you know any policy other than anyone can remove then there\u0027s if you you\u0027re assuming that everyone is synchronized on that policy or else you have this fragmentation risk so adding one more bit to that policy one more authorized key to that policy doesn\u0027t seem like something super tragic in addition to what you already had to be synchronized on so if that seems like a tractable problem is it seems like this is kind of the protocol modality I think that raises kind of the raises the question of what the protocol impact here is do we need to define the remove requests dude we need to define what this capability "
  },
  {
    "startTime": "00:58:25",
    "text": "looks like we need to define a slot an extension point where it could go so my assumption so far was that the remove request doesn\u0027t mandate any specific changes to the protocol I mean we might still want to write it up as a guideline basically of how things could be done but it fundamentally remains an application layer solution and since we don\u0027t standardize those I saw it as outside of the scope but okay so so for debate so basically this is this proposal like doesn\u0027t results in a PR the protocol document that was my assumption yet and the idea is in order to get your remove message accepted by your peers in the group you would you know glue on the outside of it a token that says this is okay optionally yeah yeah pretty Hale I completely agree with observation about new entropy but I want to say one comment on the proposal too I think we changed slides there but if we go back so one comment about the proposal two is that the server cannot actually enforce a removal of any group member so words and proposal 1 they can that\u0027s a very good point so what you\u0027re saying is that the group could boycott whatever the server is asking exactly but that is also true for proposal 1 to some extent people could do it individually leading immediately to partition obviously which is even worse so that\u0027s a very very strange threat model haven\u0027t contemplated yet work basically clients do whatever they want and they don\u0027t follow what the server says for these things so I see that\u0027s being a problem in both proposals this is dkg so the if the server isn\u0027t prohibiting the client that kicked from contacting the others and there really is no way for the server to actually defend to enforce that this member can\u0027t participate right in both proposals yeah and I mean that\u0027s just the nature of yeah of how these things are fit together I agree so maybe to go to the last slide what is connected to that a bit is that my proposal number two it appears to not be in real time because it\u0027s a request that\u0027s being sent out and nobody knows really when that is going to be enforced but that would have to be a rule on the application layer essentially that you don\u0027t do anything before you haven\u0027t honored the remove request but MLS is fundamentally asynchronous there is no real-time element in it by design so I don\u0027t think this makes much of a difference it\u0027s "
  },
  {
    "startTime": "01:01:26",
    "text": "just maybe more of a psychological feeling that things are not being enforced immediately so this is dkd again as far as the motivation for this for this entire question will a server operator in any of these cases need to be able to say this action was done right so the server operator might say oh we need to kick this person because of policy reason X let me start the machinery in process that does that do I know that it\u0027s completed so will you I have a requirement to know that it\u0027s completed it\u0027s a it\u0027s a good question so the the initial requirement here was that Ruster is known to the server so at the very least the server would see a change in the roster there and could determine from that change whether or not the action has been completed but been Caidic so if you have sort of like policy you\u0027re auditing level reason to need to be able to confirm that somebody was removed from the group does that sort of force you into having a like auditing agent that is actually a member of the group it\u0027s a good question I mean so far we\u0027ve never really looked into how manage groups with different you know policy levels clearance levels whatever look like because simply on the cryptographic level everything is egalitarian as catriel said earlier so all of that is something that again happens at the application there yeah so we don\u0027t have a precise idea about that the question is whether we need to so I think this argument about um the forward the author the forwarding like really completes authorization with PCs like you know et I understand like if surfer dinner sheets this that guarantees don\u0027t look as good but people are gonna key update and then they guarantees will look okay again and so like gate wing the deletion procedure on you know some group member reflecting it just like does not like feel like like I\u0027m like a non brittle protocols on much rather have a situation where everybody immediate he\u0027s actually on a deletion and then there\u0027s some other separate operation which is job it is to like fly pcs the family should just to fini where to bring the system but what what guarantee do you get from that that the stuff is being done immediately what problem does it solve if everybody agrees on the rules you don\u0027t do anything before you remove someone and it makes me feel better personally as well but they need partly an aesthetic position it just feels like you\u0027re like taking new protocol functions including them together in a "
  },
  {
    "startTime": "01:04:27",
    "text": "really odd way and especially the fact that like I mean I mean like the that in in when Alice forwards it that is like no meaningful semantics about like the is like novena semantics kind of authorization right like you need to you\u0027re like so in the case where in the case where alice is not an administrator the only basis on what you\u0027re accepting this is not that Alice sent it to you if you\u0027re accepting it because you\u0027re accepting it because it\u0027s signed by their group from the buck-buck by the route right I\u0027m gonna rip with it but by the authority and so like just like so he\u0027s saying like I all should forward it like I mean you might as I mean you might as well have the like one instead have a rule that you know if that you know upon you know upon receiving this like you won\u0027t you shouldn\u0027t really keep you to your own but have a basically the same fact right John Linux you\u0027re saying about the knowing of when it\u0027s complete is does the requirement here the roster is done to the external party meaning the roster the external party knows every members view or that you know whether everybody\u0027s actually gotten the state up it yet know the rest is really only the list of members in the group I mean what is the list mean when you know when not everybody might not out not every mirror might know the list yet I mean how the server gets that I mean it could be inferred if handshake message are than unencrypted for example this seemed like the minimum requirement for server initiated removal to make sense at all been connect I guess I\u0027m still sort of confused how this the server sends a message and everybody acts on immediately it would work because I mean we do have sort of a synchronous message delivery and doesn\u0027t there need to be something to enforce like that happens in the same a POC doesn\u0027t the external thing need to know something I think so as well yeah I mean there would need to be either some instruction at which a pocket it should happen or some other magic which I don\u0027t know how that would work right now I am yeah and that sort of gets us back into whether the administrative agent does the removal needs to be like a member of the group to some extent yeah cat will hear this might be a good one to take to the list in particular thinking about the threat model here I believe a lot of this discussion is in the context of a malicious client all right not necessarily a client which is not following the rules and is choosing to not well if that were the case the comment was a player rules are distinct "
  },
  {
    "startTime": "01:07:27",
    "text": "from crypto rules a malicious fine that doesn\u0027t follow a player rules could also tweet all messages so but few should think through their threat model slightly more directly like if the the users in the group chose to have were non-compliant enough that they all decided to boycott not either not do the remove or not process the server\u0027s remove they could just as well do the remove and back-channel all the messages in the group to the guy that you just got removed so I think that there\u0027s an argument like if if the users in the group are sufficiently bad then there\u0027s nothing you can do to stop them from keeping the guy in the group virtually even yeah I think that\u0027s generally true and we\u0027ve found that too between other circumstances as well so when I think what what sticks here is the argument of synchronicity of how that can be achieved if it is on the application there only and it comes as an instruction from the server so how can we agree that everybody removes the same member at the same a book so that that remains an engineering problem yet I mean Jonathan hoiding table you you could do fancy stuff with unsealing and proving that you\u0027re from the people from the group just return to the previous question it is a crypto problem that you could solve assuming that the clients were honest right the question is that is actually irrelevant in the context of MLS at all or if that is something very vendor specific that a vendor wants to see exactly so on the question of what we should do here I think I want to come down as I often do on the side of not doing work it sounds like this it\u0027s worse because I didn\u0027t even hear it so it sounded like this proposal to like punting it entirely to the a player can be done without protocol changes just by doing some authorization stuff in the a player so I think I\u0027m inclined to do that for now like and and maybe you know make an issue on the architecture graph this is to describe how this could be done in the overall framing but leave leave the protocol draft as it is for now you know that that has the advantage that you know nothing changes so if we decide we need to do something different the future it\u0027s not that hard to come back and do it so that\u0027s that\u0027s how it could be inclined again and I tend to agree that for specifically the reasons you just said if we want to do anything regarding proposal one we need more concrete proposal with more details in it and then discuss it doing proposal two is basically doing nothing for now that\u0027s true well if we want to go with proposal two then would it make sense to "
  },
  {
    "startTime": "01:10:29",
    "text": "extend the message format for removal to allow a field for justification arbitrary justification string defined by higher-level application that would be then also in it that would have an effect on our product on MLS yeah that\u0027s that\u0027s a good question I\u0027m personally not entirely sure whether we need it or whether we can do that again at the transport application level somehow and glue them together there yeah the reason you would need that in MLS is the reason you need that in MLS is if you needed that to be signed by the member and in kind of unforgeable by the server which doesn\u0027t seem like if there\u0027s a like let\u0027s put it this way like this server you know if this is not bound into it\u0027s not that in MLS the server can add or remove it will which means that you could have an implementation architecture where some of the the client is commanded in the server just adds this authorization as it transits the server which seems like it just fine architecture to me so like I don\u0027t really see the need to find it into the protocol here okay so maybe then as an intermediary results we stick with not changing the protocol for now until we have a better proposal on how to do proposal one anyway does anybody want to get to the mica and argue Lee strenuously for proposal one great now I\u0027m not gonna argue for proposal one but I am looking at Benjamin suggesting that he file an issue on the architecture to describe it there yeah that\u0027s good then we have it documented somewhere all right and we can move on version ago she ation so it is a bit of a luxury to think about version negotiation at this point to the extent that we have maybe bigger fish to fry but at the same time it\u0027s something you want to think about early so that you don\u0027t pinch yourself in a corner so there is an addition to the draft o4 and it\u0027s a fairly basic one where we basically mimic what we do with surface suits and so clients can advertise what version they support in the user init keys and essentially in a very undemocratic way the group initiator decides what version to use for a group and then everybody sticks to that and so whenever a user in a key is retrieved by the group initiator and somebody is invited in the Welcome message the initiator indicated which version is being used and of course the downside from that is that if "
  },
  {
    "startTime": "01:13:32",
    "text": "a certain client doesn\u0027t support a certain version it\u0027s not going to be part of the group so these are the concrete changes in the the structure and the user in it key there is simply an array of supported versions and the same happens in the Welcome info so there are some open questions I mean so far this is rather straightforward the major one is should be possibly to ever upgrade an existing group to a newer version and if that\u0027s a no than the discussion ends there of course if it\u0027s a yes then the question is how and should that happen on the application there should there be something in the protocol that facilitates that and also what are the security properties when you do that which is of course very hard to answer because we\u0027re working on version 1 way of knowing if there\u0027s an I ever gonna be version 2 and what it\u0027s going to look like Dominick\u0027s I mean I think you would also want the converse and if you discover oh hey I wanted this person to join but they don\u0027t support the new version do you wanna be able to downgrade existing groups to an older version that would be nice for the person but it also some very dangerous it does yes and then the other question I have is do you want in addition to versions also have protocol extensions or not necessarily you know all or nothing but you know we support also this additional feature which may be you know either you know up you know comprehension optional or comprehension mandatory possibly having both like in the capabilities that are advertised or you would say I support extension 1 2 \u0026 3 yeah yeah yeah I mean there\u0027s no and we never might even be you know I support 1 2 \u0026 3 and if you don\u0027t that\u0027s cool and I support 4 \u0026 5 and if you don\u0027t you can\u0027t join the group they might have both categories of exemptions well we don\u0027t really have the sort of extensions it I guess my feeling with no hat on though I\u0027m sitting up here is that it should be possible to upgrade at this vision of like a long-term group that\u0027s for a large corporation and and like new version two comes out and you\u0027re gonna you\u0027re gonna send out a new message to everybody you\u0027re gonna make everybody in that company like they\u0027re gonna do what well I mean it\u0027s always possible to upgrade a group at the application layer by just throwing everything away and reinitializing the group all right there\u0027s no UX impact like it\u0027s all just crypto nonsense it happens under the sheets well that\u0027s the question like if it\u0027s obviously depend on the version upgrade on the difference of the version so the questions like should we try and articulate any sort of thing we would like to preserve across a reboot like that you know would you know how it takes some group secret from before and "
  },
  {
    "startTime": "01:16:32",
    "text": "fold it into the new thing like how much can we specify in advance that well let me try a simpler problem let us say you\u0027re perfectly good group and then some really fast new like aad algorithm comes out and we\u0027d like to upgrade to that that doesn\u0027t require changing the group at all so like like can we do that we could do that yet I think that because I think like even that it\u0027s like some sort of like two general rules problem look like figuring out that everybody like speaks you know everybody speaks you know cha-cha thirty um so like I would suggest someone try to work that problem first and then like if you were ever worth that problem successfully then we can like work the problem of like upgrading the group well I mean the underlying program is that if you want to change something whether it\u0027s a quick tour primitive or something else you need to make sure that everybody would understand what you\u0027re doing yeah so I think this this this slide is kind of focused on the crypto ideas around the statement but I think there\u0027s also even more basic protocol understanding ideas actually yeah well no it\u0027s not so that the cha-cha 30 problem is still a crypto problem because it\u0027s like how do you get everyone to do something different but like even being able to part the Welcome message that comes back but it chooses version well okay means like great okay so fine if you own it that way okay like we I decide I want us I just add a mood I just added emojis and I\u0027d like everyone even to like send emojis but I want to send a movie but I mode you look bad like when I send a people no emojis so I need to know everything the group supports emojis so like doing head us all of that I mean I think we may because all the things ordered but I\u0027m just saying like like you know that\u0027s like a much easier problem so like maybe something write that down and then we can uh Korean like how you upgrade from like you know or you know from like ASCII text to like mine or something like that and then once that works then like we talked about it do this Catherine could we not solve that problem to be clear to be clear in many deployment context you will unilaterally control all endpoints correct and therefore you can just defied all my endpoint support emoji now I mean maybe but I mean I mean so if you feel in context is like we have clients that\u0027s true for your Pokemon stack apps that\u0027s not true because you don\u0027t know people if update or not so yeah so um like even then is a little is like non-trivial but in open systems is like much less trivial right but I would hope that MLS doesn\u0027t have to solve the problem of companies shipping different versions of apps to different phones yeah I agree that if a problem I\u0027m not "
  },
  {
    "startTime": "01:19:34",
    "text": "sure that\u0027s a problem that MLS should have to solve well I guess I guess mmm but maybe not but I guess my point is like if you can\u0027t describe how you solve that problem in this context you can\u0027t describe figure so the person update problem this context so maybe you\u0027re gonna write down my halves are all under Center control and I make sure they\u0027re all the same but like like it like that but write that down them because like if you\u0027re not if you\u0027re not going to tell me how to solve that problem then you can tell me there\u0027s all this one this is dkg so cat rola like yes there certainly are deployments where it seems possible I\u0027m sorry my back is to you just because of where the microphone is not I don\u0027t mean to yeah I could just talk to you in my back um there are situations where you can do that solution but if what we\u0027re saying is MLS will only work for long live groups in scenarios where you can unilaterally have a flag day then that means to be written into the architectural draft and it\u0027s currently not because I\u0027m gonna hear you that like you don\u0027t want to deal with the open world problem because it\u0027s really hard and it\u0027s what we struggle hit with here at the IETF right if you\u0027re John the Senators here at the ITF then either we need to say by the way you need to be sure that you have a way to upgrade all your clients synchronously or we need to say that we have some idea about how we\u0027re gonna do an upgrade path or we can say your your conversation is good only for as long as you\u0027re deployed clients are synchronized and then you\u0027ll you\u0027ll have to find some everyone will switch from wire to 3ma to in order to upgrade I\u0027ll go away and think about it but my I\u0027m not sure I\u0027m convinced that solving you upgrade the version of MLF is the famous solving you want to negotiate some of your clients supporting emoji but I\u0027ll go wait think about it so I go back to my previous comment which no I I think I was asking an even worse and simple question than that like I was going back to the not upgrading a group that\u0027s starting a group at all right in TLS I think in quick I\u0027m looking at Thompson because I think quickest thought about this in some detail is question of version what stays constant among versions okay I\u0027m staying I\u0027m like thank you [Music] [Music] right so so there\u0027s this question of like what stays constant across versions like in in TLS we\u0027ve like tried to keep compat in the client hello right so that these server knows what versions of clients of course and could do proper version negotiation that way so one "
  },
  {
    "startTime": "01:22:35",
    "text": "could imagine writing some similar invariants here and and you know what are the considerations we want to take into account here Thomson would you like to like provide some background from the TLS quick point of view yes so Thompson the the thinking and quick has been largely that we you need to have some way of knowing signaling what version you intend to have and that needs to be invariant across all versions that\u0027s kind of the baseline and then you need some way of sort of signaling that that version is not ok somehow and so tell us has it has far more in its in his baseline invariance because it says that the client hello is this shape and shall henceforth forever be this shape and so everyone who understands any any version of TLS can say well the table until I said Clym hello is always this shape and therefore I can I can rely on that fact here that\u0027s sort of a second order protocol consideration though I think what I think you need to concentrate on is what what are the states that you\u0027re looking at what are the what information exists in state 1 and information exists in state 2 and what needs to be carry across from from one to the other and what needs to be changed in in the two different ones and you could imagine a world where you start a new group because you wanted to change the color of the pixels that were rendered right and maybe you run two groups in parallel that\u0027s at that point and they have some constraints on how group membership to synchronize will have you I don\u0027t really know but there\u0027s there\u0027s a number of ways you can imagine this working and none of them really sort of read on that particular aspect of the problem unfortunately hopefully that wasn\u0027t too indecipherable I think one of the one of the things that you might try to think about to start start out this discussion is cipher Suites because that\u0027s one thing in which a group is going to be different from other groups right yeah cipher suites is one thing new messages new message formats might be another so to summarize what we have now in draft or for is this and this seems to be rather uncontroversial in the sense that nobody has jumped up to the mic to criticize that so yeah going forward it\u0027s our question how we channel that discussion if you bytes fighting back one slide leaving it up for a minute yeah okay too soon yeah how do you imagine this working so you have a disparate community of clients and they have potentially non "
  },
  {
    "startTime": "01:25:36",
    "text": "overlapping sets of supported versions right is the is the way this works the first person who went to the room determines the version is it\u0027s some sort of negotiation process what at what point does the final version which I mentioned is this thing on the on the right hand side what version point is that committed to because you can imagine a scenario where one person joins and that determines the version and then basically the whatever version the server or that person decides right so what happens is that there is one group initiator always a design that is going to retrieve a number of user and keys of the members that should be part of the graph and from that the initiator can determine what\u0027s possible at all I assume the initiative would go for the highest possible version because it\u0027s the best one but that remains to be seen what I get to choose that day but they get to choose and then they commit to that in the world come in for so everybody they invite they tell them exactly which protocol version and this is not an array this is just one version right at that point is to be used so as of that point you have a static group in the version and that\u0027s it basically so there\u0027s no negotiation as such between people it is it is really just members advertising their capabilities in the user in keys and then an initiated choosing from that yeah there\u0027s no negotiation until I say this is dkg so in this scenario the consequences are just to state them clearly when you go to add someone to this group and you discover that they do not support the version that the group is in you get some sort of message that this person cannot participate in this discussion so low sodium and in the future when you poll the members of group and find that they are all capable of a new version there\u0027s no way to upgrade the existing conversation or there\u0027s no explicit not something Jax and this is this is just saying any particular conversation is happens at one version that\u0027s negotiated at the initial assembly of the group and if you want to change it later that\u0027s we punt that for further down the road yeah you punt that potentially by starting a home to group someone said behind me and I couldn\u0027t see them yeah Jonathan Lennox pointed out that you can start a whole new group the question there is whether there\u0027s anything that this group needs to do to vote to ensure that starting a whole new group remains secure in and retains all the properties that were interested in retain going across that transition those are the open questions so the last one well whether or not you solve the migrated the current group to a new version or not you\u0027re still dealing with essentially the same problem which is is it secure going from state one to state two right relaying "
  },
  {
    "startTime": "01:28:39",
    "text": "from Java perhaps not the right question for now omnia asks what about the blanking problem slash double joint that seems completely unrelated in that sense that that\u0027s what I thought happy to discuss it later but maybe we conclude this first so yeah I mean to me it seems that this rather primitive mechanism could be a building block for something more mature where you can one day upgrade a group it doesn\u0027t seem to prevent a credibility of groups to me so I mean I would say that we discussed the rest on the mailing list preferably with concrete proposals of either how a group could be torn down and then resurrected on the application layer or how we can smoothly up credit group with maybe new kind of handshake message or whatever makes sense I think that\u0027s it so that\u0027s all that we had scheduled for today actually it\u0027s a little early but that\u0027s okay we got um another hour and a half on Thursday unless there\u0027s something else that we want to add well I could like revert my agenda bash and put that topic back on the sessions agenda the key schedule stuff the key schedule stuff yeah yeah I mean if you want I can we want to go over maybe we don\u0027t come to it again and we can now we can do it quick as we have 30 minutes it\u0027s in ads I was waiting for but when I his team is here I\u0027m not right his representative may come on put him on the spot and enjoy it also commented on that so I think we\u0027ve got we got quorum for that right you can have the clicker back wonderful all right so tree warning there\u0027s mostly been free of trees today but I think there\u0027s a couple minutes can give you a line here so just to recap this is a problem we\u0027ve talked about a couple times right now to confirm that all the members agree on the state of the group we have this group state object that gets fed into the key schedule and then used to confirm that agreement right now that group state object includes the roster the list of members in the group and their signature keys and the tree which has all of the d-h public keys involved in this now each of those the size of each of those is linear in the size of the group so the group state object is very really quite large when you have a large group and that the "
  },
  {
    "startTime": "01:31:41",
    "text": "upshot of that is that whenever you do a draw a secret operation which is the core operation in the key schedule you need to now hash this linear size thing which is a lot of computation to do so that that has made some people have friendly faces on the list we had some discussion about this outlined a couple of objectives you could envision here one is kind of trying to simplify things in general you could try and have a smaller coefficient on the linear size amount of data you could come by pre hash some things make them smaller but I think where we where is probably more useful to go here is to try and reduce the amount of hashing you need to do for the derived secret operation this and get it down to a more log like things that\u0027s more more parallel to the amounts of operation that we\u0027re used to in things like updates and removes I am proposing that we not take this the stronger form of sub linearity here trying to enable two folks to get along with a sub linear amount of state I think we\u0027re still going to the proposal here Institute\u0027s that each member will still be required to keep around the whole tree and the whole roster but they won\u0027t have to hash all of it every time they do they have to the key schedule they\u0027ll have to hash some summary of it that will have log size does anyone feel real strongly that we should be aiming to allow endpoints to get away with a log size state and see Geralt shaking his head okay so no one\u0027s leaping to the mic to to say that I agree that\u0027s it\u0027s a desirable thing but it requires a lot of extra information the hikmah so I got a summary and I think it\u0027s actually not desirable to have the clients keep a sub linear amount of state like I think the clients in the secure messaging application should know who\u0027s involved in the messaging sorry that was dkg yep fair enough okay great so I\u0027ve got a PRF right now which sketches out as a solution here it follows the the UM Pellman hash approach that I\u0027d outlined on the mailing list in the in the PR it\u0027s called a tree hash which is somewhat less colorful but also less likely to run into trademark issues okay and well the approach here is is kind of Merkle tree like but with an extra input in the intermediate notes so you can align it to the tree structure right so with the leaf nodes we\u0027ve collapsed the collapse the roster into this struct so the leaf node info here holds both the leaf public key as well as the credential for the member holding that leaf so you gather all that input together and put it in to the the leaf hash in this overall hash structure it\u0027s "
  },
  {
    "startTime": "01:34:42",
    "text": "optional obviously because leaves can be blank if they\u0027re not occupied by a member so that\u0027s how leaves leaves get hashed and then when you have an intermediate node you have its left and right children you know represented by their hashes and you then feed in the public key at that node in hash form as well there\u0027s an error in the PR because that should be optional because you can also have option blank intermediate nodes just have to figure out how to do that easily and TLS syntax but basically you do this in code and hash and code and hash dance up the tree and you end up with a root hash which is a summary of the whole tree it\u0027s a commitment of the whole tree just as a numerical tree so you\u0027re committed to all of the public keys in the tree as well as the credentials of the leaves kind of by the transitive property of hashing and the upshot what that lets you do in protocol terms is that instead of having the group state contain the roster and the tree and have this big linearize thing you can just have the tree hash which is a single hash value and so you have a constant size group state object that gets fed into the key schedule and it\u0027s and it\u0027s all much faster you you do have to keep this thing up-to-date as you change the group but the upshot of that is because we\u0027ve aligned the the hashing to the tree structure you just have to do a lot you have to do the same number of hashes as the nodes you change of the tree so typically log worst-case linear so that\u0027s the proposal on when it\u0027s a briefly visit you know nobody was calling for a ver trying gets the log state but if you were if you were inclined to go that way here\u0027s why you might not and the reason for that is like if you\u0027re going to try and a lot of people get by with only log state then you have to provide them the parts of the tree that they\u0027re not seeing so you have to provide the hashes of the the alternate children and so you end up multiplying the size of your handshake messages by two or three times which seems like kind of a lot of bloat in order to get the smaller state for the last line here like there was some discussion of extension a little while ago maybe this is something if people were really keen on this that could be added as an extension point in the in the handshake messages so you could say here\u0027s your public keys you need to update the tree and as an extension here is the hash values you need to update the tree hash um could be there but it doesn\u0027t sound like there\u0027s a whole lot of energy and interest in the room so overall like does it does this answer the mail does it sound like a sane proposal thumbs-up from Joelle questions comments should we just merge the PR [Music] gothic by going from India so there is value in having the hash of the tree in many situations but also value in having the some representative of the transcript of all the operations that have happened so far and they\u0027re kind of related but somewhat different ways of looking at it so do we already have a notion of the "
  },
  {
    "startTime": "01:37:44",
    "text": "transcript and where is that getting fair and well it\u0027s getting hashed yeah that\u0027s perhaps a good discussion have right now and in parallel with this I think the current PR well so in O War as in the previous versions there is a transcript - there in addition to the giant stuff I think in the PR it just takes the gigantic stuff and collapses that down to a tree hash so you end up with a transcript hash and a tree hash and the transcript hash has chains over the tree houses no no no the transcript has chains over the actual message that were messages that were sent so it\u0027s it\u0027s a hash chain over the the handshake messages that were sent right so just kind of abstractly if it were the case it probably is that if you know the initial tree and you know the transcript if you\u0027re given initially maybe on the transcript and deterministically you should be agreeing also on the current tree so this does seem to be somewhat redundant perhaps in a good way perhaps not necessarily where we have these two representatives of essentially the same state where the transcript - actually has strictly more information it\u0027s a great you are going on well you work here more information in principle but I think actually less information in practice because if I\u0027m a late joiner and you just hand me this transcript Cassius I have no way to interpret it rightfully gender said that is a problem right and so that there\u0027s I think the question I think pension right discuss some is whether you could get away with only the tree hash and not using the transcript hash at all because you know the transcript hash doesn\u0027t add anything unless you\u0027ve been there the whole time I just dis late - Jonathan Holland does late joining mean anyone apart from the first member well you you get you get information from the transcript - in purport to the number of handshake messages you\u0027ve seen right so you can verify a chunk of handshake messages but the hash itself only authenticates messages that you have so if you don\u0027t have if you come into a group and you don\u0027t have the history it doesn\u0027t give you anything so so the first and second member then can can fully interpret it or fully understand this transcript - well if I join at epoch five or I park two hundred say and I\u0027m given the transcript - at that point that epic 501 like I can look at the transcript - and the you know the when I was handed when I joined in the sequence of messages I received in the mean time and verify that that is good but I can\u0027t verify anything prior to when I joined shell okay thank you yeah this is Joelle when again step does the the transcript hash includes actual messages as well not just update group update stuff it only includes the "
  },
  {
    "startTime": "01:40:45",
    "text": "handshake message just change the state of the group it doesn\u0027t include the application messages although the actual messages are perfecting all right yeah yes it\u0027s not quite wasn\u0027t the advertised topic of this section but I think it\u0027s it\u0027s a question that one could could ask is like whether we should delete the transcript hash from the protocol because might not be adding any value that we\u0027re not already getting from the triage well Costigan in RIA so from the transcript hash the thing is said there could be multiple transcripts that lead to the same state it was potentially possible and considering that one path might lead through a malicious node who has done something and one other path may lead through perhaps only non malicious nodes in the analysis it actually becomes important how we got here not just where we got because of what could have been influenced and stuff so for the analysis when you do the security analysis you certainly I think would prefer to have more information which is what is there in the transcript - so one way of dealing with is to say that the transcript house should contain I mean every the way you update a transcript hash is you take the the current rehash and then you add the new operation whatever the new message was and then you get the new transcript - we could be we could define a transcript as something that is some treasure as something that\u0027s worth builds on top of the tree hash now that might be overkill on the cable whatever we can think about that yeah I think that\u0027s maybe one step too far one step too fancy yeah I don\u0027t think there\u0027s a whole lot of benefit to having one hash to set up - in this case you know a transcript that receives us the transcript messages and the tree hash which is just the tree and those two get combined in the key schedule but yeah I\u0027m happy to keep the transcript - around if you think it has some value it\u0027s not it\u0027s not expensive really - the protocol so ok sounds like folks are ok with this tree hashing scheme so I guess you can probably just go ahead and land this I\u0027ll take another pass through the PR and make sure we address like the optionality blank intermediate nodes but I think we\u0027re good to go all right get to go eat cookies early see you all Thursday "
  },
  {
    "startTime": "01:44:03",
    "text": "you "
  }
]