[
  {
    "startTime": "00:00:56",
    "text": "30. And the accident and, and, Okay. Sounds good. Thanks for Alright, everybody. Can everyone hear me? Okay. Alright. Yeah. Thanks, everyone. Iutf 119. This is the VPF Working Group. Thanks everybody for joining us. This is our 3rd official BPS working group meeting, 4th 3rd. 3rd? Okay. I'm David Bernay. This is Suresh Krishnan. Let's go over the agendas per usual, a few other notes as well. So as always, we're gonna start with the note well. If you're not familiar, please read up on, on the note well. So you can remind yourself of IHTF Policies on topics like patents and code of conduct."
  },
  {
    "startTime": "00:02:01",
    "text": "Yeah. And, this is an IETF meeting. So we're going to live by the F code of conduct, everybody should be respectful and courteous of each other at all times. This is, you know, this is the IETF. We know what we're here for. as we'll talk about later as well. There's there's always gonna be a mix of IETF people, Linux kernel people, this is, you know, a a community of both. So anybody from any background is welcome. Of course, participate and, and help drive this forward. Here are the administrative tasks at tasks, excuse me, have a ether pad here, meet echo. Does anybody have, availability or desire to take notes for this meeting Thank it. you. Appreciate Yep. Alright. Here's the agenda. We're doing the bashing right now. Shouldn't take much longer. Then Dave Fowler is going to jump in to go over, the latest for the Bpf is, Yeah, Dave's here. To go over an update on, everything that's changed or the specification document since ITF118. The, following that we'll have another 15 minute presentation given by Dave on, the call instruction, the, indirect call instruction, Vpf, And then following that, Nalini Elkins, I apologize in advance if I if I mispronounce your name, but, gonna be giving us an overview of of some implementations of VPS and how that's being leveraged. Sure. Yeah. Showing the slides So let me Oh, Yeah. Yeah. People are chatting with? Yeah. Like, they were saying, Oh, yeah. There you go. okay. How did you do that on the bottom? That's Here. I mean, you got it. Yeah. Yeah. Okay. So, yeah, sorry about that, everybody. Cut of conduct, the administrative tasks somebody already kindly offered to do. The note taking. Yeah. Here's the agenda."
  },
  {
    "startTime": "00:04:03",
    "text": "The bashing we're doing now is a specification. Like I mentioned, Dave will be taking over after this for about a 45 minute discussion, which could go over, depending on what we discuss. The ISSA document is now in last call. So we wanna try to get as many things taken care of in this discussion today as we can. Obviously, if you don't get everything, that's okay. But, you know, it's in last call. So now's a good time to to raise any any thoughts you have. After that, we'll be talking about the call x, the indirect call instruction, Again, led by Dave, probably about 15 minutes. And then, Nalini will be will be discussing an implementation or, an application of BPS, I should say, being used, by by, by them. Yeah. So that'll be thing as well. About 20 minutes. Alright. That's about it. Oh, yeah. Can you sorry. So as I said before, our newcomers are welcome. Bpf it's, it's not our first meeting, but, you know, it's a large ecosystem. Everybody's willing in a More than well more than welcome to participate. And if you have questions, the, the floor is yours, So that's all we had. Any questions before we get started and and hand hand off today for the, ISSA discussion. Okay. Alright. Great. Thank you. Dave, Take it away. I think, yeah, you should be coming up soon. Alright. I clicked ask slides. Literature. I did give you control. I gave you control there. Do you have it? Not the same way as when we trusted it right beforehand. Because it's on the chair slides right now. Change deck. Let me try this. It's coming. Alright. Here we go. Next. Alright. How is it presented? Yeah. It's looking good. Thanks. Okay. Great. Alright. So, I am they were independent. For the first time at IET here. So let's go ahead and get started."
  },
  {
    "startTime": "00:06:00",
    "text": "Talk about the things from last time. My goal is to spend only very little time things that are, at trivial and So the first couple of slides, I'll go through pretty quick, unless people have questions. And spend most of the time on things that are more technical. So just some history in case anybody is new in the meeting here, draft 0, which was not the first version of the document per se. It was the first draft format was in October which we discussed at IETF 118, We've had a bunch of discussion on the list, a bunch of patches merged, draft 01 was post on March 3rd, and then the working group last call started March 7th and last until at least April 5th I think in the working request call announcement, it said, at least, 2 weeks after the conclusion of the meeting, it didn't actually set a deadline. And so April 5th or later, the chairs get to decide what the closing that it the date the me. the intention for now is for it to be, April 5th. Yeah. Thanks for thanks for clarifying Okay. Excellent. So you still have time to, review if something, jobs, you remember at this time to follow-up and and come in time later. That's perfectly fine. Alright. So let's talk about, I've been using the GitHub repository it was presented even back in the, BAF for tracking of open issues, right? The actual changes to the draft, right, are go through the, process to go the Linux kernel repository, but her tracking, what's the status of issues, and what's been responded to and so on. I've been using the GitHub issues to track basically it's my own to do list, it's public. And so, anybody is welcome to see it and see the status of stuff. I'm just highlighting if that's where things are. The repository as created does not have ISA in the name. So it's the IETF Working Group/bpf, do an ETF docs and so anything that's for the ISA document as a label that's tagged as, ISA, so just because it's in there doesn't mean it has anything to do with the ISA document. So sometimes it's unclear, and then it gets tagged or removed based on discussion about, oh, this doesn't belong in Right? Or it does belong in this. Right?"
  },
  {
    "startTime": "00:08:02",
    "text": "And so in terms of velocity, we've addressed, 19 ISA specific issues since IETF 118. That's a good run. And there's been a couple the opened since working group last call started, mostly just type of trivial things that aren't necessarily worth discussing, but I'll still show them at the end. So so this is one This is my one slide on editorial I'm not gonna go through these, but these are things that that's that list of stuff that I don't think needs any discussion, they were pretty trivial. If you wanna talk about something, feel free. We can come back to it But these are the ones that I that to my knowledge, there's nothing to talk about. So just giving visibility that there's a whole bunch of things that are just editorial that were addressed or clarifications, typically cases where Two places in the document were inconsistent with each other. And we updated them to be consistent. Alright. That's the general Fred. One editorial change just worth noting is actually changed the document total. The document total is now consistent with the charter, right, where the charter says that we do the BPS instruction set architecture So we renamed the document to actually say that because we always refer to it as the but it didn't use ISA in the title. So that's a that's an example of one that, just to highlight Alright. So now we're getting into the the the technical things that have been done since last time. So this is, I don't believe there's any open issues here. Just reporting back out. That this has changed. To confirm consensus was that, that I did it correctly. I think that we've already gotten, merging on the kernel list, right, but we're report it back to everybody here at so first of all, the first one had to do with how legacy packet instructions are handled in the document. So there's 2 very closely related issues. 1 was about the what set of opcodes or deprecated. Fence, Back in 00"
  },
  {
    "startTime": "00:10:02",
    "text": "you could read the text and you could read it as saying, all possible combinations of APS and IND opcodes are deprecated, including ones that were never used. And so, 1 updates that get you in a second here. The other one, isn't about the up codes, it's about the other fields. Right? So for the up codes that are used, what's the values of, Deskridge, offset, and service where you could read 00 is saying combinations are deprecated. Whereas, in reality, the only things that were ever used are cases where those are 0 for a test dredge and offset. And 0 for source reg in the ABS case. And so 1 makes the text be more specific and the appendix, likewise, be more specific. So that we only deprecate the things we're actually used in the wild. And that leaves laundry space available for few Christmas. I'm gonna keep going unless there's any questions, right, because this is all stuff that we've already done and kind of already on the list. Right? So didn't know it's a set of things. We're not specific to the deprecated instructions, some of these are about some new instructions. Some of them were and just making the things be more explicit even though some of these were kind of implied, but it's better to be explicit. The first one was about a new instruction that moved with sign extension instruction. We clarified that, This instruction is only defined when the source, it says that you're sign extending or register. Right? There's no real use case for sign extending immediate value, right, you would just use a different instructions. Right? And so this clarifies that, there is no such thing as a move x without the source equals x bit. That's an undefined space. Right? Similarly, some of the jump instructions were kind of implied"
  },
  {
    "startTime": "00:12:01",
    "text": "because it said unused fields are set to 0, but we made those be pretty explicit. So the exit instruction, for example, needs source equals k. Well, the source isn't really is kind of a a don't care, right, because there's no value that you're using with exit. Right? And so whether it's a register and immediate, it's kind of a is it k or x? It's arbitrary. Right? So it's just defined to be 0. And so things like that that, kind of already said that before if you squinted, but now it's just explicit. So that was just an editorial change. Same thing with, regular calls, meaning it was door sequence k, and the same thing was jump always. All of these is just being explicit about things that we're kind of and then finally, similarly, with the, negation operation, meaning, like, arithmetic minus again, source equals k. So that's just, clarifications that help to improve the the document and to help to avoid bugs if somebody's gonna implement off of the spec. Alright. Now we're getting the ones that were actually touching more of the documents So this one touched a large percentage of the document, but it was purely editorial and doesn't affect code at all, code at all. This one, I don't know how to pronounce his name. Ao Yang, Fang, my best guess anyway. Put it out. That, Some of there are pay various cases with 4 bit fields, for the spec talked about 8 bit values for them. So, for example, vpf_sub equals Hex 10 is an 8 bit value the field is the left 4 bits of those. Right? So one in the field that you're talking tier and 0 on the other field and so it was, sometimes it did this, and other times it just said, here's the value of the 4 see you. So he said, what do we do about this? And so we some list discussion had"
  },
  {
    "startTime": "00:14:02",
    "text": "and the consensus on the list that the chair is called was to credit, excuse his usual Iutf conventions, you know, documentation conventions, The defined 4 bit values for 4 bit fields, and 2 bit values for 2 bit fields, and so on, and so we, reformatted the document to be consistent with the way things tend to look in order to prevent conflicts in terminology then I dropped the bpf_prefix from the fields defined like this. You can see Whereas it's BPSSA being the full opcode 8bits is hex 10 The sub bits, just being 4 of those, doesn't use BPS Under Score. It says sub equals 1, which is a four bit value. Right? Now this is not a case we put in code. It's a Bpf sub and sub and get a conflict whatever. Those are 2 different things depending on what you're implementing off of the full 8 bits or implementing off of the 4 bits. So documentation convention, and so the diagrams change to use the classic IETF look, which is illustrated at the bottom there, rather than the, see like, struct definitions with, you know, colon 4 for a four bit field and things like that that the document used to use. So, again, there's nothing that it says now that it didn't say before, as you the style of documenting it now matches what's typical in RFCs, and this resolves the issue that Aoyan Grace k. But that one, the the majority of the changes in the document number of not lines have lines have changed the document, that one accounts for probably more lines have changed anything else because it touched lots of different places in the document to to make the change. Alright. Not seeing questions I wanna keep moving. The next category had to do with the discussion around documentation of 64 bit immediate questions, right? There's a section that's basically called k. K. In draft 00, yet"
  },
  {
    "startTime": "00:16:03",
    "text": "It was text that introduced, the formatting and instructions that said, or at least implied that all 64 bit immediate instructions use this thing that it defined as IMM64 which it put two fields together to calculate that. But it turned out that only one of them does, and so that was a little bit confusing. So in particular, out of all the immediate instructions one uses that 2 of them use IMF and the next IMF field for different purposes. Right? They're not combined. They mean 2 different things in in the use. And 4 of them don't use next time in at all, and so you always set it to 0. K. So it said, since the computation of this I'm M64, only used by a single instruction, not all of the 64 bit immediate, then we moved that consultation. I think it was if it's Kristoff or or, young correspondent did the change, but, thank you. Anyway, the the change was moved down into the one instruction. And so now there's no such thing as, before that appears in the document anymore. It's just the one instruction contains the computation for your computer 64 bit value. Everything is done in terms of I amm and next I amm, and there's a little diagram down below that shows, you know, when it's a 64 bit, and the following instruction, instead of being shown as, you know, opcode 2 and regs 2 and offset 2 and so on. It's just, you know, reserved, right, must be 0. Because they're not really an offset field. I mean, you could, because for Sierra, but it's just IBM and next IMAM are the only things that are used. So if that's the diagram as it appears now, and it still explains in the text, that contains a pseudo instruction with opcode, Deskridge, source reg, and offset false to 0. That text still remains. So if you wanna describe it that way, that's fine. The document still does. So Okay. Most of the discussion that we had at IETF118,"
  },
  {
    "startTime": "00:18:00",
    "text": "on the list was actually in this category of how do we deal with conformance groups. Right? This was the main topic last time that we said We could go to a working group last call left. We resolved how we're gonna do this, and so this is where the actual work was was in this category. Right? That's a split between 2 different issues, but I'm just gonna combine them together to cover conformance groups because This is the main set of work that was done since IITF 1 18. I'm also gonna give a little bit of an implementation report because, it's we had, implementation work that, resulted in some of the issues the thing got clarified, and so that helps to give, faith in the correctness and completeness and clarity of the of the text, which is good. So Alright. So we talked about at 1 18 just to recap, we said that we were going to use, quote, logical units of functionality that term on the slides that, we used, as opposed to something else, whether it was, you know, playing CPU version numbers or whatever else, right, as the things that would define groups of of what you can make informed us to do. The result of this choice is that the current Linux kernel is course, RFC compliance, certified definition of the spec, right? It's it's the documenting what's actually used. But, this choice was, that older versions that at least there's no current reason, to make to make to make to make to make Oh, I come to you in just a minute, Kristoff, that older versions of Linux and windows or anything else are not necessarily RFC compliant, right, because they may have some combination that we're specifically crafting conformance groups to meet that. Right? And so even the basic one, they're gonna say, you can't say it's RFC compliant. Only the latest one is RFC Right? We want things to be able to see compliant going forwards. Is no current request to retroactively try to make old maybe, older things BRFC compliant. And if you had a question on that, I can pause here, Kristoff. Otherwise, you can wait till the end. So Yeah. Christophe, go ahead. And the other important point is only, like, the Prime Maintained Linux Architect or RC compliant, all the various, like,"
  },
  {
    "startTime": "00:20:03",
    "text": "Not perfectly up to date. Architect reports are neither. Bit. That's kinda expected. Yep. Twist Thank you, Rissa. Okay. So, again, this is from Iutfone 18. That, sorry, Oh, go ahead. Yeah. Yeah. The other thing to probably mention is that, the the conformance groups basically match what risk 5 does. So the idea is that if you're a vendor implementing parts of the the for, then you're probably, I mean, you might be using risk 5 and you know, we're we're sort of following the contours of what they're laying down for what they consider to be logically conforming groups of instructions. So The older versions, aren't RFC compliant, but would say kind of looking forward. It's it's sort of we're kind of looking towards what we think vendors would care about. And, yeah, hopefully, risk 5 will represent that. Yep. Yep. Yep. Yep. So and it's current state meaning how you write things at the beginning, right, as we mention the DITF 118 every instruction exists right now in the ISA, is in exactly one is one that conformance group. That's because we don't have a reason at at at time 0 to have any instruction being more than 1. But over time, An instruction can be in multiple groups because of the way that addition and deprecation mechanisms work, and I have examples on later slides. Right? But the intent is, you know, by default, every instruction isn't exactly one. But you'll see that, that is not a documentation constraint. It's just a that's what best practice Right? And what and and what makes sense technically And whereas before we had conformance groups, every instruction we would, it have to individually track whether it was permanent or deprecated, you know, what the registration status Is it deprecated? Is it not deprecated? Is it you know, vendors specific or whatever it is. Right? We'd have to track that on a per instruction basis. Price. By switching to conformance groups, we said the granularity of tracking that is not at the individual instruction"
  },
  {
    "startTime": "00:22:01",
    "text": "at the conformance group basis. Right? So you can deprecate an entire group, or you can, take a a group of stuff and then just tied to standardize that that type stuff. And so you can still make groups as small as a single instruction. So there's no loss of generality. But it is certainly simpler to deal, administratively with a status per group within a status for every individual instruction. Alright. So, Here's the set of conformance groups that were discussed on the and what the document has matches, and I think as David mentioned, this part, at least this list was in part constructed based on what, risk 5 does. Oh, I see a typo there. The 2 divmole ones, the 64 bit division is missing the common multiplication and those should match. Right? So I think you guys get that So for most of these, there's a 32 bit variant and 64 bit variant. For the legacy packet instructions, that's the only one you can see in the bottom right corner. That's the deprecated set everything else is not deprecated. The status there? So, the includes column means that if you claim Conformis to say basic 64 then it means you you can't do that unless you also automatically conform to all of base 32. So base 64 includes everything in base 32 plus everything explicitly tagged as base 64. And the same things together. And so let's say if you are saying, what does the latest Linux kernel support You'd say atomic 64, base 64 divimal 64 and packet. Okay? That would be the answer for latest winks, right? For some other runtime, let's say you had an offload card, then you might not have the 64, as you might say, base 32 is the smallest one you could possibly support in BRC compliant. Just say base 32 only. Right. Right. Right."
  },
  {
    "startTime": "00:24:00",
    "text": "Various other variant variations are possible if we have a run times or off load cards or what Makes sense. Okay. I'm gonna give a brief I'm gonna interrupt the the the regular thing. Well, I'm non topics of conformance groups to give, some implementation status on this one. Just to say how well did we do at describing it as the cables complete and we're confident that we don't have errors in it because, were issues filed during this 1, there were 2 typo issues filed, I think after working group last call started, and they're kind of all in this category of just implement says making sure there's no typos in it and so So the first one, there's open service project that the link is there on GitHub. This is the DPF Conformis suite, and so this is an open source project. That has a bunch of ISA confirm its tests. Right. I'm sure there'll be more and more added over time, but there's a lot of them that are in there now. K? As of about a month ago, that project now supports conformance groups. So what does that mean? Okay? Well, it means that the user that's gonna run the performance test can specify what groups to include or exclude during a conformance test run. K? So if you're gonna test, you know, a particular runtime that doesn't the 64 bit ones, you can say do a run, and just use the 32 bit ones and see if it supplies, you know, past, past, past, past, past, or I wanted to supply this new one. Am I there yet? And I can run it and it'll say, nope, you know, Right? By default, if you don't specify, then it uses the set of groups supported by the latest Linux are the ones that I mentioned before, right, base 64, atomic 64, or decimal 64 impact. That's the default account that's best this con this open source project is then used for testing at least 5 other open source projects. Although, Bpf conformance itself has a test suite that tests meaning a CICD run that tested against the Linux kernel is kind of a base Right? So it's Linux curdle, by being used by VBF Conformats, then for their projects use performance. See a hand up."
  },
  {
    "startTime": "00:26:04",
    "text": "Yeah. So, Dave, I, I kind of, like, did not get this historical thing. So I had a different understanding of historical. So, So you're saying the deprecated also goes into historical. Right? Like, so maybe we kind of need to rethink the registration policy for that because, like, we probably don't wanna write like a whole spec for doing changing something to historical right from permanent in case we wanna deprecate it. Or, like, either come up with a new status or, like, you know, change the policy on how we change things, like, from the state just the status like, I thought deprecator was, like, something different than historical. Maybe we probably need to rethink that. I just like to realize that. So okay, I'm gonna repeat back what I think you're pointing out because I think pointing out is not actually on the slides, which is, you know, go back one, So when it's historical right now, for every status, there's, IANA policy associated, right, whether it's, you know, IETF, standard standard or, you know, expert review or whatever, and today, the document says historical requires specification required. Correct. And you're saying you would see drop to expert like to that review Something like so, I kinda want I I always thought like, of differentiating, like, registering something as a historical thing that happened before are, like, changing something to deprecate it. Like, the the the deprecation could change the status of historical, but it requires, like, much less lightweight process. That is kind of what I thinking. We can noodle on the test afterwards. was That that that's great to appear in the in the minutes. I would support that propose you're right. That's not what the document says right now, but the historical and saying that you're looking at, you know, review sounds great to me. If we file an issue for that, I'm happy to author of the patch that does that. So Okay. Thanks, Andy. So what's the logic for, for making it more onerous to, like, like, less onerous to drop something historical, why would we want"
  },
  {
    "startTime": "00:28:01",
    "text": "to make it less onerous to do that. Let's say we want to deprecate something. Right? We don't wanna write an RFC to do specification required does not require an RFC. It just requires a document. Referenceable It could be a text file in the Linux kernel tree. Okay. That's a specification. Right? It's it's whatever the designated decides a sufficient documentation. Okay. So let let's talk about it, Dave. Okay? So take it through the system, Yeah. Because, like, I, I think we probably need more discussion because, like, Dave does wanna make it easier, but we can talk about that too. Yeah. I mean, I guess, I think the the default assumption so far has been that it should be like a relatively high bar to with that and deprecate instructions. And I'm not opposed to changing that, but I think, I would Yeah. I would be curious to hear, like, what what we think I gain out of making it easier. Yeah. K. I personally don't carry their way, so but I'm but I'm okay with off a change if the working response to that, but I don't have any preference either way. So Alright. Someone to continue on the other project that it's been implemented, and I've got a slide just on status of each of these is what the result was. The other one is prevail is the name of an open source, verifier that can be used by multiple run times. It's used by EVPF for Windows, and I believe it's used by at least 1 or 2 other front times. That I don't know the names of. Go ahead, David. Yeah, sorry. I just want I was curious, for the for the Bpf conformance So is it? It tries to execute the, the instruction and then, what sees if, like, the jit accepts it or ejects it or, like, can you maybe go into a bit more detail just out of curiosity? Yeah. Sure. What it does is the the the BPS Conformant suite, which I'm not the maintainer of Ellen Joe. It is, but I have contributed stuff to it. I guess I'm a contributor but not a maintainer."
  },
  {
    "startTime": "00:30:01",
    "text": "And so I'm familiar with how it works because I've contributed code to the way that it works is it is a, framework that can then run a plugin. And so you're gonna integrate it with another runtime, then you'd write a run a plugin for that runtime, that, DPF conformance would invoke, and so it passed in a set of instructions and what the input, you know, memory is or whatever it is, and then what the plug in reports back is what is the result what what is the value? I think it's of, r0 at the time of the depletion of this set of instructions. Okay? So there's a way to pass back. And then what it does is it compares that against an expected answer. Okay. So the Conformis test suite, at the Conformis test, a set of 1 or more instructions to be executed by the plugin and an expected result. That comes back. Gotcha. Okay. Yeah. I I can take a another closer look at the code. I my initial under you know, explication would be if a jit didn't accept an instruction that it wouldn't really There wouldn't be like a semantic meaning of what was in our 0 at the end because it wouldn't executed in the first place, but, Sure. Sure. So there's there's a couple different results of a run, for a particular test case, right? It can come up with the correct answer can come up with a wrong answer, or it can hit an error before it can come up with anything, and that would be your example of where, you know, legit fails and can't actually, you Run it, Fred. Okay. Gotcha. Cool. Thanks. So that's what it does. And so since it's since the core part is agnostic as to what it's running against, that's the plug in. In this case, there's happens to be 5 different plugins that that that exist for it. Whether in the BPS Conformis wrapository or in some other using projects repository. Like UVF, for example, is another project that, uses it, and I believe it's in the other direction where assumes Vpf informants and then runs it against the UVF interpreter and the UVPF, Jit compiler and, and, and execution early. Bye. And I think, like the Rust VPN is another one that uses it and, BPS for Windows is another one that uses it and is one other one. But, anyway,"
  },
  {
    "startTime": "00:32:00",
    "text": "Nice call. Okay. So the verifier is against a project that is, the pre bell verifier, I should say, is a run time agnostic project that's used by windows and other run times. Okay? And this one, the verifier was updated to use conformance groups. You could use the verifier with run times that themselves use different conformance groups at the, you know, the jet level or whatever else. So so both of them were done, off of the spec and nothing but the spec. Right, to say, okay, If both of them do good results and pass with a correct set of instructions, the test cases themselves, then probably the spec was rewritten. At least that's the that's the That's what it's checking anyway. Thanks. Thanks. So here's the status of that report. So VP of Conformis is currently has tests for everything in base 30 and base 64, except for 2 things are missing, and so there was there may be things that are have not been yet been detected as far as, you know, wording or whatever else still missing tests for calling to help her function by BTFID, and it's missing tests for the other, 64 bit and media with source greater than 0. So those are the only gaps per se, all the other ones are fully supported, and the legacy packet instructions are not supported, but they're deprecated so who for the status in the, prevale implementation, and it does the same kind of thing. If a runtime use it, the runtime exposes to the fire the set of performance groups that it supports, And so when the verifier runs, it runs as if those are the only ones that are supposed to be supported, and everything else should be failed and so on. Thanks. So this one is also missing a current implementation status. Just like the previous one, there's a couple of gaps still, at least the first one is already in progress. The"
  },
  {
    "startTime": "00:34:00",
    "text": "Bpf to Bpf calls, that one's already in prod us, the other 2 are as the same as on the previous slide. And so both of those still need to be done, but they're actually simpler to implement too. So able to get done sometime soon, but, I'm sure both of these are open source projects. Anybody can So those are still gaps that need to be done. But again, everything else, below that is already supported and of course, packet is partially supported, but deprecated. So who cares? Probably that one will never be completed because over time, you know, the the front time should say, I just don't support that. So So that means for everything that says support it and with the exceptions of what's called an issues, I'd say I'm pretty confident that the document does a good job and doesn't have, you know, pipos or errors or anything in terms of how those are described and how the instructions are described because there's multiple different implementations off of the spec. everything other than, like, the For a helper function by BTFID and the 64 bed mediates with, source reg than 1 or greater than 0 depending which project we're looking at. So that tells me that, I don't have concerns about getting to the end of working call, but it also tells me that if those are done, before April 7th or April 5th or whatever it is, then, there's so possibility, you might see another, issue raised. So Alright. Going back to the document and said the implementation reports So we defined processes which charter said we needed to for adding instructions and deprecating instructions. And so first, I have the actual text on the screen, which don't expect anybody to read through. I'll highlight things, but then I got an example which might be easier to follow. After the text pay. So the notable things that you'll see is, Conformance groups once they're registered and published, are considered to be immutable because once they're published, then you can have somebody that's implemented off of them claiming conformance and you can add new current performance groups, which don't change existing ones. That RFC does. Right? It's immutable. works like an"
  },
  {
    "startTime": "00:36:05",
    "text": "And so conformance groups can be published in RFCs and it's not surprising the immutability is the same between an RFC and, to confirm its documented in an Rfc. You can create new ones and deprecate old ones. That's perfectly fine. And so we talk about how you can add new instructions over time, via the group's column, and so let's look at an example. C precise. And the example, the the text here is in the document. The example is not maybe that's a question. Would people like to see the example put in the document? Because, It is there for the deprecation case, but not for the addition case. Deprecations were complicated, so maybe you don't need an example of the adding, but I'll, you know, keep that welcome. So let's say you start With this, before adding stuff. And so this is just making everything be, you know, hypothetically, you know, agnostic here. You have a conformance group at the beginning that says it's called example. That same with the Confirmance script doesn't exist. It's an example. And it has 2 instructions in it with 2 opcodes. We call them a and b. And so now you decide you wanna add 2 more instructions, and gosh, it showed him that nice if instructions 34 were in the original example one, because now we've added 2 things that are similar. What do we do? So here's what it would look Just what you're seeing on the screen, is what it looks like in the INA registries itself. Right? The expectation is that there would be one I end a page with 2 subregistries one sub registry on the top of the web page is the set of performance groups and one is the set of instructions, which is the the the long list of all the instructions. Okay. So this is kind of excerpts And so what do you do if you want to add some instructions? Well, after you add it, so you write a document that says at the end state will look like this. Okay, And so in this case, maybe I'll start with the bottom here. We've added 2 new instructions, right, CAD. Right? Their example instructions 3 and 4 and we can't put them in the example Confirm its group because example is immutable. But we can create an example V2. Right? There's nothing special about versioning. I"
  },
  {
    "startTime": "00:38:04",
    "text": "used a string that was different. Right? So in this case, example, B2 is that maybe for for you guys to understand, but it doesn't have to have the letters b or 2 or anything. That's just arbitrary. Right? And then in the conformance group section, you say, example too is a new label that's been created. We have some description that goes associated with it. And it's also permanent but we say that it includes example. So that means that, example B2 includes everything with the example label or everything the example would include, plus anything explicitly tagged as an apple V2. Right. Right. Now if you say you're confirming to example V2, it means you to support all for the instructions in the bottom. Right? 2 of those because they're an example that that example V2 requires 2 of them because they're explicitly an example B2. So the UC includes column is the same as back there when I showed that, say basic 64 includes basics base 32 It's the same kind of definition of includes. Right? You can't claim to the new one unless you have everything in the latter one plus k. Now this plus, you can I haven't talked about the excludes column yet, but this is how includes which is all you need for this example? Okay? Over time, you might be adding 1 new performance group and labeling new instructions with this and taking care of everything else so that includes column to say, this is the new version of Okay? So adding stuff over time is pretty easy. It just means that we have a new label for the new set. I see a question from Eric Klein in chat. And he asks relevant questions. I'm gonna take the question live here. Eric asks a and b, don't get a common example in their group's column, Answer, no, because that's administratively more difficult been just using in the top one that says include. So it's implied but and so the group's column does not have to be dynamically updated just because you do this. Right. Right. When you look at these two tables together, You get the same answer as if you had annotated A and B with example, comma 2."
  },
  {
    "startTime": "00:40:01",
    "text": "But what this is is it means that you only have to touch 3 rows in the entire page instead of consider the case, for example, had a 100 instructions in it. Like, you're gonna add something in the base 32. Right? Right? Would be pretty onerous to the registry, right, as opposed to wanna have one instruction to base 32. Do I have to touch all the plus all the base 32s? No. Okay. So thank you. I see a plus Okay. Thanks, Dave. Jagan, did you have a question on this topic? If you have a question like you can say, like, I'm going to, example, version 3. Right? So then the includes will contain Example 2 are both example, and it comes up to version. Yeah. Good good question. And the answer is the same because example V2 already includes everything in example 1. And so it would be the example be 3. Would have in the includes, it would say example V2. K. And so to answer your question, it includes his recursive. Or transitive transitive closure. Right? So if something includes example b 2, because you can't claim performance, for example, b 2, unless you claim the paint conformist everything that it requires. And so V3 says you gotta be compliant to example V2 plus anything explicitly tag as V3. Okay. This is a design to minimize the total number Thank you very much. roads, you have to update. Which is least administrative work and least opportunity for INA or somebody else to make a typo. Right? So metro. Thank you. Good day. Thanks. Thanks. Okay. Alright. But good questions. Good questions. Alright. So now let's go through the Deprication example. It's marginally more complicated, but now you've got all the ground information, so here's the actual text and so we're gonna walk through an example that's probably more understandable than the text, but the hope is that they match. Okay? So I'll read this first. Deprecating instructions as part of an existing performance group, there's, 2 things that you do. You need to find a new conformance group for the deprecated ones,"
  },
  {
    "startTime": "00:42:02",
    "text": "and you define a new conformance group to supersede the existing ones. I, for the new superseding group, is gonna exclude sorry, include the 1 and exclude the deprecated ones. So let's see an example. Again, this is the case that there's an example in the document itself, and I'm gonna squeeze that same example in the document itself. K. So now let's say you're starting from a case like this, Okay? In this example, you got one group, and it's got 4 instructions. Okay. It's called example. There's 4 instructions on the example group. And we'd later decide that, you know, 12 was good, but 34. Gosh. Those are kind of bad things. We'd like to get rid of 34. K? Such that going forward, there's only a and b, and we'd like to get rid of and D going forward, or at least, you know, deprecating going forward. Right. So what do we do to do that to say? How do we deprecate part of a group without deprecating the entire group. Right. Substating entire group is is easy. Right? There, you just change the status from permanent to historical, right? That's what kind of Suresh was, alluding to before. But here, we only want part of that. Right? Wanna keep so. What do we do? Debt. Document walks through this. Okay. Here's what in the Aina consideration section walks through this. So here's the unsafe. K. So in this case, we create 2 new groups, I, One is called, legacy example, which are the parts of it that we wanna deprecate On the bottom, you can see we've labeled the ones we wanna deprecate with legacy example. But, of course, we haven't replaced anything. We now have 2 groups down there. They were still part of example, but now they're also part of literacy exam. Okay. And so we said those are not historical. And example B2, says it's everything that's in the example, minus the things that are in legacy example. Sorry. So in other words, include first process the includes, and then process the excludes, right, that's your order precedence, right? So you first take Example will be to you include everything that's an example, and then subtract everything that's in legacy that's what you've run your conformance test or or clean support against. K? So in this case, legacy example is more like a negative group. Right?"
  },
  {
    "startTime": "00:44:02",
    "text": "As it's used in in the excludes. Right? You don't claim Conformis to be legacy example. I suppose it could, but there's probably no practical value. This one is optimized for, I don't wanna deprecate the entire thing. I wanna deprecate a small number of instructions. So let's say there was 1 or 2 instructions in base 32, we wanted for Kate. Again, we don't have to touch all of phase 32 We just touch the 1 or 2 that we wanna deprecate. K. So again, there's 2 different deprecation paths. 1 is to deprecate an entire group. And one is to, deprecate a enumerated type of instructions, and they enumerate of instructions is what I'm showing in this Hi. So just a quick question, Dave. So I guess the assumption is that if you're deprecating instructions, you'll always have this sort of empty new conformance group that's just a union of an old group with a legacy group Like, you wouldn't you would never add new instructions or anything like that, I would assume, too. Such a group? Could you put these both together and say example V2 adds 2 instructions from the previous one and also deprecate this, you could if you're doing those at the same time. So let's say you had a case where you found that that example instruction 3 and that example instruction 4 did it the wrong way. And you wanna do the same kind of thing, but do it a different way. You could do those together and say your example V2, and then you'd have Good example, instruction 56 tagged as example V2 that's basically taking the other example in this example and taking the union of those 2 examples and putting them on the same And that'd be like a replacement. I'm gonna replace these 2 with these other 2. Gotcha. Yep. Good bye. Okay. Alright. I wanna go on because that's the main work that was done last time. And so now I wanna talk about current state working group last call started, and so what's come up since that? I'm now done talking about Draftdale 1, and I'm ready to talk about anything that's past draft01. Alright. So the 2"
  },
  {
    "startTime": "00:46:01",
    "text": "Trivial things that were brought up so far during working group last call, only affect the in a consideration section. Both of these are in a consideration the main body of the document, no changes. There were some, you know, changes to the labels at the last minute that were, corrected in the requirement repository before being merged, but, I know, a considerations, section still had an older set of names, and those just have to be fixed to be, to be to be the same. So see in there, if you look, Adam 32, that's supposed to be atomic 32, that's a typo. And the other one, there's a typo in the appendix that was found in those, in the Which is just one op code. This label is base 64, where the body says it B Base 32, and the body is correct. And there's a typo that 32 should be a 64 in the appendix. So, yep, those are trivial to fix in the appendix. So I haven't had a question in the chat. Yeah. Okay. I don't know if you wanna speak up or probably just read it. So I can read it out loud. So Alright. So Darren asks If there are 10 groups, between the latest, and the one being deprecated must all groups after the one being deprecated also be deprecated. I'm not completely sure I understand all the but I would say because you asked the word, you asked it with must, I would say No. You need to do whatever is the simplest administrative way to get to be deprecated And so, really, you want the set of groups to be permanent that somebody would still want to claim conformance to you going forward. It's just what's the best way to accomplish that? So if you got a suggestion on know, feel free. I think another way to say that would be the I don't think every group has an necessarily be derivative of the ones before it. So if you Correct. Cancel one that's 10 groups before, it would only be relevant if there was, like, derivative and the groups between Yeah. Yeah. 6 Yep. But, you know, we're gonna have more than one group. I mean, if you think about the evolution of flight"
  },
  {
    "startTime": "00:48:02",
    "text": "CPU versions in, you know, in Linux and Clang over time. Right? You've gone from CPU equals V1 to V4. Now that we have conformance groups, you could have, you know, example 1 through for over, you know, a 10 year period that that that not be surprising to me. So Okay. I think I have one more slide in Yeah. It sounds split into 2 slides, but one here. Okay. thing. So this one also came off. I posted, this the the the these two slides were in the mail that I sent. I don't know. What was it, like, 12 hours ago? I would say, you know, today or tomorrow, depending on whether your local or Right. Right. So clarification. So these are cases where I don't think anything is broken, but could something be better worded I'm starting to think maybe the answer is yes, but I wanted to ask that. So the first way to ask it is that I think would be helpful to clarify I don't know what the answer is, but the point is whatever the answer is, it would be helpful to have a sentence So here's how to phrase the question. Day. This first came up when reading the text about, you know, call helper function by address. K. So we have, you know, helper function IDs in the in the old form before using VTF ID. Right? So it says call helper function by address. Right? However, the upper end is a 32 bit immediate, right? So you say, well, then the address bits and 32 bits. So this begs the question. Well, there's all kinds of, you know, addresses. And often a VM ISA will say addresses or pointers or whatever are defined as being, you know, 32 bit numbers or define a for a bit number. It sort of finds being up to the up to the CPU. Okay. And so here, the question that would be useful to maybe be more precise about the answer is, Well, since a helper function address clearly fits in the 32 bit IMM, at least as worded right now, this mean I'll address the phrase you've been? Should we say that the answer is up to the runtime, that it's not 32 bit? And so as an example, somebody reading the document right now would, take the example in the bottom of the slide at the beginning. Let's say you have your input register and say R6 contains a context pointer. Right?"
  },
  {
    "startTime": "00:50:01",
    "text": "Now you do an instruction that does a 32 bit move from R6 and R7. K? And so even if you had a 64 bit pointer on some architectures, sixty four bit register on some architectures. You're taking the bottom 32 bits. And now you try to dereference, our I should say this typo there. That should say, dereferencing r7, not r6. Okay. The question is if I now try to dereference r7, is that valid or not? Say, While if it was a 32 bit pointer, then that dereference would be valid. If it's, if it needed to use a full 64 bit, it would not be valid. If it's up to the runtime, or the the the CPU, you know, the architecture underneath, then the answer would be it depends. Right? Now this is All before jit time. This is in the DPF VM. Right now, the document doesn't say. And so is this something that should be clarified? And if so, what's the right document to clarify we say that pointers are 64 pissed? Do we say that they're 32 pissed? Do we say that it depends? Or do we not say, and if and if we say, then which document do we put that This is a question I have with the working group, so Crystal, go ahead. Thanks. So, I think the biggest issue here is that I I suspect it's mostly just a typo because the instruction really is obviously not a call by address if you look how it's used. It's really a call by number, call by ordeal, and the right fix is to just clarify that instead of pretending it's an address which it's not. Yeah. Right? It's just another form of calling by ID. No. Yeah. So if by contrast, if you look at the 64 bit immediate section, right, then you have in the in the in the smallest bullet in here, right? We have things like, map by IDX over Iumandumand their address over IMM, which has text that says this will get the address using a very true bitmap index or using a variable ID. But there's nothing in the document right now that's like a helper function, help her address by IDX, which I think is what you're, suggesting, Krista."
  },
  {
    "startTime": "00:52:07",
    "text": "I I implementation. But, I mean, in in the end, it's really, It's not an address. It's just buy an assigned number kind of like the really old school 1990s Linux a out, shared libraries. Right? We're And we just need to make that clear. And I think anything that tries to where it like like, backwards and figure out what is an address from that is just gonna get us trouble, trouble because it's not. Thanks, Alexis. Go ahead. Yeah. Angri, this is all, historical at this point. So this is clearly, yes, Christophe said that never was an address. It's an indie also a thing doesn't fit since it's not really index. It's more of ID. So call health promotion by I c probably fits the best. So, like, we kinda called it an address because we Because this is how, like, a VM is worth thinking about it. Like, 10 years ago when it was initially implemented, but, like, realistically, address 12. The nonsensical, like, you cannot have, like, by difference between 2 different addresses. So it's more of a, like, hack that was back then. In, really, in some ways, it's a real location. It's Like, it's a that Once the code goes through the verifier, eventually it's got the kernel relocate this ID into proper address and the one is get jitted. The actual address is used. In the colon structure. And just to clarify, folks, I think what you mean is, like, we would did it that way. So that thing would emit a call instruction to, like, a non address. Right? It wasn't It it was it was really just for the compiler to admit their callers"
  },
  {
    "startTime": "00:54:04",
    "text": "it was combination of many different things. Well, to be precise, it was to Not define the whole concept of, relocations at this time. When and against what. So it's like, Back then, it was just like maps, helpers, and the program. Now we have, like, BTF, key funds, BTF AD, etcetera. That's why now we have all we have is this call K Fong by AD, which is this BTFID is the relay using like normal, like, compiler terminology. And here, it was let's hard code some of the IDs. Starting from 1 to mean like certain addresses. And once they go through the verifier, these IDs get converted to address. So call helper by addresses Kinda may be correct depending on the angles you look at. It's a jit. It's an it's an ID that the jit understands, right? It's an ID. Yes. It's an ID, and it is sorted a bit. And, well, for the last year and a half. We've stopped, increasing them. So probably, like, IDs that we have now on the coral. That's it. So there will be, like, no more because a mechanism that has plenty of disadvantages that we, like, realized then Well, they're they're only because of your API, and we cannot remove But, realistically, it's the old way of doing stuff, which is not great. And if you look at how GCC did it, GCC even added a special attribute call it as, Cardinal helper, to like, put this ID instead of address. So it's Works cleaner from, like, GCC perspective. So is all, historical this like, at this point. And, like, answering the other question, is this a valid like, your example, if it was like the reference in our 7, is it valid point of the reference?"
  },
  {
    "startTime": "00:56:00",
    "text": "Dance, it is depends. It depending on what this address is, if it's like a pointer to contact then on any architecture, even, like, 32 bit architecture, when the true 64 bit point get, like, reduce the city too. This instruction 1 would not be a valid point of the reference But if our 6 initially had contained a different kind of pointer to a different, let's say, address space. In this under space, the certitude bit may be a valid answer. Yeah. So I'm gonna repeat back what I've heard so far. Thank you. This been great, great discussion. The first one is the suggestion to change the highlighted weren't addressed to something else, after listening to, unless then I might suggest legacy ID because we already have the other instructions call helper function by BTFID Right? And he said this is kind of old. And so maybe legacy ID wouldn't be improper replacement for that word. Being good. The other way to look at it is just it's another way for for, Jits to have 2 different name spaces of IDs to call functions by. For Linux, it's certainly deprecated. And I think given that we, like, probably won't fill the 32 for BTFIDs, it's probably fine to do either way. Uh-uh. I'm open either way, whatever the working group wants, I'd say, from EVPF for Windows, I would expect EVPF vendors to do the same thing as, as Linux, and that once it has the BTF IV support finish, in the various projects that it needs, then it would be using that instead and not be using the the legacy So if we call them legacy and said that, that would be fine with me. So And then legacy is the right way to go if that's that's the, the idea. Now, I can't speak for, of course, hardware offload cards and stuff. There's any different answer that they'd want there, but, I'm saying, I don't know of any reason to not call it legacy that I've heard so far. But on the other question that I asked about, can we clarify how wide"
  },
  {
    "startTime": "00:58:02",
    "text": "pointers are, I heard, like, Alexis explaining it depends. And so, I'd said, okay. Well, if the answer is it depends, it would be helpful that clarified in some document, and I don't know whether the ISA is the right document or API or the compiler expectations or something else. And so I'd love to have many excess opinions. So what's the right place to clarify that? Because the the question is begged by reading the ISA document. Right? If we say it's left for a different document to answer, that's fine. But if we know an answer and we wanna put it in here, fine too. You guys tell me. I think a business is really, like, ESABI document. That we'll talk about, like, calling convention as well. What's the argument promotion and everything else, including the sizes of pointers. It's like, typically, it's ABI document that talks about sizes. just to And clarify what I was saying that it depends whether it's 60 for or search it a bit. On x86. The void star is not always a byte. Independent which other space you're using on 64 bit intel, it may be 4 bytes. So pointers can be subject to bits even on Intel. So there's no, like, surprise on some special architectures. I think, ARC, you can have 16 bit. You can have 12 bit. And some weird, like, 20 plus bit pointers. So it all depends on, like, other space that pointers appointing too. Yeah. So since this is a new or a different CPU. Right? This is the DPF CPU or a personal CPU. Then we can define the answer here and what do we want to say? Right? So you could say that everything has to be the same. You could say it the pounds, but my point is we should say whatever the answer is. So what I'm hearing you saying, Alexei, is that, saying would best belong in a PSABI document as opposed to in the ISA is that Is that correct?"
  },
  {
    "startTime": "01:00:02",
    "text": "The the real question is, does it even matter, right, because what matters for Like, the EVPIF code generation is how much storage do you need to store the pointer? And that's pretty clearly defined by the register and, and, and, and, and, How many bits of those are valid? I mean, this is in, like, normal processor API that might be important for things like The JVM were other magic interpreted code that once deal a few bits from it. M I suspect, at least right now, the answer is you can never speak a bit from a pointer in your EBPF program period. And it Does not matter how many of the pointer bits actually end up being used by the runtime because you can't use them anyway. Even if we said that, Kristoff, that would be, useful because, an that means like if you're gonna push a register value that contains a pointer onto, you know, into stack, you're gonna consume, 8 bytes on a mid system that uses the base 64. Listen the width of the corner, you're gonna consume 8 bytes because they register as 8 bytes. That's basically what you said. That would be fine to point out. Probably something that in one form or another needs to go into this document. I I like the way that you phrased it, because that could be said in one sentence, so Yeah. Okay. Let me finish up to keep us on time because I have the second part, and this is actually answer half of the next slide. So Oh, go ahead, DeWaxi. Just to clarify. So I agree with Christophe that, we should document that these should not be stolen from the 64 bit the other space, but this is not really ISA. It's not an abstraction set. Like, the number of bits is not what, like, CPUs it's it's it's EBI part. There's like how many, like, page tables, the the hardware CPUs have with this, like, a 4 level page table or 5 level page table that depends how many bits of the virtual others will be valid. And"
  },
  {
    "startTime": "01:02:02",
    "text": "whether, like, clover bits can be stolen for, like, tagging or whether upper bids means this and that. Like, all of this is not feeling and distractions set documents like when when when when it's undocumented, but not in this one, I think. Yes and no. Right. I mean, the Given that we don't even do page tables in EVPF. Of course, it's a little different than a real ISA document that deals with physical and virtual memory and the mapping between the two, which we don't really do because we always operate on Well, It's neither physical nor virtual on a logical address space. But the important bit for the ISA is basically debt. That if you pass an address to load and store instruction or any other instruction that takes addresses just just just Don't mess with it. It's a It's basically a an address is a register sized cookie. Period. Well, it's not a cookie because you do medics on it. Yeah. Okay. Let's let's take this offline and think about it a little harder. strongly I would said if we do put this in an asadoc, this would be like an extension or something, but, Yeah. And Okay. So we're taking it to the list then. Now the the next slide is now this one actually had a technical question. The next one is purely and we've actually answered half of it already. So maybe that there's nothing else to do. So So here's the next one. In the 64 bit immediate instruction section. In the table there, the code editor instruction has a desk type of the words code pointer. Right? Is the only time the entire document that the word pointer appears. K? The legend of it is useful because it says code editor gets the address. There's the word address, like in the previous slide."
  },
  {
    "startTime": "01:04:02",
    "text": "Which we said the previous slide used it incorrectly, but here's the address of the instruction. And a specified relative offset and number of 64 bit instructions. K? I would just point out the editorial point is the term code is not defined other than in the text that I just quoted, which maybe that's a sufficient one. There's actually nothing in the document that says you'd actually ever use a code pointer for something. And that's because there's no instruction that does, but certainly helper functions can. And so that's probably is intentional. And so my own opinion is, that part is fine. Not an issue. Things like jump instructions, which offsets, not code pointer, the call instruction, we just said is irrelevant, And so a reader that sees code pointer and address in a couple places might wonder why do we use 2 terms instead of saying just code address instead of code pointer. Doesn't seem like a big deal to me, and so that's why I didn't really call it out before, but since I was talking about the other issue, it is a little bit related to this one. So I thought I'd call this to should we keep it the way it is, which is fine with me, or should we change the words code pointer to be code crest or something like that, you know, I don't care strongly. We've already said that the more detailed discussion goes in another document, whether a helper functions document or a PSABI or whatever else, but, the highlighted text there, is there anything we had changed? You should make it the highlighted text there's no consensus, then the answer is. Leave it the way it is. And I just wanna highlight this because it's relevant to the previous slide too. So That was the other part of the email that I sent, what, 12 hours ago or so. If I don't hear anything, I'm just gonna say the way it is, but if somebody thinks it would be helpful, to change one word someplace, then that's easy. So Yeah. So, I mean, it's pretty obvious that we should not use trade term that's not defined anywhere. And Alex, they may correct me, but I think that simple answer is it's actually an address And I'm not even sure it should be. Code address instead of just the address. It's an address pointing to the vote. Yeah. Correct. Correct."
  },
  {
    "startTime": "01:06:04",
    "text": "Yeah. Because the the line that I didn't show, there's also a, data pointer in a juke 1. And if we change the word pointer on 1, then we probably change the other one to be a data address and a code address. If we did that I mean, it's It's an address, and we can noodle on the details if we wanna refine term code address, say address off the code or something around that, but it should go in that it's, yeah, I think address seems like the least Yeah. Ambiguous. Yeah. Okay. Well, I can generate a patch for that, and people can see whether they like that patch or not, but it's pretty simply be changing two words in the document from web pointer to address. So just Alright. Alright. Alright. Wanna spend too much time on it because this one is in the really not that important kind of category compared some of their technical ones, like the one that we just walked through. So, Alright. This is my last slide on the main ISA. So any other comments on the main ISA before we move on, Yeah. Thanks, Dave. So there's, like, 2 things. Like, one of them is, like, just my point. Like, one of the things I figured out is the the provisional registration flows not defined at all in the document. I'll file a issue on that it's not clear what happens with the provisional registration. Does it time out? Is it like something that needs to get refreshed. How does it come out to a permanent? It probably needs to get written down somewhere, but I will file an issue after the meeting. Okay. Thank you. And the second thing is, like, you know, we would love some more reviews. So, like, you know, please, if you are willing to review the document, put your hand up here, or, like, in a center note, you'd love to see more reviews here. Thanks, Kristoff. Okay. Sounds Darren, let the notes indicate good. Christophe volunteered to do this. Thank you. Yeah. Thanks. Thank you. So, Dave, yeah, go ahead, please. I think k. Ready for the next presentation then."
  },
  {
    "startTime": "01:08:01",
    "text": "Yep. I think you can take it away with Alex. Okay. So this was a a a the thread that was going on in the mailing list, and I thought I just give some visibility here to bring everybody else up to speed are we talking about? How can I even follow this thing? And here's what's, So here's the current status of things and and so on. So I'm gonna try to give a a summary of this for the and at least according to my understanding, and maybe there's other people in there that have more information to hide it by what I put in here, but let's get us on the same page here. So Alright. So some background, we just saw in the other document that there's a call instruction that's only defined for k, meaning the bit is 0, which is defined as call helper function by address, Well, well, by legacy ID or that ID is in the, immediate. At at@at but there's not defined as what happens if the exit is 1. K? Which would be maybe call helper function by legacy ID a register value. Okay. That's kind of where I'm going with this. The issue is that this call x was never supported by Linux, It was never part of the ISA, so it's never been documented. That said, Clang generates it. And GCC generates it when you use, that 00 or, with Clang or MXBPF with GCC. And so it generates these things, and so is there something we should do about that? Turns out there is interest from other projects and consuming them because compilers actually generate them. I think we could if we care, we can go into why, but that's not relevant to the question as to why would somebody wanna consume it? But the point is are sure generated right now, and should we do something about document it goes? It documented only in Clang and GCC talks? Is it documented ETF? Is it professional? What do we do? That's what that's that's what this, issue or presentation is about. K. This is not saying we should do it in the ISA document itself. So here's the simplest examples. K? At least a simple example. So you have some source code, and this is in C, right? You have a function"
  },
  {
    "startTime": "01:10:03",
    "text": "that's a BPS program, and all it does is it calls to help her function with no arguments, and it returns, whatever returns. Okay. So it's a very simple EVP program. So if you compile it with playing using 1 or 2, you get following a pair of byte codes. Byte byte quit operations. Okay. The first instruction says 85, which is that call legacy ID by immediate and an immediate you have the value 14, and that's the hex 0E, and that's just shown here in, not a little Indian machine. Okay? So it's calling 14 being that ID that Kristoff was mentioning. It's not address per se. It's a legacy ID that's used to get the address at, you know, Jit time or whatever. Okay. So it's a 14 that's encoded in there, and then there's an exit because it returns. Okay. That's great. If you take the same program and you compile it with 0, and the the the, instructions instead look like the bottom k? It's 4 instructions, and it has this thing that, playing shows and so does GCC as call x. Type, type, type, Now This has been around for ages, and it does this. State, state and you can see if you look at the actual, byte instructions, the value for there's no there's no 0E in there. She says, well, where did it put that? So let me walk you through where it actually puts k. How that works. It's kind of this is your, tutorial for one of this new here. Even I had to do some research to figure out exactly how this works and what I found. And as far as I know, this is common between GCC and point. So alright. So the Bpf code that's compiled, the stick stuck into an l file, if we look at that l file, there's number of sections. Okay. So there's a dot data section, and if you're looking for where does it put 14, well, that's in the data section, right? So the data section here contains, that's the full contents to the data section in the previous program, and offset 0, there is that value of 14. So it's sitting there in the data So then how is that used in the program? K? Well, there's a section that tells you how to do relocations so that the relocation section for the dot tech section, the program is."
  },
  {
    "startTime": "01:12:01",
    "text": "Has a relocation record that says at, offset 0 in the text, right, to a the four bit relocation and, replace it with the pointer to the dot data section. That's how to read the line at the bottom. Right? So what it does is the relocation says that, offset 0 in the text section, which is what that where the first instruction is, and I'll I'll I'll kind of give a walk through on the next slide. It's gonna take that and replace it with the actual 64 bit address the death data section. Okay. So that's that's what the real text section says. So, Going back to that 4 instruction program, okay, that was generated by Klein or GCC. Here is what it looks like. Here's the first instruction. And you can see the, immediate of the the 64 bit immediate there. It's all zeros. Okay. The relocation record says to replace the highlighted part or the address of the data section. K. So then at the end of this one, then r 1, will contain the address of the data section. So it's a a pointer into the data section at the beginning of k? The next instructions says the deep reference the first sixty 4 bits and replace it and stick it in in in our one. So at the end of instruction 2, R1 now holds the contents to the dot data section to offset 0, meaning our to r 1 and now holds the value 14 k? The next instructions says call x the value of R1 to get their legacy ID So this one looks in R1 and says, well, the value is 14, and so I'm gonna do this do exactly the same thing as I would have done if this was call with 14 is the immediate. Okay? Is why when you turn on optimization, it takes this code here and it optimizes it into a call 14th. K? As few of Fred, as far as Clang and chief CEO of concern, these programs are cemented the equivalent This one is with and with optimization without optimization. It's just where is the legacy ID place? Is it in the data section, or is it in the radius directly in the in the in the instructions? K? This is what Clang and GCC do today and have done for a long time"
  },
  {
    "startTime": "01:14:04",
    "text": "I don't know what it first came in, but it's been there since long before playing 11. If don't know what the first version was. Thanks. So question then, The question then is, Should we document this? In any place other than, you know, claim docs or GCC docs. So I saw what else you posted in. I'm gonna keep going because I did this by running these using the version of Clang that was I think it was Clang eleven that I ran locally, but I think I got 2 different versions of playing, and so point is some persons are playing do this with cones here with, 0. And they vary by which version of playing or whatever else. So I'm not exactly sure, but I can tell you that many versions of claim does this on different architectures. I've done this multiple times with different powers. So So, I think the conclusion of the thread was that it does not recruvysate the answer, it doesn't log in the ISA document. K. So right now, this is tagged as a possible extension should it be an extension? Should it be left for a clang or TCC docs? Is kind of where discussion could go. There's one wrinkle, which is that older versions of slang, put the register number then one would go on immediate instead of into the Desk reg field. That's fixed in Clang Nineteen. And so Clang 19 and GCC do the same thing of using the test reg for it. And so, one proposal would be to say, well, everything that uses a non 0 INM field with the soft code is being deprecated we know some compilers generate them, but you shouldn't do this. We could handle that similar to what we did and just say, don't you, don't reserve, don't use those byte codes for something else. Because it will conflict with some legacy use, but don't do that going forward. That would be one way that we could possibly do And then would be helpful to clarify things like whether the following,"
  },
  {
    "startTime": "01:16:03",
    "text": "is legal or not, and I don't really care about the answer because I don't think there's any code that would do this unless you were trying to construct a test case. Right. Right. Right. You could construct a test case, but using that code editor instruction we talked about before, to say, get a code editor in our 1, And I'll call r 1. Colleagues with our what. Once we redefined call to say it's a legacy ID, not an address, I believe that this is automatically answered, and that question goes away. So the discussion we had earlier in the meeting answers and makes that question go away. So it still says, what do we do with this call x use that's used by Clang and GCC and has been for some What do we do with there. Now you are all up to speed on the thread that was going on. So the question is, what, if anything, do we want to do about this in the context of the IETF or in INA registrations. Open discussion because I I I I I'm not sure what the answer is. But but but This is the time to discuss. Okay. It looks like I want that is. Yeah. Go for it. I'm clicking clicking the hand up button. Well, first of all, it's, I guess the question to you. So it sounds like your main, Dave, like, motivation to somehow support Compiling with dash 0. If I understand correctly, So, because, like, it looks like in this whole, like, slide deck, there are, like, so many things that probably need to be like, divided in concur. Otherwise, it's, like, too many things all at once. So starting with a 0. So, like, DPF code generally like, what you found was this, like, colleagues and Azure 0, the optimization that come some compilers don't do, like GCC, It's, it is indeed the problem with decimal 0, but there are, like, bunch of other things. So, like, And taking X86, for example, or arm Like, if you compile the kernel in general, like, without the NPPF, just kernel"
  },
  {
    "startTime": "01:18:02",
    "text": "you compile this dash with 0, it will compile, but it will not worth like, it won't boot. Like, kernel by itself is not like boy king was dash for 0. So is not working with this. And the main reason is, call stack, call, size of the stack, explosion when you compile anything 0. Same with Vpf. Like, if you compile with the 0, even let's say we're hypothetically, like, make it somehow work I, this collection or whatever or whatnot, whatever is solution. Like, it's not gonna help BPS programs to be verifiable or usable with decimal 0 0. This is just like a territory that's like, not solvable, I think. Like, Jordan was not solving it. And we cannot really, like, help with, like, anything during DPS space. Then, in your example here on the slide, you're saying this is John Gitkharan, the APAD goal for team. So this is probably because you're using all definition of this, helper. So the link I just posted in an ETF chat shows that Clank, all versions of client, even this dash is 0. They actually generate cold 14 as normal. Because the way that this helper should be defined. This was a extra cost modifier. If there is a cost modifier, come clang does the right thing. GCC, like, has to do this MXBP thingy, well, it's it's up to them. Like, what to what to do with this? So that's, like, second part. The third is what is the address Like, since we just agreed, to use to, like, renamed this call helper by others to call helper by legacy AD. In this case, for the call x. So this will not the AG. This, on the slide, they get slide, instead too that doing the lot, it's not loading. Any helper ID, this is actually the full 64 bit load. So of the instruction 2, or one has the full address."
  },
  {
    "startTime": "01:20:03",
    "text": "So that's where it's becoming a different kind of instruction R1 is actual full address and indirect call will be indirect call by true absolute address. And it actually matches to what real architectures do. In, normal, hardware CPUs. There are only 2 flavors of calls. Either it's a relative call by, like, PC relative plus offset or indirect call by absolute address. And the same applies to jump instructions, jump instructions, inside the relative jam by pcrelative or indirect indirect jam absolute address. So when we support collex, colleagues are 1, and the instruction number 3 in here, this are 1 will mean the full 64 bit address most likely, but I would not document any of the stuff, not yet yet because this address also, like, as soon as I say, it's address, the question is what other space this address point to is this address is actually the full journal address, or this is actually the address of the VPR program. What this indirect call is jump into. Is it indirectly calling another VVR program? A function assigned with your program and directly calling the kernel function. They potentially are in different address spaces. So like, it's, I think, like, way too early to recommend you know, but just because, like, we don't know what would be the real answer once we get to implement this all. And what compilers currently do is more or less, like, best guess. Like, Liam was doing one thing for the last 10 years. And, a couple months ago, we changed it from human to destination registry. Just this is just experimental stuff. Yeah. So, Kristoff speaking, I agreed a lot with Alexey. Right? I mean, if you look at how the EVPF ISO works and you have the immediate versus register bit It's"
  },
  {
    "startTime": "01:22:04",
    "text": "in general, only supposed to mean if you get the same value from the immediate encoding or register, which means you're If the compiler had actually followed that, you would not have an address in here, but you would have the magic number 14 in the register and call that So actually think both compilers are Yeah. It's a con. I doing fundamentally the wrong thing here. Which doesn't mean like a real indirect call that has an address to be specified interest in your could be useful in the future. But it should not be encoded as a call x. Well, I, and I think that's that's the Lexi's point with const, right? Like, it is actually a constant ID. And it does do the right thing if it realizes it's constant. But it it's the the compilers are doing something really strange there. And I don't think we should legitimize this. I mean, we might have to put in a warning in there that this up code has been used incorrectly in, in capital ways by various compilers, but trying to legitimize 1 of the 2 behaviors given that they're both actually wrong Doesn't seem good, which brings me back today's first slide or I'm not sure. Maybe you just said it and did, if it's like, but thank you. Mentioned that you actually had uses for that behavior in some projects. Prevail an EDPF window. So potentially, and I can talk about that if it's relevant, but I think that's what Alexia was responding And so, I I was gonna take a second and repeat back, but I what I, taken away from the feedback so far to see if I've, got stuff write in my notes because if I have it all right, then it could be that the right conclusion is what you just said, Kristoff, which is to, document the opcodes as, used then the same way that we do for the legacy packet ones, we don't say what they do. They're just saying, you know, danger here. Don't use these. Right?"
  },
  {
    "startTime": "01:24:01",
    "text": "And and then the system is deprecated bot code. That might be the right takeaway. Which are luckily and shouldn't be used, but they're actually reasonably well defined. Which I not in the ISA. The ISA the ISA specifically does not define them. It removes all mention of what they do. And so as far as the ISA is concerned, they are undefined. As far as Linux, it's concerned they're defined, but that's a Linux thing. It's there. At the ISA level, they are, have undefined behavior. Don't use No. I said, where I was getting to was to say, if we believe this is the discussion we had in presentation about the, the word legacy ID if we believe that the use of legacy IDs because you should just be using VTFIDs anyway. Right? That's the same rationale, but call x with a legacy ID should also be and if it's deprecated, then you don't need to define the behavior. Right? And so that's kind of where I'm using tuition just a second. I mean, call by ID is a very heavily used right now, and at least Linux tries to a wide adding more of it To be honest, at least for the one use as we play 1, the EVPF standard for an NVMe for some use cases, I suspect we'd actually be better off using them in a tiny welcome train environment, but that's when I you pivot the question, it's something don't think is legacy that because there's, I think, the the discussion has still be wide open and we could have a behavior. Call by call by ETFID. In a with, with the X bit. That is unused and undefined, and so you could define to do whatever you want because BTF ID is the way going forward calling by BTF ID right now, we have a way of doing that within the immediate wanna do that with a register? If so, how should that work? Big open question, right? But there's no legacy there to do it. So How are you gonna know questions? They're both good questions. And probably have different answers. Uh-huh. The thing is called by ID using"
  },
  {
    "startTime": "01:26:02",
    "text": "immediate is very heavily right used right now Linux as sort of the main EBPF Environment, has deprecated the use of it in new program types or maybe even for the extension of existing ones, Alexey will after you get to that. So that's one thing, but it's been very well defined, very heavily used which can't be set for call by, I be in register ish. Correct. So they're I I don't think they should be handled the same way, and I think My personal opinion for some of the use cases is actually the call by e is useful for certain environments that are very resource constrained and limited. That So I would not argue for deprecating it. Up here to people that are that have even more skin in the game. Okay. So I'm gonna repeat back what I think Alexa's points were to make sure I captured them We have 3 main points. The first one was that if you use, dash 0, then the, experience has been that you can't expect it to work because of things like Stack Exposure. So you can't really use dash 0 expect it to work very well. The second point was, about, constant IDs, even with, 0, the that, Clang will do the right thing. And so I can see what I was doing differently in my testing or whatever, but there is a way to get language 0s with 0 to, to to use the call instruction, And so great information. I will probably use that And so I will try to figure out how to get that to work, and so thank you for pointing that out. And then the last the the third one that Lexi pointed out was, the discussion around, maybe When is the 14 replaced with an actual address? Right? And I think there was maybe an assumption or an explanation of how it works, but it's jitted or whatever."
  },
  {
    "startTime": "01:28:04",
    "text": "If somebody was doing it in a DPS interpreter, and I'm thinking about, like, the UVF project that has an interpreter that is, the VP of Conformis sweet to test the interpreter there. Not that anybody should use an interpreter, but if somebody does, what's the right hey, if you're there, I think there it actually does have the value of 14, like Kristoff said, but the answer might be different depending on whether it's jit it or whatever else. I don't know. And so I think that was a lot too Last point is it might not be a 14 in some cases. It might be an actual address that's different. They get different behavior. So hopefully I've captured the three points correctly. If I didn't, please, you know, correct my understanding. So Yeah. Old connect. In the just to poll. Clarify. I'm not saying that working trying to make the show 0 work is pointless. This It can be useful, but It's just like scratching the surface, like, once you scratch the surface. this this colleagues suggest, like, Like, I'm looking to discussion the surface. Like, once you get deeper, any big programs, you will find all sorts of other issues that and it's not like people didn't try. Like, it was an hour, like, to do list for a while. Because it was DECO 2, the bug information is more or less useless, right, as normal. So that's why in parallel with trying to do this kind of Vesho G. That still, like, optimize this a little bit, but the back information is good enough that that that resorts all the variables, and you can see. So this is actually not, that's specific to Vpf, but, like, are the projects on full normal CPUs would like to see this dash og like, working, and it's it's kind of the orthogonal effort to all but then, back to, colleagues. So my suggestion is not to listed deprecated because, like, it never existed. It never worked"
  },
  {
    "startTime": "01:30:02",
    "text": "in the kernel. So there is nothing really to deprecate. Also, I wouldn't market has reserved yet. The, Campal is generated just because, like, we who else we can still change it. Right? And most likely, once we go through the actual implementation of it and supporting the fire jits everything else, it might change. The encoderic might change. It might might and might not. Right? So I don't see kind of the point of going through the effort of, aiding into, I say, right now, with whatever conformance group, it feels to me and just we'll create a churn. Right? So we have very low, at this point, like, confidence that it will stay the way the way the compiler is generated now. So that's why, like, I just don't See aid any, like, anything to the dog that we're, like, doing at this point. But right now, there are people who are working on adding in drag jumps and indirect call. To OVM to the verifier to the kernel. So eventually maybe, like, 6 months from now, we will, like, come back with the actual prototype that will do, like, real inter calls. That will, like, do the right thing. So at this point, that would be the time to discuss the like, encoding and what it means, what it means, what it means, what it means, Uh-huh. Okay. We we don't have much time left. I wanna that we have time at the end, for the last presentation, but I also just wanna say that for the dash 0 thing, Yeah. I mean, to me, they're it's a completely separate issue. Like, I think Trying to support dash a 0 is a is a good idea. It's useful. But, but if, you know, the, the, the fact remains that that it's a, it's a static. Sorry. It's a constant address, right? Like, it's a const ID, the fact that the compiler happens to emit a call because it doesn't happen to realize that it's constant is feels very, like, circumstantial. I just my my personal opinion is, you know, I I don't think they necessarily need to be coupled as as like goals"
  },
  {
    "startTime": "01:32:00",
    "text": "for dash 00. And I mean, the other this might be a question for Dave. know of Do we any Like, She had run time and wiremen. That actually handles the pillars generating in a weird way. I don't know offhand of any that already do. I've heard of potential reasons why they might in the future, but I think Alexei was responding to maybe points that they will run into if they tried and So they might not actually succeed why I don't I don't in doing it. Right? And so, yeah, so that's I I I wouldn't take it as a as a yes right now, so that's why I'm finding the presentation here. That is true. Out to the working group, I think the right way to do it is to not much deprecated, but to literally put in a footnote never implemented, but generated in I don't even know if you need to do that. We can just, like, yeah, But, you know, I I missed it. Yeah. I, I guess the word interest really does mean interest. It doesn't mean that anybody is at formal support for it, which to me You're I agree with yourself. Yeah. That it's correct. and just to respond to Kristoff, it could be that right now, the footnote you're talking about doesn't need to be in any IITF document. That could be a footnote in, say, the, in, say, a playing notes, file in Linux or in a webpage associated with GCC or a webpage with llvm.org or whatever. It doesn't have to be in life. You have to ask them to do that for That's fine. Yeah. I can send a patch for that. That's fine. Alright. Thank you Thank you, Dave. Thanks. Is there anything else you wanted to, like, you have the path forward for that? Which is to do nothing on the ISA document. Right? This Correct. The whole point of it. We'd already decided there was no attached I was in a different presentation, right? This is not for the ISA document. This is for some other document, which may or may not even be in the IETF, unclear, right, maybe it's a claim, the you know, help document or maybe it's a GCC help document. Maybe it's"
  },
  {
    "startTime": "01:34:01",
    "text": "maybe it is in the IETF. I don't know. A lot I hear Alexis and Kristoff saying is that 6 months from now, there may be enough to actually have an IETF document before Right? That's what I'm hearing is the is the discussions Yep. A good day. Thank you. I think Melanie Archin may whoever wants to percent. Like, are you on the on-site tool by any chance, or if you want control otherwise, normally, I can You can say next. It's it's either whatever is easier for you. Okay? But it just is a little no for your time concerns. Still got almost an hour. Drops. Oh, we have, like, 25 minutes. No. We've been here for an hour a half. It's 1105. It's sat on a half an hour butter. Time flies were Yeah. It's a lot of fun. Yeah. Okay. So I I'm Delaney Elkins with inside products. And, we have 2 young men with us today. N I from NITK, sir ethical. And, they are 4th year undergraduate students. And, they have done the bulk of the work. I am just taking credit And, we've been working together for 2 years. And so Here they are. Yeah. Hi, everyone. I'm. So, we have done the implementation of PDM using EVPF. Your premium is a an ipv6 extension header. So, why we chose EPPF for, Action Hatter Implementation over kernel implementation. So, the reason is, it takes much less time to develop using EBPF and, wireless maintenance. Also, the portability is pretty, attractive to, implement the extension header. Like, we can, implement"
  },
  {
    "startTime": "01:36:02",
    "text": "in EBPF, and we can port it across different kernel versions. Without much problems. And the BPA verifier also ensures say for implementation for us, Also, the accuracy of timestamp is relate to a period where we have to capture the time stamp of the packet when it arrives. So, wire arrival time would be more accurate in in something like PC or XTP. Junmai. Yeah. You can look at that one. It's really easy. Yeah. So, or yvpfoverraw sockets So, yeah, so, we don't have to write extra code we just have to add extension header to a fully crafted packet Now and we don't need to exit. We don't need to modify existing user space applications, because, the packet is fully crafted by the kernel next Yeah. Coming to implementation of, PDM using TCBP. So, PDM is performance and diagnostic metrics. It is described in RFC 8 to 50. It's a destination options header. It it is used to measure packet processing and network delays. So, the reason we chose, TCP for this is that we can attach to both ingress and ingress often interface, there is no egress option for XDP as of yet. So we used TCP for this. So we used a VP of helper the PPS help us to use were, VP of SKB, adjust room to make space for the packet and then BPSSKP load data and BPS SKB, store data. So store bytes and load bytes. So, it is easier to do packet mangling in TCDPF than XTP. So, we kind of chose TC for this. Also, the ETPF maps and"
  },
  {
    "startTime": "01:38:00",
    "text": "we, since we need to use in both ingress and ingress and we need to be able to data from the EVF Maps, we have to do object pinning. And we store the 5 triple state for, every single packet and Yeah. So, TCTP have provided a nice interface for us to, be able to implement the extension header Yeah. Yeah. So we wanted to see how this TCBP program would perform against a kind of implementation So we, tested for 3 things. CPUcycles, network throughput, and packet processing latency. CPU cycles, we wanted to compared with the the kernel 1. So we used, iPOS 3 to generate to simulate, traffic. Test bed setup was, 2 VMs on the same physical host. And, both of configurations, it goes in 16 GB RAM each. And, We use Perth to, know, get the performance of Ipus 3, which we're using to simulate the network traffic. And then for network throughput, we just directly got the results of 553 without running any as such. And, for packet processing latency, we used F Trace. So we use it on, devqxmid because we couldn't directly get the, you know, latency for that particular EBP program run. And this deputy estimate was for the egress program, and then, NetF received X KB was for the ingress program. And, compared that with a kernel one where we could directly get it for the function itself. Sorry. Just that. So when you say compiled into the kernel, do you mean, like, compiled directly into VM Linux instead of compiling a VPF program. You mean like the for the kernel implementation, Yeah. Like like, yeah, you compiled it directly into into the kernel and reason I'm asking this is because VPN runs in kernel space, it's like Yeah. Yeah. Okay. Yes. So we compiled it directly into the kernel. Yeah. Okay. Glad if I Thanks."
  },
  {
    "startTime": "01:40:00",
    "text": "Yes. Next slide. Yeah. So these are the results for CPU Cycles. We the testing that we did was, IPF simulating traffic for 5 minutes. Then we ran this thirty times. And this were the results that we got out of it. So we see that, you know, ABF is taking considerable Lee, you know, Morris, CPU clock cycles as compared to the kernel 1. We also managed to get, call stack information and then make a flame graph out of it. So this is not statistically relevant, but we roughly found that the main, you know, best the ones that were using CPUcycles the most was MEM CPO operations and then Vpf, map reads and writes untaching. Photos. Right. And we were also using, Bpf k time get an s, which was quite which wasn't taking up any, cycles as such. Yep. We can go next. Just, comment on the statistical you're trying to do, like, more sampling to kind of see like, you you're changing the, standard deviation or not, like, to because, like, the more you sample, right, you can probably get a better air bone on the thing, like, Right. So for this test that we have put it up here, we'll ran, for 5 minutes of simulated traffic using IPer. Thirty times. But for the call stack information, the call stack would take the data that we got was quite huge. So we couldn't run it thirty times. So we ran it quite less, and, I don't think we can conclude much about it. But generally speaking, maybe maybe maybe maybe maybe maybe maybe maybe maybe for network throughput, we see that, you know, without PDM, that is without any sort of kind of compilation or ABF. We see, you know, we get a higher bandwidth, throughput compared to, you know, adding an extension headed, that would be expected because we are"
  },
  {
    "startTime": "01:42:01",
    "text": "forming additional operations. While adding it. For the kernel implementation, we see a slight decrease and then for EVPF, it is you know, bit more of a decrease, but I would say it's overall not that duplicative. Compared to the benefits that we have using EBPF for a running color code. Or modifying current state. Yeah. Next slide. For packet processing latency, the premium kernel implementation. That's for the egress function call of in the kernel to add the extension header itself. And, that compared with so we measured devqxmid with the EPPF program attached. And, we also measured it without the EBPF program attached to the hook. So, we figured out it was devqxmid through the call stack information And, that is for EBP of Egress and, hence, to get the actual you know, latency of the EBP program. We just have to subtract the boat with and without. And we get around 1.28 microseconds, compared that with point 7 of the kernel, We see that it's slightly more, but not, you know, extreme And, we also have the same for the EPPF ingress, which Couldn't really combine that with the kernel, but that is point 5 microseconds in itself. In ingress, we just read the packet fields. And in egress, we actually, adjust zoom. Okay. Yeah, this is some future work that we are planning. One thing is to optimize, the EVPF program itself. To find out, you know, how well we can actually perform compared to the kernel implementation that we did. And, like, the benefits of EBPF is quite huge, and we would like to see, how well it would actually do."
  },
  {
    "startTime": "01:44:00",
    "text": "Maybe we could handle, memory differently. Maybe we could do, less BPF SKB rights, that is something to be seen. We also wanted to see, you know, we've tested this in a simple consumer grade 2 VM setup. We also wanted to see how it would do in high performance environment, And then, we would also like to see how well this, is flexible to implement other extension headers as such an eBPF. Also to try different, methods of air. Finding performance overheads of ebpf programs. Maybe we could also, in the future, collect, cash hits and cash misses. And other stuff. It's That's about it for, the presentation. If anybody has any thoughts or questions. Thanks, Samog. And, thanks, Sheena. So, Do you have appointed the quote that you can share on the list? That'll be cool if you have a put it somewhere like, you know, that'll be good people can take a look at it because if you're asking for, like, you know, is there something better we can do? Maybe it'll be good to share it and see. Right. So we you know, we have not yet made it up into us, we plan on doing so with a suitable license, we'll inform that. This is this is awesome work. Can you guys share what types of pain points you hit with VTF and where you think, like, we improve some sharp edges to make it easier to work with. That was perfect. Okay. Yeah. So, I mean, a current pinpoint in DC at least is it's after everything. So we have to ensure that we don't increase the packet over the MTU. And, there is no way that we can actually, you know, add extension headers if we are go we're gonna go over MTU. There's no way to split the packet there at that level. That was one pain point, is"
  },
  {
    "startTime": "01:46:00",
    "text": "not like it's mostly about, like, other pain points would mostly be about approachability. The documentation is really good. And, it's actually amazing. And we found it easy to follow through. Yes. Alex is laughing, but he's Nice. That's great to And laughing. hear. Yeah. Yeah. I don't know why I'm laughing along with it. No. That's that's great to hear because a lot of the time we actually peep people sent in to ask for more documentation. So It's good to hear. We've been trying. So it's it's and Rad Hat's been submitting a lot of patches, so it's gotten the, yeah, the problem, like helper function documentation is great. But to debug some verifier errors, that, you know, it gets the instructions and everything. And it's quite hard to understand this. Yeah. Yeah. Great. Okay. Last call. So thank you very much, and thanks for coming actually doing it and then coming and telling us about it. So, like, really appreciate, like, you know, hearing feedback from like people who play with this stuff. So, Tom, thanks a lot. Thank you. well. And welcome to your first aid here as Thank you. Is it booking? Thank you, for doing all of these experiments and such that shared the code like, without seeing a code, it's hard to, like, give any suggestions. And, consider other forms, like, beyond the ATF, like, what you just described? Like, it would be I would say a great fit for, Linux plumbers, like, an African tracking or VPF track, this kind of the talks that people typically give there. And so if you have once you have, okay, code all open source, Yeah. And cutters you to, like, present there as well. Okay. Yeah. Thank you. Here. Yep. We're looking Alright. Thank you, guys."
  },
  {
    "startTime": "01:48:03",
    "text": "Thank you. That concludes like our regularly do agenda. So if anybody wants to sing, please come over, but like it. Just kidding. Don't. Uh-uh. So thank you very much, and, see you again, like, in next meeting and, like, you know, please be active on the list. Thank you. Yeah. you. Thank You were mentioning you guys, Yeah. James. You know, many years one just to get Alright."
  }
]
