[
  {
    "startTime": "00:01:16",
    "text": "Hannes? I would say Do you remember when the tool had a Make something. Yep. Display. you. Oh, okay. the chair slides. So if you want to switch to stop sharing, it makes someone Yep. that would be great."
  },
  {
    "startTime": "00:02:23",
    "text": "Hannes? Like, how do I advance the slides in the presentation? Do you have a I have any USB C. which I have in my room. I didn't click the room here. time. weird 8 Oh, okay. How did you get to that screen? window. I just clicked presentation view. Alright. Alright. Let's get started. Can I get my speaker? Welcome to the Cose meeting, we have 2 hours. I apparently failed to type because a is my session title, but that's where we are. Eva, my cochair is with us, note well, the note well,"
  },
  {
    "startTime": "00:04:02",
    "text": "if you're going to contribute content, be prepared for us to use it or not. note really well. These are all available as part of the both materials here as well as general material for the whole IT meeting, It's requested that if you're going to Enter the queue to raise a question. You do so via the app either on your phone laptop, please do not have video or audio on there unless you're actually speaking, to conserve bandwidth. And if you're presenting remotely a headset is encouraged. So the general agenda, you must know about or you wouldn't have found this trim. some of the meta material is at the presentation page. The first thing we need to make progress is for for a person or a cohort of persons to volunteer to take notes, I expect we will have substantive discussions Hannah raises his hand, although I know Hanas is a sometimes presenter. So we need somebody to tag team with Haunas. It's a collaborative editing tool which is easy to use. we need a second willing participant to help us know what we decided and didn't."
  },
  {
    "startTime": "00:06:00",
    "text": "John is walking away. Let's see. Life, could I Barbara, your attention, particularly when Hanus is press presenting to take minutes I'll I'll log in Okay. Let the minutes reflect that haunt us and life has agreed to do it, but any of you are free to chime in, It's an open link there in the meeting materials. So we have a full agenda again, although not as full as back one way only had an hour, we have 12 different presentation sessions during the 2 hours So I will be somewhat ruthless with the clock so as to be fair with the people who may come after you, This is the 2nd hour We have made some progress on documents since we've last met our heroes. the AES, CTR, and CPC is in the RFC editor queue. So that will emerge in RFC at some point in the hopefully not too distant future. a draft that I'm I'm an author of, and so EVOS is gonna have to be the one to decide this. but EVO believes that's ready for a shepherd bright up. if anybody is eager to do that, please talk to EVO and volunteer to do the shepherd right up. The shepherd write up basically means you go down a checklist"
  },
  {
    "startTime": "00:08:04",
    "text": "and answer a bunch of stock questions like does there appear to be consensus are there implementations and what have you. Mike Prorock, Did you join the queue? Oh oh, you're volunteering? Thank you, EVO. Let it be noted and scribes let it be noted that Mike Prorock is willing to take a stab at doing a shepherd write up. Thank you, Mike. And with that, that is all of the chairs slides and time unless anybody wants to join the queue, We will go on to the next presentation, which is the first quantum drafts. And, honest, come help me again. I I can never find the tools. the buttons. Okay. Stop share. preloaded, There yes. That's it, Share. Alright. You're my you're my hero. Perfect. Thanks so much, Mike and Hannes. Today, we're gonna talk about 3 Is the mic working? Maybe Possibly. There's switch Yeah. How about now? The microphone goes very well. k. yes, no, maybe. The microphone works very well. The room audio apparently does not work well. Ah, well, I can talk really loudly if that helps"
  },
  {
    "startTime": "00:10:00",
    "text": "people in the room here maybe, Alright. Cool. I'm good with that. I actually prefer that. Yeah. So today, Mike Paroc here today, we're gonna talk about 3 draft. these are all signing mechanisms that are postquantum safe. So it's dilithium Falcon, and Sphinx Plus. So next slide, please. coming, coming I think we're all familiar with this stuff at this point. since we've had a couple of ITFs discussing exactly this slide with basically no changes, but just in case you're not, please do get on the nest website. That's probably a good starting point. One of the things that has changed, can we actually include that in the appendix to this deck as well is that now with the p quiffer pewquip or whatever we're calling it. But, basically, the post quantum engineering nerds here and other cryptography folks. actually do have a post quantum for engineers that's a really good primer on the stuff. So if you're not familiar or you're looking at some of the differences Like, we've seen confusion on the list in the past as to, like, well, why can't we just call this an elliptic curve and stuff like that. It's it's not that. Right? So you know, please leverage those resources that some of us in this room have been contributing to. Next slide. Maybe there we go. So key thing here is that since there are now at least in theory some potential attacks on the horizon. against some of the mechanisms we use for asymmetric cryptography, and especially in regards to signing. there are 3 leaders that have come out of the nest standardization process in this area. maybe more using other approaches in the future. But This is the starting place. And so one of these is hash based. which is Sphinx Plus. And then there are 2 lattice base, which is Falcon and Dilithia. each have advantages, pros, and cons."
  },
  {
    "startTime": "00:12:01",
    "text": "Key thing here is let's make sure we have an intuitive upgrade path for providing digital signing of information. using asymmetric cryptography. And let's go through and make sure that we're meeting kind of the bare minimums that we need around cryptographic agility. we have a path forward. We also, obviously, wanna make sure we get IONA Registry in place so that when I send you in the future, something that says, yep. This is a job. signed by whatever or CWT signed by whatever, that whatever number resolves properly back to dilithium, so you don't go try to read that key into something else that it won't do anything with. So next slide. So couple of things to be aware of, key sizes, and signatures are larger as a rule. Right? Falcon's a little bit of an exception to this where things are a little bit nice size wise. But there's other problems there, particularly in key generation where things like floating points can get into the mix that can cause problems. 5 Oh, sorry. you. Thank you, Scott. This is why we have people like Scott in the room. So on the signing side, not on the key gen site, which is correct, and this is why We have smarter people than me here. The there's also typically larger amounts of parameters in in play in some cases. Right? Things like sphinx in particular can get kinda weird from an optionality standpoint, so we just need to be aware of this. And so we need to be extremely clear when we're looking at in Jose or Jose, you know, hey. I I tell you I'm using SphX Block I tell you I'm using dilithium. Well, what what exactly does that mean? What are the back details involved? And what strength am I after? Right? If I'm constructing the Lattice, you know, structing basically a matrix right of certain size for dilithium. How how am I doing this? What it what size is that? What does that mean? because otherwise, you can wind up with very drastically different and incorrect and bad results. So next slide."
  },
  {
    "startTime": "00:14:03",
    "text": "So couple couple of key updates. there's really only one technical update, which is as naming has kind of evolved since stuff has started, and discussions have started around this. we have rolled the key type over to MLWE. So, you know, basically talking about modules for learning with errors or ring learning with error type problems. for dilithium. So MLWE is being reflected in the dilithium draft. that's the only real significant change. Otherwise, you'll see the changes listed below which is we've got a note to the r future Fc Editor that basically we've gotta wait for this standardize this stuff, or everyone's gotta be okay with it if it goes ahead. Otherwise, there are some editorial cleanups and things like that. probably, most importantly, from an implementer standpoint, is now that Open Quantum Safe is really kinda cranking along in a good way, we were able to leverage that directly out of the box and open SSL to go ahead and build test factors straight out of the open pond of safe lids for this stuff. there's probably problems there. Like, let's just be real. Right? This is stuff where we're seeing differences between libraries from time to time. Certainly, the JavaScript libraries that you see floating around for the stuff do not use unless someone else says otherwise. But basically, I would assume that something you see from Cloudflare is fine. I would assume that something you see implementation wise from open Quantum Safe is fine. And otherwise, I would be very careful and step through the implementations because there are errors many of the implementations floating around in GitHub. Next slide. Basically, we got 2 help wanted areas. 1, maybe someone in this room can but probably not, which is hey, come on. Let's just go ahead and get the parameter set stuff, but that's gotta work through the process. Right? The the finalization and"
  },
  {
    "startTime": "00:16:01",
    "text": "final feedback from this has gotta continue going through. Number one thing for us is eyes on test factors and implementations. We're obviously all testing with what we've got. I know Ori and I have been doing some hammering back and forth. I know that other folks are as well. but we need to make sure the stuff is interoperable. There's a thank you in the acknowledgments now to Dave Cohen, who over at Block, who's been TBD. I forget what his official affiliation is these days. But he's also been testing and caught some errors in some of the JavaScript so it's very good to start getting eyes at Next slide. Big request for the chairs at this point and for the working group as a whole. We we think we're pretty much done minus any editorial or double checking of test factors and things like that. So we need eyes on this to tell us that we're wrong and where we can improve things. especially if we can because I'm sure as with everything that can be improved. So we want that feedback in. But at this point, we would love kind of finalizing from the chairs that's where we're Thank you. So, note of observation, The result of working group last call might be a request for publication, but this would be held due to normative dependencies on the underlying cryptographic specs. before it's actually done. Yes. Thank you for that clarification. And each of these specs has a note at the top to the RFC editor that says, please hold this until miss says, go. basically, does anyone wanna queue to ask questions. This is not living in a vacuum, and and that really mean -- Who are you, Russ? Sorry. Hi. Russ out. the There's a pair of documents or three documents going through"
  },
  {
    "startTime": "00:18:01",
    "text": "the lamps working group on how to use CMS with these same algorithms, There's 3 documents going through lamps on how to put the public keys. for these into certificates, there's 3 documents going through Jose. It's where out of where the thirds are gonna land. And what we really wanna make sure is that they're done in such a way that the the libraries behind these all work the same And so We just I'm just screaming for for making sure that eyes from all the groups are on all the 100%, and and I think that's one of the reasons, like, the number one ask was eyes on test factors. a note on cross collaborations, etcetera. Not only do we have a couple of the authors of folks on these specs engaged. We also have authors of specs over in the Lam's working group as well that are crossing over. very intentionally. So when this work started out, the first calls actually were and emails went out to the authors of the, you know, the 3 Suites in question directly first, followed by who we're looking at IDs over in lamps. might have to put some eyes on some of the Jose's stuff because I'm not sure. I I don't know which draft you're referring to there, but because this does cover both Jose and Jose. Yeah. Okay. Perfect. John, you have the floor? Thanks. I don't really see why we would Is it reasonable to go to last call now before the algorithms are even standardized we know that it will be changes I don't know. The explanation that we will push this through and even note to the edit Or if the others does make zero sense to me, there will be make their technical changes and changes to test vector. So they wanna only So I I think this should be kept until the finalist standards."
  },
  {
    "startTime": "00:20:08",
    "text": "Lawrence? Yeah. The Lawrence Lundlight. My I'm not really deeply familiar here, but my my question is, think you proposed there's 3 algorithms there. is the idea to go through with all three of them. And, like, wouldn't we wanna just pick 1 or 2, make it simpler for all the the the world That that would be lovely to be able to pick 1. NIST is proceeding with 3, and I think for good reasons. Dylithium meets In fact, it's in the currency NSA 2.0 profile. as the kind of preferred mechanism from a signing standpoint. in certain constrained environments and other areas where especially key sizes are very important. Falcon does come into play. The math does look great. Right? So it's that's that's one of those things there. With also the caveat that, yeah, wall lettuces have been around a while, we're really beating them up for the first time in prod. Right? now. And so When we look at that, that's one of the reasons to include sphinx plus. because it does provide us a fallback that we know will work regardless and is Post Quantum Safe. So that that's the reason for the 3. Right. We're we're at time. gonna be closing remarks. You've feel you need to make? The the only closing remark, I would say, is that, obviously, we need to be testing some of us are facing regulatory requirements around stuff over. So some of us that are dealing with those kinds of customers are doing that already, but I thank the IETF for continuing to make sure that there's conversation around Post Quantum in general. and thank folks for showing up here that normally just show up in CFRG, etcetera. So so so Thanks all. Pick."
  },
  {
    "startTime": "00:22:06",
    "text": "Now, I just uploaded your deck, now. And the tool is not showing it to me. Okay. You're gonna help me again. No. Let's choose Yeah. That's fine. Complete. show you it now. It's the test header parameter 1. 33. Now the folklore is that the stuff gets uploaded 20 minutes before the meeting starts. Yeah. I had a problem with -- No. I can talk to That's not it. I guess, they talk about it. That's fine. Yep. If if it's what? I I can simply talk about it. Okay. Why don't you talk about that? I I don't need necessarily need slide site. This is home. You can you can do a refresh spike while you think you're talking. Okay. Is there a special refresh button? I refreshed the browser. It's like a recycling button. and and start talking. Yeah. I think I can start talking without giving some context. So My presentation is about time stamp token that you get from a TSA or trust just the timestamp Authority, That's basically a during quoted thing. And relatively old. But how this is used"
  },
  {
    "startTime": "00:24:00",
    "text": "until this day, whenever you, for example, have an Acrobat signs a PDF, and your RTC in your system is not trustworthy time source. You can go to a more official time sourcing the Internet and get a signed timestamp token. in essence, And maybe we got slides for that. No. The refresh didn't work. Just keep going. Okay. So what we decided to do or to until we have some thing that could be a Seabor time tag and maybe a little bit more I'm separated way to hit 2. It's acquire timestamps. We are, for example, epoch. Marchouse And EPOC beds. for now, we thought is useful to have an interim head of parameter where you can just store this timestamp token token. So when you request such a time stamp talking from a TSA, you send some data over there. You can call it a digest. TSA calls it an imprint. and the the science structure that you receive that you get back at the response, basically is based on that imprint. And so in my previous example, I want to sign a PDF. I would create an imprint of that PDF that is relatively small. If it's a big PDF, the That's send that to the TSA and find that imprint in the science and tone. So And this order, now I have a time central, and now I sign the PDF, and my time spent was a sealed enter the now structure of the combi younger than this point So that's that's a legal thing a lot of countries have, and there they are. A lot of countries have these TSAs. And now I can go from contact next slide, please."
  },
  {
    "startTime": "00:26:03",
    "text": "Yeah. This is basically to explain this RFC 31 x one. If you wanna look at it, it's it's it's pretty well written. Next slide, please. But now we can use this teleparameter, and 2, buckets. We can put it into a protected bucket in Cozy, and we can put it in a unprotected header. buckets. And, unfortunately, what we only were thinking about is, like, the counter signature thing. And what you can see here is the PDF example. So the to do Hank Expanded adjusted here with a PDF example, you if you want to put it in a protected header, the imprint is different obviously, because You can't. have a signed object yet. It is unsigned. So the input is different. And and then you can have the TST had a parameter in the protected tower. Next slide, please. you want to do it like a Counter Signature. I hope Russia is not angryp, if I say that, if this augmented crowns a signature that includes a time stamp. then, of course, you have already assigned thing, a cozy thing, create the imprint from that, Send that to the TSA, can now put that handsome talking into the unprotected hella bucket. but that is a different procedure with the different semantics. And now we are at the point next slide, please. Okay. Interest, I think, we actually have the 11 Yeah. on last time. But now the question is, are these actually header parameters because the semantics are different because the procedures a different or is it okay? to find one header in a per in a protective bucket. And by that, it's implicit, of course, that you use this one procedure a that is we describe will describe in the RFC. Or if you find it in the unprotected, had a bucket that we use the"
  },
  {
    "startTime": "00:28:04",
    "text": "procedure b. So so the question to the working group basically is now Would you like to have this in London? had a parameter with the designated experts for agencies have an opinion about that. or or would it be too header parameters for for each bucket because I I'm not sure if there's a precedence for header parameters that can only go in one bucket. Even the counter sickness one has no normative language about it. It just it can go in the unprotected bucket. And then yadayadayada, how it's done. but there's no normative language on on restricting the the head the the specific Vicquetta. we are ahead of perimeter has to go to. And, yeah, that's that's basically the open question that that's stopping us from working here. and that we need working group input on, which hinges might be a good reason to do a call for adoption because we don't want to make decision by our own. So chair hat off, I will say that the draft for CWT claims in a header parameter says that it should be used in the protected header but but There's also security considerations about, you know, what might happen if it's used in the unprotected header. and That's not exactly your use case. Yeah. Mikeus on the line? Yes. Thanks, Hank. the I I think that one header parameter probably fine. but I think they're absolutely at minimum in the security considerations. should say something like, hey. WE'RE TALKING ABOUT TRUSTED SIMPS HERE. IF YOU PUT THIS IN AN UNPRETECTED AREA, You kinda just just lost any value to header I would be fine if you just went ahead and stated that it belongs only in the protected some Thanks, Mike. But"
  },
  {
    "startTime": "00:30:00",
    "text": "but that is not the only actually, we we started this with the idea of this is counter signature esque So counter sickness of metadata that yields something new that goes into the unprotected header. And, again, the procedure is different. And as obvious, it's very clear that we're going to describe both procedures when when when to switch what when to use which. So yeah. I'm gonna recognize Russ and then Ori, and then we're gonna cut the queue. there are cases where you need to do the time stamp after it's already been signed. Therefore, it has to go in the unprotected that are in those cases. Yeah. Of course. Right? And there are other cases where you go get timestamp on the thing, and then put it in the protected header and sign it, and they've got different semantics. as you said. Yeah. just explain that. but used the same header type. Perfect. That is a valid opinion. I I I love concrete support. Thank you. Yep. Aory Steele. I agree with what Russ said. But if you're super scared that people aren't gonna read, you can force them to interpret them differently by giving them different identifiers. so so It's really just about how how afraid are you, but I would listen to Russ over being afraid. Yeah. Very encouraging. Thank you. Yes. So and, again, so I think because this this off already was a working group decision. I think we we should go for a call for adoption and then fix that there in the working group. Everybody reads it once, and then we can have that shipped. hopefully. And that's what was my presentation, basically. Yep. people comfortable and, obviously, we'll really do this on the list, but are people comfortable"
  },
  {
    "startTime": "00:32:01",
    "text": "having this adopted, if so, nod your head or put up your thumb Does anybody think it's a bad idea? k. No objectors. Thank you. Sir, sir. Sir, thank you. k. Next, seaborne encoded certificates. Thank you. So I So do you flip the what do I Yeah. Just say next slide and I'll advance it. Yeah. Next Yeah. I think So next So High level, still some discussion how Yep. commenient to how to pause things, and, yeah, I think we don't have so much a technique slide. We can go through that. She's here's a short issue where we're quite lot since the last meeting and then quite a lot of updates. Basically, all of them are quite Minor updates except the that we have started working on UCS BC board encoding of that, we can see the things here. Big thanks to Ili 4 very detailed comments. We have not addressed all of them yet. can next slide. one thing that we are planning to do was originally So, yes, the bicuspid is to break out the revocation we feel like that the certificate and the sign in request pouch are quite stable, He would like to published deeds,"
  },
  {
    "startTime": "00:34:03",
    "text": "We plan to break out the CRL and OCSP seaborne codings in in a separate drop because otherwise, we think it will take longer time. Let us know if you don't agree with this. Otherwise, we We'll do this in the next up next version of the dot next. Here's the first version of UCSP and that you were made, and it's as he says, it's not really done. So look at it. If you want, otherwise, maybe wait for a more the polished version. Next and next again, I think, And next Some ongoing discussions and issues continue long living issues, how to parsing the the contra message Seis have done quite a lot of things here all reddy. Nothing. things are now mostly array, so there's no sequences, high level, has been discussions per node. No clear conclusions please comment on this in the GitHub if you have some more comments. Otherwise, we we think it's the current compromise is quite good. Next. Then we have some issues on further amization, you can do as we show in the draft, you can do more compare by adding growth Lee, for example, or or or of the diseased blood encoding, both on a single certificate and then on several So they've got"
  },
  {
    "startTime": "00:36:04",
    "text": "can also do optimize. In chains, there's a quite of fields that are the same, which you could also optimize. But that leads to to pass implementation, which we would not like to do. So our suggestion is to not do anything of this if you use C509 in TLS, you can use Broadly on top. And if somebody wants to add that later, that can be added later to COCI. So next Next slide. And the Vintech slide. There's a relatively new you suggesting more registration of more extensions Our current CSC is to register value integer values for them, but maybe still have them there encoded Otherwise, seaborne encoding needs to be specified. Talking with that is worth doing for these extensions. But if somebody wants to do that, this we are very happy to see that, of course. Next slide, I think that's the current issues. There are some some encode known arrows in the in the example source code, we think the specification is correct. The the the the source code is wrong, so we will update that definitely before Prague, hopefully, before that to make a new version that aligns with with the draft and fix and eat"
  },
  {
    "startTime": "00:38:03",
    "text": "problems we are aware of. Yeah. Next slide, Yeah. Was not too much. Next slide. Yep. We are Well, in time and have Yeah. Time for some question or comments. Otherwise, we have we have fairly we have some amount of issues, basically, all of them smaller, we will continue to fix them we plan to split up the draft So that revocation is in a separate draft, tend to do that next submission. And then we hopefully fix all the issues, and we can hopefully publish the certificate and CRM soon. Here's a column from my Yes. It's basically as They are fundamentally RFC 5280 certs Definitely. This is a seabornecoding coding of RFC 52 8. That has, of course, benefits and also negatives. You get all Yeah. everything in North Sea, the 280, but I think that is yeah. That's the current approach. Definitely. Yes. and the sizes you can get for IT are very, very small."
  },
  {
    "startTime": "00:40:10",
    "text": "And then some other things are not supported. doesn't support everything. It's a subset of, let's see, 5280. Any questions? Otherwise, we will move on to Merkel Trees. Alright. Thank you, John. Alright. I'm Maurice Steele. presenting work on concise and coding of signed Merkel proofs. The co meter draft This is work that Hank Burkholt's Antwan and Cedric, from Microsoft Research have also contributed to This is was previously presented, the last IETF and origin this work originated from the the skit, securing supply chain integrity and parenty working group and it is an expression of roccal proofs inside of Cozy. Next slide, please. So What does it do? describes a verifiable data structure in CBOR encoding various proof types for binary merkel trees Merkel search trees and cryptographic accumulators, etcetera. So those are examples of data structures, that have certain kinds of proofs associated with them. So these provide cozy building blocks for transparency logs another verifiable data structures, and These are important building blocks for Skit,"
  },
  {
    "startTime": "00:42:01",
    "text": "but, you know, potentially also important building blocks for key transparency and certificate currency, you know, and you'll see in the next slides especially the relationship to certificate transparency. Next why do it slide. So Well, There are a lot of different approaches to verifiable data structures out there. And in particular, CBAR is a compact way of encoding some of these proof types So in RFC 9162, which is the 2nd sort of iteration of certificate transparency, the binary mercury format that is defined there, has supports 2 kinds of proofs. a proof of inclusion and a proof of consistency And those are the 2 proof types that certificate transparency builds on And, essentially, what this this document is doing is it's taking those expressions of those proof types and allowing them to be encoded in Cozy so that they can be used to build protocols rely on proofs of inclusion and proofs of consistency. and when you're building a transparency service or something that relies on these kinds of proofs, that can be used to sort of enable other use cases such as offline verification where you happen to trust the transparency service but you're not gonna go resolve the signer keys for every sign statement that's been made transparent. It gives cozy the ability to kinda understand these proof types And that's sort of similar to how Cozy understands a digital signature, but you know, the implementation underneath a digital signature they might have different underlying cryptographic building blocks. So cozy today, digital signature might be ECDSA, EDS In ASA or RSA, But Cozy has algorithm identifiers that tell you Indeed, this is some kind of digital signature, and therefore, some amount of interoperability and protocol design can rely on that convention."
  },
  {
    "startTime": "00:44:02",
    "text": "So there are other transparency use cases such as key transparency and certificate see. I I work know, in the Skip Working group, we're looking at securing software supply chain artifacts, but Key transparency was gonna have a buff this time around, and and now that's been resolved on the list. and certificate transparency is a previously concluded work. next slide. So since last we met our heroes. I love that. We've updated the draft to think more about the generic concept of verifiable data structures and proof types So previously, this was very focused on Merkel trees. And what we've learned from key transparency and certificate transparency and other work that's happening in the community is the underlying building blocks for the verifiable data structure, they might not just be binary trees. There could be cryptographic accumulators or Some of the interesting work in key transparency relies on this paper, the merkel squared paper where you take 2 different kinds of merkel trees and you combine them together to be able to do proofs of noninclusion and search proofs. And so what we've done in the draft is kind of update the draft to reflect that there are these verifiable data structures they have these proof types Whereas previously, it was sort of saying there are these Merkel trees, and they have these only these certain merkel proofs. So the the tree piece is sort of being de emphasized the registry request is being updated to accommodate that there are things that might not merkel trees that might get registered. but but but still the concept of This is the data structure algorithm identifier, and these are the proof type that are bound to that data structure, that that part is still the same. So we also have to improve the CDDA all examples and we'll be monitoring the proof type output from KT and render it cozy interoperable. So I've already mentioned some of those proof types that they're already looking at."
  },
  {
    "startTime": "00:46:01",
    "text": "the proofs of noninclusion and search proofs. Yeah. And we we need to improve the CDDL instead of twice. Next slide. So just to give you some idea that this isn't just like an abstract thing that we're talking about. Here are some examples of using these assigned Merkel tree proofs or assigned inclusion proofs. So in the skit use case, we have a a skit receipt, which is a kind of profile on top of signed inclusion proof. And it shows you that, you know, While the algorithm is e s 256 in this case, we have a verifiable data structure that is RFC 9162 shot 256. And in the unprotected header, you can see the inclusion proof and that's gonna prove that this transparency service has made some statement transparent using this verifiable data structure algorithm in this inclusion proof type. You have to read the specifications associated with those registries to understand exactly what that means We have a general idea that there's a set membership proof that's being combined with a digital sure. And on the right hand side, you have the consistency proof So the inclusion proof and the consistency proof are the 2 proof types defined in RFC 9162. and the consistency proof in general, it proves the append only property of the inclusion proof. the inclusion proof is a set membership proof effectively. saying this element is in the set. But if the set's growing over time, you'll need a consistency proof to show that the previous inclusion proof that you got is still consistent with the current state of the log Next slide. This is to show that there's implementations behind this. this get hackathon, I showed some folks demo of a transparency service that uses this signed inclusion proof and signed consistency proof. and you can make images transparent. You can make"
  },
  {
    "startTime": "00:48:00",
    "text": "application, jwkpluschasingtransparent, any content type you like, you can make them transparent using signed inclusion proof pieces, And I'm happy to give you a demo if you find me show you how it all works, show you how it all works, Next slide. So At this point, there's some intention to do some profiling work on top of this And so as as I mentioned, the current draft describes these verifiable data structures And there is already an idea of another kind of verifiable data structure out there that's not RFC 9162 shot 256. It's the confidential computing framework tree algorithm, which is another mercury algorithm, but it has a different option. So you need to be able to distinguish it. And there could be some CDDL to represent concept of a a skip receipt that uses that tree algorithm. and the proof that's going along with it is still assigned a Merkel Tree proof But You wanna be able to tell what tree algorithm that signed Merkel tree proof is associated with. Next slide. So further profiling examples I know how much everyone loves CDDL, so we've included lots in these cases. the CCF leaf So in the construction of the leaf that is gonna be include the source of the inclusion proof Different tree algorithms have different requirements on how you might construct the leaf. And, hopefully, constructing the leaf is easy, but In the case the tree algorithm requires specific details, you have to communicate that to the verifier and the the issuer of the inclusion proof. So this is an example of a profile that's built on top of our our draft, and it's describing how you can apply the CCF tree algorithm giving sign clue signed inclusion proofs for a transparency log. Next slide."
  },
  {
    "startTime": "00:50:02",
    "text": "So as I mentioned before, we presented this work previously, the skit working group is is interested in leveraging these building blocks and We have use already in Skip for 3 independent tree algorithms that all have this signed inclusion proof property. but different underlying tree algorithms. We think the document is ready to be reviewed and beaten up by all of you all. We be grateful for the opportunity to improve in that way. Is it ready for adoption? I I would I would love for the opportunity to improve it as part of the working That's it. who in the room are online is in favor of adoption. I see about ten hands who is opposed Alright. We'll do a adoption call on the list. Hank, it's your turn again. Thank you. Oh, okay. I did. I did hanks for him. So we just bought 10 minutes. Yay. Okay. So next would be the cozy Keith on print draft. Can you hear me? Okay. Yes. Okay. So I'm I'm Jorge Sobe. I'm a cozza of the co cause the key some print. So Okay. So I'm working in Deep Walking Group, especially so"
  },
  {
    "startTime": "00:52:02",
    "text": "implementing along with the tip protocol draft. And that's all. And this idea was approved by the implementing hand updating the TIP protocols. Okay. Okay. So next Okay. So So recently so in the last IETF, so in the deep working group. So Deep protocol was modified. updated the confirm and shared the and a shutdown, kids for the signing to the tip protocol keep message, and so verifying the distributing suburbs by the how, each devices have reached the kit. keeps that to signing the message. So in the these processes, so we want to method to confirm the keys. So identifiers. So But so in the Kozi and Kozi keys. So there are no specifications for calculating the identifier values. So I proposa disdraft. Yeah. So this program is in the any other relating works for for example, so suit some inserts specifications also needing identify the key identifiers. So yeah, that is a we need to specify the calculating the way to the keystone print. Okay. next spicelies."
  },
  {
    "startTime": "00:54:05",
    "text": "So, you know, so there are some they are existing standards to calculates up key identifier values. So, for example, database some print, and that's so key identifiers in x.55oq, 509 certificates. So we can use so the gets key identifiers values. So by the existing standards. But so even though you we want to use up cause the implements. But so just for calculating the sampling values. So we should add the extra implementations for adding for the JSON's implements or 6. 509 to increment it. into the UI implementations. So I want to solve method for the just So we can we can implement only within the our end quasi objects operations only Okay. Next slide, please. Okay. So this is the methods to we propose how to calculate it from the quasi key object into the some print values. Yeah. Yeah. Yeah. So this is a composite over 3 steps. So fast step is make a quasi key object This is already defined into the RFC 9 or 50 So but so all elements are not included in the this quasi key object And the second step, so the so So"
  },
  {
    "startTime": "00:56:02",
    "text": "ensuring for the each quasi key object quasi key object uniques. So we use the the deterministic deterministic encodings weights So that is also defined into the RSC 8949. So that is that. So intended to the make a unique to the it's quasi object. So on the finally, so the deterministic encode it across a key object in hushed you have the the object. So So in this draft, so we don't identify the concrete has algorithms. So you can choose any hash algorithms, so you want to use Yeah. Yeah. help creating the some point values. Okay. Okay. a next private, And so the formats drive, so I mentioned the all parameters of key parameters in included into the quasi key objects. So this is a source of what details are explanations. So in asymmetric case, so we can use public key parameters only. So That is also intended for the match the public keys and the private keys on yeah, into the single some print values. And so additionally, so you can use metadata So, for example, keyops or concerns, But so so to identify the keys or to choosing the keys so we can I'm not here with"
  },
  {
    "startTime": "00:58:02",
    "text": "we should not use such a metadata parameters. So in this draft, So these parameters are excluded. And so Yeah. And so, additionally, so the asymmetric keys not supported in our drafts, So because of the some prints is So These closings of the all is now asymmetric key values, So this is a node supported. And so this design is so duplicate it from the JWT samplings So there are no differences of the original ones, Okay? So next step, please. Okay. This is a example. So, brak, broke is copied from the RSC 9052. So in the our our our proposal. So and the quasi key object is so modified into the orange blocks, So the each parameters. Do you order it? and that's all. the key ID parameters is a developed from the original key object. And so finally, so the orangeproxy you you ask that our engine blocks that binary strings. So final result is a some print values. Yeah. Yeah. Yeah. Okay. Next slide, please. Okay. So so since So the driver's savings. So they are so a quote for a lot of shows our draft. So as far as I know so there are many so supporting voice, so I appreciate it."
  },
  {
    "startTime": "01:00:03",
    "text": "So in this meeting, so I want to gas as a any opinions for any comments. So on the I'm with the saw I'm with the saw as how many as what the documents were adoptions. Okay. That's all. Yeah. So I would encourage people to respond to the call it tougher adoption. Although we're It's timed out, hasn't it? or how many more days Yes. Already over. Okay. So the chairs have it. on our plates to assess the result which I think was positive and I would like to ask people particularly once there's a working group draft to review it. I'll put up my hand as the JWK thumbprint author that I should really read this. there's others who probably are interested in having solid key thumbprints for cozy keys. So if anybody wants to tell the minute takers they plan to do so, that would be Thank you very much. Alright. k. Okay. or Europe type header parameter. Somebody Oh, oh, somebody on the queue. Okay. Brendan. Hey. Can you hear me okay? Yes. Okay. I have a use for cozykeythumbprint in a symmetric key scenario, in the original version of the suit firmware encryption draft We had a mechanism that needed for security reasons"
  },
  {
    "startTime": "01:02:01",
    "text": "a hash of the symmetric key that you could so that it was verifiable that the key had not been tampered with. before you go writing your firmware to your flash. And that that would be really handy if we come back to the former distribution scenario rather than the 1 to 1 mapping we're currently looking at. So I just thought I should encourage you to also look at the symmetric key version, please. Okay. So Okay. So I already mentioned so that simple heath, methods is also just a leading to the disclosed, that always now similar case. So I think so I want to should we I should we should add some mechanical improvements. So I want to try to yeah. adding us mechanisms. Okay. Good. Thank you. Just as an individual of say I just looked up the JWT thumbprint does support symmetric key. operates. I think this is something that should be discussed on the list, particularly once there's a working group draft because I can certainly see both cases Okay. Thank you very much. Mhmm. Thank you very much. Mhmm. Thank you. Thank you all. Yeah. Corey, I believe you are up to talk about another header parameter draft. And unless there be any doubt, I'm an author on this. and so my co chair will Cheer this. aspect of the meeting, Thank you."
  },
  {
    "startTime": "01:04:00",
    "text": "Alright. I'm here to present with Mike Jones, the draft for the TIP type header parameter. Next slide. So what does it do? Well, it adds the CYP header parameter to the cozy protected header parameter list. So this enables typing the entire cozy structure using registered media types While Cozy included the content type, parallelizing Hosey's CTY parameter, failed to include the equivalent of T YP. So just for some background in the hosea ecosystem If you have a JSON Webtoken, or a JWS you can have a header that will have a TIP value which is the type of the entire token. And if you look in the iona media types register, you'll see lots of awesome tokens. that are all identified as media types that are something plus JWT. You'll also see lots of other media types in there that are content types that could be the entire CTY that's dedicating the entire JWS payload to a known content type. So it's confusing, and these are 2 distinct header parameters, and they identify using media types, different things. Next slide. So why do it? Well, it enables explicit typing in parallel with the JWT ECP So the JWT BCP's excellent document. Encourage you all to read it. And in particular, it has a section on token confusion and explicit typing, which is very relevant. In the case that you have a verifier, or an issuer that's producing many different kinds of tokens. They may be interested in being a explicit, what type of token is this? And so the the JWT BCP encourages implementers to"
  },
  {
    "startTime": "01:06:01",
    "text": "make use of explicit typing, and in particular, the TYP parameter So This again consistently distinguishes the envelope and the payload media types It's been discussed on the list. There's an example here, which is showing you potential source of pain, and it is is not completely unrelated to the motivation for this. There's all other work happening multiple structured suffixes in Mediaman that could really really cause problems. regarding this. So I'm make I'm showing you these examples here. to beg you to please go review what media man is suggesting regarding multiple suffixes and ensure that media types will be at least not made any more uncomfortable than they are already. So in particular, you can see in these examples, typandcty, that there could be a type of the entire envelope that could have a very complicated media type, And then there could be the type of the payload that that envelope is securing, which could have a simple media type or a complicated media type. And on the bottom example, the Top example you can do today, the bottom example you can't do today until you add TYP parameter to the Cozy Header parameters list Next slide. So a question that should come up is why not use the seabor tags seabortag prefix the, you know, the cozy structure are not part of they're not part of it. And, therefore, they're not integrity protected. might be omitted. The TIP parameter parallels Kozie's Hosie's use of content type. So Like, if you're, for example, if you're doing work with the rats and eat. you have this concept of JWT and CWT with sort of intention for them to be treated"
  },
  {
    "startTime": "01:08:01",
    "text": "and you're trying to follow the JW TBCP for the hosing side. But you on the cozy side, you can't because this parameter doesn't exist. that confuses developers, and so this would potentially address some concerns there. And, also, An area I'm less familiar with, but the cope content format numbers media type strings. So there's a desire to sort of have some consistency also for the Cozy Convention side of this the cboard convention side of this. Excellent. Excellent. So some examples. So I I I mentioned to you already previously the work on Skit. I'm not saying that Skit is gonna use this typ parameter. I'm saying that there's many application protocols that might want to do explicit typing because they wanna do something that's sort of like what the JWT TBCP is recommending And this is a real issue in w3c verifiable credentials while working group where I'm an editor. and we're trying to secure adjacent LD payload, which has multiple suffixes consistently with an envelope type that uses explicit typing to follow the JWT BCP. And we do that for JWTs by file following the JWT BCP We cannot do that for cozy trying to do the same thing. That verifiable credentials use case is very similar to the EAT as a framework use case and rats where they say, We're gonna do JWTs, and we're gonna do CWTs, and we kinda want them to behave similarly so that developers are not confused. Next slide. So it's brand new. Recently published. We need CDDL examples It's also very simple. and I the relationship to media types is the complicated and painful part that's not our fault. But if you want to use this, you should"
  },
  {
    "startTime": "01:10:03",
    "text": "pay attention to what's happening on those lists and, in particular, the multiple structured suffixes drafts. and look forward to getting any feedback you might have on this particular piece. We have already gotten some feedback about the relationship to Cozy profiles, which we've started to address on the list. Next slide. So We'd love more review. We've already gotten a little bit of quick review since publishing the draft, but we wonder, you know, is this something the working group would be interested in looking at especially given the relationship to work that's already underway, in media man and in w3c, etcetera. next. That's it. That's it. There were people on the queue, I thought. Brendan. Can you hear me okay? Yes. Yes. Good. Good. Would it change the mediate or the the type parameter if you countersign a cozy object. that's a great question. So in the 1st to signed object that's being countersigned, you'd have 1 type parameter. And in the counter signature, you might prefer to leverage this parameter for explicit typing of the counter signature. but it strikes me that the aggregate type of the whole thing changed when you added the counter signature. I don't well, It would it it did technically bites did on the 6th year. But but now you have a type that mismatches header that you can change."
  },
  {
    "startTime": "01:12:02",
    "text": "I I love you, but the the counter signature goes in the unprotected head So Exactly my point. So the only way to make the types resolve is to remove the counter signature. That's not great. Great question. and also really it's yeah. Ask it on ask it on the list and I'll I'll respond in in longer form. But that is actually that same question is the same problem that processing multiple suffixes creates creates with or without counter signature, you still have that problem because your you're processing content that the content type is changing as you process it, in in well, just go read the document. You read the multiple suffixes. draft in the media man group, but but it's a similar a different take on the same kind of pain. Kirsten. We are hearing a lot of pressure for these cozy profiles And I'm not entirely sure. I know what that is But essentially, the the type parameter is a way for the signer to to actually indicate what what this signature means. I mean, signing some some data is is not necessarily unambiguous in in all cases. and actually saying that not just the the payload, but but the the other information that goes into the the assigned object. is meant to be interpreted in the context of a specific media type. is a way out. So this this adds another dimension of overloading of media types, which which may not be the best feature. But on the other hand, media types are the best we have for this. So Why don't we use it?"
  },
  {
    "startTime": "01:14:04",
    "text": "I agree with everything you said. in particular, the intention of the issuer when they sign the TYP parameter in the first signature, They are not necessarily aware of what counter signatures might be applied to their object after that point. So how can they be accountable to the changes in the interpretation of the media type that might follow-up Yeah. Not not even limiting my answer to to answering this question. I think in in general, the the approach here of for using media types as a way to indicate that that intent that is the right approach, and that that's what we should be doing. Hank. Yeah. This is saying, oh, speaking for Thomas Forsati who can't be here today, and we we last the last cozy working group meeting we warned with the story that we have this individual ID that might the cozy profile, whatever that means. There's a recipe in there. And maybe we should look together at this and see how this combine of it, Because if it would be, that would be maybe really a way out that would be nice. might have saw You that coming. Yes. We we I think Mike and I have already both responded on the list. join us in the dark side, come to the media type side. Yeah. Let let's let's go through where I -- What's how we we should talk? Yeah. It's a good way to talk. I got Eva, you're chairing this segment. What would you like to say? Well, Basically, like, this will discuss this. And the list We I mean, Lucas see what have the goes. And if Larry said, Gender"
  },
  {
    "startTime": "01:16:05",
    "text": "consensus that this is useful after the COVID 2, I Yeah. Proceed something is glass and Thank you. the queue is clear. now we're going to talk about HPke, which Ori and Hottest collaborated on a joint deck So let me pull that up. and we will take it away. Okay. This is a HPKE sort of summary recap. And as I said, as was just said, this is collaborative work with Haunas and, really, the entire cozy list and all of the patient readers and workers who've been following along or commenting on the discussion over the last time More than a year. Thank you, Russ. Next slide. So what does HPKE do for folks who might not be familiar with this particular item, Cozy HPKE is the item that we're discussing, and it enables the use of HBKE inside of Cozy. And, you know, what does enablement mean? Well, it means have to have some keys that key representations that can support HPKE you have to have envelopes that can support HPK, and you have to have a document that tells people how they can use those things with HPK. and we do. And that's the document that we're gonna be discussing. Next slide. So most of the discussion has centered around the concept of algorithms The ALG parameter"
  },
  {
    "startTime": "01:18:01",
    "text": "which can be present both in keys and in envelopes. protected headers. So and then another important aspect of algorithms that has made it particularly difficult to work with is that it is present as Alg in both Cozy and Hosey and both cozy keys, and JWKs, both cozincrips and JWEs But alg doesn't always mean alg depending on who you talk to. That's okay. You because it's just getting get getting into it. So they're actually go back and make sure I don't forget. Sorry. That was just a false click. Yep. I covered everything. We can go. So there's been a lot of discussion on how should we do this A lot of decisions have been made and then arguments that was the wrong decision and back and forths. So there's basically 2 proposals for how ALG is gonna be relevant. And this is the, I think, reflection of the current draft proposal on the on the right hand side is definitely in the current draft But the left hand side is a key representation, don't believe I'm not sure if that's not in the current draft right now, but it kinda makes sense to put them together because I think you need to have keys that go along with envelopes. So I put them both on the slide here, but just to be clear to you all, only the right hand side is in the document today. And the left hand side is the proposal that I believe closely aligns with what is in the document today. And you can see the algorithm parameter in the key representation is saying hpkevonebase dash cam And then you can see You see some familiar things on the left hand side. You see a key type elliptic curve. You see a curve p 256,"
  },
  {
    "startTime": "01:20:01",
    "text": "You see x and y? These are all familiar. Then see ALG and you're kind of potentially used to seeing algs that maybe you don't understand Or maybe you do because you've used that one ALG all the time, and you really know it super well. It's new, is definitely new is the HKC configuration object which exposes the CFRG HPKE registry, which is a registry for identifying chem algorithm identifiers key KDF algorithm identifiers and AEAD algorithm identifiers. you have a single chem identifier, which binds typically very strongly to the key type and curve and curve point sizes because chem algorithm identifiers if it's pre quantum, it's gonna be, like, a DH cam, and so it's gonna be, like, sort of ECDH like the that particular, chem ID is sort of very much related to the kind of curve that the key is representing, The KDF identifier is in an array box, So, potentially, you could have some multiplicity there. is that a thing that you want? How many array items is too many array items in the KDF box. and the the AEAD piece same kind of deal. there's there's There's art well, There are there are arguments that it's good to allow a key to expose all of the configuration for HPKE that could be valid against it, and There's other arguments against that. But in this particular representation, let's just say, Your goal is to expose the full capabilities of HPK as the CFRG allows. this proposal best captures that intention, in my opinion. On the right hand side, you see"
  },
  {
    "startTime": "01:22:02",
    "text": "the HPK sender info, which sort of corresponds to what you might have seen in the ECDA ephemeral public key, you know, previously for ECDH, yes. And you see repetition of these HPKE CFRG Registry Identifiers. the cam identifier, the KDF identifier, and the AEID. And you also see a repetition of the ALK. So Long story short, representing a lot of parameters in your key. and you're representing some subset of those parameters that the sender chose in your envelope. Next slide. So that was the proposal that you just saw was kind of what is in the current document and proposal for adding a key type to the current doc. a key to the current document. The this proposal represents an opinion on simplifying this where we make the algorithm kind of carry those parameters in a way that is slightly more compact But it is a design there's a design difference you can see requesting a registry entry for TBD 42. and having Al in the key represent TBED 42, and ALV in the header represent TBE 4 2. And when you go to the registry, you look up what does TBD 42 mean, not going to a CFRG registry. You're going to cozy registry, and it tells you the same exact parameters that you just saw in the last slide. but they're kind of all together in a suite. So there's a design choice here around is it good to expose these parameters and have people choose them. or is it good to register suites of HPKE configuration in Cozy and have Cozy implementations use the registry experts for the cozy registry to explicitly say, You're trying to do HPK TBD42 or TBD 43. instead of"
  },
  {
    "startTime": "01:24:04",
    "text": "Here's an object with arrays inside of it, and here's an array with parameters inside that's comparing the two examples. Next. So there's been a tremendous amount of discussion on the design choice here, is it a good idea to do proposal 1 is a bad idea to do proposal 1. Good idea to do proposal too, bad idea to do proposal too, many people have weighed in, what we really need to do here is establish some consensus on should out fully specify HPKE using an integer in string, okay, the Cypher suite approach. Yes or no? If yes, We have to make changes to the document. no. No. We need to define a key representation that aligns with that and get it into the document Do you wanna take questions now? I'm I'm fine. Mike Pearl Rock here in the queue. Thanks, Mike Parikh. Clarifying question. With proposal 1, is it possible to wind up with situations where nonsensical combinations come together. can you go back to proposal 1. So I don't for some definition of nonsensical, but sender might choose so let's say that the recipient had expressed multiplicity of KDF and AEID. And they, in particular, said they had, like, a really, really big KDF, and a really small KDF and a really big AEAD and really small AEAD, And this the the sender might be like, I'm gonna take the small one and the big one together. like, Is it nonsensical, or is it, like and then the is there a legitimate"
  },
  {
    "startTime": "01:26:02",
    "text": "valuable vendor use case for making that decision. that's a question for you all. Let's see. Mike, Mike Ellsworth And Trust. an example of nonsensical might be that your cam internally uses shot 3 and you specify any track shot to KDF, and that's just not with bad. It's just weird. So the comment I was gonna make is as the author of the hybrid composite stuff in lips. I got thrown the rotten tomato called reef factory in the last last IPF. So that was the comment that too much flexibility here allows developers to make bad choices, and we're forwarding the complexity to, you know, RTFM forever using the crypto library. So that I if that argument that was made to me in lapse, also applies here, then I think Cypher Suites is the way to go. Thank you. That's okay? Hi. I'm the sched for me. Thank you for summarizing the to proposal. Thank you very much. And then I have already said everything are, I wanted to say, on the merit risk, So I don't want to repeat it here. about the I think we should provide some some kind of comparison table of the pros and cons of the 2 proposal, I think. And if are otherwise are the party sprints can't make and some kind of informed decision. So I believe that after making their our comparison table. And then a boat boat should be taken on the mailing list, I think. Thank you. Thank you. Thank you. Thank you. Thank you. Yeah."
  },
  {
    "startTime": "01:28:01",
    "text": "Karsten published a document guest yesterday. I saw you and Alaria had already commented on it, and it I think is related to your request. their on on comparison, like, potentially what's needed here is guidance to the registry maintainers and additional information that would help resolve this, not just for this scenario, but for all future scenarios that might impact the registry's Jonathan, and I'm gonna close the queue on this topic after Kirsten again. just because we should keep proceeding. Hi, Jonathan Hamill. So I I spent the last couple of days implementing the that that current proposal and ran into a few issues are are are in ambiguities because of of the use of the HPKey identifiers, particularly that the now there's, like, multiple identifiers for AES 128 Centimeters, Do you use the cozy 1, or do you use HP Key 1? particular if you're putting it into the context for the KDF. And so Those change the numerical identifiers that go into that context. it Yeah. I I I think I I haven't commented on the list, but but based on my experience, I prefer the proposal 2. 2. to bias. Tobias. Yeah. So for as someone who hasn't followed all of the mailing list activity, closely. certainly looking at the 2 proposals on face value at certainly feels like proposal too is more in keeping with how many of the existing Cozy algorithms have been registered. and"
  },
  {
    "startTime": "01:30:00",
    "text": "you know, nonsensical kind of combinations of k KDS and AEDs by having an algorithm registered using the old property, force that conversation back into an IHF forum where there can be suitable kind of review and saying, this composition of these primitives is perhaps You know? least an ideal or at least force developers to elaborate sufficiently as to why that is required, which I think would be a a useful forcing function to keep combinations of these kind of HKDS down to a limited, useful set. Paul. Pavel speaking as individual. So I'm not going to say whether I think one or 2 is better. But I had a clarifying question for a proposal too. which is what are the registry policies for adding those entries because now you're going to possibly buying people to not get what they want. Right? can you advance to proposal 2. or Cool. Cool. Cool. Cool. Cool. Yeah. So this proposal to just to be clear, This would be an algae entry that would be reviewed by the cozy registry experts, not the HPK CFRG registry experts. the guidance to them as Carsten has noted in his document gives them a lot of leeway on it the param the configuration of of the so the red line at the bottom is an example of the kind of entry we might expect Am I answering your question? Maybe so you're saying the policy is a designated expert. Yes. Okay. Thanks. Okay. Thank you. Chris Brown, watching Commons. you know, I'm even of the extent of even drastically limiting the Cypher Suites. I'm the co author of TLS 10,"
  },
  {
    "startTime": "01:32:05",
    "text": "editor, etcetera, drove that whole thing you know, to my dismay, my other co editor, atgoogle 15 years later says in order for Google support 1 to support 90% of the Internet, they had to support over a 120 Cipher Suites. Gosh. and you know, and could not, you know, could not pick any to, like, reduced from and was very unhappy with TLS 13, and I'm very happy. with TLS 13. So have to look at this from a 20 year perspective because that's how long it took before what I really consider TLS you know, 2.0 really is is what we call 1.3. And I think you do need to limit it. even as an expert in this area, I don't know how to make some of these choices. So please, not just proposal 2, but, like, make it tighter. fix, fix, Thank you, Christopher. Kirsten, Okay. It always takes a while to unmute the audio. Sorry. Yeah. I'm I'm also very much in favor of proposal too. I have a slightly different set of reasons for that I actually believe that HPKE is is a product of CFRG. and they designed their registry. in a specific way, and to properly import this into Colby. we need to be able to support what's in this registry. I mean, they should be making the the shots here, not us. And that's why I made a proposal to actually I think the current proposal, there's 4000 cyfa seeds, they're pretty cheap in in COSI, so we we can easily do that."
  },
  {
    "startTime": "01:34:02",
    "text": "that essentially cover what's right now in the registry and probably the next decade or of of other things going into the registry. So we would have cyber speed numbers, algorithm numbers, for all the combinations that CFRG has prepared for us. And if this is the wrong thing to do, I'd like to hear that from CFRG and not from this working group. Haunas, as a co presenter, I'm going to let you speak now anyway. even though I've close the queue on this. Yeah. I was just to say that, specifically, this the limitations on the Cypress rate are limiting this number of Cypress rates often comes up, but the problem is While it sounds nice in practice, it's actually nonaccomplishable because they are so many different territories all have the different preferences. So I I I wouldn't go there. in in with regard to this specific proposal, I think there's a larger debate in general for the IDF, not not for this specific document. Alright. Thank you, Ori. Why don't you carry on? But that's still a word for for the Cypress with approaching because Just having said that because -- Okay. you, Hannes. Thank you. Next slide. So there there are other issues. We talked about the next step, we'll take it back to the list. Please comment there. Next next slide. So the second topic is on encoding bank. and, again, the three letter acronym, Inc. is different things to different people. in different context, but in the context of Kozhpg, this is present in envelopes. that would be cozy encrypt and, you know, in a jwe"
  },
  {
    "startTime": "01:36:01",
    "text": "you know, Jose World where Jose had support for HBK, you might see it there. contains the output of the HPK algorithm. So it's specific to the chem that you used. Next slide. So proposal 3, just so that We're not confused on which proposals, which number, This is current proposal, as I understand it, And this is in the document today as as far as I'm aware. and it is Hank is an opaque output that is bound to the Kim, combination. So, basically, what this means is if you read the Alright. the original HPK draft, it has an API that defines how you end cap and and decap how you use ink And the current proposal is, you know, it's opaque bytes and CFRGs, HPKH, just be o opaque bytes in Cozy HBKE. Next slide. But it turns out that in the case of the DHchem, Inc. is actually an encoded public key. And so we could ask the question is is inked when a when you take HPE and you expose it in cozy as a sort of serialization, making use of the existing cozy convention, should you encode and as a key structure, as a cozy key, or as a JWT, because you know for a DHChem, it's gonna have x andycoordinates from the BH cam piece. but for Kyber or for some other schemes, it might have a different kind of structure. And so basically, this this proposal 4 says Okay. Like, you have tags that represent, I'm including a key and a header. can you use them to make it. cozy HBK experience that feels like"
  },
  {
    "startTime": "01:38:02",
    "text": "an ECDS experience in Hosey, where you would have seen an ephemeral public che cheap cheap cheap cheap cheap cheap 4 or some developers might be looking for that key representation there. for the a non encrypt use cases. So The comparison here is opaque bytes versus serialization and a key representation discuss. So asking as an individual because I suspect others will have this question as well. if if ENC is opaque and the contents are not specified do you get interoperability between implementations? Chem identifier has to define what ink is. So one chem identifier might exposed Inc. as one thing. And if you look at the recent registry entry in Cozy HB for the X25519 Kyivar Combination, Inc. is a concatonation for that, whereas, Inc. is just the a public key for a DH cam on p to 56 for that chem identifier. kirsten. I think I have a very, very Yeah. strong preference for actually doing the cozy thing here. and using keys as they they meant to be used in in KOCI. and not use the the encapsulation that is defined in the HBK direction because that that is just foreign. and we shouldn't be importing them. So we have 2 different key formats that that applications have to deal Mike, it's extra work. Mike Alsworth. So just clarifying question. The problem here is that we don't know what to call the output of a chem. Sometimes it CT. Sometimes it's and siphoned or encapsulated. sometimes it's a public eating, or I was recoliting what ENC means there. it it"
  },
  {
    "startTime": "01:40:02",
    "text": "if there is a problem here, it is that the cam identifier specify the output of this particular opaque set of bytes and If you're just consuming Kozhpg as CFRD defines it, you just take these opaque bytes and you forward them along, You write extra code to make to to restructure them in a serialization that's consistent with Hozy or Cozy, that's extra code that you have to write. but it is also sort of expressing more of kind of what it is. you could argue it's bad because the HPKE draft just tells you it's opaque, just forward it as opaque. Don't touch it. So Those are the two sides of it. So Lawrence Lundblad. When I read rct9180, the HBK HPKE specification. I mean, that is written in the form of a Python API. Right? So it's not like and it it's not even really clear which messages are Dustin for the wire and which ones are Dustin for local example, the private key, you you're never gonna put that on the wire, but that's sitting right as an argument right next to something that you would you would put on the wire. So it's it's it's a confusing specification to read, So to me you have to look at the public API that's specified in Python there and not inside the Python code that actually implements or the details of it. And we were if we didn't write this as a Python API, if it was written as clear messages. This is up to this message is this. This message is that. That goes on the wire and this is a bite 3 and all of that. we would have maybe a different view of that. So When I look at the API, I see the ink parameter as an external message defined as a byte string. So I am in favor very much in favor of proposal 3. because that's what I think the the specification intends and says, even though it's kind of"
  },
  {
    "startTime": "01:42:02",
    "text": "because if it's it's a specified as a Python API, it's kinda hard to draw that conclusion. I mean, if you're if you, you know, look at the anchor parameter, these reading the Python code, and then you'll say, oh, I see. It is a it is a key that I could do this way. But if you're just looking at the top low Python API, you wouldn't know that it's the key. So that's funny. pitch for proposal 3. Thank you, Lawrence Tobias. Yeah. I I just wanted to come back to the answer to the question given in the to Mike's query, which was you you said that the algorithm identifier defines the perimeter has been opaque. HPK, but then a concrete Kim concretealgorithm identifier, defines it further. So so how does it remain opaque even in the concretealgorithmic construction, You say that it's like the format of of a public key, where does that definition Depends on their cam. So what what it what Lawrence is saying is an accurate summary of it. If you treat ANK as a opaque message, that comes from a particular CAM ID The fact that it's a public key for DHKMs and it's a nation of information for a hybrid chem. that. Right. And and I think so the question is about format of that. Right? And whether or not that should be a a concatenation of coordinates This is a -- You can't change what it is for the HPKE CEMMY IDENTIFIRES registry FOR KIBREX 25519, THEY DEFINED that this opaque thing that I'm handing you for Kyber X Two 5519 is is this. Right. Right. Anderson. Thanks. Hi, Jonathan Hammel. Jonathan. I also ran into this issue when I was I was implementing, I was using Google's Tink Library, and, unfortunately, it actually puts"
  },
  {
    "startTime": "01:44:01",
    "text": "the the encapsulation together even with the ciphertext, So and it was kind of not It was kind of ambiguous how to separate those out. because in in the RFC for HBKE, It's just the theank comma CT. Well, is that returning concatenation, or is that 2 parameters returned, And and so it depends on your crypto library, like, in in tank. It's just one opaque block. And so further to just whether ink being opaque, you could view it as Inc and CT being opaque together. Thank you. Just okay? Hi. I agree with Robins and the and the I think HPK RFC defines a our defines are truck. ink ink for you as a a byte string. So we should we should ara. adapt or pick for big format. And I think and and also this key diaphragm card either duplicated things. So we don't we There is no need to specify these things. So we have to choose a proposed r3. syncing. honest. partially this confusion is caused by the way how the HPK specification is written. it as Lauren said, it writes these APIs, but it actually doesn't make them mandatory. expressively says that it doesn't specify what goes over Avaya is just an algorithm description, something I I confirmed with the ulcers of HBK. It's it doesn't have that intention. But if you go and sort of So follow the references. It's, of course, it specifies through various layers of references that the format of the"
  },
  {
    "startTime": "01:46:02",
    "text": "of the messages. And it is, of course, the xycoordinates. in the in the end that's that's a little bit unfortunate. in in that sense. And so there are different implementations offering different APIs, and they are nonintroperable. It's it's just bad bad design of the specification. And I think proposal 4 fixes those things. Thank you, Hannah. Mike. my accounts worth. Now that I understand what you're asking So I I think we only have one defined HPKECAM right now, and that's DH chamb. where the ciphertext happens to be a public key, but that will not be true of other, you're nodding. You're shaking. The registry already contains a pointer to a draft. I think it's an individual draft that is a combined one. So and my point is that let's not overfit the solution here to the Right. Yeah. one example we have OPake seems more future proof. Kirsten and then Lawrence, and then I'm gonna have you continue. It seems to me that that some of the discussion here comes from from trying to use HPKE Implementations HPkedelibraries. And if if you believe that that is going to be the structure of the word in the next couple of decades. that that may lead to certain conclusions But I think the the reality is that that HPG is just a particular way. to package certain constructs together. And there there is no need to assume that that HPKE will always be implemented in a separate HPKE implementation that that has output that that is opaque. So I I really don't understand that kind of argument."
  },
  {
    "startTime": "01:48:03",
    "text": "And, again, I think that we should be doing the cozy thing here. and to carry around keys the way keys look like. and not use the random opaque presentation that has been used in the HPKE reduction Natalie, Lawrence, and then we're gonna continue. Alright. So The question is how you know, RFC 9180 is some top level Python APIs that are labeled that as such, and then it's a bunch of Python code. that says how you fill that in. Now that is descriptive, not proscript dips. So you're free to implement the internals however you want. You don't have to do it in Python. You don't do all of that. exactly that way. the question is how far How far into the Python APIs do you read to know what the specification is. And if So here, we're choosing to read couple a couple layer calls down and say, oh, like, I see it. This argument is made this way, which is made this way, and it looks like a cozet key we're gonna make it a Jose key. there's there's like 10 other arguments in that. in different other Python APIs. We could read 3 levels down and say, oh, that's a, you know, that's a this and that's a that. We should encode it this week so it looks like that. so we have to make a call on what the top level API up level specification is for HPKE and stick with that. I mean, my my interpretation is is is RC 9180 says clearly how to encode the ink parameter, and that is an internal part of the HPK specification, not something to be mucked with by someone at the top at a level higher than that. So I'd still see it very clearly as proposal 4. And because of the that's the way the specification is written that's that's"
  },
  {
    "startTime": "01:50:01",
    "text": "And then I I understand it's difficult to interpret maybe, but that's it's it's it's it's That's the specification to me. That's I'm sorry. Proposal 3. Oops. proposal frame. Next slide. Alright. Thank you. Let's proceed. So So similar to the last set of proposals know, should ANTH be opaque, leave it as it is today in this specification. or or should cozy, take a part part of what HPKE is defining, and restructure it for cozy for some reason. to to apply it sort of consistently or to clarify this in the future to to help make sure implement implementations of Cozy HPKey, are not discovering this as they read the Python API and to come to the same conclusion Lawrence. I think Lawrence is sick. summary of proposal 3 is good. And so, really, this sasking, you know, Do we just leave it as it is in the document? That's proposal 3. So I understand it. Right, Lawrence? Yeah. or is there more work to be done here? Next slide. Oh, Do we have time? I feel like we need to finish this. So there's a longer list of issues in addition to those that we just discussed One of them is HPKey supports different modes and we so far have only supported the base mode, which is the unauthenticated mode The authentication which you would obviously need that would come separately outside at least in the current proposals outside of a cozy sign. or assign 1."
  },
  {
    "startTime": "01:52:01",
    "text": "The suggestion was made to actually not just focus on one mode from HP key but to actually make all of them available which includes this the ones listed on the slide, and which add then the authentication part with PSK or with digital signatures, into and the combination of digital signature and PSK. It's an open issue in the GitHub Next slide. Obviously, the The question, should we stick with what we have? anticipating that someone else will come up with that later and maybe separate document or do it right away. Next slide. That's another tricky one. the we had in in other working groups. And also in course, your discussion about what goes into these key derivation functions, there's typically based on the NIST specification, there's there's the idea that you would bind the context and the end the identities of the endpoints, entire lot of our information into that key derivation function And at least in the suit group, which the meeting will follow afterwards, we had various different proposals being discussed and also the Lam's group The same topic showed up with Kim's on what to include. And so we bounce back and forth on that topic quite a bit. The current one proposal is to put nothing in there basically sort of making out of the box implementation easier, but then obviously risking that there would be an issue because the key is not bound to the to the context The other proposal proposalist, which I'm in favor of, is aligning the the work we do other way another working groups, on"
  },
  {
    "startTime": "01:54:00",
    "text": "the content specifically with what the the lamb screw wants to do Not using endpoint identifiers, but using the context of the application providing a user supplied input and adding the algorithm information about the kewing encapsulation mechanism. So that's one. So it depends. It's probably be We would benefit from some coordination in different groups to actually have the same information included in here. The HP key specification is somewhat was somewhat silent on that topic, surprisingly, while the cozy specifications are talk about this extremely bubbosely, propose a structure and suggest or mandate this to be used with efemurals that is tphelmin. Okay. Just clarifying question. Do these parameters serve a similar purpose as the party u info, party v info for -- That's exactly it. Okay. That's That's what I thought. Thank you. Next slide. The the way COCI specifications are written it like, they have these different contracts. For, for example, the koci encrypt, Now of cozy Mac, cozy sign, and so on. And in each in the HPT specification we sort of mandate that you would use d the previously shown snippets for the cosy cosy HP key always with an outermost trackable by cosisign And so it why it's a little bit on on what was previously done with the other courses specifications. And so Lauren suggested that we would leave that or untangle that and leave it to the developer to pick and choose whatever whatever they like, they would most likely use the cosy sign or cosymacin in addition to that, but"
  },
  {
    "startTime": "01:56:01",
    "text": "specifically in light of what I mentioned previously or on the on the different modes. this might make actually a lot of sense to untangle those 2 aspects. makes sense. Another clarifying question is that kind of like supporting under the net gated encryption No. No. No. Okay. Next slide, So far, we have because the need for HPTE surfaced in with the firmwareing trip the suit work And so they are obviously we looked at firmware encryption, and so encryption support COSI tripped it was also raised that Disuke, I think he was who also mentioned that we shouldn't be implicitly focusing just on the encrypt, but it could as as well HP key, could establish keys for use with cozy MacAs 1. I I think that's fair. got 2 more slides. Yeah. be Alright. The we talked about the APIs previously, and that two sets of APIs in the HPK specification, sort of a generic API, for user protocols that use HBK derived key material over longer period of time. it is a 1 shot API specifically focused on 1 shot messages as the name indicates and In in writing the specification, we sort of board the 1 shot API semantics, but in retrospect, I think it's better not to going through this API business at all? Also, the discussion we had, I think, this it maybe was well intended. This whole API display but it's actually for what we do in probability across different nodes it's kind of more confusing. So I'm actually tempted to suggest to actually rip this out and not talk about these APIs at all. soft Okay. So being API agnostic. Okay."
  },
  {
    "startTime": "01:58:00",
    "text": "Next one. So Yeah. So we have a GitHub issue tracker. There's also one issue which I forgot to mention up here. we have 2 ways of using HP key in the document right now based on suggestions. One is the classical way where we where you have 2 layers. There's a content encryption layer and industry recipient layer, which establishes the content encryption key. that's what we had initially in a document. But then someone I think it was Richard Barnes who suggested oh, we can shave off a few bytes if we just collapse the two layers. And I think while that was great from saving another 2 bytes, I wonder whether it's actually a good idea if we Think about alignment with the rest of the cozy work Maybe that was a little bit of premature optimizations, and I'm wondering whether we should revisit that design decisions and and and indecision and tried to be a little bit lead back and not optimize their last heck out of it. And that's That's all. So a lot of op issues after what started as a simple effort. Lawrence. Lawrence. So I I I think what because a HP ke the documents to do is clarify how those APIs are used, and those parameters are as a, descriptive methodology. I mean, HPKA chose not to use ABNF CDDL or anything like that, they chose a Python API as the descriptive mechanism. And and for for better and worse. I mean, the good thing is you just got running code and you can test it. Right? The bad thing is it's an API, and you"
  },
  {
    "startTime": "02:00:00",
    "text": "you don't know what parameters or what and all that. So I think You cannot just say no APIs because the HPKA definition is in APIs. You can't just throw them out. And in this one particular in this one particular API, now there could be That's not to say that All HPKE implementations have to use this API We're just using it as a descriptive meansier. And it's to me, it's causing huge amounts of confusion because there's no clarification around this. And I think the Kose HPKE aft has to sort it that out. They have to say, this message relates to this parameter in this API as a descriptively. not prescriptively. descriptively. Seek so That that seems like the job of the Cozy HPKA GRAFT. this point. Well, it depends a little bit on how we answer the first couple of questions on how far we need to go into the into the API description, I believe. Well, yeah. Yeah. You have to say how far you're gonna you're going. That's what because the HPKE draft has to say. It has to say how far you're going. Okay. -- where you don't know. If you I need to call time. Okay. Thank you sincerely to everyone who contributed to this very formative discussion. I think, while there's some disagreements in the room, we have a basis for asking the right questions. I do wanna point out that By letting this go long, we cut off Geosecond at Buenavarco. who had another presentation he is graciously volunteered to put a YouTube recording of it, which he did as a backup on our mailing list and in the meeting chat So those taking the minutes, please include the YouTube presentation as part of the official meeting minutes."
  },
  {
    "startTime": "02:02:00",
    "text": "and I encourage people to look at them. Thank you very much. So so Special thanks to Iliari and Dasuki. for the comments on the list. Chris 1, Okay. disappeared. didn't disappear with my grilled cheese. kept on payroll since"
  }
]
