[
  {
    "startTime": "00:00:53",
    "text": "up okay so let's get started and welcome everyone to this interim meeting of the co-working group i am marco tiloka my co-chair is jaime jimenez and this is an official itf meeting so we've been recorded already uh the not well displayed here applies if you are not familiar already with it become familiar with it it's not only about ipr it's also and special about our code of conduct so please be nice and professional uh with each other that said as to the agenda for today we start with a status update on the two korkov documents under an isg review so young seabor and seed"
  },
  {
    "startTime": "00:02:02",
    "text": "we've had progress on both also an update on recent progress in href especially and discussion points on coral we have had recently resubmitted an href version and then we enter into group communication territory we have uh updates both on uh the group combis document with an open pr and the grupo score document to discuss a few selected points on a review received recently from esco does anyone want to bash this agenda today or any other comment before we start kirsten so justin how much time do you need on coral itself um i plan to make this short like five minutes just mention the mention the issues and give everyone a brief and a very short understanding of there is this point and if you have input place it there great because i'm trying to judge how much we can overdraw the encore conf and i'll make this as short as need be good thank you and i plan to take minutes most of the time but any help there is much appreciated thank you okay then i think we can start with the first item uh it's karsten uh if it works for you you can share the slides uh yourself all right please go ahead so i had to find the unmute as usual okay so i want to talk about two things"
  },
  {
    "startTime": "00:04:01",
    "text": "uh quickly and these are one slide set for economy so the the cia part is actually already the next uh gender item um so let's talk about uh car conf just as a reminder uh there there are four documents uh on the plate of the working group uh two are in the isg two are in working place called past stage but yeah essentially um it seems that there will be some some fallout from the processing of the first two documents so we we may need to rev these uh one or more one or two times to actually uh submit them to isg so i i talked about the first two and um the the plan with the isg processing was to do the discuss clearing first and the plan was to be done uh by this time but we aren't done yet and i'll explain why uh so that the yang ziba document um has cleared the discusses and as usual there is a weird status in the data tracker yeah anyway uh so this really should be revised i do need it because we still have to process the the comments uh on this uh document and that's going to be next after we have cleared the corset discuss and on corset we had uh several discusses one is remaining and of this signal discussed by rob wilton uh only one item is remaining so we are pretty far advanced but that item turns out to be rather interesting and it's not one where i thought as a document also a really document finisher um i i should be trying to make a decision here because it's uh"
  },
  {
    "startTime": "00:06:00",
    "text": "it's not easy we'll see um so um the the discuss from rob wilton uh really is not about something that that's totally core to the the yang issues here but about the idea to have this this global namespace uh the the sids the schema identifiers and uh of course these sids somehow need to reflect uh evolution of the underlying schema definitions which in our case is the the young definitions and we already tried to change the text and and cause it twice based on previous comments by by rob but that that really allowed him to sharpen um his comment a little bit so it's a bit easier to understand and so essentially the the question is uh how does the mapping between sids and names evolve for a module that is evolving so young modules have a name and a prefix and these modules can evolve they can make non-backwards compatible changes and of course the question is how do we actually evolve the sids that are attached to the the items in the the schema and the current document takes the position that the sid should be attached to the semantics of the item and actually one one interesting uh criteria here is does the sewer encoding of the item change then apparently it's structure changed and its semantic semantics must have changed"
  },
  {
    "startTime": "00:08:00",
    "text": "it's not so clear what exactly that uh means but that might be an operable definition we have in in the document right now so that's what we thought we would be going with um but the the alternative would be to to take a much more bureaucratic approach and just say sids map to item names and well if if you change the name of of the schema item uh there must have been a reason for that so it's uh uh usually also okay to change the sit with that and on the other hand if you don't change the item name then really you're expecting that item to still have a similar meaning after evolving the the yang schema so that that would be a point of view on attaching the set to item name and i probably need to add here this is about the time when the module actually has been published so there is some promise of stability with that module it's pretty clear during internet draft time we are throwing things around and changing names and so on so this this happens all the time and i would expect that when we just have a plane name change uh we actually keep the sit but this is about the situation when the module actually has been published so there should be a stable module a stable sid to name mapping and we only touch it again when we have a very conscious updating of the module revision and then we have to"
  },
  {
    "startTime": "00:10:00",
    "text": "think about how we update the city so this this threshold may or may not uh coincide with the time when the document is published as an rfc i think we have some some very different religious views on this and i'm more on this side once you have promised promised the thing to be stable then you have to operate uh on the stable side and it's not that important whether it's an rfc already or not anyway um so the the the advantage of attaching the the to the semantics is that um you isolate implementations from name changes and well yeah that's great but why would one change a name in a published module so if the name is disney then there might be a reason to change a name to avoid the trademark conflict but yeah we usually don't publish modules that have trademark conflicts uh in them so it's uh not so clear that this is a lot of a benefit but on the other hand this also means that if the semantics changes uh behind a name then we can allocate a new sit and isolate implementations from that semantic change or actually make it more aware more obvious that a semantic exchange has has occurred so andy says that uh sid to name mapping he says sit to pass mapping but that's the same thing here does depend on module revision date tuples used in the sid file so when you have a new revision date your path mapping changes and further if the module uses groupings with which is"
  },
  {
    "startTime": "00:12:00",
    "text": "a way to bundle things for export groupings from other modules then those revision dates also matter so you essentially have to have a pretty good map of the landscape of revision dates before you actually can choose the right sid or and he says if we can accept that yang files can change in backward compatible ways then the same has to be accepted for sid files and that's probably true but but rob has had some comments on that so let's go to the the alternative uh when we attach to the sid to the name we avoid a number of problems that that rob wilton notes in his discuss comment which unfortunately only went to the author's chairs and and uh isg so um i think that that's a little bit of a problem uh with uh transparency here um so sorry for for unveiling this uh 12 days after we got the comment but uh initially i thought we actually could handle this but we we it's a bit hard so um he says a controller that understands two different sid values for a given leaf because we have updated the set value for that leaf between module changes when configuring two devices then the the device will understand a specific version of the module so as a yang server a restcon server core conf server will only understand one revision normally so it's the job of of the client of the management station to understand potential different revisions of a module"
  },
  {
    "startTime": "00:14:00",
    "text": "so this isn't exactly new uh but here it would add the complication that it not only needs to understand that there are different revisions of this module which usually are designed carefully um so you you don't break existing implementations a lot um you would also have to to distinguish two different sid values so i consider this manageable but it is a burden that that we have to keep in mind so the alternative would be to uh put uh more logic into the client um i'm not quite sure whether rob really means clients here or servers here but yeah somebody has to carry the owners of the changed sid value and it can be the client or it can be the server but somebody gets gets the the uh short straw here um well okay that that's an interesting observation but by itself i think uh that um this is not yet completely uh convincing but then rob notices that um essentially what what andy said that sid is a binding to a namespace a name and a set of module revisions where this sid actually applies and of course this set will probably expand in the future uh so you cannot know the entire set you can only know a snapshot shot of the set uh up to which your your knowledge of the registrations uh actually goes and he sees a number of problems with that um so one question would be when do we actually allocate new sids"
  },
  {
    "startTime": "00:16:00",
    "text": "um yeah then we need a set we could also allocate new sits each time we change the module so we get completely new sits but then of course we uh use a lot of sit numbers and that's actually um absolutely the the inverse of what we are trying to do here um there's something in the chat i probably need to read yeah okay good so this did go to to the core uh mailing list but uh yeah this was still in in the vacation time so i'm not sure that everybody saw that yeah i'm not sure there is no need to to read it out loud yeah and and then again each young server implements a single revision the what does it actually do thank you what does it actually do with sids that actually come from a different module so this is probably just the robustness consideration again something we we might be able to to sweep away uh but really has this interesting argument here if you have a middle box translating between sets and names then that would also need to know the schema revision information to perform the translation correctly and that made me blush a little bit because i mean we are the working group here that looks about it looks at proxies and and making proxies useful uh and so on and um translating a proxy between sets and names is something that is entirely thinkable in particular if the"
  },
  {
    "startTime": "00:18:00",
    "text": "proxy is not only translating between sits and names but uh also has rest conf on one end and and car conf on the other end so it would be using names on the restaurant side and and since on the con car con so this this is actually a piece of software that that we definitely should not uh make uh impossibly hard uh to to do and this is a bit of a convincing argument for me that that making the the mapping between sids and names more complicated is undesirable now these proxies are hard to do without schema information for other reasons the the rest conf the young json mapping is not a schema free mapping so you have to know a little bit about the the schema to actually write that that proxy but i still can imagine um doing a successful uh proxy without schema revision information with with the occasional creaking at the joints and yeah i wouldn't want to actually kill that kind of product so yeah can can we can we actually reap the benefits of this more or less static sid to name mapping that that rob is advocating here if yes then we may have to weigh that against the the other benefit that mapping to semantics would provide so um i don't know if anybody has an immediate reaction uh to this but this is the the decision we will have to make uh within the next uh days and and weeks to get rid of that final discuss"
  },
  {
    "startTime": "00:20:01",
    "text": "um christine i have an immediate question here um if we if we were to stick with the sid means semantics variation wouldn't that imply that if there are two names that both apply to those semantics either would be good for a proxy to produce well the the on the way back from from the server to the client it would have to choose which of these two names to use so choosing the wrong one will will make the the client blow up the same would be true if the if the seed sticks with the name and there's just a disagreement between what the name currently means yes but the the difference here is the the sed to name mapping is something that that kind of happens as as an afterthought so people are not necessarily curating that carefully uh to to keep these middle boxes possible while the the actually changing a name or changing the semantics behind a name uh is something that would be considered very very carefully by people who were evolving a module so the module designer or the the module evolver is is actually in this picture and will make sure that the damage from from changing changing the names um is somewhat limited"
  },
  {
    "startTime": "00:22:03",
    "text": "that sounds reasonable thank you that's really hard to decide these things if when you don't have 20 implementations out there with uh implementers shouting at you um but we we have to uh yeah forecast a little bit what people actually will be doing and i think this this idea of translating proxy um is uh uh rather useful in a mixed rest conf um call conf world and we should do everything we can to to keep that possible okay let's go yeah can you hear me yes and you think so i'm just wondering is there also a problem with different versions of the modules so that you also give the complete yeah module i think a sip number and so what what if then another version of that module pops up so is that actually an issue that it needs another ship number or is that not needed well the module might need a set number actually i don't know i would have to look up whether that's the case that's a good question but still the contents of that module could could remain stable as much as possible yeah at least the way uh i've used it there was a kind of base number i think that describes uh yeah a set a set of uh sub elements uh i thought it thought it was related to"
  },
  {
    "startTime": "00:24:00",
    "text": "module and then you basically use relative numbers for these sub elements so you have a bit of compression and then the module number is kind of the yeah the number of the root that you use to the first number i was just considering if the module gets first and so would that's it also need to use basically a different base number or can it use the same base number well you normally don't see module numbers in in data node uh items right here you see that the top level of this compression tree is usually a container or some other top level uh item within the schema you you don't identify the module you identify the top level item and since this item has a namespace that namespace indirectly indicates a family of modules and there we are because we have this family on on the name name space site and we we um yeah this should uh somehow fit with the sid uh world where also the the same sid should be used for that family but you you can completely abstract the way the compression uh thing here because that that's kind of independent the compression will be uh resolved by the time you actually look at the data yeah so you can just get basically numbers for all the items yeah the compression is schema free right yeah that's right so yeah ideally you want to keep the sits uh the same across multiple versions and that's what"
  },
  {
    "startTime": "00:26:01",
    "text": "you also indicated in the slide so yeah not not not change all the sits every time something uh gets versions yeah yeah there are some some pretty weird things in the young jason world where for instance if you go from 32-bit to 64-bit numbers then the the data changes between integers and strings and so on so um i think on the restaurant side uh the the clients the management stations will already be used to to doing weird things um so i think they will be rather robust um so uh as long as we don't create a new problem for them but just a problem on the encoding side we should be pretty much safe here okay so i think we need to have another meeting of the design team but if you have a position on this it would be really uh interesting if you could uh send something to the mailing list uh why we have invented sids for for for encoding yang uh sids are actually useful as a more generalized namespace um so you you might find yourself writing a yang module just to get sids at some point in the future because it's a nice alternative to a someone object identifiers or creating new registries and so on so i would like to keep these as useful as possible okay i'm i have stolen like five minutes here any other comments"
  },
  {
    "startTime": "00:28:01",
    "text": "then let's quickly go to the coral part and i have slides for the href part of coral just as a reminder the the href document defines cris which are concise resource identifiers uh essentially the the structured binary equivalent to uniform reference identifiers which are the the one uniform resource identifiers which of course you all know and are defined in rfc 3986 um so uh we have submitted the dash online recently and and part of that actually already was discussed in the december uh interim we introduced ctdl features as a way to talk about uh more esoteric parts of this structure and we also recognize that percent encoded text in your eyes really are byte strings uh and this also allowed simplifying uh the encoding and we also remember that fragments can have percent encoder text as well so this is old now what what's new is uh we have removed the part that said cri removes any lone empty path segment so if you have a uri with a single path segment and that is empty uh this is now different at the cri level uh from a uri without a path segment and you can see that in the example here so so co-op column slash full slash"
  },
  {
    "startTime": "00:30:00",
    "text": "leads to a cri with one empty path segment as the third element of the top level array and if we leave off that slash then we get a different ci now this is maybe a little bit surprising if you know schemes like coab and http both schemes actually have a built-in equivalence so we actually have rules in the the various documents that talk about how to use the ui schemes that provide an equivalence here so these two cris are equivalent in the scheme the scheme co-op tells us these two mean the same but at the structure level of of the ui without looking at the scheme they are different and therefore it's not really the job of of the ui encoding uh to exercise uh this equivalent so we took that out on the other hand of course this means if you actually generate uh for instance co-op options from this then you have to implement the same rule that you already had for uris for cis as well if you have a lone md path segment then you leave it off and that that's actually defined in rfc 7252 so you would continue to do that instead of having the cri layer do it for you because it happens to know uh that the schemes that cri likes have this equivalent so what why are we doing this now we are doing this now because we we have been uh pushed towards looking other schemes"
  },
  {
    "startTime": "00:32:01",
    "text": "uh for instance the the gid decentralized identifier scheme that w3c is so fond of uh and so we have been pushed to into making sure that the ci scheme uh the ci mechanism is scheme agnostic and this is the one thing that needed to happen for that and while we were doing that we decided that we would want to have an appendix where we collect the weird examples because we don't want to load down the main text of the document with the weird things we want to talk about the normal things in the main text so the weird examples will be banished to this appendix and that's dash online now and what's next is making sure all of our implementations uh can do this so the the behavior that dash online uh provides uh actually was an existing bug of my implementation which is now a feature so you actually can get different output uh from uh co-op slash foo and co-op slash that foo slash um already this is uh something that was already uh present but we have to make sure that our implementations actually work with the whole document and in particular we have a pull request with test vectors and we need to make sure that these are these all work and also uh are sufficiently complete that we can give that to implementers and say if you run these then you can be pretty sure that your implementation is fine so that's where we are with cis questions"
  },
  {
    "startTime": "00:34:10",
    "text": "then i hand over to christian um yep thank you so the focus of work in the in the cri slash choral design team meetings has been serialized recently there are two um issues tracked in the issue tracker that i'd like to point out to you um they're also referenced in the minutes minute one is one that i'd like to complete rather soon that is the um the decision of whether this is all an open world or close world system uh with the proposed resolution to allow both but give guidance towards building open world systems because they work better there is an example in the in the issue that i can briefly copy paste over into the minutes as a quick replacement to screen sharing that is where did i have this open right again that is about gremlins so if you if you say something like um like this uh there is a way for feeding these and this this works by going to feed gremlins and then there is additional information that says and by the way don't do this after midnight things might go wrong if there are partial representations around we don't expect to have partial representations all the time but it could easily be that a few tools work better if they allow them so guidance would be to to rather implement things like like in the second example to say that to say at the very point in time where you say that there's a way of feeding that there are limitations and that you can only feed if you satisfy any of those and then you list the allowed times before midnight and thus can be"
  },
  {
    "startTime": "00:36:01",
    "text": "information the form doesn't get acted on at all and um so this all is failing safe if you have any ideas about these um please approach me us say something now or input it into the issue the other issue that is not as clear-cut yet is the issue of saying something about the security model this is not only about forms although it came up in the context of forms but it's just the same about links i think that we now have distinguished a bit more clearly at least in the internal discussions that what we expect to produce is not something precisely like what is happening in the web but more informed by the application that is driving it that is unlike in the web we don't have to make sense from a user clicking on the link but we have to make sense of an application saying that it wants to with these characteristics with these characterized authorizations perform a particular action now that characterization may not exactly match the the forms model but it has to in some way and put boundaries on on in one direction which authorizations can be used at all and in the other direction what assurances from the server about the or from the source of the form about the authenticity of the form data has to be provided we have a few corner cases in the issue if you have input for that we'd appreciate that um please also just have a look at the examples there and the corner cases um so that we can be sure to cover the relevant topics not in terms of um providing a full security model because that would be what ace and the walls provide but in terms of providing the"
  },
  {
    "startTime": "00:38:01",
    "text": "the hooks into which security system authorization models can be tied carson the reason why this is a problem for carl can best be explained by an anecdote um i i have this security information security class that i'm running for for 15 years now and at some point we had pen testing assignment where people were running local copies of a system that is also used at the university and try to find problems with that and at some point a student found a problem and sent a mail with a proof of concept uri that the ui was enough to trigger the problem to one of the administrators so that administrator knew about this proof of concept ui and and that was the the objective of the mail from the student and and that's fine um but then the administrator forwarded that uri to another administrator and the other administrator didn't quite know why the uri was in this mail and thought the first administrator was telling them the uri to click on it to try this out and so one administrator tricked the other administrator into breaking our course management system and of course they they were not happy and this is exactly what can happen in a choral document that one entity provides a uri to another entity but if the other entity doesn't know why it should follow that thing and and also of course what what security context it should be using for following that thing then this can be a very dangerous situation and that's exactly what we have to avoid in the context of coal and and of course"
  },
  {
    "startTime": "00:40:01",
    "text": "in the context of any hypermedia system thanks for the good art it clarifies very well any more question comments for carson or christian on cornell okay now thanks we can move on with escond group combis and esco the pdf is available for for sharing if you ask for authorization to share i think i see it let's see right if you look at the top left here slides right here [Music] you all put it on great thank you yeah so this is uh presenting an update of group combis and what we're showing here is basically working towards version 6 of this draft so i'll get started so after the last meeting there has been requests to add some more examples on particular topics especially how to encode application group names in co-op requests if you want to discover these groups and there are two open issues on that so those are the only open issues at the moment and to address this we open the new pull request so that's shown at the bottom number 32. so that should address all the open"
  },
  {
    "startTime": "00:42:00",
    "text": "points to clarify how it work works or can work and also to have at the same time more examples shown of what message exchanges can be used so yeah people are free to review of course this spool request and to check it out so here i'll go briefly through some of the content there so not all but some of it so first topic we have in section 221 and that's basically the coding of names of application groups so there we added quite a bit of examples and the structure of the section is also updated to accommodate that so there are some ways to encode the name of an application group you can have it first point in the group uri of the core request and there it can be in various places so those are the sub bullets here so you can have it in the path component query the authority component as a whole the host subcomponent or even in the port subcomponent and those are presented now in the text and there's a second class of ways to encode it is basically have it in the co-op request as a kind of add-on but not encoded in group uris or may not make it visible in the group uri so there are two options shown so you can use the uri option of uri host option for that you just add or replace that one just before sending with some custom information in this case that's yeah the name of an application group you can also define a custom or new or application specific co-op option to carry that information"
  },
  {
    "startTime": "00:44:02",
    "text": "to not have it at all on the wires and just implicitly derived based on the application context and the application software that is processing the requests so there are quite a bit of choices there so i'll just show an example here on the first one so there we have an application group name so this is gp1 here underlined and it shows up in the group uri as part of the uri path and then in the draft we now have a complete example also showing how this translate to our co-op requests with the different options in here and may be important to note here that we use as the host we need to use a hostname group.example.org so this will also well by applying the proper code parsing this will translate to a uri host option in the corp request i think we also mentioned there that often in implementations this uri host option is not there because the server normally doesn't actually use it so it just looks at the udp level addressing information and based on that it can basically derive yeah derive the correct ui host and serve the correct content so it doesn't normally doesn't need to be actually encoded in the request but for clarity of these examples and correctness we just apply it here let me see it's a question from christian is this about the current slide or uh yeah this is this is about the basically the um third bullet first third bullets first sub bullet so maybe you'll count that anyway yeah i know i i"
  },
  {
    "startTime": "00:46:01",
    "text": "was not planning to explain more about it but um yeah basically let me think about that so the question is okay how can i not be in the group ui that come in your eyes host option well it's very simple um suppose you start with the group uri and it's actually not not shown in slide here but suppose this group.example.org here is there and or sorry it's not there and then you replace it by an ipv6 literal multicast address so with the square brackets and ip multicast out so if you do that then the uri host option disappears here again so correct then you can send the request without uri host option so now the trick is you do first the translation from group uri to the actual code request with headers and then in your implementation code you might have in your co-op stack a process that basically adds it back in so it basically adds the uri host option with some custom value basically in there but but then that is the group uri then you're just providing another way of inputting the host name independently but it's still part of the group uri so i do well it might make a difference from from an api side but um [Music] yeah i wanted to say it's actually not because if you take a group uri that also means you're sending it to the basically the authority that's listed here if you use ip female v6 multicast address literal for example here that means you're not going to resolve the name group.example.org but you're just going to send it over udp to that ipv6 address so using the literal"
  },
  {
    "startTime": "00:48:01",
    "text": "and that means that whatever you put in the uri host option you could see it as a kind of misusing the right host option so whatever you put in there is not actually used to choose the udp destination of the packet so in that sense it's not part of the group you write so only added let's say in the last instance just before sending it out you can consider that it's added back in so the group uri is already defined has already been parsed and that's all done and now you can still decide to add some option in the co-op request some option that's not uh yeah basically not encoded in group uri so it could be a comment if we say here like hey wait a minute that that's like a misuse of uri host of or that's incorrect in a way then okay i can i can understand that so in that case it's maybe better to use a custom option so it's the second sub bullet so you have some specific my group option in co-op that you used in kodi group but this is why we uh yeah put put these as separate options because you can use uri host to do that and the reason is that normally that option is not used in actual co-op encoded request so normally if you send to group uri group.example.org you can basically resolve that to multicast address and then decide to basically not send the uri host option because the server doesn't do anything with it so instead you use it for something else yeah okay so we can discuss more about that uh offline so it might not be the kind of best or recommended way of doing things"
  },
  {
    "startTime": "00:50:01",
    "text": "but i think we put it in because it came up in an earlier discussions in the core working group as a way to do it so i'll now move on to the next slide um it shows now that you can also encode it in query components so there are two ways shown so you either use the entire query component so that's the top one you just have a gp1 query which is the name of the group or you have other parameters too and then you might want to use the key equals value syntax so then you have something like gp equals gp1 to encode the group and this is for the rest it's quite straightforward and all this text with examples is by the way in the pull request so we can also review it there so also for section two two three group discovery we basically have revised the text and put some concrete discovery scenarios with extended examples so we'll go through two examples here so the first one is this so given a co-op group that is known clients may want to discover all the associated application groups so what application groups are all using this co-op group and it may want to also know which servers are in that co-op group h key having some application groups so then this shows an example of discovery so there's one always at the top a request line and then there are responses from two or three servers an example so the the known corp group is in red underlined and that's where also the request is sent to using dot well known core so you can get link"
  },
  {
    "startTime": "00:52:01",
    "text": "formats results and what it does here it's basically looking for a particular resource type and within this custom application context the resource type starts with g dot to indicate the group and then the thing after the dots is some information about the type of group in this particular example for a particular application and the servers then respond back with those resources that have that type so you can usc gp1 is a light group which is supported by both surface and then gp2 is a temperature control or temperature reading group which is supported only by server 2. yeah and again this this type of encoding is you can say rather application specific but yeah we also give examples of other ways of encoding uh but i'm not showing those here in the presentation so there's no kind of as you will know uniform standard how to do that this shows another example so you have an application group which has a no name and you want to discover in the associated co-op group so it's the other way around also the service again and the resources in the group so now you start with the known in red so the basically application group name so you know the path encoding of that that's in our examples it's always slash gp slash something gp1 is here the group name so you basically look for those resources using a href query sent to all co-op nodes in a particular scope so again you get two responses here from two servers so in green you can see that also the core group is responded"
  },
  {
    "startTime": "00:54:02",
    "text": "and after that yeah you see again the the requested application group gp1 and you have a resource type also indicating the type of the group so in this application example the rt contains some information again about the type of group okay and i think we also provide a little bit of explanation in the draft uh well why this uri link returned here is an absolute uri while in the previous example it was a relative uri due to the way that link formats work and importantly once you get these responses from service s1 and s2 you can also discover what are the resources within each group so there you use for example unicast discovery that seems to be the most efficient because you can get a long list back so the idea is we just say you can use unicast discovery to find resources on a particular server for example within a particular group so using wildcard queries is one way to do that in link format so you can for example ask all sub resources of group gp1 at one particular server okay so i think these are the examples for this section and then another one added so in appendix a bit lengthy examples of message exchanges in group communication in general so a very plain example is that client sends multicast requests and then responses follow and this is what is shown here on the right let's see there's a second example uh using observe notifications with multicast and third example using blockwise so all of the things that are"
  },
  {
    "startTime": "00:56:01",
    "text": "explained in the text are now also clarified with additional simple examples okay any questions on these examples here or the previous slides if not you might go to the next steps so if there's no objection to the content we can hopefully merge this pull request soon and submit it as a version 6 draft of course once it is in version 6 we can still get reviews that's not a problem we also can do the reviews for the pull request at this moment it's still open and if all is accepted and well we can then close the remaining open issues and then we think this version 6 might be ready for the working group plus call the next step thanks here's also a link to the open issues and the pull requests if you want to check it out so any questions on this no and i don't see any in the chat either or in the minutes okay very good okay thank you dan esco thanks a lot yeah then we'll just proceed with the proposal i think here okay then we can move on uh to the last set of slides that i can present on group score"
  },
  {
    "startTime": "00:58:04",
    "text": "all right so this is also ongoing work on the next expected version 14 of the group score document and we did have version 13 uh after uh itf-112 that went through the second working group call and we have already received a very good reviews from esco thank you very much for that in two separate parts so the main comments were first mail then more editorial comments and needs followed they're already addressed and merged into the editor's copy and there's also one more review coming in soon but for today we went through uh the main points from esco and we selected a few that can deserve some um a discussion with the group to be sure that uh what we have in mind is a good direction before we start working on the document so i selected a few and this was uh i i think the most interesting uh to consider about the the format and actually the storage of public keys uh first of all we we definitely have to improve the use of terminology because right now we are using public key in two ways uh to mean both the actual public keys to verify signatures but also to refer to the the broader um container including also the public key which is uh authentication credential so for sure we will rephrase uh sections of the document to use the two uh the two terms consistently uh as we mean it uh but then the main point of esco um so thinking of authentication credentials was that um we are storing them um entirely uh to use them especially for two processes uh also summarized here in"
  },
  {
    "startTime": "01:00:01",
    "text": "the slide deriving pairwise keys and feeling the external aed for uh cryptographic binding between request and responses um so yes we are storing them entirely intentionally and we think that is a good thing to do in spite of of course the resulting storage um overhead uh in particular as they are issued by the original issuer those credentials include even a lot of metadata not only the fundamental signature algorithm but also think of issuer subject key use and expiration for the public key and most important this ensures that all endpoints here are going to consider exactly the same bytes as released by the original issuer when using the authentication credentials for those two procedures so you can see that as a trade-off between uh the storage you have to live with and and the complexity that you would otherwise run into in the finding as also you mentioned in in your review was called the the relevant subset of metadata to consider and and how to encode them in a canonical way and you have to do that for for every credential uh keep those definitions up to date and repeat the exercise for every possible future credential to be introduced later on so putting all this together a reasonable proposal can be well to keep the storage of whole credentials as of now but to explain better these points and especially clarify uh the trade-off uh that you have to deal with uh between storage and and complexity on the other side would this be a good way forward are there objections"
  },
  {
    "startTime": "01:02:00",
    "text": "i would say it's a good way forward to keep storing the whole ones because like you said there's so much complexity then you have to define this for all existing credential types and any possible future ones coming up also so thank you ricard uh there's a question from karsten uh on the chat what is relevant subset yeah defining what is relevant would also be part of the definition exercise so that this is can you just give uh some numbers here i mean what's the whole thing going to be and how many bytes and how many bytes would be would the relevant subsets maybe how much would we save well really minimally it's the public key plus the signature algorithms but then of course you have also to define the the encoding you are interested in for that subset and as far as understand all this is is relevant or applies to um edo just as well with similar considerations i believe so this could be done in less than 100 bytes probably okay [Music] that's behind the queue uh i think esko was first yeah i'm not cute but i'm just thinking uh maybe i'll say something so we we had some prior work uh hit that point for uh x549 certificates specifically so there was well you can have the whole certificate and that's uh for constrained implementations yeah we usually ended up somewhere between half and one kilobytes for a certificate"
  },
  {
    "startTime": "01:04:02",
    "text": "so that's the complete credential and from that you can for some cases you can all only take the public key part and that was needed to yeah put in a field of a particular bootstrapping protocol that was the context of the brewski bootstrap protocol so the public key is you can say a smaller subset of the certificate and don't recall how much it really how much the public key was takes five nine including the yeah signature algorithm and such so the format for that once once you agreed it's clear but you have to really be very precise in specifying it because we ended up with three different understandings of how it could be encoded so it's just taking a very particular part of bytes from the x59 certificate but you have to know and define exactly which byte so it doesn't need to be uh specifically defined something new but you need to define it as yeah in a very exact way to to become interoperable i'm not sure about the size though it's probably less than 100 bytes i think but i don't remember that i can look up some examples yeah michael is also suggesting in the chat it's around 200 bytes for ecdsa certificates and more for rsa yeah so the ones i've been working with the interrupt work is like mostly 500 to 1000 bytes in that area depending on what you put in uh sort of depends on yeah what people choose to put in and how long the strings are etc so the public key is much shorter"
  },
  {
    "startTime": "01:06:01",
    "text": "than that but yeah that was i don't recall the size i think it should be less than 200 bytes but let me check thanks you're on yeah i i think what might need to be stated in the draw in the draft and also i mean for this discussion is i mean the relevant subset would wouldn't that if you have if you know what the relevant subset is couldn't you choose a credential if the sort of if the storage limitations are really strict couldn't you choose a credential that contains essentially the relevant subset so so i mean if if you only need the public key is that if that is the real subject maybe the entire x509 is not the right credential and um yeah yeah you don't maybe no need to store but maybe for some applications you do need to store the entire credential for proper authentication because if you only store the public key well you only know that hey this is a trust device that authenticates but you cannot link it to any other information of the device like okay who was the the vendor or what role does it have in the current network deployment or which authority yeah basically which name of authority uh created that certificate all that information is not kept but i was thinking for the purpose of oscor you ideally you you might want to use a data item for public key that's as small as possible"
  },
  {
    "startTime": "01:08:03",
    "text": "but yeah there's some problem involved in defining it like that's also on the slide so you you would need to define that for all the yeah for every type of certificate that exists or every type of credential and to give more context that the exact authentication credential to using a group is up to the side for a group administrator creating the group and and this is then ultimately enforced on the group manager so it's not something that the group members really negotiate so probably it's a good thing to to thing from the start considering the kind of deployment i'm going to have is just better to go for this authentication credential type considering the impact you would have on storage you know what you were saying is that the group manager can also select it so what if it selects a subset of the certificate and deploys that to all the nodes would that work it is practically enforcing what uh decided by a human being as an administrator of course but yes it's the group manager authoritatively saying this group works this way this is the authentication credential type used here yeah but maybe it doesn't need to be defined then in uh score group draft just no no no this draft is just listing some examples of possible credential types to use yeah yeah i just give some recommendations that that for i think for the case of x 509 certificates it it needs to be minimally the public key and the signature algorithm that those are already encoded as one element but it can be more i think based on what the group manager decides there sure that's up to the issuer of a"
  },
  {
    "startTime": "01:10:02",
    "text": "certain credential of a certain endpoint what that contains thing is any other endpoint should should take it verbatim to store it as ease and use it as is no okay then i wasn't that's why you were saying that maybe we don't need to say uh in this draft like it needs to be the entire x five or nine certificate it doesn't need to be then apparently sure the entire credential is issued uh whatever it exactly contains when it was issued yeah okay yeah but i think this is it's a good comment that's gone this needs to be clarified in the text exactly what is the what is the role of the credential and and what is the possibility to decide on that who i mean who decides on what credentials being used in in this setting yeah it can be a custom format as well defined by the group manager sure not necessarily something standard [Music] okay but if you're just asking the question about sizes here if so the input from michael was that certificates were around 200 bytes then the the public key would be and signature algorithm would be less than half of that so i suppose that's not the major uh hurdle those 200 bytes compared to the one kilobyte you were talking about yeah i think it depends on the group sizes so if you have a constrained device and uh let's say you're 50 group members and then 50 kilobytes yeah still i don't know might might be rather a lot depending on the platform of course yeah if you if you need to communic everyone needs to communicate with everyone else"
  },
  {
    "startTime": "01:12:00",
    "text": "typically maybe there is the just the in this multicast session there and maybe not everyone is there yeah i understand one two or three uh clients basically yeah that could be yeah yeah that's right yeah can also be okay so it seems like overall this direction here is good enough to consider for a first draft revision so keeping overall this approach but clarifying a lot on the details and the trade-off yep sounds good thank you for the input yeah the second biggest comment i i selected was um i mean it looked to me mostly as a request for um clarification on why we are doing a certain thing and how it helps we introduced something uh last year in the draft out of a suggestion from christian basically when a certain endpoint joins the group it receives from the group manager the the current group id using the group say g1 and and from then on uh that group id is going to be the birth gid of that endpoint and you can apply the same to any other endpoint so of course for many different reasons the group manager can rekey the group that can happen multiple times and and every time that happens the group id changes now uh the details here depend uh a lot on on the specific policies the group manager um considers for picking up a new group id and how that is uh formatted encoded and so on but at some point the group manager will run out of available group ids that"
  },
  {
    "startTime": "01:14:01",
    "text": "have never been used before and it will start to reassign already used group id values in the past so until last year or so we were actually forbidding this because that was going to create a problem in the security of very very long-living observations but uh christian suggested to introduce this concept of birth gid which enables to uh safely recycle group adi values so to make the group live forever in principle um while not incurring into any unsecure long living observations and the trick is that if the group manager is going to rekey the group and assign a group id that coincides with any birth jd of any group member well then that group member is also going to be evicted in that very wrecking process so that evicted node will just have to rejoin the group uh basically becoming a new endpoint and when doing so it terminates its observation so solving the the original problem we had by construction and all this is summarizing in a very short single sentence that i quoted here and we intentionally did not explain any of this in detail we didn't and provide an example because it sounds a lot like discussing design considerations that we did have but maybe it is useful to to add more explanations about this instead and since security aspects of observation uh are involved here uh maybe the security consideration sections um is a good spot uh what do you think about this way forward and yeah for me um as a well making this comment uh"
  },
  {
    "startTime": "01:16:00",
    "text": "i thought it was really complex and it seemed to be for for a case that that will not be reached in practice like running out of group group ids how how could that happen basically um how many group ids are there that that's maybe the question so if you want to do it and if it's really a kind of a corner case that normally you don't run out of buddies and i would do something like this maybe yeah in a separate section or maybe appendix or so now it was really at the front of the draft and to me it seemed quite quite complex and confusing so you want to keep a note as a group member and then you still need to evict it for this security reasons it wasn't all too clear why that's why that all needs to happen so maybe it needs to uh say like okay well if you if you want to ever reuse a group id so normally you don't do it but if you really really run out for some reason then you need to look into that appendix and then do us there otherwise you can also build a system that does not allow to you reuse group ids right so just yeah isn't that possible that you say just if a group manager can just evict everyone from the group and start to basically start counting uh change yeah use a new group id again or maybe reuse one start with one for example and then just provide new key material for everyone isn't that also solving a problem then before i speak people are in the queue yeah i just wanted to quickly say don't don't put in a mechanism that will never occur in inter in job testing that will never be exercised that will that be implemented by a number of"
  },
  {
    "startTime": "01:18:00",
    "text": "people uh we need to make sure that the the parts that uh actually make the protocol work are also parts that are being used a brief note on the topic of of running out never happens um this depends on on how large gids you want to afford so if your group if you just accept very brief gids to not let your messages exceed some bound then you might say have a liberal for a nibble for the group identify for distinguishing different groups and another liberal for counting your counting your rekines or say a byte for each and then you can realistically run into that condition uh i agree that we can it might be a good idea to have some servers that just say yeah we don't we can't do arbitrarily short group ids and we just never rekey but this is something that the client doesn't need to have an active part in so the group manager can just do that um i'm not even sure if it's so much of an interrupt concern because a device being kicked out is something that can happen and anything else happens just as in that case yeah sort of you're saying the complexity is only on the group manager so if the group manager wants to provide very small numbers then it also needs to do that do that extra work like either kick everyone out or kick out the notes with a particular birth gid yes yeah but okay i'm just saying that for a reader this all this text it seems rather complex arbitrary and scary and you might want to not have that in front of the draft yeah i think we should definitely give more context around this um in that section already and then maybe as a"
  },
  {
    "startTime": "01:20:01",
    "text": "dedicated appendix but a main input i i got from you before esko was to say that um a group manager can potentially actually enforce a policy to never recycle group ids actually and well in that case when the possible values are possibly finished the group is shut down and and that's it right yeah that can also be okay kind of the easy easy way out in a way or completely re-established the group with new key material right that should work so that was actually the original case so we use this thing to to make it possible to do something better but but i understand it has to be something optional not just part of the picture necessarily yeah indeed no no it looks really like uh a main part of the protocol and maybe that's not not how we want to have it it's more like optional thing that group manager can do to improve for example these long lived group memberships and observations too okay so a group manager that plans to recycle group ids can use this mechanism to allow observations to continue basically and yes all the logic would be on the group manager nothing really changes on the group members yeah might also be other benefits besides observe notifications because not more than every application they have observe active i think but could it be benefits that that's yeah you don't need to for most members you don't need to change the key material for example or it can just keep working without interruptions all right noted and i see you're agreeing also"
  },
  {
    "startTime": "01:22:03",
    "text": "okay so these two were the two difficult points i i'll say uh what remains is easier but still important to check with the group sooner than later um yeah we have a section 10 mandatory to implement compliance requirements exactly the same title and purpose of the corresponding section in the edoc document in lake by the way and i got from one comment from esco that um a title like that suggests uh the reader to expect only text uh using is mandatory to or must and shell well instead we also use non-normative statements and should recommend it and what the text says now is basically would you actually mean to say so a good fix for this that uh i agree it does require fixes would be to simply change uh the section title to implementation compliance because i think that's what we have meant all along and that will still include both actual mandatory to implement requirements but but not only would this be good yeah that sounds great okay that was actually easy and then there was a cluster of doc sorry of comments about references that are now informative but used in a normative statement so to say and the few things uh clash also considering guidelines from the isg that esco's review uh quoted so i selected uh only a few of those uh most interesting ones uh in the security consideration the there's a draft from from john in cfrg um about reintroducing randomness in deterministic signature um schemes"
  },
  {
    "startTime": "01:24:02",
    "text": "and now we are essentially recommending uh normatively to use the draft uh if elliptic curve signatures are used um and to reply on a detailed point uh on the the optional use of this thing and similar things um esco i understood from that draft that if it is used it works also on verifiers that are not supporting this and this approach themselves so it works asymmetrically which helps out but still your point remains um so good options here can be um first of all keeping the reference and and informative but then doing one of the following uh simply switching to a non-normative recommended or and i think it's better uh rephrasing uh that part of text altogether to still recommend normatively using approaches to reintroduce randomness but present in this particular document as an example for doing that carsten yeah instead of making a more or less normative statement you also can make a factual statement that says oh by the way when you use this then you avoid the following security considerations you freeze your points in a different way yeah i'm trying to say that you don't have to have a normative semi normative statement in there you can simply say by using a scheme like this you avoid a number of problems you will run into otherwise yeah okay this could be an option three uh here to do that sounds good also sounds good"
  },
  {
    "startTime": "01:26:06",
    "text": "any more you're yeah i i have a little slight problem with number two there i i think it's we would like to if we want to recommend something we like to actually make precise reference because things might go wrong and i mean in this particular case this draft is a little bit stalled because there are some considerations about how to do this right so so we can't really formulate the statement of this draft and we shouldn't do that as in sort of as text we should we should either point something um that is uh agreed and ready or we should or we think that we become become the the right way to do it or we should not do the normative recommendation i think so carsten proposal address your concern then yeah except that it's not really clear what is the i mean in this case what because this is this work in progress so i'm not sure being formulated at this stage exactly what what properties we gain which would be the which would be nice of course we could say that these are the properties you gain or you get i think i'm slightly in favor of number one here uh because they're then pointing to a working work in progress document um without um binding us to to do exactly this yeah the the problem really is that if you would change this like in one and the next thing the sg will do is change it back"
  },
  {
    "startTime": "01:28:00",
    "text": "so you haven't really won anything so this is just trying to reduce the the likelihood of an accident where in the end we have a normative reference that that keeps this document in the rfc editor queue for half a decade or so oh okay so how about doing as carsten propose but not formulating what we get but rather for making the problem and i mean we can get back to exactly how we formulate it but saying to avoid this problem uh there are there are various techniques and here is one example yeah i think that's what carsten was proposing okay i think that that euron has a point here um i what i phrased right now was making a factual statement of what this graph does and that's of course difficult because the draft might evolve so any factual statement about it is fundamentally broken so it's better to say that that technology is being developed right now uh and simply reference that that document but not say something about what this document does but that the technology is being developed to do this and the this is the class of problem addressed yeah yes okay yeah that sounds good great okay on the next second from last point it's a similar thing it's still the same cluster of comments it's about the ace group manager defining that draft right now here we are recommending it normatively i i think this uh this can be addressed"
  },
  {
    "startTime": "01:30:00",
    "text": "easily by just uh keeping this an informative reference but relaxing the text around it to simply put this as an example of group manager uh to to use uh still uh having highlighted the features it has and that would be it would be good or objections yeah i think uh relax you mean uh not not using the capitals all right and and phrasing it explicitly as just an example of group manager yeah and that's it and and it's fine actually we should have done that from the beginning probably okay yes the reason to keep it informative is that you have less yeah wait waiting time on that or well that document is pretty much aligned with this one at the moment in terms of process but but still it's probably an overkill to have it as a normative reference or used normatively so okay yeah i can agree to that yeah okay uh last but not least and not uh long story short uh he would be about promoting everything related to echo request tag to be normative so right now the the reference is informative it's mainly used in an appendix as an example way to do challenge response synchronization and it's the equivalent for groups of an appendix um of all score but last year the the use and the importance of the option in group score has raised still not mandatory to implement but it's intentionally recommended method not the only one"
  },
  {
    "startTime": "01:32:00",
    "text": "to solve another issue uh discussed in the in the document body so putting all this together considering also the the status of the uh echo request document now it makes total sense to make the reference actually normative and and have the appendix becoming a section in the document body i think any objections to that you know that sounds good i thought you also had it as a must requirement at some point in the text uh that that's in the appendix itself and by the way we saw that in in other similar and known appendices uh this is maybe a big controversial point but if we make that appendix a section altogether uh there'll be a non-problem okay yeah okay since we are in our time already uh i'm done and we need to start actually working on these comments but it was good to have any feedback on those and we'll process more comments as they come and earlier today i posted on the list a detailed reply to esco's review so possibly we can continue there too and yeah we hope to have version 14 submitted before the next itf meeting thanks a lot tesco great review thank you indeed great thanks okay and again since we are over time if there's no very last point anyone wants to raise uh we can close the meeting and meet again in two weeks okay thank you thank you very much everyone thank you for helping with the minutes bye-bye thank you everyone"
  },
  {
    "startTime": "01:34:01",
    "text": "bye"
  }
]
