[
  {
    "startTime": "00:00:09",
    "text": "all is good oh thank you very much hello there you go like the mic stand s foreign yes"
  },
  {
    "startTime": "00:02:07",
    "text": "foreign some job yes itself thank you"
  },
  {
    "startTime": "00:04:26",
    "text": "all right we will get started in a minute we're waiting on some elevators for some people foreign that's a good way to think of it all right we'll give it about 60 more seconds and then we have a fairly packed agenda so we will started chucking through there foreign"
  },
  {
    "startTime": "00:06:11",
    "text": "welcome to mask at ietf 115. this is yet another session that is being recorded uh at this point in the week you probably uh know how to do this but if you don't use the QR code over there to bring up the on-site tool if you're in the room if you're not in the room and you're hearing this you've already figured that much out and uh you can enter the queue by raising your hand leave it by lowering your hand and when it's time to speak please do speak State your full name before speaking this is the ietf note rail please take time to read it these are the terms by which we participate in the ITF also note that this includes a code of conduct so please be respectful of each other if you're in the room we also have a mask policy at iitf115 so you need to be wearing a mask at all times in the room unless you are actively speaking into a microphone we have some fun helpful links notably we've moved jabber over to zulup if that link doesn't work let me know and we'll go figure out a better way to link to it thank you and we have an absolutely packed agenda for today so we're going to start off by talking about our remaining working group document which is connect IP we're then going to work our way towards discussing some proposed text for a recharter and on the way to that we're going to run through a fairly long list of other proposed extensions and additional work and part of the goal of this is to take a look at these items and say where do we draw this line where do we say yes these are things that we want to be in scope and which things do we want to be out of scope so we're going to take a quick tour through a long list of things some of which we've talked about before and"
  },
  {
    "startTime": "00:08:00",
    "text": "we'll talk about those a little more briefly now some of them are new before we do that however uh connectip is our last remaining item because our first two items are now actually rfcs so huge congratulations uh 9297 is HTTP datagrams in the capsule protocol and 92.98 is connect IP which we named proxy and UDP and IP and http so very nicely done thank you to everybody for all of the awesome feedback and super hard work and yeah let's uh give ourselves a hand with that uh Alex I believe you are up with connect IP ad yes I can I granted your request but I can steal it from YouTube if you want that works too hello everyone can you hear me okay um excellent I am Alex tremachowsky I'm one of the co-authors of the mass connect IP draft I expect none of you are surprised to see that we are presenting this today because we've been talking about it for the last couple of sessions next slide please um so I wanted to start out by talking about our progress from the hackathon we had a very packed two days in which we sat next to the Erickson folks and some of the Apple folks who were working with us and we managed to get a every client that exists talking to every server that exists which is amazing news because at the beginning of Saturday morning this entire Matrix would have been empty um this is very cool um unfortunately our friends at Apple did not have a server implementation for us to test"
  },
  {
    "startTime": "00:10:00",
    "text": "against which is why the Apple column is all gray boxes but you know given the fact that we had three clients and two servers I think this is amazing progress next slide please um so what actually enabled us to get here is if you actually go and look at the GitHub issues prior to this session uh at the end well sort of two weeks after ietf 114 in Philadelphia we had about seven issues that were open and we were discussing um as a result of that meeting and I am very pleased to say that all seven of them are currently closed meaning that there are no outstanding issues on the draft um so I'd like to go through and detail what all of these different changes were next slide please um so the first thing was around MTU one of the things which is very interesting of course is that MTU tends to be both a hop by hop but also end-to-end property and when we add all of these different layers of encapsulation we are of course are taking away the MTU IPv6 of course specifies that we want to have a minimum of 1280 byte MTU so we have some interesting questions about what to do if you cannot cannot support that so one of the things that we added was some text that clarified that the icmpv6 method that we described that was previously optional must be used when intermediaries are in use unless you have out-of-band information but the path MTU is sufficient we also added a bit of text that says that you must abort a connect IP stream if the quick MTU does not allow sending 1280 bytes if you're using IPv6 so this basically clarified a whole bunch of different edge cases that previously were there um of course if you want to use streams that would be fine you just can't do this over datagrams next slide please we also clarified some details around some icmp errors so previously we just"
  },
  {
    "startTime": "00:12:00",
    "text": "had a small paragraph in the document that said go look at RFC 4443 and didn't really provide any additional information as to how you would actually use the information in 4443 in these contexts so after working group pointed this out we went back and added some text that said you know go look at 792 look at 4443 and here's some specific guidance on which error codes to use when for example you get an invalid Source address or an unwritable destination or practice cannot fit inside the MTU um we also added another clarification which is one that came up from Philadelphia um last session which was what happens if you're using iproto scoping with connect IP and you haven't asked for icmp packets um we've said well you probably should you should ask for icmp um and we also but you also need to be prepared to also receive them if you're not using any route advertisement capsules then there are some recommendations in the text for how they connect IP proxy should go and actually grab out those signals directly to learn those error codes so that again helps handle how a whole bunch of Errors previously were a little bit ambiguous about next slide please um another feature that was added which was found when we were working through this as a previously connect IP the address request capsule basically provided a mechanism for you to say I want this specific IP address or this specific subnet but it didn't have a way for easily specifying we'll just give me an address but it turns out this was already something we had planned ahead for but we had just forgotten to write text on you basically go and request the all zeros address with a subnet mask of the desired size so for example if you're an ipv4 and you want an entire slash 24 subnet you would ask for 0.0.0.0 24 and the server would give you back some slash 24 if it had one available this is obviously much more"
  },
  {
    "startTime": "00:14:01",
    "text": "usable in IPv6 land than it is an ipv4 land but hey you can ask for individual addresses the same way um as always a mass connect IP Server doesn't need to respond to you successfully with this request it is always allowed to say well I can't satisfy that but at least within any address assuming that there's actually IP resources available we should always be able to give you back what you ask for next slide please um another issue which was quite contentious at 114 was the cross product of the fact that you can have unsolicited address assignment capsules be sent but also that we don't necessarily guarantee a reply to any sort of uh IP address request capsule and also what happens if you need some address which you do in order to send any amount of packets and Martin Thompson rightly pointed out that this probably means you have to wait for a timeout in the current scheme in order to be able to start sending your first flight so after a lot of back and forth we concluded about the best way to fix this was to add requests and response IDs to these capsules so that that way you can tell which address assignment response correlates with the different requests that you send so now you can easily tell apart oh the server sent me an unsolicited address assigned that I didn't ask for so I can only start using it it might not be the one I asked for but hey I can do something so now you don't have to have a timeout in order to wait for some addresses sign capsule that will never arrive for example next slide please another thing that was brought up was do we want to split the address request and address assigned capsules which currently support both V4 and V6 fields in two separate capsules and after a bunch of discussion amongst uh contributors and the editors of the draft we basically concluded that they didn't seem to have any benefit to do the split so we decided to leave it as is"
  },
  {
    "startTime": "00:16:00",
    "text": "uh next slide please so um at this point you probably realize that we went through this presentation fairly quickly because no one has come up to the queue and asked questions which means I have a question for the working group which is uh do we think we are ready to proceed to working group last call um I personally think that we have made excellent progress we have no open issues and I'm not sure what else we could do so if anyone else would like to go into the queue and offer an opinion I'd love to hear it David schenazi mask Enthusiast with an opinion the yeah the the draft was in good shape we made like really good progress at the last ITF um and we were all thinking well yeah the text wise this seems good but you know um let's see if it actually works before we go any further and it was quite great at the hackathon uh this weekend to see that like some of the design choices that we made ended up being even better than we thought so for example the like let's just use icmp version uh we realized that we got that feature for free because we have the kernel taking care of that for us so that was kind of nice uh of like why are you sending me this oh oh that's an icmp packet oh great we don't need to implement anything that's automatic things like that uh and the oh what's going on here with anyway so we're pretty uh I'm personally very happy with where things at I think maybe the editors can do an editorial pass before uh we launch the working group last call but maybe that but I think that's the only thing there aren't any open issues and that'll be a good way to motivate people to to read the draft so maybe give us a few weeks to do editorial work and then we're ready for that I think and I will also say the hackathon almost all of the issues that we ran into on interop weren't on connect IP they were like oh you screwed up your Linux routing firewall or oh"
  },
  {
    "startTime": "00:18:02",
    "text": "your certificate's not a valid x509 search which is you know the best kind of problems to have things that we should have been able to fix going into it anyway yeah I think we had one instance of oh right you didn't update to this version of the draft for the capsule types and then everything else was iptables die die die um but then we got it working foreign Google and uh maskady um thanks for your uh to everyone for the diligent work on this seems like you're very efficiently you know solving the resulting issues um I wonder if this might be a good time since you've figured out how to spell everything to um maybe do it early into area review So to avoid issues coming up in ietf last call I mean I'm fairly optimistic that it'll be fine but um it's always a good thing to get it done yeah that would be fine thank you for the recommendation Martin you know we can run those in parallel Lorenzo is up next uh lorensically the Android um so I haven't read the draft I was just reading it now yes shoot me now but that gives me a unique perspective of being able to ask a generic question um the question is this um it this feels like a really sort of like the level thing low layer thing and one thing that we have unfortunately in Android is that applications use the BSD sockets API very extensively and there's a lot of warts in there like dual stack sockets and you know automatic assignments on buying a lot of assumptions that apps make my question which is super generic is has anyone looked a little bit at how to map the sort of semantics of the system calls that apps use like bind or connect to this um this is very packet oriented right um thank you very much that is an amazing question um so there's two ways to use connect IP"
  },
  {
    "startTime": "00:20:01",
    "text": "um the first of which is this is more like a traditional VPN with a virtual Network device where the individual applications don't have to worry about this and in the case that we have today which is I think um how you know one of the Google implementations that we interoperated with worked it like literally brought up Linux 10 devices on the client side and basically you know we didn't actually do net link to set the routes but you can go and you know set your routes to go through this device and all applications which were making requests are handling responses naturally have their packets flow through this device by the kernel so you assign an IP address and everything at the beginning and then you just leave it absolutely it just shows up as a regular Linux network interface so none of the apps have to know that this happens to be backed by connect.p the other way of using it is when you're doing more direct flows yourself which is where a lot of Ip protocol scoping and a whole bunch of other things happen where for example if you have a user space stack which is already doing packaging such as a quick stack and you want to do some sort of interesting tunneling you can use that mode directly and you don't necessarily need a ton device we implemented that as well where we know we were going and doing fetches of you know example.com directly encapsulated through a mass connect IP stream but that usually requires that your application is actually aware of that mode oh yeah so it wouldn't be great for TCP you would need to have like a user space DCP stack if you want it to work that way but but this is by Design oh yeah that's why we have connect and connect UDP as well I'm sort of wondering how yeah I guess in the second mode I guess the first mode yeah it makes sense I guess the second mode I'm wondering is look you know do we have for example like how do we know that anything using a BSD sockets API that this protocol is is expressive enough to to support that do we have like an app that like like an old trivial app that was tried like you tried to Port it right like you you took all the instances of bind or connect and try to but I mean it's just a question maybe you didn't do it and maybe that's okay yeah so uh the short answer is we didn't do exactly what you what you were suggesting but we are running like a quick stack over that mode and like it was fairly easy at least on the Google"
  },
  {
    "startTime": "00:22:01",
    "text": "implementation I'm not sure on the Apple or Ericsson ones because I wasn't working on those to go and have an encapsulated packet writer that went and did all the things without any sort of difficulty thanks all right Tommy you're up all right I think I'm next up um so just to the question here I think yeah we could do last call on this I think we could do it on the current version I don't um I don't think we need another pass necessarily and definitely agreed that doing indaria review in parallel would be good um one thing I wanted to mention here just for the interop was that this was also a really good opportunity to I think for the first time between a lot of these stacks do a real capsule interop with non-trivial capsules back and forth you know I know we already shipped the capsule protocol RFC um but at least I was not aware of you know this level of really using capsules in some of these protocols so I think if for nothing else doing the connect IP work is a good way to exercise that and prove that that's part of the stack works um and then to Lorenzo's question um I just wanted to mention so the testing that we did from the Apple client was all the like per flow stuff not the interface level VPN so you know we we do have our kind of like quote-unquote modern socket replacement apis that have a user space IP stack and so they could easily work with this directly um and then on Apple platforms uh for BSD sockets we've had a way to bridge those um for quite a while as like an"
  },
  {
    "startTime": "00:24:00",
    "text": "application Level VPN and divert those over to a process that can do a modern proxy stack so I don't know if Android has that but we were able to test with those cases where you have a app that doesn't know anything about it and just opening up a socket okay David scanazi um mask Enthusiast um first off Tommy thank you for starting your day at 1 30 a.m to be here really appreciate it um so some some thoughts on this uh Lorenzo the the oh well first to Tommy's point we had some non-trivial interoper for uh capsules with web transport so we had that before we shipped that RFC and we kind of helped us establish uh that at least in the Google implementation of chrome and with somewhat transport servers uh like um twitch if I recall correctly but anyway having more is always better um back to um the uh connect IP and the mapping to BSD apis the way I've been thinking about it is Connect ipfits into a suite uh and if you look at the BSD API which is you know in practice what apps use or you know the for the other more modern better apis like what Apple has they you know inherited the security properties of the BSD API which is an app running on your phone can open a TCP socket again or a TCP connection it can open a UDP Association uh but it can do create completely a raw socket uh and so the idea is if you want to map that which you know for Mass privacy proxies that we've been like are looking at implementing the idea is if the app"
  },
  {
    "startTime": "00:26:00",
    "text": "wants to open a TCP socket that gets mapped to connect which has the very the very same semantics as TCP and you can do that with a collaborating app where the app just calls an API that does that or you can do it in a non-collaborating app if you have kernel apis that allow you to hook in at the flow level uh so Android doesn't have those pretty please that would be a great feature to have any Linux kernel hackers around but apple has a way where you just hijack the flow and like you get the calls and user space directly from the socket it doesn't involve the TCP stack at all which is a great way to hook from a TCP socket of a non um uh an app that doesn't want to do this you can just drag it kicking and streaming in a way that's really efficient because you don't have to involve the atcp stack at all and same for UDP you can use connect2dp and connect IP is kind of the pan at the bottom to catch everything else so if the app like wants to do icmp for example on bsdos's you can do ping as a non-root user and I'm sure other use cases connect IP is for those so that's kind of the way this all fits together at least in in my mind and when you have a user space um uh networking stack like apple does you can do that all inside that stack where you can swap out your TCP stack for your connect machinery hope that helps yeah thank you I I actually I try to click the button to lower my hand but it didn't work so I'm still in the queue so but uh maybe you can boot me up but uh I guess one one sort of concrete question I'd ask is for example like the BSD sockets API has a concept of being able to bind to a port and it provides certain guarantees like for example um unless you go out of your way to say that they can no other app can bind to that Port so in the town scenario fine you know that the kernel deals with all of that you just you know that the"
  },
  {
    "startTime": "00:28:00",
    "text": "kernel stack will deal with that but um in the um sort of um more direct access and I don't know what you call it but you know an app would be able to you know it sounds like it would be able to like send their arbitrary IP diagrams right and and then in that case right like how do you provide a device like let's say a phone with egress to the internet um without requiring like you know like how do apps collaborate like do you need to give every different app its own IP address for example because you don't have you know Port mapping things so yeah um so there's there's a couple different ways to do this um so one way to do this would be some additional extensions which we we have discussed in the past and haven't yet decided to do to allow carving up the port range spaces um we basically decided in uh the working sorry in the design team beginning of this year I think it was the beginning of this year that we were going to basically um handle when connect IP initially anything would just in the IP header and not anything we're using the TCP or UDP headers Downstream but it is totally possible to design an extension to allow carving up for example the port range saying so you can say I can request ipro.tcp and then have a request you know Port wrench 10 000 to 11 000. um that doesn't exist today that's definitely something that someone they were excited about it could write up the other way of doing it is imagine you can do a link local IPv6 address and then you know Nat on the connect IP proxy service word you say that um like so you don't necessarily have to egress with the same IP which is assigned to the inside of the tunnel um yeah okay no that that I understand that I want one point to David to your point um much as I would like it to be different the Android sort of Kernel timelines or seven to ten years it's depressing but that's how it is so uh in terms of you know getting a feature to to the fleet"
  },
  {
    "startTime": "00:30:00",
    "text": "so yeah I'm relying on that to to to deploy this is maybe not gonna but anyway yeah so anyways that that it sounds like the primary case was like out of the tongue case which seems like well specified and basically functional at this point and a sort of like a single tenant kind of thing where you give a an app an IP address and so for V6 you could have where you whatever 50 apps on the phone they could each have their own IP address and they could use IP connectivity um for V4 yeah I guess you wouldn't you I guess you could use that yeah okay anyway thanks that does clarify it's sort of a kind of out of scope right yeah the other thing I quickly like to add is to emphasize something that David said earlier which is that connect IP is like you know the catch-all for when you want to do something that is not already handled by connect or connect UDP we expect that 99 of the different use cases of an app wants to do something TCP related or UDP related scope to a specific Port is going to be handled by those existing specifications that we have so if I can write a webrtc client with connect UDP a combined um uh based on drafts we have today yes you can bind to a specific point I believe um I don't think we have listened yet but I think that's actually on the agenda for this week thanks all right I see miria you are asking for slides ah I will decline that request then cool all right so it sounds like um we're gonna spend a couple of weeks doing a quick editorial pass and then we will go for a working request call as well as requesting interior view in parallel wonderful thank you so much thank you so much all right next up we have proxim listener UDP and there we are all right hi everyone"
  },
  {
    "startTime": "00:32:00",
    "text": "um my name is zabi Singh Google and I'll be presenting the connect UDP listener today um so since our last presentation that iitf114 um we've made a few changes but most of them are editorial ones next slide please um so what connect UDP is right now is it enables connected udb sockets um so the proxy can send and receive from a single Target specified in the path field of the connect header but what if we wanted more tuples next slide please take for example um webrtc like in this basic topology the clients are paying a stunt server um next slide please and then a peer-to-peer connection is established uh here between Bob and Alice so they can have a very important discussion about their favorite cat videos next slide please so the same uh topology of the proxy would look something like this uh next slide please and in the in an Ideal World hopefully the proxy would relay the the discussion about the cat videos to Alice um next slide please now the question is why not just to use connect multiple connect UDP connections um that could work right um that could help us get multiple five pupils um next slide please now now here's the catch"
  },
  {
    "startTime": "00:34:01",
    "text": "um because it's we're running HTTP proxies two individual requests they're on guaranteed to be served by the same server instance so the IPS that get exposed uh at the end of the proxy might be different um and so so so this breaks ice um so if this sounds familiar it's kind of like what we have a like symmetric mats but uh I think like using current servers to support this seems very unnecessary and expensive uh when we could still support peer-to-peer um next slide please so connect presenting connect UDP now with listener support and so one connect GDP connection um infinitely as many uh UDP targets next slide please so how does it work uh I mean so in the header as you can see like we specify the paths with asterisks meaning can have as many targets as we like and so in the in the quick frame you'll see there's a connect udb listen section with the IP address um next slide please so what this IP field is so when when uh when the connectivity uh datagrams are sent from the client to the proxy they represent the target IPR Port that's uh that it should be forwarded to whereas on the other in the other direction uh when the proxies uh receiving and sending it back to the client it would represent the source IP"
  },
  {
    "startTime": "00:36:01",
    "text": "from which the proxies received these packets um so but here there is an open question like does the proxy validate Source packets um and I guess this is where we would we would need like turinx people who have expertise with webrtc turn um next slide please so I would like to open the question like are we are we interested in adoption of course we'll need some security considerations like I mentioned um like Eddie anyone who has like webrtc or turn expertise that would be that would be quite helpful next slide please and that would be it um so we can open the mic for some questions wonderful all right our uh queue is currently booting but Lorenzo is first Lorenzo is no longer first um it does work all right keep walking Lorenzo um so we have a timer on screen we're gonna try to keep our comments within that time um so the two things that we want to talk about Are One technical feedback clarifying questions anything like that as long as we keep it super short and the other is is this the kind of thing that we'd like to include in our Charter is this useful is this necessary for real world deployments that kind of thing all right Lorenzo I guess Tommy was performing but um is this useful I think it's necessary if you want to do anything you know more complicated than just a client server interaction so it does seem useful um from a technical feedback perspective usually apps will bind to an empty address and um so that's one thing to consider and there are you know again like to my"
  },
  {
    "startTime": "00:38:01",
    "text": "earlier point about mapping this to sockets apis they they do things like you know bind connect and then call get sock name to figure out what their local address is and so on so that's those are like things that they're accustomed to doing that if you want to Port an app to use this such as webrcc you might want to think about those semantics and replicating them a little bit things like get sock name is are actually you know and get pure name error often used the other thing that I would say also is is a complexity that you need to think about is um the dual stack sockets so often an app won't know if a connection is coming in on B4 or V6 and it'll just like bind to a to a V6 address AFI net six empty and then it will you know the kernel will deal with V4 traffic on that socket using mapped addresses and so on that's it you can make all that work and I think you yeah yeah okay so it does yeah because and that's something that's like sometimes on Triple but good to know that you've already implemented it all right Tommy all right hello so yes this is definitely useful um I would say this is the main pain point for the browser use case when using a mask proxy um and we've been running within deploying these for like two years now and this is kind of like the main Gap that we need to fill so please let's do it uh let's adopt it here um I also think if any if anything is in scope uh for this group this should be because this is kind of like a clear um like bug fix essentially in the whole connect UDP ecosystem the one other thing I would leave is doing something like this for connect TCP would be interesting too I I know that shouldn't be this document but that should also be addressed"
  },
  {
    "startTime": "00:40:07",
    "text": "I don't have any comments specifically on the draft but I do think that the use case is important so um we should work on it awesome Dave it's kanazi thanks Abby for waking up at 4 30 a.m and joining us today this time zone is rough for the U.S uh this time around I just wanted to answer uh Lorenzo's question as co-author uh the kind of spiritual war that's not the right word the uh conceptual way to think about this um is so connect udpg unextended the current version that's published is a connected UDP socket and this is a non-connected UDP socket so you you do bind and then you you get on every packet that comes in uh the uh receive packet info and and then you can send to uh to a bunch of places so like get pure name it's not because it's not connected there and the the call for getting your local name like that's the one that's like not defined but if if you want to fit that you would say here's a 1918 space address that's fake uh because that address doesn't exist in this space um it's like imagine like I'm realizing the more and more we think about this more and more masks feels like a gnat that's running over HTTP which is kind of ironic because the old name for Nat was masquerade um but that's kind of what this is where like if you have if you you can give your app an address but it'll be fake just as an address that's private to your side of the NAT is fake um one thing that folks have talked about that we can decide if we want it to be in this draft or not is you can you could also add an option to to use"
  },
  {
    "startTime": "00:42:00",
    "text": "Mass to say hey here's the public address that the proxy is using for this connection on the outside in case that's useful to facilitate things like ice and all that yeah yeah so that could be um a useful I wouldn't say you need it because with a Nat like the you don't have that you don't have a way to tell the NAT what's my public address today and things still work because like we've uh it's done you can do that but it sounds like a useful feature maybe we can use that but I think it fits into the shape of what you're describing yeah I know for sure for sure it's just a way to think about it uh I hate Nats as much as the next person all right thank you very much sounds like we've got quite a bit of interest um let's move on to our next topic uh Eric before we move on just uh asking as a co-author what are our next steps here uh should we talk about adoption or is this a conversation we will have after the recharter we're going to talk about that after the recharter because we have the whole pile of documents that's one of the questions is where do we draw that line Thanks so adoption is on the table for anything that we decide to Charter all right next up we have quick aware proxying using http hello can you hear me all right we can hear you and see you awesome um I'm Eric Rosenberg Apple I'm going to be talking about quick aware proxying using HCB which is an extension to connect UDP when quick is being proxied next slide please so why quick awareness we already have connect UDP quick runs over UDP and everything's great and everything is great but there's some opportunities to try to make it better uh one of the first things that you"
  },
  {
    "startTime": "00:44:00",
    "text": "might come across when using connect2dp is that if you're supporting Target servers accessible over ipv4 you may run into Port exhaustion between your proxy and the target additionally when using connect UDP you may notice that there's MTU loss for each proxy that you use by encapsulating inside of http datagrams and this may not be a big deal when using a single connect 2D proxy but if you start to chain these proxies this MTU loss can be quite consequential even to the point of maybe not being able to run quick over those nested tunnels and then finally um there's the processing and uh send and receive overhead associated with connect2dp that you would expect and there are some opportunities to to Short Circuit some of that work when you know that quick is uh being proxy next slide please so what is quick aware proxying uh well essentially the client uh who is is speaking quick to some Target is able to tell the proxy some information about the quick connection that's being proxied um and specifically the client is sharing the connection ideas for the inner quick connection uh with the proxy using the capsule protocol and immediately with that information what the proxy is able to do right off the bat is it's able to reuse Target facing ports for these connect UDP tunnels so instead of having to create a a new unique socket that might be a new port for each connect UDP request if it knows that it's quick it may be able to reuse sockets and distinguish traffic based on connection ID on top of that if a client in proxy"
  },
  {
    "startTime": "00:46:01",
    "text": "agree uh that they want to support a forwarded mode of proxying they may skip the encapsulation of the quick packet for the inner quick connection inside of an HTTP datagram for short header packets and this is what we call forwarded mode where the client is generating a quick packet for the client Target quick connection and instead of encapsulating it inside of an http datagram it can send it directly to the proxy over UDP and using this forwarding mode helps eliminate the MTU loss associated with encapsulation and one other thing to note about this forwarding mode is that the the connection ID bytes on The Wire between the uh the client and the proxy are different than the connection ID bytes on The Wire between the proxy and the Target and I'll explain more about that and why it's necessary in a moment next slide please so I introduce a little bit about how the client shares connection IDs with the proxy and it's fairly straightforward how the proxy might be able to take advantage of that for Port reuse the forwarded mode uh requires a little more consideration so before getting into too much more detail about that when is this actually interesting uh well as I said before uh if if this MTU loss makes a difference to you if you're interested in chaining proxies um forward in my forwarded mode might be applicable and then it's also worth noting that when using forwarded mode we're not encapsulating inside of an HTTP datagram and so the quick packet contents that are on the wire between the client and the proxy and the proxy and the target"
  },
  {
    "startTime": "00:48:00",
    "text": "are largely identical and so this is not preventing traffic analysis pipe servers of both sides of the proxy next slide please so consider we have a client on the left here who sends a connect UDP request to a proxy and in normal circumstances the client trying to establish a quick connection with the target would use http datagrams with quick aware of proxying the client would also share connection ID information with the proxy using the capsule protocol and once there was enough information excuse me the proxy could use that to reuse ports between it and the target and if the client and proxy both agreed to support the forwarded mode the client would be able to generate quick packets for the client Target quick connection and instead of encapsulating them inside of http datagrams if they were short header packets they could send them directly to the proxy over UDP where the proxy would then forward them on to the Target and similarly in the reverse Direction next slide please so I mentioned virtual connection ideas without getting into much detail about it virtual connection ideas are a way of having the connection ID bites on the wire between the client and proxy be different from the connection ID bytes on The Wire between the proxy and Target and it may not be obvious why this is is useful but if we for a moment consider if we didn't have virtual connection IDs um if the packet between the client to proxy were identical to the packet between the proxy and the target um the proxy receiving these forwarding"
  },
  {
    "startTime": "00:50:02",
    "text": "mode packets would be receiving quick packets that have connection ID bytes that it did not choose and if that proxy were sitting behind some load balancer or other routing infrastructure that depends on being able to encode routing information in these connection ID bytes it may not arrive on the right server and so by introducing virtual connection ideas we have an opportunity for the proxy to choose the connection the connection ID bites uh for quick packets that it receives on this forwarding mode the proxy then translates or replaces that ritual connection ID with the real connection ID before forwarding it on to the Target another good example of where a virtual connection I use are useful is connection migration so assume that we have a client that is migrating its network path with the proxy um depending on whether or not the target's interested in issuing more connection IDs and cooperating with using new connection ideas um the client may wish to migrate and also have those forwarded mode packet connection ID bytes uh change as the network path changes and so by introducing virtual connection ideas we're able to change the connection ID bytes on The Wire independent of any uh change with the real connection ID uh next slide please so we've uh run the kind of regular connect PDP implementation that we have as well as our quick aware connect2dp implementation uh in our lab and there's certainly uh I expect that quick implementations are going to mature and this is our tunneling implementation is"
  },
  {
    "startTime": "00:52:00",
    "text": "only going to get better by what we've seen so far is that when we leverage quick aware forwarding um forwarding of these quick packets essentially requires an insignificant amount of CPU so it's an extremely efficient thing to to do um it is a very lightweight way of proxy and quick next slide please so I mentioned earlier that we're using the capsule protocol there are about six capsule types that are part of this exchange um I could come back to to this slide about the details of each but it might be more interesting to jump to a sequence diagram where they're actually used so next slide please okay so consider that we have a client it's sending a connect UDP request it's indicating that it wants to do this forwarding mode which is optional um the client is also telling the proxy about the client's connection ID in the form of a capsule and it's also sending its client initial inside of an http datagram on the same flight the proxy then takes that information optionally reuses ports and if it also supports forwarding mode they can go ahead and create a forwarding rule in the Target to client Direction the proxy sends the client's quick initial to the Target it sends a 200 status code to the client including that it it does support forwarding mode acknowledging that it received the client's connection ID um after receiving the server is quick initial it encapsulates that inside of an HTTP datagram because long header packets are always encapsulated to avoid unnecessary exposure"
  },
  {
    "startTime": "00:54:00",
    "text": "now that the client knows the targets connection ID it shares that with the proxy and we're able to complete the set of forwarding rules so now we have a forwarding rule in both directions Target to client client to Target and after acknowledging the receipts of this target connection ID information the client is able to use this forwarding mode where it generates a quick packet for the client Target quick connection it instead of encapsulating that inside of an http datagram it replaces the connection ID bytes with the virtual Target connection ID bytes sends it over UDP to the proxy the proxy recognizes these connection ID bytes in the packet replaces the virtual Target connection ID with the real Target connection ID before forwarding it on to the Target and similarly in the reverse Direction next slide please so that is quick aware of proxying using HTTP um very interested in folks reviewing the draft and providing some feedback and gauging interest from the working group thank you um Martin Duke Google no hats for this comment um thanks for this uh first one clarifying question which quiche oh yes this is uh cloudflare based on cloudflare okay um so I I think the use case for this is pretty clear but um having thought about this way too long the other day uh I'm concerned there are some foot guns that we need to work through um one is uh first of all the virtual CID thing is like a great idea um I'm wondering if it's correct to bind those one to one to to the real cids um I'm having a lot of trouble reasoning about the threat model of of like linkability versus like the"
  },
  {
    "startTime": "00:56:01",
    "text": "proxy anonymity of um if you're I mean clearly you need to change the virtual cids on in the on the proxy between the proxy and the client but do you actually want to change the CID that comes out of the proxy to the Target and I I think the answer is no but that might be wrong uh similarly and I think I brought this stuff on GitHub but um the interesting property I realized about this is that if you were if the proxy client connection consists entirely of these sorts of forwarding mode things that you can essentially have no AC feedback on the mass connection which is a very weird situation for transport there's there's an idle idle time issue which people have thought about but there's other things like a lot of congestion controllers will like kill their congestion window after a while if they don't get you know if it's if it's allegedly idle Etc and so I I would you know one nice thing about this being the transport area is like maybe some of the right people here to think about that really hard and make sure we eliminate a lot of those foot guns at least with some advisory texts but just thinking if if there's something more we need to do here some way to like collect the acts of these well you can't act them because they have no packet number so um it's another way thinking of it is sort of it's just it's a it's this is a way of negotiating a layered three tunnel or a layer three forwarding situation which maybe makes it okay but I have a little bit of the Willies about all these sorts of concerns thanks yeah thank you uh just to address the first comment um I don't think that the virtual connection ID and the real connection you have to be one to one um we still need to kind of flesh out the details of of the protocol but uh the idea is that the virtual connection ID can change uh and still be mapped to the same uh real connection ID and then yes for uh for accommodating for there not being traffic on the regular client to proxy connection um thus far we've been leveraging keep lives uh to keep that in that stream alive yeah right"
  },
  {
    "startTime": "00:58:00",
    "text": "that's that's fine I like I I I feel I fear that there's a problem Beyond keep alive but I can't articulate it very well right now thank you yep thanks um I think this is a an important problem solve I think the draft is a very elegant way of doing it even if there are some details to be worked out um also in the in the real world often you're not using this just for one connection that you set up a tunnel and then never touch the control Channel again you're usually also still using it for other traffic for other connections that are coming in going at the same time so yeah there's some stuff to work out with certain usage patterns but that's something we could do posted option I think this should be in scope for a returner um I agree like this as clear benefits so it's it's something we should work on and do I have a question about um virtual cids and I think this is maybe something we discussed in the past but I understand how like you described how that works between the client and the proxy but I think um we would have the same problem between you know the Target and the proxy and having to Route Pockets based on uh proxy chosen CID um again between the Target and the proxy so I was wondering if the existing mechanism that you described would also solve that problem or if it's something that we would need to add later on yeah thank you I think we'd have to I'd have to understand a little bit more about exactly what you're talking about their their virtual connection ideas in"
  },
  {
    "startTime": "01:00:01",
    "text": "both directions one that the proxy chooses and one that the client chooses and it's the receiver that's deciding and the receiver in this case is is the client so from packets that are coming from the target to the proxy for now have have the real connection ID to to make sure that we don't require any cooperation from the target so the the real connection ID being the the connection ID picked by the client yes right so so I I think the problem being um in a situation where you require routing quick packets based on connection ID that proxy would have to to ever say in what the connection ID is in the case thanks hey Lucas part of your cloudflare um I think this is a clear use case for this it's got clear benefits it's not just a micro optimization there's like some some strong properties that can provide the technical details yeah we need to to hammer out some of the the edge cases or thought guns here uh earlier draft didn't quite fit the needs of like Alessandro to Saluda to load balancing concerns the later draft with virtual SIDS there's a much clearer path um toraco Mark's point I think there's ways we can mitigate stuff via controlled channels or other stuff like we we should do this work here I think so that we can actually get Collective View and different deployments like same technology different deployments different concerns let's try and and come up with Technical Solutions to this so thanks for doing the work and I'm always happy to review and give feedback thanks man Thompson this is your mom all right pardon me uh yeah it got short the um the thing that bothers me about this design aside from all of the"
  },
  {
    "startTime": "01:02:01",
    "text": "questions that Alessandra had which I also agree with I'm just going to keep going um is the traffic analysis here is is trivial and I I think what this design really needs is uh re-encryption at the proxy as well in both directions I realize that's unfortunate and maybe less efficient but the Privacy properties of the protocol uh are not that great until you do that so I'd I'd like to at least consider that yeah I think echo's raised this point in the past it's just concretely not biting so I will continue um because racist pointed before I think he raised it in in terms of saying what's your threat model uh which is a nice way of saying uh I don't like this design so um please consider that sorry this microphone stand is uh impaired uh David schenazi ask Enthusiast um so unsurprisingly I think like yeah I agree with people there's uh there's a useful there's a need for this it really solves something there are a lot of details to hammer out but yeah I work this working group seems like the right place to do that so plus one to uh chartering recharging the working group in such a way that this fits in and then adopting this um I think uh Martin and Eric are operating with different threat models which is fine so we might need you know multiple modes of operation um one of the really nice properties if you don't re-encrypt is that it allows"
  },
  {
    "startTime": "01:04:01",
    "text": "you to implement the forwarding mode and ebpf fully on the neck without ever touching the CPU which is pretty banana pants awesome and uh so I think Eric has done that which is crazy awesome great work uh and so I think for some use cases that's what like that makes a huge difference and allows you to scale way more and for other use cases that Martin has maybe we don't so maybe we have another mode where we do we encrypt which are both valid things we'll have to talk about that more but I think the working group is the right place for this thank you wonderful thank you very much we're at time for this presentation but it again sounds like we've got a good bit of interest and people think that this is a valuable problem to solve and this working group is probably the right place to solve it next up we have access service description objects okay hello everybody this is Ben Schwartz from alphabet I guess uh and this is I changed the title to access service description URI okay so what what am I talking about what is an access service uh I came up with some kind of definition for what I mean by this basically it's a thing you use to access the internet using http um I mean these things uh we have all these things now in HTTP that allow you to access the internet over HTTP and so this presentation is about this draft is about how do I turn"
  },
  {
    "startTime": "01:06:01",
    "text": "it on uh so here's the like status quo of how you choose your proxy server you like put in an FTP proxy or something uh and this is how you configure a VPN server so like I guess if we want to activate connect IP it goes in here maybe and this is how you choose your dough server uh I I wrote some of this code so this is uh this is the status quo and uh so like how many different times are we going to ask users to enter the config information uh how many different times does the user need to authenticate this connects to something I heard David scanzi say a few minutes ago that uh that it's easy to imagine Services where there are there's a UDP proxy service there's an IP proxy service maybe there are other proxy services and uh and any given connection is uses one of them as appropriate based on how that app happens to be implemented based on what transport protocol it's using so this this is sort of based on an idea that from the user's perspective these this this whole bundle is really one service the user's mental model is that this is an access service or a proxy service or a VPN service so that's one problem and the other problem is authentication how many times does the user need to authenticate to all of these different Services you know these are different HTTP endpoints there's no potentially even on different Origins there's like no necessary rule that they all need to be authenticated in the same way um"
  },
  {
    "startTime": "01:08:00",
    "text": "so the goal of this draft is to enable a world where the user just enters one magic string a URI into one user interface somewhere to activate this thing this access service and the users authenticate to that once and that's that's all they need to worry about uh so like here's a very detailed rundown of how this all would work but basically there's a URL the user has the URL they plop it into some user interface that which then the client fetches it you know periodically when it expires and fetches it again and and the thing it gets back tells it all the different Services sub services that are available and crucially the the authentication is done on the access service description URL and then those that authentication information transfers to all these different services so we don't need to authenticate them separately so what's at this URL uh I mean it doesn't the exact format doesn't matter but you could call this a placeholder but fundamentally it's just a trivial structure containing the the templates for all these different things uh some of you may note that in addition to the connect UDP connect IP and and do templates here there's also uh some other stuff for TCP and HTTP um I have five minutes maybe at the end of the session to talk about that so that would be like a connect TCP uh thing if we wanted to do that so this sort of imagines a world where we've we've fully transitioned to this kind of template driven description of proxies and so we have this nice parallel construction for all of our different Protocols are described the same way"
  },
  {
    "startTime": "01:10:02",
    "text": "so this was uh I presented this at the last session but a bunch of things have changed here uh so there's the those template driven TCP proxies and such and I've removed any normative mention of oblivious HTTP from this which previously some oblivious HTTP stuff was mixed in here it seemed like that was not popular uh so now instead of having key configs in here none of that the key configs can be described by some other object that uh Tommy Polly has a draft for and I added this discussion of authentication which I hadn't been talking about yet um I want to highlight that what I really think would be even more interesting here it's not in the draft is a vanity URI scheme for this so you just you know replace https colon with mask colon and now you can imagine saying you know okay how do I activate an access service for my device we just click on a mask colon hyperlink and uh this is very dangerous uh but it's very powerful and basically I have faith that the very small number of implementers who actually have to think about this because it's only basically uh operating systems and browsers would um would think very carefully and maybe not support it but if they did support it would would put up suitable barriers um to make it safe so that's my very simple proposal and uh I'd like to see this adopted in mask um presumably after some kind of retardering discussion I think that's it"
  },
  {
    "startTime": "01:12:00",
    "text": "Eric yeah overall I I like this I want to see it happen somewhere at least something along these lines but I'm not completely convinced this this fits for a potential retire in this group but skimmed into preview discussion we're going to have here at the end of this meeting but assuming the plan is we want to retire this group to be focused tightly to one down after finishing up the necessary work then I think we should leave this group focused on proxying UDP and IP and similar stuff around this and this is this proposal is more of just a general proxy and thing so if we return a lot of stuff like this where taking the big risk of returning this working group into becoming just a general proxy working group and kind of afraid that's too much scope that's apply that will lead to this be a permanent working group and I don't know if that's the greatest idea so I want this to happen maybe something like HTTP working group would be a better place I'm not completely sure but I I my my suggestion is maybe we don't return to allow this and this doesn't leave the bar for every chart of this order but still please make this happen somewhere okay I I don't really have an opinion about venue Tommy all right um so thank you for updating this I I do think this is better and clearer than the previous proposal um I'm still on the fence about the exact details here um and like when I imagine in like the short term how the configuration is going to work for these types of things um I I see two kind of main paths for configuring like one kind of like you like you're alluding to we have these Legacy proxy configuration boxes somewhere in an OS or browser settings UI and in those cases the user just like types in a name of something um"
  },
  {
    "startTime": "01:14:00",
    "text": "for those cases you know connect Works already and for connect UDP connect IP we defined a well-known URI specifically so that you know we could just try those and have a well-known location off of a name so that case seems to have a short-term solution that works okay and then the other model is you know we could either have a application or you know we have like MDM profiles I mean like you could have a more complex language for describing all your different uh urls that could come in some other format um so I think what you have here definitely enables more automatic use cases but I think I'd want to see more and I think it just requires more discussion among this group or another group more broadly to understand like what's the exact kind of user flow and who's going to need to get this information that can't either get it from a well-known URI or can't have a richer configuration profile uh described in another way thanks hi hi Alex journalhowsky Google um Ben I think this is very cool and I think you're on to something here but I think uh I still would like to better understand what the user story here is because one of the things that I'm having a hard time wrapping my head around is how we envision people using this and I think that wouldn't really inform the specific design which sort of leaves me to say that I'm not sure that we're necessarily the right group here and then second the messages in the zulip of taking us a dispatch but I think definitely we need to better understand how we envision users using this I can't personally"
  },
  {
    "startTime": "01:16:00",
    "text": "think of the last time I used the proxy UI to configure something other than when I was developing so I'm I'm not sure if the solution and the problem quite match up yet yeah I'll say you know we don't really use these uis they exist but like you know I think the vastly more people install VPN apps from their app store then use these these like ipsec configuration uis that every platform carries and uh I think that's a bad thing I think that that's a failure of standardization and we should be trying to Define standards so that we don't have separate apps for all of these things that when we can we can standardize it end to end yeah um Martin Thompson I suggested dispatch I think there's a really difficult question here about scope uh you've talked about doe you've talked about Ojai you've talked about a bunch of other things if I imagine all of those things falling under this umbrella there's an interesting sort of question that are very concerned internet citizen might ask about in the interest of users about centralization thanks uh I I don't see a I don't actually see a significant centralization concern here I think that these you know if anything this makes it a lot easier to spin up new um new competing access Services by lowering the barrier to creating new ones right now the the barrier the the amount of technical work required to to get started is is much more significant yeah the reason I said that is that in your description you had one UI affordance and one authentication and that's the sort of thing that bothers me when it comes to these sorts of diversity of services"
  },
  {
    "startTime": "01:18:01",
    "text": "I I think there's something here like there's something in this space I agree that like it's not 100 clear to me like what the UI flow is and kind of what the boundary is of this is so like how many things do we have in here and that that brings a question to Scopes so I think I I want to see this work happen to or at least get a little bit further down the road to like really understand where we're going with it but I'll I'll plus one previous comments that maybe like mask itself is not the right place because it touches doe and probably Ohio and a lot of other things foreign thank you very much ben it sounds like there is interest in seeing this go forwards in some form somewhere but potentially we need to look for a dispatch or something like that next up we have HTTP proxy status parameters all right hello everyone uh so this is a pretty minor little addition and it's uh this one straddles the boundary between mask and just generic HTTP for proxies but uh generating sharing it here because it really has to do with this uh forward proxy privacy proxy use case all right so first some background uh we're talking about a addition to proxy status so what is proxy status um this is defined in a recent RFC 9209 it's a new header field that lets proxies tell clients extra information"
  },
  {
    "startTime": "01:20:01",
    "text": "in their responses um it includes the list of identifiers of the different proxies that handle the given request um that's not super interesting for this but it also includes an extensible list of parameters that can include errors and Upstream details Etc so why is this relevant for mask um I don't think we've talked about it in this group but in practicality it is very very useful for connect connect UDP and connect IP proxies it's also useful for reverse proxies too um and in the case where we are currently using mask for private relay we use this status all the time for example to communicate DNS failures or that you had it on ritual IP and this lets the client determine what errors to show or what policy to apply as far as saying oh maybe this is a local network resource um so as an example you may get back a proxy status that says hey your example proxy hit a DNS error and that error was an X domain and so now you know that you were trying to reach a domain that doesn't really exist at least on the public DNS so to see how that works out um clients doing connect UDP to an uh or connect or connect UDP to a bad.example.com the proxy will try to resolve that get to NX domain says hey sorry 502 um here's the error so that works fine okay so what is missing what's the problem that we're trying to solve so in the successful cases for um being able to actually connect to a server over the proxy and actually having DNS work there isn't a parameter to communicate any DNS response details"
  },
  {
    "startTime": "01:22:03",
    "text": "there is a next hop parameter which can contain one token which is a name or an IP address or an alias um but that's not really the same as saying you have DNS response details and why would you want DNS response details so there are many different reasons but the one I'm concerned about here is the fact that uh clients can use uh DNS responses including like a cname chain as well as the resulting IP address that you connect to to detect uh cname cloaking or IP cloaking so this is a case where I'm going to what looks like a benign domain but it's actually being C named to a uh name that maybe I want to apply special policy towards because it is a endpoint that is doing a lot of tracking or data collection or something that the user wants to block for some other reason or wants to apply some policy to um or even maybe a case where instead of using a cname it is directly going to an IP address that is a known tracking endpoint or some other uh concerning IP address that we want to be able to apply policy towards and you could solve this by having clients always do their own DNS lookups before they use the proxy or you know do dough or something else through the proxy itself but that definitely is a lot less performant than what we're able to do with the normal connector connect UDP and it's not uh I think a good trade-off to say that in order to be able to apply uh cname cloaking prevention or IP cloaking preventions that you need to lose a lot"
  },
  {
    "startTime": "01:24:00",
    "text": "of the performance wins that make um going through a proxy viable for a browser use case so to go back to the use case here if we have a successful connect for example to example.com the proxy itself is doing a resolution it knows if there is a c name there it knows what the IP address is the client does not learn that however it just gets back at 200 okay proxy status that can include for example the next hop and that's just the name that we originally requested so the concerning case is let's say this is a cname or IP cloaking and I'm happily going to example.com but now it's being c-named to tracker dot example and it has an IP address that is somehow concerning to me potentially and that response looks exactly the same I cannot tell uh what's going on there so the proposal is very very simple it's just to add one new parameter currently calling it DNS used and that is essentially the the DNS answer and chain of aliases that was used to create this connection um and so a client would be able to read this and apply whatever policy it has in the browser this is going to be about preventing cookie sharing or potentially blocking a resource um and the proxy status parameter for DNS use is very simple it would just be a string that is a list of the IP address and any aliases or C names that were on that chain so this particular proposal is very limited and very minimal um it's intentionally that way to be a very"
  },
  {
    "startTime": "01:26:01",
    "text": "simple to add proxies can add this um with whatever information they have it doesn't require any extra negotiation and it's just extra useful information and it solves a real problem um that we have for our browser and I think when we discuss this on list uh other people mentioned that they uh would have use for similar information I also want to point out there's definitely room for more work and thought about DNS results over a proxy this does not address how would you do DNS SEC validation over proxy how would you get svcb parameters uh if you want to do ech or alpn negotiation um those cases require more active work on a proxy to say please also request these things and give me the responses um and we would want more complicated negotiation maybe we could use capsules for those maybe they're other headers Etc um so I think there's work to do in that area but I would encourage us to uh split up the different problems and I think we can have incremental usefulness with a parameter like DNS used so questions um do we think this is useful where should it be it could go either in master HTTP I think both groups should have review and input on it and also this is a call to if people want to talk about more advanced proxy and DNS use cases we should talk about that David schenazi thanks Tommy I think this is useful uh and I think uh the space of uh"
  },
  {
    "startTime": "01:28:02",
    "text": "more information about the DNS through an HTTP proxy makes a lot of sense um so I I want to see things like this happen in terms of um where to do the work my my gut feeling is this applies to more than mask it makes sense for other HTTP things so perhaps it makes more sense in HTTPS but like not horribly strongly on that one all right yeah Martin Thompson this seems like a an extraordinarily narrow solution to a very specific problem where we know that we have a more General problem sitting right there uh you you point out it at in the last slide uh I would prefer to explore those other Solutions before deciding to do the narrow thing I think there's there's too many cases where the client needs more information about what was done in terms of the DNS queries that may be the right place to do this work is ADD instead sure yeah I I definitely agree that we should do the bigger stuff too but um yeah I think I do think there is incremental value we're doing the small thing it's it's a useful hint anyway Ben hi uh benchworts I I don't know that I believe in the cname cloaking use case really but uh but I do want this just uh just to be to to Lorenzo's point about supporting the posix apis uh this is very useful if you're trying to emulate get Adder info which does surface the cname results uh at least"
  },
  {
    "startTime": "01:30:02",
    "text": "optionally so uh just for the sake of being able to get it Implement get Adder info I think this is useful I don't I see this as quite distinct from a deeper system for conveying DNS results generally which is a a much bigger problem and runs into a lot of DNS ossification questions and uh please change the name don't the DNS used is not good enough let's do better do you have a suggestion oh sorry you're gone drop me a suggestion somewhere my suggestion is something involving the word CNA okay it includes an IP address too sorry yeah I'm um I'm not sure about where this specific solution belongs if it's in this group or in another group but I think we should actually take the DNS use cases in scope for the re-chattering and because I think there might be more work in this in the space that we that we should not ignore okay excellent all right thank you very much and we're going to speed round through three more quick things so everybody take a moment to breathe in breathe out stretch a little bit and then we will talk about summary chartering so next up we have sequence numbers Marcus right hello hello so I'm going to talk about a very very small proposed extensions about adding numbers to http datagrams so next slide please so some background why we want to do this 3gpp are working on a study called atss it's a study on access traffic steering switching and splitting supporting the 5G system architecture so"
  },
  {
    "startTime": "01:32:01",
    "text": "it's basically solutions for steering traffic across 3gpp and non-3dp accesses there are various ways of doing that different steering modes one of these steering modes is called traffic splitting where you basically do bandwidth aggregation there are already Solutions defined in release 16 of 3gpp where where mptcp is used now we're looking at other solutions for non-tcp traffic and there have been various proposals for how to do the multi-pass steering and MP quick has been decided as one of the potential Solutions and that could be used together with mask now these atss endpoints when you're splitting traffic they would like to be able to support limited reorder reordering of the receipt packets to be able to compensate for path delay differences of the different axises um so when we use Quick we can either send data as streams or as in datagrams the problem is when you send data in streams you get full reordering you get a lot of delay Jitter you need to handle re-transmissions and whatnot if you send data as pure quick datagrams you get no reordering at all you get a lot of out of order delivery of packets you get a lot of potential duplicate acknowledgments and things like this also have problems with performance so to be able to do like some partial reordering the atss study proposes to extend HTTP datagrams with a sequence number so that you can perform limited reordering based on based on the differences between the path delays uh next slide please so it's a very simple extension to mask that is being proposed you just add a new type of a payload format so we have a sequence number datagram that has a sequence number followed by some payload um next slide please um to indicate support for this we're proposing to use a capsule first you can indicate support using a HTTP header then you can register the use of"
  },
  {
    "startTime": "01:34:01",
    "text": "sequence numbers for your datagrams by sending a capsule the capsule would indicate the size of the sequence number used a context ID and also indicate what payload format there is of the inner payload and if you have multiple inner payload formats like you can have UDP payload or in Connect IP we might have IP payload as the normal it's the normal inner payload but we might have other extensions coming up with compression of Ip and such so you might have multiple context IDs existing in parallel we're also looking at how you can uh register new context IDs for sequence number datagrams that would wrap different types of inner payload formats and this is what we're proposing we're posing to use two different kinds of capsules for this one to register the use of sequence packet sequence and another one to basically register context ID aliases for the same packet sequence so that we can support multiple inner payload formats and this is pretty much it what we're posing and we would wonder if this is something that is in scope for this group or for some other group or if 3gpp should work on it by themselves foreign very quick clarification you said we'll use NP quick or I might use NP quick just for clarity well there has been quite some discussion and to my knowledge there is there's an agreement that MP quick will be used but it's not agree that might be the only solution there's also mpdccp considered and I'm not fully up to date with the latest and I think there's a meeting next week that will clarify even more"
  },
  {
    "startTime": "01:36:02",
    "text": "David's good David schenazi um thanks for presenting this I I'm still not convinced that this is a good idea the the concept itself of partial reordering on the proxy uh because this starts to smell like a TCP accelerator uh and those have been great for ossification and making performance worse I have numbers for that one um so on that I'm not sure it's good to answer your specific question of if we want to do this or if this is happening where should it happen uh I personally believe it should absolutely absolutely not happen in the 3gpp uh and we shouldn't not encourage them to Run With Scissors because that's how you can hurt yourself so this topic is in scope for mask it's an extension to a document that we published in mask but I'm not sure we should necessarily progress this forward because I'm not sure it's a good idea but like apparently I would be down to have that conversation in mask yep that's great hello uh I'm from Huawei I think it's actually a good idea to do a reordering in the proxy that you have the end point I have some kind of weakened Point yeah but there is a whole lot of discussion regarding the protocol ossification that kind of stuff yeah so we can I think we need to find the middle ground for for the function between the proxy and the endpoint so if I record correctly uh it has been an intentional Choice within the quick"
  },
  {
    "startTime": "01:38:01",
    "text": "working group do not expose the sickest number of packets being sent and based and that was based on the understanding that doing exposing that uh would actually do decrease the performance of a multi-stream transport protocol that doesn't always have the head of lamp working problem so I think that this proposal is I mean the concern here would be that this proposal is actually negating the achievement that we made in the quick protocol and I think that's a major concern thank you yeah all right thank you very much next up we have HTTP datagrams UDP processing and extensible prioritization from Lucas good morning I did not know how long I'd get for this slide so I got loads of slides sorry this talk so let's go uh this is a kind of a document I came up with about a year ago I think I presented to this group I can't quite remember um it's kind of just sat in the background I've not been doing that much with it uh give it a little spruce up about four months ago and kept things quiet maybe trying to do some chatting in the hallways and then I got ill and couldn't do it so let's go with some background very briefly we've got RFC 9000 quick saying let's stream multiplexing has a significant effect on application performance but quick doesn't provide a mechanism providing uh for exchanging any prioritizing eggs prioritization information so you know your implementation is probably going to do some stuff if it cares about doing this application performance maybe it doesn't maybe it doesn't matter but the signaling of what's important what's not"
  },
  {
    "startTime": "01:40:01",
    "text": "is kind of punted so hp3 is an application protocol uh it could have had signals for stream prioritization but we had some issues during that process so we punted it then we have Roc 9218 which kazoo and I worked on for extensible prioritization mainly for hb3 and now we we backported it to work over hb2 as well each one doesn't really have the problem because it's not multi-streaming so whatever um then we have quick datagram frames which we defined in quickland they don't have a transport multiplexer identifier so you're sending messages um you know but you probably want to send different datagrams for different kinds of information flows within a connection so in this group we came up with HB datagrams and the capital protocol which is another RFC and also proxying UDP and HP also if we should be familiar with here which is great um the first time I wrote this draft a lot of those things weren't quite rfcs yet so we're hedging our bets but now they are which I think makes this discussion a bit more clear you could say datagram information flows multiplexing like what would be the use case for that mass processing is one maybe quicker where prompting negates that a bit I don't know web transport potentially two depending on who's using web transport to do what we're seeing some proposals in a mock working group about not using datagrams and still achieving the kind of low latency video goals that they would like to to do um without datagram so maybe we don't need this thing I don't know what I'm trying to figure out is is there any interest in this document it could be done but should we do it and if we did where might we do it next slide please um so yeah this is the the Venn diagram of all of the the rfcs that we have and the different working groups that have done and things that are HTTP datagrams possibly could have been done in HP working group but we did them here"
  },
  {
    "startTime": "01:42:02",
    "text": "in this van but next slide um so just a very quick recap about what this extensible priority scheme is um it's for signaling between clients and servers and then there's other thing where you might be a reverse proxy and you want to have an origin or maybe some code within your like maybe CDN world that can also influence the prioritization so it's a kind of two-way thing but it's all in the RFC but we have two signals effectively urgency which is between zero and seven it's kind of like buckets of wheat or whatever and this incremental thing which talks about how the the responses in HTTP can be processed but really it's about you know is he streaming the important bytes of content that you care about how much they be used which influences maybe you want to send all of the one thing in one go and then move on to the next or maybe it's useful to have bits of things coming kind of as closely in parallel as possible because you can render them something like a progressive jpeg or something like that so in addition to the signals we give some scheduling guidance it's not mandatory but effectively it's there so we can articulate broadly like expectations so if you're going to use the signaling scheme it's useful to know how the other end might operate on that but we can't mandate things because scheduling and resource usage is always within the control of the the other side that is sending and scheduling data so next slide very quickly if you follow that guidance you might end up with this kind of thing I don't have the time to go into it unfortunately next slide um but when you come to datagrams you've got these Multiplex flows using quarter stream IDs uh there's this all one big bucket so how do you schedule that maybe fifo second stuff is a bit basic it could work but maybe it wouldn't next slide um so then you combine that with screens"
  },
  {
    "startTime": "01:44:01",
    "text": "and you've got this one bucket of one thing and these multiple weights of other stuff it's kind of a mess that slide then you stick capsules in and capsules are going to be sent on streams and maybe they have the same stream and that the kind of the hook for the stream and the datagram and and maybe some things are more important than others like slide um so oh that shouldn't be in there next slide uh so there's this thing and it adds a thing for datagram emergency but basically accommodate datagrams within like a compatibility mode that would just fit and fit within extendable priority scheme and its extension mechanisms and there's all to do with how you might share the bandwidth between datagrams and streams next slide yeah there we go look magic next slide uh is it a problem uh I don't know like in the in the web transport World in w3c there's like these big long threads of issues they just go go like wow um maybe we can maybe we don't please please let's figure this out and just resolve it because it's been dragging on way too long the next slide yep and we had another one to our Venn diagram the w3c at the bottom they need to occur to next slide uh yeah so what do we do everyone's pointing at each other um can we just put this to bed please all right if you're gonna hop in the queue we'd like a thumbs up this is something we should talk about in mask thumbs down somewhere else and we'll have further comments on the list or elsewhere thumbs up but I'll just add when we wrote HTTP datagrams the privatization for HTTP the extensible one wasn't ready yet so we decided to punt to not delay um but if you had been there we probably would have put it in there so this seems like the right thing to do thumbs up thank you inside mask benchwartz I I don't get it where's the queue these are these are datagrams"
  },
  {
    "startTime": "01:46:01",
    "text": "there's like no there's no streaming here there's like no there should be no buffering here like you know datagram comes in it goes out there's there's no where's the queue it would depend on the implementation um you know if you're doing something like quick you probably want to send a flight of packets um effectively if that's what you're doing in a processing model so you would have maybe a batch of 10 things you send it one time um and you're building up you know multiple say connect UDP streams that are coming in and you're trying to dispatch them as quickly as possible I agree and they should just be in and out but you might build up a cues there's no flow control I'm sure yeah I don't yeah I don't really understand where the queue is but if the queue is on the sender side on the on the inside that's sending from the client to the proxy from the proxy to the client then this doesn't seem like the right layer you want the the place where you want these priorities is on the outside of the packet so you can tell the kernel to schedule the delivery or adjust it's it's buffering in some way but I I guess I don't really get the use case separate from that I want to separate from that I want to say in general in mask we have an interesting problem with these extended context things which is we have a way to define these formats but we don't have any way to explain to the counterparty when they should use it so I can I can define a format or a context ID for you to be able to express priorities back to me but I have no way to tell you whether I actually want you to do that or how often I want you to do that uh I think that's a puzzle same with sequence numbers same with all the extensions that we've talked about I think that's all right before we go too deep into that this timer Ben is uh your time for the next set of slides if you'd like to do them um so we can talk more about priorities if you want to take us on a quick tour through your last set of slides that"
  },
  {
    "startTime": "01:48:00",
    "text": "also works great or we can go into retarding thank you Lucas okay well then to be very brief uh this is I'm also going to be mentioning this at the HTTP working group but like this is how mask looks right you've got a template and then you use uh extended connect with colon protocol um so like could we just do that for the old HTTP request proxy and TCP proxies um so the TCP proxies are an obvious parallel to UDP but actually I think there's also a parallel in HTTP request proxies and um and I claim that this uh that this solves some some real problems because these old-fashioned proxies they're like completely impossible to Virtual host and also the TCP proxies don't really work well with happy eyeballs so uh the specific proposal in the draft has a bunch of intriguing uh intriguing edgy technical bits but the bottom line is like should we do this where should we do this uh and this is really for the rechartering discussion so maybe I can just close all right any thumbs up thumbs Downs Tommy um yeah I find the TCP use case a bit more compelling um and certainly if you're trying to have a new format for the you know normal HTTP proxy that should be done in HTTP and not in mask I want to make sure that if we're doing"
  },
  {
    "startTime": "01:50:01",
    "text": "any of this we're actually getting enough new functionality for example you know if for TCP we defined the ability to do you know start.star to have a TCP listener like that would be like a compelling New Edition that is like fundamentally something you couldn't do today so yeah so maybe split the TCP stuff from any other changes and look at having TCP listening foreign thank you all right thank you Ben and with that steal that should we get a little wider there we go so this is a proposal and I'm showing it this way instead of a diff view because the diff gets messy when you move things around this much but the main uh difference between our current Charter and this is this paragraph that I've highlighted part way down so this is a somewhat provocative text in the sense that it pulls in a whole pile of stuff that we had previously said was out of scope so the intent here is uh as we've just been talking about a number of documents um I think we've sorted at least one over to dispatch we have uh some DNS conversations of do we want to have that in HTTP or add or DNS Ops or continue to talk about that in mask whatever we decide there we will certainly be coordinating with all of the relevant other working groups and we have some text about that at the bottom of the charter as well so we can add other groups to that list and we also had a set of things where it looks like we've got quite a good bit of energy and some really good ideas around what we want to do so with that the my client is open um Let's uh tear this apart or decide"
  },
  {
    "startTime": "01:52:03",
    "text": "that we love it Lucas clarifying questions could we uh what what do you mean by call documents here the stuff we defined only in mask or the things we depend on from other groups our original Three so HTTP datagrams connect UDP connect IP okay so so the priorities example is it's an extension to a document that was written in HTTP working group but the extension affects the behavior of the documents we made here so we're not extending the documents per se but the behavior without being scope too potentially David you want to hop in the queue and say such things sorry I yeah I happen to me next I I think of uh Lucas's uh datagram priority as an extension to http diagrams even if like you're right when you like get down to the details they might not necessarily be so I I would phrase this in such a way that it's in scope um this seems a bit uh so now to make my personal Point uh this new paragraph feels a bit too broad to me good um yeah the um uh I'm sure our isg overlords don't want us doing too much stuff uh but conceptually I think it would make more sense for us to focus on extensions to our core documents uh you know some wording needed here because of private previous point so extensions to connect UDP uh to give it more features that we think are useful uh extensions to http datagrams each accessions to connect IP should be in scope"
  },
  {
    "startTime": "01:54:03",
    "text": "I really like the idea of real world use cases except that's kind of ill-defined so I would like to see that tightened but I like the concept uh let's not go crazy into like hypotheticals like let's keep it real um and then where I then draw the line at kind of close like narrowing the scope would be to say that if something applies to hcp more generically it shouldn't be in scope here it should be in scope of http um the the remaining thing that's still here is Discovery and configuration I I'm not sure that should be in scope at least because so far all the proposals we've seen in the space are not specific to mask and kind of more General to http and encompassing things like doe or high or all that so I would perhaps maybe explicitly Mark that as a out of scope as something that is not tied to our code documents so I would take a chainsaw and probably remove three quarters of this paragraph beautiful thank you so previously we had also discussed splitting Discovery and configuration and one of the reasons I mentioned this is being provocative is we previously had a sentence that said Discovery is explicitly out of scope and this pulls it back in and one of the questions for our folks who are in the queue now is uh is that something we want or do we want to keep Discovery out of scope so next up we have Eric can I be heard apparently my video failed to start there yes you can okay"
  },
  {
    "startTime": "01:56:00",
    "text": "so let's just talk then so similar to the comments I made in I don't know an hour or so ago and also similar to what they were just saying now I think the big danger here of just being too broad is this work is if we let this working group essentially become the general proxy and working group so I think we really need to make sure that whatever we have written here is focused on only proxying for connect UDP and connect IP if it's relay or an extension to those specific topics I think very broad scope is good configuration discoverability extensions all that stuff is good but I think we really need to focuses on proxying UDP or IP make sure and possibly explicitly leave out anything that's General to proxying that includes proxy and TCP and all that stuff anything that's in that area is this working group is just going to become permanent if we just allow anything that's proxying related foreign next up Tommy all right hello um yeah I agree with what I've heard so far I I think the text maybe rather than saying core documents should be very specific and talk about enhancements to connect UDP and connect IP or however you want to call them um and be very specific about saying we should be doing work that adds missing functionality that you know prevents some use cases or is about improving performance or you know text like that um for some of the other things I don't think this should include authorization um I'm not sure what transparent modification of proxied content means um I'm also uh I I think maybe rather than Discovery and configuration maybe another way to put it would be to talk about coordination between"
  },
  {
    "startTime": "01:58:01",
    "text": "different resources like some of what Ben was getting at was you know recognizing that oh this one server does connect udpa and connect IPA and connect and I think there are also their functionality use cases that could be related to saying Hey I want to connect UDP that has the same local address as my connect IP to bundle them together so maybe talk about more how we are coordinating these different resources I don't have a specific test for that right now but that may cover the configuration but narrowly scope it um and then the last comment um I I think it's fine to say that we don't include the TCP stuff and that goes to http but again I would bring up like the TCP listening case is interesting and maybe it's worth bringing up to the HP this group of like you know if someone is going to do TCP listening proxies to mimic the UDP ones does http want to take that on or do they want to punt it over to mask because that's feels more Masky than normal proxies um Martin Duke uh so yeah I definitely don't want to read the proxy working group um the the current consensus I would say is that we're not also not going to be mask m and I I feel like this like we are open for any and all extensions to connect star is like not is like a mass gem Charter now I mean you know that's not written in stone we can decide that we want to ask the ITF to cup mask M and if so you know great if there's that much work to do but maybe we could scope this to actually some actual problems we were trying to solve like explicitly and I think this has been a very useful session we ran a"
  },
  {
    "startTime": "02:00:00",
    "text": "little proxy dispatch which is fine and like some things I think have already more or less been booted there um but not today but like over the next few um months we can uh figure out like a set of plausible problems that would be put in scope and if we choose later not to adopt them it's okay to not deliver all the all the all the things that are in the charter um and then we will have a nice stopping point to then reevaluate rechartering you know when when those those like concrete items are done thank you yeah so my uh follow-up question to that which I'd written down earlier was do we actually want to mention explicit documents and I think mentioning the explicit use cases we can always swap out documents may be a nice balance that we want to take yeah and like and and again I think it's important to say that something can be chartered we could just not do it for for various reasons that's fine too all right real Speedy Alex Google um one of the things which I found really interesting about the discussion today is sort of the overlap between some of the different things that we had like I'm not proposed to service Discovery per se and it's useful in some cases where you wanted to offer for example like a doe endpoint on your mass proxy so I'm particularly interested in figuring out how to put in scope a lot of these like layer breaking things that actually would help us make a high performance useful service so that is really where I think we should be focusing around those sorts of edges that way we avoid the like maintenance problem but we still get like real world use cases got it thank you Martin uh to type this point earlier about the scope of this this can be very broadly interpreted and I think this needs a very specific uh exclusion Clause following all of this saying that the work will not do generic blah blah blah because otherwise this is going to um yes you want to do all those things related to proxying but you also don't want to go out and Define new HTTP authentication mechanisms or all of those sorts of other things so I'd like to see that worked on"
  },
  {
    "startTime": "02:02:00",
    "text": "and David schenazi very quickly yep agree with folks here like maybe not quite as tight as explicitly listing all the extensions that were discussed today as only what we can do but very tightly like something close to that so it's not all extensions one thing that I just thought of that I might want to add and well we'll take it to the list is I've been trying the idea of writing a document that it that's that answers the question of what is a mask proxy uh because I that comes up a lot of work at work where people I hear someone telling someone else well just use mask and then someone says what does that mean and we don't have a great answer to that today I think that goes into like the discussion that we had with Lorenzo earlier of how connect connect UDP connect IP how all these pieces fit together and there might be space for an informational document and I don't know if that should be done inside this working group or I can just go dump my thoughts to the ISE but that's that's what we're discuss question I'd like to have a working group if we want to do it here or not and our recharger is the right time to have that discussion perhaps on the list sounds good thank you I see Lorenzo cheerfully out of the cube but at the mic let's go fast um yeah I just wanted to say I think trying to figure out what mask is going to offer I mean to me it's it's the ability to basically proxy at individ at the fine grain IP level can can we basically say that that's the goal and like all things that everything that is in pursuit of that goal is basically how can how can a a client appear to be at the proxy and still make everything work as if it were you know as if it were directly connected to the internet I think that might be a useful thing to put in there to navigate okay what is and what isn't in scope yeah thank you all right this is excellent we have gotten lots of really good input there uh we will follow up on the list with some links to very specific proposed"
  },
  {
    "startTime": "02:04:00",
    "text": "text as we go through that I think we're hearing a good consistency between the last meeting in this meeting in terms of the scope of what people are interested in working on and also super importantly we've got lots of really good energy from folks who actually are providing really awesome input so thank you all very very much for that and with that that concludes mask at itf-115 thank you all foreign"
  }
]
