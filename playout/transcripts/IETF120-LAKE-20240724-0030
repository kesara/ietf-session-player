[
  {
    "startTime": "00:00:09",
    "text": "Okay all right, so I guess we're at time We have a large crowd present so we'll press on Good afternoon, good evening, whenever you're We have a large crowd present, so we'll press on. Good afternoon, good evening, whenever you are. Welcome to the lake session from IETF 120 My name is stephen farrell. My co-chair, Militia is remote waving to you there As usual, kind of note well You've probably seen this today already or yesterday and you'll see it for the rest of the week. So we should be from familiar with all this stuff All the IPR rules. Be nice to each other We haven't had a problem in this working group so far on that So I'm sure you'll continue to behave well And note really well, be nice so uh again i don't expect an issue because we're not too controversial these days, which is good. For in-person, participants, please sign in You can use the on-site tool. If you're remote, please make sure your audio and video are all unless you're presenting or are talking making a comment in the queue if you want to make a comment please do join the queue, even if you're present in the room so we can help it And the headsets recommend it As you can see, malicious being very good There's some links. We'll come to the agenda in a second in a slide. We have no takers Thanks Giovanni and thanks Marco, who's remote For notes, we only need kind of actions and things. We don't need a blog by blow, but feel free to type as much as you like Brief is fine And Militia, do you want to talk about this? fine event you had yes so here is a quick update on the event that"
  },
  {
    "startTime": "00:02:00",
    "text": "we had in Paris in May in between the Vancouver and Brisbane meetings So because as you could see from the announcement of the event, because many of the LA community is based in Europe, we organized a hackathon that was very well attended We had more than 35 participants nine projects and more than 14 side meetings We kind of mimicked the IETF hackathon setup at Inria Paris premises in France. The event was very successful. We had so much fun and we are looking forward to the next IETF in Dublin where I guess most of the community will be meeting again in person Next slide, please So in terms of the adopted drafts in the group, so we currently have two the new one is marco ad hoc implementation considerations draft, which was adopted on 3rd of June 2024 It was resubmitted as draft IETF-Lake implement cons Mark will be giving an update about it during the meeting today And then we have the A lake odds draft, which is in its 0-2 version to be discussed during today's meeting as well so these are the two adopted items that we currently have, and we have a number of individual submissions that we will be discussing today, mainly on remote attestational over at Hoc and pre-shared key based authentication method in ad hoc With that type, I guess we can get to the agenda. So this is what the proposed agenda looks like if anybody would like to bash this agenda, now is the time, so please speak up"
  },
  {
    "startTime": "00:04:03",
    "text": "Nobody wants to bash the agenda Nobody wants to bash the agenda. So we stick to the proposal and we proceed with the first presentation, which is Giovanna, I believe Yeah. Yeah. All right so you can just tell me when to go the next slide i don't think the clicker is going to do it with my computers okay hello hello Okay, so this is Giovanni, and I'm going to present updates on the draft lightweight authorization using net hoc. Next slide please So I will give a quick recap on the protocol and speak about some merged PRs and then spend some more time talking about a new proposal which is advertisement of the lake Oats capability and then ask for input from the work group. Next slide, please So to give a recap so we are proposing lightweight authorization using ephemeral diffelman over koz COSE. Sometimes we call this protocol just alts or also just zero touch network joint. So maybe I'll use this term to using this presentation So we have three main entities, a device domain authenticator. Sometimes it can be considered just like a gateway in iutans contexts, and an enrollment service which can be analogous to a manufacturing server. And we will be referring to them as u v and w for brevity and the idea is that the device wants to join a new domain but it doesn't have information about the domain, only about the enrollment server so it will ask for for a voucher And then the domain authenticator, V, will ask to the enrollment server if this device should be allowed to enjoy to enroll"
  },
  {
    "startTime": "00:06:00",
    "text": "or not and the idea here is to allow a flexible provisioning and this works well if you have many devices that you want to deploy and you don't want to provision each one with a for each different domain you you you you don't have to connect to each device and provision different credentials because the all the information that is relevant is exchanged between the device and the environment server And something important, we are using ad hoc between you and v so the link here is constrained between the device and domain authentication So next slide, please So for a brief set of updates from the version number one, now we are in number two So we merged at a explanation with more details on how the error handling happens between the domain authenticator and the enrollment server We have some updated references now that a doc was published as an RFC We also addressed the extensive review sent by Marco. Thank you, Marco, for that. So we had some editorial updates We specified some missing co-op status codes We updated the name of one section And most importantly, we clarified about the credentials because before we were referring throughout the document to certain kinds of credentials for example, only using CC for authentication but that is a specializing without the necessity So we made it more broad. So this was a good change. We also had some small updates on CDTL definitions thank by this PR by Carstan and also another PR by Joran on the I read through And that's it"
  },
  {
    "startTime": "00:08:00",
    "text": "basically. Next slide please and now I'll talk about a proposal about advertising support of the Lakehouse Protocol Next slide, please So to give you some context. So at version 0,0, we identified one problem with the protocol is that sometimes a device you may try to join several times until it finds a suitable V. And why is that? Because for example, in the enrollment server, there may be a policy stating that a certain device should only join by via a certain V or a certain gateway or a certain set of gateways so if the device doesn't know which gateway it might keep trying and retrying to enroll until it finds the correct one. And this can consume time and energy, which are resources that we don't want to spend on battery-powered devices So we proposed a solution for this to use a hint that would be shared between you and W. But then we run into some issues, mainly the privacy of sharing these kinds of identifiers that we will not go into detail here, but we had problems with sharing this information around. And this would also increase the message footprint for the protocol so we try to think of something alternative to that So that's next slide, please so what we are looking forward now is to have a way to advertise the support of Lake Alti in a similar way to what can be done today. For example, when a Wi-Fi net now is to have a way to advertise the support of lake outs in a similar way to what can be done today. For example, when a Wi-Fi network advertises supports for EAP, for example with a flag for 802 for A.A.P Connections. So for example, we want to have"
  },
  {
    "startTime": "00:10:00",
    "text": "that V or the gateway can tell you the device about the support of the lake outs protocol And for example, this can be done by having V sending a piece of information. We are calling it V info to you. For example, it can convey that V supports, they call it, or then that V is part of a particular system For example, here Acme.com. And the idea with here is that is the same that I proposed. The goal is still is the same. So it's to, it's to prevent that the device will unnecessarily keep retrying. So we want it to just go directly or have better chances of trying to join via suitable V. And then the question is, how exactly is, what is the best way to do this? which is on the next slide please So for now we have two approaches that we think may work So one of them is based on layer two beacons and the ad hoc forward flow and the second one uses co-op and casts with a unit response and the ad hoc reverse flow So I will detail each one on the next slides For approach number one, we consider later two beacons and the ad hoc for the floor. So we have, I'm only representing entities UNV here on the diagram on your left So what we have is that I add this two first arrows. They are not part of the original protocol. So the idea is that we leverage layer two to carry the information about V in a beacon, what I'm calling a layer 2 beacon that is carrying V info in the picture And optionally, this may be preceded by a L2 discovery message"
  },
  {
    "startTime": "00:12:00",
    "text": "This is needed in some layer 2s two. So we make some assumptions here, or we have to make some assumptions here is that the layer 2 two can be extensible at the beacon level So, for example, this can work at I3E 802-154 which includes extended beacons that can be added, or also raw Bluetooth flowing energy, which is a technology that we use for a certain deployment at in RIA, for example but this can require profiling at certain later two And this approach also requires trigger packets, but again, it depends on the kind of layer two if this trigger packet is needed or not. For example, in non-beaconate i.3.E 802154 this kind of packet is needed And we are keeping the use of the ad hoc forward flow So it doesn't change the current state of the protocol And we already have something like this in the draft, which is in the COGP appendix, which already considers a discovery process with the difference is that we are adding here the V info information to be carried. Next slide, please And now I will present approach number two, which is about using co-op and cast response But here we use the ad hoc message flow So see that now we have far messages. So what happens is that you and V you are the ad hoc message flow. So see that now we have four messages. So what happens is that you and V is keeps being declined and V keeps being the server, but now you is the responder on ad hoc and V is the initiator So first, the client, you will send a co-up discovery message as a"
  },
  {
    "startTime": "00:14:00",
    "text": "as Unicast and this message is not redock yet, and it will be received by V and then if V supports Lake outs it will respond if not it can it will simply drop this kind of packet then upon receiving this we can send back a message to you again, with the V-info that we have been this discussing, but what happens is that we can already create, compose a message one and initiate a doc exchange. So that's why we have the ad hoc message flow here because V is a composing message one. And then this is sent to the device you and then the Voucher info, which corresponds to the enrollment request is sent on message two. And then message three, will contain the voucher with the response So with this, we also have some assumptions where we assume that layer two allows transporting packets before the enrollment takes places. So for example, this can work with Raw BLE or even Bluetooth flow energy with generic attributes And this also works as an automatic filter, as I said in the beginning because if the if V doesn't support Lake Oaks, it will simply drop the quo Co-Up any cast request And of course, we are changing here more parts of the protocol because we are using the ad hoc reverse message flow where you is a response and V is the initiator. And message one is carried in the co-op response and v info in the ead one so on and so forth for Voucher info and voucher Next slide please. So now for some discussion and impacts. So just summarizing basically points that I ask Next slide, please. So now for some discussion and impacts. So just summarizing basically points that I spoke throughout these two approaches"
  },
  {
    "startTime": "00:16:00",
    "text": "So with respect to layer two profiling, number one. So approach one requires updates in beacons to carry V info, and that would require one profile per layer two technology In approach two, may or not, may need or may not need layer two profiling as co-up messages can be just sent as payloads so all the definition can be made once in terms of what will be these co-up messages And then if they can be sent as payloads, then it's easier then next approach one is a smaller change because it doesn't reverse the ad hoc message flow Approach two, on the other hand, allows for ad hoc message one NV info in the same packet so it can be a little bit more efficient But again, it requires co-op communication before enrollment and the approach to uses the ad hoc message flow And one question here is if we think as a group that is it commonly as commonly deployment as the forward flow do we have any consideration on that? and what impacts do we have it on implementations? And also, if we use this flow, we have strong identity protection for V than you, because we reverse it as described in the ADOC RFC. And approach two also offers better protections for some features For example, Voucher Info is sent in the clear in Approach 1 because it's on message one but then in approach two it will be confidentiality protected. And similarly, for the voucher, it only confidentiality protected in Approach 1, but confidentiality and integrity protected in approach two So those are the main points that I see so far, and I'm looking forward to input of the working group and that's it thank you cool thank you So thanks. The discussion leading"
  },
  {
    "startTime": "00:18:00",
    "text": "this was interesting. So I'm grateful that people are willing to kind of consider these potential privacy issues and see if there are good solutions So yeah, now is a good time to jump in the queue if you want to discuss this I think it's a it's a good thing to discuss and we have a question Hello, thanks for this update Two points of questions One is, do you envision using co-op over get for the approach too? Because that does not trivial support any form of any cost. So if that's a requirement or if that is something that you want to use, I think it can be added but we should talk a bit more about that okay that's true. That's the point I have not considered about any cast on Bluetooth Okay and the the related note is that if the if you're going with version uh, with approach two, um, then it might be an option to send a bit of data in in related note is that if the, if you're going with version with approach two, then it might be an option to send a bit of data in the Bluetooth advertisements that are broadcast by the device And then this would not necessarily be a core message one. This could also just be a kind of layer two in basically a layer two information sent by the device and then the ad hoc messages would be as in approach two but it would not require the need the use of the reverse flow because but the RTV could be the co-app client in that case. So I think this this might be a bit of a hybrid thing between eight one 82, but I think that could work well, especially with very constrained devices that work better as a server I see, yes, that could work I think only I really, I really don't know how so the hard thing for me now is"
  },
  {
    "startTime": "00:20:00",
    "text": "selecting because we have a few approaches that can work and and how you can decide on which which one we think will be better because we have many options So I guess a question is does this have to be a single choice or? options. So I guess a question is, does this have to be a single choice? Or could you give kind of implementation guidance? for, say, you know, if you're in this scenario, then A1 is? better or in this scenario A2 is better? Is that a feasible kind of outcome? or it can be a recommendation, but uh i think we we should strive to specify as much as we can for our interoperability Sure So I guess, I mean, in this case, I think V is unconstrained more or less yes so it could implement if we had two approaches it could do both relatively straightforward yeah that could be yeah it's a good point yeah um mean, I don't think we need to decide it right now, but I think I'm guessing you would like to get this finalized soonish yes right because it could have to decide it right now, but I think I'm guessing you would like to get this finalized soonish. Yes. Right, because it could impact on a lot of the rest of the draft and so on. Yeah so do we have other inputs from people who are? remote or present in the room? so we can input from Yaron who thinks that both options can be supported depending on implementation also consider that identity of devices not protect in the A2 option So I'm just relaying from the chat Which I guess if V was somehow a person carried thing or in your vehicle your vehicle then in that scenario broadcasting the info mightn't be great. Sorry If V was part of your car then being willing to broadcast might be a bad idea at that point. Depends Seems a bit unlikely, but it could happen, I suppose. Yep. Yeah, I think"
  },
  {
    "startTime": "00:22:00",
    "text": "okay so I guess um I suppose. Yep, yeah, I think. Okay, so I guess, I guess for this, we just want to start up with kind of a thread on the main list and and try andres olave it that way yeah probably the simple thing. But I mean, I think if if we're if if if it's the case that V could you know, implementations of V could could support both options and then we can give some guidance as the house to each one, that might be sufficient for interest interoperability, given that this is like a, this is an optimal Yeah, yeah, yeah, it's true, it's true it's an yeah and all the advertisement thing as I see for now, it's optional as an optimization yeah yeah that could be yeah that makes sense So I already sent an email to the mailing list so whoever is interested, I welcome to comment Great. And so we should kick the discussion if it doesn't warm up. For sure. Okay list. So whoever is interested, I welcome to comment. Great. And so we should kick the discussion if it doesn't warm up. For sure. Cool. And I think that's the main issue with this with this draft that remains outstanding, right? Yep Okay. Any other comments on this draft? or on the topic? Okay, so we'll take it to the list and try and get it resolved in a timely fashion. Yep, excellent Thank you. Great, thanks And I think Marco is next Yes, everyone I'll give you control of the slides Marco. Yes, please Thank you. So, so everyone. This is Marco. This is an update on this working group document on implementation consideration for EDOC and yeah like my usual mentioned at the beginning it was adopted a month ago. So we are in version 1 now and the scope is unchanged of course it's about giving guidance on the implementation of edoc and edoc library or the use of edict by an application so rightly rightly doing so"
  },
  {
    "startTime": "00:24:00",
    "text": "the edoc rcd then focus on some implementation specific aspects focusing on the protocol in itself and it was then useful to have instead a separate document like this one providing guidance for implementers on different aspects. And those cover until version zero the adopted one where basically these three ones on what to do in principle if ad hoc session derival application keys are both becoming valid how when it appear can behave in terms of learning on the fly or not new other piece authentication credentials learn during a time adult protocol execution and the side processing, brain side processing of incoming ad hoc messages mostly in two aspects the fetching them validation of authentication credential of the other peers or the processing of EAD items and sometimes the two things go really hand-in-hand Okay, so some updates from this version The main one, I think, was adding this new section 5 with considerations on using edoc with co-op and with the co-op layer fragmentation, namely blockwise and this content builds on an appendix from the edoc curvc given the first definition of using edoc over co-op with the two possible message flows But it builds also on a document from the co-working group now with the RFC editor that continues with more details on the use of on the use of EdoQ with Co co-op for keying OScore and especially proposes also an optimized execution of edoc where thanks to a combined request that is possible to use only two run trips to both complete NEDC execution and make a first Oscar protected data exchange thanks to that so putting all this together using the original or the optimize workflow, it is possible to"
  },
  {
    "startTime": "00:26:00",
    "text": "take advantage of the blockwise fragmentation of the co-op layer or sometimes you really need to And it's good to have some considerations about that and especially when it starts being inconvenient or to lose some of the expected advantage and this sort of consideration used to be until some point part of the of the core document until we realized well enough that it was too much implementation specific or related. It was good to take it away that we did and now it's coming back here as in indeed considerations for an implementation So the details are in the draft of course but it's mostly about this three aspects in case the is a wish to use the optimized ad of workflow beyond supporting it in itself, of course without pre-requirements in terms of mostly message size limit if blockwise is used and available or not A sort of high-level comparison of performance mostly in terms of round-trip times for completing ad hoc and then a follow-up first secure data exchange in different situations. So depending on the size of the original data body to fragment and the size of the small block fragments using blockwise or not altogether and using edoc with the original workflow or dioptimic one. And an interesting takeaway, I think is a comparison in terms of round trips in case blockwise is used considering first case where the use of blockwise is not specifically triggered by using the optimized workflow and in that case that workflow is indeed convenient. It gives you better performance and one round track timeless Or, yes, there is a corner case blockwise may be triggered specifically by the use of the optimizer of workflow"
  },
  {
    "startTime": "00:28:00",
    "text": "and that combined request. And in that case, the optimized workflow is not better anymore in terms of performance. It can still be as good at least in terms of runtime, but there's even a risk that it performs worse So it's good for the application and it is totally possible to do that to perform an early scientific check before rushing because it may be just overall inconvenient to run this optimization that becomes in principle conducive to worse performance So that's one addition And another addition is related to the trust models that I look appeared another addition is related to the trust models that the network peer can rely on for learning on the fly or not credentials of the other peer. We had two policies defined already, trimmed down to three that we have until some point, if you remember, and building on that topic, I started the new section 3-1, describing some particular data of what this means what this process becomes in this particular situation when EDOC is run as part of a transfer profile of the ACE framework for access control, the EDOC and those profile. So in that framework and in the profile, you can issue an access token express in access rights for one of the other peers, the ASC client. The token is supposed to be uploaded at the other peer acting as resource server and the token includes the public authentication credential of C to be used in edoc There's a traditional way to upload the access token on the RS historically, but the profile is also defined in optimized way where the access token is conveyed in the ad hoc execution by means of any AD ATEM So in that case, and typically the first ever issued access token for that pair, of peers, CNRS is going to include"
  },
  {
    "startTime": "00:30:00",
    "text": "the authentication credential of C by value DRS may well end up learning brand new the credential of C without having going to include the authentication credential of C by value. The RS may well end up learning brand new the credential of C without ever having seen that before without having any stored yet. So practically for this two works smoothly by uploading the access token and the item, learning should be really the learning policy on the resource server. And there's this sort of consideration about this topic now in this section 3-1 3-1 and finally we have most of the draft already pretty well covering, I hope already the main expected behavior and steps to perform for processing incoming ad hoc messages also in terms of site processing mostly for, again, authentication credentials of the other peer and the EAD items There may be also some particular situations for now I call them that way So I started the section about that where more details can be provided on the processing of e-doc messages and to be a bit more concrete, I consider it again the case that I mentioned in the previous slide in this particular subsection on the Edoch and Dosco profile of ACE is mostly a editor's notes for the moment where for now I plan to cover mostly how to inform the learning policies and in case the non-learning one, if the IRS has a strong reason to enforce that anyway for that resource and basically the possible upload of the access token in a nearly item under this combination should fade and it's important to note and guide on how that can practically happen on the resource server. And you may also want to perform some sanity check ryan cross check between the authentication credential as indicated by value or by reference in the ad hoc message as usual and also in parallel instead in the EAD item"
  },
  {
    "startTime": "00:32:00",
    "text": "if that optimization is used It's all a bit provisional now because depending on how much this is real implementation specific it is indeed more appropriate for this document if we realize that something already important to say for the ACE profiling itself, probably that particular content can be moved out to the ACE document but early to say at the moment and I just prefer to start sketching this here So for now, I only have this particular situation in mind that profile is, but this new section 44 can be the right venue to call similar situation-dependent details, and I'm thinking of course of the other two documents that we have around in Lake, so outside and RA place to provide input and in case we can start a new subsection on more particular situation So this is the outlook on how to continue I plan to mostly build up on those editors notes I mentioned in the previous slide. I would like to have an appendix collecting certificates or other authentication credentials that can be just taken as using for testing and a good starting point is something that we have already in the traces RFC, but I like to have more security considerations, of course And again, people working on the implementation of EDOC in itself, the original protocol or use cases based on those, and again, also, at an array, most likely, please do chime in and we can arrange additional subsections with consistency specific on those cases Thank you very much Thanks Marco and within a second of the 10 minutes well done so I guess this document proceeds along as you described. Any comments or questions on this right now?"
  },
  {
    "startTime": "00:34:00",
    "text": "Okay, so in that case, I think we can move on to the next one. Thanks, Marco. And as Marco says, please comment on the list And next is Yuxha is attestation correct okay and i pass you control of the slides you come yeah you should have thank you yeah okay so hi am michuan and the draft is about remote attestation over I talk. So a quick recap of the initial version at last IETF. So we defined how to perform forward attestation in background check model. And one use case for it is that when a IoT device needs to rip attest itself remotely to a server for next one use case for it is that one IoT device needs to attach itself remotely to a server for network access or onboarding check. And we also define three EAD items to complete the process over ad hoc So the message flow is like the attester starts the remote attestation by sending an attestation program in ad hoc EAD1, which is a list of like all the evidence types that the attester can support to general the evidence. And then the Relyan party will reply with an attestation request in ad hoc EAD2, which is a single select evidence type. And then the attester will carry the evidence in ad hoc EAD3 So right now for the new changes, in version 01, we extend more possibilities. We define we also define the reverse attestation and mutual attestation, and then we consider both the background changes model and the passport model. And we also define EAD new EAD items for the passport model and a new ad hoc arrow to indicate when the attestation failed. So now for the attestation in passport model, the ad hoc session is still between the attester and the reliant party"
  },
  {
    "startTime": "00:36:00",
    "text": "And the process over i talk is that the attester will start the attestation with a result proposal in EAD1 Like I said, it's a list of all the verifier identity from which it can relay the attestation result. And the verifier identity here is defined similarly to what we have in ad hoc for ID Kreid, which is from Kozy Heidelberg perimeter registry. And then the reliant party will respond with the result requesting EAD2, which is selected trusted verifier in common with the attester and then the attester needs to contact with that trusted verifier to obtain the attestation result and send the result in EAD3 So for the reverse attestation one use case is that server needs to attest itself to be trusted by the device when a device needs to share some sensitive data with the server And here we, I'm also seeing input from the working group because we want to discuss about whether the remote attestation in background check model and the past port model makes sense. So in back one check mode the process is that the device will trigger a new ad hoc session to the server and server will send ad hoc message 1 with an attestation proposal in EAD1. And then the device sends the attestation request in EAD1 and server sends the evidence in EAD3 And for the passport model, it's still the device trigger the ad hoc session and this time the server says the result proposal and the device will reply with the result request and here concern about the attestation result is that what kind of freshness we are expected here"
  },
  {
    "startTime": "00:38:00",
    "text": "So I'm thinking of two options. The first one is, fresh attestation result with Nance, which is that the reliance party, sorry, the reliant party sends a nance together in the result request. So when the attester, receives the result request, it will start a new remote testation with the verifier and then the verifier generates a fresh testation result and then sent the result in EAD3. And the second one, is that when the attester finishes the attestation with the verifier, the verifier will reserve the attestation result with a timestamp to indicate the meditation period But this case, it will require a precise timing component And then it's for the mutual testation that we allow both the device and the server to be attested So here we are also looking for some advice from the working group to see if both the background check model and the passport model work So if the device has no connectivity construction, they can perform the mutual testation in background check model in the sides. So it would be like the EAD1, the device starts the first attempt with an attestation proposal And then in EAD2, the server will reply the type station proposal with an attestation request and starts the second attestation with an attestation proposal And in 83, the device carries the evidence of the first attestation and then reply an attestation request for the second attestation And then we need a force message which carries the evidence of the second attestation in EAD4 And then for the device that has connected problem, which cannot have,"
  },
  {
    "startTime": "00:40:00",
    "text": "many connections, they can perform mutual testing in backward check passport model So the device also starts the first testation with an attestation proposal and this time the difference is that the server will send a result proposal for the second attestation, which is in passport model. And in EAD3, the device will send an evidence for the first attestation and then a result request for the second attestation. And then the server needs to contact that trusted verifier to get the attestation result And here, sorry that I made a mistake for the figure for EAD4, because like this EAD4 line should be after the second green line because for sure, like, the EAD4 is sent after receiving the results from the verifier, sorry for that And then we also define a new at-hoc arrow which is to indicate that all the options complete successfully but the result of the attestation is not good. So it can happen in two cases The first one is that the verifier evaluates the evidence, but this is not in a good state And the second one is that the reliant party receives the attestation result, but the level of trust it can establishes not enough to proceed with the following actions So the Reliant Party will generate the attestation the reliant party receives the attestation result, but the level of trust it can establishes not enough to proceed with the following actions. So the reliant party will generate the ad hoc arrow and send it to the attack and it is the application who decides how to handle with the arrow method So for conclusion, we define the forward, reverse, and mutual testation flows. And we applied it on both background check model and passport model. And we defined the new ad hoc arrow to indicate the attention field and the most importantly we are looking for input from the working group to have to discuss like the freshness tag of the attestation result, either with Lance or"
  },
  {
    "startTime": "00:42:00",
    "text": "something with timestamp and also the feasibility of the reverse and mutual attestation and like any other advice So thank you for the attention and we are also open for more detailed discussions and collaborations you can send me the mail And we are now welcome in the year comments and advice Thanks, Mohammed Hi, Yukshan. Thanks for being awake at very late night. So a quick question. So you had the terminology of forward and reverse Is that a standard terminology or is that subject? that you have defined on your own? uh so for i talk to have a reverse ad hoc flow. But for reverse testation, I think right now it's new, because I want to like distinguish between the like when the server is a tester which is the reverse attestation, and the device is device attesture, which is the forward attestation so right now it's I think it's not standard before. It's like the reverse attestation is quite new. Yeah. Okay So then in that case, do you differ? in your draft what you have defined or what you think of it as forward and backward do you define the terminology section or something like that? Yeah, like I have a section separate to define yeah thanks Okay, are there comments? I guess I have a question next time Where do you think this document is at in? terms of issuing a call for adoption or? do you think this document is at in terms of issuing a call for adoption? Or I don't know, militia, have you thought about that? It is, this topic is on our charter. So it's a chartered, it's a thing we're chartered to try and address yes the charter is that the addressing the remote attestation using the rats architecture so this fits well in the scope of the Thank you So yeah, this is the"
  },
  {
    "startTime": "00:44:00",
    "text": "second time the Tushan has been presenting this, so I guess we could aim for adoption call soon Soonish sounds precise enough Yeah, I think that's that's that's interesting right. I mean, so i encourage people to read it and with a view to expecting a call for adoption in the next month or two probably before November Yeah, I think that's reasonable. I think that's reasonable Yeah. Okay, cool. Great. Thanks for example adoption in the next month or two, probably before November. Yeah, I think that's reasonable. I think that's reasonable, yeah. Okay, cool. Thanks, Xen. Thank you. And our last presentation is Elsa And let me just get the slides up for you Also, I can give you control of the slides, or would you rather I click through them? Yeah, okay I give it to you, there you go. OK so we don't quite have 20 minutes. I think we've sick, we've I'll be shorter than that So, twin. Thank you OK, so hello, everyone everyone everyone My, sorry, no. Okay, so hello everyone my name is Yelsan, I'm going to be presenting the ad hoc pre-short key-based authentication method that, well, we're working on the implementation right now So a bit of where are we at right now So the draft was published on the 4th of July and the call of the presentation is to present the current stages and the two proposed variants for pre-short key-based authentication in ad hoc hoc So a bit of, well, what's the motivation behind it? So the IETF Lake Working Group has identified pre-shute key authentication as a key objective in its charter"
  },
  {
    "startTime": "00:46:00",
    "text": "And so we're looking at regarding the infrastructure we're looking at billions of SIM cards which are already deployed worldwide. So by focusing on pre- pre-shared key authentication, we can tap into this network without requiring widespread hybrid replacements. So in instead, we can update the software which is significantly more cost effective And this approach also preserves the substantial investment that has already been made in this technology The strategy that we propose also facilitates a gradual transition to newer security protocols So by combining ad hoc with preserved key, we can create a bridge to a bridge between current systems and future security needs. So this allows for adoption of security measures by other devices that may not be capable of supporting the new authentication methods on their own This gradual approach also ensures backward compatibility, while still moving to forward with improved security standards So currently, the working group has proposed two variants or solutions for including pre-shared key authentication in ad hoc So here we have two images presenting the message flow for each of the variants, to which we refer as variant one and variant two. So the main difference is highlighted in yellow so it's basically where is the identity of the pre-shirt key credential sent So in variant one, following the approach of TLS, we said the ID-grade PSK in the first message in the clear whereas in variant two, authentication is delayed until message 3"
  },
  {
    "startTime": "00:48:00",
    "text": "and the ID-C-PSK is sent encrypted in message 3 3 So I'll go a bit into each of the proposal solutions So regarding variant one, we have in the left the message flow of ad hoc and on the right we can see the message flow of this current variant. So the main difference is are, first of all, the send the ID credit PSK in the first message in the key clear. We keep the message to the same as the message flowing ad hoc, but we use the Mac instead of the signature Regarding message three, we remove the MAC and the signature and we use the authenticated encryption with additional data for authentication And then message 4 remains optional, and it's kept similar to the ad hoc message follow There are also some modifications regarding the key schedule So basically these modifications include we substitute the credential of the initiative and the responder by this credit PSK So they affect some pseudo random keys such as PRK 3E2M and as well for a 3M MAC2 also is, it's also modified since in the context we are including as well the identifier of the PSK credential Similarly with the transcript hash, which include this great PSK Yeah, and the key three and initialization vector as well Regarding variant 2, yeah Oh, I see someone that has... Do you want to jump in NASCAR? Do you want to wait for? So scott rose going to the mic Okay. Behind you"
  },
  {
    "startTime": "00:50:00",
    "text": "Scott Flores is Systems, could you go back to slide five? Yeah That's five, not six. That's six yeah. Oh, okay. I believe that you're using uh basically the authentication that happens if the AED is actually able to validate, is that correct Sorry, can you repeat? Okay and you're basically the validation is in Message 3 three. If validation fails, the idea is that if the keys don't match that AAD is is, is, will fail The problem is that I don't, that's relying on a property of AADs, which is not standard Mm-hmm basically, an AED does not guarantee the fact, of whether or not you can have two different keys which both value the same message Okay so it would still be needed to add the Mac. Is that what? yeah uh you either need to specifically say you need additional properties of this AAD or do something else. Okay Okay, I note that. Okay Thank you you Okay, so continuing with the second variant This one includes more modifications with respect to the current ad hoc message flow So message one is kept the same. In message two, we remove the MAC or the signature because there's no authentication yet to be done. And then, Message 3 is composed of the concatenation of two cipher texts. So we have a first ciphertext"
  },
  {
    "startTime": "00:52:00",
    "text": "which contains the encrypted ID credit PSK. And then we have a ciphertext 3B which contains the authentic encryption with additional data Note that here for the external AAD, we are used the ID credit PSK as well And we are not using MAC either in this version And then Message 4 is still optional but in this version, in this variant, we do not a fourth message in order to have mutual authentication but it can be replaced, for example, by an Oscar message message So regarding the key schedule, again, there are some modifications which mainly include including this credit PSK in some of the pseudo-random keys or the transcript has. And then in addition, we have this new key stream 3 which is used for the encryption of the ID ID-Q-P-PSK in Message 3 So yeah, this table is used to compare a bit the different variants and what are the pros and cons So regarding the privacy, we see that in variant one we could say that it has lower level of privacy since the ID credit PSK is sent in the clear, compared to variant two, where we send it encrypted. In addition, in variant 1, the identity of the initiator is exposed from Message 1 and both initiator and responder are vulnerable against passive and active and active attackers, whereas invariant 2, the identity is protected until message 3 three and the identities are protected against passive attackers. The authenticate on type of data active attackers, whereas invariant two, the identities protected until message three, and the identities are projected against passive attackers. The authentication timing occurs in message one for variant one, whereas it's delayed in variant 2 until Message 3"
  },
  {
    "startTime": "00:54:00",
    "text": "This also affects the early access control, which is possible in variant one from message one and delayed in variant two Regarding denial of service attacks, vulnerability, we can say that variant 2 might be more vulnerable since yeah, until Message 3, there's still no authentication. Also, resource allocation, variant two requires more resources to be allocated before authentication And the key derivation timing is delayed as well And then regarding the completeness is we understand completeness as achieving mutual defense, authentication and key authentication, variant one is complete without message four whereas in variant two, we actually do need a fourth message which again can be replaced by a no score message So this leaves us with in both cases, three messages plus an optional fourth And then the number of operations is similar in both, with two asymmet operations and four symmetric operations So regarding the next steps we're working on the implementation of ad hoc with pre- research key in Lakers So the goal is to merge this pre-shared key authentication method with the already existed stats pre-shared key authentication method with the already existing, uh, um, stats that method, uh, which uses the static definition Helmand keys. And then we want to work on evaluating and comparing both variants in terms of security, privacy, operations, synergy consumption, memory consumption, or later And then compare them also against the already existing methods such as the signature and the static Diffy-Halman keys. And that's all for me, thank you Great, thank you, questions, comments comments? Thank you"
  },
  {
    "startTime": "00:56:00",
    "text": "thank you. Thank you. Questions, comments? In that trade-off between variant one, variant two, have you looked into whether it might make sense? to send the PSK ID in message? 3, sorry, in message 2, because that sounds a bit silly when you're looking at whether it might make sense to send the PSK ID in message 3, sorry, in message 2, because that, that sounds a bit silly when you're looking into the, into the co-op forward flow where the client is the initiator but when the client is the responder, this might give you a middle ground of the properties and still complete with message three and hide the PSK from a passive attack but not from an active attack which I think is the problem that variant 2 has as well um you have middle ground worth in this investigating. Yeah, okay, thank you yeah I don't yeah I don't remember if we are actually looked into this or not But yeah, thank you So I guess, I mean, this again is is a chartered topic for the working group I think in this case, it's somewhat more complicated So it, I don't know, militia maybe the right thing to do here will be to give, you know, see does anybody else have a different idea for how to do it and if this is the proposal or if we get other proposals I guess organize an interim meeting on this topic specifically I think that's a good idea. So we had a very fruIETFul discussion during the hackathon in Paris on this with several key participants participating in the discussions and essentially what else has proposed was presented is the out in Paris on this with several key participants participating in the discussions and essentially what ELSA has presented is the outcome of those discussions that were kind of not an idea, it wasn't an idea was still very, very focused on Lake And so in that sense we already had kind of a meeting to discuss this but having another meeting specifically dedicated"
  },
  {
    "startTime": "00:58:00",
    "text": "to PSC authentication, I think totally makes sense. And I guess we should be aiming for a timeline for a timeframe before the IETF 121 sometimes September or late September yeah I mean I guess I guess we can we can send a mail to the list saying we have this draft does anybody else have a another draft to offer and if we you know if it if it if it turns out that this is the main thing under consideration we can probably do something sooner in September If there's others, if somebody has another idea for how to do it that might need a bit more time yeah I think that's the idea. Yeah. I think this top can probably do something sooner in September if there's others if somebody has another idea for how to do it then that might need a bit more time yeah i think this topic needs some time and consideration anyway and probably some security analysis and all sorts of things So, but it's, you know, it's a charter item we should progress with it and we'll probably start that with an interim in the next before November sounds good sounds good that's reasonable in my opinion. So what else has been presenting, this is an individual submission, as you know So, yeah, we are looking forward to more discussion on this for information, the billions of sims comment that that triggered me anyway to say this this probably needs a bit of work Yeah I think it's good work. It's good that we analyze these things any other comments on this if not right? So we'll take this to the list and then to an interim likely I think that brings us to within a minute of time. Does anybody have any other business that requires less than a minute? Is that business or are you leaving? Otero's got to the microphone, so he even got in the queue. Terrell So in ICCPA, so in ICCB we started a project to actually standardize ad hoc now to 1540 So if there are anybody who are interested in that work, it's"
  },
  {
    "startTime": "01:00:00",
    "text": "starting probably in the, you know, the november prime frame or we might already have a meeting in september right so that's a that's an new ITApility project? That's a new project TG for, TG9A 9a. So it's a 159 which is key management for 154 and adding the headhog as one key management protocol there Excellent. If you could send a mail to the list with a pointer, that would be super Thanks Tara Okay and I think with that we're at time Thanks, everybody, and we'll see you on the list and with some interim meetings and maybe in Dublin in November Thank you, and thanks to our note-takers Cheers, militia I guess it's late for you I can probably have a look at the notes and send them out as draft minutes, unless you feel like staying up later I can do it tomorrow. It's fine Okay, great. Yeah, I'll set, yeah I can do it tomorrow. I think the guys have done a great job of taking notes so it's only a matter of formatting and then push them to the Datatracker go right ahead thank you Yeah, I'll be tomorrow. Thank you Cheers, bye-bye all right"
  }
]
