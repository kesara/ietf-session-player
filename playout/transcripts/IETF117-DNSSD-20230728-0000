[
  {
    "startTime": "00:00:23",
    "text": "Yeah. Oh, Okay. It's 5 o'clock. It's Let's start this session. So briefly, Since this is a different session, you will have to re register with the QR code. can use the one on the screen there. It's probably better. The note well still applies. puts you a all in the previous session. I think you're aware of that. so we plan to go through these items. in the second hour We do still have 2 or 3 slides from from SLP replication. which I like to finish first. And and then we'll move on to these. So I think that's where we whoa. pay a privacy. Yeah. We were we were I think we were done with peer priority."
  },
  {
    "startTime": "00:02:01",
    "text": "So Okay. Go ahead, Ted. I may have mentioned the conflict thing more than once. fact, I know I did. So I'll hit on this again in the TSR document, but Right now the way we're dealing with conflicts is is we're assuming that that when I conflict conflict when conflict did. We're assuming that that we're a fight with somebody that also wants the same name and for a different purpose. But Often, that's not the case. we tend to treat NDNS as a black box, And, you know, when we're doing SRP replication, that doesn't work very well. So You know, like, when when SRP replication is doing a registration then we shouldn't see a conflict. I've thought a bit about, like, you know, an anaptonax touched on on the idea of just having only one server do updates, which is certainly one way to approach this. other way to approach it would be to think about, like, okay. one of the ways that conflicts occur is that you know, we get an SRP update, The first thing we do is we publish the content of the update which conflicts with all of the stuff that's being published by the other servers. One thing we could do is we could update all the other servers first and only then publish the the VM, only only then published the update to MDS. and know, we'd have to come up with some strategy for how the servers how the how the services are deregistered on the other ones, if that makes sense. But that's one way to to just avoid these sort of, you know, self inflicted wound kind of conflicts. And then another thing is could we say that if you're not the primary, then"
  },
  {
    "startTime": "00:04:04",
    "text": "you don't do conflict probing because we already know that the record has in MDNS. And so there's no reason to probe it again. I think we definitely wanna do that if we can. I'm not quite sure how. Certainly, the current MDNS responder API doesn't provide a way to do this, but you know, you know, extensions are possible. But, yeah, I already talked about decoupling the name spaces, so I don't need to go into that anymore here. Next slide. And then I'm not I I didn't actually have a chance to to review the draft before I before I wrote this up. So I'm not sure exactly how much this differs from the draft, but they're basically like, a bunch of different state machines in the draft. In my implementation, they're all kind of mashed together into just two. And so I just wanted to call out what the state machines were us very off topic from the previous slide. So So on each peer, there would be these 4 state machines. One of them is just monitoring the active peers that this Pierre knows about. And so, you know, is that you know, like, do I have a connection with that peer? has that peer's information changed, stuff like that? Another one's monitoring operational state. Am I publishing or am I synchronizing or am I not participating? pretty simple, and others monitoring the state of connections. Like, I have a connection to the other peer? am I currently trying to connect to the other peer? Is the connection to the peer or from the peer? stuff like that. And then there's the SRP protocol itself. So that's something that I think needs to be clearly called out the document, and I don't remember whether it is. But it just when I was writing the slide, it came came to me to write this and so I did. I'm not sure that it's actually relevant. You know, does this Does that does this make sense to you, Aptan? because you've this implementation too."
  },
  {
    "startTime": "00:06:01",
    "text": "States and then Yeah. Yeah. That's Sorry. I'm a bad influence. That sounds about right. Yeah. are the states. And if I remember in the code, you use Phases and dates and stuff. Yeah. Yeah. So I think I think it makes sense to actually, like, know, in the in the SRP document, it would make sense to formally talk about each of these 4 state machines So I just wanted to get that down because because I was thinking it when I was writing the slides, and I think it's worth actually documenting. So that's all I have, I think, there another slide after this? Is No. just kinda left it there. kind of petered off into silence. so we can on to the TSRR. thing I guess is k. So the theme here is preventing friendly conflicts. And, you know, the original solution we came up with that is to remember when we received an update. and use the time since received as a way to determine whether a whether an MDNS advertisement or probe that we see is advertising stale data or new data. Next slide. So just gonna talk about a few things. One of them is operational experience as usual. and then some more about the adversarial versus cooperative approach. talk a little bit about useless probing, this kind of morphs into, like, an RFC 6762 update. I actually am starting to think that maybe rather than just doing TSR, we need to sort of just just just just really think about how we cooperative MVNS. and do an RRC6762 update that talks about that because I think 6762 sort of acknowledged that"
  },
  {
    "startTime": "00:08:00",
    "text": "was an issue and that we would wanna be able to do this, and has some ideas for how to do it. but but but but but but but but but but but but but but but but but but but but but but but but but but but I don't think there was a lot of operational experience with this 167 2 is originally written. in, and now we have some. So so it's maybe maybe time to use that learned experience. So let's talk about that first. Next slide. So know, CSR when it works, when we actually have all of the information we do the TSR comparison, we get the right answer. that's been a success. But lot of times, we have issues. We can get timing races it's not timing races may be the wrong way to put it, but, basically, we can we can come we can wind up in a situation where it's ambiguous which one came first. which is obviously problematic. That never happens if there's actually a conflict. If there's there's actually a conflict, the time is always gonna be different. but we get conflicts that aren't actual conflicts and then the time is the same. and and the decision that we make winds up being weird I talked in previous in in the previous presentation about incomplete sets of records in the probe. And the other thing is just that that TSR is specific to names not to update record sets. And so know, we might have like I talked about in the previous presentation, we might have a service instance name, and a host name update And those are in the same update, And they've got the same time stamp on them, but there's no way for us to tell that they're in the same update based on the TSR record. other than just the time stamp happens to be the same. And and there's no particular reason why we would go hunting for that name, and so it just doesn't wind up having any impact on the way that we do conflict detection. So"
  },
  {
    "startTime": "00:10:05",
    "text": "The other thing that's a little challenging about TSR is that we actually change the way we do detection Normally, there's two ways that we do conflict detection. One of them is Well, actually, they're both sort of the same. which is that we send out a query, and then we see what answers we get. And if we get back answers to our query, that are different than what we're publishing, That's a conflict. And and assumption is if we set out a query and we got an answer, The answer predates our query. therefore, it wins. I may be stating that slightly wrong. I don't know. Okay. Yeah. So and that that's sort of the the the normal situation And then there's also this thing called simultaneous probe behavior, and and that's There there's a section in 6762 that talks about this. Basically, the idea is suppose 2 devices register the same name at the same time, which By the way, what a weird coincidence is something we're doing all the time. So two devices register the same name at the same time. We see a probe from the device at the same time that we're probing the name, And then how do we resolve that? Well, it turns out that in order to make TSR work, we actually have to change simultaneous probe behavior a bit. And I don't know that I really need to go into the complexities, although I if If you wanna talk about that, I'd be happy to hear I was just gonna set a quick word for the people in the room who have not been deeply working on this. what Ted is describing is that the old model was first come first served. Right? you have a device on the network, if calledprint.local, and then you buy a new printer, while the old one was there first, it gets to keep its name. and the new one is printer 2, and hopefully that is pretty intuitive to all the people using the old printer, the new printer,"
  },
  {
    "startTime": "00:12:01",
    "text": "Once we add these proxies into the network, The thing that was there first is the thing that's stale and out of date. and the thing that's newer is newer and better and replaces the old one. So it it flips the logic on its head. And the simultaneous probing was a very rare thing, but it was there for the corner case when you have classroom full of computers, all connect to a power strip and the teacher turns them all on at the same time in the morning, and they all boot up. And They foolishly say, I'm imac.local, and you've got 30 computers all saying they have the same name, and And that it was a rare occasion, but the simultaneous probing was intended for that thing. You got plugged stuff plugged into a power strip and you turn it all on at once. That's not the common case. but the thing that is relevant here is that we've flipped that logic from what used to be the the the earliest thing has the prior claim on the name, which it shirt, for physical objects, the one that was there first should win. But for these proxying things, The old one might just be a stale entry for the same data, and that's where it becomes hard to know which case you're dealing with. Yep. Yeah. So there's an additional twist So so the the the first The first sort of insight that we had about TSR was just, oh, you know, we don't want 1st come, 1st serve. We want stale data loses. but only for for proxies. So we had to add TSR in order to get the new behavior without breaking the old behavior, But the basic theme of both of these is that we're assuming that when we see a conflict, it's actually conflict. n, n that's actually when you're doing SRP, with replication, not normally the case. So next slide. Why does that Okay. thought I'd give you black and or white on black. or black on white."
  },
  {
    "startTime": "00:14:04",
    "text": "Well, anyway, Probably not. Yeah. Apparently not. These are the old ones. I did. I I can't Don't worry about it. It's not a big deal. So Yeah. We've had this problem with Minako. We many working groups is, like, updating the slides doesn't work, I think. we can Yeah. I think the only way is if you, like, present your screen and have the PDF locally, which kind of unfortunate. Yeah. I don't think we need to worry about that. I just you know, as long as as long as everybody's okay, Yep. So yeah. Yeah. Yeah. This room is not awfully crowded. That's true. Anyway, so so the the the first insight was, you know, we want stale data to lose. which is new behavior, then the other thing is we're actually in an not in an adversarial situation here. We're in a cooperative situation. And so doing adversarial conflict detection makes life a lot harder than it needs to be. And so So can we do better if we if we know that we're cooperating without actually breaking the case where cooperation isn't the case. Like, you know, when you buy a new printer with the same model number is the old printer, and they aren't cooperating or when you have iMac on the network. Next slide. So Right now, the way we notice that there's a conflict is We look in the probe for the list of we we look in the probe for records on a particular name, And then we look in our auth database for the set of records that's on that same name, and if we find A set of records, in the auth database."
  },
  {
    "startTime": "00:16:01",
    "text": "and we find a set of records in the in the probe, then we compare them. If the sets are identical, meaning the exact same set of records is in both sets. that's not a conflict. So there's no problem. As I've mentioned previously, that doesn't always happen. So if we do detect a conflict, then we use CSR to figure out which one came first. which, as I mentioned earlier, a problem if the TSR is the same on both of them because it's not actually a conflict. So then when that happens, we wind up just comparing the RR data. And that produces the situation that I talked about earlier where, like, the host record gets conflicted on 1 and the the services obtained gets conflicted on the other, and they both lose. So So, fundamentally, what's going on here is we're treating every conflict. If it's a separate conflict, or treating HCM separately, And the reality is that they're all actually part of a group of records that was updated at the same time. So One of the things that I thought about doing that might help would be to And this this would be specifically applicable to SRP, although I think it could generalize. But Certainly, in the case of SRP, The SRP update is signed. So we could just take, like, the first sixteen bytes of the signature and put that in the TSR record and call that a hash. And so that's what that's gonna mean is if we have any records in our auth database, they're gonna have that hash on them. And so if we see a probe, that has the same hash, then we don't care whether the whether the data is we don't even need to compare date. They're from the same update. if there's if there appears to be a conflict, it's because the probe is missing some data. So that makes life a lot easier for us. We don't really have to worry about the completeness problem here because"
  },
  {
    "startTime": "00:18:01",
    "text": "it's fine if some of the records show up in pro a and some of them show up in pro b. We won't detect a conflict in either case because the hashes are the same. the hashes are sufficient sufficiently random, we can choose how many bits we use. But I think there's sufficiently random that the likelihood of a collision very low. And so then we almost don't need to use the TSR here. that is to say the the time But we will need the time if we see if we do see a kind of look like if the hashes are different, So but there's a little bit more to it than that. Let's move on to the next slide. Oh, sorry. benefits. We no longer have to keep the records together. already said that. we don't include all the records, it's still we we don't get a conflict like we do now. and So so we don't have to send necessarily all the records. Next slide. Okay. So only fly in the ointment here is that one of the things that can happen as we get an SRP update that changes nothing except the time stamp. But it has a different hash because It was signed a different time. It was etcetera. So So what does that mean? if if if If that happens, then what we'd like to be the case is that we first validate that the update didn't change anything, and then we can use the new hash, and we can maybe provide the old hash in the TSR record. And so when we see a probe that has both the old hash that we already know and a new hash can say, okay. This new hash is referring to the same data as the old hash. And so, again, we don't detect a conflict. And by the way, we update the hash. or maybe we don't. This is a little half baked, so I'm not cleaning. This is good solution on just"
  },
  {
    "startTime": "00:20:00",
    "text": "thinking about how to solve this problem, and this seems like it seems like there might be a pony in here. So So I think I think this this this might work I think we need to think about sort of the lifetime of this data. and whether we actually wanna update our internal database or whether we just wanna wait for the SRP update to come along and update the hash for us because it should, and then we don't have to worry about you know, the hash maintenance question, we just like we recognize the old hash and so we don't create a conflict. So the other thing about updates is you can get a partial update where it updates some records and doesn't update others. so you know, they're having sort of that comparison helpful. I think we need to do a little bit of analysis about what could happen here and make sure cover all the cases because one of the challenges with CSR is we really know, we thought it made sense, and and it made enough sense intellectually that I don't think we did thorough analysis of it. that's where we ran into trouble. So so next slide. The other issue is the TSR only goes out in probes. So if we see an answer that produces a conflict then don't have a way to tell that that answer is not in conflict because it's actually the same data with the same hash. So in other words, we might get an incomplete set of records that would produce a conflict using this the current conflict detection algorithm and we can't use the hash because we don't have it. So what can we do about this? It turns out that at least Apple's implementation of MDNS, if there's TSR in the answer section, will put it in the cache And we kinda didn't wanna have the TSR and the cash because it's It's a sort of a weird record. And it's talking about a relative time. And so it's you you you can't reason much about"
  },
  {
    "startTime": "00:22:03",
    "text": "the time based on what's in the record, you have to know when the record was sent. in order to use the time. So Sorry. Yeah. So so amazing how little train of thought I have when the when the reading material goes away. Look at that. Yeah. Is that easier to read? Yeah. So so, anyway, the question is, is there a way for us to to to address this problem. Can we somehow get the TSR information to probe maybe in an EDNS 0 option or something like that. and think the answer is probably yes, but We need to figure out how to do that. So I think And and we could actually just always do that. Like like, we could just get rid of the TSRRR type and have an EDS 0 option that does with CSR record doesn't. I think what it would do is it would basically say, okay. Here's a list of records in you know, by section. that are referenced by this TSR, here's a hash, a Here's a time. And so something like that. because right now, the the way we associate the TSR with the records and the and the answer is that the TSR has a has a name. And so all the records that are in the answer section or all the records that are in the response that have the same name are subject to that TSR record. So Anyway, so Uh-huh. Jonathan Lee. So I I guess Just idea that popped in mind instead of time since last received, like, What if the SRP update the SRP client included some kind of sequence number. Yeah. So"
  },
  {
    "startTime": "00:24:00",
    "text": "Actually, that was my first thought too. like like way back before we came up with TSR, I actually have code. The the our implementation until recently actually assumed that number would be coming from the client even though I never implemented in the client. the problem with that is that the clients don't remember the the the client the client doesn't have necessarily stable storage. even if it did have stable service, not clear that we wanna store the number in stable storage every time we update it. we're gonna update it like every hour. gonna say it has stable storage che. Yeah. But we don't update the key. Yeah. Exactly. So The other thing would be if it if it knew what time it was, but it doesn't. So Yeah. I I I I thought about using a sequence number, but I couldn't figure out a way to make it work that didn't by writing it into stable storage every single time we send it. And therefore, I eventually eventually eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, eventually, abandoned the idea Okay. That's great. Mhmm. Well, I guess, specific to threat threat does require a stable storage Right. Well, I mean, I'm being super sensitive about flash storage and rewrites and stuff like that. I mean, a 100,000 rights is not very many when you're writing a key because you don't write it very often. But if you're you're doing a 100,000 rights, lots a 100000 hours. So assuming assuming a renewal every hour. So a 100000 hours, how long is that? And there's some checks you can Yeah. right every time you You don't? Yeah. You you you can say, right, like, you know, 100 in advance. So You would you would divide by a 100, right, the number of rights, but but then you risk every time you reboot, you're recommending by a 100 Yeah. Yeah. Yeah. That makes sense. That's a good point. Yeah. Oh, I don't know. I mean, maybe that is a maybe that is a thing to do. I just you know, I didn't wanna rely on stable storage, but you know, that that could work. The only thing about that is I don't really know that we"
  },
  {
    "startTime": "00:26:01",
    "text": "care that much about the sequentiality of it. What we really care about is, like, Okay. There was an update and now there's been a new update. and -- a s. you know, like, we wanna be able to tell which one came second. But that that's where the sequentiality is. Yeah. Yeah. Yeah. wanna know which one's newer. Right. Yeah. Yeah. Yeah. No. I I I mean, just, again, very specific Right? Yeah. Actually, there's another argument against this, which I think is fairly compelling. Yeah. ain't in the current implementation. Yeah. That's true. So, you know, Always with stuff like this, the question, it's like, we're super easy to update servers. It's not so easy to update client. So do you really wanna update the client Yeah. Yeah. No. No. So Yeah. Yeah. So I I think, you know, we could we could fall back on that if we conclude we don't have a solution that doesn't require it. But if we can come up with a solution that doesn't require it, that's probably the right thing to do. Anyway, So next one. Yeah. So I talked about this in in previous presentations, but, basically, the issue of, like, if we have 5 advertising proxies, each one of them has to probe before registering. That's based that's built into the in RRC67 2. So if we wanted to do something different, we would have to update our C6762. I think it's worth thinking about doing that. I don't think that we really need to do all the stuff we're doing right now when we have cooperating, proxies. The original multicast DNS RFC does include a concept of, I think, we called it known unique records -- Yep. where it is assumed that the uniqueness has been determined by some band mechanism. So probing is not required. Yep. So"
  },
  {
    "startTime": "00:28:02",
    "text": "Is that something you thought about using that? We thought about that. I think I tried that, and it was not successful. And I don't remember the details. Part of the problem is that Knownunique is an assertion which can be contradicted by evidence provided by the network. And so we can still reg we can register a record and say that it's known unique, but then wind up with a conflict. So maybe you it let it does let you skip probing, Yes. If it sees another device answer with conflicting data. Right. Then it will kick it back to the client and say, you told me this was unique, and you lied. There's somebody out there saying something different. Exactly. So what we need is known to be really unique something like that. And so, I mean and the the problem there is it it actually goes back to the previous slide, which was talking about can we send the TSR and answers? Because if we could send the TSR and answers, then we wouldn't maybe we wouldn't have this problem. The reason we have it now is because if we don't probe, we don't get to do the TSR based conflict resolution because it's only in probes. So if we see an answer like, we published known unique, and then we see an answer that seems to be in conflict. don't have the TSR records. So we have it's just in conflict. We don't have any way to ambiguate. So Yeah. So so getting rid of useless program would be really nice. And we may be able to just use the known unique thing plus maybe an improved TSR solution to avoid that. And, you know, one of the problems that I think may be happening, and I haven't been able to prove this, but it's a suspicion is When we are doing synchronization with a a new peer We do all of this probing. and it all happens kind of at once. And so that means that we send, like, a lot of multicast traffic all at once. at which point, I suspect that some Wi Fi access points may say"
  },
  {
    "startTime": "00:30:03",
    "text": "I either just accidentally because they don't have enough buffer space for multicast data more intentionally. They may just say, Screw it. Screw it. There's a there's some kind of weird multicast brokenness going on here. We're just gonna block multicast for a while. And so then we see that multicast stops working for a while. or possibly forever. I don't know. we haven't fully characterized this, but we definitely see multicast unreliability I suspect might be associated with this somehow So if there's a way to avoid these kinds of bursts, I think be very much worth doing. Yeah. I can I can reinforce that. I'm not gonna say confirm. because I think we're both speculating a little bit, but I've definitely seen home Wi Fi access points where the UI has some checkbox that says guard against multicast traffic storms. And you look at that and you think, what does that mean? Yep. because There's no ATF standard that I know of or I probably, for what constitutes a packet storm, So who knows what these different vendors are doing to implement this protection? And by not having a spec, As a client writer, you don't know what behaviors expected of you to avoid getting in trouble. Right. So Like, we could we could modify our code to limit a number of packets per second if some spec, somewhere said. devices should send no more than 10 multicast per second per device. then we'd say, okay. We will make sure we comply with that. But there is nothing written down comply with. Yeah. So, I mean, you'll you probably what you just said is one example of this. and, you know, another example of why I feel like you know, I was Aptan and I were talking about this during the break. one of the reasons why I kind of like load balancing versus just having one server be the head. is because that means that the amount of multicast traffic poor source is reduced even if the total amount of multicast traffic is exactly the same. And that, I think, might Also,"
  },
  {
    "startTime": "00:32:03",
    "text": "prevent some of this adaptive behavior. But as Stuart said, we don't know. We're just tiptoeing around with our fingers crossed hoping for the best. No. But but I think that this approach might might actually improve the multicast DNS reliability that we're that we see. So so Next slide. Okay. This is another thing that has to do with the 67, 62 update. right now, when we send multicast DNS messages, we send them both over IPV 4 and ipv6 because we don't feel safe in assuming that All hosts can process ipv6, and We don't We don't we don't wanna just send IP before because we might be on a v Six only network and Yeah. So It seems like it'd be worth thinking about not doing this. And I'm not sure exactly how to solve this problem. I I suspect to a first approximation if we just did this on modern devices and we literally just stopped sending IPV 4 packets entirely. except for queries, for I mean, took enough. I'm hand waving a little bit But But I think we could come up with an algorithm that does a pretty good job of sort of noticing if If there's ipv4 stuff out there that's not ipv6 capable, and cents queries. that way. But, otherwise, just sends everything over ipv6. probably something we could do. I don't know Eric. Erie Green. No head here. you know for sure that there is a DHCP V Four option now. tells you this network is a pv6 only."
  },
  {
    "startTime": "00:34:02",
    "text": "That's also really your problem, not the case, but it's all part of it. Yeah. The problem with that is that I really wanna make this traffic go away if if if What I want is to know whether the network is whether every device on the network is V Six capable. rather than that the network is by policy v Six only. because by the time by if it's by policy VCs, only then absolutely. We should just stop sending IPV So that's actually I mean, that is a good suggestion, and we should implement But I think that we need to or I think we should consider whether the whether there's more we can do to improve that situation. I'll talk about this a little bit in the next deck. So So if we had haven't blathered on long enough. Next slide. So Remy is next in the queue. Oh, Hi. So running the event for Google. So I'm Actually, I mean, looking at the implementation on MDI some like, the Android side because, like, we've got a few clients actually for these new use case is a thing else. One thing I've been told then for this kind of problem was that basically, hey. the service. that I'm getting advertised is that being advertised by your device that only does receive. Therefore, there's no point for you to advertise it with people because, like, once you know, even if you can find the service, there will be no way to connect to it. Right? that's maybe another thing to consider. Like, hey. know, the services being advertised, is it actually advertised by the the device that's trained to listen to you know, request over the six afterwards. I have it if it is basic, I'll need them. Yeah. You really don't need that because it's already full. because there will be no way to connect to it. That's true. I'm not sure when that would really be the case though. Yeah. you have a a dual stack network your prob your service is probably gonna be to a stack. just because it's listening on you know -- Oh."
  },
  {
    "startTime": "00:36:02",
    "text": "I mean, in practice, for example, it's like, you know, when you have devices on thread, that only have the 6. then there's no no point, basically, you know, advertising them over before because any device I want to connect to them will have to use these 6 anyway. Yeah. Thanks. That that that was a really great clarification. I hadn't connected that, and that's a very good point. those devices, we definitely don't need to advertise over v over v 4 because if the node doesn't speak V Six, it's not gonna be talk to them at all. So, yeah, if there's a way that we could have a flag that says is v Six only. Don't bother. That would probably be good. Yeah. I was just gonna echo that that our use case is b 6 only. Mhmm. And I think there's a way with Avahi to specify only ever ties on V Six. Mhmm. but not with MDS responder. But -- Okay. -- even in that case, maybe consider better protocol support. Yeah. Yes. No. That's great. Thank you. The reason I stood up we'll have to think carefully about how the two queries interact because if one of the design goals in multicast DNS is that all devices on a network see same view of the network. Yep. We don't want the situation where your your tablet sees something sees the printer and your phone doesn't, and now you're confused because they be saying the same thing. If if we have a situation where a client does a V Four query. For the list of devices well, for a particular device type, and it includes in the known answer list. Here are all the answers I know. But one of those is a V Six answer. then The V Six only device is not gonna answer that. Right. And other devices on the network are gonna see"
  },
  {
    "startTime": "00:38:00",
    "text": "There's a query here And and I was expecting to see this answer, but the answer is not there. So must be a mistake in my cash. I'm not gonna try to work it out now. We don't have time, but just -- Yeah. -- I'm saying, let let's remember make sure those don't interact in unexpected ways. Yeah. I mean, I think if we get a v Four query, a pretty clear indication that we need to do before. But if we don't, So maybe we shouldn't send v 4 queries unless we don't get an answer on v Six. something later. And I'll very quickly say plus one to Eric, think, suggestion that if the DHCP v Six only option is there, we should respect because that immediately halves our multicast rate, which is especially valuable on WiFi. Yeah. for operators who are choosing to send that option, we should assume they meant to do it, and we should respect Yep. Yep. Yep. Cool. So there's more to talk about this. I'm not gonna go into more detail here because, you know, it's it's we need to just talk about it. probably at more length. Next slide. anyway, kind of where this has all been going, I think, of So, probably telegraph this month or twice is is that I think we actually need to write another document that updates the RC6762 protocol spec to deal with sort of the new stuff we talked about here. I don't wanna do, like, a really big document but I think we have some pretty clear things that we can think about. I don't know if we can do anything about the IPB sick stuff, but, certainly, we've had some ideas here of things that we absolutely could do. and we should do those. And then because, certainly, like, just not doing IPV 4 traffic for thread border routers. like, that's the one that's causing, like, that I mean, thread border routers are doing way more multicast traffic than anything has been doing historically. So Just getting rid of that one case would actually make a huge difference that's totally worth doing. We should put that in the spec. we should"
  },
  {
    "startTime": "00:40:01",
    "text": "Think about whether there's a way to avoid probing that we can make work with TSR. In other words, you know, advertise known known unique, and then and then send TSR on our answers so that we don't get spurious conflict. Think about whether there's a way that we can improve TSR so that so that it's when we have a clear match, we don't have to do weird records that disambiguation stuff. and Anyway, that's sort of the general idea is is I think there there's a fair tight set of things that we already know about that I talked about in this slide deck. that we could put into an update doesn't have to actually be, like, 67, 62 completely Again, plus changes. It might even be better for the implementer if can see the changes as a separate document. So the way I would propose to do it. That's it. Or is it? No. Yeah. So deaf. Yeah. think I'd summarize what was on this slide and what I just said. Next slide. That's the last one. Alright. We're done. So now all we have is the very brief slide deck that follows that. And then, finally, Somebody else can come up and talk. Okay. So the last thing I wanna talk about is just the problem of infrastructure DNS SSD because something. I've mentioned at other ITFs, and I really want us to you know, we've we've done a whole bunch of work to make DNS SSD work over Unicast, but we haven't really put all the pieces together yet. And so we're not actually seeing it deployed in the real world. And I'd really like to happen in the real world as opposed to just in our imagination. Next slide. Next slide. So what we have now you know, in the IETF printer room, Stuart gives us this example every time he talks about it. You know, we have a printer that is statically configured in the DNS with"
  },
  {
    "startTime": "00:42:00",
    "text": "be an SSD, records, and so you can discover the printer, and you can print on it. It's great. and we have MDNS. and Also, we have now thread border routers, thread border routers, do SRP, do advertising proxy for SRP, and they do discovery proxy thread nodes. So a thread node can discover MDNS Services advertised on the infrastructure network using discovery proxy, which is unicast DNS. So that's pretty cool. but it's a very limited use case. So We have specifications, obviously, you know, since we've got it in the thread border, we have for SRP, the discovery proxy, NDNS, dNSST over DNS. We we have all of the building blocks we need to put together unicast, unicast, do an SSD, Why don't we have it? So next slide. So what's missing? know, so there's kinda 2 use cases that I would think of. 1 is the managed setting, like an enterprise network, and 1 is the automatically managed It's not really unmanaged, but but it's machine managed, let's say. with no user intervention. That would be a small office, home office, or just regular home setting. I don't think there's a huge difference between home and home anymore. So problem with that is that we don't have SRP support. We don't have discovery proxy support. or anything like that in pretty much any I I don't know of any home router that implements these. And, certainly, we don't have a way to take a thread border router and integrate that into a home network that supports this because we don't have this. also don't see commercial solutions. Next slide. So My theory is that we don't need to care about commercial solutions because if we come up solution, for the home, commercial will follow. That's been the way that the Internet is generally sort of grown over time."
  },
  {
    "startTime": "00:44:00",
    "text": "So then to me, the priority is getting this into home routers. And how do we do that? I think you know, we can have a couple of different unicastian SSD functions. We can have home home routers do discovery and advertise that. We can have home routers do SRP registration, We also need the things that are consuming this, at least you know, you know, a preponderance of them to start trying to use multicast in instead of multicast. Otherwise, we can't shut off the multicast. or minimize the multicast. So that means that, you know, Android phones, Apple phones, your laptop, whoever made it or whatever, they should be doing Unicastian SSD queries, in favor of MDNS, in order to do that, we have to tell them that that's available. So and this is stupid stuff. Right? It's not hard, but we have to do it. We have to advertise a service on the network that says, you can just do MD and s On in this domain, to this server, server, and you will get or sorry. You know, unicast DNS to this domain and this server, and we will do MDS for you And so now everybody's going through the same ending as cash. It minimizes the number of ending queries that go out over the wire, minimizes the number of answers that go out of the wire. Everything that can registers with SRP and gets advertising proxy service for devices that do MD and S queries for that service. So, basically, that's the thing that I would like to build. And then also the ability for a stub router to say, hi. I'm doing SRP over here, can you integrate this into your discovery set of discovery zones? So that's what I'd like to see happen. There are some discussions going on in other standards bodies about this. But ultimately, the IETF needs to write these specs. The the other standards bodies aren't gonna write these specs. They might"
  },
  {
    "startTime": "00:46:00",
    "text": "refer to them and say you should implement this, but that's about the best they're gonna do. So here is where this has to happen. So this is something I wanna have happen. Obviously, we've got plenty of work on our late right now, but I think this is pretty important too so I just wanted to mention it. Is that on a slide or is it more? Oh, so you guys think about this, if anything, thumbs up. Alexander. Hello. I've been looking and trying if this sort of things applicable to discovery in the cloud. because having looked at all those crazy solutions, that people put together that kind of widespread when we've got DNS servers. I'm wondering if this is one of the possible use cases maybe that someone's thought about? Or is there a reason not to go down this path So the problem with that is that you need to know where you're looking to do discovery. So the way that way that RFC 6763 talks about this is sort of network specific. You take your IP address and you form a DNS query based on that and you do a reverse lookup. that tells you what browsing zones to use on this network. So that wouldn't work for sort of arbitrary service discovery, but Stewart, just got up to the mics. I I wanna make a very quick comment because I wanna leave time for our last presentation. I think this is really important We've had multicast DNS for about 20 years. during those 20 years, we've gone from predominantly Ethernet to Wi Fi And as WiFi unicast rates have got faster, multi cast has not. So that gap between unicast and multicast performance on Wi Fi would we're all using right now has got more and more Wi Fi has got It's more wasteful spectrum. It's less reliable. and every year, this same problem comes up. You talked about"
  },
  {
    "startTime": "00:48:02",
    "text": "access points doing multicast stormlimiting, we've known about this problem, and every year, we put off fixing it till next year. Yep. Yep. And then and then where as a community kinda look dumb to the people who are relying on our services when And you and I know, at Apple Tread with home kit and AirPlay and things like that. they're grumbling that the service we provide to them is not what it used to be, So We I think it's really important that we fit this because at this point, if we don't, we're just dropping the ball. And then the other thing I'll mention very quickly in CSA, the matter work, Matt also depends on discovering the devices in your home. So There is interest there. in making a template for what does a good home network look like that will work reliably. And some of that specification work could be done in matter Some of it, I think, will be better done in the ITS. So that's another area where I my ideal solution is we work on this we work out the right solution. We present the RFC or the draft to CSA, and they say that also, we will include this by reference in our list of vibants. Yep. Yep. Yeah. That's exactly what I have in mind. By the way, I apologize, Alexander. I think I slightly cut you off, but this is what you brought up is something we should probably discuss on the mailing list because I don't think know, we we don't have time to do that topic justice here. Jonathan, for me. Just wanted to reiterate. Yeah. as I do think it's an important problem to solve bye. you from a know, Like, we're we're talking about access points, but see a lot of Wi Fi clients that are trying to reduce their power and multicast is a big impediment to that. Yep. You know, they play games today about Oh, we're just gonna drop arbitrary multicast capacity because we wanna save power. Yep. And, you know, we're also trying to play games with MDMS filters and stuff like that. So"
  },
  {
    "startTime": "00:50:01",
    "text": "Like, that's all kind of silliness if we go to a unicast Right. Okay. Yeah. So I think we should probably stop so that so you have time to talk. But Thanks. Thanks, Ted. And we're definitely getting from the room that this is interesting and worth working on. So we invite folks to bring this to the list. And, Ted, you know, you were mentioning maybe this A new draft that updates 6762 is warranted. maybe start the process of finding a coauthor for that. and anyone in the room If you think that sounds like an interesting project to work on, reach out to Ted. Ted Nice. Alright. Go ahead, Nate. Alright. So good evening, everybody. Nate Carson's with Garmin and the National Marine Electronics Association. Next slide. So we're at IETF to kind of work on a number of different standards related to improving multi cast, in multicast snooping environments, specifically for boat networks. with multiple sensors and multiple displays interested in that data. So there's 3 different standards or Internet drafts that are listed there all related to this. But all those, One one thing that we still need to do is if you've got all these different multi streams out there. you still need to wait for the display or the user to say, I'm interested in the stream. How do I even get to it? How do I subscribe to it? So next slide. So with that, one idea we had was a kind of a new way of doing a DNS based multicastrian discovery. And, I mean, the the main point from that is just including a multicast address in the a orquadae records. to tip."
  },
  {
    "startTime": "00:52:00",
    "text": "to use that multicast address. think probably one of the things we came into this meeting, not in this early knowing is if anybody was interested in in this and pursuing in this working group here. I think Stewart has posted something to the the mailing list saying that it it was of interest. So I think we would still pursue that And then They So we're off also offered to suggestions here. One is to no longer do or or to not use mcast. ARPU. was originally just included to kinda highlight the fact that this is a multicast that US, but we do recognize that can just look at the contents of the record to know that that's multicast. So I definitely agree with that. and load, your comment about being how, not what is definitely useful. and looking forward to to what to do next. The other comment that Stewart had was that we should also consider what do about source of specific multicast. And so I don't have any ideas myself on that. But and the time that we have, if you have anything to to mention, that'd be great. Yes. I didn't mean to put you on the spot. I only sent that email today, Mainly, I wanted to thank you for thinking about this and writing this draft and presenting it. This question has come up before. at both in this context and just broadly in the case of multicast when you're using dynamic multicast, how do you discover what the multicast address is? It is just like service discovery. in a different context. No one before actually wrote that down, and they just just talked about it in the corridors. So Thank you for writing it down. I'm hopeful that this will be a fairly simple draft. that we could move through the process fairly quickly. It shouldn't be very long. it shouldn't be very complicated. but it's good. Even if we decide the conclusion is relatively obvious, it's still good to write down that obvious"
  },
  {
    "startTime": "00:54:01",
    "text": "conclusion so that other people stop discussing in the corridor and just have an RFC to refer to. So You sent email about a month ago asking and Unfortunately, There wasn't any reply. I'm guilty of that too. from So I sent you a reply today. And and I hope other people will at least read the draft and give comments. we can work together. on making these little refinements. I think the basic idea is good. as you know, from the email, have some thoughts about how we might do it a little differently, but but but but but but that's normal in this process of refining an idea. So so thank you for doing this. Let's work on getting updated draft out. And after we've done that, let's hopefully get more feedback from other people at this stage. I would suggest other people wait till we've updated it and and then send feedback. But but Let's try to get that done and get some feedback before the next meeting. Yep. Absolutely. Thanks. Thanks. You can go to the next slide. just kinda notes some other requirements that we'd wanna include in here. for instance, the service name should be UDP because that's what you use with multicast. and then the advertise port thing about this that's different than unicast services is that you have to have that coordination across all of the devices as to which port they're using. So that port does have to be preassigned by Ayanna or maybe if you have a a very, like, isolated network, you can just, you know, can here that yourself as an administrator So the document does describe that. and then it also lays out the advertisement of PTR Records, reverse lookup of what those multicast addresses are in the chosen host name or group name."
  },
  {
    "startTime": "00:56:02",
    "text": "I I wanna be quick because I'm conscious that we're almost out of time This is really a question for the multicast experts, and maybe we should reach out to them. The point you're making here is something that is sort of bugs me about multicast for a long time. the port number is pointless and stupid and shouldn't be there. in in a way if we could do things differently, maybe we wouldn't use UDP for multicast maybe we would have a protocol called multicastatagramprotocol because The idea that your host joins a certain multicast group And in the case of wide area multicast, it's actually setting up forwarding in routers, And this packet might make its way multiple hops to the Internet to get all the way to your machine and then it looks at the port number and says, nope. Throwing it away. That's a huge waste of bandwidth and battery power and spectrum and everything. If you didn't want gas group. And if you did join the group, presumably you want to receive the traffic. so the idea that you've got this 32 bit or 128 bit multicast address that identifies the group of receivers And then you got these extra 16 bits. that if they're wrong, it throws the packet away. it's It serves no purpose. you know, I don't know what current APIs allow. If it was possible just to use UDP port 0, and say, we don't care about the port. Right? a packet arrives, I wanna receive it. Mhmm. That sounds like a conversation for the multicast people. But, yes, I agree. This this this need to have an ion and reserve multicast a bike, reserved UDP port for every multicast protocol, just because they're sixteen bits that have to match all the packet gets thrown away. it's it's just a really crazy situation. So so so That was a bit of a tangent, not related to what you're saying, but I'm agreeing with your points"
  },
  {
    "startTime": "00:58:00",
    "text": "order number, it's it's just this weirdness Yeah. No. That's a great point. And so with the other documents, we're working with the PIM working group on that. I can bring that up. meeting tomorrow, we can start the conversation on that. Next slide. this is just an example that kinda brings all of the of various standards that or documents that we have. around this problem space altogether and into one spot. The highlighted one, talks is mostly giving an example of what the address allocation protocol outcome would be, and then everything else that's not highlighted highlighted is more related to what we're talking about here. is basically That's it. Yep. So so, and we're we had, like, a minute left. So Any other comments questions before we wrap up? Alright. Thank you. I'm gonna repeat my thanks for doing this draft. Let let's keep in touch. You can take a look at the the suggestions in my email. If there's anything not clear or you disagree, let's have a discussion about that. maybe we can find other co authors who want to get involved to but I definitely wanna help you get. a revision app Okay? That's great. Thanks. Cool. And thanks, Stuart, for the reviews. Thank you for the presentation and for And just a quick comment and easy one. I don't know whether the example you are using EU 64 receives. don't know whether they see your arrest or draft, but please do not use EUC for the system anymore. think they're 48. Yeah. Yeah. I think a pd6 enthusiast. Alright. Thank you so much. Alright. Thanks, everyone, for coming to DNSSD the second session. Great time today. And as usual, we'll see you on the list and in Prague. and the words interim was spoken, so we might"
  },
  {
    "startTime": "01:00:02",
    "text": "potentially do that, but let's coordinate on the new list to figure that out. Thank you, everyone. So"
  }
]
