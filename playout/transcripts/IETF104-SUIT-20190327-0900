[
  {
    "startTime": "00:00:19",
    "text": "[Laughter] yeah this is beer night so good morning this is software fits for Internet of Things seats working group so this is the new well I\u0027m sure you\u0027ve seen this many times this week so this morning we have we have a jabber scribe Thank You Ludwig we need to no takers any volunteers we\u0027ll wait that\u0027s one and your name Robert thank you yeah if you could use the ether pad that would make things easier so this is our agenda for today any agenda bashing so working group status so so far we\u0027ve adopted the architecture and information model drafts as working group drafts we\u0027ve also received a leis on statement from the itu-t SG 17 which we\u0027ll be talking about in a little bit they\u0027re working on a document describing usage scenarios around software updates they\u0027ve shared a draft document with us that\u0027s posted out on the data tracker and they\u0027re seeking comments on that draft as well as alignment with the work that we\u0027re doing here in the working group their next meeting is in August so if we\u0027re gonna provide comments we\u0027re gonna have to provide those by then we had a hackathon project at this ia TF and that went well "
  },
  {
    "startTime": "00:03:23",
    "text": "we\u0027ll be hearing a little bit more about that as well later on so milestone wise we\u0027ve closed out quite a few of our milestones but we have a few that are a little bit delinquent I hope is that maybe we can we can make some progress on those today so we\u0027ll be taught more about about the manifest format a little bit later as well as the information model so we should definitely make a considered effort to try to catch up on these milestones assume and that\u0027s it for the status any questions all right so first up on the agenda is the liaison statement the CRA\u0027s is this first click present here and I guess okay so I\u0027m gonna provide a quick update on the leis on statement that we received next slide police so the the document that the itu-t is working on doesn\u0027t define specific protocols or formats they\u0027ve noted in this document that that we are working on a format for a manifest and there\u0027s an interest in in referencing and leveraging the work that we\u0027re doing it\u0027s it talks about some of the prior work that has occurred within the IETF and elsewhere on this topic so basically what the document does is it defines some some basic requirements for some of the key architectural roles that participate in the software update process this is mostly consistent with our architecture doing a deeper read of the document though I think there is some ambiguity over the function of status trackers especially with relating to delegation I\u0027ll talk a little bit about that more close 8.1 I\u0027m in the document requires that an IOT device has a status tracker which is slightly different that are thinking about the topic next slide please so generally the way they\u0027re defining a software updates is I\u0027m starting on the right hand side you have an offer an author who creates a firmware image they publish that image to a firmware server starting on the left hand side you have a status tracker that is responsible for "
  },
  {
    "startTime": "00:06:26",
    "text": "tracking the current update status of the consumer and then initiating a firmware update when an update is needed the it instructs the firmware consumer to to perform that updates the consumer then requests the firmware from the firmware server providing the image back to to the consumer either embedded or by downloading the consumer can then verify and install the firmware and report at the updated status to the status tracker next slide please so the the draft talks a little bit about a number of different implementation scenarios for how status trackers are leveraged so there\u0027s an idea that a status tracker can be embedded within the device and communicate directly with the firmware consumer you can have a status tracker that\u0027s responsible within a device for orchestrating multiple consumers and you can also have which is indicated on the right a hierarchical set of status trackers which is somewhat aligned with our architecture except that this document does state that that a device needs a status tracker because that status tracker has to be responsible for initiating the firmware update procedure to verify that trigger has occurred and to check the status on that the firmware consumers actually installed the updates so I think there\u0027s an opportunity for us to provide some feedback just to seek some clarification there some of their examples that next slide please do you seem to indicate that there are devices that might not have a status tracker but it\u0027s not clear like in the example of devices B and C whether there\u0027s a status tracker implied in this diagram or whether there\u0027s actually a status tracker you know present on that device and um I I talked with with Aki Takahashi who is one of the the authors of this draft and he would definitely appreciate some feedback on on where where he can clarify things to make sure that this is in sync with our work next slide please I\u0027ll mention that talk has been active in this working group and I just was at the hackathon but he had to leave last night and so otherwise he presenting this now that\u0027s right so in the latest revision of the document there\u0027s been a bunch of minor editorial changes you know a lot of fixing of case and abbreviations throughout the document there were a bunch of definitions in the previous version that were kind of in line with the text there\u0027s a new section Clause 3.2 where all the different definitions are now kept so they\u0027re a little bit easier to "
  },
  {
    "startTime": "00:09:29",
    "text": "find in the document and also they\u0027ve recently added in appendix 2 which provides an example scenario of IOT software updating using a distributed ledger technology next slide please that guy so on the distributed ledger technology it seems like that approach is a little under specified in the document so it\u0027s not really clear the exact role that a distributed ledger is serving in the update process so I think there\u0027s probably some more work to do for them on that front so considering this liaison statement I have a few questions is there any trust to respond they\u0027ve stated that there\u0027s a desire to have ongoing collaboration with the state working group they\u0027ve been sharing this work do we feel like there\u0027s a need for us to provide input this one is yeah I was just wondering about the earlier mentioned status tracker discussion because when I provided the text in the architecture document there the status track had somewhat a different semantics and it was really like a device management functionality and as that name indicates it monitors the whole firmware update process and it wasn\u0027t actually on the device itself so given that there are these subtle changes throughout time you son like if they seem to still work on the document and so I prefer as I will later explain I prefer to wrap up of the architecture document at some point in time in the near future in then it there may be some the do documents may drift apart so I don\u0027t know what the roadmap is or whether they are now freezing their architecture what the story days now I think they\u0027re still working on the document and planned to at least continue to do so through August interesting enough I looked at the previous version of the document and this discrepancy is actually present in the previous version as well so there doesn\u0027t seem to be a lot of progress yet on you know clarifying these points maybe that\u0027s because we haven\u0027t provided enough feedback to them as the person taking notes I\u0027m going to remind every the microphone please state your name because if you don\u0027t say your name you don\u0027t go in the notes and then it\u0027s as if you never said it so starting from a statement my name was a little mutt of kryptonite I would like to mark my "
  },
  {
    "startTime": "00:12:31",
    "text": "presence here just as a possible point of contact with a study group seventeen being a vice chairman of study group seventeen I would like to point out in our point of contact you could maybe have seen our know today who is working party chairman of study group 17 and in the absence of statistic factor takahashi we can kind of provide a contact and collaboration thank you thank you this is Brendon Morin at the mic and I\u0027ve gone through this document and there are a number of points of ambiguity that I think we would need to resolve before we can move forward with more more alignment between our two groups in particular the status tracker needs significantly more definition the status tracker is currently defined as doing a great many things in fact I think that you could probably we construct an update system entirely of status trackers I think that it means perhaps a bit more definition and perhaps a bit more division between different roles yeah I\u0027m actually I think different roles for status trackers because it\u0027s not clear what the difference in function is between a delegating status tracker and sort of a delegated to status tracker yeah I mean I I even saw a line in there that said a status tracker may reside inside a status tracker right it\u0027s Turtles the whole way down so just observation on the first question of do we need to respond this isn\u0027t the first time that we\u0027ve asked that question that\u0027s obviously not the first time we\u0027ve got a liaison from Citigroup 17 so far the way that it has worked in the other direction so by the way in this direction my understanding I am NOT an itu-t study group seventeen expert but my understanding is the way the mechanism that they have to share the document with us is through a liaison statement and so that\u0027s why we get the Izod statements from them so that we can review the document and the other direction we don\u0027t need a liaison statement for them to review our documents and so in the other direction has been working by email to tack and discussion on our public lists and so do we need to respond is not the same question as do we need to send a liaison it may be discussed in the list to which tack and vasiliy or whatever are visible participants in and so that may be sufficient yeah Brennan if you have comments just posting into the list and making sure that taxi\u0027s them may be sufficient rather than going to the formal way as on process we can send early as I know if we feel a need to but so far we have not felt any to us when you get oh I feel yet not the specific for ITU but others there are organisations then to be like actually 3d and so trying to be much more formal in their communication so indeed sometimes they expect a liaison response I see the person behind you at the mic may have advice for us okay thanks so I "
  },
  {
    "startTime": "00:15:32",
    "text": "would I would suggest indeed conveying this information at least capturing it it\u0027s already a good start I think the questions that Brendan asked are fairly good and maybe when asked Takeshi what would be the best way to communicate back so that the message gets through with the group but that would be my suggestion thank you a bit of clarification again I was a little more of a bit of clarification on itu-t procedures and the years own statements you\u0027d correctly stated the role of Lea\u0027s own statements in the ITU so which is where I would propose if someone wants to walk on the text and the contents of the document it\u0027s bellow most efficient way to contact acacia takahashi directly and walk through here with him maybe participate as a co-editor sorry something like that the other own statements you will need in two situations first one if their itu-t does something definitely wrong in your perception then steadily as young the itu-t can definitely stop the process and start rethinking and discussion in now ever the way which I prefer if you definitely support this you can send Lea\u0027s own statement saying that you support which document in its contents and it will speed up the recommendation approval I one good clarifying question if you don\u0027t mind so if if someone was seeking to actually help author this document do they have to be a member of SGA 17 in order to to contribute or is there a way to do that with an outside party an official way is to make a contribution from a member state I do not do synthesis we cook were quite a way to do that no restrictions to the participations is imposed on them maybe if we\u0027ll if one like to he his name as a co-author of the document he could he should represent even member state or sector member which are a lot of large companies are so that depends on the position of the person and it\u0027s vicious that doesn\u0027t present any meaningful walk the document sliver editors of the document okay okay so on another point I was talking with Takeshi earlier in the week and he expressed a "
  },
  {
    "startTime": "00:18:32",
    "text": "desire to have someone else help with editing this document so if there\u0027s a member of this group that would be willing to contribute some time he would welcome that that contribution pending what we were just talking about I think that the person that would would be helping would would probably have to be a representative than of a member state in order to ask for a sec remember in order to contribute so if there are any parties I\u0027m interested in in participating please email Takeshi about about your interest that\u0027s it hello I\u0027m just gonna give a small status report on what we did it a hackathon next slide please excite so here\u0027s the team where 12 people one remote yeah really nice next slide please so as you know here we\u0027re working on suffer updates for IT so we are working on architecture and metadata for software updates it\u0027s actually firmware updates now for IOT devices including small microcontrollers not to forget them at a hackathon we work on hands on implementation of the latest metadata format draft so it\u0027s the super manifest format craft moron oh for next slide so what happened at hackathon at the hackathon we had available new manifest generators two of them one from arm and one from renesis we had new manifest parsers three and implemented three independent limitations and one from in Ariya are I went from on one former NSS and two of these implementations were actually running on actual Hardware on actually small microcontrollers so one with 32 kilobytes of RAM and the other with 64 kilobytes of RAM so we\u0027re we\u0027re pretty in a let\u0027s say the low end here and we\u0027re happy to see that we could demonstrate interoperability between the "
  },
  {
    "startTime": "00:21:33",
    "text": "manifest generator from arm and the partials from INRIA and finally Bassett it on one hand and the parser from renesis so that\u0027s good and and we also had a full workflow demo [Music] firmer building manifests building and transporting that to a riot device and actually doing a firm Arabic with that I think yeah excite so what did we learn there were a couple of aspects in the spec where there were several ways to do things and cost contributions it\u0027s not the first time it happens in the IDF but you know so this similar conclusion is that we should just define one thing one way to do things maybe Brendan will talk about a little bit later and first foremost ITF hackathon is fun and really nice venue to make some progress so for those who weren\u0027t there please consider coming next time yeah next slide yeah so for more information we have we had an inter pad where we noted bunch of things and links useful links for the what happened at the hackathon concerning suit yeah and then the usual links to the spec work in progress and working that\u0027s it yeah thank you thank you for all your efforts so I think next we\u0027re gonna talk about architecture Hana she want us to bring up the draft it\u0027s quite short so I didn\u0027t put some slides together so I submitted do drafts update since the light last IDF meeting the first one was early this year to do it the Molalla alignment that was discussed at the last IDF meeting in context of what we discussed earlier with the I do tea liaison and that document so it seems to there may be some additional work and for the second update I added some text on boot loaders specifically following the discussion that we saw on the list where the focus of the firmware update didn\u0027t just include sort of the transfer of the firmware plus the manifest from some devices from the firm walls all the way to the IOT device but also then "
  },
  {
    "startTime": "00:24:35",
    "text": "concerned the question of what happens then afterwards at the device and specifically the interaction with secure boot and so we\u0027ve seen that some people want to use the same manifest or at least a stripped-down version for the secure boot mechanism afterwards and I try to capture that discussion a little bit India I try to keep it as short as possible because there are obviously a number of ways to design a boot loader with different stages and we talked about this and in previous meetings before when I spoke about the hackathons so there are different design choices and I didn\u0027t want to preclude or favor one specific approach but there will obviously be implications in terms of code reuse and the security property of the device itself depending on what you are doing but this was clearly something that seems to be important to people because they want to do want to reuse the former don\u0027t want to use a specialized format and again for the metadata that is used but if bootloader when itself it has to verify the firmware that\u0027s on the device so it\u0027s a it\u0027s a similar task and the the information model darkened and also the solution document took that into account by offering fields that can be stripped off later in the process because clearly there\u0027s some information that is more relevant for the transit and and the initial verification at the device rather than than during the boot process so that\u0027s something I included they\u0027ve send a message earlier this week actual Monday with a small with a note from Dave wheeler which wants to have additional clarification regarding the trust anchor which currently only talks about these be its it being a public key but also wanted to highlight that there are some requirements regarding the protection of those keys are clearly you can\u0027t just store it on the in flash and let everyone modified so there are some requirements to protect it against modification against sort of stripping it out deleting it etc etc so I\u0027m going to add that I think that\u0027s a minor clarification but still quite useful a useful addition and otherwise I would suggest - I would have suggested to start a working group last call but now I\u0027m not quite sure anymore but if the discussion is about the status tracker and some of the other idea T work so I\u0027m not entirely sure but yeah it seems like that could happen in parallel with the working group last call I mean we are a "
  },
  {
    "startTime": "00:27:37",
    "text": "little behind on our miles down there so it\u0027d be useful to to move things forward so I\u0027m interested in maybe a raise of hands how many people have read this draft that\u0027s a good number does anyone have any concerns with moving this forward after this one revision is made okay so so Hannes when when do you think you could ship an update to the rear end with this small edition yeah ah I can do that today I can do it when I sit down okay that\u0027s perfect so uh so maybe later today we can we can actually start the the working group last call thank you that was supposed to stand prey right over the trapdoor okay good yeah kick it set on the eggs okay so following ietf 103 there were a number of updates requested to the information model specifically these had to do with a couple of new threats and not one new threat and a couple of new use cases next slide please so what\u0027s happened mostly in this update is that we\u0027ve rearranged elements mostly to place the manifest elements at the beginning that was on request of the chairs at the previous IETF and then as I said new threats and new use cases next slide please so HP HR PC requested that we address the possibility of exposing information about an individual by exposing what devices they have and so that requires obfuscating the contents of a manifest because even though it doesn\u0027t contain any IP it could contain device identifying information and that could reveal information about a person or the things they own so to resolve that we\u0027ve added a new security requirement for the option of having encrypted manifests next slide please there were several new use cases discussed specifically as Hanna\u0027s mentioned secure boot and once secure boot was an option the next thing to to add in was the ability to transform a firmware image during the "
  },
  {
    "startTime": "00:30:38",
    "text": "loading process so decompress on load was the use case that was given to me but I\u0027m quite certain that decrypt on load is also a requirement so that\u0027s been added in as well and there was significant discussion on the mailing list about simple parsing so we\u0027ve added that as a required use case in the information model next slide please and from that we derived for almost identical usability requirements and that\u0027s about it for updates to the information model so do we think that this one is also ready for a working group last call first of all to the author are there any outstanding comments that you know up on this document that have not already been addressed to your belief I think there are a few outstanding comments yes they are largely editorial in nature okay I\u0027m not aware of any technical comments no Dave wheeler so I haven\u0027t read all of the the documents in detail but I did spend a couple hours yesterday reading through the information model and things specifically with the purpose of trying to reuse the manifests for teeth and I think there may be some some things that we might want to add to this but I don\u0027t have anything right now solid to give you as input but I should should do that within the next couple of weeks so I since you\u0027re asking about last call I just wanted to let you know we\u0027re considering using the manifest for cheap and I think we will have a few things that we\u0027d like to add to it yeah we\u0027d absolutely let to get like to get input from teep I think it\u0027s important for us to get alignment between these two working groups chair conference so we were just considering maybe doing a four-week working group last call on this version of the document which would then allow for some time for additional comments on the draft to be considered and then based on those comments we can we can go from there any any concerns without approach Brendon you said there were some editorial comments do you have any timeline on when you are planning to address the editorial comments hopefully "
  },
  {
    "startTime": "00:33:39",
    "text": "this week okay so if they can be addressed by Friday they we can say we\u0027re just going to start to work we\u0027re gonna send out the working your class call as soon as that appears if it\u0027s going to be longer than that then we should go ahead and start it but if you\u0027re going to potentially do it before a Friday then we\u0027ll send out the working request call announcements initiation on Friday if that\u0027s all right all right great thank you anything else I think the next one is also me all right so this has been a major revision from the previous draft next slide please so I really want to thank everyone who\u0027s contributed I\u0027ve gotten a lot of feedback not all of it positive on the previous draft and that made me that encouraged me to do a major rethink of the mechanism that we were using to handle the the serialization of the information model and the rethink I think it produces a much simpler result the the format ends up being the format is constructed specifically to make the parser simple that doesn\u0027t mean in all cases that it makes the format smaller but it doesn\u0027t increase it significantly I don\u0027t think I\u0027ll have to I\u0027ve had some discussions about every byte counts but it\u0027s still I think that the trade-offs are in the right in the right vein next slide please so I this is just an overview of what we\u0027re going to or what I\u0027m going to talk to you about let\u0027s get into the reasoning behind the changes so the previous draft was very complex and and every time I added a new use case it got more complex and that means complex parsers and that means complex code and that means more space on constrained devices I didn\u0027t like where this was going so the new use cases were introducing new optional fields in places that already had significant numbers of optional fields this also made capability reporting really complicated and the irregular structure of the data made it very difficult to parse efficiently next slide please so there are a few different things that are turning up in this in this draft and the important ones to recognize our commands which are either the the struction for to a device to test "
  },
  {
    "startTime": "00:36:39",
    "text": "something or the instruction to a device to do something there are parameters which the devices use in order to perform those two options and the components are the things that devices operate on those are you typically firmware images or other resources that a data that a device uses next slide please so at the high level the only real change is that I\u0027ve moved the authentication container typically cozy into a B string I guess we\u0027re saying it is cozy so the cosy container goes into a paste ring now that is specifically to ensure that the top-level parser doesn\u0027t require a understanding of cosy this this is to partition the responsibility for understanding different formats into the individual software modules that implement them I\u0027ve also expanded the CD DL that describes the the authentication container to allow an array of authentication methods this was because it allowed us to handle both a cozy Mac and a cozy signature within the same block which would otherwise not be possible and the manifest itself has substantial changes which we\u0027ll get into in a moment here next please all right so the new manifest is divided into two major sections there\u0027s the common data area now the first two elements in that are different from the rest those two elements are specifically intended for an external system or external software to be able to read it\u0027s not really part of what the manifest processor handles this is because the structure version informs a device whether or not it\u0027s manifest processor can handle the data and the second allows it to decide which manifest it should be looking at so both of these things have to happen before a device is able to actually start processing its manifest this this is again a secure boot question rather than a update question you need to know the sequence number before you can pick which partition to boot then there are dependencies and affected components so those are components that are affected by the manifest or its dependencies the dependencies are other manifests that are required by the one that\u0027s being processed behavior definitions are used to explain to a device exactly what it\u0027s supposed to be doing in the course of an update or a secure boot process and as Carsten has pointed out they are effectively scripts but I didn\u0027t want to use the term scripts because I don\u0027t scripts have a lot of baggage and one thing you don\u0027t want in a secure boot "
  },
  {
    "startTime": "00:39:39",
    "text": "process is a lot of baggage so so this is the reason I\u0027m saying behavior definitions rather than something else is because we\u0027ve lived we\u0027ve removed the possibility to do some of the things that scripts do that make them problematic in this kind of space specifically the ability to perform branches and loops there is no halting problem here there the complexity is sort of enforced to be low so they the individual the two steps they\u0027re laid out here the install and the run are broken down into three pieces each I\u0027d like feedback on whether these are the correct three pieces I believe they are but there may be other requirements out there I think that they should be relatively self-explanatory next slide please so all commands must target a component this is because components are essentially what we\u0027re operating on if it\u0027s not targeting a component then it really doesn\u0027t do anything on a device some commands may target all components this is an optimization to allow you to say go and fetch all of the components that are about to be installed or in do an image verification on everything most parameters are scoped by component there are two specific parameters that are not scoped by component but I\u0027ll talk about those a bit later next please commands are other conditions or directives as I mentioned the commands typically prefer consume parameters instead of arguments there are a few exceptions to this for example the vendor ID and class ID are I can take an argument rather than a parameter this is perhaps an instance of two ways to do things and we might want to consider removing that but given that I can\u0027t see a reason for a device to make a decision about what class it is or what vendor it is I think that it might make sense to say that these cannot be parameters and they must be arguments so some commands are consumed arguments where only a single use is expected which is the vendor ID class ID kind of scenario and override is not expected to be needed and I\u0027ll talk a little bit more about what override is in a few slides next please so there are behavior definitions command lists are composed of two different components the conditions and directives and the conditions are for ensuring applicability ensuring correctness in ensuring that the and allowing a device to make a decision about what it\u0027s going to do and that\u0027s implemented through the sub behavior "
  },
  {
    "startTime": "00:42:40",
    "text": "directive which essentially allows a device to have a soft failure on a condition check which is the way that we implement conditionals in the manifest it\u0027s done in that way because it allows reuse of the same command sequence parser as the existing one and I have been assured by at least one person who is at the hackathon that it was trivial to implement that way yes next slide please so the parameters that don\u0027t require a component to act on are the strict order and soft failure parameters so the soft failure parameter is the one that enables conditionals that as I as I just described strict order is a parameter you will only ever see on a device with many components and lots of RAM this is a mechanism to allow it to do things out of order where they do not have dependencies this is for one particular use case at least that I\u0027ve seen where a Linux device wants full say over how it installs things and want in which order it installs them and to enable that the the manifest as it exists today would make that explicitly impossible so the strict order flag if strict order is disabled will allow the the device to collect all of the commands until strict order is turned on again and then execute them in whatever order it feels like the the remainder are the list of sources so those are you are is typically in download but for boot and loading those will be component IDs processing step configurations so these are things like decompression decryption and unpacking and image identifiers are typically cryptographic so digests of a an image but I also allow for the possibility due to previous requests from this group that they could be version numbers there may be an interface version that\u0027s required and verifying that an interface version is available and is the domain of the manifest in this particular type of parameter and finally device identity which we\u0027ve defined under the under the UUID scheme that\u0027s described in the document next please so I\u0027m going to go through an example to just show how this fits together and then we\u0027ll talk about sizes for a few more examples after I\u0027ve gotten through here so here\u0027s a the information that will encode into a manifest in the current format it\u0027s about 96 bytes of information but what\u0027s not obvious here is that there "
  },
  {
    "startTime": "00:45:42",
    "text": "are also instructions to a device on how to use that information so this is just the raw information if you were doing this bespoke the minimum that you could use to encode this information is 96 bytes since that\u0027s exactly what the data size is we could encode it in 169 bytes but that does give the device some flexibility on how to use it next slide please so the outer wrapper is the same as it always was it\u0027s not terribly exciting next slide please I the inner part of the manifest shows the version number of the sequence number it\u0027s got one payload and I will talk a little bit more at the end on the open issues about how the component is listed there I think we can do better then we\u0027ve got the common section a common is executed before every other command list and then validate so this is just doing a secure boot no apply and then validate there we are apply validate and run so our common is executed before every each of these others and that\u0027s to enable essentially size reduction because it contains the digest as I\u0027ll show you in a moment it reduces the amount of space that\u0027s consumed because the digest doesn\u0027t have to be repeated in each segment next please so in here it sets the component index to zero checks the IDs and sets up the digest that will be expected later and the size that will be expected later next please well my highlighting is all gone can\u0027t see which section you\u0027re in okay so this section is apply and in apply what is happening is that it\u0027s doing a simultaneous fetch and install they are two separate sections for fetch and install but on very constrained devices we expect them to do fetching and installing simultaneously so because of that the fetch section ends up also in the apply section so it\u0027s a B string wrapped URI list that\u0027s configured as the second parameter now this the second parameter is I think it\u0027s another area where we can have some improvement there were some comments during the hackathon as well that this is not the or this particular format this encoding is difficult to parse and I think that we should try and find a better solution for that and I\u0027ve got some more information on that in the open issues section at the last element there 20 is a fetch all elements directive but it\u0027s "
  },
  {
    "startTime": "00:48:43",
    "text": "definitely not in the description ok next slide please I hear it\u0027s very simple this is apply or this is validate so this is a very simple section it just sets the component index and validates the now downloaded image against the component that it\u0027s got specified by the component index next please and here\u0027s run the same thing again component index and run the selected component now this I I hope that it\u0027s obvious that we\u0027re setting the component index a lot and possibly too much and so one of the other open issues is should we have a default for that so that it\u0027s not necessary to set a component index all the time next please something got dropped there I don\u0027t know why we ended up with was that two 6s or missing seven so all of the manifest sizes that I\u0027ll give in the next section are done without the coziest an authentication structure and I hope Jim will correct me if I\u0027m wrong here but those sizes I believe are roughly correct barring large key IDs of course so you can add those numbers for authentication depending on what your use case is next please so a pure secure boot manifest encodes 47 bytes of information and consumes 91 bytes encoded I again dependent on exactly what your component ID is next slide please for a minimal update without secure boot again depending on your component ID and your URI 74 bytes of information encoded in 130 bytes of manifest next please adding boot to that cost to 9 bytes next please so now adding compatibility or applicability rather verification to this caught it\u0027s an additional 32 bytes worth of uu IDs and it ends up being encoded in 177 bytes next please so the parser that I\u0027ve put together to to verify this took me about 600 lines of C for the the part that executes the manifest and about 200 lines of C for simple C bore information and extraction that isn\u0027t compiled sizes obviously and the C is pretty vanilla and probably has too many prints in it so that\u0027s just just a ballpark figure for how complex it is to implement and I\u0027d love to get feedback from anyone else who\u0027s how to go at implementing it if if that\u0027s available or if someone\u0027s "
  },
  {
    "startTime": "00:51:43",
    "text": "on the line perhaps who could mention that when we\u0027re done here next please so there are a few open issues as has been pointed out already there are a few places where there\u0027s more than one way to do things and that makes parsers more complex so we should get rid of them the digest incise hair was done as a mechanism to trade off between parser complexity and data size so encoding it the way they in one way would produce a smaller manifest but a more complex parser and encoding it the other way would produce a less complex parser but a larger manifest I think that the since one of the mechanisms is required for a few use cases and the other is not explicitly required for any other than the size optimization I think that we should stick with the slightly larger but less complex method the URI list is complex I don\u0027t like how much parsing it takes to handle it and I\u0027m not convinced that there are a lot of use cases that require the URI list that we have at the moment I think there are three different ways that we could deal with it so we\u0027ve got the existing one which is effectively a multi map just not listed that way I think that we could I don\u0027t think it\u0027s necessary so the second option is just a plain list of your eyes where priority comes out of the order in the map or in the list rather than coming out of an explicit priority number listed with the URI the second possibility is a map of your eyes keyed by priority that prevents duplicate priorities that\u0027s the only and that\u0027s the only problem that it has I think so these what these options don\u0027t enable because that apparently has cut off it\u0027s like I forgot to save it at some point so the what these don\u0027t enable is that the is the ability to have multiple you are eyes at the same priority that was raised as a possible optimization at one point where devices need to choose among multiple your eyes of the same priority for geographic region selection for example I think that this is a fairly complex use case and in situations like that I think devices should probably work out their own priorities based on order and based on geographic region and I think that having an explicit prior in there is probably not something that\u0027s beneficial to most devices so I think either a list or a map is probably the right answer I\u0027m commanding coding it also has a bit of an open issue right now it\u0027s an array of maps an array of maps is fine and it\u0027s equivalent to an "
  },
  {
    "startTime": "00:54:44",
    "text": "array of arrays with two elements each so there\u0027s there\u0027s no semantic difference there I I think the array of maps is probably okay a multi map would be a more efficient encoding but I I gathered that see bor has considered this and rejected at numerous times so the other option that\u0027s been brought up is a pseudo multi map I I call it that because that\u0027s the best explanation I can have for it where we alternate keys and values in each successive element I think that the array of maps is probably fine it adds a few bytes but it makes the semantics a lot easier to follow and so we also have the issue I raised a few minutes ago about the default component and dependency index it was fairly obvious going through that example that the component index gets set repetitively and I think that that probably means that we need to have a default because that\u0027s extra encoding that we don\u0027t need every time and finally I\u0027ve had a request for script list operation as in mechanism to put this manifest together without having any of the command sections present this would be fine except that if we remove the ability to layout the digest and size of a payload in its component description and move that explicitly into the command sequence we won\u0027t be able to do that so there\u0027s a trade-off here where you could use this manifest in a completely script --less way but if we eliminate one of the ways of doing digests and sizes we\u0027ll lose that ability so I\u0027d like feedback from the group on how we should handle that and I think that\u0027s it is there another one no that\u0027s it pick an issue so so one one comment on David wheeler I\u0027m sorry Dave wheeler one comment on the URI list in in teep when we look for the source for an element that we\u0027re going to download there are an equal number there all of the options are equally valid but a device may choose one based upon their trust anchor list and so the URI has to include both where to go get it and the key and one of the things that we\u0027ve been talking about is that particular URI might need to be signed to prove that it\u0027s valid so I "
  },
  {
    "startTime": "00:57:45",
    "text": "want to maybe explore that with you some more via the email if we\u0027re thinking about this in the right way but it creates a rather complex case I think for the URI LS it\u0027s also possible that we could handle that one through another command one of the benefits of this approach is that if there\u0027s a complex use case that not all devices are going to need to handle we can actually just add a new command to enable that okay so okay I think this would actually be a good point to raise capability reporting under this model capability reporting is dramatically simplified from previous models because all a device needs to do is report which component IDs it has which commands it supports and which parameters it supports if it can report those three things then a any remote system can tell exactly what the device is capable of in three lists which is dramatically easier than it was in the in the previous drafts where capability reporting had absolutely nothing to do with the draft and it was a completely separate topic that needed to be addressed manual Bocelli inria so we\u0027ve got two of the implementers that are online and mythical I don\u0027t know if they will speak out for their if they are in a position to speak up but from our initial measurements of our implementation which is not complete the out good - maybe it can it\u0027s gonna say somewhere later we see an impact on code size compared to v1 against its preliminary results it\u0027s quite substantial but like depending on like how much flash it\u0027s flash you have on the device it\u0027s so like relatively to the flash like you have to relate that to the number of mouths of - we have so when I hear that we may want to run this stuff in the T where we might have like I don\u0027t know like reduce num reduce amount of flash this might become like a something we want to characterize that\u0027s why I don\u0027t know if Koon wants to say something it\u0027s you see he came to the to make so maybe I\u0027ll let him talk about this please go ahead that\u0027s perfect for a ghost yes okay actually we and "
  },
  {
    "startTime": "01:00:47",
    "text": "unfortunate we\u0027re having audio issues so we\u0027ll have to you so just to give some some quick numbers like for v1 we were about like 600 bytes of code size and here were about triple bet but okay so if if you\u0027re thinking about like you know device with 128 kilobytes of flash that\u0027s thick bearable if you\u0027re thinking about like 64 or kilobytes of flash or in a pretty small and maybe you take it becomes like a something significant to take into account but again like this this is a very preliminary results I just got now so to be confirmed this is the based on our hackathon hacking whatever so maybe we can some optimization possible maybe maybe yeah so at this point if another comment at the mic please go ahead not quite come on this typing one seconds okay I think you just finished Ludwick sites for the Deborah Cohen a clarification on the cosy handling would be nice to have maybe some examples what exactly should be passed to the signature verification yes I erased that yet yesterday in the cozy working group so at this point it seems like most of the comments have been you know positive and you know constructive about improving the existing format we we had some previous commentary about about other manifest formats but those have seemed to be mostly addressed at this point so are there any concerns in the room around moving forward with adopting this as this the the manifest format so not seeing any objections we will confirm adopting this document on on the list and we\u0027ll have you move forward with posting this as a working group draft oh we have another comment sites "
  },
  {
    "startTime": "01:03:54",
    "text": "relaying a jabber comment from Casper Schleicher the smallest MCU simpler I don\u0027t know what\u0027s simpler simpler manifests 32 kilobyte MCU with flash split in half cannot spend two to four kilobytes on see bore and manifest ours I I agree and I think if you look through the mailing list archive there was a point I raised some time ago about not using see bore parsers to parse see bore and there\u0027s a way of just doing exact matching you know with mem compare that you can or you can take as an approach to really cut down size if you\u0027re in a very fixed function case like that that\u0027s right if you if you make a consistently structured see bore object you can treat it as a binary structure okay thank you so I think we\u0027ll move on to or move on where are the blue sheets this is a blue sheet near you raise it up so we can see where they are I want to make sure other people in the room that have not seen the blue sheets go by them please send the blue sheets in those directions if you see a blue sheet thank you so this is a quick overview of the work that went into the the creation of manifest zero 4 it\u0027s essentially the information model if you will behind the serialization of the command sequences and goes a little bit into the ideas that we used to to to generate that serialization and the the reasons behind them so what does the recipient do when it needs to do an update probably check for authenticity assuming it\u0027s not guaranteed by some other means and then it needs to install a payload but there are a number of questions around that as well next please so descriptive updates binary formats provide a recipient with explicit information I\u0027m in a number of different ways and then expect the recipient to act on that information via some pre-agreed methodology next please it\u0027s got a few pros it can be quite compact and it\u0027s easy to present to a "
  },
  {
    "startTime": "01:06:55",
    "text": "user but it doesn\u0027t specify behavior very well and that means particularly that you end up with a lot of corner cases and that all of the understanding of how to use that information winds up in the code rather than in the manifest itself the the data is complex and that makes parsers complex when you have structures that repeat you either end up with a general-purpose parser in which case you have to understand the structure that it outputs or you end up with a complex fixed-function parser which has to again understand the structure that it\u0027s parsing and capability reporting as I mentioned earlier is it\u0027s a completely separate definition and it\u0027s a separate problem next please the other option is to specify things in a behavioral way to specify exactly what a device do instructing it on how to perform each step in a normal update process and in a secure root process as the recent use cases have pointed out the same information is all there but the organization is different next please so it\u0027s unambiguous as to what a device should do it because it\u0027s constructed of directions to a device the data encoding is very simple the parsing should be very simple although those numbers that a manual has been giving me are concerning the behavior is explicit not implied which is beneficial from a security perspective and there\u0027s a high degree of flexibility the codes are the the size of the manifest itself may be larger but that\u0027s a encoding question rather than a informational question and there\u0027s more tooling required definitely because it effectively turns your manifest generation infrastructure into what is effectively a compiler it also means that presenting the information in a manifest to a user requires tooling as well next please the outer structure is the same as I\u0027ve shown in the previous the previous set of slides you have the authentication wrapper and then a set of externally accessible data which is used by other parts of the system then common data that\u0027s shared between all of the operations performed on the device and then finally the command lists that the device uses to process through the manifest next please so we constructed six command lists and one common command list that gets executed before each of the others this was done to ensure that "
  },
  {
    "startTime": "01:09:55",
    "text": "each of the phases that a device typically goes through in an update would be catered for next please dependency handling is something that needs special tension in this model it\u0027s explicit as all of the other operations on the device are but because dependencies have to be resolved all of them before any one dependency is processed in any other way the command lists have to be handled in lockstep so dependency resolution of the first manifest has to complete or at least partially complete before now the dependency resolution has to complete before the image acquisition starts now that\u0027s important because you want to have early failure in devices you want to know that an update will be able to acquire all of its dependencies before you start applying the update likewise you want to know that a device will be able to acquire all of its images before it starts to install any one image similarly on the secure boot side you need to do all of your system verification before you load any image so that\u0027s the reasoning between dividing out these command lists into their component parts when dependencies are involved we need to be able to divide down into the individual sub steps of the update process and dependencies are explicitly processed so the there\u0027s a command in the manifest to say go and process a dependency and that means that it processes the current command list in the next dependency so dependency resolution means dependency resolution the image acquisition means image acquisition and so on next please I\u0027ve gone through the lists of commands there\u0027s one here that wasn\u0027t listed in the other one which is the third-party authorization and on the other side directive which is wait for an event those are two cases that we have found will probably be needed in a lot of devices next please I\u0027ve talked about the different parameters already I don\u0027t think that I need to go through that again next please oh that\u0027s it okay there we are so that\u0027s that\u0027s just an overview of the process that we went to get here it\u0027s very similar I guess questions or comments and for reference this was purely informational I think that the content in it should mostly be rolled into the manifest serialization so that it\u0027s a standalone document any concerns with "
  },
  {
    "startTime": "01:12:55",
    "text": "taking that approach ludwik sites relaying comments from David Brown on the dabber so dependencies seem to be restricted specific version not something like semantic versions question currently dependencies are managed by digest that\u0027s because you depend on a specific you depend on a specific manifest if that\u0027s not going to be the case then there are going to it\u0027s going to be much more difficult to construct a secure dependency chain and the other mechanism for handling this is to verify are sorry to check for availability of a particular version and we already do have that but it\u0027s not constructed as a dependency so so I guess for the next update merge the you can merge the documents to be honest they already are largely merged if there\u0027s there\u0027s a little bit of overflow and the the terminology is slightly different it\u0027s much more generic in the behavioral draft are me yeah so I think I think now we can move on to to any other business and then we\u0027ll just quickly summarize the actions at the end cross Housley two meetings ago I advocated that we take a look at hash based signatures and I just wanted to provide a update on where the work in the cosy working group is gone to allow us to do that since we were aligned with seal or we needed signatures there the hash based signature specification out of the CFR G is in the RFC atatürk you there in auth 48 so we actually know what the RFC number is now it\u0027ll appear very shortly then the cosy spec was his progressing that says how to use that algorithm in the cosy structures that is ready for "
  },
  {
    "startTime": "01:15:57",
    "text": "working group last call so I think we now have all the documents fairly mature in a place where if we want to use that algorithm we have the things we can reference to do so so I\u0027ll mention and manual didn\u0027t put it into the hackathon report but at the hackathon there was actually a question that was raised at the soup table which is so what is the status of quantum resistant stuff we\u0027ve talked about that before but we didn\u0027t hear about that and that\u0027s actually what russ was just answering was the question that came up with hackathon manual you want to say anything else Mineola chilly yeah here I was at Cosi so I reversed some of your slides and you were talking about the the signature sizes depending on you know how many times you can sign and etc and you know like lasting a long time obviously is means longer signatures the thing I remember like that you had like the very minimum 30,000 signatures or something like that with like rather small slides is is that the type of thing that we will recommend to use for software updates on like really small devices yes that is depending on how you actually manage your software development process because the thing with hash-based signatures that\u0027s different than others is when you create the tree the number of leaf nodes defines the number of signatures that you can produce so if you are going to do multiple builds a day then that\u0027s probably not enough but if you expect you know a release once a month that\u0027s plenty so that that\u0027s a trade-off that I think each software developer needs to to do themselves they probably don\u0027t want to use the same tree for software development as they do for production yes Brendon more in here is there a profile that would allow me to say use for our 16 something small I mean if 4 or 16 what signatures only in the lifespan of the signature all right that sounds really scary because then when you use the left leaf you can\u0027t do any update without installing a new trust anchor right but we\u0027re in firmware update here so why can\u0027t my last signature be of the next public key it could so because of that and because we are very constrained in some use cases on size it would seem to me like having the ability to ship small signatures outweighs the requirement to have a lot of repetition I you can "
  },
  {
    "startTime": "01:18:59",
    "text": "certainly look at that but right now the specification I think the smallest tree is like it\u0027s 5 levels okay so two to the five signatures 32 okay that\u0027s that\u0027s a good that\u0027s a good number to have thank you okay so we should just quickly summarize with what actions so so Hannes thanks for submitting the update we issued the working group last call on on the architecture for the information model we are in a weight on the last update there and then start the four week working group last call towards the end of this week we\u0027ve we will confirm the call for adoption on the seed manifest format on the list yes note taker anything else we missed okay so with that I think we\u0027ll wrap up the meeting thank you everyone and we\u0027ll see you next time Thanks yeah I just met if you need to sign the blue sheets they\u0027re up here [Laughter] "
  }
]