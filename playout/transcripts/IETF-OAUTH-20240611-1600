[
  {
    "startTime": "00:00:05",
    "text": "can you can see there is a audio video and then share screen right wait I I don't think I had that let me try again oh okay Christian ask to share the screen okay I I passed slide control to you so I'm not sure what else to do if if not just send me those slides yeah yeah easier to top upload it here that was the Gmail address for you right say that again the Gmail address yes yeah yeah hello hello hello while we're waiting can we get somebody to take notes please if get any volunteer here should be there sorry Pa and I did some last minute discussion what to present and what to change but we forgot to send you a copy yeah I see it again I'm still looking for volunteer to take notes if somebody can volunteer that would be awesome okay perfect"
  },
  {
    "startTime": "00:02:04",
    "text": "okay uh hav't seen any volunteer for taking notes anybody please any taker come on guys no one okay well you go without uh without taking notes I guess uh let's get going um we have the recording anyway so somebody wants to see it can can watch the recording later okay welcome everyone so let's get going this is a a reminder not well applies here so notwell is is really important if you're not familiar with this make sure you are familiar with the with the notwell because it governs everything that that we do at ITF so please make sure you're you're familiar with this H our schedule we're almost done so this would be our last interim meeting and we have um three topics to discuss today that token list status list the O status attestation and Global token revocation um and reminder ITF 120 is in Vancouver is coming soon so if you have any topics that you want to discuss um please let us know as soon as possible um any questions comments okay um still have no volunteers for taking notes okay I'm going to share"
  },
  {
    "startTime": "00:04:01",
    "text": "let's start with Christian GNA get us going here thanks armed for taking notes appreciate that yeah I think Paul is is starting so I'm after that okay Paul go ahead thanks okay so yes I will start with o token status list was formerly known as J C status list um working on this together with Christian and Tobias uh Chris Tobias can't be here it's it's not a favorable time in in New Zealand this call but we'll do with the two of us um yeah we prepared some slides uh the um toet sets list was suggested um April of last year and was then adopted quite quickly to the a working group um so yeah let's jump into it um next slide please uh so yeah very um short overview of how this um Works um the um wallet um will send a presentation of a token to the verifier so this is an example for the issuer holder verifier model but could apply also to other things like like access tokens but in this um example here the wallet sends a presentation to the verifier um this contains um what we call the reference token reference token contains a a status claim and in there we have an index and the URI the URI um points to the status list token and the verifier in step two will send a request over get https uh to fetch the list um the issuer"
  },
  {
    "startTime": "00:06:00",
    "text": "which maintains the reference token um May update the statuses of the referenced tokens and multiple referenced tokens are then combined into one big status list which is hosted by the status provider issuer can also be the status provider himself he is responsible for hosting of the status list tokens so he will receive the get HPS um with the URI and he will as a response return the status token and then the verifier can um look through this status list token and take the index which is also in the referenced token status object and then look at a specific index within this list and then uh these bits or this bit will represent uh the uh the status of the reference token and if the is wants to update things he can do update and then there will just be a new status list token available at the status provider and in that way the verifier knows how um the status changes um important changes that we did because we received the feedback that we may want other status mechanisms is that previously we had yeah the status um claim which directly included the URI and the index uh we now have um a CNF uh um like style where we have a registry and um the name of uh the particular status mechanism is then used in the status object in our case we register the status uncore list um claim and then now this one contains the URI in index which is particular or specific to the Token status list if you have other mechanism then you could again use the status uh claim and then um have a different claim underneath that matches to other specifications and we'll see that in the"
  },
  {
    "startTime": "00:08:01",
    "text": "in the second or third presentation um yeah so this was one of the recent changes that is quite important to today's topic um what else are we working on there was um uh a request that there should be a list basically a list of status list token your eyes this is um handy if you want to fetch uh upfront all the relevant um status list tokens for example for a specific credential so imagine you may want some offline or caching support for police officer who's driving in in the countryside and may not have access to the status list uh provider uh so he may fetch um all the relevant status list tokens for mobile driving licenses in the morning uh and cash these for one day so therefore we have this aggregation um thing where he can find out where to find all status list tokens this is one of the recent changes um yeah and the second uh discussion is um something that was also brought up from Isom mdl uh territory is um that people not only wanted um not only considering status list and token but they would also want um a more simpler mechanism that is more similar to a crl um we gave this a lot of thought and the request kind of came up again and again um but we decided that this is too much or overloading the status list token specification uh so we opted not to include in the status list specification but drafted a very early separate draft"
  },
  {
    "startTime": "00:10:02",
    "text": "that again also makes use of uh yeah the gener generic status claim that we have and could also be just a new entry for the upcoming registry and this behaves quite similar to um crl um where you only include um specific identifiers and then these identifiers have a status but all other ones that are not mentioned have like a default status basically how our crl works one one use case or like One requirement we have seen is if people want to basically have a way to figure out when a status changed there are certain use cases domains and so on that explicitly wanted the ability to see when the status change occurred which is not very easily doable with current status list and we do not think fits that model very well the exact time the stat is changed uh yeah sorry yeah so basically the op the possibility to add metadata to a status right now status list is optimized to only have current status we have gotten feedback from several implementers that they have use cases where they want additional metadata which in my opinion doesn't make a lot of sense with the current status list which is more in line with classical crl approach Chris do you want to continue here okay um so open points uh early on we got feedback that people were interested in an unsigned option so basically an endpoint to just return Cabo J directly we are currently strongly considering removing this option so if you're interested in this"
  },
  {
    "startTime": "00:12:00",
    "text": "please reach out right now we've seen not too much uptake on this and it makes these draft is back quite a bit harder to read in my opinion or in our opinion um Bri Brian you want to elaborate on your why I guess Carson kind of touched on it but why on what point exactly sorry what what was the question why why remove the unsigned status L option so we reached out to some implementers and most people so far told us that they would only be using the S option so some kind of token and it made writing and reading the spec quite a bit harder so if you have used cases and would be interested in explicitly the unsigned option please tell us as and then and in most people means all people yeah we haven't heard anyone who's considering to implement the unsign status list option and if you have a feature in your draft that's not being implemented by anyone it's probably a sign that it's not relevant so that's why we're putting it up for discussion CH Chia po hey boys well um it depends by the requirements of no repudiation if a party have to demonstrate that something was not revoked in a that in a specific time in the past signature helped in in this that was one of the reasons why we we've seen quite a bit of let's say preferred using this signed option yeah"
  },
  {
    "startTime": "00:14:00",
    "text": "I I would I would say that this is um um this is related to the trust framework where the uh specification is going to be adopted therefore it makes sense to me allow this in the in the technical specification despite if it will be used or not in some in specific context so you would keep both options yeah as it was for JWT we may have unsigned JWT and signed JWT and it makes sense to keep the both of them or otherwise you will be forced to separate this to another draft the the sign one I I say okay Chris we only have 10 minutes per draft so I think we we should continue uh if if anyone else is thinking removing it would be a bad idea then then please reach out so Todo there was some discussion about the public key basically key resolution parts for the for for the status list uh we need to detail out the validation rules that is a big to-do that are still missing we need to valid nlock example I think that is soonish done uh yeah there was a a feature request from at least two people for can we get this for a specific point in time that is something that we are currently considering not entirely sure right now and then Paul the comparison of status mechanisms I think you can say a bit more about that one right yeah so um we as as there are multiple status mechanisms upcoming um and we have a lot from the x509 world I think uh we want to try to compare those I think that was"
  },
  {
    "startTime": "00:16:01",
    "text": "also a request from ITF um that we get some information when to use what and we're currently making a comparison um with some Italian uh friends uh from jeppa and um then we will see where this fits in I think in my opinion it should not go directly into status list but maybe it makes sense if we have multiple status mechanisms to have an informational RFC how these compare to each other um yeah and then I think we had some slides on on comparing to to the others I'm not entirely sure if we want to go through these and now maybe maybe briefly just each one of those uh one sentence on those right yeah so the O status assertion is apparently the new name I would say it's very similar to ocsp stapling or I think it was called validity credentials as well beforehand we also consider that option in the beginning but we thought we need something that set US list as well so we think we kind of need different mechanisms for different requirements different use cases um that is also the reason why we chose to switch to this CNF style stus claim so it's basically a defined extension point for for a different kind of mechanism um next slide please so Global token revocation the way I I understood it is basically an endpoint that allows you to revoke specific tokens for example every exess token or whatever from a specific user the concrete concept of revocation or stus mechanism is kind of out of scope for selfcontain tokens so this"
  },
  {
    "startTime": "00:18:00",
    "text": "could be used basically to trigger the revocation via status list or something else so it could be something basically in front of the list or like combined with it from my understanding so it's not an alternative okay okay awesome uh Paul and and chrisan thank you very much for this anybody has any questions comments do you have any feedback on the discussions regarding the more crl like approach identifier list hey guys I can only say that it seems to me that um we are going to live in a world where um revocation LS to different use cases and probably in our real world we will not be able to live with a single revocation check mechanisms because there are some cases where our party is allowed to monitor a status of a credential over time even outside of the scope of single user authentication and other case that where it is not supported or allowed for privacy reasons and this is something that I'm going to talk during my my presentation about status of search okay okaya yeah that's awesome thanks Joseph so so this is good uh Paul Paul and Christian thank you um I think we we need uh probably a longer presentation discussion in Vancouver so please be ready for that and and um and hopefully we'll we'll have one of you present present that again in Vancouver we'll give you more time for for that uh okay let me switch"
  },
  {
    "startTime": "00:20:04",
    "text": "to just that pleas okay H let me hand you the control jeppe do it yourself wow oh it works there you go yeah yeah this is the my first time I present on this platform hello to everybody I'm josep um I I I live in the south of Italy therefore uh it looks that I'm pretty wet here we have 35 gr Centigrades but anyway I'm very happy today to talk about a specification that actually is an individual draft that was born roughly six months ago and as you may see from this Slide the title is changed it was born as all status attestation and according to the feedback given by our community it became o status assertion and another evidence that um I'm not alone in writing the specification we are me Franchesco Marino of the Italian national printing services and Ori Steely that has already presented this individual draft during the previous ITF meeting I suppose in um um in Brisbane well what's St assertion is technically assigned artifact it could be of uh different formats and at this stage we support JWT and cwt and it demonstrate the validity of a digital credential in particular the non- revocation status of a digital credential it is issued by the same digital credential isser of the"
  },
  {
    "startTime": "00:22:01",
    "text": "digital credential where it refers to and um the holder the wallet obtains it automatically and the force should present the status assertion along together with the related credential to the relyant party status assertion allow to not renew our credential requiring low high because in at least in my church we believe that uh credential issued with a low high should not be um obtainable using a refresh token and another is that um a status assertion allow that the ring party must not well definitely the r party since the party should not have any other interaction outside the with the one with the wallet distance while the status assertion allow the ring party or other wise allow the wallet instance to present the proof of no revocation of digital credential therefore the L party is not forced to reach the credential issuer or any other status list provider and the most important reason why this specification was born is that status assertion allows um that the line party checks the no revocation status and at the same time um does not allow a reli party to continuous check the status of the credential over time um this is an example of a digital credential that um supports the status assertion and as mentioned by Paul and um Christian we use the same Json object status where uh along with aside with"
  },
  {
    "startTime": "00:24:01",
    "text": "the status list we may have also status assertion and this make us evident that a single digital credential May support um both uh status list and Status assertion this is an example of a request and also a response as evident we use application Jon and in a single HTP request we are able to request more than a single status assertion belonging to uh more uh digital credential this means that if a credential issuer is able to issue or have already issued more than a single credential to a single holder the holder with a single request is able to obtain uh all the status assertion it needs and therefore the response is an HTTP to with content type application Json and an array with all the response where um within the status assertion response array we may have status assertion or status assertion error uh respect respecting the um index value the position of each artifact in relation to the um this deposition of the request object in the HTP request the here an example of status assertion request object where um proof of possession mechanism is required to demonstrate The Possession and the control of the digital credential where um an old request uh related assertion and this is a status assertion object where else I would say that status assertion is therefore signed by the credential issue and must be presented to a relying party"
  },
  {
    "startTime": "00:26:04",
    "text": "um well I can told you I can tell you that in the current implementation the holder present the status assertion within the VP token using using for example open ID for uh verifiable presentations um Next Step uh I would work more on the jpe there's a question from Christina do you want to take a look at this Christina do you want to talk about that question yes so je this is basically the model where it's not the verifier but the wallet um obtaining the status list and sending it to the verifier right CH Christina yes so I do have concerns with that M um we spent a lot of time discussing at one of the large scale pilots in Europe and where people were trying to entertain that idea and basically I think one of the big conclusions was if the verifier is trusting the wallet to do all the status management like why do you need isure signature and knows that in the first place right so and also from a you know I'm not sure how privacy preserving how much privacy preserving ads either because it sure doesn't know who's calling wallet with the verifier anyway right I think John was making that point earlier but I think my my larger question is enabling this model where wallet is fetching status list on behalf of the verifier what implication does it have on the trust between verifier and the wallet and does it actually make sense from that perspective sorry Christina I missed the question but this obviously caused by my language level you mixed a lot of things"
  },
  {
    "startTime": "00:28:00",
    "text": "together are you asking about the value of wet of the status assertion in comparison with status list or about the burden that it's moved to the riant party in doing verification or what can you replace the the the single question please I'm concerned that wallet fetching the status list on behalf of the very verifier does not really make sense from the perspective of the trust between verifier and the wallet it's not a question it's a big concern I'm not sure we should enable it well this this is our opportunity to have a good conversation um I can bring the evidence that the wallet the holder must be informed when a credential in possession of a is revoked therefore obtaining the status assertion about the credential it holds is something that that meet the requirements and uh also well you know to inform the user at least and therefore this stus assertion can be provided to riing party and verifier also in offline use cases the riing party doesn't need to reach any other third party so uh this is very efficient because in a single HP request the holder provides all about the stat the the digital credential and the status abouts the the point is uh working with legal teams uh we are facing a big issue about do are we sure that we may allow our Aline party to continuously monitor uh status of a credential even outside the user authentication me authenticating to Rel party a yesterday"
  },
  {
    "startTime": "00:30:03",
    "text": "Rel party a once have the index and the URL of the status list is a to monitor the status of this credential over time there are use cases where the party should or must doing this an example when a citizen request and obtains social benefits or stuff like that are use cases that we are not enable to do this I'm not in favor of status assertion against status list as you as Christian mentioned my proposal was to include this approach because I'm driven by the requirements first of all the legal requirements um that probably the question we are working on is um are we sure that only two revocation check mechanism are enough do we have mapped all the use cases that may um raise the requirement to have another additional uh status check mechanis and probably I didn't answer to your question Christina Christina do you have a followup to you want to some clarification from jpe I kind of do but there was lot of questions in the chat chat so yeah I don't know I I see lots of comments in the chat so people any anybody wants to kind of talk about this here instead of a chat there yeah Paul go ahead yeah just to be sure about the discussion and the chat so the difference to ocsp stapling is that this end point provided by the issuer is kind of protected so that the verifier cannot access it correctly it's protected the way that the that the"
  },
  {
    "startTime": "00:32:00",
    "text": "wallet needs to do um assigning operation to the request object yeah I I I just read the question from Oliver yes it is correct the wallet must prove the to be in possession of a digital credential so there are sort of protection based on the proof of possession of the credential I think that's also a little bit my concern because um as it's designed right now this means that the reference token as I would call it in our spec so the the the token that the status is about needs to have a CNF claim um so that you can because you need this key in the reference token to authenticate towards the issuer's status endpoint what what I would propose is that um you would decouple this more from the referenced token and I I think you should more of provide Keys within the issuance uh because I think for us it would be interesting to to um to allow reference token that don't have a CNF claim anyway um I well I I read Brian Campell comment about the use of the mons and rat probably we are going to define a new term mons that it's seem something different than knows but may need another meeting and Paul yeah actually we have stuck using um confirmation method based on cryptographic uh proof um did I miss something I would say my point is I would not base this proof"
  },
  {
    "startTime": "00:34:02",
    "text": "on a key in the reference token but on a key that is provided alongside during issuance otherwise you can only make status assertions about tokens that have an embedded public key if you for example take um exess tokens yeah an ex token can be opaque and does not contain a public key that can be checked yeah yeah I I fully agree with you there may be several confirmation method uh in the in the last changes in the individual draft we have played uh more about this requirement to get this generalized at the same time we have um provided some concrete and practical example using cryptographic proof of possession but during a present we know there may be different U proof of possession mechanisms different than cryptographic um regarding the which public key to use you know I'm not as a fan a a great fan of the linked keys or at least for today um I'm T I'm trying to keep the specification simple without playing with key derivation mechanisms and stuff like that uh the individual draft is pretty I would say it's pretty fresh and um well probably we we we should continue at this stage it is my interest to consolidate the uh requirement to have another even another um revocation verification mechanism okay uh Oliver hey hello um yeah so would it make sense to"
  },
  {
    "startTime": "00:36:00",
    "text": "protect the status endpoint using the same depop key assuming uh you were issuing the credential using open for VCI through the credentials endpoints then you might solve um some of the problems or might address also Paul's comment yeah we know that there is going well there was a lot of discussion about wallet trust evidence AR array of attested relable cryptographic key in possession of a single older and therefore there may be several opportunity in the future to uh extend how the uh this end point can be protected even with proof of possession um demonstrated with key different from the one using in the digital credential uh please open issue nothing will be overlooked you know okay um Christen yeah one question regarding let's say scope one of the discussions we always had been talking about this was if you can request a new credential why would you use some kind of status assertion because you could just do shli credentials and that would be be basically your freshness right so scope would be that this is used when you have L High where it's not easy to get a new credential is that correct and for the use cases where it is reasonable to just get a new credential you would just do basically very short lift credentials and use that instead yeah yeah let's um let's talk about the the story of the user that obtains a digital credential with low high and uh using uh the electronic"
  },
  {
    "startTime": "00:38:01",
    "text": "identification card with NFC proximity pin and biometry well you know all the stuff required required for lowah high a shortl credential could be something less than 24 hours and uh with design service design that works in the field of user experience which try to uh avoid this because we do not want to force citizen to uh well you know the burden of lowah high uh for identification authentication and credential issurance this is something that can be achieved because there may be strategies that say no we want to use refresh tokens we want to use but at least in Italy there are several concerns about the the use of refresh tokens because there's something that went out from the control of the user because we know that the refresh token is in control of the client and uh a wallet distance at the end what would be the value of the referesh token user a automatically and obtain another digital credential and we don't think that this uh matches the low high we want and neither the user control that we want for the wallet ecosystem but I I'm not excluding other strategies based on short lived credential um something different okay Paul yeah I think the question from Christian is the the most important one um if if there are good reasons why this is better than shortlived credentials I think then it's definitely a Worth to adopt this um as um yeah it then has uh quite different tradeoffs compared to to"
  },
  {
    "startTime": "00:40:00",
    "text": "status list just has different privacy tradeoffs it it's probably or most likely definitely worse in in scalability but it might be more privacy preserving depending on which use case you have but I think the the most important consideration is how does it compare to shortlived credentials okay thanks Paul uh jepp do you want to wrap it up with the this last last slide here no I believe that we had a very good conversation thank you guys awesome thank you josepe hopefully we continue that discussion in in Vancouver um okay AR you have the the floor and the control great oh yes I do thank you okay um I'm GNA give a quick background on the problem that this draft is solving and then I have a couple of notes on um how it relates to the others at least and how I see it so this is your typical ooth um flow of a client getting getting its tokens from an authorization server um I put these terms at the bottom app and app backend as more colloquial terms that you would find people um using in discussions uh when they're talking about building building things um so this is just a regular o flow what this draft does is adds a new endpoint to the authorization server uh which an external tool or other um or identity provider can use to tell that authorization server to revoke the tokens it has issued to a client application so uh the idea being in um"
  },
  {
    "startTime": "00:42:03",
    "text": "in some cases like in the identity provider use cases would be if uh this if this client has has done a Federated login to uh an external identity provider and that identity provider wants to tell uh eventually revoke the the tokens from the the client Downstream um this is built on uh it uses the subject subject identifiers for security event tokens as the identifier in the in the revocation payload um this endpoint does require authentication uh but that particular method of authentication is left out of scope and that matches the token introspection uh how token introspection handles authentication as well um in our current implementation the authentication we're using is actually a uh very similar to the open ID private Key Jot client authentication so it's a it's a jot sent in the uh it's sent in a bare header rather than in a the client assertion post body parameter but the jot is structured very similar to what you would find in open is private Key Jot method which is actually RFC 7523 um the expectation of this endpoint is that any refresh tokens issued are revoked if it's possible to revoke access tokens those should be revoked um I say if it's possible because some people have implemented access tokens in a way that are not revocable um and importantly that authorization server must reauthenticate the user before issuing any new access tokens um this is what it looks like in a post request so uh the the actual endpoint is not defined of course that's just an example path uh the there's the jot"
  },
  {
    "startTime": "00:44:04",
    "text": "authentication in the authorization header there's the um user in this case is identified by an email address um the there's a couple because this is a subject identifiers format there's a couple different options you can use to identify users uh including an opaque ID or issue or subject uh so you know however whatever whichever way makes the most sense for the down the the downstream server you're talking to is what you should use um the response is just an HTTP status code saying it worked or didn't work uh there's no need to communicate anything really further than that so if you return 204 that's an acknowledgement that the authorization server is processing the verification it is um not uh it is not it doesn't have to be uh revoked synchronously it can absolutely be done asynchronously so that's why it's a um two4 no content and it's not meant to like acknowledge anything else beyond that um and then otherwise just standard error codes if if something's wrong with the request um in in doing this I did a a survey of other existing token revocation drafts in the various communities um in a quick summary of that the RFC 709 token rication is um it is a client initiated call and the input to that call is the token itself which doesn't work for this case because the input in this case is about usually a user identifier um front Channel log out is a similar problem uh where it's client initiated uh so it doesn't really work and it also doesn't work because it's in the front channel uh back Channel log"
  },
  {
    "startTime": "00:46:00",
    "text": "out from opened connect is the closest to this uh however the language in that mostly talks about terminating sessions and it actually has a sentence which is a particular problem which is that refresh tokens with offline access should not be revoked and in in our case we explicitly want refresh tokens of all kinds to be revoked um there's some overlap with the open ID shared signals framework uh although the big difference there is that it is as in the name a signal it's a signal about something that happened in one system so the closest you could get to map to this use case would be the identity provider sharing a signal saying that a a user has gotten logged out of that identity provider uh but it is not it is explicitly not a command in the shared signals framework and the receiver is meant is expected to do whatever the receiver wants with the information it learns from these signals which may or may not be taking action um and again in our case we want it to be a very clear command that the authorization server it's a very clear contract that the authorization server does revoke those tokens um it's also a lot more infrastructure to set up to receive those so that's the short summary um I think as uh as mentioned in the first presentation um I compared these this to the other ones we talked about today um I really I see this as as like an input into this like a thing that could cause any of these uh this would cause a token to be revoked and then how the revocation happens would have would be determined you know based on however you're implementing token revocation so if you're using sadus assertions um then the authorization server would no longer issue uh the expectation would be that the authorization server would not issue any further assertions that the token is valid when asked and in the token status"
  },
  {
    "startTime": "00:48:02",
    "text": "list it would be that the authorization server would flip that bit in the status list and that would cause the resource server to uh reject any requests with those tokens in the future um so basically this would be an input to A system that uses either of these the end thanks Aon um I was quick short sweet okay questions comments thoughts Hest hi uh hi everyone uh sorry for being late um one question for me is um and we see at least with the very fiber crous work a tendency to make uh tokens rather long lived and thereby we run into the issue that we suddenly need to have all sorts of different revocation mechanisms and the question is to me is out of all of those how many do we need uh because I see there's like uh I see a a relationship to what uh has happened in in the uh B world where all sorts of different mechanisms have been developed and then like still people are unhappy because all of them have different pros and cons and and in the end it's it's a it's feels like a little bit of mess uh and I'm wondering whether we can learn something from that uh environment because they have gone through a little a little bit of pain already I don't know maybe maybe it's just me that has that thought and maybe it didn't occur to anyone else but so so this is a generic thought uh Hest not specifically on this document right that that's completely correct yeah I think"
  },
  {
    "startTime": "00:50:01",
    "text": "it's a more general question fair enough so maybe we can get to that a little bit later I just wanted to see if people have thoughts on this specific presentation I see Oliver in the queue go ahead Oliver yeah thank you I think it's also a more General thought but this presentation just triggered that thought um so you saying um um these are revocation endpoints when the status list draft we currently Define it's currently defined that uh that think three different status bits or types valid invalid suspended and I I don't know if there are a similar status types in the uh status assertion draft that chpp just presented do you think would it be needed to Define status bits types across the different status methods um to because otherwise you you wouldn't really know what um hitting the location endpoint will do with the um respective tokens would it then be set to suspended or inval it so I think um there's definitely some interface discussion there and if you're speaking I we can't hear you Oliver you're back sorry hello yeah can you hear me yes we can okay so I was just um wondering whether we should um oh I think we lost we lost eron or is it okay Aron can you hear us I can hear you I wasn't sure if a question for me okay okay yeah"
  },
  {
    "startTime": "00:52:01",
    "text": "sorry yeah it was a question actually so I think the concrete question for Aon was so if you revoke a token would then how how how does the status list provider know in case of the status list specification what to do with the token would it set the tokens are suspended or invalid um because currently the status list defines three different status types and I guess for status assertion it might be even different um and then the question the follow-up question would be do we need to standardize um at least a revocation or revoked stus type so I think uh Brian has Brian has said what I want to say which is this my the intent of my draft has zero to do with VCS it is about it is about ooth in the traditional ooth sense of apps getting tokens from an authorization server and needing to revoke those tokens so I I do think it's confusing grouping it with these other two presentations that are explicitly about VCS and wallets uh so that probably didn't help the discussion here um I'm trying to go back to just back to the the ooth world so um if I I put in that last slide how it relates because that was the homework we were given uh but I if you want to use a status list as a mechanism to keep track of ooth access tokens that's fine um you you can do that I think that there's an interesting some interesting uses of that even though that's not the intent of the draft uh and in that case yeah we probably need to make it very clear which of the flags to use but um"
  },
  {
    "startTime": "00:54:01",
    "text": "that's yeah okay uh Paul yeah I mostly wanted to refer to all of us comment I think it's it would be valuable um if the status types could be reused across these status mechanism drafts uh also I thought it could be beneficial like if the terminology uh between those two drafts is is somehow um aligned as good as possible so that if readers want to compare different status mechanism it's uh easier to compare if if the same terminology is used okay thanks Paul um Peter hi Aron thanks for presenting this um I was curious right when how does the authorization server then end up communicating back to things like the resource providers or the uh resource servers is that something that still needs to be done via SS or Cape or something like that yeah that's a good question um in the in the oath model that link is traditionally out of scope um so if you look at all the definitions of how resource servers validate access tokens those are out of that's out of scope of of ooth and then we do have now one draft which is the jot access token draft that talks about how a resource server can validate an access token in that particular format um so that is to say in some cases the authorization server and resource servers are the same server and in that case there is no need for any complicated mechanism or any spec to to Define that behavior um because they're just the same server and it's all internal logic if the"
  },
  {
    "startTime": "00:56:01",
    "text": "authorization server and resource server are separate servers then they're going to have to coordinate somehow and uh that's where we need to start we basically need the the re the opposite of the John access token spec which is how how the authorization server and resource server can coordinate on revoking jot access tokens um other than that it's just all internal infl ation uh anyway so how the the main the main point is how is the resource server validating the access token in the first place uh because the answer might be it's asking the authorization server every time using token introspection in which case now you don't need to do any more work uh or the answer is you're using jot access tokens and now you need to keep track of token statuses somewhere which is where there is some overlap with for example the S list draft okay and yes ar ar from chat is is uh reminding me that this is why revoking refresh tokens is a must and access tokens is a May because revoking refresh tokens is something the authorization server can do on its own which will prevent further access tokens from being issued and revoking access tokens is a May because it's not always feasible depending on how you've deployed it yeah I thanks thanks Arin thanks Peter just want to quickly we we have two minutes or two and a half minutes here go back to hanes's question about multiple multiple revocation methods do we need all of those and did we learn anything from the pki experience anybody has any thoughts about this Peter I don't think we"
  },
  {
    "startTime": "00:58:01",
    "text": "did so Christian is in the queue Christina do you w to join the queue please yes okay Christian so my current take on revocation is as long as we don't have scalable secure cryptographic accumulators we basically need more than one model there is basically no one system that that fits everything in my opinion right now okay than thanks Christian Christina yeah I don't think we're seeing any convergence towards a single model and at least in the wallet space right not talking about Aon draft SL pure o space um I don't think we have clear metrix who is using what when eer it's more like each implementation is choosing whatever seems to fit their requirements um and when that happens from my experience in the wallet space it's very hard to drive conversions so yeah I'm partially um embracing s for a world where there will be multiple Iration mechanisms and everyone will have to implement everything um yeah okay thanks Christina anybody else before we wrap up here hes do you w to talk about this comment last comment here yeah which I made a typ in there anyway um yeah I was I was wondering whether it's uh out of all the mechanisms and I've seen more being developed outside the ITF um on"
  },
  {
    "startTime": "01:00:01",
    "text": "whether whether developers are actually aware of the criteria for deciding for one or the other mechanism um whether that's such an easy easy decisions like almost like a decision tree like if you have that deployment go for this mechanism otherwise go for this and if there's yet another criteria do this um I think that would be quite useful to avoid confusion I can already see in a couple of years from now people complaining about this topic yeah okay thanks thanks hes good comment so yeah clearly there's a need for more discussion about this so hopefully we'll we'll continue this discussion in in Vancouver uh thank you all for all presenters or attendees and um let's let's continue this in in Vancouver thank you thank you right byebye bye bye"
  }
]
