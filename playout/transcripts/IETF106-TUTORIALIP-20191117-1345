[
  {
    "startTime": "00:00:05",
    "text": "you\u0027re probably for coming sorry for the AV difficulties I guess that\u0027s what happens at the start of the week unfortunately that means you\u0027ll miss out on all my animations but under the circumstances we\u0027ll make do with the PDF version my name is Joe Shaw I did my degree in computer science at Cambridge I did my PhD at Stanford while I was there I was one of the few Mac users everybody else was running Linux and I got tired of all the other Stanford computer science PhD students coming to use my computer to print because they couldn\u0027t figure out how to do it I I was quite vocal about the terrible state of ease of use for IP back then compared to Apple talk where you just pull down the Apple menu and click on the chooser see a list of printers pick one I became co-chair of the ITF zero configuration working group I served a term on the IAB I wrote The O\u0027Reilly book you see there\u0027s there a configuration networking and I am currently a distinguished engineer at Apple so apple talk in the 80s was well known for its ease of use and what we\u0027d like with zero configuration IP is nobody ever has to type an IP address not to configure a device to set it up and not to connect to some service on some other device and if you think about today nobody has to type MAC addresses we have this protocol called ARP that maps from IP addresses to MAC addresses we should do the same thing with IP addresses users should deal with names and we should map those programmatically to the current IP address of that service why do you care if you\u0027re making products it lowers the support costs if people are not calling because they can\u0027t make it work it saves you money people are not returning the product because they can\u0027t make it work it makes entirely new product category as possible which would not be possible there would not be a market for them if they were so difficult to use nobody bought them and perhaps last but still interested it makes products that are a pleasure to use instead of a pain we still see applications that look like this that ask users to type in the IP address of the thing they want to connect to these are some pictures from when Apple introduced air print you tap on print and you see the available printers nobody types in an IP address Apple uses zero configuration networking for things like air print airplay home kits you don\u0027t see anything in those UI where the user has to type in the IP address of what they\u0027re connecting to this is especially critical for devices that have no screening keyboard think about Wi-Fi access points the only way you can "
  },
  {
    "startTime": "00:03:05",
    "text": "configure and manage a network device with no screening keyboard is over the network so you have to have absolutely reliable networking because if it can\u0027t be reached over the network there is no way to reach it 20 years ago we had serial ports and you\u0027d connect a vt100 terminal to its and manage it over the command line and there are still some products like that but more and more we want to move to a world where we don\u0027t need a serial port as a crutch to make a networking work the networking should be self-sufficient so how do we realize this vision there are three supporting technologies the first one is you\u0027re not going to do much IP networking without an IP address DHCP is great if you don\u0027t have a DHCP server you don\u0027t the product to fail so that\u0027s where self-assigned link-local addressing comes in this is really simple in v4 and in v6 you pick a random address within the designated range you send an ARP or neighbor discovery request to see if it\u0027s already in use and if it is you pick a different one and try again so that\u0027s great we now know that all our devices will have an IP address may be randomly picked or may be DHCP assigned but if we don\u0027t know what the address is that\u0027s only got us partway there so we want to do naming DNS is great if you have DNS setup and you have the infrastructure to do that then that\u0027s a great way of naming devices just like with link local addressing where we want to fall back when DHCP is not available we want to fall back when DNS is not available and that is multicast DNS which adopts as much as possible the same naming syntax the same record types and as much as possible the same semantics except it is just done using multicast where the query in client sends a multicast to all devices on the local link and if any match that name then they respond you can name your devices with anything ending and dot local and the dot local is what signifies to the underlying resolver infrastructure to look this up with multicast on the local link so once this is in place you can type printer dot local into your web browser to access the printers web UI to check the ink levels and things like that or for developers it\u0027s super convenient to be able to log in with SSH without having to remember IP addresses they can access their devices by name on the local network so this is a step forward but you still need to know what name to type and if you type it wrong or don\u0027t know what to type then it doesn\u0027t work and you don\u0027t get any helpful error message so the third thing we need is discovery and there are three basic operations in discovery that I call offer enumerate "
  },
  {
    "startTime": "00:06:06",
    "text": "and use offering is the step where a device that has a listening socket TCP UDP quick SCTP any other protocol if it\u0027s listening for incoming requests then it can advertise that on the network clients that are looking for that type of service can then browse or enumerates the instances on the network that can meet their needs and then finally having picked one either the human user picking one or with machine-to-machine applications some algorithm chooses the appropriate one maybe just the first one it finds in some case as having made that choice the third step is actually using it which means finding the IP address making a connection and so on sometimes this happens once sometimes discovery is just used for onboarding a device onto the network I\u0027ll give an example with the homekit products that do home automation when you get them out the box they\u0027re advertising a service type which basically says I am a non configured device waiting to be set up the client in this case an iPhone browsers for that finds those devices communicates with them over the network using the setup protocol and once that done they\u0027re now set up they are no longer done configured device in other cases where you for example select your default printer then you may do that selection once but every time you hit command P and print to that you may do that multiple times per day so this discovery stuff sounds nice one of the things we want to keep in mind here is very constrained devices I talked about home kits building automation IOT a lot of these devices have limited resources we\u0027ve already decided we need DHCP and self-assigned addresses we need DNS and multicast dns for naming if we can leverage that code that we have any way to do discovery as well then that saves us having a whole new body of code so let\u0027s get a bit deeper into the three operations they talked about the first step is offering a device a service running on a device a piece of software uses the discovery API to publish DNS records describing the service and those three record types are PTR SRV and text you might ask what are those records well when I show you the next steps that will become apparent so imagine you are trying to prints on your iPhone using AirPrint and you\u0027re looking for printers that support IPP you send out that query on the network and you get back in this case "
  },
  {
    "startTime": "00:09:07",
    "text": "there are four different devices that answered each with different names and the user can then take a look at that list and decide which one they want to use this is the browsing or enumeration step once the user has picked one we go to the next step which is actually using it so in this case we look up the SRV record and the txt record for that name that the user picked the SRV record tells us the target host and the port on that host the txt record gives us a bunch of key value pairs that describe other attributes of the service in this case for example it says the page description language that this printer supports is PostScript also by the magic of DNS additional records even though the client didn\u0027t ask for the address record of the printer the responding device knows that he\u0027ll probably need that information so for the target host referenced in the SRP record it has an additional record giving the address of that to save the client doing another round-trip to look it up notice the port number in the SRV record this is incredibly helpful this frees us from having to use fixed well-known ports if you want to run multiple instances of a service type on the same device they can\u0027t all have the same port and this leads to very complicated workarounds HTTP has the host header which lets a server act as multiple virtual servers but it\u0027s kind of awkward IPP has similar demultiplexing but every application has to invent this demultiplexing if you just run each instance on its own port it\u0027s much simpler and that wasn\u0027t possible with well-known har code hard-coded ports but service discovery frees you from that restriction so going back to these results let\u0027s take a little bit of a closer look at that name on the left it is a structured name made up of three parts the first part is the user friendly visible name of that instance of the service it is arbitrary utf-8 text it can contain uppercase lowercase spaces punctuation anything you can represent in utf-8 typically users don\u0027t have to type this name when they connect to a service typically they using a graphical user interface and they click or tap on it so keeping it short and easy to type is less important than have it be descriptive when you set up the device you name it however you want and having done that naming then other clients just select it by tapping the second part of the name is the service type which tells us what it does and the final part is the domain so let\u0027s look at those three in a bit closer detail starting with the "
  },
  {
    "startTime": "00:12:09",
    "text": "instance name there are two kinds of names at play here there are the host names and the service names host names are what we\u0027re used to thinking about with DNS they\u0027re often typed on the command line with things like SSH commands in terminal windows and it\u0027s definitely convenient to have those to be short and memorable and easy to type and it\u0027s good if they don\u0027t have spaces Pickers shells get confused with spaces in arguments service names on the other hand should be as rich and varied as file names and we used to have dos 8.3 file names all capitals but we\u0027ve moved on from that and the same is true with service names having rich tests naming is something we should expect in today\u0027s world this is a point where I\u0027ll make a little digression something we see a lot of vendors do is they feel the need to make the names unique in the factory by stuffing the MAC address into the name and I it\u0027s a mystery to me why people sometimes think this is full thing to do because multicast DNS has name conflict detection and automatic renaming so let\u0027s consider three different scenarios one is the average home user has one printer they don\u0027t need a 12 character MAC address if the printer is called HP LaserJet then that\u0027s their printer now imagine a small dentist office where they have two printers they have one and it works fine and later they decide to get a new on the second one they add will detect the name conflicts and call itself HP LaserJet - now most people in the dentist office without even thinking about it will very instinctive to remember that\u0027s the old printer I\u0027ve been using for years and the new one is printer - no confusion two different MAC addresses much harder to remember than the new one is number two third scenario is imagine you have ten printers well at this point memorizing ten MAC addresses is no use to anybody numbering them from one to ten is at least a little bit better in reality when you get up to these numbers what makes sense is for the administrator the person buying and installing this should go into the web UI of the device and give it some kind of more meaningful name but in none of these cases is MAC addresses any use to the end-user trying to tell what thing they\u0027ve discovered so let\u0027s move on to the second part the service type this seems very simple but there are some subtleties here this is not displayed to the user this is something only programmers see so there is no value in rich text here they\u0027re limited to 15 characters letters digits and hyphens just like traditional host names that is "
  },
  {
    "startTime": "00:15:10",
    "text": "a big enough space that they\u0027re effectively unlimited the allocated first-come-first-served and there\u0027s no risk of running out on the other hand the identifier space is short enough that it\u0027s not wasteful in packets particularly for these IOT type applications I\u0027m talking about you want to be mindful of wasting bytes in packets the second half the label is the protocol type string this was inherited from the definition of DNS SRV records in retrospect looking back it probably isn\u0027t necessary and it causes confusion but it\u0027s a legacy from what we adopted and the rule is if the protocol runs over TCP attention underscore TCP and everything else is under school UDP and that would include things that actually don\u0027t use UDP but they\u0027re pretty rare things like quick actually run over UDP so that\u0027s why the world is divided in two there is TCP and there is UDP and nothing else now the semantics of the surface type string are really important because they encode two things they encode what the service does and how it does it what it does is a user meaningful concept like say printing that is something somebody understands but there are many ways of printing there\u0027s IPP there\u0027s the old LPR protocol there is a collection of proprietary printing mechanisms that traditionally use port 9100 variously called apps or Couture jetdirect if you discover an IPP printer but your client doesn\u0027t support IPP that\u0027s no use to you so it\u0027s not sufficient just to have the logical service that the user wants you actually have to have a compatible implementation and this is important the other way around as well I can give an example the music streaming protocol built into YouTube into iTunes is actually just HTTP GET you can share your music library on your home network and other clients just do HTTP gets to fetch it so at some level the protocol is HTTP but semantically this is not something you would use a web browser to view there is no HTML formatted text for a human to look at so the service type for that is not HTTP it\u0027s a different string it\u0027s D a ap digital audio access protocol even though Wireshark would look at it and decode it and perfectly well say this is HTTP semantically it is a repurposing of HTTP so the service type encodes both what the user perceives they\u0027re doing and the protocol that\u0027s being used to do it here are some examples IP p is "
  },
  {
    "startTime": "00:18:10",
    "text": "printing ssh remote login remote frame buffer is VNC screen sharing you can see all of these in use if you if you have max here in the terminal window press command shift K it will bring up a browser showing you or your fellow IT efforts you\u0027ve got SSH turned on on their machines it\u0027s important that these service types don\u0027t collide so Ayana maintains a free registry like many of the other registries they maintain and it is first-come first-served within reason unless there\u0027s an abusive number of excessive registrations there are no restrictions on getting a service type assigned and you just fill in the form and you get one and it\u0027s yours in perpetuity it doesn\u0027t have to be renewed every year like a domain name before shipping your product do register your service types because it would be awkward if somebody else used the same name and then you have inadvertent conflicts on the network now let\u0027s get to the third part of this name the dot local well dot local tells the underlying system look this up with multicast but if the name is not dot local then that means used the standard DNS that we all know and love is there a question there okay am i not close enough is that okay thanks like that is that not towards my mouth okay okay we\u0027ll see how that works try to talk louder so when you\u0027re not using dot local when you\u0027re using some other domain then normal DNS that we know and love comes into play services can publish their information using DNS update and clients discover it using DNS queries and DNS is the largest distributed global database that I think the world has ever seen so it is incredibly scalable we use it for storing host names we can use that same distributed database for storing service information we\u0027ve been doing this for many years at the IETF and you may have used this without even thinking about it if you print out your boarding pass or print out an internet draft to read sitting here you can find the printer in the terminal room and you\u0027re not in the terminal room you\u0027re not on the same local link as the terminal room but it still works and if it didn\u0027t work people would grumble and curse stupid multicast DNS doesn\u0027t work across links but when it does work nobody pauses to think what just happened there they just they hit print they get their boarding pass and they\u0027re happy so I wanted a bit of a walk through to demystify what\u0027s really going on here "
  },
  {
    "startTime": "00:21:10",
    "text": "it starts with DHCP and you can walk through these commands and you\u0027ll see this happening here at the IETF meeting Network these commands are done on my Mac when we look at the information we got from the DHCP server we look at option 15 here it\u0027s displayed as hex but if we decode that it tells us that the domain that the DHCP server is reporting for this network is meeting not IETF Talk okay that\u0027s a good start so now we look up this special query with the prefix lb DNS SD prepended onto meeting dot ITF dot org and we do a PTR query and what that is asking of the DNS infrastructure specifically asking the people who run the authoritative server for meeting dot ITF tour dog is do you have any service discovery information and if so where should I look and here we get an answer and it\u0027s a sort of self referential referential answer it says look in meeting dot ITF go talk but because it\u0027s a pointer it could direct you to services ITF dog or wherever in this case it\u0027s simply self referential answer pointing to itself so now we know where to look we can start looking at services and one of the questions that people often ask me or what are the assumptions I hear people have is that you have to be quotes on the ietf network and that\u0027s sort of a loosely defined term what does it mean to be on the ietf network what is the ITF network DNS is global so here\u0027s an example doing the exact same query sent to Google\u0027s quad 8 service and it gives the same answer the answers that you get from dns for public names don\u0027t depend on where you are now VPN and internal DNS accompanies does muddy the waters a little bit here but broadly speaking for public names you can look them up on any resolver in the world that\u0027ll consult the same authoritative service and get the same answer so now we know where to look this is what happens when you go into system preferences on a Mac and click the plus button to add a new printer it does a PTR query on the network and here at the ITF we find one printer call term - printer they could have named that a bit nicer with capital letters and things but that\u0027s what they chose to do so when you do this on your Mac and click plus this is how it the ITF meeting you\u0027ll see that printer show up when you actually want to print this is the user you then look at the SRV record for that printer and you find that it is implementing that printing protocol on port 9100 and there\u0027s the ipv6 address and you can print if we do the same thing on iOS it does the query "
  },
  {
    "startTime": "00:24:11",
    "text": "and it prints notice here that iOS is using IPP so it\u0027s a different service type and the port number is different so same hardware different protocol different ports same results Turner on paper now those of you who are watching closely would have noticed something there in the query that the iPhone did it has this prefix Universal which is a subtype of IPP subtypes are a little used feature of service discovery but I want to mention them here for completeness because they can be useful if you need that subtypes are aware of narrowing the scope of what you find so in the case here there is no way for vendors to install custom drivers on an iPhone iPhones only support driverless printing using the IPP protocol but specifically the print has to support a format called universal raster format and the printer can optionally support many other formats as well but the mandatory to implement format is it must support URF because that way you know that your device may not be able to send post group for PDF or JPEG to this printer but in the worst case it can send a raster image and the printer will print it so the underscore Universal subtype of IPP is the subset of IPP printers that also implements URF so if you have a use case where you want to narrow your search to a subset of a particular set of devices that have a service type sometimes let you do that so now get on to how you can use this it is included I\u0027m sure everybody knows in Mac OS and iOS and has been for more than 15 years most Linux distributions include the avahi LGPL implementation Android started including it in 2012 and Windows 10 in 2015 added their own native DNS service discovery ap is the best way to get started if you just want to play with this and prototype is to use the DNS SD command-line tool which is installed on Macs if you get the NBS responder project for Linux or POSIX you just type make install and it will install the daemon and the same command-line tool if you have bonjour for Windows installed then the same tool is there this is not intended for you to embed it in scripts and use it in production software but as a quick and easy way to kick the tires and see whether this works for you it\u0027s a very low overhead way of trying things "
  },
  {
    "startTime": "00:27:11",
    "text": "out and if any of you are interested in seeing this in more detail afterwards we can sit down and do some experiments together it supports the three operations I talked about offer enumerate and use the - are option registers your service with the underlying daemon use tell it the name type domain and port you\u0027re listening on and then that is published on the network either with multicast DNS if it\u0027s local or if it\u0027s some other domain with the DNS update when a client wants to find those it does a browse operation and you\u0027ll see the parameters are very similar except you miss out the name you say the type you\u0027re looking for in the domain you care about and the result you get back is the list of names and then finally the lookup or resolve step that you do prior to connecting you tell it name type and domain because that\u0027s what you learn from the browser what you get back is the target host and port how you select local and wide-area this is one of the benefits of having it designed on DNS this way is it\u0027s not a different API use the same API you get the same semantics you get the same behavior it just depends on where the domain is local or something else in terms of API usage if you\u0027re writing an application we recommend that you don\u0027t specify domain just past null or empty string and that lets the underlying system apply the users defaults most of the time that will just be local but as you saw at the ITF meeting where you get hints from the network that in addition to local there may be other domains that have interesting things for you to find if you pass null the system will do the union of all those discoveries if the printing system passed local as its domain parameter would only ever find local things by leaving that unspecified it allows the system defaults to come into effect so here are some examples which for those of you who have Mac\u0027s or windows with Bonjour windows installed you can try these on different terminal windows on one machine or on different machines that example shows advertising a service called test of service type underscore test browsing to find those instances and finally looking up the connection information so that\u0027s how you prototype with the command line tool for programming you\u0027ll want to use C API s\u0027 or Java or Python or whatever language you\u0027re using I\u0027m going to talk here about the C API that are defined in DNS underscore SD dot H that is what has been used since we started doing this on "
  },
  {
    "startTime": "00:30:11",
    "text": "Mac OS and iOS if you install MD and SD on Linux it\u0027s the same API if you install our he ever he has its own API but it also has a compatibility layer that supports the same API s-- and Bonjour for Windows has the same API Android additionally has its own Java based API so they were introduced in jellybean so there\u0027s a link there which you can get in the PDF to find the documentation for that Windows similarly when they did their own implementation they had a slightly different API and the documentation is there but I\u0027m going to talk about the C API so that I\u0027m most familiar with here this is how you register a service there are a bunch of parameters the first parameter is actually an out parameter that is the result of doing this call that is a service discovery reference there are some flags which are optional typically those are zero you can specify an interface index if you want to constrain it to one physical interface again normally you just pass 0 you advertise on all interfaces you specify the name type domain if you\u0027re advertising a service on a different host then you can do that that\u0027s for proxies typically don\u0027t be null you specify the port you\u0027re listening on if you have any key value pairs then you pass a txt record and this is all of these routines take a callback function which gives you a synchronous notifications of events now if you compare this function with the Browse function you\u0027ll see a bunch of the parameters are the same but with some missed out you don\u0027t specify the name because you don\u0027t know the name that you\u0027re looking for you don\u0027t specify host and port but the other parameters take the same form and likewise for resolve it\u0027s extremely similar you\u0027ve now specify the name you\u0027re looking for but things like the port and the text record are the results you get when your callback is invoked so one thing you may have noticed here is all of these calls are asynchronous and that\u0027s because networking is at its heart asynchronous if you browse the network for services and the ethernet cable is not connected or the Wi-Fi non-associated you\u0027re not going to find anything and it\u0027s not helpful for the call to fail and the application has to then have a retry loop maybe wait for the configuration to change it\u0027s much easier to have the API just handle that so when you start a call going that call will run until you change your mind and tell it to stop and any changes in the environmental configuration that happened during that time I just handled automatically the way that a synchrony "
  },
  {
    "startTime": "00:33:13",
    "text": "is handled because over the years there have been many different models of asynchrony threads used to be in fashion but it can be difficult to get that right with race conditions event loops are now more popular there are things like Apple has CF run loop there is Lib dispatch there\u0027s selects and Pole and K events there are many different ways to have an event-driven system the way you integrate this into whatever system you\u0027re using is you extract the underlying file descriptor from this SD reference object and then you add that file descriptor to whatever your event handling mechanism is and then when you get notified that there is data readable on that file descriptor you call DNS service process results it will parse that data and call your callback function as appropriate if you get the open source M\u0026F responder codes that I pointed you to earlier then in there is the source code for the DNS SD command and that is a great source to crib little code snippets for the thing that you want to do the the main function of that is basically a big switch statement for each of the operations and you just pick the case in that switch statement that applies to what you\u0027re doing and that will show you how to register browser resolve a synchrony is really important for a good user experience and you may notice that you will not find a refresh button anywhere in any of the network browsing API a UI that Apple ships and that\u0027s because it simply calls the API the Browse call runs asynchronously as things come and go the results are updated if you do a browse with no networking you find nothing you associate with Wi-Fi you find some results you turn Wi-Fi off those results go away again if you roam to a different access point then the old results go away and new results are discovered this continuous change monitoring will happen indefinitely for as long as you leave that browser running for hours days weeks in principle if you can write an application please don\u0027t browse for weeks that\u0027s really hard on the network but if you did it would work the asynchronous results are worth mentioning in a bit more detail they also give us something really useful for free and that is event notification there are many systems then in addition to everything else they have a completely separate publish/subscribe mechanism for events well we don\u0027t need that because having the ability to do continuous operations that are updated as the environment changes means that those give us notifications as well so here is an example you have some service "
  },
  {
    "startTime": "00:36:13",
    "text": "on the network it registers its service to published on the network as date Rebeck that service changes let\u0027s say the ink level in the printer or the paper in the paper tray it can call DNS service update record to update its text record with new data and a client that wants to be informed of those changes as they happen uses DNS service query record which is not a one-shot query it\u0027s an ongoing monitoring operation it will continue giving you callbacks until you cancel it and that would for example allow a client to monitor the ink level of the printer and see it going down over time without having to continuously Paul every five minutes or every five seconds to find out the data so if you need something like this this is an incredibly simple and powerful mechanism this works for both local and remote services for local services when the publisher updates the record a multicast announcement is sent out to all the peers on the local network and listening clients get a callback notifying them the remote case is more interesting and this was more work to build the publisher sends a DNS update to the registry to update its information and clients that are interested use dns push notifications to register that interest and when the data is updated the registry then automatically informs any interested clients so that lets remote clients across the building or across the world get live updates to information without having to continuously poll to find it so some tips if you\u0027re building browsing UI you don\u0027t need a refresh button we really request that you don\u0027t leave browse operations running indefinitely there is a temptation when your application launches to start a browser in the background and keep it running so that you keep a data structure in memory hot just in case the user wants it that is very expensive on the network particularly Wi-Fi multicast on Wi-Fi is very inefficient and very slow and consumes a lot of airtime unicast Wi-Fi goes up tens hundreds in theory up to 1.3 gigabits per second and higher now with Wi-Fi six multicast is down at the single digit 1 to 6 megabits per second so a single multicast takes as much airtime as 100 unicast s\u0027 it is very very expensive so casually browsing in the background can consume a lot of shared network resources so the better way to do it is if the user brings up a browsing UI for "
  },
  {
    "startTime": "00:39:15",
    "text": "instance they tap the air print button that\u0027s the time to start browsing show the results you will see that it is already fast enough that the results appear within less than a second so there\u0027s no real incentive to keep a list in memory in advance and then when the user dismisses the UI stop the Browse operation another tip as a general rule users get frustrated when menus change underneath the mouse as they\u0027re trying to select something whereas windows that change are still can be confusing but they\u0027re less objectionable so we really recommend that you bring up a window showing brows results rather than displaying it in a menu that then shuffles around underneath the user\u0027s mouse and the final step is that there is a very deliberate conscious reason that we have the three basic operations use enumerate offer user numerate they are they\u0027re separated so that they can be done separately the enumerate step will find everything on the network and show the use of the names at that point you don\u0027t need to look at the IP addresses because the user hasn\u0027t chosen which one to connect to yet or in the case of software the software client hasn\u0027t chosen which one to connect to so it\u0027s only when you actually want to connect that you then look up the address for that particular service in many cases you browse the network to find something so the familiar example is setting up a printer you go into the printer preferences you click plus you add a printer some tips here we have seen people make this mistake when you find the printer if you saved the IP address well with DHCP that might be a different address tomorrow if you save the address and port well with dynamic ports the port number might be different tomorrow so the right way to think about this is late binding store the name type domain tuple of the service that were selected and then at time of use you look that up to the current address and port that\u0027s in use at that moment in time so here\u0027s an example of information you can find and that first column on the left is what you find by browsing the network you get a list of names and that is a small amount it is seven bits of information and if you look at one row on that chart that is the detailed information about a particular service but if you browse the network and resolve everything you find you\u0027re finding all the information about all the services and that is a very "
  },
  {
    "startTime": "00:42:15",
    "text": "expensive operation especially as I said on a shared network like Wi-Fi where you\u0027re consuming everybody else has shared resources to look at this information that you probably won\u0027t need so final advice here only resolved when you actually need the information because IP addresses change and you want to get the latest information at time of use another thing to note is when you resolve modern devices may have multiple addresses they may have v4 and v6 they have may have link local and larger scope addresses and if you just take the first one and that doesn\u0027t work and then you fail that\u0027s not a good user experience we have known this for a few years now we highly recommend you follow the guidance for happy eyeballs now you can implement this yourself which is a bunch of work or you can use an API that does it for you and here is an example from Apple suite of api\u0027s using network connection which is our current recommended API suite you simply tell it the service name type and domain you want to connect to and it will handle resolving getting asynchronous results sorting the candidates into a logical order trying each address in turn if it doesn\u0027t get an acknowledgement after some number of milliseconds moving on to start a second parallel connection attempt to the next candidate and so on so we really recommend you use api\u0027s that implement happy eyeballs it gives a much better user experience so this is the point where I often have people say this doesn\u0027t sound so hard we can just we invent our own broadcast protocol we don\u0027t need to use this and I understand why it seems that way because it doesn\u0027t seem like it\u0027s very hard you you broadcast some packets you listen you answer and when we started this it didn\u0027t seem that hard appletalk did name binding protocol we thought we\u0027ll do the same thing a year or two work this will be finished and what we found is to build a really really good service discovery protocol there are lots of things you have to take into account one obvious one is that Wi-Fi is very lossy so you have have retransmission okay no big deal everybody knows retransmission an exponential back-off there are questions about how you tune and tailor that to give the right performance Wi-Fi multicast is also very slow so we have a lot of techniques to maximize the efficiency of how we use the network one is if if you do a multicast query for IPP printers and I see it then because "
  },
  {
    "startTime": "00:45:16",
    "text": "all the responses are sent by multicast and I see those responses and I opportunistically cache them if you do a query I will see the same answers you do so if later the user on this iPhone presses the air print button we don\u0027t need to do another browse because I got to piggyback on the Browse that you did and I already have the results so duplicate query suppression prevents multiple devices on the network from doing the same query to minimize network traffic we have long cache lifetimes so once you\u0027ve seen something it stays in the cache for a long time now I\u0027ll come back to how we manage that because of retransmission there if you do it naively every time you retransmit you get the same set of devices answering so you say I\u0027m looking for IP printers and you get 10 replies well there might be packet loss maybe there\u0027s one that you missed so Yuri transmitted and you get the same 10 replace and Yuri transmit and you get the same can replace this is very wasteful so the queries include known answer lists which in effect say this is what I\u0027m asking for this is what I already know so if you\u0027re in the list you can keep quiet is there anybody else that I missed I don\u0027t know any other discovery protocol that implements known answer suppression there\u0027s also duplicate answer suppression which comes into play when you have proxies now for various fault tolerance and reliability reasons and other reasons I\u0027ll come to later you can have proxies on the network that answer on behalf of other devices and you can have multiple proxies but you don\u0027t want them all answering so the answers are delayed by a random interval and the answering devices also listen for answers so if they were planning to answer but then they see the same answer come from somebody else they can suppress their own answer so this is another one of the techniques that\u0027s used to minimize the amount of multicast traffic now I talked about the exponential back-off for queries again if you do this naively you get a very poor user experience because you query you query again you wait a bit longer you query again you wait even longer pretty soon it settles down to a quiescent query rate of no more than one query per hour now if a new service comes on the network waiting up to an hour to know about it is a not a good user experience so hand in hand with the queer is an exponential back-off when a new service joins the network and that includes both starting up a service or starting up a service and then connecting the cable or then associating to Wi-Fi and those linked change events are detected when the new connectivity happens then the service sends gratuitous announcements "
  },
  {
    "startTime": "00:48:17",
    "text": "so that if there are clients who have been listening for a long time they immediately get notified of the new service so that gives you very rapid discovery without rapid polling another aspect is we manage name uniqueness which is why you don\u0027t need to have names unique from the factory you don\u0027t need MAC addresses you can have simple names and if the name is detected already in use then the API will rename your service with a two at the end or if you prefer it will call your callback function and give your code the opportunity to pick a new name so I talked about the long cache lifetimes this is good for efficiency but it\u0027s not good when things go away now if a service shuts down cleanly it sends goodbye packets on the network but suppose the power fails then it goes away without saying it\u0027s going away and that data will remain in caches now as long as the user doesn\u0027t try to use the service that\u0027s kind of benign it\u0027s sort of like if the tree falls in a forest and nobody\u0027s there do they care but at the moment that user actually tries to use that service and it doesn\u0027t work that\u0027s when they get frustrated and if they get an error saying can\u0027t connect and they go back to the browser and it\u0027s still there then they get really frustrated so we do this lazy cache cleanup where if there\u0027s a connection failure we even though the cache record might have 45 minutes to go we decide we don\u0027t trust that and we do a couple of queries and if it doesn\u0027t answer we remove it prematurely from the cache so by the time the user goes back to the Browse UI that thing has disappeared and they at least now have a mental model of what happens they think oh somebody just turned it off and they walk down hall and find the printers turned off well that\u0027s nest not necessarily true maybe it wasn\u0027t just turned off maybe it was turned off half an hour ago but it doesn\u0027t matter because the user at least has a mental model about what happened and what to do about it that isn\u0027t frustrating a refinement beyond that is that if you try to print and fail and remove the printer from your list because it\u0027s turned off I passively eavesdrop on that transaction I see you querying I see no response coming back I update my cache as well so one user discovering that something is not visible serves to inform all the devices on the network to update their caches so this is how we get rapid addition and removal of entries without a high burden of polling on the network and then a final thing that is really important if you want a good user experience is mobility when you put a device to sleep "
  },
  {
    "startTime": "00:51:18",
    "text": "it sends goodbye messages saying its services are no longer available with an asterisk I\u0027ll come back to that and when you wake it up it renounces when you change your connectivity then it reissues queries it renounces services and that includes even subtle cases where you roam to a different access point you may be on the same Wi-Fi network name with this same IP address and the same default router address but if you switch access points the multicast domain you\u0027re in may be different with a different set of services handling all of these things in your own code is really subtle which is why you benefit if you use a very mature implementation that has done all these things I said the little asterisk about going to sleep one of the things that we support is a sleep proxy so you can have a device if it supports wake-on-lan when it goes to sleep it notifies a sleep proxy of what its services are what its name is what port it listening on and that sleep proxy can then act on its behalf and wake it up on demand that way you can have devices that offer services on the network that are available even when they\u0027re asleep to save power and finally using these existing api\u0027s gives you remote discovery like we use at the IETF it also allows discovery via this thing called the discovery proxy which I\u0027ll mention so here\u0027s the example I was talking about with a sleep proxy you may have a USB printer plugged in with printer sharing but the Macs are sleep the sleep proxy on the network answers on its behalf and wakes it up when the client wants to talk to it a discovery proxy is what lets you do discovery of legacy multicast DNS devices from multiple hops away now if this phone on the Left sends multicast queries on the local link it\u0027s not going to find the printer because it\u0027s not on the same link this is similar to the situation here at the ITF when you\u0027re not in the terminal room now at the IETF we have expert volunteers who run the network and the DNS and the Amanar you put the records in but for normal users we want to automate this and that\u0027s what the discovery proxy does it acts like an authoritative DNS server except when the client sends it a query instead of consulting a zone file that was typed in by hand by an administrator it uses multicast DNS on the local link to discover what\u0027s available and then uses that to generate the unicast answer back to the client so using that we wouldn\u0027t need the NOC volunteers at the IDF to manually manage these records so to wrap up there are some links in the PDF that "
  },
  {
    "startTime": "00:54:18",
    "text": "you can download if you\u0027re making a hardware device then I strongly recommend you do link local addressing here are the RCS that tell you how to do that for v4 and v6 here are the RFC several years old at this point for the basics of Discovery stuff that I\u0027ve been talking about and the Ayana procedures for registering service types there is a bunch of new work going on the wide area unicast registration builds on DNS dynamic updates with an addition that Ted Levin has been working on called Service registration protocol which basically builds on DNS updates by using 6/0 public keys to give a really low overhead simple first-come first-served but secure naming system where any device can claim a name but having claimed it and installed the key it gives you some protection against some other device coming along later and masquerading as that DNS stateful operations is the foundation for the query side features we\u0027ve been building and that includes push notifications for asynchronous change delivery and the discovery proxy which lets you automate this export of local multicast dns information to the wider space and if this seems like a mountain of information you\u0027re right it is the final link there is the roadmap documents which gives you an overview of how all these pieces fit together you can get the source code from the ITF hackathon github page that includes the source code for the command-line tool there is a great tool called discovery which is a graphical version which is a free download from the Mac App Store and then finally if you\u0027re building a hardware products you can get the Apple Bonjour conformance test for free and run that to validate your design because that is designed to catch many of the common implementation mistakes we\u0027ve seen over the earth so the - action here is if you\u0027re writing a piece of software that currently expects the use of the type in a name or an IP address you can carry on doing that but add a button for browsing as well so the user can pick from what\u0027s available if you\u0027re building a hardware product do link local addressing because that what gives your product bulletproof reliability even when things like DHCP are not available and use the conformance test as a verification so that is the end thank you for listening and we have a minute or two for questions if we have any oh and I do remember to fill in the survey helps the ED you team maintain the quality of the tutorials we have a tie ATF sorry no questions yeah the first one actually is if our ten printers right bring at the "
  },
  {
    "startTime": "00:57:19",
    "text": "same time they will rename it their name if on you know one to two hundred ten yes but how physically you can identify which printers with printer printer you can print a test page which physically a pizza but for IOT devices how can do that is only the way is Madras right questions right the second question actually is if printed number five I need to replace it what is the procedure okay so there are two questions there which is how do you identify devices and how do you replace devices excellent questions the way you identify devices is somewhat application-specific there are a couple of ways this is done in practice one is if you buy a device and then buy another one the next one is number two and then if a week later you buy another one that\u0027s number three so simply by virtue of the fact that you had two device on the network and you add a third one and now you have a device number three on the network well the one you just added is device number three so in many cases that is not confusing if you are getting 10 things or a hundred things out of a box all at the same time in connecting them then you are absolutely right in case the service discovery protocol is not going to tell you which as which in the case of IOT uh there is typically I know with the home kit stuff is what I\u0027m familiar with but there are many IOT home automation building automation protocols there is normally a command to have a device identify identify self by blinking a status light so in your list of things if you see number three and you click identify you see which one has the light blinking I still think that saying device number three and seeing the light is blinking and maybe getting a post-it note and putting a three on it is easier than putting a 12-digit MAC address on it and then having to somehow remember all those MAC addresses in your head and remember this is often only the bootstrap step this is the out-of-the-box configuration what you typically do with a bunch of IOT devices is you give them names like bedroom light switch downstairs hallway you don\u0027t know user wants to see a list of MAC addresses in their home automation application they want to see descriptive names so so that is a case of the out-of-the-box configuration step and then to answer your second question what happens when you replace it that is an excellent example say printer number five breaks and you go out and you replace it with an identical printer because you love the printer it was great that the employees in your company loved it we just want another one the same you buy one exactly the same you give it the same name through its web UI or whatever configuration tool you put it on the "
  },
  {
    "startTime": "01:00:19",
    "text": "network and then because the names are the primary identifier they could they identify the logical service on the network then the employees come to work next day and they print on printed number five and prints number five answers and the paper comes out and the fact that the atoms have been replaced with new atoms doesn\u0027t change the fact that the service is providing which is printing paper in the copy room on the third floor that service is the same even though the physical thing has changed and being able to give a new thing the old name so it takes over that role on the network is a really useful capability okay I think we have time for one more question because we did start late and we\u0027re running over but one more thing this isn\u0027t even a question it\u0027s mostly a comment as Stuart said seriously registration is easy don\u0027t be intimidated by the Ayane format you have to fill out but please don\u0027t please be sure that all you need is a service name just ask the service name don\u0027t also ask for the port you save yourself a lot of hassle yes I that the foremast lots of questions ports are in short supply if you ask for a well known port expect a grilling about why you need it if you leave the port number blank and say I want a service type you\u0027ll get a a big cheers from from my honor saying thank you for not wasting a port number and you\u0027ll get a very rapid confirmation of your allocation okay well thank you all for coming please do remember to fill out that survey [Applause] "
  }
]