[
  {
    "startTime": "00:00:49",
    "text": "okay so it\u0027s ten o\u0027clock so let\u0027s get we need a minute taker and a jabber scribe we have a job or thank you Joe for volunteering so early minute taker major decisions we don\u0027t need a blow-by-blow everyone who\u0027s sitting in the back we got plenty of room up here so come on up feel like I - you two have gone I feel like we picked on somebody else last time so I don\u0027t know I\u0027ll pick on the same person this time anybody anybody wanted a famous anybody we can\u0027t start unless we get a minute taker awkward silence minutes anyone take minutes anybody anybody that\u0027d be excellent a bad job is better than no job that\u0027s that\u0027s Felix thank you very much Felix I appreciate it I got a banana if you want one yeah it\u0027s mostly just the actions you don\u0027t need to like play-by-play what the discussion was of people we really need that we can get that back from the cording so welcome MLS ITF 106 I\u0027m Sean I\u0027m Nick hello and katrell is not here but he might be remotely and Brendan\u0027s in the Medeco all right so this is the note well it\u0027s Friday morning you should have seen this a lot unless you only came for today basically you know behave what you say if the microphone is going to be recorded if you\u0027re aware of IPR you need to disclose it that kind of stuff you can click on the links to get more detailed information pretty straightforward are we so we got a minute taker we got a jabber scribe the blue sheets are going around so that\u0027s please sign those when you get to the microphone please make sure to state your name and let\u0027s keep it professional at the mic our agenda is you know progress since the last interim open issues and future items we do actually have a fair number of slides though it\u0027s only two presentations so I guess we\u0027re going to start off with Richard check tested he\u0027s a little silly being up here on literally on a pedestal in front of this crap so what I was going to cover is kind of some changes we\u0027ve made since the last interim so this is going to be the stuff that went into Draft o8 which have been stuff we were largely discussing off and on before "
  },
  {
    "startTime": "00:03:51",
    "text": "then but this is kind of your notification that has landed and last chance to complain about it there are kind of bad is a kind of an understatement is that color alright alright well that\u0027s that is the only transitions only for transition so if the chairs want to take a three minute break I can change the soon yeah okay do we want to open up the set of issues just to just just open up github and okay so we\u0027re gonna just load up get up right now and give some folks just a high-level overview of what issues are open and these are things we\u0027ll be addressing later he looks in sticky notes okay so we have 16 open issues 66 closed some of these are very old this is just on a protocol document here are the 11 issues that are open on the architecture document the hope is that some of these will be resolved pretty quickly they\u0027ve been around for a while thank you doctor if I blink so I can download richard has used two sharpies drawn white paper this time "
  },
  {
    "startTime": "00:07:00",
    "text": "[Music] [Music] - - OH - a woman all right apologies for too much innovation there the game went too far so yeah so section 1 is stuff that went into draft oh wait section 2 is going to be things I screwed up in draft oh wait that I discovered on the plane on the way over here and then we\u0027ll have some future you look and stuff so the major the one like big change to dwarf all other changes this proposal commits stuff I think we\u0027ve been talking about this for a full meeting cycle we had a bunch of discussion at the interim about this but the the basic idea is that instead of having ads updates removes each initiate a new epoch now we have these proposals which get sent out to the group to propose a change but the change doesn\u0027t actually get in to put it into effect until someone sends a commit message so you can basically lazily add people or lazily update people and then they are not actually added or updated or removed until someone sends a commit um the idea is to amortize the costs of the updates in groups that are quiescent so you only have to send commit messages when you\u0027re actually going to do something with the group so if if you know there\u0027s there\u0027s a requirement in there that if you have seen some proposals come in Oh while you\u0027ve been quiescent and then you\u0027re going to send a message you need to send a commit before you send a message so that when active only any actual activity occurs within the group all those proposals get committed and put into effect before there\u0027s an actual encryption this obviously can be made to revert back to the previous scheme if you always send to commit alongside of proposals so it just adds the additional flexibility you know usual one layer of an extra layer of indirection adds that flexibility so that you can amortize cost in groups that are maybe lower activity Raphael you have anything you want to add on on this because this has been one of your favorite things yeah so this was fairly fairly invasive change in document terms but I think is mostly mostly works um you know implementation is just starting to kind of verify everything holds "
  },
  {
    "startTime": "00:10:00",
    "text": "together we found a couple of you know technical knits in in how it holds together but I think that\u0027s overall the the the message now one thing for for people to keep in mind is that proposals that are not committed cause the tree to degrade so here we\u0027ve we\u0027ve updated we\u0027ve updated two leaves and added some one in in the second leaf and they degrade the tree in the sense that\u0027s these these X doubt nodes they cause these X doubt nodes to be blank so when you when you do a change to a leaf all the proposals right now change the leaf and blank the path above that leaf and what that means is that when the next person updates they\u0027ll have to encrypt individually to a bunch of to the the leaf nodes that have been added or updated so you don\u0027t get the benefit of having the tree there you don\u0027t get the the performance benefit because all of these nodes are blank in the middle as a result of proposals that haven\u0027t been committed when you rebuild is when you do commit so here we\u0027ve had the the first left most node do a commit which has repopulated those nodes on its path to the root so you know there\u0027s there\u0027s this trade-off here between the amortization and you know things it when you impose the cost and the cost of the thing when you finally do it yeah so there\u0027s no way so when you say there\u0027s no way to reject a proposal right so one of the areas where we should probably start where we need more clarity as a follow-on to the technical changes is exactly what the policy is around what the policy considerations are for when what how proposals are accepted or rejected so right now in technical terms it is up to the sender of the commit message to decide what proposals go into that commitment so you can I can subset them yes and huh so what happens and what happens if if I propose one two three and four and then someone commits four three two and one in the opposite order so the proposals themselves aren\u0027t proposal to not ordered until they are committed so the committee also decides the order in which proposals are applied so what this does is it takes of what we\u0027re previously like distribute ordering problems that would have to be enforced on the group and makes the commit or the arbiter of sharing things so I mean I guess it\u0027s it\u0027s been a long time since I\u0027ve like looked at this in a detail but are you have you convinced yourself that that works in the in that it used to in the um I guess I guess or cheeky tree cam this is less serious he\u0027s drinking a lot simultaneous updates "
  },
  {
    "startTime": "00:13:00",
    "text": "like without the premise of Cree camp right but some things the tree home could not be sequenced that way it\u0027ll be not simultaneous and so I just tricky in principle allows simultaneous up you know I understand I\u0027m just I\u0027m just trying to make sure like that that my memory the situation was at some some things some things could not be see some things depend on other things and some what they spend another updates right and and so how do those so so part of part of what we what it took to make the proposals thing make the ordering independence work is that an update now is not is more limited than an update in the prior sense so an update does not get you pcs an update plus someone else committing gets you pcs okay so the semantics have changed a little bit in addition to the ordering things okay I\u0027m paying for the slit this seems come the seems all like oh so you\u0027re saying that if if if you\u0027re so if I offer one two three and four then you pick up two three and four and I\u0027m like what the hell happened to one then I can just commit one exactly and if you really want things to happen in a certain way you can commit them yourself why would you not want things to happen a certain way I mean so because it doesn\u0027t matter in that sense so what changes now is that you can group the proposals by category meaning you first deal with you removes because what that does it only blanks the leaf and the direct path for a certain member and so that destroys the tree to some extent and then once you\u0027ve done that you I don\u0027t remember you do the ads and then the updates or new updates in in removes and then adds well at the end of the day so what you do with the updates you only really now change the leaf node you don\u0027t do the direct path anymore so it doesn\u0027t have any effect on anybody else when you\u0027re trying to leave and and for deletes you just delete stuff the leaf and then whatever is above it and the same is for add and really only the commit is going to change any of the intermediary nodes okay but now I have it\u0027s a question which is say that I proposed one two three and four and Raffaele commits two and four and Colin chemist three and four so proposals are all are each proposals premise on a given epoch so they couldn\u0027t starting no I understand them I get I guess my so so what happens yeah I mean how do you know anybody can commit right it\u0027s part of your thesis right yeah and so what if two people try to commit there\u0027s a one wasn\u0027t the race there was the commits have the same ordering criterion as we had before so before we had this proposal this criterion that any group "
  },
  {
    "startTime": "00:16:00",
    "text": "operation any change to the group had to be sequenced so they\u0027ve got linear history here we have the same same requirement but it applies only to commit great so so why would someone else commit or not commit so you commit because you\u0027re required to before you send a message okay so all right yeah that answers it so you you\u0027re not allowed to send an application message if there are some pending proposals you have to commit first and so the whole idea here is that you don\u0027t have to do it immediately if there\u0027s nothing going on in the group so you can sort of pay the cost later the whole thing was driven by the problem that we had a bottleneck whenever in a multi-device scenario somebody would add a device to their account and all of a sudden they would have to do crypto in hundreds of groups most of which are effectively dead because people created them at some point and then they never use them again so it seemed very expensive to do some crypto in those groups so with this proposal commit scheme you can decide to do it later or not do it at all that\u0027s then up to the application to decide I mean this seems like a very worthy objective I\u0027m just trying to make sure it works you know I mean like I understand we\u0027re talking about and it seems like extremely like a really good idea to try to make that work um and I was just trying to make sure like I understand this updates of why it would work or not work yeah the minimum is you have to commit before you send messages I think there\u0027s probably going to be advantages to scheduling commits at an application layer for example when you add someone you probably want them to update and commit that update so that their paths the route gets populated and you have a fuller tree yeah Kevin from Google so this may have an auth assala G if you have receipts so if somebody sends a message and that proposal at the same time then ever and the group will try to receipt that message and so we get everyone trying to commit the same repulse at the same time I\u0027m not entirely sure to solve this here but it could this could be required for instance if sterling tries to remove themselves and set a message or something like that sorry qu state again what you think the challenges if like everyone tries to commit the propose at the same time could generate a ton of commits at the same time so it\u0027s hard to see yeah so there\u0027s and there\u0027s gonna be an inherent contention issue with this protocol just because we have common group state and so those contentions are gonna have to get resolved by the application somehow whether that\u0027s at commit time or before we before this PR we had that for any change you made to the group so yeah I think there\u0027s there\u0027s more work to be done in terms of figuring out how the scenarios with applications yeah and you know read receipts in multi packaging especially yeah Nick ordering is "
  },
  {
    "startTime": "00:19:00",
    "text": "generally a problem you haven\u0027t solved yet yeah and I think part of the the part of the reason this seemed appealing is because it punts the ordering to more infrequent events yeah yeah it solves a lot of problems this is an odd pathology that we essentially found we all come out from Lebanon I have a clarifying question is if the committer is the arbiter like the ordering is communicated through commit messages to other nodes is that correct that\u0027s correct so like how are like the like the proposal proposals are committed in communicated to other nodes in like another another form of message also correct yes so the presumption here is that the members of the group have received the proposals being committed and cash Evan okay and then the the commit includes kind of indexes into that cash okay and also like another comment about like ordering like the ordering problem I think it will still happen for the the ordering of the commits so I think this proposal in commit solves the ordering of the proposals but I think there\u0027s still the problem of ordering the commits between the other nodes yeah so no matter what we do here we\u0027re gonna have a problem either of ordering or of dealing with forked histories okay thank you yeah and we have a little bit of we touch briefly on forked histories in a little bit but that\u0027s generally generally we assume that things are kept pretty linear okay so you know not hearing any any like dramatic pain we\u0027re going to keep this in not gonna plan to revert that PR so there\u0027s a couple of nice implications fall out of that so one of the cool implications that falls out of proposals is that with proposals you can have multiple new clients added to a group in the same epoch which is one level a little challenging because you know before we each time you added someone you had to send them a welcome message so adding multiple people sounds like more work but because you\u0027re initiating all these people into the same epic that means now you can send them all pretty much the same thing there\u0027s like one secret that varies this path secret that varies per node but everything else that you\u0027re going to tell them about the group is going to be the same and so you can just send one thing encrypted under a common key the big thing is this group info that\u0027s gonna be the you know it\u0027s gonna have size on the scale of the the order the size of the group and then you send what we called a key package to each individual that client that\u0027s joined that lets them decrypt the the big encrypted thing so that that in itself is just kind of a nice little optimization but I think is is makes "
  },
  {
    "startTime": "00:22:00",
    "text": "this extra nice is that we had had before the separation between welcome message which add a single individual new participants of the group and in it messages where you would add multiple people to the group all at once to initialize your group I think what\u0027s nice about about this framework is that now this looks very much because this is designed to be sent to multiple people at once you have now made something that can be used both as a welcome message to welcome new members to a running group and something that can be used to welcome the initial set of participants to the group so there\u0027s much cleaner group creation algorithm in the document where you the creator makes a one member group of a very specific form we\u0027ve defined all the initial parameters the Creator then sends its effectively sends itself the add proposals to add the initial set of participants now obviously this can be done virtually an optimized doze and it\u0027s visibles the external world it but then commits that which is I think exactly the same computation entails exactly the same computations we were doing within it before but can be expressed more cleanly with this proposals language so once the sent once the creator has done has done those additions it can it gets out a new state for itself and a welcome message that it can send to all the new members at once it\u0027s the same message goes to everybody and they select the key packages belongs to them so we\u0027ve added a little bit of complexity here with this this kind of two-stage encryption but I think it\u0027s it\u0027s a net win in terms of complexity because we\u0027ve eliminated we\u0027ve gone from India in it and welcomed and down to one single thing and we\u0027ve cleaned up the the creation stage any questions comments about about this approach ok like I said considering its kind of last call for complaints another kind of neat implication about proposals and and Kevin your comment about self remove reminds me that\u0027s another thing so before any change to the group had to be proposed from inside of the group because a change to the group came within you know in case of updating remove who caused encryption of new entropy to the group and we didn\u0027t want to allow that from outside but right now proposals the stuff that goes in proposals that an ad proposal just says add this user is client init key I\u0027m just provides the client in Turkey there\u0027s no secret I change to the group you don\u0027t do anything secret with the group and so you send to commit so this means that people outside of the group are now capable of generating proposals that the group can can evaluate and decide whether to accept or not and the only question here is is how do you verify it and the what landed in the in the document is that we signal how you verify it by the the signer ID which is in most cases and index into the group but we\u0027ve reserved this chunk of very large numbers to address these special "
  },
  {
    "startTime": "00:25:01",
    "text": "cases so is there any reason to use this special numbers I\u0027m Calvin Berlin from Google he\u0027s a special others rather than just indicating via like I feel there\u0027s something that I\u0027m doing something for not in the group no reason except you know compactness and syntax if you had a separate field that would it would be there and it would cost you a few more bites but I don\u0027t think it\u0027s probably a huge consideration if you wanted to Jenna poppy artists to tease out this signaling I think we could probably do that yeah so I don\u0027t so I understood fffff etc that I get I don\u0027t quite understand this that preconfigured once yeah so the pre-configure ones the assumption is so that\u0027s designed for for like you have an application where there\u0027s some server and control and the the the clients are configured somehow out of bands and no to trust that server right and so the idea is that you have some table of you know 0 to 255 elements that map\u0027s sender IDs to the public user used to verify okay so I can\u0027t believe I\u0027m fighting this but that if you\u0027re gonna make a range for this let\u0027s pick a picker you\u0027ve got a lot of space we just make a generalize the sender identifier and we have to either have also be fine I\u0027m just saying like they you know yeah like you know you got you got to 32 bits you\u0027re like you\u0027re gonna hear me really sad when you want to under fifty seven and you\u0027re like well what the hell 5,000 or something I mean maybe you\u0027re pressing more pessimistic about the size of the groups we\u0027re gonna have here with we\u0027re not gonna be able to fit half of the world\u0027s population okay so I see your friend is back at me your point is we\u0027re gonna have like to 232 like the real problem is we got treated here too - like you know - these 5,000 and that\u0027s a little and that green sound we have another like 30,000 trees yeah that\u0027s like I\u0027m very futures bigger than the past [Laughter] yes I think I would tell you I sense a little proposal to clean up the signaling a little bit I think we\u0027d probably want to have kind of kind of abstract there kind of signer type so we have we would have within the group external like you know externally configured sign basically servers and then the joiner itself for this user initiated ad case now I mentioned this gets a yeah so this means I like the server can just sign as though it\u0027s beneath the client needs to know some sort of identity supposed to work and sign as well yeah that\u0027s the assumption yeah like I said the assumptions the clients are configured with some table that maps from these IDs to the public keys you used to verify yep oh now the bottom call out here mentions this gives us server it almost gives us survey initiated at this obviously gives it servi initiated remove because they serve it just proposes that our move into the group it doesn\u0027t quite give a server initiated add so it gives us the server\u0027s ability to propose the add that will then be "
  },
  {
    "startTime": "00:28:02",
    "text": "realized when someone in the group commits but in that interim the so that that that means because of this commit before send requirement that means that the new joiner will get any messages that are sent by existing participants before you know once they send them but the the new joiner can\u0027t immediately sends to the group so there\u0027s a missing send to group thing which I think Rafael is going to talk about in his slides later we kind of treated that as a separate sent a group from outside function how to do as a follow-on so yeah great so action item it\u0027s a Calvin here to propose the update there there was some concern that the in terms analysis getting away a little bit from the proposals stuff there\u0027s some concern at the interim about downgrade protection so Brendan had proposed that we simplify the client in turkey struts by having to be specific to a version and a cipher suite now the the the working model here is that client init keys are stored by some server and they\u0027re provided to a client when it wants to initiate a group and so there\u0027s this downgrade worry that you know if Rafael\u0027s client supports two really crappy legacy suites and two really awesome new Suites he\u0027ll provision for client Inuk keys and the server can choose to send me the old crappy legacy suites and prevent me from having a conversation with him using the new Suites so to address that we added extensions to client init keys this is something we kind of seemed like we needed anyway we\u0027re kind of following the TLS pattern here by having a client Keys Express what versions they support of the protocol and what cipher suites they support so the key that\u0027s in the client into key is still going to be specific to a cipher suite but the idea is that when you are creating a group you download a bunch of client init keys you see what what Suites you got and you can look at these supported cipher Suites right and verify that you know what you got was was the best thing that was supported I think I\u0027m maybe I\u0027m misunderstanding this design so the client each client idiot keys gonna duplicate all this information yes it duplicates the support information David Benjamin and mouse I mean why not just have one bond ball that has everything in it Brendan is on the Mike Brenda\u0027s in the in the media echo I think he had proposed this change I\u0027m forgetting exactly what the rationale was beyond just streamlining the objects family he remembers I think the idea is that you can rotate them if you put everything into one key and you have to throw away all the cipher suites even if you haven\u0027t consumed them in order to get fresh client init keys it\u0027s doable but it\u0027s it\u0027s voice not sure Impostors in that but I\u0027m happy to take a look think "
  },
  {
    "startTime": "00:31:02",
    "text": "about it later so I guess are so I think one me is the ideal I\u0027m supposed to what what so I\u0027m supposed to UM but the way I\u0027m consume this thing is like that I take the thing and then I like negotiate the best version and then I pull the key out right so what happens if what happens if MLS version you know MLS version one on the DA support post quantum and most version two does and I want post quantum so I pull it so I happen to hit the client and it key that doesn\u0027t that has X two five five nine nine but not post quantum in it and now I versed negotiate and now like I look at the key and I\u0027m like oops you\u0027re saying is potential conflict between the versions in Psych recession negotiations yeah whereas what was it was he had a little bundle then you could just sequential ordering one at a time in each and each each each decision you make narrows down the Romanian sessions so Brendan McMillan and the jabber says because there\u0027s a lot of keys then it\u0027ll be a big CI k imagine supporting ECC and RSA even if you use ECC you can always have to send RSA and everybody would have to store it yeah maybe okay I\u0027ll take I think you but if you need I think if the problem is you now need to explain how you now know explain how the negotiation works and why doesn\u0027t that prevent why isn\u0027t that a lot down great so in this particular matter in the case that just indicated right where um we have we have version one which only supports classical and version two which supports post quantum and classical right and so um and so the version negotiation is fine um but did but then the the server removes the so they both says front one and two and there\u0027s a there\u0027s two there\u0027s two CIA\u0027s one of which says one of the boys say one and two and one has it one has to $5.99 the other one has to have you know two 5 and X you know psych right and um and what I do is I remove the second one and so now I\u0027ve forced you here I have four through natira posture what\u0027s one possibility or I forced you into I\u0027ve still forced you back down a fascicle the classical right so so I so I\u0027m not entirely sure that so depending on how you define this so I\u0027m not sure the first unless for the error posture is acceptable and the second one is seems like it\u0027s downgrade so um so I think you have to think the first step is to write down what the algorithm you\u0027re supposed to execute is like that sounded like a downgrade attack in which case an error seems like the right outcome I mean maybe I mean I guess are the semantics that I mean but then you\u0027re placing into strong semantics and requiring all the CIA CA case you never got lost that\u0027s the posture you\u0027re saying CI case can never get lost that\u0027s the posture like that no subsetting is an attack I think that would be the implication is algorithm yeah okay I\u0027m not quite which n yeah I agree has interesting operations I\u0027m not quite sure what the resources being conserved here is because it seems like I stopped to download all the CI kids anyway maybe we should add that the term "
  },
  {
    "startTime": "00:34:04",
    "text": "downgrade protection is a little ambitious here this sort of helps to detect you know potential downgrade it doesn\u0027t guarantee that no downgrade can never occur Calvin so the set of support cipher suites and versions is more of a property of the client not really the property of the key so it\u0027s odd to see like they\u0027re supported cipher Suites be included in every single client in a key you get from that from that client would it make more sense to perhaps specify that you can specify your support versions for this to the client and key server and then you can just create what versions the client supports yeah we could we could split this out into a separate information element effectively yeah like it would have to be have to be signed by the client clearly so that it\u0027s authentic yeah yeah I think the I the idea here was we we had kind of had there\u0027s existing operational practice around managing these init keys you know and so this using the inner key as the struts to hold this stuff avoided creating another thing to manage mmm-hmm but if it\u0027s big enough problem we can we can obviously they add a new struct yeah I thought I agree that it\u0027s a little awkward Jim you didn\u0027t hear it\u0027s also awkward to see a required extension that like my otherwise we\u0027ll just put in the main message then why happy extension yeah don\u0027t have real strong feelings about that I think my feeling here is we so this this expiration thing is an example I think the feeling was we\u0027re going to have a need for things that are optional and and so many for extensibility here and so these are things that are extensions in TLS and so might as well exercise the the extensibility mechanism that we\u0027re going to need anyway sounds good yeah yeah so since I mentioned expiration right another thing you could do - it\u0027s a kind of Tetris point is if you\u0027ve got a client that supports you know crappy sweets and they upgrade to support awesome sweets and publish new client init keys one thing the server could do is just ignore the new ones and keep around the old ones and give everyone the old keys and only enforce force you to only use the legacy Suites so you know in addition to other concerns about rotating engineering freshness and rotate inclined into keys on this expiration is just like super simple UN 32 or UN 64 a second since that box sort of things specify expiry so I think actually what Rafael said was like pretty important hum which is like defining what this is supposed to do we really helpful I mean so if you recall like we spent quite a while in TLS and "
  },
  {
    "startTime": "00:37:04",
    "text": "there\u0027s like an enormous appendix that it\u0027s like allegedly tells you what let\u0027s the security here and his ETL are supposed to be and so seems like maybe we should start by defining let\u0027s you\u0027re gonna this are supposed to be and then we\u0027ll know if it achieves not yeah and since produce is not here I will propose that he write that section um sure if you want to assign me to that I\u0027ll try to give it a shot okay great thanks Nadine you just proposed already I propose produce right oh I seem fantastic like I\u0027m happen happy if you think I should have happy to give it a shot I don\u0027t think a party best person I since since you\u0027re thinking about it now like if you wanted to jot down like a list of properties that that you think sounds like about the right pop set and you know we could we could iterate on that that would be helpful if you could send that\u0027s yeah I I could do that if you don\u0027t mind it just to keep down my list if you don\u0027t mind assigning me they get a bishop can chairs shares some combination shares and no takers make sure that we get our answer that okay thanks cool all right so that\u0027s extensibility what next okay so we landed a whole bunch of things last week published a draft what Monday and we had some trouble with the draft tracker deadline and on the flight over here I tried to implement it and I came across some bugs well this was actually just an improvement so one of the things in the version of the welcomes in draft eight since we have this separated encryption thing the keys that were used to encrypt the group info were just generated by the the sender of it which was kind of unfortunate in terms in the in that it requires the sender did you have fresh entropy and you\u0027re assuming that the key generation goes okay it occurred to me that because we are in an epoch already we can just ktf more stuff off the epic secret and use that for encrypting welcome messages it keeps things a little bit more chromatic the other thing is in the handshake messages in the commit messages we have this confirmation we\u0027ve had it in group operations before which members of existing members of a group used to confirm they\u0027ve all arrived at the same state as a result of processing this group operation or commit message this is analogous to the finished Mac in TLS that confirms the to two and saw the same transcript that it it turns out we have all the material in the Welcome message that a that the new joiner would need to be able to compute that confirmation so we might as well as my thinking here as he might as well throw it in the welcome message so that the recipient the new joiner after it\u0027s you know imported all this stuff and vera and done some of the key derivations can verify that it has arrived at the same state as at least the sender of the message you won\u0027t know that it\u0027s the same state as the rest of the group but it will get kind of a an internal consistency check on it that it is correctly processed the welcome message so I don\u0027t think we really get any "
  },
  {
    "startTime": "00:40:04",
    "text": "meaningful security properties out of this but it seems like a useful you know sanity check probably you know a way of way of avoiding bugs in implementation with with fairly low cost so there\u0027s a PR for this I think it\u0027s fairly small change kind of inclined to land it as as a way to make things little bit more internally and a little bit more rigid says minor stuff no comments the other thing is proposal IDs as in draft eight don\u0027t actually work so as we just said before the commits we have have to have pointers to which proposals they\u0027re implementing one of the changes we made in the proposals PR fairly late in the game was to make the proposed the the hash and proposal ID the hash of the MLS plain text that contains the proposal and then I landed a PR after that that an enabled MLS plain text contain multiple proposals so now we have this ambiguity of which of these proposals does this refer to this is kind of an instance of a slightly more general problem so so Calvin and Nomad pointed this out that we we have right now this packing of multiple proposals and it commits into a single MLS plain text which introduces this ambiguity about how you refer to proposals and you know it introduces a little bit of complexity into the the processing and key selection etc so there\u0027s there\u0027s kind of general question of like how do we pack things in some MLS plain texts so the trade-off here is on the one hand if we pack stuff in as we do as as we kind of do now is you could do slightly more generically then you can use a single signature operation to cover a bunch of stuff so if I\u0027m adding 20 new people to the group and sending five messages alongside them I can sign all of that stuff together at once and not have to do 25 signatures so that\u0027s you know some computation savings but on the other hand if I do all that packing then my unpacking code gets a lot more complex and we have this question that was raised that I think it matter ace one wants me about whether we well if you\u0027re going to do key separation you have to you know change which key is based on what is encrypted in the message whether it\u0027s a handshake message like a commit our proposal or whether it\u0027s application content if you\u0027re not going to do that key switching then you have this question of whether you\u0027ve lost something in terms of key separation so wanted to open this question up actually for discussion as people whether have other people have feelings about which of these should be a priority in terms of you know advertising signatures or maintaining a stronger key separation obviously the kind of simplest with simplest solution "
  },
  {
    "startTime": "00:43:04",
    "text": "with highest you know easy a clearance key separation would be this this middle proposal where each MLS plain text contains exactly one thing it either contains a single application message a single proposal or a single commit so you have a clear semantics for what each and well as plain text is and you have a you know that kind of unit there but that means you have to do a separate signature for each of those which you don\u0027t if you do this kind of packing thing so like people have thoughts on trade-offs here all right Calvin I see you kind of gesturing I guess slightly leaning towards just the simple solution just one entry for everything because I will just keep it simple I cannot really show the implication of using separate keys are for a different but same key for a signature for four different plain text feels weird yeah slight slight thing I like generic framing also it looks sort of nice I don\u0027t everything in either way yeah I think I agree that the current frame was that Jonathan yeah okay basically like I don\u0027t really have a game either way like one entry seems slightly nicer because it keeps the code simple and you don\u0027t actually know how much like I don\u0027t have a good idea how much does he get your actually costs on those claims yeah III agree that the current proposed the current solution is kind of pessimal in that it is like neither clear nor nor simple so I think unless people objections those people are worried about doing bazillions of signatures I think I kind of agree with Calvin that the single single entry one is going to be simpler to reason about and we can do that for now and if it gets to be a computational burden later we can look into optimizing that you know generally seem plausible to people seeing a couple nods yeah okay all right cool another thing I tried to slip in right before the deadline I thought I was gonna get agreement for my co-authors and it turns out we didn\u0027t agree was this question of making epochs unpredictable so right now and the epic which identifies you know all your crypto state in MLS yeah epic is just a counter you know you started epoch 0 the next a POC is 1 the next step after that is 2 and you go straight forward and you have to have linear history as a result because you have no way to refer if no way to identify to a different Forks if you have them this forking property it turns out is important for some applications so this the matrix protocol which has been looking at integrating MLS is operates in a fairly highly decentralized mode and so they have common Forks and merges of history I\u0027m not proposing to adjust the merge question which is much more complicated but fork the only barriers are doing the fork half of that now is this epic question so the idea here would be to just make the epic something "
  },
  {
    "startTime": "00:46:05",
    "text": "unpredictable so it still needs to be a unique identifier for for the the state of the group over time but instead of assuring that by having a linear counter we would assure it you know sort of stochastically I mean generate some you derive some value off the key schedule that would become your become the identifier for the app hoc Raffaele you want I think you had the concerns about this yeah I did have some concerns I wasn\u0027t quite sure if the server could actually do its job of enforcing the ordering of commit messages I don\u0027t have a strong argument right now and this might just work but I to be honest I have to think about it some more okay and so to be clear about why I think that\u0027s not a problem um the rule the server needs to commit to enforce is that there are no two commits on the same so if the server is going to enforce linear history we\u0027re not tolerate Forks then what the server needs to enforce is there are no two commits on the same epoch and the the outside of the envelope of the mmo\u0027s ciphertext will state what the epi\u0027 what epoch this is premise taun and so the server can see even if that\u0027s a random Epoque there are no two that are identical so I think the Jonathon like so I think the more yeah well I I seems to me that like it\u0027s pretty likely you could still maintain that still do that John John Clinic\u0027s I mean with only 32 bits you will get collisions occasionally do you have a procedure for that well so that\u0027s kind of the question I\u0027ve Illustrated 32 bits here you could obviously make them 32 bytes I think immediately after I posted this Brendan and it submitted a comment on the Tiaras like stop truncating hashes so I I\u0027m inclined to truncate a little bit here just because this is gonna be send in every message and it seems kind of blow to you to send a 32 by - in every message but I agree that we do need to have have it be large enough to so make collisions pretty rare I\u0027m not super worried about collisions because the space of collisions is not every epoch ever I think in practice you\u0027re going to be worried about collisions in the the set of states that clients have around you\u0027re going to want to delete State for forward secrecy and so clients might have a handful of states around in cash and it\u0027s only if you have a collision in that you know recent history that there\u0027s an issue so like maybe it\u0027s not that big an issue [Music] Jonathan moon cobbler if you did have a "
  },
  {
    "startTime": "00:49:07",
    "text": "collision of two blocks they were very close to each other is there some way you expects clients to be able to recover or is just like the whole group burned haven\u0027t gotten there yet I think that would actually be pretty bad yeah and that\u0027s why I was also concerned about the collision thing because you if you derive this epic ID from the key schedule unless you get some new freshness in two key schedules then it is a problem I mean you could detect that on the client side as you generate the new app book you could see oh this looks like the old one I better do a new commit I mean you could just add freshness like when you commit you have to insert a nonce in to kick nhk lyrics tracks and the news eh KDF expander like generate your batch of comments yeah now that I said I think you always have some new freshness in a commit message anyway because at the very least you do an update of your own leave key message and I mean do we also need to worry about if you\u0027ve got fresh is coming in too we need to worry about some malicious group member searching for very quickly through through the first two bit key space and saying here\u0027s another commit that has the same ash and trying to fork the state without anyone noticing that the state has been forked because they both have the same sort of a server should catch that I mean the server should see that there is a collision so we must decentralized apps here supporting decentralized apps okay then I don\u0027t know how that would work yeah so this fair question I think I\u0027m not too worried about people trying to effectively reverse the epic ID any kind of brute force to achieve specific values because each each attempts at one of those or requires several public key operations so it\u0027s it\u0027s fairly expensive to generate a fresh guess at an epic ID if it\u0027s if it\u0027s generated like this so you just you just have to worry about the entire state being destroyed by somebody finding one by accident yeah I think so which I mean it seems like if you use enough bits it can be extraordinary so I think we can probably continue to go a couple rounds on this on the list on this but I think I\u0027m that inclined to take the risk and you know we can have some discussion about how to write down the security properties around this on the list alright so Raphael I think you\u0027re up now "
  },
  {
    "startTime": "00:52:22",
    "text": "yeah I wanted to give a brief overview of the open questions we still have after draft eight that we have to address in the next weeks and months and there is a so this three of them that are really worth looking into so the first one is a relatively big one and so this is an extension to tree cam that has been proposed by a number of people row Alessandro Evgeny and Yanis and I published a paper if you click on that URL once the slides are published you can read the whole paper so I\u0027m not intimately familiar with how it works exactly and so what you\u0027re about to see is probably just a gross oversimplification of how it works so the assumption is that the threat model that is being considered for archery chemists lightly different from the one from tree chem so there is nothing new to see here this is essentially what tree chem is addressing in terms of threat modeling so if you assume that Alice gets compromised at some point by having all of her local state being copied to the attacker essentially the attacker can impersonate Alice up until the point that Alice does an update and therefore successfully evicts the attacker if the attacker doesn\u0027t have any access to and storage anymore Alice will have introduced some freshness with the update and that excludes the attacker from being part of the group and so this is what we call post compromised security and before the point of the attack we have forward security and that simply means that the attacker cannot get their hands on key material that would be useful to decrypt things that were sent before the time of the attack so in our tree cam the threat model is a little larger in the sense that the assumption is that an attacker can potentially compromise more than one member since in M\u0026S everything is about a group it makes sense to think about these more complex models as well so if we have the same scenario in the beginning where Alice gets compromised at first and later she\u0027s going to send the same update but at a much later "
  },
  {
    "startTime": "00:55:22",
    "text": "point in time Bob which is an arbitrary other member in the group gets compromised as well so in the worst case scenario where we would assume that bob has been a passive member meaning that bob has been consuming messages sent to the group but has never issued any update on his own in that particular case compromising Bob will dramatically increase the size of the window of compromise and so the reason for that is that when alice issues an update she\u0027s going to cam some secret to one of the nodes in Bob\u0027s direct path in the worst case their siblings and then she\u0027s going to commit to Bob directly and if bob has not issued an update in in all that time that means that the Bob still has the keys stored locally in his local storage to decrypt that CEM to update from Alice so that means that when Bob gets compromised we can sort of recover the freshness that L is introduced and since the attacker had everything before Alice introduced that freshness the attacker now has absolutely everything from the point where Alice got compromised to the point where Bob gets compromised so this looks pretty dramatic but I wanna emphasize that this is the absolute worst case and this is not a not guaranteed to work all the time so even if Bob doesn\u0027t update if Alice and Bob are are sufficiently far away from each other in in the binary tree then it\u0027s very likely that those values will have been overwritten by somebody else\u0027s update this is just to illustrate how compromising to separate members can give you more than just the sum of those two windows of compromised so yeah this is what I already said actually and these are the the ingredients for the worst case scenario basically Alice and Bob are siblings are very close to each other and the tree Alice gets compromised very early on Bob is a passive member and only gets compromised towards the the end of the lifetime of the group or at the very least at a much later point of time so this leads to a scenario where at the very least the confidentiality of the group is broken and so there\u0027s been some dispute whether this is now forward "
  },
  {
    "startTime": "00:58:22",
    "text": "secrecy or post compromised security that is broken I\u0027ve heard the term peace EFS post compromised forward secrecy it actually doesn\u0027t matter what we call it and the confidentiality is broken for quite a bit if if we run into this worst case on average the window of compromise gets a little bigger if you consider the attacker to be able to attack more than one member but it doesn\u0027t dramatically increase necessarily and also it\u0027s very important is the assumption here that Bob is a passive member normally Bob should not be a passive member everybody should issue updates once in a while in small groups that works really well the problem is in really large groups if everybody say you have a group of ten thousand members if everybody issues an update once a day that\u0027s a lot of updates to process for other members it\u0027s just some crypto to do in the background it doesn\u0027t give you anything other than security properties so the the assumption here is that in larger groups it might just be the case that applications decide not to issue as many updates anymore since it\u0027s not mandated to issue updates regularly with MLS it\u0027s up to the application to decide when to issue them and what people tend to go for whatever is cheapest in terms of computation and effort and payload so the assumption is they won\u0027t be a place all the time so mm-hmm how does archery cam work the idea behind is that we can do diffie-hellman with some deltas that scheme I think is called upk II so imagine that Alice has a key pair a secret and a public one and now Bob chooses a delta and encrypts this Delta under the public key of Alice and sends it to Alice what Bob can I do with you PKE it\u0027s some sort of homomorphic property where Bob can calculate a new public key that is essentially the the secret key plus the Delta and advertise that without needing any response from Alice and Alice can do the same on her side so in practice what that means so this is a tree where the rightmost leaf does an update and the green you can see the color as well so "
  },
  {
    "startTime": "01:01:23",
    "text": "the the green plus is here just indicate that there is some new freshness on the direct path all the way to the root and and that\u0027s how it is today with MLS with our tree can we get some additional freshness on the co path on which is the the siblings of the direct path nodes so you have the blue pluses here that now also get some freshness so and this is important because these are the nodes that the the the green freshness is being kem to so as a passive member if you consume that you\u0027re going to throw away whatever old values you had in there before so try to come up with a list of pros and cons obviously it does make sense to think about an extended threat model because we talk about groups things are being improved if members are passive but we also need to be very clear that this is not an incentive for members to be passive because if you\u0027re passive you still don\u0027t have any pcs if you get compromised so you still should do updates this doesn\u0027t avoid that scenario at all it comes with a little overhead that seems to harbor but it\u0027s still an overhead and so last night the question was brought up how this compares to other messaging protocols actually and it\u0027s kind of hard to compare because we we think in terms of groups now and and there aren\u0027t that many other protocols that take care of groups so send your keys for example it doesn\u0027t even compare because Center Keys doesn\u0027t have any sort of post compromised security if you get compromised as a member with Center Keys then you are not going to recover from that at all actually until you start generating some new freshness which normally you only do when somebody got evicted from the group so that might be a long time or never actually and with pairwise encryption like with playing signal protocol for example again there is no notion of groups so groups are done in a way that you have this n minus 1 legs between you and the rest of the groups and these sessions these individual sessions are not cryptographically correlated at all so if you attack several members in a group then you cannot immediately combine these windows of compromise because things are completely distinct however it might be the case that these one-to-one connections are also passive so signal gives you first come security if you dude if you Hammond "
  },
  {
    "startTime": "01:04:24",
    "text": "ratcheting on these sessions but if you mention that two members are part of the same group and but don\u0027t exchange anything between each other ever it could very well be that one of them is absolutely passive if they\u0027re not connected otherwise and exchanged messages so this might still work very well in signal groups as well so bottom line is it\u0027s hard to compare and it\u0027s it\u0027s not better or worse than others um it just works differently so on the list of cons that one\u0027s a little longer so first of all you pke is not standard cryptography so we are talking about the multiplication of two private keys here so this is something relatively new that has not been studied in academia a lot it\u0027s not nothing complicated it\u0027s it\u0027s not very hard to analyze either but it\u0027s it\u0027s new so if you\u0027re wondering whether it\u0027s a mustache here some people have out all this hipster crypto because it\u0027s new and hip but we don\u0027t know if it\u0027s fit for purpose and in the particular case of curve 25 519 there are some concerns about the security level because private keys are clamped and then you would count them before you multiply them and then the question is what you your security level is afterwards and a very practical consideration is that none of the standard crypto libraries would support this so you would have to essentially roll your own in addition to whatever crypto library you\u0027re using so it\u0027s especially bad with web crypto because then you don\u0027t have any support whatsoever I don\u0027t I\u0027m not even sure you can manipulate private keys with web crypto easily so in for an idea of standard this is quite a concern actually that it\u0027s not quite clear to implementers have what you do here and I mentioned that already there is an increase in the payload it seems terrible but it\u0027s still an increase so this is still an open question there\u0027s been quite a bit of discussion on the mailing list and the the practical problem here is simply time so if this is something we want to adopt this is going to be an issue timewise and by time you mean working through getting the analysis and getting it into the libraries and stuff okay exactly yes Richard you had something yeah I was just going to inject my analysis and opinion here I think you\u0027re pros and cons list about right I\u0027m not sure this would result in increased payload size I think you could you made you to be able to get away with deriving some extra stuff and folding that in but again that "
  },
  {
    "startTime": "01:07:24",
    "text": "would require more analysis my general inclination here is to punt on this for now and not add it to the spec probably in in in the initial version we do I think this might be doable as an extension or as a v1 I\u0027m thinking about some of the extensions made the tea laws between proposed since he lost one not three to kind of update the key schedule with new stuff I think you could envision this as an analogous extension to MLS if you know once we finish the initial version and assuming the the relevant you know prerequisites firm up I\u0027m I think I am I think the the the hipster crypto aspect of this is concerning for me like I don\u0027t think we have a firm enough grasp on what this update operation entails and what the bounds are on its usability especially in the in the curve t 509 incur four four eight case I\u0027m pleased that the the proposers here haven\u0027t actually worked out how did it do it like when we first look at this it wasn\u0027t clear that it was even possible to do updating like this on on two five five one nine and four four eight we have Nelson as and proof that it is in fact possible with a couple of caveats but I don\u0027t feel like we have a strong enough understanding of what the implications of that are to be comfortable adding this to the spec so so my proposal is we cut basically to punt on this for now okay any other questions just to conclude I like I I do think that the it what it provides is valuable I think the increase for PC FS as its called it is a valuable extra property but I don\u0027t think it\u0027s one we can\u0027t live without I feel comfortable punting yeah I tend to agree with that I mean it\u0027s not like MLS is catastrophic ly bad without that it\u0027s so very good but um this would make it a little better we just have to be very careful not to introduce any new risks because of the new crypto I mean so the idea is it like if this is good and better and we could get it in v2 right with the idea be that we would kick all this other process off to get this reviewed and put in other libraries to get ready to use for v2 or do you think it would just kind of stop no I mean that could be ongoing work okay depends on how dedicated people are any other questions comments so I\u0027m gonna jump to another subject this one\u0027s going to be very brief we talked about that in the past and I just wanted to give you a little overview of where we stand which is pretty much still in the same place as last time so when you add a new member to a group whether that is actually a "
  },
  {
    "startTime": "01:10:25",
    "text": "new user or a new client you have to transfer some state some of it is secret and and that goes into the Welcome message and some of it is the the public keys in the tree which are not particularly secret because they\u0027re public keys and finally also the the roster meaning the the list of members in a group so we have ways of doing it fundamentally one is the one that is in the protocol right now and that is client to client meaning everything goes into the welcome message it\u0027s enter an encrypted so it\u0027s secure and private you cannot really look into it the problem is it doesn\u0027t scare very well so if you have a very large group you get a huge welcome message and also if you are a member of many groups and then you add a device then you need to transfer the state for those many groups to the new device so this is also a scalability problem so very early on one of the intuitions was that we need the server to assist with that somehow and one way of doing it of course is to store the public keys of the tree on the server and also to store the the roster on the server meaning who was a member of the group so the public keys of the trees probably not too bad is it just public user and say a lot such I mean they don\u0027t really help identifying people etc they could maybe be used for some more elaborate attacks having the roster on the server is not great on the other hand it\u0027s a privacy concern so this is obviously the the worst solution in terms of privacy and so ever since the idea was born that maybe we can encrypt this stuff as well and so this is something where you want to look into in the next weeks and months because we don\u0027t have a very good proposal for that yet so we are talking about metadata encryption so if it doesn\u0027t have all the security properties that we apply to messages for example that might be fine but but we need some good initial proposal so this is still an open question as such so I guess you\u0027re being really nice I\u0027ll try to make this a little more pointed is there anybody that wants to stand up and talk first doing client-to-client for this because i mean it works well in small environments but some of the environment we\u0027re talking about are like 10,000 so this is Richard wood I\u0027m standing up "
  },
  {
    "startTime": "01:13:29",
    "text": "because the you know logistically simplest and what I think probably merits running to ground is whether there\u0027s with the recent so especially with the recent simplifications to welcome message where you\u0027re sending one large thing to welcome everybody I\u0027m not sure that seems pretty close to like the theoretical lower bound on how much data you\u0027d have to send so I I\u0027m fine to investigating some alternative strategies here but I wonder if there\u0027s there\u0027s actually much to be gained here well I\u0027m hoping that we can go from three to at least two because I think D is just I think two is like a non-starter so if anybody wants to get up and start talking about that one well they don\u0027t get interesting let\u0027s call them one one use case that was pretty useful transferring states Windows client loses a stay and sort of starts failing to decrypt stuff and so get that like the current solution just remove an ad that feels kinda like you could just get the state back somehow better it would be nice yeah I mean you just address another problem actually I\u0027m kind of losing states so at the very least they\u0027d they have to get the state back yeah yeah so I think maybe that revised my previous remarks I think maybe this is not exactly the right access to slice this on like you\u0027re gonna have to have the initiating or you\u0027re gonna have clients upload something that this you know that the server holds on to and redistributes I think so we should I think the question we need to investigate here is like what does the client need to update and under what circumstances and what the server needs all wants you I think that kind of covers all three of these cases and we can answer those questions so yeah yeah I mean that\u0027s correct I mean transferring means the kind is uploading it to a server most likely because we\u0027re not in a peer-to-peer scenario necessarily and and then another client downloading it so the the idea for services is that the uploading still happens but it happens ahead of time alongside other messages so that when we\u0027re in the scenario where a client needs to download everything that clan can do that without having to wait for another client to upload something first all right no further questions Richard already mentioned it earlier on this has been a long-standing idea to send things to a group from an external party so the external party the assumption here of course is that that party doesn\u0027t have access to any of the group secrets yet can still encrypt in a way that only members of the group can then decrypt it so there are some different use cases for that just to motivate the idea as such for example the server can encrypt things like status messages that are application specific to the group and that way those messages don\u0027t have to "
  },
  {
    "startTime": "01:16:32",
    "text": "stay on the server unencrypted until they\u0027re consumed so in that case it\u0027s more like meta data protection essentially another use case that I think is going to be very important and that is when external users are being invited to the group Richard mentioned it already that this might be a proposal from the server for example and that proposal has not yet been committed yet the invitation is already sent out so the the new user or the new client thinks that there will soon be part of the group they don\u0027t have they don\u0027t receive any messages because there\u0027s no activity in the group but maybe they would like to send some messages already and then they could do that with that mechanism yeah there\u0027s a question so there\u0027s Calvin just two things here if two users so one of those cases here is the for external user hasn\u0027t yet joined the group he also has the group so this is means they can send and receive commits but they won\u0027t PLC received messages from another user in the same state as another user who hasn\u0027t yet joined the group so if two people try to join the group they\u0027re not quite added yet and they both send messages the okiya each other\u0027s messages uh yeah that\u0027s a very good poncho and secondly if a user is proposed to be removed but hasn\u0027t been removed yet they\u0027ll be like get these messages as well sorry can you repeat that last one if the users been proposed to be removed but that remove hasn\u0027t been committed yet they\u0027ll be able to get these external messages as well because this if these extra users not gonna commit the remove before sending a message yeah I think so I think the user would still get those but I mean the user doesn\u0027t appear as being removed yet at least to the external user yes so I mean maybe know what you want but at least it would be transparent yeah but it\u0027s a very good point yeah we can obviously come up with some more rules around that this is a relatively simple approach for now and another use case would be handshake messages so when the server does a proposal for an add or remove we can simply also just encrypt that to the group again this is in the context of protecting that that metadata essentially and then of course we are depended at the fact that whether or not a commit will be consumed or accepted sorry whether proposals will make it into the the commit that will depend on the particular policy that the application will apply "
  },
  {
    "startTime": "01:19:35",
    "text": "so in practical terms this is certainly not the final version but just to give you an idea in the key schedule we can simply derive a secret sent from outside secret and we can take that secret to generate or to derive a key pair and then we can just use HQ ke with that so on the last struct we have an ephemeral hpk public key that is used and then the message is simply just encrypted as an h PK ciphertext so note that there is no authentication here so this is a an open question as well whether or in what way we want this to be authenticated because obviously if a member of the group receives that they don\u0027t know who who sent it it could be anyone so yeah that is an open question if it is an external user for example that is about to become a real member then we actually have some identity key material that we could use for a signature if it is something that it\u0027s sent by the server then we might not have that because the server is not signing stuff so the most general case here for me would be to say this should be some sort of more proprietary format inside the cipher text richer bars again so I think the first chunk of this is totally sensible I think yes so the first two chunks deriving something that\u0027s the key scheduling then deriving keep her off that obvious I think you have actually two authentication problems not just one you have the problem of authenticating who is sending to the group but you also have the authentic the problem authenticating whether a key belongs to a group for the sender now I think that\u0027s probably not an issue that we\u0027re gonna solve in the protocol I think that\u0027s probably something to cover in the architecture that\u0027s yeah basically is an additional function of the authentication services we call deposited an authentication service that vouches for bindings between user identities and public keys I think what is needed to make this really hold together is an additional function on that identification service to vouch for bindings between group identities and public keys so I think we just need to describe that in order to have that full story there as far as the sender authentication I my inclination here would be to reuse the MLS plaintext structure and so you would have a signed message with same sort of contents of your application messages or proposals "
  },
  {
    "startTime": "01:22:36",
    "text": "and basically treat this as I think if you do that all you really have to do is provide a credential alongside that in the wrapping so you\u0027d have kind of an alternative MLS ciphertext thing so right now I\u0027m lost I protect I\u0027m symmetric encrypted MLS plaintext so you\u0027d have like MLS a symmetric cipher text or something like that where you would have as you have here the hbk a cipher text but probably also the credential that goes with that and so that you can so that the members of the group can verify from whom this message was sent right yeah so to address the two things you said with the authentication of the group towards the external sender that\u0027s a very interesting question and we have to see what what sort of guarantees we can give there because obviously the external party doesn\u0027t know anything about the group and we\u0027ll get that from a party that is mostly untrusted probably the server so we have to see what meaningful guarantees we can have that are immediately applicable and not only in hindsight once a member has actually drawn the group because that mattress be too light and the other one regarding the signature yeah I thought about that as well so obviously we don\u0027t want to have the signature out in the clear we want to that should be part of some ciphertext or insert some ciphertext the other thing is that the signature might just be optional simply because there there are scenarios were you don\u0027t want that because your server doesn\u0027t sign stuff we could make that mandatory of course but so in that case what I\u0027m concerned about in the case of when you say server doesn\u0027t sign stuff is when the group receives a proposal to say add someone that purports to be from the server how do they verify that they should accept that proposal yeah I mean that is an open question how you generally deal with proposals coming from the server they could be signed but I mean the signing key lives on the server as well so um I agree with you that that it doesn\u0027t sound good but when things are not signed particularly in the contexts of an remove so let me ask maybe ask the question a little differently um do you think that requiring servers to sign proposals into the group would cause operational problems or deployment problems or do you think we might just not quite get the properties you would expect out of it no no it\u0027s only for practical reasons but I mean you might be right maybe we should just enforce that it\u0027s not so complicated to generate some key material the only thing is that we need to make sure that clients actually trust "
  },
  {
    "startTime": "01:25:37",
    "text": "that so we run into the typical certificate problems there yeah I actually think this cleans up the problem that Calvin noted with the current hacky system of signaling you know reserving some code points and signaling external stuff that way because if the message from outside contains a credential and is signed now you don\u0027t have to pre configure all of the public keys into the clients you can configure some identity authorities key and configure the clients to trust servers the certificates issued by that I don\u0027t need so it makes the signaling a lot cleaner it\u0027s probably the way to go you know but those modifications I think this is a good thing to do oh yeah I know and one thing I think Benjamin mentioned it last night regarding the derivation of the key pair potentially we could derive more than one key pair for a given netbook I\u0027m not entirely sure what that solves but um it\u0027s definitely a possibility and in the same way we do it with the exporter for the key schedule yeah I think that was the last slide any more questions thank you I have one more question are you are you gonna make a PR for this I knew you\u0027re gonna ask us of course I am Benjamin BER douche Oh can I get a line here yeah so this is a couple more future issues that Benjamin and I have been noodling on with so gonna try and outline issues here maybe there\u0027s like a expand fill screen yeah that one it\u0027s the opposite of what I expected so a couple of things that we have some of which we\u0027ve got pr\u0027s on can try and outline the proposals and get any feedback on solutions here so first thing is this MLS exporter thing those of you who have worked with TLS in the past know that it has an exporter function so you can export keys out of it and layer things on top I think you know the core of MLS is really the key exchange we have a way of framing and sending application data messages but I think it was always been pretty well understood that in a lot of cases you\u0027re going to want to export keys and use them for some non MLS applications so all this says is much like in TLS you "
  },
  {
    "startTime": "01:28:37",
    "text": "take your epic secret there\u0027s an epilogue secret at the top of this chain here and in addition to directing your application secrets your confirmation mat key you derive an exporter secret that you\u0027re going to use for exporting yeah similar can this this PR is basically just a copy and paste from TLS so it\u0027s same you export your root exporter secret and then you explore specific secrets off of it Thank You Jonathan I was waiting for you to get up Jonathan Norland CloudFlare so if you want to have exporter secrets and also to be in line with RFC 50:56 which says if you have exported secrets you must have imports secrets then you should also have imports secrets I have that in a couple slides so stay close to the mic so that\u0027s the exporter stuff it\u0027s probably just gonna be pretty straightforward copy-paste from TLS that\u0027ll probably Lane pretty soon any other comments on exporters anyone who loves exporters I think this is critical yeah that\u0027s that\u0027s more like it okay good so we\u0027re gonna do this so this is a little bit more complicated um this and this kind of gets the security properties we get out of the protocol so um Karthik bhargavan and and Benjamin produce have been looking at you know developing proofs of the security properties of this overall protocol and one of the questions is what assurances does a new member of the group get when he joins right now the new member all the new member gets when he joins is a welcome message signed by the person who is adding him to the group that says behold here is the state of the group and there\u0027s credentials in the leaves of the tree that that adder provides that say who occupies each of those leaves in the tree but there\u0027s no signatures to say that the corresponding hbk he public keys actually belong to those users or that any of the intermediate keys in the tree belong to the users below them in the tree so whoever adds you to a group can completely lie to you about who is in the group and you have no way to check that that you\u0027ve been lied to so the in order to counter this you need to have some assurance that the keys and the tree actually follow this tree invariants that we\u0027ve been talking about that the private key for a node in the tree is known only to the nodes below it and the approach that the Benjamin and Karthik have come up with is to have add some signatures to the tree so the idea is that whenever you do an update let\u0027s say I\u0027ve got some figures here whenever you do an update you sign the nodes that you\u0027re updating in the tree so when you\u0027re updating you always provide new "
  },
  {
    "startTime": "01:31:38",
    "text": "values for the nodes above you in the tree so the proposal here is basically to augment that update and the resulting tree data structures to have those signatures over the nodes you are updating um so there\u0027s a couple ways you can imagine going about doing this this is a you know this presentation the heist I presume a tree so here we are presenting a six member group where the members are in the leaves and everyone has updated in left-to-right order so you can see a updated and reset all those things on its direct path and be updated and over wrote that parent node etc all the way to the right so this is how it works now we we don\u0027t have any any signatures here these are just public keys in these nodes so one way you could go about implementing this is I should have used colors or letters or something on these but one way you could implement this is to attach signatures to each node so I guess the way to interpret this is that the the gold circle on each of these means that the there\u0027s a signature there over the public key in the node by the letter holder so D double prime there is signed by D so everything was signed by the last member that changed that node so option number one carry the reassign the node every time you change it option number two is kind of syntactically different the idea here is when you issue an update you update your leaf with a list of the nodes you changed and you sign that leaf so your you know D when they updated they updated nodes D D prime D double Prime and D triple prime now you notice that the triple prime which was at the root got overwritten so that\u0027s kind of a useless hash on that will never get used to verify but you in case your algorithm here is when you\u0027re checking whether a given node is valid instead of Tec verifying a signature on that node by one of its children you check that it is in the signed lists of one of its children it\u0027s the same cryptographic assurances out of this it\u0027s just a direct signature on the node versus a signature over a list including the node it\u0027s kind of a manifest approach the idea of doing that is that you trade off message size for signing operations so if you\u0027re going to sign all the nodes means whenever you do an update in addition to doing log tree operation d-h operations yes if you log signatures as well but you know the benefit is that you only have a signature per node in the tree lot to keep track of if you do the signature on leaves thing you only have one signature you just sign the leaf but then you have to carry around in log in hash values yeah Jonathan likes yeah I think I don\u0027t understand the threat model because it seems like if the person adding you to the group is malicious what stops them from basically "
  },
  {
    "startTime": "01:34:40",
    "text": "impersonating the entire group you know its Annabelle M for murder attack everybody you\u0027re talking to is actually the attacker so we have some protection against that in that we have and I\u0027ll presume an authentication service that provides credentials so there there is at base some presumption that you know I can\u0027t omit I can\u0027t imitate Jonathan at gmail.com because there\u0027s an authentication service the blocks emerge from doing that Jonathan modie and cloud play could you do something fancy with batch signatures such that you only have to do one signature to cover all of the notes in your path yes you may be able to do something like even simpler and more murkily not Merkle more bloom filter e so then instead of having log n log n individual hash values you could have a smaller bloom filter and check inclusion in that bloom filter for the the nodes above it so yeah you could potentially optimize downsize I was trying to optimize for number of signals because if you could get yourself down to one signing option rocks from one then obviously that would be the benefits option two and option one yeah so if you\u0027ve got suggestions for algorithms to do that\u0027s a that could be employed there I think kind of going back to Rafael\u0027s presentation we\u0027re keen to avoid exotic crypto here but if there\u0027s some stuff that works more or less off-the-shelf I agree that seems like it could you know cut through the trade-offs here so I mean again this is one of these cases where we\u0027ve got a computation message size trade-off I think my bias here is probably two by two to do the one signature option and just carry the hashes around because it seems slightly simpler but looking at other implementers here to see if what they think would be easier to do yeah just add my two cents to that I think what\u0027s important here is that conceptually this is a very important addition to the whole thing because MLS is one of the few protocols I may be the only one that caters about groups this makes a lot of sense because with one-to-one protocols you don\u0027t have a concept of a group you don\u0027t really know who is in the group you only know it when you individually encrypt it to what you think are the recipients but you never have any guarantee that when you receive a message who the sender of that message you know as thinking is in the group so this conceptually makes a lot of sense to do that addition for MLS I\u0027m but I\u0027m equally worried about the the overhead "
  },
  {
    "startTime": "01:37:41",
    "text": "here so it would be interesting if we can make it even smaller but if anything I tend to agree with you that we should go with one signature and more hashes because I think signatures are not pretty if you have a lot of them covered any thoughts here this is another implementer whatever but I think Rafael to take your I think your key point here is that option three is not the way to go we should we should in fact address this risk in the most efficient way we can okay alright so I think the author\u0027s can plan on doing I think number two here I\u0027m you sign the leaf and you just hash hash the the nodes above and due to inclusion checks Jonathan it be blood here if you got some some idea strategy to better okay that issue this Benjamin added to the deck and it was totally new to me so I\u0027m gonna like kind of wing this so right now all of our all of our injection of fresh entropy is via these HP ke things one could imagine at post quantum world where you want to inject some external entropy into the key schedule so here\u0027s where we\u0027re getting to your importer stuff Jonathan um so it appears this is a I haven\u0027t even went to the floor request for this so if here\u0027s the proposal here is to be able to add some additional entropy some pre shared key that is that the group is established using some out of van protocol to enhance the secrecy of the handshake if if we have less confidence in the the D H or kemper motives that are being used for the HP ke distribution so yeah it sounds like yeah so he\u0027s all about defining a new group operation that would in is that says take this PSK that I\u0027ve identified and injected into the key schedule so I probably would be analogous to a commit message and that it would advance the Epoque because you\u0027d be advanced in the key schedule but instead of sending new entropy to the group in the form of you know a bunch of HP ke stuff that updates the tree you would just send things by this PSK in input that is externally negotiated somehow and yeah I cited Jonathan\u0027s draft here Jonathan you have any thoughts on this general approach whether this whether there\u0027s things we could copy and paste from CLS which is my favorite way of doing protocol engineering um no I obviously I think this looks good some some thought needs to be given to checking whether you actually say in the "
  },
  {
    "startTime": "01:40:45",
    "text": "extend key schedule draft there\u0027s two different ways of injecting secrets and then not the same so I\u0027d need to spend some time thinking about which one you want here and which one you have here yeah do you think it might be better to think of this as like a generic entropy importer kind of in the cells that he proposed for TLS as opposed to specifically a PSK authentication sort of thing yeah so because what you\u0027re in the tier last thing at least you\u0027re not actually trying to get PSK necessarily or you might be trying to layer MLS on top of some other pro Scot so like if I was running MLS over the top of point-to-point TLS for some reason I I you know trying to come up standing on one foot I I think you all you need some way of injecting pre shared key but also some like agreed-upon context and that would be a channel binding and yeah I\u0027d have to think about it oh so you\u0027re thinking that if we had a generic importer mechanism that could be used for injecting PSK like stuff as well as injecting binding information yeah so you need some web you need a way of adding public information that you\u0027re committing to and secret information that you\u0027re agreeing upon okay oh yeah okay so it sounds like a little bit more discussion of motivations is in order so I\u0027ll get Benjamin to send some emails of the lists and get some discussion started I don\u0027t really interesting but this is trying to get to in sounds like but I think this importer approach is probably the way to go learning from the TLS experience let\u0027s see is this yeah so one of the things we\u0027ve been discussing for a little while is how to deal with that are there\u0027s been a bit of a gap in our forward secrecy story in our post compromised security story and that we assume we there\u0027s no mechanism right now for doing any rotation of the signing keys that are used to identify participants so if a notice if a client is compromised and they get really all of the secrets that are in there including all of the D H keys and all the signing keys we have no way to recover from that because there\u0027s no way to rotate signing keys right now so there\u0027s an e going to be a need for a signature key rotation I think Owen sent something else of the list on this starting of that conversation I think it\u0027s a first step toward that is replacing the current unsigned data in the leaves of the tree with client in it keys that\u0027s nice for from one perspective because it kind of solves the problem we were just discussing about where to put the signatures on over the parent nodes in the tree so client and accuser signs so and kleinen turkeys have extensions now "
  },
  {
    "startTime": "01:43:45",
    "text": "so you can just make an extension that says you\u0027re my parent nodes and now you have the tree signing done it this also kind of opens the door to doing signature key rotation because now when you do an update instead of just saying here\u0027s a fresh D H public key you would probably we\u0027re probably the implication is probably that you provide a fresh client init key that it has a new D H key potentially a new signing key and other information yeah yeah yeah that\u0027s an interesting idea I just wonder how that\u0027s going to work with what we discussed 10 minutes ago with signing the intermediate leaves if you rotate the signature keys because the signature of the intermediate Lea is there going to be potentially old so it\u0027s it\u0027s not clear how you keep those keys around - in order to verify the signatures there yeah I think there\u0027s some booking giving I\u0027m not tremendously worried about old stuff and so old stuff hanging around is inherent in the the single signature variant here right so so B double Prime and B triple prime no longer appear in the tree they\u0027re stale they\u0027ve been overwritten so this approach inherently keeps some old stuff around it\u0027s kind of the cost but I don\u0027t think that undermines the the security the protocol well I mean at the end of the day you need to be able to verify signature so if you have rotating signature keys you also need to keep around the Ottawa in order to verify old signatures possibly I think we need to whiteboard a little bit to understand precisely we\u0027re talking about me yeah so this this is more of a announcement of intent I think the tree signing stuff indicates there\u0027s a need for sign stuff in the leaves of the tree client any keys are signed and they give us an opening to rotating signing keys in the future because you know you could envision having an update where you replace not only the D H key but also the signing key and as long as that\u0027s been recertified by the authentication service you\u0027re okay you\u0027re the saint you can verify it\u0027s the same user so this is very preliminary stuff keep an eye out in the future this is more of a highlight so looking at implementers in the room this is something we discussed the interim it would be good to get a little bit more motion on this so I put on the lists I was able to extract some some data from WebEx teams about how groups are actually used and one of the questions we\u0027ve had about this protocol is like how does it what is the overhead look like once the costs look like in the context of actual groups you know like what is the distribution of sizes of groups how often do people join them leave so what I\u0027ve done in the WebEx teams context because that\u0027s what I happen to have access to is I\u0027ve gotten some ways to generate I\u0027ve called it an ik data here because it\u0027s only what I as a user of the system can see so it\u0027s a little bit special it\u0027s not global "
  },
  {
    "startTime": "01:46:45",
    "text": "across the system but I\u0027ve gotten a way to extract these kind of this is what I\u0027m called a transcript of the group\u0027s lifetime so it\u0027s a bunch of events add remove message events with an indication of who in the group did it you know by index no no identifying information but who in the group did it and kind of how often that occurred and that seems like it\u0027s a useful input to running basically a simulator of Emma what MLS would have to do here and so you can simulate all the crypto operations that the various participants in the group we need to do so they good there\u0027s a question here I think it would be useful to get some of this to build confidence in the protocol to do some of the simulation and answer questions like what is the impact of different doing commits at different times I\u0027m a few like for example always update on when when you\u0027re first added how full does that keep the tree sparsity look like so this is kind of an invitation to researchers and other operators of messaging services to say you know can we get some more data here and would anyone like to volunteer it\u0027s like run some simulations and and do some data analysis because I think that would be useful in terms of building confidence in this protocol so like I don\u0027t know if the Google folks or or wire folks have any ability to get this data or share this data but this is kind of the it seems like a very highly abstracted form which maybe extractable but is also useful for evaluating the protocol so call them Google um could try get it no guarantees depends on the privacy and how we can apps I think you know ad said last time you try to get some data but it hasn\u0027t come to do with it so have to check with him to see where it\u0027s at Felix Honda Facebook I used to work on messaging if you want to send me an email I can definitely forward it to the right folks but I it\u0027s probably unlikely that we\u0027ll be able to share this do you think is so is there maybe a more limited form that would have a more likelihood of success that is a good question I can I can investigate yeah as far as you can envision like just getting summary statistics like the distribution of group sizes or the you know inter arrival rate of ads and these yeah yeah so I\u0027ll send you an email as a follow-up all right and I think that\u0027s the last thing I had yes Lesley all right so the other exciting news is we\u0027re having yet another interim in January we\u0027re gonna do it on the 11th and 12th in New York City I get that right right after we lower crypto on so basically we will get all the implementers and a lot of the academic community in the same place I will submit the interim request for been shortly "
  },
  {
    "startTime": "01:49:46",
    "text": "beyond that be on the lookout for stuff on the mailing lists thank you very much thanks for getting done ten minutes early if somebody has the blue sheets we would like to collect them another trick "
  }
]