[
  {
    "startTime": "00:00:05",
    "text": "uh hmm good morning all right i think you could go ahead and get started so the uh alexi thank you so much for running the slides there are a bunch of them we have a pretty full agenda today so um i guess without further delay let's go ahead and get started next slide please by this point in the week you should all be very familiar with the note well but please make sure you're"
  },
  {
    "startTime": "00:02:00",
    "text": "aware of your obligations before you contribute next slide uh basically this is the agenda it's two pages full of stuff um the first part is stuff that needs the least discussion and then we move into the stuff that needs more discussion um and then we move into stuff that's under consideration for adoption um has anybody uh oh and there's uh one agenda bash the last presentation um renee reached out to me and said it was very unlikely that that is going to make it to that we're going to get through all of this so he has withdrawn the request to speak and he will bring his topic to the mail list are there any other agenda bashes is there a scribe oh thank you for keeping me straight um is somebody willing to take notes from the kodi md i see a very shy hand awesome thank you very much a shy hand so the uh first presentation is going to be from hendrick i believe he's the one going to be speaking hendrick would you come to the okay"
  },
  {
    "startTime": "00:04:00",
    "text": "thanks for us that's right yep um it's on the materials um yeah it's all through the first three presentations okay next slide please next so um this is about the changes to cmp update since um itf 112. um i managed to reach out to the authors of 4210 to remove the pre-work disclaimer i did do some checks to address nits from the nit checking tool with regard to outdated historic rfcs we did clarify the reference to crl sources based on this thing a distributed name and issue a general name we referenced fur to further documents with regard to random number generation we did open the ca search support message to also transfer trusted root ca certificates and addressed and security consideration with that regard and we rolled back a change to the root ca updates support message to not to need to register new oids next slide please so we addressed all feedbacks from from roman from the area director review and um i guess there are two points"
  },
  {
    "startTime": "00:06:00",
    "text": "for further discussion um i didn't get feedback yet from roman whether the rest was was sufficiently addressed but coming to the two open issues roman suggested to have a 42 10 bis document though the cmp updates offers quite a number of changes so the authors are open to do so but the working group back then decided to go with this cmp updates approach and um finally if not having the cmp updates approach we would also probably need to do a 6712 bis because there are also some updates of 60 20 712 in the cmp updates document so the the question is how to move forward um with this point i would would like to to get some feedback and guidance on on what to do next so yet i didn't receive any concrete feedback from a roman or or us well roman's ready to speak so let's let him do that oh sorry roman you're welcome hey good morning thanks for all the work and and all the different updates so the one thing that would help me uh review all the changes that you made is if you could publish a new document that would be exceedingly helpful and as to the cnp updates versus kind of doing the best documents that's we don't need to make a change we just need to explain our rationale and i believe the rationale is exactly what what you said and what we talked about in the in the email which is historically that's not how lamps has done the updates and lamps is continuing to follow the the same path it's done before and i can use that to discuss that in the isg i"
  },
  {
    "startTime": "00:08:00",
    "text": "had just anticipated that this would be a bit of feedback on how the document would be done and i wanted to make sure that we had appropriately kind of had that history documented uh roman the other thing is that we thought this was going to be much more modest when we started okay and it kind of grew um like we we took the opposite um approach with logo types where we actually decided to do the bis because we we wanted to merge two rfcs so i mean i i think this was um a reasonable decision at the time we made it right and i think it's just a lot of work to to get from here to abyss yeah i completely agree i mean again in an ideal world had we known this it would have been much cleaner and kind of easier to do this but that's not where we are now and so that's right i i you know just we're having the conversation with this good and for me you know the resolution of this let's just document it in the shepherd right up uh and i'll have this in my back pocket that we talked about this from the minutes and i'll use that when we ballot and i'll get the feedback of why didn't you do the best okay um so do you want me to update the shepard write-up could you do that that would be very helpful all right because that'll indicate that the working group discussed that versus me saying the working group discussed that okay and then on if i was being asked about feedback on the dot well known i need to dive into that i believe it was actually ben who brought that to the table it was ben he brought that in the review of cmp over co-op in the ace working group yeah he's probably right um so we took the same approach than um est took just for for for being aligned and then"
  },
  {
    "startTime": "00:10:02",
    "text": "not having different approach for different enrollment protocols but i see his point having a locally defined path segment in between or some two well-known segments is not what yeah the well-known was was built for right i just found my sticky note on on my desk for when we talked about it yeah i have some proposals on the next slide but um yeah yeah you have yeah given it so coming back to the updates and these documents we ended up in similar situation right pc maybe we started doing dc encapsulation guidelines and implementation notes and so on and then we realized that you have to update and change things and then we decided it actually is easier to make a piece document because it's actually it's much easier for implementation where everything is in one document you don't have to go oh yes implement this but you always have to implement everything in it here and and that's so it's very and also the other question is that my understanding cmp is already in use in lots of places where so should we actually start uh think about progressing it from proper i think it's proper standard now right so how about moving it to the internet standard should we actually start doing that at some point they're not doing that i think would be much better to do in this documentary yeah so i had a i had a look into the 4210 and 6712 and talked to the rfc editors and got some yeah some kind of xml version so what what the authors think we could could offer is just providing an xml having all the changes done as discussed in cmp updates and that's it so that would be kind of a reasonable update"
  },
  {
    "startTime": "00:12:00",
    "text": "or a reasonable effort going through all of the sections in cmp updates is probably more that what we plan to do so i want to make tyro say that more slowly what do you want to change the document to the internet internet standard okay i just couldn't like i mean this is very brave of you suggest this i mean not saying you know it's a bad thing but go ahead michael sorry michael richardson so um i think that's a great idea the problem i think i i understand is that i don't think that the work that we're doing here is simply uh um is simply removing things that we didn't implement before and the stuff that i think you are doing is new work that we won't have a we won't be able to point to two years of interoperation or something like that to be able to get to that so it would be nice to go that direction um but unless we want the document to sit around for two years while people deploy it um i i think it's probably gonna be don't think it's two years it i think it if i remember correctly it's like six months well okay but do we wait and and i don't see a reason we can advance later yeah so that that's all i mean we we could well anyway i i think that that as you said we we thought this was a smaller effort when we started um i think i agree with tarot that it may be is that easier to write this as a redo this as abyss um but i i don't i don't think you know i it would also be good that we could rip out stuff that we never used when we go to internet standard and that would also be a good best thing if we can get rid of 20 of the document that's stuff people don't have to review um so but i don't think that we can do"
  },
  {
    "startTime": "00:14:01",
    "text": "that i just would be a lot nice i just don't think we can get there okay roman go tarot says going to the abyss they're going to the internet and and i meant going to the internet standard yeah right that was exactly what i was going to ask about we're not talking about trying to do is for the cmp updates because that's a no-go uh if we want to make abyss we which would be the only way we could do the is that's that's a whole new body of work all right good thanks i was just wondering whether we were trying to do something a lot harder i think churro was trying to get us to do something a lot harder so so one more comment also if i understand correctly we can go to the enter standard later if we have a beast document if you actually do this document and then we have implementations and after two years we when we are ready and we notice that nothing has to be changed we can then go to data standard without making a new rfc at all yeah you can upgrade it to internet standard without changing the document yeah so with regard to readability for implementers with all the erratas and the changes implemented or proposed in cmp updates it would definitely be much easier to have a best document but yeah as i said my approach would be to really just just do the changes as discussed in cmp updates and and not like uh michael also said um stripping off 20 of the text that would be just resetting the effort and and kind of starting over again and i yeah don't think that this is what is um yeah planned yeah i think yeah basically uh moving to internet standards it's a lot of extra work for you so understandably okay so at this point uh i think the"
  },
  {
    "startTime": "00:16:02",
    "text": "plan is to proceed with the document uh as an update and if we want to advance we will do the viss at that time does that make sense does anyone object to that way forward okay thanks russ okay just checking the the chat to make sure no one's objecting okay go ahead so the second point um as i said it came up was brought up by ben during the cmp over co-op review and as as pointed out the the past segment that is implementation specific pointing at a c certificate profile to be used for the enrollment or a ca to be addressed in the past in between of the protocol portion and the operations portion like like here we see the arbitrary label in between est and simple enroll or in the cmp example between cmp and the initialization operation portion that was kind of addressed or criticized that this is not in alignment with the dot well-known specification and um yeah ben clearly pointed out that this wouldn't work out but then you're on the the cue please go ahead yeah uh i guess the the short explanation here is that the well-known path is designed so that there's parts of the uri namespace that are under the control of the protocol because by default the ui paths are in the control of the site operator and it's perfectly reasonable for us to say okay we've got this well-known stuff"
  },
  {
    "startTime": "00:18:00",
    "text": "that's part of the protocol but we want to redelegate some of that back to the operator but my concern here is that we should not re-delegate all of it back to the operator leaving us stuck without any path for expansion if we need to make new parts of the protocol and so i don't object to having this sort of arbitrary label or profile label present i just think we need to make sure we do it in a way that we retain a scope for expansion in terms of parts of the path that are under the control of the protocol still so the easiest way to do that would just be to add another sort of sub component that prefixes what these arbitrary labels will be and we were sort of only delegating that subtree back to the site operator but there's a bunch of other ways we could imagine leaving us room for future protocol expansion maybe next slide so we discussed um with also some some ways to move forward here so number one is um as we specified it today number two is kind of if we move have to move away from that um to do it in the in the query um component of the uri to specify the certificate profile here this example shows if you want to enroll to a local domain and you want to specify that you want to enroll the ldf id certificate profile then you could could do it yeah could use this label to to indicate that to differentiate to some application specific certificates they may need to be enrolled later on so this is the second approach doing it with a with a query component the third approach is to switch the operations label and the profile label but yeah that seems not to be that the logical order"
  },
  {
    "startTime": "00:20:04",
    "text": "and the fourth option is to to move away from that well known at all but that is also something the authors would yeah did wouldn't like to do so yeah ben you proposed additional options i didn't fully get them michael richardson i also didn't understand ben what you proposed which is why i put my my hand up uh so i guess my if you go back one side yeah one slide back much like that so my proposal like currently we've got done the bottom line is the well-known cmp profile label initialization and i was saying that uh we could do like that well known slash dmp and then add a new path component but call it p so we would do well known cmp slash p slash profile label slash initialization and adding that extra like p path component or whatever we want to call it is a signal that the stuff after it is a protocol or is a profile label followed by the rest of the stuff so so i think to be clear heinrich on this slide the word profile label is a label not a prefix okay so so so just the the profile in this case is called profile label right just so everyone knows that's not a literal and and ben is suggesting that it's a cnp slash p slash you know profile label and then uh i don't understand how initialization is not the label myself but i guess it's initialization oh that's that's the label that's the verb yeah okay yeah the operation specified in the light by profile in this case so i don't object to what he's suggesting i i i and and it kind of is interesting to me that um"
  },
  {
    "startTime": "00:22:01",
    "text": "that particularly when it comes around to renewing things that it would be nice to say which thing you're trying to renew um ldev id versus some application uh thing it would be good to be able to say that so there's no no confusion uh i think we have a we have we've discussed this a lot we know we have a discovery problem here um um but but we but i think that in many cases that essentially someone else is going to say you know for for light bulb systems that that the following profiles are in process and that there's no no discovery you can go forward one slide again so i don't like number two i don't like queries but other than that i have no particular choice i just wanted to say that i think the query makes it more difficult than anything else and we can put the slash p or whatever it is we want to put in in their bin i think that i think that's reasonable you know well taken uh suggestion okay thanks i think the decision is one with additional with a additional uh label yep a well-known label um that indicates the next label is or the next segment is a the profile name yep right okay understood thanks thanks for the guidance next slide please so coming to cmp algorithms the authors addressed i guess all of the feedback coming from the working group after um 112 and from the area director review we mainly added um in section seven a table um showing all the algorithms um and sorted by by their cryptographic strength"
  },
  {
    "startTime": "00:24:00",
    "text": "and we got a very valuable feedback from quinn and his colleagues on the shake and kmac and yeah also on the table itself we added some security considerations and i yeah and we managed to also remove the pre-work disclaimer so i i guess the cmp algorithms is is fine now from from the editor's perspective so just needing feedback from roman on yeah on the on the status of the changes absolutely that's totally fair action caught i've been a little behind i will re-review that's re-review it and get it moving i think from all the conversation we had we had a resolution actually take a look at the actual text thanks okay thanks so next slide please next slide is on the status of the lightweight cmp profile so this was not yet reviewed by roman as we were still discussing on cmp updates so that is great we will we did some changes um to the lightweight profile since one one two we did change to recommend it for implicit confirm um with enrollment um we did a section on on conformance requirements in section 7. we added some clarifications and we aligned with the changes done in cmp updates so this is mainly it on lightweight profile next slide please so next so open points would be also to to address and implement the changes on the dot well known as discussed before and from um discussions with with"
  },
  {
    "startTime": "00:26:02",
    "text": "implementers we got some some feedbacks that clarification on error message protection and the section 7 the um the the pki management operations support level would be required so we would like to do that and yeah afterwards start into the the area directory view so next i think that's that's it okay so um with these it looks like we'll be able to return uh once you make the changes that we just talked about with the label uh it will the next actions will be with the isg and i will update the shepard write up for that the i think that puts these three documents back in the in the pile for the isg as soon as you have that done any last comments on these all right thank you for for this work hendrick yeah thank you for supporting and uh the next document is uh lamps samples there are no slides for this it is in auth 48 is dkg in the room is there anything that you need to share with the group or are we just waiting for the rfc editor to finish uh your room i don't know if you can hear me properly i'm gonna be a little quiet um [Music] hopefully that's better um yeah so it's in auth48 um there are a few minor editorial cleanups that uh auth40 has requested and i've i'm a couple of cycles into that um i suspect that it will be able to be published shortly the main changes that they're asking for"
  },
  {
    "startTime": "00:28:01",
    "text": "are asking about rather are fairly small just textual edits but they also there were some errors introduced by the textual edits as well so i'm just clarifying them right now okay thank you the next uh that ends the first batch those things that are with the isg or the rc editor the next ones are the certificate related documents and sean turner's up with the document signing eku one two three four all right i think we're good um russ are you gonna share the slides or do you want me to yeah i i'm happy i don't like mine alexa's gotta sort it out all right i'll let you do it it's one slide or two slides i guess that'll be pretty quick no keep going there's only two slides so it's really good yep hi this is uh i guess i can need to update the the link there but this is a working group draft for um a new extended key so just for uh document signing next the draft is in uh the o2 version was published i think at the beginning of the month then it's currently in working group last call we've received some comments and we're going to address those before uh being done what we need to do shocking that we defined an extension and didn't indicate the criticality um obviously we need to do that um we're going to make it optionally critical um there are some minor editorial issues that we need to fix which we've got queued up and we need to add some acknowledgements and that's it at this point with respect to changes that we have uh lined up to make for the next version which i hope will go to our"
  },
  {
    "startTime": "00:30:00",
    "text": "responsible area director um it's in working group last call now it does not end until i think next week so if you have comments send them on in but otherwise let's yield some time back to the rest of the agenda uh sean actually you're not defining a new extension you're defining a new void to be carried in extension yes so the definition of the extension i believe already says optionally critical you could restate that but it's not like you're defining a new extension fair enough we can do that we'll just make sure we'll just make sure to reiterate that you know as this is in the eku it is therefore by definition optionally critical all right thanks for that clarification yes he said it's almost like well so then the next one has no slides and it's me um we're in working group last call on rfc 3709 fists the big change in this document was to get rid of sha-1 and say where a hash is needed use the same one that was used to sign the certificate that way we won't have to do this again for an algorithm change um it is also in working group last call we have no comments at this point plus no slide um so please uh take a look at it otherwise we're going to advance it to the isg next week and the next one is sean again for the uh clarifications on the missed curves hey russ on the 3709 on the 3709 i did send in something but did that get addressed before it went on to work last call um i'd have to take a minute to go through my mail and look but if yes i'll make sure so it's minor i think i think the only"
  },
  {
    "startTime": "00:32:01",
    "text": "thing is uh i think there was some no um the big one was about which asn 1 attacks to refer to in the title of one of the appendices oh no that got fixed that got fixed okay so if if you fix those in great uh russ sorry i got a bit confused uh on agenda is header protection next i think no i think it's uh 84 10 key usage clarifications oh yeah what happened uh was it was originally down in the under considerations section but the working group adoption completed so i moved it up here did i not repost the agenda no uh sorry i'm struggling to find the slides let me tell you what the name of the slides are it's lamps clarifications for ed255 okay fine okay can i ask you before you start that is did the draft change yes there it is because you still haven't yes i um sneakily submitted i sneakily i submitted a working group draft uh last night at like three o'clock in the morning or i don't know what time zone that was but yeah so hey thanks for adopting this draft um"
  },
  {
    "startTime": "00:34:00",
    "text": "this basically uh you just go to the next slide so what's in this id right so this um text that i'll look really really familiar to you um it's basically uh another version of um the 5480 clarifications that was published in rc 8813 but this time it's for the edie um star uh algorithms the other draft or the other rfc that had um these define these key that the keys which is defined for this particular set of algorithms was to find an 8410 uh they only specified um key agreement in cipher only in decipher only so basically the only thing this does is basically said you know all the other things that it's not supposed to include and i think there might be one more slide or there are six slides oh there are so go to the next one so there's there's this this draft is so short that i think i put the whole thing in these slides so basically all we're saying is we added some text you know the first two were already there so basically what we're adding is the block at the bottom which basically says don't use any of the digital signature related ones um so we just made those must not kind of slam the door on those um and that's really it because if we're using key agreement you don't use in you don't use key and ciphermen or data and cipherman so it's kind of just straightforward now if you remember at the beginning i asked simon why they did this and basically he said nobody asked for it so this is just kind of like fully enumerating all of the possible options to make it clear to people the things they shouldn't do so it's basically removing ambiguity next and you have to do that both for uh the the um the encryption algorithms as well as the signature algorithms so it's the 255 uh ones and the x448 or above and then you have to do it for the signature ones as well so you have to do it for the ed255 and the ev448 and so then the only"
  },
  {
    "startTime": "00:36:01",
    "text": "difference is you have to do it for the e certificates which is what this says so um for e certificates obviously you can only do not repudiate your digital signature and you do may do a crl sign and then must not for all the other ones and then the next one is for the ca and the only difference is that for a ca you can also put ca keysearch sign next wait a minute go back i think i think the um you back up one more okay when are you using a crl sign if you're not a ca when you're when you're on uh like an ocsp responder this mimics exactly what's in 5480 or was a union in 5480 and now in the in the 8813 update so an ee is allowed to set crl sign oh it's for the indirect cro that's what yeah okay thank you i was having a hard time with ocs because it's uh it's um 5 30 our time so yeah no kidding thanks all right so uh sean just uh out of curiosity have you reviewed these changes against the lamp sample draft which has uh certificate authorities and and nc certificates in it i have not but i will i will definitely i haven't tried to compare them i i'll look usually i mean to be honest i think most people that are sane usually don't blow this but there are people i think that uh sometimes willfully try to misunderstand and make things difficult so this is mostly just trying to slam the door on that but i'll definitely take an action to review the examples draft i i think i i think i got it right but"
  },
  {
    "startTime": "00:38:00",
    "text": "it that that one is enough 48 and it would be ashamed to publish that shortly before uh declaring that we got it wrong can you shoot me that link if you shoot me the link for the off 48 thing i can look at it like before the end of today yep we'll do thanks awesome thanks all right so lexi i think we're moving to the last slide and so since you guys have seen all this stuff um and i know it's just an oo version um i'm actually asking for a working group last call now um i think that uh this shouldn't come as a surprise it's pretty non-controversial and basically we're just aligning with the previously published rfc so i think that that's not an unreasonable request thank you so what i would like to do is since we have two working group last calls that end next week is issue the working group last call when those end totally totally wonderful okay any objections or concerns with that approach okay thank you now up next is header protection alexi okay can i sneak in so we basically have a week to review this before you issue we will start working group last call in a week so you'll have two weeks after that to review it's three weeks to look at it yes hey folks uh daniel kahn gilmore here um presenting about the header protection draft um which is work with uh bernie and the lexi and myself um where the the editors on it um just wanted to uh report back to where we are um i'm gonna give a brief recap and then uh talk about some changes that have been made we've made good progress on it it's uh since the last weekend so that's good so to recap when we were defining this there were two different schemes for"
  },
  {
    "startTime": "00:40:00",
    "text": "header protection that is cryptographically protecting the headers in either signed or encrypted and signed emails the type that was specified way back in sm3.1 uh has not seen much uh deployment that's the wrapped message that you see on the left there you take the these things are the cryptographic payloads these are the the data that is within the layers of encryption in the message and in s mime 3.1 we said well just wrap it all in a message rc8222 object and then we have this other scheme which is injected headers which just stuffs the headers that you're protecting directly on the cryptographic payload itself so next slide please um the reason that we weren't really satisfied with the wrapped message is that for one thing it wasn't widely implemented there were not a lot of senders that actually did this and when it did come out like this a lot of the existing clients that were capable of decryption would present the message in a weird way it might look like a forwarded message it might have some strange user interface elements you might have to click it to save it and then reread it or something like that or in some cases somebody's radians couldn't actually read it at all the objective header the injected headers variant some of the obscured message headers that is when you have an encrypted message they would be invisible to the legacy clients um and we had a fix for that in the previous version that was called a legacy display mime part that stuffed a decorative representation of the message headers that were obscured into the message body so it changed around the the cryptographic payload to add this decorative part to unobscure to to to unhide those header fields for clients that don't know how to interpret this"
  },
  {
    "startTime": "00:42:01",
    "text": "the unfortunately what we found was that the legacy display decorative mime part made the entire message unreadable in one significant mail user agent which was outlook so that's sort of where things stood as of the last meeting next slide and the update is that we have changed the way the legacy display mechanism works for injected headers instead of inserting a mime part what we do is we modify the main main body part of the message that is the text plain part or the text html part that is sort of the first leaf of the message itself and you can see here how the this is a text plain example here where you did we just uh dec we just add this uh legacy display element directly into the text plane part next slide or if the main body part happens to be html you can see we add it in this particular way so these are both legacy display elements a message that is multiple part alternative might have two different main parts one text text plane and one text html in the situation where you have that both of them get this legacy display element added and the rules for adding the legacy's legacy display element are pretty straightforward and they're designed so that when the legacy display element is present you can tell that it's present and you can ensure that the legacy display element can be omitted by a client that knows about it so it's really there specifically for legacy cryptographic decryption capable clients to be able to render the user facing headers that that would otherwise be hidden next slide please um with that change the as the draft authors uh we've made some decisions one of the biggest issues with the draft was"
  },
  {
    "startTime": "00:44:00",
    "text": "that we still had these two schemes lying around in it it wasn't clear what implementers should do and here we're saying we've made a decision with the legacy display element instead of legacy display mime part we believe that injected headers is something that is going to be is going to work for pretty much all the legacy clients so conformant muas must be able to generate injected headers we're also saying that conform and use may generate the wrapped message um and that all message you know the receiving message user agents or mail user agents must be able to consume and render both schemes in practice we have not seen much adoption of rendering the wrap message but we think with the legacy display and injected headers that even male user agents that don't adopt know that don't that don't handle the rendering uh in a deliberate way we think the legacy ones will be able to at least show the user what they're looking at and this gives them an incentive to step up their uh rendering and parsing because they will now get some security advantages of the protected headers so must generate injected they generate rap message next slide please alexa thanks so the way that we got here was a meeting of the design team uh which is the group of us who are listed as editors plus uh hernani from the pep group we've been meeting about every two weeks we've been working with the git lab so we've been doing issue tracking and merge requests and things and that has actually been pretty productive uh we welcome anybody else who's interested in participating to join these meetings you can let us know either directly on the lamps list and say you're interested or you can mail one of the authors directly if there's anybody else who's interested in joining we'd be happy to have you we are particularly looking for an implementer of a major mail user agent in particular outlook or mail.app who's interested in this because we think we are getting pretty close and we"
  },
  {
    "startTime": "00:46:00",
    "text": "would love to have one of the major male user agents um uh you know an implementer from their way in so if anybody who is currently in the meeting right now is an implementer of outlook or mail.app or knows somebody who is and wants to get in touch with us um you know we welcome your participation next slide um from the work group generally even if you're not interested in uh joining us as we sort of put the finishing touches on this draft we have updated the test vectors this document has a bunch of test vectors and there's a pretty clear there are different ways you can get access to them that are described at this link at the bottom header dash protection dot cmrg if you can we would love anybody in the lance working group to help us take a look at these again take a look at them with your mail user agent take the sample messages and route them through various mail transport agents see how they get mangled what happens to them test uh automated systems if you've got things like mailing lists or bug trackers or other systems you know we'd love to try to make sure that these mechanisms um we want to understand exactly how these mechanisms interact with those systems obviously we can't do that exhaustively but we can be more exhausted with more help from the work next slide um so a couple questions for the working group um a couple i think there's five in this deck here um you may recall that one of the definitions in this draft is the header confidentiality policy so uh just a quick recap about what that is when you um are sending an encrypted email message and you want to do header protection not every header is going to be uh secret the way that the content of the message is secret um and uh we define an abstraction here uh called the header confidentiality policy or hcp"
  },
  {
    "startTime": "00:48:01",
    "text": "that describes how how the mail user agent that is composing decides which headers to protect we had a couple variants in the draft http minimal which basically just says protect the subject line and here's how you do it and http strong which basically says protect everything but by stripping it out everything but the from to cc date we obscure the subject line with that and we put in new message ids there um uh the design team we have sort of feeling like we need to recommend one for initial implementers to do we don't want people to have to make hard decisions when they're implementing this we want them to just have a a pretty straightforward roadmap and we are leaning towards recommending http minimal as the um as the initial implementation you can see there's a link to a merge request that describes that change the reason we have this hdp abstraction is so that we hope in the future this will evolve but we want people to have you know something specific that they can do going forward um if you're going to go from no header protection at all to predicting the subject we think is a win in terms of confidentiality next slide uh by the way this is our these are questions for the working group we're just you know in some cases we have some ideas about what we're going to do but if you all have any particular comments that you want to make on these you know i welcome comments now we could also have questions and suggestions afterwards and of course messages to the list would be great um when you are composing a message using injected headers you need to decide whether to put the legacy display element in the main body parts as described earlier or not um we would love it in some future world where all male user agents that are decryption capable are capable of actually dealing with protective headers like this we would love to abandon the injection of legacy display elements that's the goal because it makes things much simpler you have to think about"
  },
  {
    "startTime": "00:50:01",
    "text": "but the question is how how do we get there um if i'm composing a message how do i decide whether i need to put in a legacy to play or not um the draft currently is silent on how you make this decision it just says the mail user agent you know sets a boolean flag when it's doing message composition uh do i include legacy or not um and the guidance in the draft i think currently says you know if you don't know just set it to true and carry on um so there's a couple different ways that we could get rid of legacy display elements one of them is that male user agents could respond to a general ecosystem survey that says hey every client that's capable you know if we at some point in the future we just do a survey of all the decryption capable clients and we say um you know can they render injected headers correctly without dealing with legacy display we don't need the legacy to play for them and if enough of them say yes then we update all the clients in one more round and we set legacy display to false alternately each recipient could try to sort of somehow signal uh that they can that their email user agents can render obscured injected headers and don't need the lexi display um in that case but figuring out how to signal what specifically the signal is pretty tricky and if you look at the link at the bottom of the page here that url uh points to some discussion that we've had about what what would be some of the drawbacks of signaling uh what are some of the things we could try to signal ways we could signal what the semantics are um so we don't know whether this draft will contain signaling or not it will certainly um it could mention that we need signaling without defining it um but we're we haven't made a decision within design team about how to do that next slide um so one of our concerns about the legacy display elements is that we're not sure how they will interfere"
  },
  {
    "startTime": "00:52:01",
    "text": "if they would interfere with systems that do command processing now remember legacy display elements only show up in encrypted messages so this might only be relevant for an automated mail system that uses encrypted messages uh for its control channel um that might get confused if it sees a legacy display element uh present um there are not a lot of systems that we're aware of that are out there that do this that use email as a control channel but if there are you know we want to know in particular the schloer mailing list is an encrypted mailing list that uses pgp mime not s mime but the systems that are described here are probably relevant for both um so we've done some outreach to the folks who maintain uh mailing lists like schleter and mailman um bug trackers and looking at if there's anything else i looked at joker.com which has an email interface control channel for the dns but they don't actually use um any mime based encryption scheme they just use pgp signatures inside the message body which has all kinds of other problems but we can't really uh solve that here anyway folks know of automated mail systems it would be great as i mentioned earlier with the test vectors to test this stuff out we're particularly concerned about legacy display elements but we you know we'd also like to know whether um injected headers would cause problems um on their own with any of these automated mail systems so something worth taking a look at next slide um so for a legacy display element in text html um the uh the definition of the legacy display element is basically that it's a div with this special class header dash protection dash legacy dash display"
  },
  {
    "startTime": "00:54:01",
    "text": "uh we think this is relatively straightforward for composing male user agent to insert uh that is if you're making the message and you recognize that you've got a main body part that is of type text html pretty straightforward to put it in there um and we think it's actually pretty easy for a rendering male user agent to omit this if it needs to we have an example of some you know css snippet that you could slap into your local css file for rendering uh mine parts if they are tagged appropriately but we also are aware that you know html and emails may have some issues and if you are concerned that this uh this div being injected might cause a problem we'd like to know about it we haven't found any case where it does but it doesn't mean there isn't so we'd love any feedback from your working group on if they see this as an issue next message okay so this is uh i think this is the final question that we have for the working group that is pretty tricky this is part of this is an issue about user interface and how we represent message headers to the user so um the mock-up you see in this slide is a terrible user interface but it's uh an attempt at representing some of the information that we think value vehicles will have so currently male user agents don't uh mention any um any levels of cryptographic protection for message headers because there are no levels in quicker graphic protection for message headers before this draft other than the the s9 3.1 which was uh not widely implemented um we think that a male user agent may want to render and they need to know even if it doesn't render it the cryptographic status of"
  },
  {
    "startTime": "00:56:01",
    "text": "each particular header field that's used um so in this message this is an example here you could imagine that this message was sent and the entire message all of the headers are protected by the cryptographic signature of the message that's represented by the check mark at the top but the subject field as with hcp minimal uh was obscured going forward by you know so that the subject doesn't appear on the outside of the message um so you can see that in this mock-up that's drawn with a little gold box around it with the with the the lock just like the message body itself has the the gold box in the box the question is how does the rendering male user agent know that the header field which header fields were encrypted or which ones weren't how does it uh does it just compare them with the outside uh message or um or do we need something else the current text in the draft says that we mark that header field where the cryptographic status that includes encrypted when the protected copy of the field doesn't match the unprotected copy but as we all know the unprotected copy of these message header fields um can change in transit that's why we want these cryptographic header protections and we haven't really defined what counts as a match so for instance if white space changes does it count does it mean now they're different and we should treat it as encrypted uh michael i see you in the queue uh michael richardson so i i it's a your ui is not terrible i was gonna say your example would be actually good if alice was emailing bob and frank and frank wasn't someone who uh knew how to validate the um the do any of this stuff right and so the subject is that frank sees is of course friday's dinner plans and thinks oh i won't go on thursday"
  },
  {
    "startTime": "00:58:00",
    "text": "i'll go on friday um and some you know attack on him um and so i think that's that that would be that would be an attack on the on the signature status right which is different here we're talking specifically about whether the header field has been successfully obscured or not but but but i agree with you that there is a separate attack on the message signature and bob uh frank would need to update his mail user agent to be able to get the verification on the headers so so but the point is i'm trying to say is that bob would get a a notice that says that the subject does not match right that's the goal here because bob's actually done um bob's actually done done is validating all of this and realizes that there's something going on frank of course is oblivious to this because he's just using you know his uh some old web mail system you know from 1972 right um but um maybe not that early um so but uh um so but i was just saying that that's that's the kind of attack that you're talking about right as you say the unprotected copy can change the transit and so you want to know what kind of what kind you say what is a match and what are you going to do with that if it's if if it just differs by some spaces which i don't know someone some system put in in the way right well let me let me let me you're raising i think a different concern okay it's a different concern all right thank you that's actually understand yeah so the concern that you're raising says um we want to know whether the message headers uh were tampered the outside message headers were tampered with because we want to make sure that we're you know we've got the right ones but we want to know if the one outside was tampered with we currently don't have any cryptographic status that indicates that and the reason we don't have it is um because if your mail user agent can show you the correctly signed message then it including the correctly signed headers"
  },
  {
    "startTime": "01:00:00",
    "text": "then it will and and and doing the kind of debugging that says hey somebody filled with the thing on the outside is not i think for normal users to to worry about right um like if you if you say hey warning this thing changed it makes the message look even worse when in fact you have better security properties um and people you don't want when you're sending a message it just show up flagged just because somebody filled with it going through the issue that this is trying to raise here is specifically about obscured headers during message description so when your message is encrypted you might not be obscuring out the the to and the from or the date but you are obscuring the subject so there is no there is no there is no there is no clear text version of of it that that was going to see anyway because it's obscured right i get it okay right and in particular the um the concern here is if the sender obscures the subject by replacing it with the square bracket dot dot square bracket which is the recommended you know http minimal mechanism then obviously the subject has actually been protected because the only thing on the outside of the message is a dot dot dot but it could be that the sender did not obscure the subject at all maybe they used some sort of hcp null that's like hey we're you know we're going to protect everything from signature wise but we're not going to bother obscuring anything but some outside male user agent injected you know star star spam star star in the subject line and now they differ right or it re-wrapped the subject line now they differ do we claim then that it changed um that that because those things differ it must be encrypted you know technically it's not a match anymore deb i see you in the land yeah i know i'm in real life now because i have to stand on my tiptoes to get to the mic again anyway so can you re-explain what protection is on which part of the is like not not long and drawn out but just little so the whole header is integrity protected signed that's correct the way this the way this draft is specified basically every"
  },
  {
    "startTime": "01:02:00",
    "text": "single header will be wrapped by the signature layer and of course also wrapped by the encryption layer but some headers may have the same value on the outside of the encryption layer as they do on the inside but in this case not the subject line right and that's the that's the recommended header confidentiality policy right we have this header configuration this the http in the draft says when you're composing a message you need to decide what to do on the outside of the message based on what what the original message headers would have been so your question is what happens when the unencrypted but previously obscured subject line does not match the original well so in particular we're saying look when you're rendering the male user agent probably wants to know which message headers were protected with what kinds of protection they should all be signed and some of them could be encrypted and signed and how do you tell which ones were encrypted and signed when some of them have i mean obviously they've all been encrypted but some of them have also been copied to the outside it doesn't have the same confidentiality guarantees that people expect right so yeah so i'm going to make a comment and then i'm going to walk away um so comment is that i'll tell you that having dealt with smi messages on a daily basis that most users aren't smart enough to know the difference between signed and signed and encrypted let alone with this sort of level of detail that we're talking about i i agree okay good so so the re yes uh so the reason that we want male user agents to be able to reason about these message headers this way is that when so one of them is you could imagine some you know expert mode thing but we're not going to get into the expert mode thing right where where you really do want to show this a user wants to inspect it right you could imagine that most people will never use it as you described there's three of them by the way people"
  },
  {
    "startTime": "01:04:00",
    "text": "sorry uh there might be four you know there might even be five i don't know awesome devil in this room and like [Laughter] but the mail user agent might want to know which message headers uh had this kind of protection because it might be relevant for uh for dealing with the message for example when i reply it might be worthwhile for somebody who's implementing a message a male user agent to know that when they're replying these headers had been obscured previously and we would like to keep obscuring them yeah i agree i just think this is um mostly ridiculously complicated for the regular user note i totally agree the only reason that i i've presented this in the user interface here uh so people can see the kind of thing that we're talking about but i generally agree that we do not want to present this to the to the regular user but we do think that male user agents need to be able to reason about which headers had what level of protection yeah and so this is so the question here is when the mail user agent is reasoning about the header fields how does it determine that this header field was encrypted that is actually confidential or not and the text currently says when it doesn't match the unprotected copy but the trouble is we know that the outside copy can change in transit go ahead aaron uh hi aaron um why if if this is intended for machine why don't we put it into the encrypted header into like a signaling mechanism or something like why don't we just say i don't know encrypted subject even just true or one actually to what uh is in the draft there is a record of which header fields were obscured and which one wore yeah you know preserve this is yeah so i think part of the question is there is this extra complexity that goes into you know the"
  },
  {
    "startTime": "01:06:02",
    "text": "an extra side a couple of headers that will go uh into the encrypted part and you know will people implement i think that's kind of where dkj was going with this i mean yeah really the extra complexity adds adds complexity on the center side but this makes it so much easier for like machines to reason about it because like the using untrusted data i'm not the biggest fan of this idea yeah right yep so if you take a look at the git lab issues 25 and 26 there's actually a proposal that's very much along the lines of what you're recommending aaron so i appreciate you taking a look at that and see um if you think it makes sense for you that's sort of the conclusion i came to as well but i wanted to raise it to the group so we could hear your suggestions jiro so one of the things we were actually pointing out there saying that it's actually for the many users email uh application to know which headers are you know encrypted and so is that you were saying okay if somebody something was like the subject header was obscured with not with the dot dot dot but nothing here and you are replying it do you actually want to keep the you know the previous unobscured version that that was clear or do you actually want to you know uh create a new one or do you want to and you of course don't want to take the real subject here or encrypted subject here i put in outside so so i think actually and of course we're talking about yes we don't not talk about user interfaces but we actually are talking about to the implementers who are implementing these things and if we don't give a clear instructions to the implementer saying that don't do this do that and follow these rules they are not going to be they're going to be inventing their owns and which means we're probably going to have a mixed issues again when somebody says something else and somebody does some other male implementation that then we have a legacy legacy legacy display that shows you that the subject that was in legacy display because somebody did implemented it wrong so i think we have to be very"
  },
  {
    "startTime": "01:08:00",
    "text": "you know strict on rules how do we actually say we are talking about now with everything trying to get new implementations to follow our rules so let's make them very strict on what they say that do this don't try to do anything else i i think if i can interject this discussion also makes me think that yeah if we we probably should just decide on rules and make make them clear and if we do clear rules then people will implement them correctly if we'll allow a lot of leeway then they will be secondary interesting side effects and bugs so actually i think dkg this discussion just convinced me that your proposal is right and completely unrelated to this issue but actually more generic on this area there isn't this group of mob which is a messaging multiverb or whatever it has a joke of her fail wrecking and i think this is something that would be probably more you know in scope with their stuff what they are doing there's lots of you know mail vendors there's there's you know this kind of uh people who actually write the mail clients and actually write the uh mass mail mailing software and probably sending encrypted stuff banks and so on so i would actually recommend actually taking some of these things and try to get it in present in the air or something like that i think the next meeting is in london in june or something like that well that's very convenient considering that i'm local um yeah that's a good point really thank you for that suggestion i think that's a good one that we should definitely give the mog folks a heads up at least that that something like this might be coming um so that you know we can see how to work with them um"
  },
  {
    "startTime": "01:10:01",
    "text": "so yeah uh feedback on uh on the mailing list feedback on the get lab issues uh with these things would be would be great i think there's one more slide but i think it just says questions on it so um i appreciate the engagement and and discussion from the group here so thank you very much design team for for really digging into this over the last uh meeting cycle looks like we have uh the ask at itf 112 was give the group a straw man to shoot at you've done just that so thank you very much and i'm looking forward to a robust discussion on the mail list at this point is there any last questions before we move to the next presentation um i believe you're not going to talk about the eda email guidance there so i i'll give you just a brief overview i don't have slides for the e2 email guidance there's been one update since the last one which was just uh defining a set of headers as being user facing which just lists things like subject from to date cc which are typically presented to the user as opposed to the other message headers um that that definition of uh you know what is presented to the users directly is useful turns out to be useful in the cryptographic in the header protection document we haven't done much else um i am actively reaching out to mail user agents and systems that are used to doing uh you know cryptographic end-to-end protection in particular um well different values are different implementers i'm reaching out to them privately to ask them for their feedback and thoughts on the end-to-end male guidance so hopefully we'll see some more action on that on the next cycle but that's it for"
  },
  {
    "startTime": "01:12:00",
    "text": "that draft unless anybody has any comments on it okay thank you um thanks now we're moving to the uh under consideration for adoption discussion there's a lot here um the first one is uh michael richardson with the rfc uh 70 30 csr adders this microphone is actually kind of yeah we should switch them for you you do you want to give me uh do you want to give me that um you want to try that see if it works this time probably not you okay and you find my name and click on it and hover and whole hover you the whole hover interface is really ridiculous no there we go yeah okay so um yeah so it's a terrible name so please suggest a better name um and uh that would be that's the most important ask right now um so uh story so far so uh we had a conversation probably last summer probably at the this meeting last uh summer we wound up with a virtual interim meeting at the end of august to talk about this problem um and i put the links there if you don't know about it they're recorded um the uh and we formed a design team we'll tell you a little bit what the problem is there but that's the story so far um and we don't have a lot of progress in this but i'm going to talk about what what we we have uh done um so the fundamental problem does that work yeah okay so this is your viewer viewer caution thing uh there um the fundamental problem is that it turns out that a number of us uh particularly in the animal working group uh made a red rfc 7030 we thought oh this is uh"
  },
  {
    "startTime": "01:14:01",
    "text": "some asn1 that we don't quite understand so we'll just we think it means this and so we proceeded on that that uh that basis um max pritikin who is one of the authors of rc8995 and of 70 30 um was among those who believed that we were correct and and behold we were not correct um the sn1 did not do what we thought it did um and so now they're having a conversation of what's going on fundamentally what we need to be able to do as a an est client in anima but in other things as well is we need to be have the the registration authority say and this is the subject alt name that you shall use and any other name that you use will be uh stricken from the record okay so please request it please put it in the in your csr request and that that's how it's going to work um and it turns out that we can't do that we can say things things like um please use uh curve123 without specifying the actual value of the public key and we can say a whole bunch of things like that about that kind of thing but we can't actually say and you will put this value in the attribute you request so how are we going to do that so one way is the the kind of simplest way right now we have a a sequence of attribute or oid and you get this choice o id or attribute and uh this part in the middle here i don't want to use my hand because people remotely won't see it but the part in black in the middle that's what's there right now i renamed that x type and x attribute simply because uh in this slide to to make it uh less confusing to repeat the same words um and that's what we have right now and we seem to believe you see it's it's it's non-trivial amount of asn 1. um and we seem to believe that the x x attribute actually would allow us to put a value in there and we actually wrote"
  },
  {
    "startTime": "01:16:01",
    "text": "code that did that and well it interoperated but it's wrong okay so this is the simplest version the simplest version i think is that we add a new choice the top which has a value and then we have this new structure at the bottom which you see now has three three elements in it and uh there's a thing in the bottom which is put the value that you want and i think that's an octet string in the end but uh i am not qualified to say that for sure um so that's one version okay and this is this is essentially um a conversation another mailing list is whether it was upwards compatible or backwards compatible but uh what i know is that if you if you if you ask for if someone comes along and asks for uh the expects the old response and gets this that they will be successfully able to skip it and ignore it and not understand it which may make them fail to interoperate to accomplish their goals but they shouldn't blow up um so that's that's uh uh one part of it so this is option a okay and this would make this essentially uh is a superset of what we do now so everything that's out there deployed right now would continue to be compliant to this without having to do any other other changes for me what oh sean go ahead yeah the end i just i just want to say that i think we're putting a lot of stock in the rationale that you have and the example in 70 30 did not include a value in the attribute i think we should i think we should just fix that if you look at the the thing where you can put a value in where the x the uh attribute thing that you have like there's csr adders adder or oid or attribute what we didn't do to the example was a value for the for the attribute we should just fix that example and call it a day"
  },
  {
    "startTime": "01:18:00",
    "text": "go back for a moment i think that what you're saying is that our interpretation of the asn1 was maybe correct and that we just is that that what you're saying i'm thinking it's right we just the example was just wrong because it's got an at so you have for the oid obviously you just include the oid for the attribute what you're saying is you want to provide an attribute value back to the client to use right the example of 70 30 for the attribute just included in the light and not the value which is incorrect asm1 so the example is wrong okay so you're saying that okay uh this is also a good a good result i'm perfectly happy with that it's not right because because because technically if you look at it you set the type the value if you define an attribute that has no value you would just send an oid but most attributes have some kind of value so you would include the actual value so um here's here's the i believe the example that may contradict what you're saying um which is that you the type might be the algorithm yeah the value now is the name of the algorithm like you know uh esd cdsa or es256 right but at no point do you include the public key which is the value of that thing right well if you need to do that then if you needed if you need to include um something that's not defined you define a new attribute and use that okay so if you want to if you want to yeah if you want to slam a subject public key in there define an attribute that is subject public key and slam it in there and there you go okay so that would be the solution if you needed to do that that's not what we need to do but but yeah yeah yeah okay i guess yeah sorry uh uh uh so i i'm gonna engage you on the list with with the example that i have for my code okay and i i'd really appreciate it if you could you could say that you in fact believe it follows this the a i mean it's there"
  },
  {
    "startTime": "01:20:00",
    "text": "it does because in fact there is another rfc that is defined that is used this way um it which is you know rfc 8295 so it's it's i wanted to provide an entire pki data back to the um client using est and i define it there's an attribute that's defined for that and pkcs whatever it is i can't remember the value it's like a pks pdu so you can slam the whole thing in there and you can include whatever values you you want you can actually give the whole csr you want the client to fire back to you okay dan did you want to add something here at this point and i see i see that dan is there so i just want to make sure that you know because he was one of the authors yeah thanks so sean you said that the example is wrong so can you explain why they what's what's wrong in the example let me get the let me get to that draft if you look at the example has an order for challenge password and then it has an attribute of extension request and it's requesting the mac address of the client and then an attribute of of ec public key and it says use p384 but at no point does it provide the challenge password no right which is which is which would be something that maybe someone wants to do but s tells you what the challenge password should be it's the it's important yeah it's the something else the tls so what i'm saying is that in the examples that are in section four whatever that there's there's one for just an oid and so you're right you just provide the challenge password but that's the only order you're just providing an oid which is saying i'm not giving you the value if you want to provide the the value you would send the challenge password attribute type where the value i think that the examples in the draft and that asn 1 sequence blob if you decode that i think it doesn't actually include the value for like mac address that's correct"
  },
  {
    "startTime": "01:22:01",
    "text": "right so i think what that example needs to have some value set for mac address and whether it's a dummy value actually included value for shipping it back i think that's what should happen as opposed to going off and defining another choice i think sean needs to join the design team i i would agree okay all right i've been volunteered and i'm willing to do that all right so so i'm just going to skip through the next slide to tell you what i think we've just decided not to do okay um so the other choice was to basically make do something new maybe even put it at a new end a new uh uh end point so you wouldn't say slash csr attributes but csr better attributes or whatever and we would return a completely different thing and uh the suggestion we had was actually that you know maybe these are the three things that we care about having values for and that if there were more they would be added later with a new document not necessarily by uh by an ayanna or anything so i think we've just decided that we're not doing this does anyone disagree with that i'm very happy not to do this so that means less i think my code may require no changes which is even makes me even more happy there and that was it so that was the discussion this is a squirrel i saw last summer all running any other comments no okay sean you will receive email about this so you gave him the bag i'll i'll be there i'm just saying if i get donuts from tim hortons i did not give this girl the bag the squirrel in fact stood in the line and got his own stuff just just to clarify that you know okay great uh i will i will bring i will"
  },
  {
    "startTime": "01:24:01",
    "text": "bring sean donuts in july there you go i'm not in the queue sean did you throw out 82.95 yes good i know what that is great uh glad to see we're making progress uh although it's uh it seems like you might be changing directions a little bit the next uh presentation is about post quantum keys or quantum safe keys and i'm not sure who's doing the presentation of the of the people on the draft this is the right route this is the nist one the lamps nest because oh okay it's mike osborne who's gonna do it um sorry i was just trying to get because the the list of documents doesn't have titles from the documents and them it has file names which is this was is a quantum safe keys okay uh i thought i saw there he is so first hi everyone this is my first ietf meeting so it's a pleasure to meet everybody and um unless i understand a bit how things work here closer to the mic okay okay just uh um just to say it was it's my first uh my first meeting here so we um we've been working in this area for a while um it's going to go into"
  },
  {
    "startTime": "01:26:00",
    "text": "um let's say maybe we go to the first slide essentially so this is a piece of collaborative work um around post-quantum crypto we've been very active in this domain uh with with some uh collaborators um the challenge that we've seen is that the um nist when they were looking at standardizing this and the round three or the fine this should be announced this week is they really haven't looked very much into how keys are serialized for the competition it was just required to have a a single blob that was what the api required and so there wasn't really much thought put into um managing um you know how keys are serialized and identified and things like this um it's kind of a lot of people have picked up on it to say okay for example you can i um not having to look at the keys and just identify it with oit it's very nice you know there's no more passing of keys it's simple um however the there are problems with that sound sounds really nice in theory but i'll come on to why that's that's uh that's not not a very good practice um if we look at the structures of keys so keys um they're it's an implicit structure now um that's going to depend on whichever of the algorithm strengths is selected which uh version of their algorithm have been lots of versions already going through the different rounds um and there are a number of hardware related um alternatives proposed so you can as a there's a lot of um just a lot of different algorithms that you would have different ids that will need to be tied to some form of keef key format um so lots of variants if you start tying those variants to hybrid schemes it's just a combinatorial explosion so we also look at open quantum safe we have a test server up with over a thousand hybrid"
  },
  {
    "startTime": "01:28:02",
    "text": "uh quantum safe and and classical key formats and that's only a fraction of the ones we could have implemented so um and we have lots of problems with interrupt testing just because these things are evolving these things are in the field and we just need to figure out how to manage the complexity you can go to the next slide please as i mentioned it's nice in theory to have uh an implicit key format tied to an oid um because um people who design algorithms that they they're all security then they say okay there's no passing involved you remove all of the passing um vulnerabilities that you can build in um you know in practice as i mentioned these algorithms are deployed we've been deploying quantum safe algorithms for over three four years now we see that legacy systems simply do not support the size of the keys for many of the new schemes this is for in our example i work for a large um ibm large machine manufacturer our largest platform cannot support this even the smaller sets of keys for um for a lot of the algorithms so there's a lot a lot of legacy out there which is just gonna struggle so um so and it's this aspect of getting keys safely to algorithm engines which is kind of not really looked at from an algorithm design perspective but from a secure implementation perspective is really important and that's where most of the problems are so actually most of the schemes proposed and this they they detail compression schemes so in a very unstructured way um and we've just found in practice that these schemes are required so um so we're trying to avoid a bit the mistakes in in the past i understand it's very compelling oid key format very simple but we know that we're going to have to compress keys we know that they're going to be evolutions of algorithms"
  },
  {
    "startTime": "01:30:00",
    "text": "and so what we're trying to do is design a format that that handles that complexity in the future rather than take the simple option and then just add then these exceptions as and when they come that's a bit the problem that's happened in the past with with other algorithms you can go to the next slide please yeah would you like to take questions now or by the end well however however it works process-wise this is my first meeting so it's your choice basically i'm not going to take you now there are four people in the queue oh sure michael richardson here so um so you're telling me that basically um you if i if i if i present a certificate to some systems that they just blow up because it's just too big for them is that what you said actually more on the private key side so probably and so some there are some compression schemes for the public key but absolutely yeah okay i wonder if we should just start issuing certificates you know with some bogus extension that has a megabyte of random data in it just just to kind of you know to test out something to grease out the systems and see who's going to blow up and kind of present some stuff like that that would that would break some things intentionally that's exactly what some experiments have been done by certain companies they have actually you know just put some junk in it exactly to see where things in the internet break exactly but that you're talking about private keys and i think that you're now as i understand you're now really talking about about hosts or systems talking to their cryptographic engines their physical hardware engines they can't even get the private key across that interface well essentially if you want safe algorithms you need to get the keys safely to them right and essentially so there's no point having very strong algorithms unless you you manage the key and those interfaces which i think are somewhat hardware are breaking as well as what i think you said absolutely okay so also lots of protocols any any protocol where you need to transport keys any any kind of like internal framing mechanisms for key movements anytime you want to use uh okay whatever"
  },
  {
    "startTime": "01:32:01",
    "text": "this is just a whole just a whole lot of legacy which is going to be very challenged purely with quantum safety let alone hybrid related things okay sean okay so one of the problems that uh ended up happening with compressed keys before was that there was ipr i assume that there is no ipr with respect to any of the schemes that you're proposing so um let's say we we're contributing to some of the candidates and most of the candidates certainly the ones we propose to are all ipr free so it's less about the compression schemes it's more about marking uh or let's say the the framing of keys or let's say the the um you know being able to identify when you have a compressed key and things like this it's not not how these things are compressed more how they are communicated that we're concentrated on but certainly what the the the key compression i think that's a that's a decision for nist at the end of the day which um in terms of life yeah so i think i think i think nist is i just want to say that the last time that this came out was for elliptic curve stuff and one of the reasons why no one would touch it was because we couldn't get good terms and so i think if we're going to adopt a scheme we just have to make sure that we understand that there is there isn't and i think what you're saying is it's not my problem it's whatever whatever agreement this comes up with the competitors and that's great thanks actually what i'm saying is important to be able to manage compressed keys you know whether or not um which which schemes and which compression techniques are used that's something else yeah i'm not sure this is the right way to go um the most of the schemes that have some compressed alternative are different schemes they are not compatible with the uncompressed version you can sometimes do all sorts of things with secret keys where you pre-compute some stuff you can expand the lithium's matrix but that's all on the secret key side and i don't see why you would need that for public key representation yes so there's a couple of there are a couple of schemes that have public decompression but this is more"
  },
  {
    "startTime": "01:34:01",
    "text": "essentially about from uh more related to the private key and being able to identify essentially what key um yeah so it's more than about the management of the private keys that this is uh okay then you also still need to be careful that like uh the compressed variants of rainbow i mean rainbow's dead now but the compressed variants are not the same scheme as the yes of course but the schemes which currently look and this are looking at the compressed alternatives to those what exception of rainbow is they are just artifacts of how you can compress the keys in in a way that is compatible with an uncompressed one so you have a trade a trade-off with key expansion versus um key size uh and then the other thing i expect all the non-uh sha-3 variants to be murdered by nist very soon i have the understanding that none of the um submitters intended for any of the aes or shadow variants to actually get standardized um there's two things one's being standardized ones being used so there are a lot of schemes including rainbow for example was already being used but and also dilithium and kaiba they are used already in a number of industries things this is a bit the problem that you have with anything that's about to be standardized because standardization takes a long time they still they start to be used you start creating legacy then in order to manage complexity you you end up with standards which are very um very evolve very awkwardly so what we're trying to do here is let's say for this aspect look at we know what's coming that we will need to use these compressed keys which take out of the equation it's really about how to manage those appropriately and and safely okay the management yeah one last question with regards to if you the symmetric primitive that use inside really makes obviously all the test sectors"
  },
  {
    "startTime": "01:36:01",
    "text": "difference etc so that's a different algorithm what is the problem with just assigning more oids the size the size purely in size even it's it's uh so one is managing the um the uh what the no id actually references to um the other one is then how you handle and manage um non-expanded key formats how you actually manage and understand what you have okay by the way we just want to let's say reduce complexity around passing of um of private keys uh so thanks for bringing us to the group this is daniel gilmore um so it sounds to me like this is just about private keys right we're you're in this presentation you are not talking about trying to represent public keys at all here that the main concern you have here is about private key representation is that right exactly it's more so the focus is really on managing complexity and it's really uh focus exactly more on the private key side of things yeah right so so yeah it's useful to have that clear because otherwise we're going to have people going off about public keys as well okay maybe an issue but we can we can tackle it separately so my question for you is this if an implementation is choking on uh seek private keys that are too large presumably that implementation doesn't even have an implementation for uh private key for that algorithm because it can't because the key is too large so where is the issue with just saying when you know when you're ready to handle keys of algorithm x make sure you can handle keys of the appropriate size for algorithm x as long as there's an upgrade to handle algorithm x presumably that upgrade you also tackle the parsing structures that have hard-coded limits and extend those"
  },
  {
    "startTime": "01:38:01",
    "text": "hard-coded limits what why is that because there's a lot of legacy it won't be able to handle the the uncompressed keys so you're saying that there's like a part you're concerned about parsing layers that are uh algorithm agnostic um the identification and management thereof so at the end of the day one of the goals is is essentially to provide the smoothest path for a transition to a quantum safe future and that essentially means um in some ways it's also the widest adoption and if i look on the systems that we've we that we have worked on is essentially there are the there are limits which make it very difficult to expand certain system parameters to handle private keys so it means if you can't do that then um you are you are was maybe one um of the nist alternative quantum safe algorithms will be used but it will prevent a a lot of systems from being able to use um quantum safe crypto can you identify the specific parsing layer uh limits that you guys have run into i mean it sounds like that you're talking about a parsing layer that is independent of the algorithm implementation yeah it's less the passing layer so essentially if you need to transport a key to to an algorithm engine somehow i mean yeah at some point you have to it's it's any framing any protocol where you're actually moving that key essentially wrapped or unwrapped or whatever it's um um can you identify one of the implementations that has these limits just so i can get a better sense of the kind of limit you're talking about like is this like open ssl issue is it a uh nss issue um it's it's anywhere where you're kind of using slightly slightly more secure methods when you're not just using a file to save the key somewhere so um"
  },
  {
    "startTime": "01:40:00",
    "text": "um yeah it's any um without going to maybe we can respond with a list of systems that we've come across that would be great i think i think having a concrete list to look at would would help to characterize this because i i don't fully understand the problem without looking at some examples i think thank you uh you said that you were worried about legacy systems not being able to handle these keys but legacy systems aren't going to be speaking a pqc algorithm anyway so why why do you care that they can't get well legacy platforms i mean legacy platforms not systems so so essentially any uh if you build platforms or you build you know systems that actually you can't actually um manage keys just but just because um because they're too large for the parameters of of the systems and the protocols you've used um i'll give you an example i've got a mainframe platform yeah sounds like a very large platform um so um there's a lot of keys you just can't use just because you can't transport them securely they're too large outside of the design characteristics so if you want for an existing platform or or or that's a um edi system or something like this where you do need to transport keys around and um isn't that platform gonna have to be changed to support well that's the point no not if you use compressed keys if you use compressed keys then you trade off the size of the key with the ability to actually uh uncompress it or regenerate it so it just means that you're able to a lot of legacy a lot of systems where you where the uncompressed keys you can't fit you could then you can use quantum quantum safe algorithms all right we have any more questions oh no nobody in the queue at the moment so okay yeah sure sure"
  },
  {
    "startTime": "01:42:03",
    "text": "yeah so that's the goal essentially i mean we've seen how difficult it is in in in applications and it's really about making sure that um the pqc or quantum safe algorithms can be used by the largest number of applications and um that's a very gonna mean a lot of them are going to need to use either schemes with very small keys and there's only really one and or use compressed keys um the other thing is a lot of this or as part of this nccoe effort to sort of facilitate the migration to quantum safe schemes um if we if things tend to happen sequentially and in an uncontrolled way so um actually the more that we kind of experience what we've been doing essentially experimenting with interoperability and understanding how to use these things in real systems the more we can do in parallel which is why we kind of it's a bit early a lot of people said why don't you wait until the to the final in this selection and then and then work on this and that's because actually there are some things um that have fed back into the the different schemes so for example uh in in this piece of work um so it's it's really just about make widening the aperture for for four systems to become quantum safe actually um the approach is really just to think about the complexity ahead of time not go for the easy case and then add stuff on when when things don't fit um the um so it's really about um also there are various ways to actually um to come up with oids for uh so how you create oids so so in terms of you know whether the whole parameter set gets represented by a key or not i mean with these uh with with certain of the lattice schemes they are that they are matrix so"
  },
  {
    "startTime": "01:44:00",
    "text": "you can actually put the matrix sizes in the in the oids and things to simplify um essentially just to simplify stuff um and then um the so this is the identification algorithm approach and then the high level um just the high level api considerations essentially the optional choices recommendations for when you would want to use a compressed key format and when when when not what the trade-offs are stuff like this so so generally a kind of like a guideline for um the the usage of of of private keys in um in in in a kind of a future-proof way for for for next generation um algorithms go to the next slide please i think this just kind of like says how or suggests how we think we can arrive at such a scheme so it's kind of whether this is in informatory or whatever just i think um it's not something that that there's a got a lot of wide uh visibility just because a lot of companies have been waiting for some fine on this standards essentially so the problems around private keys um this thing with interoperability and stuff so we've already had some new numerous interoperability challenges because as algorithm evolves obviously the private key formats evolve and if you can't manage the transition so so say we have to tweak a parameter because of a security breakthrough for example in rainbow then we we have to sort of tweak the keys uh the algorithm a bit which means the keys change so yeah in some systems if you're using the older keys you might want the ability to migrate to the using the new algorithm but with the old key that's that's very difficult it's very messy and complicated if it's just an in an implicit serialized blob um we have shared this with the cryptographic community we have um"
  },
  {
    "startTime": "01:46:00",
    "text": "received feedback from a lot of the ski mortars we are ourselves authors of some schemes um and the approach has already um identified a number of challenges or caused actually some of the specifications to be updated because they weren't particularly clear in um in in in the formats of private keys so it's it's already a couple of years old this this work and i think we're just looking for the best uh place to give it to to sort of help help the community with awareness in this area um i think next slide please and so um in terms of what if you need a structure to be able to manage things like uncompressed and uncompressed it's what does that structure look like what what are the trade-offs when it comes to complexity in passing obviously we want anything that needs to be specified needs to reduce any uh potential vulnerabilities um so that's a debate because there's many ways to do that um there is complexity it's just a question at the end of the day where you want to manage it um you can't ignore it it's a lot of alignment with other activities the whole set of separate questions around hybrid which just amplifies the problem essentially um um yeah and then um there's things like as i mentioned scope adjustment as soon as we've we've originally we created a document for all of the nist round three finalists and all the alternatives and um happy to debate what scope or what what else should be in there in terms of there will likely be um schemes which drop out um when things are announced next week there will be alternate schemes brought forward for round four so um all things are happy to discuss what makes sense what what what best"
  },
  {
    "startTime": "01:48:01",
    "text": "serves industry in terms of having some clarity going forward about how how keys should be managed private keys private keys should be managed that was all i wanted to say i think that was the last slide and let's see as a question i guess i think uh i'm in the key here this is daniel um so uh i had one other question that i think wasn't actually covered here which is whether you are looking at stateful signature schemes as well it seems to me that stateful signature schemes would require even more infrastructural overhaul than just expanding key fields uh key sizes right are are we excluding stateful schemes from this because if staples are included then it seems like there's gonna whatever transport uh uh you know plug-in mechanisms we're talking about are going to need an overhaul anyway right that's correct that's a scope question so again that's up for up for debate or discussion uh it's um there are a lot of complexities because of you know the feedback mechanism when keys are used uh you're absolutely right um it is another layer of com complexity state we're using stateful um um hash based signatures but really open to whether if they should be in here or not it's kind of uh so so my observation is just that if you're gonna be dealing with a system overhaul for stateful signatures then surely that happens at the same layer that widening the field for secret keys or private keys would be done and this strikes me as injecting a fair amount of complexity into the overall interoperable ecosystem for the sake of not touching a few uh uh implementation layers um just to widen to widen the width of"
  },
  {
    "startTime": "01:50:01",
    "text": "whatever you know wherever those limits happen to be and if you're going to have to why you know tamper with those infrastructure layers to handle stateful keys as well then i i would prefer to have less complexity in the interop part of the systems that's just my observation yeah yes yeah complexity will come like i said the aim is is to manage it you can't ignore it and it's a very good point with the stateful hash it because this is um this adds a really very different level of complexity so this again is a scope thing very very happy to sort of um have that debate what what you think makes sense but you will not get away from complexity because systems will need compressed keys it's really that simple question is when you when you when you face the problem whether you're trying to manage um manage it up front how it should evolve or or you kind of evolve as as these things come up that's all it is that discussion okay julian yes uh hello everybody so maybe that's my first attendance to the meeting so hello everybody i'm julian pratt i'm working for kryptonite security so dealing mainly with quantum safe algorithms and my question is about um the opportunity of defining all the compression formats because i get i think that there are as many compression as there are implementations so isn't it a little bit tricky to try to be exhaustive and to define the parameters well as you made in your draft rfc i mean with many details uh because i think that there will be more tricks that will come later and i think it's more a kind of the work of nice to define the key format than our work i guess"
  },
  {
    "startTime": "01:52:03",
    "text": "no actually we spoke to this and they suggested here um [Laughter] yeah but it's again a scope thing so we also believe that compression mechanisms parameters will evolve so how are you going to manage that you just at the end of the day with that with a million oids and and sort of a million different um specifications to go and look at that's one way of doing it but if you don't think it's a good way yeah so you've got to start somewhere it's just again so just how how you want to manage the complexity going forward for something that is complex just because things are much larger things um are evolving you know that's how it's just an attempt to help um manage that journey going forward and what you're talking about is scope so in terms of when things change what to do when things change i mean the point is that round two algorithms around three algorithms are already in the field and being used so so it's kind of these things already need to be managed by the organizations that have rolled these out so um then comes along a a kind of the nist standard then they'll be probably uh i suspect there'll be some changes in the parameters so that'll be another one and it's kind of and i suspect after that all you need is a is something like a breakthrough on rainbow where the lower parameter lower strength algorithms get broken and then you need to ratchet things up so they'll change and that's kind of um just gonna just gonna amp unless you manage it it's gonna be difficult that's all i think we're trying to communicate okay uh scott uh okay okay uh about stateful this is scott floor uh about stateful base uh uh is a moving key uh private keys for stateful based signatures uh that requires a and a whole bunch of other problems which need be addressed i believe this is way out of scope for"
  },
  {
    "startTime": "01:54:01",
    "text": "this draft it would actually somebody would have to sit down and work out all those issues uh separately totally independent work thank you yeah i i believe you you need a protocol you need to define protocols to manage stateful have signatures properly and securely and that is not really what that is a different scope than that at least the simple cases for the um for for the stateless themes we're looking at i i agree but um okay i i'm closed the queue so we're going to wrap up this presentation continue the discussion on the mail list and try and squeeze in one more presentation in the remaining five minutes which is sean who's going to talk about how to put post quantum keys into certificates the it's very clear to me at this point that uh we're not going to get any further in the agenda and we'll have to schedule a virtual interim so tim and i will uh put together some kind of a a poll to figure out when to do that and um sean over to you so all right so hey so this is an individual draft that i'm requesting the working group to adopt there may be one or more of these because this is specifying the algorithms for our sorry the an rfc 5480 like our uh internet draft that hopefully will move to rc status which specifies how to put um post quantum uh chem certificates uh keys in certificates next and so what's in this right basically just it's actually pretty short um"
  },
  {
    "startTime": "01:56:00",
    "text": "there's not a whole lot in there because basically all it's specifying for the pq kim stuff is the format for the subject public key so it says you know what oids are we're going to put in there we're not defining any we're going to take what this gives us parameters none we're just going to use an oid to specify whatever the two security levels are leave it at that we're trying to learn from the complexity that was um i think hampered the deployment of elliptic curve with all the options that we had we're just trying to keep it simple um the key format just a bit string again if you remember the elliptic curve had the first byte had some weird values to tell whether it was compressed or hybrid or whatever we're just gonna not expose that let the crypto let the crypto standard specify that and let the crypto engine deal with it um key usages just set one it's only one that really applies uh get rid of everything else and again in this in this format this is uh this is the one key one certificate option next uh we got a couple of questions whether to do one or all when i was writing this the idea was that we were going to put all the pq chem candidates and then the last time we talked it was like well what about all the signature candidates too panos asked me he's now one of my co-authors i guess that's something else i should mention is that uh i got co-authors that actually implement stuff so it's not just me writing it so um panos and uh jake from aws and baz from cloudflare to uh look at this stuff um so we i we could put all of them in there we could put one and panos is like why did you do that and i said well that's kind of what we did and like one stop shop is really nice and but that's not really the the strongest of recommendations so i think we can kind of take it to the list to decide whether we want to have one draft with all of it or multiple drafts that would allow things to progress differently panos has a bunch of reasons for why we might want to split them so right now it just has one and luckily missed hopefully he's going to pick next week or by the end of next week and we can just rev a version and put put some values quote unquote in there and we want to prohibit some key usages"
  },
  {
    "startTime": "01:58:01",
    "text": "that's it next next i guess i double up the slides what do we want working group adoption thank you i know that was super fast hopefully deb got some of that uh so um i'm glad to to hear the use one away to define the algorithm and parameter set uh and then just put an octet string with the key in it that seems straightforward and is going to eliminate a lot of the silliness that we had um with you know signed bits for dsa and so on um this this i think is a good good thing um mike you have uh some comments mike we're not hearing you mike still not hearing you mike all right so let's go to panos and see if mike can figure out his microphone problems yeah can you hear me okay yep i just wanted to make the the point that you know for for one scheme per draft because i think you know it's easier for an implementer to follow and comply you know it's easier to review in the in the list and also you know camps and signatures have different uses right so probably it's cleaner to have them separate"
  },
  {
    "startTime": "02:00:00",
    "text": "that these were my basic arguments for cleaner one one draft for cam one draft for signatures thanks okay mike we're out of time is did your does your mic work not hearing you i should say that i know that um mike's got some other drafts in flight and flight two we are working together to make sure that we provide uh the same answer so that what his draft specifies and what this draft specifies at least line up from uh we we are out of time like i said we'll schedule virtual interim to uh hit the rest of the agenda thank you very much and uh clearly we have a lot more to do coming and this is expected to make their announcements by the end of the month so we should know in the next week or so thank you very much and for those of you in vienna safe journey home thank you alexi for punching the slide buttons thank you bye good"
  },
  {
    "startTime": "02:02:00",
    "text": "i have no idea i have no idea"
  }
]
