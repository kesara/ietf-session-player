[
  {
    "startTime": "00:00:05",
    "text": "okay ready yes we're gonna start I think yes I think we're gonna start yes hello good afternoon we will start the roll meeting welcome um okay so here's a note 12 if this is new to you please read the BCPS and the documents shown here and to one point I want to emphasize is that we want to have a friendly and cooperative and positive behavior in the group meeting tips please remember to register to that session if you're remote you have uh joined already through miteko if you are in the room join through the on-site version of the tool and if by any mistake you register you joined through the the full tool make sure your sound is turned off so that we don't have local Eco here if you're remote please and and want to speak make sure you use a headset otherwise we would get ego as well most likely"
  },
  {
    "startTime": "00:02:00",
    "text": "uh yeah presumably you know the agenda already and the one point I want to emphasize is if you need technical assistance with the tools here's the URL to go to yeah yeah I don't know um we are taking notes on code EMD the link is here on the second line please join taking notes we have a micron Ivan already committed to take notes but feel free to join and help especially if you say something ask questions go back into the notes and make sure the your question was correctly understood and your happy with the way it is represented we have a chat on zulip as well and yes if you want to edit the minutes you need to be logged in through the data tracker and that will serve uh to log into the the minutes as well [Music] give a working group a status then we are going to provide some more details in current documents like NSA audio variable normal priority mopex are in FD then Pascal we provide the update on the projection with the shipper document is in progress then Pascal we provide as well they work on six long multicast registration and then we have open floor for further comments uh it's okay some comments on the agenda okay okay we have a message on the main uh display"
  },
  {
    "startTime": "00:04:01",
    "text": "here in front of us that says uh shut down yes no I don't know how to say no so if some some technician can see that yeah right here thank you we put like no but yeah I don't know how I think I have no control [Music] no not my computer this is anyway we can do without it [Music] anyway so maybe yeah I don't know okay um about the jello draft we are going to provide some more details and about the blue double projections um is going to be discussed today yep so for the milestones we are a bit delayed with the double projection so we will need to ship it as soon as possible and then for the jello ones uh we need to put the efforts on completely those works too um next slides okay okay now more details on document status okay so we're going uh we're going through the list of a few uh drafts that we have in the group and we don't have the offers here to talk on so we have an X NSA extension uh"
  },
  {
    "startTime": "00:06:02",
    "text": "just to remind everybody this is a uh draft that proposes a new objective function and a new metric container extension to carry the set of parents of a node in a Dio and that allows a node that receives the diode to know its potential grandparents and so we had the adverse review in March asking a few questions providing comments 20 of those about 20 of those who are noted as major comments and well yeah the authors are still working on them so please uh yeah I'll we keep bugging them but we really want to move this forward we need a revised draft before we can send to our ESG so that's NSA extension that we have in the works okay for the variable basically this work introduce a dial options or the road request options route replay and target options as well this work he introduced a new multicast address with Lincoln link local scope all the variable nodes this draft as well use the same author operation of P2P Ripple but they don't Collide for example because they are running different Ripple instances so this is at the main contribution of this work yes and based on the last comments in the mailing list they were a discussion from the outdoors requesting feedback about the Ripple instance ID pairing how can you uh detect when you have a lot of audible Ripples and connections how can you the intermediate routines"
  },
  {
    "startTime": "00:08:00",
    "text": "identify the objective function so the authors propose to use a triple origin note Target note and ripple instance ID uh okay they proposed that but there was not the comments on the main list so we believe that this is accepted as it is um yeah then okay um a new version was published on the version 15 was published on September basically this version address the ticket one um the discuss of uh John scooter basically the comments were to improve readability then address as well we believe the address ticket to bend discussion discuss um to basically the discuss provide comments to improve the protocol um the outdoors we believe I have addressed all the comments they have replayed to them but we have not heard back from them of course because he changed position so we believe that those tickets as well are addressed then we have as well Pascal review um but this one is the ticket number three there is some comments that you did Pascal that still are in the in the document they were not fixed in the version 15. so um do you do you know if the version 15 addressed your comments okay okay so we will take us an action point but yes there are some comments that you did that there were not others they were still the fifth version 15 with these errors so um then the review by contract uh it was addressed and we got comments in the"
  },
  {
    "startTime": "00:10:02",
    "text": "Middle East in October so the next step will be a new last call when all the issues are closed this basically the Pascal review okay yeah [Music] um Michael Richardson so this document's kind of uh come and gone for um seems like several years to me um I I look to see if some of the authors are on the on our meeting today and I don't see them um and so I mean there are four authors for a reason is so that we can deal with authors different having different amounts of energy and things like this so I'd really like to see these others authors maybe could get more involved and finish this document and get it out um otherwise it just it it's I think very hard for all the reviewers to hold on to review for sometimes years and then figure out what's going on um so I don't know I think the working group we should just kind of put a bit of a deadline on on this and if we can't move it forward by you know January 1st or something that we should just take it off our list okay um yeah thank you Michael um yeah well Charlie replied that he will work in last weeks and in a few weeks but yes we need to put a deadline for to get this closed um then foreign priority well we have these seven issues open"
  },
  {
    "startTime": "00:12:02",
    "text": "um so I think Michael you will work on that when you have time right based on we understood yeah I'll get on again okay thank you very much um then mopex just introducing for those who are new to the group The Ripple operates in multiple modes and we have a mode of operation field in the instance that describes the mood of operation so that no no if and how they want to join that instance and we've run we we are running out of the the values in that field so this draft is about extending that field mode of operation hence the name model preparation extension um so again that's a draft that has been sitting there for long and we want to revive it as soon as we have the first ones out of of the door and we have a ticket and a few discussions on flags that needs to be agreed on you then fast forward rotary class detection in Ripple so this work was at the working group um is proposed as an extension of Ripple introduced a root note for detection options that is carried in dios and this this document is well proposed two roles uh acceptor and Sentinels antennas are the ones that are neighbors of the road and then taking monitoring the route and as well they have introduced a counter conflict-free replicated counter"
  },
  {
    "startTime": "00:14:00",
    "text": "um then it was present in the last interim meeting and there was a new version published recently basically with the editorial comments um then the questions here um basically were based on the discussion how the Sentinels can detect if the root is alive or not um so for example um yeah what happens when the Sentinels um don't hear each others those the algorithms still detect the crash of the road yes um then what if most of the direct links to the root fall but the root is is in fact alive okay as well here the roots take part in the monitoring so they they can the root knows when there's something else are full and then if it's um how um the root get back to us that status up basically to get a new DOTA version um then there are some other questions that they still need to kind of contribution of the working group for example and where the counter is located and it's a it's a for example in the option tie option and as well um for example the when um if the several Sentinels have different threshold in order to detect if the root crash how you which one you take into considerations um well actually you take the one that has the lowest threshold but I think I as well have to be explained a bit more into the document um so these are basically the last questions that were present in the"
  },
  {
    "startTime": "00:16:00",
    "text": "mailing list um I need more of the discussion or contributions and reviews and as well I think we get the document Shepard Michael do you want yes thank you so Michael is the documentable of this document and probably if all these issues are addressed we just can't move forward with this document do you agree comments okay what else for this yes okay I think Pascal now it's your turn try this oh unless you just just tell you when you're on YouTube and um this is about the um right projection draft for repo so just to give a sense of positioning a sense of History we basically have a main Ripple specification which is an average purpose distance Vector protocol where we save energy by optimizing routes from and to a route as opposed to any 20. and when we want if which because his twist is kind of a rare traffic in usual iot Networks now when we want to optimize device to device Communications there are basically two extreme"
  },
  {
    "startTime": "00:18:00",
    "text": "Solutions on each side I would say of this main specification the first extreme solution is to go fully into the Malay world and this is what the aodv specification does the one that we just discussed and the Charlie is is editing so this is a completely reactive protocol where a device that wants to speak to another device will flood the network with a route request message which is effectively transported by Ripple now the the other complete extreme is when the East-West path between two iot devices is computed by a central controller which is more the traffic engineering space and you would say hey why do I need traffic Engineering in my sensor Network well that's because not all sensor networks are metals there are effectively cases where big robots or industrial appliances sensors actuators plcs need to be routed over Wireless and as it goes Ripple is a fine solution for this repo will build a main direct sck graph for the devices to reliably talk to the root and through the route to the controller but then for any particular route between a sensor and a PLC or a PLC and an actuator that will be the controller that will set up the optimal path with enough redundancy between the two devices and repo is a protocol of choice for effectively installing that path and for those who attend row reliable and available Wireless row will be the place where we optimize the energy in using those double projection projected routes so there is a complement between what we do here which is below the"
  },
  {
    "startTime": "00:20:00",
    "text": "controller to set up the traffic engineered path that we call a truck and a row where we'll effectively use that track but just the subset of the Dual dag between source and destination that is enough to guarantee the level of reliability that we want for for the flow we're talking about so see aodv has a really mobile adult networking extreme of raw and see though projection on the other hand as the fully controlled traffic engineered side of Ripple and Men Ripple covering like the overall Center of that picture press the button and none of it thank you no not better um anyway soapy so um basically what that's exactly what Dow projection is it's a centralized Rod computation method whereby a controller which is kind of hidden behind the root will set up geodags within a geodeck so typically you will build a main geodag that connects to the root which has enough redundancy Etc it's going to be a non-storring mode Leo deck why do we want that it's because non-storring allows the route to already know a lot of the topology of its Network and what we will do with our projection is extend that knowledge of the topology with sibling information so the the controller can effectively build optimized East-West routes we build two things one of them is what we call a segment a segment is something that complements a"
  },
  {
    "startTime": "00:22:02",
    "text": "geodag it's it's a Serial Set of of routers A to B to C to D and that's that allows to connect the dots so once you start doing this the first usage that you can have is within the main deal dag you may decide that your Source route path now can be loose as opposed to strict so you know with repo non-storring mode you have this situation where you have to to put all the Hops down the geodag inside every packet and that might be a long list when you want to compress that list you basically want to install the dotted lines the the connection between the dotted lines as storing mode routes inside the non-storic mode geodag which effectively Builds an hybrid solution with the main geodag expressed as non-storring but the data flowing along storing mode routes which connect the dots in the routing header so now your routing header can become loose and it's up to the controller to decide which specific routes will be optimized because as you know the main reason why we are not operating storing mode for most cases is because we don't know that we have enough memory in the devices to store all the non-storring mode to store all the storing mode rods here it will be the controller the root which will know the capabilities of the devices and only install as many routes as a device can actually support so it will be up to the controller to decide hey here are the path The Source right path that are used extensively let me compress these ones it's more interesting to save energy within the capabilities of the nodes along this path so that's what the segments are a segment can be connecting"
  },
  {
    "startTime": "00:24:01",
    "text": "the dots in the main geodag or in what we call a truck so track is this East-West path that is also a ripple geodag that is also installed in non-storring mode just like the main tier deck and then again there can be segments to connect the dots okay so the track is loose structure where that basically gives you the skeleton of the geodag and how to go between one node and the next node in that skeleton is using again a segment but this time a segment in that track as opposed to a segment of the main geodag so you can see the domain deal dag is just like the track zero and the uh optimized path between A and B are geodes as well just like the main track next slide please so this is basically representing what we build I've shown that before there are basically two ways of installing projected routes one is storing mode the other is non-storring mode in Black in the middle you can see a non-storring mode I'm sorry storing mode pidau it goes to the egress of the truck of the segment I'm sorry and it will fly to the Ingress of the segment and the increase of the segment answers if you look at it that's the way that works a story mode though starts at the end of the path and flows towards the root which is the Ingress of that path well same thing you flow from the end to the beginning of the segment so it's just a normal pedial it's just that instead of being generated by the destination like we do in normal Ripple in this case it's it will be injected really projected by the route into the the egress of the segment"
  },
  {
    "startTime": "00:26:02",
    "text": "and now what we represent in in Gray on the left is the track itself and the track itself is a source rated dotted line thing and in this track we have relay a relay B and decrease e which are connecting in Ingress I's geodag so what happens to build it is a single non-storring pidau that goes to the Ingress and the Ingress will reply because the Ingress is the one which will have the full topology of that track it will not know the segments but it knows all the relays so a b and egress and how you go from A to B well that could be through another track which means which means an underlay inside the underlay or it could be through a segment like we do between relay A and A Class E so basically you can see a track as an underlay that is dynamically installed by Ripple in order to shortcut to do like a wormhole between a an Ingress and an egress and it is installed on purpose by the controller and the amount of redundancy that you can have in this geodag and the the reliability of the links Etc it's all known from the controller so the controller in order to ensure a certain amount of reliability will provide enough redundancy in the possible path in that Geotech and then as I said row we'll use that dynamically to optimize spectrum and energy so you see in this slide two main lags basically one is on the North and one's on the south we call them legs and then we interconnect the legs with not exactly north south segment but East-West but up down segments in row there is the concept of no self segments which can be used in either direction but in Ripple we don't know how to build that because we only build the attacks"
  },
  {
    "startTime": "00:28:01",
    "text": "so you see there is always this angle you're always going slightly uh to the right next slide please so draft status we started the work group let's go at 29 for all I know um the all the issues are resolved with the latest version which happens to be 29 and it is my belief that we are ready for publication next slide so just to give a hint of what happened so during IHF 28 we discussed a number of things that could be improved or clarified in the document in particular we needed to clarify that each Ripple instance each track is effectively its own rib and that's why as you know we have what we call the RPI the Ripple packet information in the repo packet it's effectively the topology indication which will tell you which rib you're talking about indefinite terms because I see some net members uh it it is also the that net path if you like that you're talking about it's signaled by the Ripple packet information which is a hubby Hub header now there was this this long-standing question about how do you avoid Loops when you can have topologies within topologies when you have dotted line tracks that are joined by segments and then you have neighbors of two hubs neighbors how do you ensure that you don't end up looping looping and to ensure that the Dow projection draft had two methods and we refine or added text to clarify that at the very beginning of the document there are two things which must happen the first thing is kind of classical for those who participate to to multi-topology writing efforts in the past the the the the main thing is the topology if you can go from topology a"
  },
  {
    "startTime": "00:30:01",
    "text": "to topology B by say injecting a packet in an underlay then you can never go from topology B to topology a again because you could create a such a path that you end up looping from one topology You Go reverse versus the other topology and you end up looping so what you can do with something like that is you can take a package from the main geodag put it in a truck but then it has to go all the way to the destination within that track or an inner track which tells you that there must be a partial order a geodag of tracks if you like that there cannot be a loop in the way the tracks are ordered you can always go from a certain underlay to a lower underlay but never to an iron delay which could which could take you back so that's the first thing I think this partial order of underlays now the other thing that that we have because we have different methods we have the truck we have the segments we have the neighbors we have the two hops Neighbors is we enforce and that was the text that whole has started long ago we enforce a strict preference into which type of Rod you're using so if you have a track route a segment route a two-hub neighbor and a one-hub neighbor you always favor the one-hub neighbor if you don't have a one-hub neighbor but you have a two hop neighbor then you will use that if if you don't have that you have a segment you always use the segment if you don't have a segment the only thing you have is a track route then you will use the truck route and then again this is how we ensure that we don't Loop otherwise there was some tags which looked back to the reader which really happens when you have this track so this is this complex complex path if you like between the source and the destination and two segments could cross so you go from this point to this point or this point to that point but in the middle"
  },
  {
    "startTime": "00:32:01",
    "text": "there is a same note so you see which sees the packet with the same RPI information same topology should the rod left or down what segments are you following and effectively since the the next stop in the loose Source route is indicated in the packet this can actually be resolved so it's not a real problem but we we clarified how that happens uh the the last but not least thing that we clarified is the way the multicast dough works the multicast dial is not your usual though it is like a broadcast over the radio medium whereby a node can say hey I'm here here are my IP addresses if you want to talk to me don't look at your repo database just pass me the packet I'm your neighbor okay so it's just a way to advertise self as a direct neighbor to the other guys around now the the cool thing with the projection is we have added the concept of sibling in the dial remember we did that to provide more topological information to the root since we have we in placed our siblings in the Dao we also have it in the multicast dial meaning that when I say hey I'm here I've got a type address I'm also saying here on here's my list of neighbor and for the many guys I mean you will recognize your next uh operating next operator or something I mean the you know the guy which is behind your neighbor and with this you can get to those two Hub guys without the loop so that's why we have those four mechanism effectively in Ripple the track the segment the two hot neighbors and the one-hub neighbors the two Hub neighbors are obtained because we see them as siblings in the multicast now and that's pretty much it um there there were some typos as always"
  },
  {
    "startTime": "00:34:03",
    "text": "you know when you push the the draft when I push the draft and I look at the GFI fan so there was a like main which went a lowercase um in subtitles I guess it's still there I would have to fix it that's when our maintenance that's when I I removed the uppercase m in main geodag because it was written uppercase main all the time and it seemed that the uppercase was not appropriate so I removed that and also when I push some text I pushed it twice with 28 so I removed the the extra copy in the intro and that's pretty much it for me okay thank you very much yes we believe that the Asus were addresses and the question is Raul need to confirm the loop avoidant text yes and I think I saw Howell's name at some point so it's just typing in the chat hello rollers just typed that he believes the newly text handles the comments very good roll comment for yourself I can see that the new section uh essentially goes into details about stating a lot of things explicitly for Providence uh and I've already reviewed section 3.2 and it makes sense to me uh certainly addresses the comments uh you know I'm just trying to check whether it has impact on any other section more or less I don't you know I don't have any outstanding comments as of now so thank you thank you very much okay great thank you very much travel Okay so then we finished the shepherd rifle write up and we press the button okay thank you sorry but"
  },
  {
    "startTime": "00:36:01",
    "text": "it's more work for you more work for you it's not the thinnest thing we've produced and I'm happy to work with you again in the next next way yes let me follow myself any other comments in the room about this the projection while I switched slides yes you need to skip a good number of backup slides yeah uh I just so I left um in that presentation uh a whole history of drawings that were presented during the elaboration of the protocol so that if you guys for some reason want to to explain what the projection is you can dig those slides and and get them foreign so the the other thing I wanted to to present to you guys today is work which is happening at six low for now but which impacts uh Ripple and raw as well and what it's doing is extending RFC 9010 which is a ripple unaware leaf for different types of addresses so the first draft that you're probably all aware of is the one that avoids using MLD in an lln as you know mlds like traditional ND it's using a lot of multicast unless you know multicast is on for when you want to preserve energy so or broadcast really so the same way that we can avoid Broadcasting uh nsna message is using a six slope nnd we can also get rid of the multicast in MLD the the report Thing by proactively"
  },
  {
    "startTime": "00:38:02",
    "text": "installing the multicast and any cast addresses the same way we installed the unicast addresses using six slope and ND so using rfch 505 so what we are doing here is extending the work that we have with our fc8505 and RFC 9010 to multicast and any cast address now as if that was not enough there is a new piece of work where we want to redistribute into Ripple external destinations which are not necessarily hosts but can also be prefixes so how can you inject in repo a step prefix we certainly did not want a ripple Network or did not expect a report Network to be a Transit Network but we've always thought that the Ripple Network could be connecting steps but what we didn't have is a way to install stubs into repo by a node which does not support Ripple so what we can do with hosts injecting their addresses with six slope and ND you know protocol abstract fashion we didn't have for prefixes so that's why we are now having this new prefix registration extension that allows a node which is Ripple unaware to talk to a ripple router and say hey I have this step prefix please inject it in repo next slide please [Music] and by the way I will be presenting that at six flow and That Snack as well because it kind of solves uh some snack scenarios as well so now that the six slope and ND it starts to be a a an interesting family so we started with 6775 which was the well the starting point and and working on it and"
  },
  {
    "startTime": "00:40:00",
    "text": "deploying it we found that the number of issues so we ended up solving them and 8505 is the second and I'll say final version of the address registration mechanism in ND um then we produced 8928 to secure that so that gives you something like sound but probably better because sand is limited in the size of the cryptographic token at 928 is not and we probably are provided 8929 which is the first time uh the aware and address that is registered through 855 is effectively redistributed somewhere in this case it was redistributed in uh in ND itself so it's basically a host using 8505 to talk for instance to an access point and asking the access point to do proxy and D for the host and the proxy can be bridged that would what happened with Wi-Fi because the MAC address are breachable in which case the the basically the router would defend the AP being a router would defend the address of the stay using the MAC address of the stay so the packets will be bridged directly to the stay by the access point or it could be a rotting bridge in which case on the ethernet backbone the router again exiting as access point would present its own IP address well it would present its own Mac address for the IP address of the state meaning that the MAC address of the state would not be visible on the ethernet fabric the cool thing about that is is the layer 2 is becomes very very stable so that's the the rotting proxy in that case uh you can have devices which are not only brigidable breachable Max like Wi-Fi but also non-bridgeable Max like a22.154 so that's that's what it was designed for so that's it nine to nine and since then we have redistributed six open ND in a number of protocols so that there is"
  },
  {
    "startTime": "00:42:01",
    "text": "rift there is Ripple with uh nine zero one zero um there is a draft for ivpn I mean as soon as you have the information that the the IP address is there and with H5 the host can signal a please write to me then the router doing any protocol can inject that IP address inside that protocol but like like I said it was for only for IP unicast address now the six load multicast registration allows the host to proactively say hey I'm listening to this multi-cast address please inject it in Ripple as well or if you're using meeple or something else then it's going to be meeple or something else so so basically multicast registration adds any cast and multicast ripple storing mode as a native support of multicast we added something for non-storring mode which is basically replication at the root and tunneling to the device uh unicast look up David asking somebody it's a Munich okay yeah David David come on yeah um David lumpater um so I just wanted to note that the Wi-Fi setups when they are bridgeable they are not actually mesh networks so you cannot have a bridgeable Wi-Fi mesh setup so those are different types of 80211 operation so I'm not sure okay yeah the well once you reach the router yes effectively if you have a layer to mesh we don't really see it right so so we just see the MAC address of the destination uh if if we want and that's what we do with Ripple uh we'll be at the mesh at layer three and that's what we call rot over so there is the the mesh under which is what 802.11 s would have been doing and then there is the right over which is what"
  },
  {
    "startTime": "00:44:00",
    "text": "triple would be doing and we could effectively do Ripple over Wi-Fi if we wanted to over 15 4 which is a very classical thing [Music] um and then there is this new work I just hinted which is the prefix registration and I will come back on that a bit later next slide please 10 minutes so multicast registration you as you know it's being expected by the wise and Alliance it's covering their needs uh so we we move quickly on it and we get support from why some people at the same time we have beefed up the update rsc6515 quite a bit so we explained uh things like how we use the the Rover and the lifetime when you get the same information from multiple listeners of the same multicast address how do you merge uh the rod ownership verifier and the OU which lifetime you pick um we talked about freshness unless you know the freshness is what allows you to detect to to Route when there is movement so when there is movement the host indicates in six open NDS sequence counter so you know the most the freshest location that's 9010 and the the Ripple carries that sequence and only retains the rods which has the freshest sequence and that's basically the way when they protocols work and ripple is just designed the same way um when you have multiple listeners listening to the same multicaster drives you cannot compare the freshness information from that different sources but if you know the different uh that will come from the same Source through different paths then you can still compare and that's what we explain so the Rover basically indicates what the source is and as long as you"
  },
  {
    "startTime": "00:46:02",
    "text": "can you see different dialcomings from different from the same Source you can still compare the lifetime other one otherwise you can't um the sequence counter I'm sorry and and we have these this something we want to in Ng messages array and others and we have we had that open question with six men basically should we export that option outside of this specification or keep it in there and they recline at the the point and they have not seen really a definitive answer so for now it's still it's still in this document basically the goal here is when you register something to your router you want to know if the router has rebooted and has lost the state that you have registered to it and it's true along the Ripple path if your parent reboots you want to know so you need to send your dials again next line so the probably the most meaningful meaningful change that happened is there were two bits in the the error option and then the message is the dark message and the repo Target option message which would indicate well if the bits are zero then it's a unicast address if the first bit is arms multicast it can be designed it's any cast and if we do that we we have this value 3 which is kind of unassigned and wasted but since now we want to register prefixes why waste this value so instead of saying it's two flags we turned it into it's a two-bit field which we call the P field as opposed to the a foreign Flags we turn that into a two-bit field so we can use the value 3 and we'll use it in the other specs of prefixes so now in this P flag that you can find in"
  },
  {
    "startTime": "00:48:00",
    "text": "Arrow in Dar an inertia if it's zero it's a unique asset address if it's one it's a multicast address if it's two it's in any Caster trash if it's three it's a prefix next slide oh by the way in this particular slot if a document the multicast we say unassigned and it's the other document which is the prefix registration which reassigns it now this is extra burden for the Ina so if if uh that you know we we adopt the document maybe we uh we could assign everything there and avoid having a Yana registration registry for for just the P field admin and try to converge okay so yes so please go down okay so that's the other draft as we uh yes we need to previous slide action because that's intro for us okay um so this is RFC 9010 and what it allows is me to take the mic it allows a device that doesn't speak Ripple to register through rfc8505 proven by rfc8928 an address to a router which is Ripple router and the Ripple router will redistribute will inject that route that host route into the Ripple domain okay we can do it for host the protocol is six dependent D it is independent of the routing protocol that happens above we have these for addresses next slide please let me and now what we want to do with the new uh prefix registration is to do the same thing for external destinations which happen to be not rods or host rods but prefix rods steps so so so if you're doing normal repo you can always inject prefixes Ripple is not just for host addresses it is a routing protocol it's a classical distance Vector protocol just happens to be an"
  },
  {
    "startTime": "00:50:02",
    "text": "isotropic but we can only use Ripple to advertise prefixes if we have next slide please if we have a non-repo device which happens to own a prefix say it connects to a step or it's even a prefix which is inside that device well six slip and ND does not allow the device to tell the Ripple router so the Ripple router can redistribute that next slide so that's pretty much what we're going to to add allowing x505 to register prefixes now if we register prefixes the main question is hey one of the roles of Six Flag ND is to ensure that the address is not a duplicate you have a return code to say hey this address already exists in my network what happens with prefixes well with prefixes instead of managing exact match we will have to have some policies to say hey this prefix can be obtained by this guy because it's within a larger aggregation which we own or something like that so we'll have to have some policies which replace that that is an exact match of the full address wants to auto-conf a prefix or claim a prefix we will have to check that it's a load to claim that prefix and there will be policies but that would eventually allow a device to Auto confer prefix just like we're talking for addresses next slide how that would work well same thing as for roast address but it would be for a prefix the the device down there would claim a prefix through six level ND and the rather the first Super rata will inject that in Ripple now a question that is to be discussed with the group is should we still use NS with the error option in there or should we call that an errors should that be an RS array as opposed to an nsna or anything else because I'm getting a lot"
  },
  {
    "startTime": "00:52:00",
    "text": "of trouble just because we are using NS for the registration so freely we need to invent a new message when that's still possible next slide and as I uh interview we are extending the P field so now the value 1 1 are supposed to be a what is that when these are two flags uh now it really means registration for a prefix next slide and there is basically the flow that you would get with RSC uh eight nine uh to eight so you send a host Auto configuration address on our prefix it's it would send an NS with the arrow if the Rover is a crypto ID it would be challenged for ownership of that ID so the crypto weapons and if effectively the host can prove ownership of the Rover then the DNA will be accepted so the big challenge is the arrow is now a step registration meaning that the target that's being advertised is effectively a prefix so you have a prefix lengths in the error option next slide another tons of things we could be doing but I'm short yeah so it was mostly to to tell you guys that this is happening and the hope is effectively that we have a protocol Independence something which is completely not dependent on Ripple which allows a device to advertise the prefix that triple will redistribute and then the diagram I want to see the previous yeah so what is the destination of our address of NS that you are replacing with uh in this message is the router it's a unicast between the host and the router so the destination this nation is the the link local choice of the router okay any questions I go home that's for me"
  },
  {
    "startTime": "00:54:02",
    "text": "uh just for the chairs can you please uh track that draft yeah just like you're tracking the multicast one and make sure that you know there's coordination with six low yeah yes they are family thank you very much do we have reviewers for this document no do we have reviewers for the coming and someone want to review asking for volunteers to review within the road working okay maybe we can think to the many list uh it's like the next slide should be like the open floor so from the last meeting we have an action point for future works like how do we do Management in Ripple so that is something that we need to start working on something to think as well and research or not on this additional comments well so this is an open floor any uh comments from the group you know is what we should be doing as I said at the beginning we want to ship a few documents that are in our way and have been sitting for a long time and then we can open uh open up new I have news for work so as uh in this mentioned we want to address the management issue of Ripple routers we also one thing that we've been considering for a while is uh putting together the Ripple V2 specification so uh uh pruning some stuff that is not used and nobody"
  },
  {
    "startTime": "00:56:00",
    "text": "seems to be interested in and merging in the various options various additions extensions that we've produced over the last 10 years [Music] and so any comments on that any other stuff that we've you think we should not be missing and no comments yeah for those who care I made the exercise of turning the original Ripple specification 6550 in XML V3 so that was not a small Endeavor but but I I made it so if you want to see the original Ripple uh formatted like XML to RFC V3 can do it's effectively available the draft is expired but it's been published so there is effectively if in the Raw you know Library uh Ripple V2 if you like draft under my name which is for version zero zero the exact copy of the RFC but in XML to our FC V2 this way right thank you for that effort has come and actually I want to mention that you already started but you know should go into uh Ripple V2 the 55 65 50 best draft which we need to revive as well okay right okay [Music] anything else from the floor"
  },
  {
    "startTime": "00:58:01",
    "text": "is hand okay start about the Ripple protocol I just want to clarify the terminologies because this group is using the lln nodes and the six slope and ND they are calling the six low nodes and another RFC by the I think Bremen Kristen Bremen from Germany he wrote that constrained nodes so I discussed with him can you speak closer please so should I repeat again I think in this group or the RPL so they are calling the nodes like 11 nodes and in the six Law Group they are calling the six load nodes they are calling the constant nodes so why not we call this whole stack that having these protocols like RPL 6.5 and D6 low band uh like we we call the nurse like six load then categorize uh later into 6lr or 6 lbr so this is just a comment okay yeah thank you for the suggestion that we harmonize a notation between the various groups uh there yeah jumping they are not actually quite the same but we can make an effort in that way yes the point is 6lm is a logical function s not really a physical node so agree foreign no this is very vague because when we started this we didn't have the 70 to 28 it came after but for the six island thing that really means a node which can play RFC 8505 right so so it's a logical function a"
  },
  {
    "startTime": "01:00:01",
    "text": "repo rudder um Can effectively is expected to be a six letter and it's probably a 6lr as well um but it's a logical function so doing ripple doing six up ND these are logical function in the same node so it's not written type of node the point is if xln is a constraint node or no according to be I mean it's it's just a node that's about six slip and ND we want to to extend the range of application of 8505 to any device you like they will still be six elements because they speak at 505. thank you we've reached the top of the r and the last minute comment then meetings adjourned thank you very much let's carry on virtual interim okay let's let's plan for that so we can have a more time give us more time for Focus discussions okay done thank you thank you thank you very much for me my pleasure to meet you so you know okay let's wait does it stay on or do you turn this off"
  },
  {
    "startTime": "01:02:01",
    "text": "or I mean it's a recording isn't it okay I don't know"
  }
]
