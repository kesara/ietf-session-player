[
  {
    "startTime": "00:00:05",
    "text": "Welcome everyone Thank you Good night, sir Welcome everyone let's get going okay thank you Who is this great? subscribe need some to take notes. Can we get a voice? we need somebody to take notes. Can we get a volunteer, please? Volunteers Notes notes. Anybody? right did you check? Did you? that you take notes? I would say it gladly take notes. Awesome Thanks, Roy Okay, the note well a reminder that this applies here. And as you know, this goes everything that we do at the IETF So please make sure you're familiar with this this Meeting tips. Please make sure to sign in so we know who's and how many people attend this session help us for a future planning and allows you to join the mic if you want"
  },
  {
    "startTime": "00:02:02",
    "text": "to speak And for remote participation, please make sure to keep audio and video off unless you want to speak up Talked about this. This is Mondays, and today's agenda is identity and authorization chain across domains that Brian will talk about this for 20 minutes Aaron will be talking about identity assertion authorization grant and then Neil will be talking about Oath profile for all Aaron will be talking about identity assertion authorization grant. And then Neil will be talking about Oath profile for open public clients and lay will finish up with the oath status search assertions. We still have one more session for Friday so I hope to see you all there. We have Package vendor too there, and interesting topics too Okay, so let's get going Brian Is Brian here? Ryan no. No, Brian Okay, Aaron do you want to go first then? Let's go Brian's fixing Thank you Yes One moment. Oh, you did it I lost it. Now I lost it. You lost it? I don't know what happened it all right now i lost it you lost it oh wait on. I don't know what happened. Oh. Wait. Really, Brian's not going to present first? first It's going to make very little sense without the context of Brian's, but I can go"
  },
  {
    "startTime": "00:04:02",
    "text": "That's fine brad peters not here either either either They must have forgotten that we have a meeting Okay that's fine Okay, hi, I'm Erin Paragi from Octa This was supposed to go after the previous presentation because this draft is a profile of the previous document. So instead, you'll hear about the profile first and then hear about the parent document later. Okay, so for this this was a picture from Sunday morning at about 5.30 a.m. from 300 feet in the air from Vancouver So, yes, this document is a profile of the Oath identity and authorization chaining across the domains, which is a bit of a mouthful of a name of a name. I'm going to first talk about the problem space that we're trying to work in and then talk about what the is doing to solve it for this presentation I very much have my enterprise hat on as somebody from Octa, so keep that at mind This is a very, very much playing in the enterprise IT admin space So in an enterprise, we configure applications through a single sign on to the enterprise identity identity provider sometimes using open ID connect, sometimes using SAML, sometimes other things the from an enterprise company's point of view, they have a bunch of different apps that they will use within the company and they will connect all of those to the enterprise IDP. So you can use a single account to log in"
  },
  {
    "startTime": "00:06:02",
    "text": "So it might be your wiki app, your chat app documents whatever it is this is great we like it when they use open and connect However, there's another part of this picture, which is kind of a less well solved part of the problem If you are in one of these applications, sometimes these applications want to get data from other applications in the same workspace so in this case we're looking at a wiki page somebody has dropped in a link to a chat conversation or whatever it is This wiki wants to actually show a rich preview of whatever is at the time link. And currently this is what you see. You will see a link with a button that says connect your account. And then this app will go do an OAuth to that app to get data The user will also the user is part of that flow, like the employee user right? They're sitting at that screen, click a button they get sent through an OWL flow, see a consent screen, and everything is because it's a third-party application, and they will grant access to data at that application The problem is that that does not actually accurately reflect the correct ownership of the data, and it's also just a kind of user experience burden in the end enterprise context. So we have all these different applications talking to each other to get data from each other sending users through oath flow across each other and the identity provider that they all use to sign in to those apps doesn't see any of that happening and can't manage it, can't see that it's happening can't control it, can't enable it, can't disable it so what we're trying to do is essentially extend the single side-on experience of signing into these applications to also"
  },
  {
    "startTime": "00:08:01",
    "text": "make that work for API access between the applications with two main goals of that in mind. One is making it easy for users so that they don't have to go through the OOF consent screen for every combination of apps they use within their enterprise and so the enterprise admins can actually manage control of the data that's getting shared between the applications that they use So that is the main problem space To solve this, we have taken the previously mentioned but not previously mentioned, identity assertion, or identity chaining, identity authorization chaining draft and profiled it down So that draft essentially says, use token exchange 8673 and then use the John authorization grant, 75 to get an access token We narrow that scope and say the input to the token exchange is an identity assertion rather than like an access token like is commonly used in those use cases The ID token or SAMO assertion gets turned into a new job which is expresses the fact that this app is trying is trying is actually allowed to get access to data from this other app both of which live under the enterprise IDP that jot then gets used in the jot authorization grant to get an access token from the, the data from this other app, both of which live under the enterprise IDP. That jot then gets used in the JOT authorization grant to get an access token from the target application. This is another way to look at it. So you have a client, if this wiki, you know, the user is on this page trying to, they drop a link into this other application that's used by the company. That wiki behind this site a client if this wiki you know the user is on this page trying to they drop a link into this other application that's used by the company that wiki behind the scenes not visible to the user is going to first to a token extra using the ID token that it got when the user signed in, up to the IDP It's going to get this jot authorization grant and it's going to send that over to the resource server of the chat app or whatever it is that it's trying to get it the IDP. It's going to get this JOT authorization grant, and it's going to send that over to the resource server of the chat app or whatever it is that it's trying to get data from. And it's saying, hey, this enterprise"
  },
  {
    "startTime": "00:10:02",
    "text": "IDP says that it's okay for me to get an access token to access this data and then it can respond with an access token enterprise IDP says that it's okay for me to get an access token to access this data and then it can respond with an access to go the reason that this can work is because, again, both of these applications have a trust relationship with the enterprise IDP through a single sign-on, so we're able to actually have a complete chain and everybody involved can know that it's OK for this data sharing to take place I wanted to talk about this again This would make more sense if you have previously heard about the identity authorization training draft, but the reason that we needed to profile it is because it essentially leaves a lot of things out of scope. So it doesn't say how you get the initial token and um that token in that draft could actually be any kind of token because it's really just saying use token exchange In this draft, the initial token is obtained through an SSO flow. It is an identity token of some sort either an ID token or Samuel assertion The way that the trust relationship is established between the two domains is through the SSO relationship that they both already have And the authorization training draft doesn't actually define the semantics of the jot that is used cross domains whereas we need to be very explicit about what's in that jot and why it's okay to trust to issue an access token So this is essentially what the steps look like. The this is that step one the client goes to the identity provider and says I'm trying to access this resource, which is the token endpoint of the application is trying to access this draft defines a requested token type and then the input to this is also an ID token that it got through SSO"
  },
  {
    "startTime": "00:12:02",
    "text": "The response, which is a token exchange response contains this shot authorization grant with all the defined claims and semantics of what that means Here we have the lovely N.A appearing again, because this is not actually an access token You can thank Brian for that. He's not here Should I not hassle him if he's not here? okay This is what the cross-domain jot looks like So we have a type to find specific to this, which, which that is what this is, because again, cross-shot confusion and mentioned in the BCP is a real problem and this is a very essentially giving a lot of power to this token because it can be used directly to go get an access token So nothing should be particularly surprising in here. The issue, it's issued by the identity provider It's got the user's user ID Oh, one thing to know about the user's user ID and the client ID value is, um, provider, it's got the user's user ID. Oh, one thing to know about the user's user ID and the client ID value is, this is particularly tricky because we are trying to make this jot readable without any transformation by the thing that's getting sent to in the example I gave was like the chat which it already has a registration of the Wiki that's trying to access it through their own OAR to in the example I gave was like the chat which it it already has a registration of the wiki that's trying to access it through their own oath relationship we want to use that client ID here so it doesn't have to know anything else, and the user ID that's in this should be the user ID that is from the point of view of the chat app being accessed so there's no requirement that the user IDs are you know, the same across everything in this system because that's not how it works. Like if you go to configure your enterprise as a you end up often sending different user IDs to every different application that's being accessed through whatever kind of mappings and whatever reason, for whatever reasons so we're trying to just keep all that architecture the same"
  },
  {
    "startTime": "00:14:02",
    "text": "Then the app, the client takes the jot and uses it in a jot bearer assertion which is sunday 23 which this should not look surprising I did put an authorization header in here because this is very explicitly only useful for or should only ever be used by confidential clients. This is server server-to-server stuff going on there's no browser apps any browser app is going to be a browser app of one of three resources one of the apps in the system not across across and then the response would be the regular token response that that resource app's token endpoint would return which does not define access token format or anything. It's whatever it would return So like if we just say, you're going and talking, to the Slack app, whatever Slack already returns as an access token, we're not saying change that. Just issue the same thing. They've already got O-off, they're already returning bearer tokens. Just do the same thing. We're just giving you a new way to return these tokens So I am very excited that to report we have made a lot of progress in this since the last time we talked about this Octa has an actual development branch within the actual Octa product that we have some people playing with. It's not public yet, but it is we're able to grant access to it for people who want to play around with it and we've started actually scoping out the work to ship this in production for reels we have been working with atlasian on a prototype against that IDP for Reels And they are also working on scoping it out to build in the production there's a couple of other companies that we've been talking with as well. I can't name them just yet. I'm hoping it will be able to very soon. They're also very excited on about implementing this. And yeah, so that is, it's"
  },
  {
    "startTime": "00:16:02",
    "text": "a good sign that it is clearly solving problems, not just for us I actually want to talk a little bit about I don't have a slide for this one but I want to talk a little bit about that excitement using this diagram Okay. Let me, yeah, let me just make this point, then we'll get the questions. So one of the so for i talked about the problem from the enterprise perspective of wanting users to have an easier time and also having the IDP be able to act actually control which apps can talk to which but the other legs in the slow also benefit from from enabling this like the clients or the the resource servers and clients in this flow often, like, you know, they want to build integration to other applications and they want those integrations to work well and be easy to use and currently there just is a lot of friction because they have to send users through these consent flows and figure it all out. And they are very excited about being able to remove a lot of that friction by using the IDP as the way to mediate who's allowed to do what So I'm, yeah, I'm excited that it looks like it's actually solving a problem for multiple people in this, in this ecosystem and yeah that was the last slide so we'll take take care yeah, I'm excited that it looks like it's actually solving a problem for multiple people in this ecosystem. And yeah, that was the last slide, so we'll take questions. At all for this is top pretty cool stuff just a couple of things i guess um you know you would bind the uh Jodd authorization grant to the request. Keclosers the mind Yeah, I guess you would bind the you know, jot authorization token to"
  },
  {
    "startTime": "00:18:01",
    "text": "the client because you know, you're going to verify it afterwards so that the IDP knows that it issued the grant to the right requester, right? yeah yeah that it issued the grant to the right requester, right? Yeah, yeah. I didn't do a good job of explaining all the claims in it, but yeah Okay, and then the second question is, like, in the token exchange, is the client going to request all the different scopes that, like, all the different parties that it wants to exchange this? job authorization? Yeah, good question. So the request is made to one app. So if the, if, if last, the end of this example wants to go and talk to Zoom and Slack and whatever, they're gonna do this flow for each of those to get a new, because this jot says which resource it can be used for. So I need a new one from each of those. And as for this scope question, that's a different question, we JOT says which resource it can be used for, so I need a new one from each of those. And as for the scope question, that's a different question, we're not, we don't, we're not defining any behavior about scope but we would expect people to follow the existing best practices of like don't request all the scopes up front you know generally like request as little as you need at any given time that kind of thing. And you can always go back through and get a new access token when you need to george fletcher I guess the one of the questions I had is it seems, it was a little bit confusing to me in the JAG itself as to what the subject is bound to so like when we think about identity tokens the subject is the function of the issuer. Right? We explicitly called out in transaction tokens that in a transaction token, the subject is a function of the audience um because that's identity the trust domain. In this particular case if the subject identity"
  },
  {
    "startTime": "00:20:02",
    "text": "is the same subject identifier, the IDP would have given the you know, so like I'm on atlasian and I'm connecting with Slack or whatever. If the subject identifier is the one that the IDP would have given to Slack right, then you could say that the subject is a function of the client well, of the destination entity. Anyway, so I think there's probably some clarity that needs to be put there so that you don't run into, you know, subject identifier collisions and the right thing happens No, I assume you're saying, I'm pretty sure it's I'm pretty sure it's correct. Let me go back to the JOT into subject identifier collisions and the right thing happens? No, I see what you're saying. I'm pretty sure it's, I'm pretty sure it's correct. Let me go back to the jot. Well, no, in this diagram, maybe it needs to be clarified, but the intent is very much to treat this jot similar to an ID token. So from this, from the resource app's point of view, it's going to get this Jot, which has a user ID in it, which is a user ID bound to the issuer, just like an ID token says, right? So ID token subject is from the thing receiving it point of view it should treat that subject as subject at this issuer, right? So we did the same thing. Right, which might be slightly different than if it had been a standard OAuth flow depending on how that track was happening because you had an extra hop to the IP out of the OAuth server and the OSS server would have assigned its own subject anyway so in I can look through it and and had an extra hop to the IP out of the OAuth server and the OS server would have assigned its own subject. Anyway, so I can look through it and yeah, no, I think I understand what you're saying and I'm pretty sure it's fine as as is Okay, it might, because it's not always it's not an ID token, we might should explicitly clarify that the subject is a function, is within the domain of the issuer if that's what you want to have Yeah, and I can't remember if that sentence is it in there or not, but I think it is. Okay"
  },
  {
    "startTime": "00:22:02",
    "text": "okay. Yeah. And then the other thing had to do with, like, you know, depop binding these things or the I mean, you know, it feels a little bit scary in the sense of being, if I can mint one of these authorization grants, right, I'm going to get SSI Dan. Yeah, I mean, it's a, it's just one second. We are running out of time, so if you can quickly answer those and thanks, George and go ahead justin ethier justin richer So I'm missing a couple of key bits from this diagram where does client get or does client get an access token for calling authorization server resources app? Does that comes back from the authorization? server of the where's step three or? four in the slide? Yeah, sorry, so I didn't include the responses in this right yeah that's i'm just wondering where where that piece so the response from token extra is this is the grant yeah I got that That sent in step two. Okay. The response of that is the access token from the resource app okay so the response of two is that. And then, uh, AS is basically validating the assertion through the IDP as an assertion provider. That's how that includes kind of thing. OK, so in that case, I do, all right, I understand George's question a little bit better with that, and I do think it, it does allow the to close the loop uh a bit And it also, I guess answers my second question, which was, why don't we just hand back and access? token from the IDP directly, but it looks like we're talking about different trust domains or functional domains. We did consider that first and the very quick uh conclusion we came to, which has been validated now by multiple people we talk to was you're never going to get a app like Slack or Zoom to trust an act been validated now by multiple people we talked to was you're never going to get an app like Slack or Zoom to trust an access token at the resource server issued by an IDP right absolutely going to trust the access tokens they've issued. Right, okay Thank you"
  },
  {
    "startTime": "00:24:02",
    "text": "David. Hi, David Rassard. I think the answer to Justin's question kind of answers part of mine, but when I saw you, other diagram, the spaghetti one, where you connected to all the apps together because I'm biased to another authorization model, I was like, hang on a minute, this is a great place where you'd want to put a PDP and then you'd have essentially a gateway or an interceptor sitting in front of each one of those apps, and they essentially, when the week he talks to the chat app or the spreadsheet app, there would be an authorization request that was or an interceptor sitting in front of each one of those apps and they essentially when the Wiki talks to the chat app or the spreadsheet app there would be an authorization request that would say hey can can the Wiki site consume data from the spreadsheets app on behalf of the user authenticated in the Wiki app? I would think that the IDP could implement that with what you're talking about, but you would still need the rest of this flow to negotiate the tokens. You still need the identity like none of the policy is described by this that makes sense. Yeah, you still all black box in the idp like idp decides if this request is going to succeed or not like that first request based on policy, which is not part of the spec So it could be implemented with that So is this more of a way to, like... Sorry, guys we're running out of time. We need to finish yeah we'll talk later we need continue this discussion later how many people read this document show hand just very few so so yeah if you can get more people to review it yeah, yeah, awesome. Thank you For the meeting, me take care of us on peter and christina Someone else? Christina cool, thanks. Okay, awesome. Thank you Next one thank you um next one you know gonna talk to that or oh or? Oh, almost they want to go? Who is D. You're already here so why? We lost pride. Is"
  },
  {
    "startTime": "00:26:01",
    "text": "Neil, are you online? Hello am I coming across? Oh, there's Neil, great Yeah, do you want to... Okay. How do you want, do you want to go with this is this? from... Okay great. Great. Thanks. Neil. So I'm going to let Neil do most of the talking, but I'm going to be up here to help answer but this is mostly Neil's draft. Thank you Hi, everyone so a few months ago I sent this to the morning list and I'm kind of looking to get adoption So I'm presenting it here today to kind of kick things off. So this is I called it an Oath profile for open public clients name is not too important to me I can go to next slide please, or do I have control of that? that? can you guys hear Can you guys hear me? You're like feed of that can you guys hear can you guys hear me you're like fading in and out for some reason Okay Neil, I headed you the controlled, you can play with it Thank you, yeah. Can you hear me okay? kind of Kind of. It's fading in and out. Yeah I don't know You have a different mic. You can switch too Possibly if I can find the controls to switch the mic Seems that the sound is okay online Yeah, the remote participants have no issue Okay, that's good. So I don't think it's the mic then Well, I'll try going forwards so the problem we're trying to solve is this. The IETF has spent a lot of effort over the years to finding standard protocols for access"
  },
  {
    "startTime": "00:28:02",
    "text": "your mail, your contacts, your calendars, etc And unlike the closed ecosystems of most internet services, like Facebook and Twitter this means servers and clients can be built by two completely different people and companies with no knowledge of each other, but still work together And despite the dominance of Gmail and outlook, there are still many, many other email servers running out there and dozens of different clients. But the problem is authentication At the moment, username and password is still the only interoperable method of logging into your account And that's just not acceptable in 2024 There are lots of email hosts in particular looking to make authentication more secure while retaining, you know, And the email client authors are keen too, not least because the email hosts keep badgering them about this this So proposing a solution right the only viable answer is oath but the way it currently works in most email clients is hard-coded to only work with Gmail and Outlook It requires a pre-registered client ID and a knowledge of what options the host is configured in terms of how they do all. And this doesn't scale to support the whole ecosystem. So last year Fastmail organized a conference with a bunch of the major vendors in the email server and client space, and we came up with a proposal for an o-off profile to support this use case. We just deliberately not trying to define anything new. This is just pulling together a bunch of existing OWOTH specs and mandating choices for most of the options. So we can have a profile of OAuth that gives both clients and servers something they can implement and know we'll interoperate without having to have a pre-existing arrangement So here's a brief overview of how it works. First, we which the authorisation server metadata to get the endpoint we need. How we get the URL for that is an interesting question, but we can come back to that"
  },
  {
    "startTime": "00:30:02",
    "text": "Then we get a client ID. Now the company's suggestion is using dynamic client registration Obviously this information is untrusted and could be all false and if the server wants to ignore this, it can just return a static client ID to every client But I know as an email host myself, we would find this very useful for debugging purposes, if nothing else and tracking down issues that users might be having with the service now the client can get authorization using the authorization code grant flow once it has the client ID We've tried to reduce the options to make it secure and easier to be interoperable. So we get authorization using the authorization code grant flow once it has the client ID. We've tried to reduce the options to make it secure and easier to be interoperable. So we've mandated Pixie using SHAR-256 hashing of the code challenge, required issue identification and resource indicators to protect against mix-up attacks Then if the user grants authorization we then get back an access token and a refresh token The client is mandated to not reuse old refresh tokens so servers can detect leaked ones This is something that we find a lot of clients struggle with, but it's nice if we can enforce it once they've successfully used a new one, never used an old one then we can tell if it's been duplicated somewhere. So that's the kind of brief overview of kind of how it's meant to work. There are obviously some open questions and some presumptions So this is meant to pair with auto discovery and of course we need to do define the scopes scopes Have I got this my flow mix up here? Yeah, so this is the things that we need to know beforehand So we would, yeah, auto discovery is a key part of this and how that would integrate with this is interesting thing Um, and then, the scopes, there's a number of different options there One suggestion that I think is quite a good one is just using the J-MAP capabilities because that covers the"
  },
  {
    "startTime": "00:32:02",
    "text": "there. One suggestion that I think is quite good one is just using the J-MAP capabilities, because that covers things like access to mail or whatever, and if you know that there is IMAP, you can presume that if you have access to that data, you can access it over whichever protocols are supported So you can use IMAP or JMAP or whatever else is available if you have that scope token And so there's an open question of whether this should all be in one document or whether we have this as a profile of OWRWR and then a separate thing that kind of pulls all together as you use this profile with these scopes and then you have an intro interoperable mechanism. So that's the very brief overview of it so what I would like to do is see if we can get support within this group to adopt this and also if anyone is keen to work on it as well, happy to have people come along and help with that so I'll open the floor for questions at this point I think Christina I think Ben you were first in the queue. Was he there? Okay. Ben, go ahead I'm happy to yield this big offer I'm saying that again, Ben. I'm happy to yield and speak after okay Christina. Oh, sorry, Tony and Adeline just told me to be nice so I consider that a compliment compliment um sorry so I just have a bit of it, of an experience of, you know, trying to probe things, writing documents, you know, they try to commit different specifications to give it guidance and what we've learned is it's kind of important slash heart to define based on what you're cutting the profile so that because once you define what profile the more profiles are going to come up"
  },
  {
    "startTime": "00:34:02",
    "text": "and that's a little bit unclear for me for this document like what is your target audience like why you chose like why there's no deep up mandated for example right like why like, what are the criteria that you? chose a specific set of these OS related specifications is some unclear? Like, for example, why is DCR there? for example, right? Like, that might increase the barrier for some So yeah, that's basically the question Yeah, it's specifically for native clients, I guess. So actually one thing I haven't, I didn't mention it is the intent is that you can only register a redirect to either I guess. So actually one thing I haven't, I didn't mention it, is the intention is that you can only register a redirect your eye that's local host or a company haven't, I didn't mention, is the intention is that you can only register a redirect to your eye that's local host or a, what's called, like, com dot fast mail, not an actual URL, because the risks, jared mauch higher with a web client just being able to say anyone can immediately get a thing where if a user clicks through they get grant access. Whereas if you've had to download, and install something locally then it could always just fake a web browser anyway, if we wanted to fish you to log in So that's the intention in terms of target audience is things like your mail or calendar app or anything like that that's running locally on your device And so the reason Deepop's not mandated is because Deepop is only defined to work with HTTP and the intention is for this to work with quite a few protocols that are not HTTP based. So we can't just mandate you must use Depop across everything like to see that reading down in a sense that like I was now looking for like answers to like quite arbitrary three questions I picked but more like is the kind of example level of security you're looking for like, you know, FAPI and Appenity Connect, for example or is it more like the deployment model you're looking up?"
  },
  {
    "startTime": "00:36:02",
    "text": "Like, is this like a profile that's ideal for native apps? versus web apps? Like, um, know, like things like that. I think that should be made like absolutely clear Thanks, Christina Ben first Hi. I'm Ben Buksh, I'm 20 years developer on Thunderbird and I've been involved with four implementations of OOF specifically in mail clients, including the one in Thunderbird And I agree with this general direction of this draft We need something like this, the direction is good. It's good intentions. I have huge reservations about the dynamic client registrations registration on multiple levels. First, generally, this client ID that all of requires, has been a major problem for implementing new clients. I'm trying right now to register with Google and Microsoft and it's been pretty much impossible. Dynamic registration is supposed to fix that, but I'm not sure that it actually will It seems fairly unproven because there's no current implementations that I know of not a single email client that I know of that is well-known implements this. I don't know any provider which implements this. So there is no much experience in how this works and looking at the spec of the denial registration There's a lot of red flags there, for example it's optional. The dynamic registration could be optionally requiring a login. I need an access token in order to do in the dynamic registration, which is a catch 22, because then I'm back to regis registering. Then there is a JWT"
  },
  {
    "startTime": "00:38:02",
    "text": "thing that is required It's not clear whether an operator what block then clients and this whole business, I don't really know why we need that and sorry, I don't really see why we would need that I would propose something much, much slimper, simpler This will probably make everybody cringe in the room but I would just define a well-known client ID, calling it open, OPEA simpler. This will probably make everybody cringe in the room, but I would just define a well-known client ID, calling it Open, O-P-E-N, and the clients just connect with that And because then we're basically on the same level as what we're doing right now with IMAP when we lock in with username and password that's not not worse and we're avoiding this whole business that Google or any other provider might be block their competitors So, I mean, a few things with that Firstly, the reason it's not invented in email clients are so surveys is the whole tick-nay problem. We don't, there's, you know, you wouldn't implement it if you didn't have anyone else to support it. And that's kind of the purpose of having a spec like this that everyone can, you know, you know, email clients or surveys is the whole tick no problem. We don't, there's, you know, you wouldn't implement it if you didn't have anyone else to support it. And that's kind of the purpose of having a spec like this that everyone can agree on and, and, you know, client varieties can say, we're going to implement this if you support that as well you will get support it's uh that it's actually very simple if you look at like because it's been in the in the profile very much restricted in how it's used it's basically just submit a static jason object that contains your information to the server. The server will return a client ID That's basically it The server may choose, I said, to ignore that if it just wants to return open to every client, we can do that. But it's also, it gives it information it might find useful in terms of presenting to the user you know, it's authorization dialogue Now obviously it's you know, that information can be faked, but as I said, if nothing else, it's very useful as a provider to be able to track down issues if you find out that information can be faked, but as I said, if nothing else, it's very useful as a provider to be able to track down issues if you find that, oh, you know, these client IDs are"
  },
  {
    "startTime": "00:40:02",
    "text": "funding this problem. Actually, it's all this client and I've got information from that registration to go talk to the developer and solve that issue. The, uh, I think, either that or the opposite which is the client metadata, the one I was talking about at yesterday's meeting where you use a URL as the client ID and the URL can be used to fetch that registration data. That's another possibility. I think there's pros and cons to each but I think one of the two is very much worthwhile Aaron Go ahead, Aaron. Yeah, I guess more of a meta question for the Sorry, can I have a follow up on this? I'm still not clear why, what the purpose would be because it would seriously complicate the implementation of an of a cloud client, already OOS today is very complex that would add a number of additional steps and number of protocols, and I don't see a value If any, every client can always get a registration Why do the extra step? I don't see the value of it. If it's just about finding out which clients it is there's other means how to do that we can just use the user agent, for example, and we can define that the user agent should be in a certain form and then you have the same kind of information and just save yourself all the round trips of keeping registering and failure reasons and my object is to make it working reliable and that seems to be introduced quite some risks here in things that I can fail. So I don't see the value based on the effort that we need to make and the value I don't see this balance here I mean, I, first I do the effort that we need to make, and the value, I don't see this balance here. I mean, firstly, I don't think it is adding all this complexity is that it was at one HDP request with a JSON object that's probably static within the client and it gets back about that's it that's it And I think that information there often you will use for things like the authorization flow, like you often use the name of the"
  },
  {
    "startTime": "00:42:02",
    "text": "app to say, this is the app requesting it. And that's, you know, more useful, more user friends uh and i think also can be more reliable to uh than the user agent headers in terms of making sure there's a consistent way of associating which clients making the requests This is, this is Hannes It sounds like we would need to look at some of the details because dynamic client registration also has a couple of different features and so if you for example, if you don't include any let's say software statements etc the client the dynamic client registration is like you request some something, you get it back, and then it comes out of basically based on nothing kind of and if that's the the mode of operation then something that Ben said like then you just mint a some client ID based on whatever is probably roughly equivalent to running dynamic clients. Security-wise yes it's yeah yeah it's not doing security sorry I'm Aaron said I could jump the line the issue here so i totally get the perspective from the client side. But if a mail provider is going to allow any random client with no security to show up and start accessing the person mail based on the user's consent, they're really going to want that client ID to have a very unique, to be instant specific so that if it starts doing something untoward, they can kill it, right? And so some of this it's not just about what's, you know, what it's simple for the clients to implement but the mail providers are probably going to be fairly concerned about what's happening because there's a boat of PII in people's mail Yeah, that's the type of discussion we obviously want to half in the group"
  },
  {
    "startTime": "00:44:02",
    "text": "And in general, before hand over to Aaron it was years ago when we looked at email and the interaction with OAS back then, I remember, it was Loderstadt work on this. We published an RFC on that topic So it's probably a good idea to rebuses what was done back then and have a look at that And so very, you're very welcome Neil and also Ben and others from that community to look at that work again and see whether we can given that some years have passed, whether we can make a difference now, whether we can improve the state of the art. And that was kind of my that was. Which documents is that? So, yeah, if you can share that on the main list, that'll be great well and that was really what I wanted to what I wanted to ask here is this is a i think we're going to see more and more of this kind of pattern of there's a community that wants to use Oath in a search way based on constraints that they have which are different from other communities and where is the best place for that work to happen is it in the Oath group? Is it in the working? group that that community defines their protocols in? Is it important to involve the Oath group in those? discussions? Like do we want to do we want to create profiles for these different uses? Given that, like Neil was saying, there isn't anything new to find in this draft it's saying how to assemble oath build blocks and why these ones were chosen And like, there are several examples of these kinds of documents now already. So the answer has varied over time. So if I recall it correctly, back then we said that we would do that in actually I don't even remember but in the SIP case, which you have been working on, that was done in a different group and sort of with the review from the OAS working group. But I think like depending on the appetite for Neil and Ben and others, we can definitely"
  },
  {
    "startTime": "00:46:02",
    "text": "sort of work together and figure out what the best place would be where there's the best expertise to add for Neil and Ben and others, we can definitely sort of work together and figure out what the best place would be, where there's the best expertise to address those issues. So I think it's basically also on us to have more conversation with you guys and then to sort of like get the relevant players together and and maybe we could do an interim virtual interim meeting to get that discussion going and get more people involved i think that would be ideal right yeah this is sort of a discussion starter with what we have here And so thanks a lot for contributing that work and making us a way of it yeah I agree that's good good suggestion. Hannes, we can schedule an interim in the coming few weeks month whatever right good suggestion. Honest, we can schedule an interim in the coming few weeks, month, whatever. Okay, we're out of time here Thanks, Ben. So we think that to answer the question, the call for a adoption question, I think it's premature but let's keep that discussion going Okay, thanks. Okay okay, Leif Right? I don't know. That's right ask for time? Or ask for slightly no, no. Okay, I can, okay, do you want to did you join? Or you can flip Okay Where's the light? life? that maybe. Where is life? I think it's Okay, nice Go, control. I want to share? share?"
  },
  {
    "startTime": "00:48:04",
    "text": "There you go There we go. All right so this isn't my work All right. So this isn't my work. This is Yuseppe. I think he might be only but not necessarily awake So, you know, go easy on me and on him All right, so status at the station so so this is for checking status of digital credentials. Like, if you think of status list as the CRLs of the digital credentials this is the OCE This is a way to, like, do a live check of the status of digital credentials and the idea here is, of course, that, like, the relationship between the holder and the issue may require a different security context than you may need in order to do a status check. So you could actually do a status check with the identity of the wallet, but not necessarily with the identity of the user and that's why this gets a little could get a little bit easier and that's kind of the motive of why you actually want this, right? You could maybe think of what do you actually need this you could just do short-lived credentials and just keep issue credentials instead. But the idea is that the credentials might actually need to be user-bound in higher LOA. Anyway, so this is kind of the sort of a picture of the intended flow flow Does anybody in the room read? the draft? Hands up. Show hands like some? So there's a bit of review. All right All right, so some review, all right So the idea is that you get a credential from an issuer, the holder turns back"
  },
  {
    "startTime": "00:50:02",
    "text": "to a well-defined typically, method data status required you request status for the current you're holding from the same issue, and the idea is that you can actually do multiple status requests in one go, in one request in one request, in one protocol flow for all of the credentials you're holding from a particular issue or for a holder. And so the non-dashed arrow in this picture is what is being specified in this draft. And the idea of course, is that the holder can actually do this in essentially in the back background. Your wallet can keep updating status for the credentials it's holding holding So there are a couple of examples Essentially, you're providing a hash over the credential as a key to the issuer and the issuer can go look up that key in its internal database of stuff it's issued and response with respond with the status of that right now there's a pool request we're working on to extend the sematch of what a status is right now initially it was thought that maybe we only need to specify things like revoked or non-revoked right? But this is being extended to be a little bit more general We don't know exactly where that's going to land yet but it will be done in the short while And I think only this is where Giuseppe has to correct me, but I think when we're done with that PR we're going to ask for adoption as a working group documents"
  },
  {
    "startTime": "00:52:02",
    "text": "documents a working group documents so an example of like the request response flow, you're basically listing a bunch of shot 256 hashes and getting status objects back for those credentials from the issue There is a, if you, those of you have read the VC document, there's a picture in that VC document of the classical sort of three-party model where you have holder issue and verifier And in that picture there is like a, there's a there's a link between the verifier and the status service that is not how it would work in this case right in the case the the communication between is between the whole and the status service and the status service is associated with the issue I don't know if this kind of makes sense to see, but this is like stolen from the document the from the from the document there is an open issue about the use of depop and proof of possession in general in the draft, and I think that is also some issue about the use of depop and proof of possession in general in the draft, and I think that is also something we're looking to resolve before going for a working group adoption adoption I think one of the things that is being discussed is kind of how do we actually communicate status back right now the draft basically says that there are two kinds of responses error responses and status responses and error responses are used to communicate when the status is somehow negative, right? When it isn't fulfilling the status. That is a little bit sort of if you might um um"
  },
  {
    "startTime": "00:54:02",
    "text": "communicate when the status is somehow negative, right, when it isn't fulfilling the status. That is a little bit, sort of if in my view, because like errors may be or should be used to communicate when something's actually going wrong with the protocol but some stuff like this is being worked out There are, actually, I think I cover this already I actually think I covered this. This is based I think I covered this already. I actually think I covered this. This is basically where what we're working on right now the depop issue and more detailed status in PR 61 I actually think that's it So does anybody have questions? about this? Yeah, you have a number of people in the queue there All right, well. Oh, yeah. Yeah Mahmoud. Go ahead ahead Mahmoud. Oh, there you go. Go ahead Two questions for you. You may mentioned that you're going to be working on multiple statuses Is that a situation where a credential may exist and have multiple statuses at the same time? such as suspended and revoked, something like that? and is that going to be an array of statuses or is that going to be you can be one of, right? I think that's an excellent question i think you should comment on pr 61 to clarify that, what your requirements are. Right now I think the sense of the authors is that you have one status at a time and that if you wanted to represent multiple statuses, the combined semantic would have to be described in a status, right? Because it can be very, very dangerous to introduce sort of multiple statuses in an array and have the, you know, the, the client can consume that in a sensible way. What does it actually mean? to be revoked and suspended at the same time, right? So, I think the safe"
  },
  {
    "startTime": "00:56:02",
    "text": "response is to say, well, it can be one status and you have to define the semantic of the status. When you say you who do you mean? Whoever defines the semantic of the status Exactly, the issue, yeah, exactly And the second question is about, can I check? the status after consuming? So if I take the credential at now, and I get the status, from you now, how can I verify the status? a month from now and check that it was valid at that time? And in this case, you're the verifier? Yes. Well, the the verifier doesn't actually it this, right? It's the holder that actually pulls the status right and provides it to the verifier yeah but the verifier needs to check this the status of a credential at a point in time, right? Yeah, but all right all right is jumping in you're part of the author team, so, you know. Sorry, if it's point in time, right? Yeah, but all right, or I is jumping in. You're part of the author team, so, you know. Sorry to cut Q, but I can answer just a bit of that When you get these status assertions, they're an arbitrary status assertion of fresh claims from the issuer and they have extra validity information around them as well, like an issuance time and an expiration time so as a verifier who's seen several presentations of these kinds of credentials, I might have some, I might have seen some assertions that a credential wasn't revoked or that some additional information had changed since the credential was issued at a time in the past, I might see new ones over time so each of them is a each status assertion has validity period attached to it. Yeah, exactly exactly Christina. Thank you um i personally not a big fan of a model where the wallet fetches the status list but knowing the authors I've given up on the idea of trying to persuade them not to do it"
  },
  {
    "startTime": "00:58:02",
    "text": "So my comment is, there is a draft that achieves um trying to persuade them not to do it. So my comment is there is a draft that achieves, I mean different mechanisms, but their draft that achieves the same thing inside the OLAS working group. They state of list. Unfortunately, I don't think polar Christian bormann Tobias are on the call I would like this work item to progress in a way that is not confusing. In a way that doesn't cause confusion between those two documents I've already abandoned enough discussions where existence of both approaches has caused controversy, discussions, confusion So either, I don't know, just as a suggestion, maybe it is worse actually having them in the same document with a section that very clearly on I don't know, just as a suggestion, maybe it is worse actually having them in the same document with a section that very clearly, you know, outlines when to use with approach and that combines multiple mechanisms on with you know, reinventing endpoints without reinventing claim names, whatnot That will, I think, the existing status list draft is more advanced that would slows it down, which, you know as well as implementers in the space, I would not want to see but I think it is worse considering given the benefit of prevention confusion. Like, I as it is, I would be pretty not in favor of having these two drafts separately within the last working group So, I guess my response to that is that there are for the same reasons that see draft separately within the last working group. So I guess my response to that is that there are, for the same reasons that CRLs and OCS both exist and are used these two approaches are going to have their sort of respective uses and their valid use cases. I don't think it's I think it's, if you're trying to like, avoid confusion in OWOL, like,"
  },
  {
    "startTime": "01:00:02",
    "text": "that ship sailed a long time ago So let's not worry about it for this. Okay Giuseppe. Hey, hello, thank you Leif, for the presentation, all of you for the comments I have designed this solution and also with the help of lay Leif, orie steele and other authors to answer to our requirement to the requirement we have to avoid our line party to monitor the status of credential over time, even outside of the scope of the user authentication This was something driven by a requirement a privacy requirement I, I, I, from my position, Giuseppe, you still there? He may have fallen asleep Yoseppe. Yeah, I think we lost it. We can't hear him. Okay John, do you want to go ahead? I'm sure I just wanted to say I mean I will try to fill in for what I think Giuseppe was going to say is essentially that there are good reasons for at least in our opinion, for having this as a complement the status list. There are situations for instance where status lists will grow to simply be too big, right? to be manageable. And in that case, like an OCSP-like response will be just scale better. Well, this is, I think, uh, is something I mentioned earlier. It's like, we are redefining the PKK revocation mechanism this is OCSB yeah and I and we don't call it OCSP and, but I will, I will, and that's okay earlier as like, we are redefining the PKK revocation mechanism. This is OCSB. Yeah, and we don't call it OCSB. But I will, I agree with richard barnes from like two IETF ago and he said, let's just lean into it and whatever, yeah"
  },
  {
    "startTime": "01:02:02",
    "text": "where's Richard? Oh here, okay, he woke up. There is But anyway, John, I think maybe John go ahead john So, I have the deepest skepticism about status lists. So I think this is useful There are some things that we have to be, that we're going to have to be careful of that there is a potential depending upon how the wallet implements this, there's a potential timing correlation. This doesn't stop issue or verifier correlation It's probably, you know, most of the verifiers are going to want this information stapled somehow So that's one question is, is this stape- methodology included in the draft, or are you expecting to do a different draft? for stapling? I mean, that maybe should be a question we ask for, we ask Yuseppe. My personal opinion you should go in this draft I mean, I think it should go in this draft I mean, there's no reason to keep profiling this. I think it should be so So I would agree that it should go in this draft. We also need to consider this especially if it's going to be valid by the verifier that we're kind of limiting ourselves to SDJW or something that's plot plausibly deterministic once we get into zero knowledge proofs where what where you have blinding that goes on over the thing that is being presented, they can't recreate the hash So we are, this is kind of format specific, which isn't necessarily a bad thing, but we have to sort of acknowledge that up-hit up front"
  },
  {
    "startTime": "01:04:02",
    "text": "or he's kind of shaking his head in a random way I mean, we don't know what JWT, JWP are going to look like, right? So, but one ten to suspect things with blinding probably won't by design be able to generate the same hash. Maybe not well if it does then we haven't solved issue or verifier correlation Exactly Atul. Hi, Atul Torch, Wally Maybe I missed it, but is there a way for the requester to be authentic? when it gets the you know, it requests the status and gets back the answer? Yeah, I actually believe that's in the current version of the draft It may not be well enough specific and you should definitely provide some feedback on that if you're not finding it clearly specified enough. Okay, but yeah, thanks Hi, justin richer So I think it's important to, in terms of differentiating this from status lists, that by think it's important to, in terms of differentiating this from status lists, that both this and status lists, violence, the core privacy tenants that are promised by the SSI folks in very different ways and choosing your violation is going to be very important to the ecosystem. This leak credential use to the issuer Status list leaks credential credential over time to the verifier. Both of those are things that we were told we would never have to worry about if we just moved everything to SSI. Clearly the real world doesn't like those promises. Correct So I think that in basically, if we are to go down both the, you know, the CRL and OCSP reinvention road, then I think we need to be"
  },
  {
    "startTime": "01:06:02",
    "text": "very clear in situating these things What are the security properties they give us? What are the privacy properties they give? us? Because I think that is what's going to fundamentally differentiate what people are going to want to use in these different environments. I think a lot of the performance is going to be comparable in a lot of ways, but it's really going to it's going to boil down to like what are the problems that this is giving you when you're choosing between them there's there is definitely an element of picking your poison when it comes to like performance it it's get it this way that way. You pay it in a different spot, though. Now, in the exactly. Now, in the status attestation draft, there is a at least in my mind a credible attempt to writing a good privacy consideration section and everybody should review that and see whether that meets the experience for instance, just about this, because you're making privacy consideration section and everybody should review that and see whether that meets your expectations for instance just about this because you make a good point right and maybe we should have the same kind of sort of words in in the status list we absolutely should but I'm saying go beyond just the privacy considerations and have this be in the framing of where this document makes sense for application It's hard to put that in a sound budget nugget, but I think it would be worth it for both of these i like what you said just in but we need to keep in mind that the best privacy considerations section will not make the privacy issues go away so just making it clear. Just talking nice about it, but it's just making it clear, right? Richard you get who is up is back maybe yeah josepe you said we don't have too much time though just Giuseppe and Richard, so let's keep it short. Yeah, very short. Two small points The first one is the status of search first of all, prove to the walletista distance which credential got revoked"
  },
  {
    "startTime": "01:08:02",
    "text": "and therefore hints to the wallet distance the credential that it holds might be revoked. So this is a very interesting simple feature because in our minds the wallet distance needs to know and the citizen must be aware if the credential they have are revoked The other point is that we have implemented in Italy We are in stage with a small group of citizens and this population will go significantly before the end of this year Therefore, this is why we show well, we should call for the adoption as well as possible. Thank you Richard. So I'm mainly here because my name was in vote and so like the other gods, I emerge from the deep You woke up then? We took your name in then. Yeah, exactly. This is your penalty So I think it's absolutely fair to lean into reinventing the PK i and like it's important as you're doing that's reinvent them modern PKK and not in PKK of the 1990s. But I think we're doing it Like the great news is like what I'm seeing here is like we're doing that. We have much better handled in privacy properties than than PKK ever did, right? Yeah We're incorporating his lessons learned. The only suggestion I had here is that like, I really enjoyed Justin's comments about the trade-offs and like it might be useful just to make like instead of having mechanism A and mechanism B for revocation separately, just to, like, do them together in one document overall on revocation and here's the modalities in the tradeoffs next to each other I mean, I think that's a, that's a question for the work group chairs and for the ISE when we get to that point when we get to the point of actually asking for adoption here, right? And that's maybe one more revision away. Giuseppe would you agree? Absolutely All right, yeah, okay agree? All right. Okay. I don't know if you can hear me. Yeah, I agree All right And I would be particularly happy if we"
  },
  {
    "startTime": "01:10:02",
    "text": "would actually reference the other work because we have repeatedly been not referencing existing work, but we don't do ourselves a favor. You want us to do, Rick? recursive normative referencing between the status list and status status at the station so we can lock up the RFC editing queue so I want to reference the work we are essentially replicating Oh, I think... Informative references too because because if we that the Oh, informative. Informative. Because if we, I've seen it numerous times. If people change the name of a technology they suddenly disconnect themselves from what happened in the past. They don't take the feedback into account because they think and they talk this into them that they have actually invented something new. I ran over Brian thank you for coming. Special guest, oh I had it. I'm really sorry I've had trouble with the calendar all week. It's only Tuesday Don't worry. Okay, only 10 push-ups push-ups I've had trouble with the calendar all week. It's only Tuesday, don't worry. Okay, only 10 push-ups push-ups That's it. Yeah all the good humor for it, I feel like a real something All right. And thanks for adjusting things. Thanks, Peter for helping me and all the people that have messaged me thought it was dead and or otherwise I'm going to see if I can do this Oath identity and authorization change across domains of behalf of my co-op co-authors, many of whom's names I cannot pronounce, so I will not try"
  },
  {
    "startTime": "01:12:02",
    "text": "try But, uh-oh, did I do that? No I'll share it from here. Not my fault for a change Okay you want to go back here do you want me to hand you that control what do you want? Are you awake? My, uh connection wasn't very good on the bus coming from Kitsilano here. See if I can rest reestablish it. True story Yeah, can I do it now? Yeah, try I thought it did, yeah yeah. Yeah, it's not this one. Okay just ask you to do it. Okay That's fine. So next slide. Yep Ah, hey, you may have seen this slide before A rough agenda for the document I just talked about We're going to talk a little overview of refresh with the content Changes since last time, open issues and questions, and of course next steps. There's a lot of open issues and questions, so we'll get to that This is actually a picture from Vancouver in the background here. This was one of my abstract phase, but it is legit Vancouver Next slide, please. So, a little rough over in the form of a Manaski art picture. What this document does is describes a mechanism intended to preserve identity information and do federate and federate the authorization across trust domains using the OAuth 2 framework what it really does is compose and describe the usage of two existing RFCs that do individual pieces of this. The first piece, is actually, refers to some other work in progress, but we mentioned the authorization server disk discovery here that also didn't exist at the time of writing at least some of these But what we're talking about is allowing some client in Domain 1"
  },
  {
    "startTime": "01:14:02",
    "text": "one, ultimately to access protected resources in Domain 2 and by one and two here, I mean, of course, A and B, because I misread it One domain talking to the other one And what happens is we describe a local token exchange between the client in the first domain using the token exchange RSA to exchange something it has, some token, oftentimes this token is a token it's received from the outside world and it's acting as a resource server itself and is doing a little exchange and passing it along, but it's not necessarily that Something exchange for a JWT-based authorization grant that it in turn presents using RFC's 70 7523, which is the JOT authorization grant framework or something Sorry, there's a long run too. I ran after the bus presents that to the authorization server in Domain B and exchange receipts an access token, excuse me, that it can use to access protected resources in Domain B. All these pieces exist in various other RFCs, but they are not maybe well known. I'll get a lot of questions about them. People don't know they exist or don't understand how they work. That's probably because they were written poorly I take responsibility for a lot of that What this document does is not really describe or define a lot of new stuff. That's why I use this clever strike through here to say we just describing things, but describe the composition of these different pieces to be put together and used in a way that actually achieved something that people are trying to do, which is this cross-domain authorization and I identity Do we stop using the word chaining? Anyway, chaining, yes Next slide, please. So, of course, we last met in Brisbane. It's a beautiful place. Here's a photograph of it What's happened since then or at then? Could I have the next slide please? One thing that did happen in Brisbane is one of our co-authors, Kelly, presented on this concept to the whimsy group"
  },
  {
    "startTime": "01:16:02",
    "text": "because I and he and a number of other people feel that this concept is relevant to the work that they're doing in that group and that group is meeting tomorrow morning at 9.30, I might be there on time this time this time this time um on And there's a lot of over in concepts, cross-pollination and so forth So I wanted to bring that up. So that did happen We're sharing ideas and concept and so forth Next slide, please. So what have we done in draft two, which was released right before Brisbane in July of 25? We removed a recommendation to not use RFC that's token exchanges, requested token type. That's a good double negative there, but we had some wording in there that was basically unnecessarily suggesting against the use of something that some other derivative work of this felt would actually be useful So we dropped that restriction made a lot of sense, and we correct it as a screpancy between the alphabetic number numbering of a diagram in the text and the resource acting as a client example I'd like to thank Dean for pointing this out. These are obviously some pretty trivial changes we didn't get a lot of work done it happens sometimes next issue so looking at the open issues and requests to be pulled, we've got a few things adding center constraining mechanisms, recommending a meeting type. I'm looking at you again, Aaron. I don't actually know what to do with this I think we need to do something and or close it, but, you know, put it on the list Use multiple questions. Oh, my God my. Yeah You might be right Whether we should allow depop, that's a actually really similar in center constraining"
  },
  {
    "startTime": "01:18:02",
    "text": "describe and give examples of what kind of tokens a client would exchange. Actually, this is related to the first point I was making. It's really right now left up in the open in the open. The assumption is that the originating client has something that it can use to kick off this exchange The exchange that Aaron here, I believe, was suggesting we actually described some of those things and give a little detail I think you're probably right I wonder if someone would do that or we can at some time and add a use case to the appendix I believe this is Peter. This is fun now calling out all the people that were wondering where I was just a few minutes ago Thanks again for your patience and adjustment Anyway, and then there is an open request basically open pull request basically relating to these two items that are about depop center constraining, key constraining, whatever you want to call it And that turns out to be an interesting thing. Could I have the next slide, please? please? So I've spent a lot of time working on Cendron constrained pop tokens and so forth and I felt this photograph was really pretty illustrative of a number of things it's both terribly self-indulgent and sort of reality inducing as well. Here you can see a photograph that I took of Aaron standing on stage presenting that contains a photograph of me talking to Dr. Fett while I'll get that, Aaron, thank you I expect to see this later, about beginning to speak about what I called in a presentation deep and the Burden of Proof. And it was a little bit of a play on words here with Burden, but trying to emphasize the heavy load that it is to kill and the burden of proof and there's a little bit of a play on words here with burden but trying to emphasize the heavy load that it is to carry that and how difficult it is actually to arrive at consensus around making that actually work in reality"
  },
  {
    "startTime": "01:20:01",
    "text": "and in specifications like ourselves. So while the required to add it to this draft is absolutely reasonable, it turns out to be rather difficult and the other one thing I wanted to mention about this reality side and sort of self-indulgent is as you all know, like to consider myself a bit of a photographer I would like you to note my thumb or forefinger here covering part of the lens in the picture I and sort of self-indulgent is I as you all know like to consider myself a bit of a photographer I would like you to note my thumb or forefinger here covering part of the lens in the picture I'm a skill tactician. So, on that burden yes, yes, one corner one one one corner vignette Next slide, please. So before this stuff kicked off Kelly said he was going to work on this whole thing and it got my tackles going to he was going to work on this whole thing, and it got my tackles going. I was like, well, that's really hard. Let me try to jot down really quick some of the areas where I think it might be hard and here are the things you need to think about. So what I did was dump that into one of those issues and all I've done here is copy out the text from one of those brain dumps of the issue into the slides and tried to highlight the point in the flow where it actually makes sense. Again, this is all about where and what would need to be considered in the concept of concept, excuse me, of sender constraining key binding tokens in the context of this And the first thing that needs to be considered is the initial token exchange where the client in domain A calls out with some token to token exchange and expecting to get something back. And what we have here is that we need to think about checking the binding if it exists on the inbound token of that token exchange. So there's the subject token that's presented there that may be under constraint And if that is the case, then presumably that binding needs to be checked, whether it's MTS or Depop. Those are the only two defined mechanisms but they would need to be checked and enforced. In many cases, this might not even be possible, depending on the deployment itself"
  },
  {
    "startTime": "01:22:02",
    "text": "For instance, the very common case that people like to bring up around this, and we talk about a little bit in the document is the case where this client is actually a resource server acting as a client it's taken an inbound bear or sorry, not bear inbound sender-constrained token from the outside world exchanging it with its AS in order to get a token suitable for its backend services might be a transaction to actually not in this case it's exchanging it for one of these, excuse me, I lost my train of thought, but in that case, it's impossible to actually check the sender constraint on that because it's the client way upstream that actually holds the key, not the resource server, so you don't want to you can't, it's impossible to do it. There are cases where you might want to But trying to describe and define this it's a little tricky, hard to be done I didn't offer any solutions here, just point out the problem Next slide, please. So the problem, the next piece is you need to consider binding the token return from token exchange. So the request itself this one, could have been MTLS or have a D depop header, and it's kind of implied per the standard both of those specs say, hey, these binding mechanisms are applicable to any type of request any grant type request of the token endpoint so in theory if something comes in here that it has one of these binding mechanisms sort of on the context of the request, theoretically it's implied that the return token should be bound but it really maybe only applies to access token I don't know, it's a little fishy, so that should be described And the return JWT itself, the one that's going to be used as an authorization grant, could be bound with the respective CNF claim, just the same way that you normally would an access token, but embedding it in the CNF claim there and method meaning either, I think, the certificate hash or the JWK hash. And all this is maybe kind of implied by the standards, but it's certainly not explicitly written down anywhere. And your mileage favorite"
  },
  {
    "startTime": "01:24:02",
    "text": "I think the certificate hash or the JWK hash. And all this is maybe kind of implied by the standards, but it's certainly not explicitly written down anywhere. And your mileage may vary on interpretation Next slide, please. And then so the next thing would be this is the cross-domain call where that client has now obtained this cross-domain JWT it's used it in this authorization grant you need to check here the receiving authorization server needs to check the binding on the inbound token, we call it assertion in this of the access token request. Our names are tough. The request itself could be MTLS or have a deep op header. This is also kind of implied by standards, but it really leaves a lot to the imagination and it can be checked against the CNF claim of that JWT authorization grant The presence of the CNF claim itself might in some worlds be sufficient to say, hey, this thing is a bound token and you have to read presence of the CNF claim itself might in some worlds be sufficient to say, hey, this thing is a bound token and you have to require checking the binding on it. I will say that some implementations I know about would just ignore the CNF claim and there's a whole world of understanding about what was written and what's supposed to be ignored And I think it would be unlikely to expect most implementations to reject 7523 authorization grant assertions with a CNF claim that's not bound because a lot of them just aren't aware of its possible existence and would likely ignore it probably not all but a lot. So maybe a new grant type here would make sense to clearly convey the intent that this thing is bound. And also just from sort of a naming and aesthetic perspective, using the currently defined grant type for it which says JWT bear for a non-bearer thing is a little bit awkward Justin, I know you've taken issue with us doing the same thing in other contexts in the past Here, I think it probably makes sensitive to define something new. But again, this was just sort of off the top of my head. Next slide, please please That is? Geez, they all look the same"
  },
  {
    "startTime": "01:26:02",
    "text": "Binding that result in access token This part, I don't know, obviously the request itself could have had a header, a depop header or an MTLS connection would have had to have it for the previous thing to be bound in the first place and check. And this, I think, is also kind of implied by the existing specs that would say that the token that was issued as a result of this, this access token would probably also be bound This part is, I think, a little bit more clear in the underlying standards and the expectation would be a little bit more clear that it would indeed be bound. But as these things go, it certainly wouldn't hurt to have this part sort of written down more clearly as well Next slide, please Oh, wow. Oh, yeah. And then it really gets interesting wen lin this document we have a conceptual use case where rather than that client calling its own authorization server, getting back a token and using that to go across the main, it calls its own authorization server its own authorization server in turn becomes the client or acts as the client or in a sense proxies that request to the cross-domain option authorization server, gets the access token on its behalf and returns that access token to the client itself. It's a nice little proxying trick. It's really cute It really screws up the concept of sender constraining because you have all these different entities sort of acting on behalf of a different entity and how is the authorization server going to prove possession of a key that doesn't hold for a client that just called it I think I said some stuff in here. Kelly, I think did some prior work on this. I couldn't find it at the time I wrote it But ultimately, I think if you want this to actually work and bind the resulting token, you need some kind of like, hey, trust me, this is the CNF that someone else told me they're willing to do. Or maybe they proved it to me. I'm not sure But either way, ultimately, at this step here, you need to have something that's more of a, just trust me"
  },
  {
    "startTime": "01:28:02",
    "text": "proved it to me, I'm not sure, but either way, ultimately at this step here, you need to have something that's more of a... So, just trust me... You can't say here because remote people might not see here. Okay, sorry, sorry, yeah uh d and e steps D and E in the in the context is where the authorization surfers trying to make a request on behalf really, for this client, but it is in no way capable of pre-possession a key for it, so it gets a little tricky And I think ultimately the only way to do this, and frankly, whether we really want to do it or not, is some kind of claim probably within the assertion that's going in step D that says, hey, really please just bind this to this key and trust me it's cool, I'll do the right thing later Next slide, please So, next step I've never been to Dublin. I'm looking forward to it, but I don't have any pictures of it so I'm jumping ahead to look ahead to Bangkok because I do have some like pictures as that Okay, Justin. Thanks all Justin richer. So yeah, the AS acting as client throws several wrenches into the works but we've seen a similar pattern before with referring to AS acting as client throws several wrenches into the works, but we've seen a similar pattern before with referred token binding. And it's a similar, like, trust me, this is the context I'm going to use in something else, and there has to be a trust relationship that's defined by policy that allows it to do that so it's solvable in a way by waving your hands enough If I may be a pendantic node for a moment, and I know you do appreciate that The referred token binding did in fact show proof of possession over a key to the other party. The trust me that was sort of like trust me it's cool to reveal this to the other party. It was like a privacy mechanism so to reveal this to the other party. It was like a privacy mechanism. So, okay, so I'm misremembering some of the details there. And I thought it was a separate"
  },
  {
    "startTime": "01:30:02",
    "text": "to the other party. It was like a privacy mechanism. So, okay, so I'm misremembering some of the details there. And it was a long time ago, and it's not deployed, and it doesn't matter. Right. But token binding dead. We know that. But I, okay. Yeah, it was a little bit different it was actually okay that's that's fair. But I'm reasonably sure this this concept is not unique to this, but I am not aware of any other like legitimate way to do it than sort of that blind, hey, trust me please do this. And there's a lot of trust going on here anyway so it's kind of maybe okay and that's pretty pretty authoritative. It's kind of maybe okay thank you okay okay thank you for the entertainment it was nice nice See you all Friday Thank you No worries. No worries Yeah, it happens. It's fine Thank you. Thank you yeah happens. Thank you for adjusting. Yeah, yeah. Happens to everyone Yeah, yeah"
  }
]
