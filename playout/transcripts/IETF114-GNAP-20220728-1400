[
  {
    "startTime": "00:00:12",
    "text": "right yes is uh but that is better for us yes okay"
  },
  {
    "startTime": "00:02:02",
    "text": "yep all right folks um it's time to get going this is kinap at itf 114 welcome so we have um we have basically a big status update and walk through of your shoes today so we're gonna get to the meet here but let's just sort of quickly remind everybody about the note well and about the itef code of contact which we actually didn't put on a slide but you've seen it many times this week so you know you know what it is and also it does involve masking up which i will not demonstrate here we go so hello unless you're um unless you're a presenter and then you can do as you please the microphones work reasonably well with masks so it really doesn't matter that much all right what are we doing next uh it's um i think yeah we need to and we it would be great if we can get somebody to keep an eye on um or on the chat room as you know zootopia's mirroring into the meat deco if somebody could keep an eye on it and see if it's something new channeling but we do need a minute taker preferably to work directly into the minute taking tool so do we have any volunteers volunteers for minute taking yes no yes no volunteers who mean it taking"
  },
  {
    "startTime": "00:04:00",
    "text": "no nobody feels oh i mean i think we can worst case we can deal with that i think because there isn't all that much probably to to a minute this this time around so um so we have um the editing team um justin is remote um he he did say that oh he is actually here um so i'm going to turn it over to justin and aaron i think aaron is going to be the one standing at the upfront here and walking us through what's happened with the core documents since last time and there's justin in full color and then we let's just flip the slides yeah so if you just no we're just getting this light up here all right i think if i do this oh wait you got it right nothing changed yeah if you right hot if you hover on the arrow from that list if you hover on that you think you go to that thing then the right there you go okay the mechanics of slide sharing sorted okay"
  },
  {
    "startTime": "00:06:00",
    "text": "um yes i'm aaron parecki gonna go through some of the slides here and i think justin's going to cover for me for some parts of it as well and i'm going to give you an update sorry now i have it yes it works um the rough agenda for the session is um we have some updates to share about the various uh the two documents that are part of the uh the group right now and i'm gonna go over some of the changes what they mean share kind of details on on what's happened with that and then also talk about some of the stuff that we are planning in the future and i think we've identified a couple issues that maybe we can talk about here as well so the um the full dip links are on the slides they're clickable if you are on the pdf from the meeting materials um and we're going to go over the the changes here so there's two drafts there's the core protocol that talks about client authorization server communication and there's uh the second draft is the resource server draft that talks about resource servers um validating requests coming in and what they need to do to to deal with that um most of the work that has been done has been on the core document still there's been only some minor changes to the resource server draft so that's the big to do item in the future we've been working on github so if you are if you want to see the details of all of the changes they're very very uh meticulously documented on github which i appreciate and you can go find the pull requests that have emerged along with the discussions that have happened there and we've been trying to do a good job of making sure every change goes into a pr that gets tagged and tagged properly and now you can see them all by clicking these links"
  },
  {
    "startTime": "00:08:03",
    "text": "the uh the changes that we've done on the core uh document have closed 40 of the open issues which is a very good number it's i think that's one of the largest numbers we've been able to deal with between meetings so that's great a lot of good progress there and then unfortunately none of the issues on the resources were draft have been closed from the changes so it was just other things that were um that were changed so the uh changes that we've grouped them into uh editorial versus actual functional changes so all of these are links to issues on github again if you're curious about the actual text behind these uh behind these changes in the draft the um so there's text consistency just means that we found some inconsistencies with the text in the spec which have been corrected so they are now um better describe what they're talking about and um editorial is things that you know don't have any functional changes but are otherwise maybe more significant changes and that release number 10 is just the mechanics of doing the release so i think we're going to go into uh some of these in detail yeah um we now have fancy diagrams in svg which is the new way to do diagrams in these rfc's we have the ability to publish svg now um one of the cool things about this is it's actually generated from the ascii art source so kind of cool um which also means it has a nice fallback to if this is represented in ascii um [Music] the uh there's been some changes on the on the idea of future proofing for new jose signature methods and that was again we're not trying to like lock it down to the current snapshot so we want to make"
  },
  {
    "startTime": "00:10:01",
    "text": "future proof and when new mechanisms come in they are usable here um there's some changes around the uh the rights for apis of like what what what it means when the client is asking for access to a thing about whether that's a string or an object and um some discussion on resource owner policies which i think address a couple of issues simultaneously um there's also a new um paper from florian with a very detailed 125 pages of security analysis of the protocol that was a thesis paper so congratulations on publishing that and thank you for doing that also and there's now an acknowledgement in the in the spec that mentions that as well um the tldr i guess is that there's um mitigations for many of the security issues that were identified have been mentioned in the spec already which is good but there will need to be more analysis done if an app is ever used as an identity protocol so that is um yeah thanks for doing that it's a lot a lot of reading i'm sure and a lot of writing okay on to the more functional changes things that actually change behaviors of any implementations um there is a uh so 415 is the i think the only security related thing uh that describes this idea of a session attack and a consideration for it a couple of the syntax changes are really nitpicky things about just like it would be nicer if we didn't have such a verbose object structure for such and such um there is one feature that has dropped and dropped and this has kind of been a theme is been removing things that don't haven't had a lot of interest expressed in it there's"
  },
  {
    "startTime": "00:12:02",
    "text": "there was a lot of things in the uh in the uh in the course back i guess or at least in the the mentions of possibilities that have been um we've been whittling them down to remove them because there hasn't been interest in those features and if there's an interest then there's not going to be anybody to write the text for it which means it's not really going to be a feature um and then there's um on the protocol flow side there's a new state diagram which is um try to describe how how we expect the state of the entire system to change over time who's talking to what uh there's some discussion around that and there's now actually a new change that allows interactions to time out which basically means that if it's explicitly mentioned that we're not expecting like the as to hold on to things forever um so again those are all linked if you want to see the actual details um this is an example one of the syntax changes where it was just kind of a over from some previous syntax that i think it had more options in it before and uh by removing some of these options now the syntax is kind of redundant so it just uses a string for that user code this is the thing that like the user would type in they would see it on this on a tv screen type this in so again minor change but it is technically a breaking change right uh just on that last one i want to note that uh that that syntax change is there's now user code url and user code as two separate modes whereas before they were they were one thing and it was confusing because sometimes you could do one and sometimes the other and it wasn't it wasn't clear on what a client would actually uh need to expect at any point so this goes with what aaron was saying before of like you know looking at what people actually want to do with this and whittling it down to be as as simple as the mechanism can be and so this was the syntax for this mode"
  },
  {
    "startTime": "00:14:00",
    "text": "catching up with what was actually in it because it doesn't make sense for to have an object that only always has a single value inside this protocol yeah and i think um that is a theme that you'll you'll see with a lot of these changes is that it's we're trying to make it so that a client developer doesn't kind of knows what to expect by the data that's coming back and they don't have to go and look it up necessarily because it's kind of just obvious what it does so hopefully this helps um this is that split token feature that um sort of previously existed um that we have now dropped the idea was a request for a token might return actually multiple tokens which the idea was if you have multiple apis multiple resource servers and you wanted them to be able to not have to validate the same looking token if you want actually different tokens targeted different resource servers you could get them all in one request it sounds like a cool feature i agree it's a cool feature apparently nobody was interested and it also complicates things quite a bit so if there isn't demand for it it makes sense to drop it otherwise it's going to be only half baked in the spec which is not which is probably worse actually it's definitely worse so um and this particular uh this would be this is a really reasonable thing to target as sort of an advanced extension so somebody who needs this inside their particular ecosystem that wants to actually build this out and get experience with what this looks like especially with um the additional complexity on the client side of like i only asked for one token but you gave me back three because you've got three different rs domains that you're dealing with a client's gonna need to know what to do with that and there's a lot of unanswered questions there that that this function was raising that you know implementation experience would uh would help answer there so this could come back as an extension someday but it was it was not a good candidate to keep"
  },
  {
    "startTime": "00:16:00",
    "text": "in core yep thanks um okay key proofs so in the previous uh version there was a this is how the client is telling the as what it's going to be using as a proof is that i get that right yeah um you used to have just this string which is essentially internal internal description of what that is um between the the at the ais the new mode actually gives it the ability to have all these different attributes of that method because the um because http signatures can use different algorithms and different digest different signatures and different digest algorithms so http signatures by itself is not enough to actually describe what we actually mean so there's now an expanded version of this that describes the exact bits that are required um this one is a fun one that um actually i need to go file an issue on one of the oauth specs for this as well um the the hash algorithm names there's been this convention of using abbreviations for them or shortened versions of the names and there is an actual registry that describes exactly like the short string to the actual method and a lot of specs haven't been using it and they've just been sort of crossing your fingers that people are going to figure it out so we did a big pass through this spec and updated the algorithm names to actually properly reference the iana registry for the algorithms explicitly and that is much better than just sort of leaving it up to everybody to figure out what we meant by sha2 so uh that is technically a breaking change because if anybody had written code that recognizes the string sha2 they now have to update it to recognize shop2512 or send that"
  },
  {
    "startTime": "00:18:03",
    "text": "okay this is for you justin right yeah all right um so i don't think i have slide controls on my end so i'll just ask for next slide as we uh as we go through this um all right so what uh what we realized a while ago there was an issue filed for this quite some time ago is that uh there is sort of an implied life cycle when you're making one of these requests for access whether it's to an api or user information or whatever uh there's this life cycle that everything goes through and that it um you know you kind of uh this exists in oauth as well but it's it's never really talked about in oauth space until people started uh defining the uh grant management api over in the fappy working group then it starts to kind of come to the fore that there are these uh underlying sort of grant request objects that go through different states in the protocol um so what we decided to do in gennapp is call that out explicitly so next slide um we put together this is uh we mentioned this at the last ietf meeting in vienna this is what we've come up with for uh the state diagram from the mostly from the as's perspective of what something of what a grant request can go through uh during its life cycle so either it's it's waiting to be approved or it has been approved and it can move back and forth between those states until eventually it gets to a state where you you can't get anything uh you can't get anything more out of it all right i'm gonna go through each of these states uh and talk about kind of what they mean and how they move between each other and this is a new section that is in the um that is in the draft and i just i do want to take a a a quick second to point out that uh we mentioned fancy diagrams this diagram this actual diagram is actually in the draft as"
  },
  {
    "startTime": "00:20:01",
    "text": "ascii or not as ascii as svg um and that just makes me very happy that uh that we can do that in rfcs now um okay next slide please so the processing state this is where things go when you first make your request it's also where things go sort of in between the other the other major states so this means that the as is trying to figure out what's going on it's looking at the context of the request all of the information that's come from the client instance any information that's come from the end user and the resource owners and anybody else and it's trying to figure out what do i need to do next this is a transitive state uh in that you know you're not really meant to uh stay here for a long time but while you're in this state you're not issuing any tokens you're not uh you know issuing any user information uh you're trying to figure out what what actually needs to happen and uh if you need more information you move to the pending state so usually that means you need uh interaction for the end user uh sometimes it means you need to asynchronously go contact a resource owner sometimes it means you need more information from the client instance and uh but in all of those cases you're going to move to the pending state if you're all if you are satisfied as the as with everything that you've been rece uh that you've received for this request so uh you've either already interacted or the client gave you enough information that you can just issue things right away then you move to the approved state um and then if you get to a point where you just uh you realize that you can't process anymore so there's this you've exhausted your interaction capabilities the client hasn't given you new information or you're just in sort of an error state and you need to say like yeah this is this is done i'm not giving you anything else you move to the finalized state we're going to step through those now next slide please"
  },
  {
    "startTime": "00:22:00",
    "text": "so pending means that the as needs more information it has gone through its context and it has determined that it needs information from somewhere um this is the state that the request is in when you're waiting for the user to go log into the site and interact or enter the user code or get redirected or use the app or whatever other mechanisms that you're using during the interaction phase uh this uh the grant is basically sitting there waiting and pending uh you know pending that that interaction it could also be waiting for the client instance uh to send its post interaction follow-up message so uh you know when you're in this state and you know the user has like checked all of the check boxes and click the ok button um if there's an interaction finish message then the as uh sends that finished message out but you're still sitting in the pending state until the uh until that finish message comes in and says that everything is you know is approved or denied or whatever it is and that importantly moves you back to the processing state so you never go from pending directly to to approved the way this state diagram works is that you always flow back through the processing state because the as needs to consider everything that it knows at that point of time um to decide whether or not you might need more interaction or say you got one resource owner to sign off and you actually need two or three different ones to sign off you could go from pending to processing to figure that out and straight back into pending since you're waiting for more people to kind of show up and do their thing that may or may not be actually using the client um uh let's see here no modifications uh can be received when you're in this state so the client can't send any updates to the request it can't change what it's asking for it can't uh you know request new access tokens or"
  },
  {
    "startTime": "00:24:00",
    "text": "anything like that um it's just uh you're not issuing anything when you're in this state um and if during this state by the way uh this this was this is a bit that wasn't um wasn't called out in the text previously uh it is actually uh possible for your interaction methods to time out because you know you're not gonna have a re a redirect that is just open forever uh you're not gonna have a user code that is just valid until the end of time you're probably gonna throw those away at some reasonable timeout and uh if that happens and uh you're saying that like no this is completely cancelled and i'm not doing anything like that you can drop straight into the finalized state which is which is the uh which is a terminal state uh next slide please sorry to interrupt guys this is going to be quite a long presentation so if you have any comments or questions do jump in don't wait yes please yeah yes please yes uh we should have noted that the uh the editors kind of strung everything um strung all of our presentations together in one in one giant deck so feel free to to jump in at any point okay so the approved state is when the as is decided that it has everything that it needs and it can issue some access tokens or some subject information uh directly back to the client instance um when the uh in this state the client can um continue the it can request new access tokens based on the current state of the grant so anything that's already been approved the client can ask for additional access tokens to be issued uh during this state again if the as approves that this is this is where that piece happens the client can also modify the request so either step up or"
  },
  {
    "startTime": "00:26:01",
    "text": "step down or you know a subset of access or something like that it can send a modification request uh to the as at which point it moves back to processing because now the as has to figure out what do i do with this new context of information do i need more uh information so i go back into the pending state or are they asking for a subset of everything so i can just give them the new token or give them the new claim set and just go on with our day right from here um and uh if the as uh revokes the request uh or you know it times out or whatever the as decides this can also move directly into the finalized state from here next slide please and finally no pun intended uh the finalized state is a terminal state this means that the grant is done and nothing more can happen so when you're in this state you are not issuing any new tokens anytime you get a modification or a continuation uh request that is an error and calling out this as a sort of a separate terminal state uh we believe is actually going to be really helpful for developers realizing that like these aren't things that necessarily have to stick around uh that you know you have to keep around forever uh once you decide uh as the as once you decide that no more continuations can actually happen nothing more can be gotten out of this grant request then you just you finalize it and you're uh you're on your way in oauth this is equivalent roughly equivalent to the refresh token being no good anymore uh because you're no longer able to sort of make modifications in the context of that original request if you need new tokens if you need new subject information you have to start again from the beginning just like you would have to do an oauth with uh with a refresh token that's that's no longer next slide please aaron um all right that is the grant uh life cycle i want to pause for any"
  },
  {
    "startTime": "00:28:01",
    "text": "questions on that life cycle discussion uh if people want to know like why it's there what we're doing with it what it means no all right well i will hand it back to aaron for the next part of this presentation though okay so there's still a bunch of um open issues on the draft some of them are planned to that we're already planning on doing that's effectively you know accepted the uh list of issues here that are spelled out are actually ones that at some point in the past we've actually put into the draft itself as uh references out to make sure that we don't forget to do them um there's a whole section that we want to do on key rotation for tokens so that clients can actually not just have to use the same key over and over again um there's client management and then there's a bunch of work to do in the resource server draft mainly the idea of token models i think we have did we have slides on each of those i'm trying to remember yes we do okay um a couple of other related work that's going on is uh http message signatures which is a not tied to any other particular layer it's in the http working group um what is the asterisk justin um the http working group is meeting this afternoon and we will be asking for working group last call then uh got it so yeah so this week uh today today yeah literally in a few hours it's it's already in our slide deck that we're going to ask for working group last call um because we the editors of that spec myself and"
  },
  {
    "startTime": "00:30:00",
    "text": "annabelle uh believe that that that is that it's ready to move to the next stage yeah i'm really excited about the message signatures draft i think it opens up a lot of really cool possibilities and it is one of the options available for signing things in gnab so that's how that's why it's related um the signatures draft itself doesn't say anything about gnapp obviously or any other higher level protocol it is just about http message signing so yeah that's super cool very excited to see that progressing also related security events subject identifiers so that uh i don't know i don't remember when it went to last call but the changes after last call are now in progress um and that is remind me where we use that in gnapp justin so that's when uh you're getting back uh identifiers for um for the end user uh and also uh so when you're like basically who's there right now uh the eas can respond with it's this person identified by this email address or by this opaque identifier or by this subject issue outside of an assertion wrapper right okay so not necessarily related to security events but as part of the integrated protocol okay great um i i think this next bit is mine um unless you want to unless you want to go for it all right okay so um not seeing anybody at the mic um all right so key rotation uh has been a topic that uh has been brought up as a as a let's do this next for probably the last year um and uh we the editors decided to finally sit down and figure out you know"
  },
  {
    "startTime": "00:32:00",
    "text": "some concrete um ideas on how we could actually do this and uh so these slides represent sort of our early thinking of what this would actually look like in the context of ganap um with the with the way that the protocol is structured and especially with the clarity that uh that came from doing all of the um state diagram uh the state machine stuff this this last major revision um we realized that the major thing that we need to tackle is rotating keys specifically for tokens so being able to say that for this particular token i want to use a different key from the one that i did before and if we're going to do that mechanically as part of the protocol we need a way to prove possession of both the old key and the new key simultaneously now initially our naive thought was that oh we should be able to do this in kind of a universal way across all of the different key proofing types at least all of the ones that we've thought of and we realized kind of how dumb an idea that is um because they all present keys very very differently and who knows what else people are going to come up with for signing methods and key binding mechanisms and i mean we could see the revival of token binding in this space like who knows like we we can't predict that so our proposal is to actually allow different kinds of key presentation for each different uh proofing type um in order to sort of fulfill a basic pattern to show that uh you possess both keys and can rotate it um and then and this would be you know part of an explicit part of the protocol that says i am rotating this key and so look for these this this bit of information so the pattern here is that you want to"
  },
  {
    "startTime": "00:34:00",
    "text": "sign your message with the new key and as part of that you want to sign the new key with the old key value as part of that presentation so this proves that you were in possession of the pub of the old key when you identified the new key so that's you you're taking your old key and signing the new key value and at the same time you're also in possession of the private key information of the new key so that you can sign that message of the old key with the new key to show that you have both of those at the same time uh next slide and the basic idea is that there would be different ways to do this based on different proofing methods so http signatures is an interesting one because it uh by design allows multiple pictures on a single message including the ability to sign a signature on the message so you sign the message uh with the old key and then you sign the message again including the signature of the old key with the new key and that fulfills that you know the double signing function to prove that you have both keys at the same time um how exactly we signal this um you know that's that's sort of a syntax and bike shutting discussion that we've we've got to figure out and we've got to discuss as a working group uh because you want to be able to say like hey i am signaling that i'm doing a new key here and here's the information and make sure that that's all tied together and all of that other stuff uh this would be a field inside of the token rotation um and the token management uh calls by the way since we're talking about changing keys for specific tokens uh next slide please with the jose stuff um we can do"
  },
  {
    "startTime": "00:36:00",
    "text": "we can embed jose objects within each other right so um you can have a uh jose format that allows the new key to actually be jws signed with the old key value um as a jws payload so you sign the outer message with the new key and you sign the new key with the old key that proves that you actually have both or held both at one point um this probably assumes a jose flavored key format can app technically doesn't make a strong connection between the key format and the signing method so you can do hdb signatures with certificates or jose with certificates or signatures with jocks it can app itself doesn't actually care but this rotation method kind of presumes a key format that's something that we would need to discuss and figure out so uh this this is something that could work though uh next slide mtls is definitely an interesting beast though because you can obviously really only get away with presenting one client certificate uh at a time uh at least as far as i'm aware yarn might be giving me a side eye at this point he's off camera i can't tell um but the thing is with most mtls deployments uh you're actually already relying on external certificate management systems or in pki or there's some other certificate negotiation thing so rotation is mostly out of scope for an mtls type thing that said acme is doing some interesting work with uh client certificate uh attestation extensions uh kathleen moriarty pointed us to this proposed work in acme so that's something we might be able to follow up with the acme working group if there's something that they're working on that we can leverage to say hey if you need to do programmatic rotation with mtls go do this acme thing and this is how"
  },
  {
    "startTime": "00:38:02",
    "text": "you present it as part of the protocol next slide please this raises some interesting questions specifically if i have a a token that's bound to say the detached jose method could i change that to use http signatures with a different key this um this means that it's uh that i'd be able to change out not only the key but how it's getting presented when we were looking at sort of the grand unified key rotation idea uh which i mentioned we had we we have since walked away from that uh that idea uh when we were looking at that um this this was kind of in our mind of like you're swapping out like this entire chunk of how i prove the key versus how uh versus like and what the key itself actually is all at once um but the thing is if we allow this uh it what does that combination actually look like what would the syntax look like to change from jose to huv6 like are you using http sig to sign a header of the jose object or because it's in the body the jose object is fine and how do you do it in the other direction do you apply a signature and then put that into the payload of a jose object it gets it gets weird really really fast and it also opens the question of somebody invents a new proofing method which we expect that to happen um you know what does that actually look like what does that grid look like as that m by m grid of of transformations happens what does that look like so the proposal is we actually just keep this fixed"
  },
  {
    "startTime": "00:40:01",
    "text": "so that we can kind of avoid all of these questions and say once you have a proofing method you're sticking with that method but you can change out the key and we're going to we're going to require every method to define a way including extensions to define some way to manage key rotation or say that key rotation is specifically not supported within the protocol um but you have to like declare that somehow so that's our proposal for for that uh we would like feedback on this uh and this is a discussion that we plan to bring to the list with uh with a bit more of a write-up um next slide please so this uh does bring up a related question uh that's been brought up a few times as a use case for kidnap what if you want to use a different key for the access token than you when talking to the rs then what you use when talking to the as this is something that uh it seems a lot of people want to be able to do um uh at least at least in theory uh but it when you're separating these it does raise some uh tough questions of you know do we require that the client can use the rs facing key at the as which means that the as needs to be able to validate that key um and it might not always have the ability the same ability to do so if the as rs are in different domains and you know whatever reasoning you have for having a separate key for the rs as well um so that all needs to be considered technically if you get into the syntax of gnapp you could kind of do this now but we don't actually say how to do this or or what anybody is supposed to expect in this uh you know in this circumstance so we this"
  },
  {
    "startTime": "00:42:00",
    "text": "this does need to be nailed down and it feels like it's going to be very related to the whole uh key rotation thing because you're presenting multiple keys at the same time and figuring out what to do with with each of them so this is a separate issue from key rotation but we think it's all kind of going to be tied together speaking of next slide client instance management is another thing that has come up so uh if i dynamically show up with a client it sends and say you know here's my key here's everything i can get back thanks aaron a um an instance identifier um oauth has the dynamic client registration protocol but also the separate dynamic client registration management protocol in a separate rfc um and in ganap we realized that we could actually have a um use a very similar pattern to what we're doing elsewhere in the protocol for grant continuation and the like and just hand the client back a uri and a special access token to use at that uri to manage itself and next slide please we just define a restful or rest ish uh api for the client to change its properties to rotate its keys using the same probably the same kinds of syntax as previously um and uh you know change its display name and the home page and all of that other stuff um anything that would be associated with the client uh and and that dynamic identifier um could be done through this api um we've got all of the places that we need to hang it we need to decide whether this is something that goes in the core whether it's an extension and whether this is something that people actually want to use next slide please all right this is fabienne's part so"
  },
  {
    "startTime": "00:44:02",
    "text": "uh before we move on any questions on the keys the clients any of those bits very quiet crowd today everybody's in the outside meeting i think or is that no wait no that's this afternoon all right go ahead fabian hi we hear me okay it's a little bit can you say something else because your audio is a little bit low it's a bit low okay i'll try to speak louder um so yeah the idea is to discuss about the token model i'll need some hand also just like uh justin did because i don't have access to the slides so i'm like please aaron hello yeah i can hear you just fine uh yeah i don't know if the room can um so i'm not sure who was running slides for me do you want to take the slide control fabian i'm happy to press next slide for you if you want but you can also take control right do you hear me yeah yes so i need to i need a hand you actually"
  },
  {
    "startTime": "00:46:01",
    "text": "change the slide please um hello yes but yeah you're coming across it it's a little bit low but it is coming across so if you speak up from three clearly it will probably work fabian can you actually hear us yeah fabian can you hear us well yes thank you um is there someone that could actually change the slide because i don't have access to the slide deck okay thank you very much okay that's fine uh so yeah that part of of the discussion is actually very open it's actually because we've got some issues on the rs draft so second part actually of the work we're doing and issue 15 you've got the link into the slides it's actually discussing about the generic format maybe as an appendix maybe as something that's non-normative that could be actually used for implementation guidance so that we could actually relate to that when we're actually designing"
  },
  {
    "startTime": "00:48:01",
    "text": "uh what we need in in in the access token and we do think that it's a good idea we are looking more for something like a token model instead of something like a token format itself um but we do think it makes sense and the idea is to actually open open the floor at the end to to get your your feedback on that next slide please so what we've got in the eras draft today is uh token a list of token formats that we have some it's just an id list for now it's very unstable it's as of today and it's it's not written in stone so it can change but typically today we would have a registry that would contain some some things like judge sign just encrypted so that's fairly obvious and then open the the possibility to other types of formats like macaroons and biscuits or z-caps which actually providing different types of of features and we'll see that in a minute next slide please um so just to give you an idea that many other types of token formats exist you've got a link to your podcast on the blog which was done by fly.io so it's not mine it's just something as a reference to give you some ideas on other types of of of token formats so obviously you you get dirt inside them you've got pasito which is well some people like it some some don't uh and so on and you've got macaroon and biscuits which are described also in in that document and of course it gets into more detail but the idea is where you're very used to using jot it's obviously everywhere"
  },
  {
    "startTime": "00:50:01",
    "text": "but in some cases uh it's maybe not the the best format in some cases you need those of things and it's not what we'd like to do is to actually open the possibility for evolution uh even in the jose world but then uh of course we need to check what's inside each type of format and that's one or so of the reasons for uh discussing uh token models instead of token formats it's also to be able to guide in terms of information that's inserted into into our token but not mandate some specific implementations next slide please so what's the difference between a format and a model as we as as we understand it the token format is well in our case it's typically a jot but other formats exist as we've seen and the reasons why we want to accommodate various formats so the first one obviously is the productivity and i've put at the end on appendix for jose examples for instance new work items like json proofs and well a lot of other works which are related here and also the revolutions in the jersey world for post quantum possibilities so that's only beginning but we see that this need for more uh going on in the space and then we've got different use cases so jot is adding proofs probably and and then you've got macaron and biscuits which have a different way of working so it's abstractive instead of additive and for instance you can implement things which are not available in jots like attenuation capabilities so an example is maybe an i'm an administrator from for a building i actually give some biscuits or my carrots to my employees and then they can actually attenuate the"
  },
  {
    "startTime": "00:52:00",
    "text": "token to just limit it to some part of the building that could be accessed by someone that's external to the building that's external to the company that's the type of things you could do it requires offline delegation in some parts so it's it's really a compliment to what we're doing with that so in some cases it can be useful in some cases it's not obviously it just remains the main useful token obviously but it makes sense in some cases to not mandate data specific format so a token model instead is really information that's typically shared by implementations whatever they are and so we that's really the focus here next slide please so where should we describe the model um the first possibility in the course pack uh so in the course pack you've got the link here to appendix c which is on the component data orders and for instance it's just a note right now it's not written in in the following way but for instance we we refer to to be done for the to be described for the token so the token has a resource owner it has a user a client some resource list a list of rs servers etc and and we could probably detail the token model there we could also provide a summary the thing is the core spec is already quite long so it it needs to be there only if it's really uh completely well it's if it's highly important in that in that specific spec the second possibility especially since the issue is is actually on the rs draft itself is that the errors draft might be a better place order it's it's very open here it's it's not completely clear but it could be described here for the model as part of the context of the arrest draft"
  },
  {
    "startTime": "00:54:01",
    "text": "and it it might be a good way to actually have a link and and the description between the model and the supported format since we since in the errors draft we already described the the support the ones which are supported um of course that's the question of how do we actually make the mapping to the explicit schema it's i'm not really sure that it's it's meaningful to actually do that but at least doing the exercise externally is important we need to make sure it can be done next slide please so what's an access token value um that's important to have in mind uh that's really what we what we use in the in the course spec and as a reminder the access token is really your pack to the client so it the client doesn't need to know what's inside the token itself you just need to actually be able to receive it and then send it to the resource server and in the course pack so you've got section 3.2.1 on the access token where you do find a description on what's value that's required at that point and in the es response we also have a lot of information that's that's important we have metadata on what the value means so we've got a label we've got associated rights which is actually an array we've got technical data as well like a key some information on the expiry the flags manage url etc so you do find a lot of information on the access token already in in the api that's provided in the course pack next slide please so then you've got token introspection um so that's actually provided in the rs draft in section 3.3 and as a reminder so that's already in"
  },
  {
    "startTime": "00:56:01",
    "text": "in the course pack a token maybe appear or it could be keybound and the key the default is is that it is keybond and um and then in the errors draft you do find some information on how to do token introspection so the types of parameters that you're actually going to provide so you've got access tokens you've got the proof so that's actually something that's recommended um the thing obviously is to be able to be very clear on whether you're in a bearer token mode or keyboard mode and that's why you've got flags in the course pack and then you've got the resource server and you've got the access object so that gives you an idea of of what you need to do when you're actually interested in the the token and that's that's the kind of interaction that you need to have in mind when you're designing that next slide please so the relevant documents now that we need to take into account so there's a few um it's not an exhaustive list but you've got the the scheme schema management for identity which is interesting i do find a lot of information on the type of of attributes that are available then you've got a new draft from victorio actually on the jet profile for all access tokens where you do find a header with the type parameter that's available in there and then you've got claims um an interesting note here uh i'm not entirely sure it's it's a good idea but anyway it's just a personal opinion here uh you've got some new inf values for growers groups entitlements etc these are actually the three that are available and then you've got the"
  },
  {
    "startTime": "00:58:00",
    "text": "best current practice and there's a section in there which is quite interesting for us which is quote jot confusion and the types of mitigations which are available especially if you had a token which was uh generated in some context like o2 and then what would you do if it was actually sent over a wire to the service so next slide please and now you do find the mitigations which are actually provided in the previous document so you've got four methods um and that shows you some important um attributes so of course the issuer the subject that's something you need to validate same for the audience and then there's some uh recommendation here on christina's lane like uh the keys uh that are available that's you need to to actually make sure that you don't take that for granted and then the last method which is interesting for us is uh to use explicit typing and this might lead us to define something at least for the types of formats to not plus chart as a proposal so next next slide um in terms of other relevant documents even if you're not looking at the formats themselves it's still interesting to make sure that the mapping is possible so i've looked for instance at pasetto [Music] well which makes claims on jersey method and so on but i don't want to get into that it's just to make sure that other types of format would be would be possible in theory at least so they are actually providing a they don't provide a type they do provide a version which is fairly equivalent to having four new jazz algorithms in some way so"
  },
  {
    "startTime": "01:00:02",
    "text": "there's a v3 and a v4 and you've got a local and a public type of algorithm which supposedly is is a solution for the alec methods but actually you still need to trust the message to know which arg is used so it doesn't really solve the main issue since you can still change the algorithm and you've got the purpose which is similar to the audience so an idea of audience makes sense obviously then you've got the payload and then you've got the footer and the footer interestingly is is mainly used for key rotation in that case so it gets sets back to the previous discussion on key rotation another example is biscuits so here you've got only one cryptographic method and you've got a data log engine so it's actually a bit more advanced in terms of how you actually process claims it's not just a schema it it's actually got a an engine that's that's underlying so you've got blocks you've got base types like you can have dates and and and a lot of different information there and that that's actually what gives you some additional capabilities like uh very for instance you could have third party blocks which actually come from some external source that you can check for instance and then you you do find unique identifiers and especially for the revocation id so you do find something that's related to something that looks like gty next slide please um and so what's different in gnapp so the main difference obviously is client id from or2 becomes client and scope becomes access so that's really the main difference and so you do find on on the right part of the screen uh what you've got typically in in the"
  },
  {
    "startTime": "01:02:01",
    "text": "what word like issuer the subject the audience that's something that's fairly classical that you would find pretty much everywhere gti is also something interesting um not sure we we we should if we want something that's completely generic gti in some implementation it's it's really linked to json in some cases it's it's not the way you want to implement that from the previous examples but anyway that's the kind of thing you would find client is is fairly obvious it's just a name change between client id and client so it's it's very trivial access obviously you can embed that within your payload part but it's kind of redundant because you've got that into the answer from the from the api in in the response part so it could be optional you could well first it could be something we don't include or we don't mandate to include it will be optional or it could be something that we just passed by reference as well uh just like we do for kid for instance and then we've got some other questions like um sub uh in our in our documents sub ids are referenced to a specific spec so it's a bit more complex here it would it would be meaningful but only for all pac identifiers so is it something we want to [Music] to unfair or do we want to make sure that we can actually actually type the sub identifier uh can we for instance find there something that's a phone number or something else or did maybe uh and then um we've got flags and keybounds so we've we've discussed about kids but um that's the kind of things uh do we want to actually how do we want to actually deal with that same thing for expiry do we"
  },
  {
    "startTime": "01:04:01",
    "text": "want to to to on the expiry directly in in in the token or not in many cases makes sense but maybe not every every time and then a resource owner in practice it's often the same as the user but maybe we we need for some some specific cases which are discussed in section four of the main spec maybe that could be something where on top of the sub identifier we might in some cases refer to resource owner so it's just to give you some ideas there's more on the map between over 2 and the gnab in the appendix d5 from the course pack and i encourage you to actually have a look at that next slide please and then as a summary in terms of editor probably a new type for kidnap makes sense at least for drought formats but it's something to avoid cross cross protocol attacks that could be interesting we've seen that we've got mineral claims that are useful in all cases so issuers sub audience gti and client and others which are which could be used in some cases and which might be optional or we will have to see so it was ready to give you a broad summary of of the of issue 15 which will be i think quite important because having a format is this is quite critical in a slide and i think we we get to the end and that's the next steps um so here it was just a discussion because it's it's something which will be important especially for implementers so next step is to actually submit a pr we can actually expect that in the coming weeks and the idea is to actually"
  },
  {
    "startTime": "01:06:00",
    "text": "be able to to review it publicly and feedback is obviously welcome and if you've got some ideas and and fixed backs on that we're we're quite keen to actually discuss it so thanks very much and i'll let the questions if there are some questions and thanks aaron for changing the slides all right all right and uh and that's it for the editors uh slides although okay i did want to yeah unfortunately i'm not down in philadelphia but uh somebody at identiverse gave me the gnap smurf um so he will be coming to future ietf meetings when i'm here uh in person and uh aaron's promised that we're going to do a uh a photo shoot with this guy so that he can live in all the slides going forward so um just uh we didn't get we didn't get a chance to get him into the presentation so i wanted to make sure that uh he actually showed up at the meeting that's big enough that's right there's there has to be you can have smurf uh from every meeting yeah that's all we had um i don't know if uh there was i don't think there was anything else on the on the agenda i saw a proposal but i don't know what happened with that so we did uh go through uh what we had scheduled but and you know obviously if there's anybody who wants to raise any issues or talk about anything in the presentation or that wasn't covered by the presentation now is the time to step up to the mic um while we have you up there um if you would like could you have some some idea of the timeline ahead i mean what are we talking about in terms of iterations before we're getting close to"
  },
  {
    "startTime": "01:08:00",
    "text": "um our our goal end goal here yeah so um the way the way things have been progressing a lot of what's been changing over the last i want to say you know six to nine months or so is that we've been um it's been a lot of uh removing um sort of the more esoteric features like you know split token and the capabilities array and stuff like that stuff that seemed like it would have been a good idea but nobody was building and so we've been pulling that stuff back uh and so a lot of what's been going in has been uh either clean up of that or um a lot of editorial discussion within the document itself so things like the uh the whole state machine discussion like that that entire section and the the effects that it had on the rest of the draft didn't actually change the protocol but it changes the document significantly and sort of how people would approach the document so um this is a very roundabout way of saying that i think we've still got uh a few more of those um oh is is my is my video not coming coming through okay uh you all mentioned in chat that your video is getting clipped it's coming up yeah so um so i would consider that um the biggest things that we need to do in terms of functionality are sort of the key rotation stuff that we talked about in the core document um because that's that's something that's been um been brought up a lot uh and including the key uh"
  },
  {
    "startTime": "01:10:00",
    "text": "the key splitting between the as and rs um so i would expect probably by the next ietf meeting we'll have uh a draft that is fairly feature complete um and then from there it's going to be uh the work to make sure that you know the instructions for extensions are all in place all of the ayana registration stuff is all in place which does does take time and text but is uh less less about changes in the protocol itself all right um it looked like we did have somebody in the queue for uh all right you want a channel left back all right well perfect yeah so i i guess to kind of uh yeah mike perek here um good to see justin in this context as opposed to over in other working groups so um you know i guess kind of two questions i mean what is the end goal i know the question was asked around that but is that are we going after independent implementations you know full interop etc all the way through or just to get the protocol to find can you have some clarity there and i have a kind of a follow-on um for that as well but um i'll i'll i'll let the chairs answer that because that's more of a general ietf question than anything specific to get out well i mean we are obviously looking for us we're looking to produce a couple of staff at least a couple of standards track receipts right that is kind of technical output to this right implementation wise that is typically um a thing you kind of incorporate into the idea process process software like this rotation so the way this typically happens with iotf protocols as you publish your rfcs you select the market"
  },
  {
    "startTime": "01:12:00",
    "text": "response by sort of implementation and deployment and then after a while sometimes uh a year or two sometimes longer like the working group gets reconstituted reconstituted you go back fix all of the bugs that the market has identified in the implementation spin out a few bits versions of the same warranties and then you you kind of have achieved the level of stability right that's kind of the arc of a typical perfect yeah no helpful i just wanted to kind of double check that and then specifically in related to get uh you know good app is uh i guess it's probably question for aaron is like octo planning on putting an implementation out once this is out or you know where is that at come back to this microphone um i am not aware of i know otto's keeping track of of like you know keeping track of the work going on but i'm not aware of any current plans to go and immediately build it that said i'm also not the one that is on the actual product or map side of things so i don't actually have that much insight into it so i'm mostly participating this as an individual here another octa here yeah i'm on the product side and we don't have any current plans don't limit this at this stage right so i can say from uh my experience i know of a couple of um implementations that are out there in the wild um but they are in kind of um siloed uh spaces so this is part of a vast's verified dot me platform um but they're using it within verified document it's it's not they're not using it sort of to connect across to other implementations and things like that at this time um i know of a couple of companies over in sort of the fintech space that are using"
  },
  {
    "startTime": "01:14:01",
    "text": "nav to do um to do their authorization layer um on things and uh but again they're like they're building it within their their ecosystems and uh i haven't seen a lot of pull yet for sort of like you know large-scale provider or large-scale uh n-by-m interop matrix uh type of testing i can say that i will add that early on when we did the buff and sort of planning out the work we're gonna have um several of the you know large-scale usual suspects in with dodge uh access control not the problems like abs they did say that that the type of patterns that we've implemented in that were quite common inside their domain but as you say they they're inside and right so i think i mean personally i think we're like any uh protocol in this space the the arcs of deployment and testing and effect on the market is quite long typically yes yeah definitely for uh especially for a protocol like gnapp where like if you bolt on enough extras you can do most of what's in knapp with oauth 2. um it doesn't it stops looking like oauth 2 uh after a fairly short while but um you know this is why we've uh put the effort into backboarding rich authorization requests and you know the whole uh pushed authorization request concept is the same as knapp's you know intent registration protocol um so we are definitely seeing the patterns and the at least the people that i'm talking to uh that have decided to go with ganap have tried to uh it's it's generally been they've tried to go do that stuff with olaf and then become frustrated with the sort of the the cross product of extensions and uh found knapp as something that was"
  },
  {
    "startTime": "01:16:01",
    "text": "designed for that cross product from from the start which was one of our goals going into this um is you know as as a design how can we actually um build this out as as its own thing see roman at the mic yeah everyone hi uh roman to neglect university i wanted to come up to the mic wearing no hat and with hats so first wearing the hat i wanted officially had a follow-up on the question about what are we doing with implementations so this document in itf parlance is in the proposed standard kind of status which means that it in fact does not need an implementation to move forward to publication so taking that hat off uh as a as a kind of a personal individual participating group i would strongly urge us to really think hard about doing a little bit of interrupt this is a pretty big and complicated thing we would tremendously benefit from trying to do some interrupt to make sure that we understand the edges here where we've seen working groups kind of do that we end up with such a high such a higher quality kind of product here and while i appreciate that the arc of what he thinks is put out the ps get some adoption kind of return to kind of fix we could shorten the the with a little bit more investment perhaps we could shorten the adoption curve by making sure that we have we have some at least reference implementation and some identification of interop and then based on what we were talking about uh kind of here in the line i'm really excited to hear that folks have adopted kind of the patterns and they have some of that early experience of what worked and didn't work trying different technologies i would love to see that brought here and brought here kind of as a presentation so so i guess justin i know you mentioned it if you if you had some contact with those organizations please do invite them here it would be phenomenal so absolutely as you are aware as everybody i think is aware that there have been some initially um efforts i think lost hackathon"
  },
  {
    "startTime": "01:18:01",
    "text": "um justin and aaron did some work and there's been some stuff happening there yeah i i guess and that's wonderful and perhaps my finesse would be let's bring that that that uh i guess experience of the hackathon formally into for lack of a better term the working group proceedings to make sure that kind of everyone kind of benefits from that experience you again great that the running code is happening we're learning from that let's just let's actually just do a presentation or kind of wrap it up so to make sure that you know what happens that the hackathon is in the proceedings and we can kind of track things across as a decision line yeah and yeah on chat that he wanted to raise some other issue please again go either go right ahead so i just uh before we do i just had one one quick note um and that's that uh there is a there is a pattern for uh interoperability and testing that i think that this group would really benefit from and that's the type of testing harness that open id foundation has made available for openid connect and all of its extensions um the platform that that's built on is not actually oauth specific i know because i wrote the platform and uh the the real question is um you know where where and how could we scrape up the uh the time and funding and engineering expertise needed to take that platform and write a bunch of gnat based tests for it so that people could throw their implementations against that i would love to see that i personally don't have the bandwidth to do it on my own um but i think that that's that's something that the community would absolutely benefit from and i'd love to see us try to do that"
  },
  {
    "startTime": "01:20:00",
    "text": "also if you know going down that road we're talking about sort of maintaining infrastructure for a long while i i think it actually makes sense to partner with something like the oil foundation to talk about sort of after long-term sustainability and for something like that and i agree it is extremely useful all right uh go ahead adrian adrian thank you um i just wanted to mention in case it's worthy of some feedback in this forum and i i'll certainly raise it as an issue i don't think it's going to be resolved in any sense uh today that map in its current form has a potential human rights issue uh the problem uh as uh you know it's a delegation uh protocol uh the problem with oauth uh has been that it leads to platform oligopolies in in the way uh it tends to be implemented uh gonapp is primarily a delegation protocol and that can be human rights affirming which is very good the problem is that ganaf does not allow as i understand it the resource owner to choose their authorization delegate that poses privacy in the sense of data minimization and choice in the sense of giving the resource owners market power uh problems that do have a human rights impact and that is potentially bad if again if my understanding of uh of gnap as it stands right now is uh is correct uh which it might not be uh the mitigation to this problem is to allow the resource owner to choose their request processing agent um"
  },
  {
    "startTime": "01:22:00",
    "text": "right this is the way we choose doctors or lawyers for instance as agents in order to mitigate a power asymmetry uh in our relationship to uh resource servers and uh users of uh clients and whatnot um okay so to mitigate this privacy and human rights consideration ganaf should at least explain how it interacts with an agent of the resource owner so to the extent that the knapp does not treat the as as the request uh processing endpoint uh as being uh chosen by the uh resource owner uh which i guess is fundamental to the design at least the way justin has explained it to me there has to be at least an explanation and maybe that explanation could be that we recommend using biscuits or macaroons as the authorization token formats as was mentioned earlier in order for there to be an agent of the user that can then [Music] process requests or it could be that there are other uh mitigations to this issue that we want to discuss formally in the uh in the document uh thank you that's my comment hi uh so yeah i agree with the concerns and um i also sympathize with the um the how things have kind of turned out in the oauth world and i what i think i'm more disappointed about is that i actually don't think it's a failing of the protocol i think it's"
  },
  {
    "startTime": "01:24:00",
    "text": "just what happens in the market in the real world and i think that even if there were things that like allowed or required that kind of behavior i don't think it would play out differently and one of the reasons i say this is because open id one old old open id that doesn't really exist anymore did exactly that of allowing the user to choose where their authorization server is and basically forcing any relying party to accept arbitrary authorization servers current terminology and you can do that in oauth there's nothing stopping you from doing it but in practice nobody does it because the relying parties don't want to accept arbitrary user identities and authorization servers and i don't think that that is necessarily something that can just be forced into a protocol because as we've seen open id1 it just it just stopped existing because via stopped getting used so open id2 doesn't or open id connect does not share the same goal of doing that and while you still can implement it that way in openid connect nobody really has because again it's not the protocol's fault so i don't know what the solution is but i don't necessarily think that we're going to force it and force that model in by changing changing the protocol so i'll take off my chair hat right now right i don't save time by not running now there but um so even i think you're correct about that right um and that's certainly it's in line with my experience in the digital identity world right that people relying parties actually do want to control who they trust but doesn't mean that uh a human rights consideration section that calls this out it's not a good idea because the way i know that um especially privacy advocates work today is that"
  },
  {
    "startTime": "01:26:01",
    "text": "they work through consumer organizations and you know what will happen if we have that kind of text that somebody might actually pick it up and try to use sort of that as leverage to pressure for sort of support for those kinds of models and they might not succeed right but they will at least have a tool to work with i think it's actually fair for us to give them that tool whether they succeed in using it is another is another story justin please go next yeah so i i completely agree with life i think that that makes a lot of sense we have a privacy considerations uh discussion that does talk about uh you know ownership of the aes already a little bit but um you know that can be uh expanded in the direction that adrian's been talking about um the other aspect that i we need to keep considering is that um from a design perspective one of the things that brings to the table that was much more difficult in the oauth world is the ability to sort of bring new information and different types of things to the eas as part of the protocol process whereas oauth largely assumes oh i'm going to redirect you to a web page and then redirect you back uh map is much more open about kind of what what happens in that stage so if during that stage the af says i need a set of um you know verified credentials from your wallet that you need to present me here to do that uh you know that's not that's not solving the problem by separating the as the rs in the way that uh adrian was talking about but it is allowing the as to"
  },
  {
    "startTime": "01:28:00",
    "text": "um accept external information that's not just this user is logging in and clicking the ok button um so that is a much more sort of system level uh approach to addressing the uh sort of the expansibility of the privacy uh and and policy considerations here um beyond just you know forcing every every rs to accept an arbitrary as uh as its as its connection uh because i agree with erin that previous systems have tried to do that uma tried to do that that was the part of the uma that nobody deployed all right and a lot of a lot of other groups have tried that i saw that this one but you know it it again we can still sort of call the issue out and adrian i think you would be i think it would be great if you would have time to put together some text uh a few lines for uh for uh you know for the even either privacy or even even call it also human human rights consideration section or something like that but that that's a detail but you know that having some sort of text i think would be appreciated but i i assume would be appreciated by the authors as a contribution i i think i'm next on thecube uh i i will certainly do that i am also reaching out to other groups in ietf uh to see if there's a community of interest that would like to address this issue explicitly in one way or another my reply to aaron's uh point and justin's and uh everybody else's is that we are now in given the discussions about the difficulty in regulating these oligopolies these platforms we are now in a very different"
  },
  {
    "startTime": "01:30:01",
    "text": "regulatory capture type domain than we were when owath and uma were being worked on um and what i'm seeing at least and i think many of you um and some of the people in this meeting today is that people are reaching for decentralization or inventing decentralization protocols in w3c for example or diff in places that are not ietf uh to fill in this gap uh that i think an app is at least in my mind supposed to fill and how we fill it obviously i'm not uh at least been able to to say but i will raise this issue with a pr to maybe the privacy considerations section sounds like and see what happens thank you well i think this is lost call for open mic issues going once going twice all right we're done i'll see you all in london presumably same trip captured"
  },
  {
    "startTime": "01:32:09",
    "text": "[Music] so are we doing this yes"
  }
]
