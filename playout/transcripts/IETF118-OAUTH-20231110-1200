[
  {
    "startTime": "00:00:00",
    "text": "Man, what happened to the to the crowd here. Alright, Dave. I was staying with now only those are here who really want to do their work. K. Let's get going then. Welcome to the 3rd and lasts. Or off meeting Can I get a volunteer to help honest with taking notes, Please Thank you? Not Okay. Thanks, Hannes and Christina, for taking notes. Appreciate that. Let's get going. Okay. K. The note, well, hopefully, we're Friday. So, hopefully, you're familiar with this one. So Okay. Please make sure to log in to the meet a co application. It helps us Let's know how many people, attend and plan for future meetings to make sure we have a comfortable room. It also allows you to join the mic if you wanna see anything. And And here's our agenda for today. Will you start with George? Talking about a transaction token. Peter will then talk about identity to chaining, Ned will be talking about the use of attestation DCR. Is that the name or Right. Right. Right. Right. Yeah."
  },
  {
    "startTime": "00:02:01",
    "text": "So I got the name correctly. Okay. Aaron will be talking about first about the native applications. And later global token revocation. And we have extra time for any other business. So That's that's orange. So yeah. Ridiculous. Okay. I I see a few people join the the room a bit late, so please scan the the code and and join the meet echo. Application. Okay. Any comment about the agenda? Any Jinder Bastian, It's not George. Alright. Good afternoon. George Fletcher. Peter's here at tool I think it's 4 AM for him, and he got in really late last night. So I don't know that he'll be online remote next slide. Next one. Sorry. There are there are some breaks in here. Maybe I need to learn how to make slides better. So we'll start off a little bit with just sort of what are these things that we're calling transaction tokens and and why do we have them or sort of what the rationale behind them, before we get into sort of what's changed the last time you presented it, 117 So the goal of transaction tokens are really to look at sort of authorization within the context within a sort of multi workload or microservice environment, where you want, to sort of create an immutable context for the transaction as it traverses through multiple workloads."
  },
  {
    "startTime": "00:04:00",
    "text": "Today, in most of the systems I've seen. You have server to server trust between your, workloads, but generally nothing that sort of dealings with stuff at the transaction level. So, you know, this could be, you know, Anything, from know, a a simple a simple request, You know, like, you know, adding a stock to a watch list or or something of that nature might still go through multiple services and and how do you sort of maintain that the the user of the request is George and you know, maybe it came from this originating IP address, and, you know, this is the stock ticker that should be added. So, it's a mechanism to allow us to create that immutable context. They are short lived, and the expectation is that in a microservice environment, you really can't have atomic transactions. So something fails partway through you really sort of can't roll stuff back. And so if you authorize the transaction at the beginning of a request. Or at the edge of your network, then you should probably let it go through. So the the theory behind this is when the initial request hits the endpoint or potentially is minted internal to your trust boundary. You would, create a short lived token, that represents the context of the of the request. And then it can be basically be passed through all the services directly. Because you want that transaction to complete as opposed to current environments where if you were passing an OAuthOC token through all of these different things and each of them are going back to validate the OAuth token. Right? You could have a authorization failure partway through, which might actually create more problems. And then finally, getting this additional context gives the ability to down scope, especially in a"
  },
  {
    "startTime": "00:06:01",
    "text": "environment where you're coming from a consumer into a consumer environment, like a mobile app or something with OAuth. Your scopes tend to be very coarse grained. Ike. Ike. Ike. Know, I want to read mail and I want to write mail. But maybe what I'm trying to do is add a add a contact to my address book. Which is much finer grained in the sense of the capability. So we'll talk about that. So next slide. And next one. Sorry. So so main things that we've done to the draft, since 17 team, and I I feel like we're narrowing. We have some open questions, but we're narrowing down on this. Is, we had there's 2 concepts in the draft today. One of them is sort of like the the creation of a transaction token at the beginning of the transaction when the requested your network or when it's minted. When I talk about minting transaction tokens, think about something like inbound email Right? I mean, I I get something off of the SMTP protocol. Right? And now I wanna create a transaction token that basically says, deliver this mail message to George's mailbox. One of the key points being there is that if I can bind this into the immutable context the transaction, compromise of an intermediate server can't change the delivery of that you know, deliver it to a different mailbox. So that's one way to get a transaction token. And then the spec also talks about a way to sort of, like, get a replacement transaction token we also had this concept of nested transaction tokens, and we didn't didn't have good uses for them. So let's go to the next slide. So there was a the a lot of security implications didn't have a lot of good use cases, so we took these Next slide. We did add a bunch of new claims audience in this context of a transaction token represents the trust boundary if you think about"
  },
  {
    "startTime": "00:08:03",
    "text": "your, because and this is important because, the next talk, we'll talk about, you know, chaining across trust boundaries. But within your sort of back end infrastructure, Right? If you consider that a trust boundary or maybe you have multiple trust boundaries, but within a trust boundary, Right? Transaction tokens are meant to be scoped to a single trust boundary. So the audience claim then gives you foundry is. The purpose claim is allows you to basic this is the mechanism that allows you to down scope the the actual transaction from maybe the the larger external authorization model. At the end of the day, some of the principles here are that the authorization model for entities outside your network are probably the different authorization model than you have internal to your network And, and because of that, this gives you a way to sort of bridge The transaction tokens give you a way to bridge those authorization models. And then the purpose gives you a way to basically assert the intent of this particular transaction. Next slide. There's also an authorization details I mean, you wanna think this is a little bit equivalent to RAR if you, in the sense of if you have other other details about the transaction that should be immutable Right? You don't want some intermediate server to be able to change them. Right? Then you can put them in here. This does create some interesting aspects when you think about APIs and API driven back ends. So I think there's some thought here, but this is the the purpose of this claim. Next slide. And then we also added a request context object. We define 3 sub claims. This obviously can be extended, you know, talking about requesting IP know, the sort of authentication method, which workload requested it and you can think of other things. Like, if it was an OAuth world, you might wanna client ID in here. As the requesting workload identifier or or something of that nature. Next slide."
  },
  {
    "startTime": "00:10:03",
    "text": "here's sort of the updated example. So The original one was a little bit had was a little bit confusing. So you know, all the sort of standard Jot claims. We're using the subject identifier out of the, security events model, as well as the transaction claim, which is also defined in the security events. Mechanism, transaction, claim there allows you to basically track this particular transaction throughout your network. The the request contacts, the purpose, and then the authorization. So in this case, the purpose is trade stocks. And then you have know, information about that particular request in the authorization details. Next slide. One more. Alright. So getting to the open questions, those couple of things that are open up. They're not I I don't think there's subs super substantive, but, things we are talking about know, is transaction token really an authorization token? Or if you're using the authorization header in your back end to carry client authentication as in a two legged baritoken or some other mechanism. You're not using MTLS to do server to server trust, then should there should these really be in a separate space so you can continue to user authorization header for client authentication. Mechanisms. And then this is a sort of an adjunct to that Justin's, you know, has some work around, you know, token buckets and, you know, maybe that's a space here. Maybe they can go in both places. You know, they can use either or so this is sort of an an open space, you know, would love to have comments either here or on the as an issue but that's one of the open questions. Next slide. There's been some discussion around subject know, should we allow for a simple subject versus using the subject ID claim"
  },
  {
    "startTime": "00:12:04",
    "text": "I I think that this discussion is sort of resolving into only allow the subject ID claim because in this particular case, the subject of the transaction token is not a subject of the issuer of the transaction token. If you think about having a transaction token service in your trust domain, and it's going to issued the issuer is sort of the token service. Right? The subject is maybe the subject that came out of the OAuth token. And because those are different Right? You need the subject ID to contain the issuer of the written you know, the originating subject and not just be a sub claim with you know, in some cases without an issuer, So I think this one's resolving, but if anybody has really strong opinions on why we need to support a simpler sub model and how it would work. You know, we'd love to have that feedback as well. Next slide. So this sort of gets related. You know, the issuer claim? Should it be required, or should it be optional? If it's not there, what do you do about key rotations? Again, I think because the context says that the the issuer of the transaction token is kind of different than the issuer of the subject. It should be there. Some people might claim you know, because it's a single trust boundary, I can then assume that the issuer is always the token token issuer of the of the trust domain. But I think there are some cases where, you know, feedback they're checking there are some cases where you may want your token your token issuing services, your transaction token, issuing services to be distributed still within the same trust boundary. And so you might actually want different issuers They may be using different keys to sign the transaction tokens. So, again, I think this one's resolving a little bit, but it is still an open question. We have not, put any use spec language yet around this. Next slide. And then"
  },
  {
    "startTime": "00:14:01",
    "text": "center constrained you know, should to transaction tokens be sender constrained, and this gets to be a really interesting question. It's know, you're you're within the domain, within a single trust boundary, you have client authentication in most cases. Is there is there really a need to sort of send or constrain it? Cause you don't really want normally when you think about center constraining, you're basically saying, This transaction token was issued to this particular service, and it's allowed present it somewhere. Right? And in that context, that sort of is antithetical to what we're trying to do with transaction tokens in some ways. So again, there's a there's an issue on GitHub repository for this topic. I I could potentially see some binding to say that this client authentication request may be bound to this a particular transaction token, but I'm not sure about the rest of it. I think really what people want in trying to in thinking about center constraining and transaction tokens is do I have a secure call team path? Like, where has this trend, you know, what services has this transaction passed through to get to me. I think maybe more relevant. And, again, there's some other work in this space that might help with, that particular, that particular issue. That's sort of outside the scope of the transaction token spec. Okay. Next slide. And so that was it in the sense of the updates. What we've like to do is to ask for work group adoption. Of the specification And, but if there's any comments or other Any questions, comments first? Let's let's You're on. You're on shift. Two comments or two questions."
  },
  {
    "startTime": "00:16:03",
    "text": "Can you explain what down scoping is and how you are save it when you don't allow furnace to tokens. Sure. So so in this particular context, think about a mobile client that's doing, that's that you know, when I went and did my sort of established for a mobile client, and I went through my OAuth flow or open ID connect flow, I basically said, this client, you know, I give a consent to this client to you know, do both read and write financial transactions. Generally, they're very coarse grained Right? Now when that mobile app goes and says, I want to you know, transfer this much money from this account to this account, right, the downscoping is basically saying when the transaction token is issued, the only thing that you know, the back end system can do is transfer this amount of money from these let's get to the top of the transaction, not attenuation later on. Right. Okay. Got it. And well, I guess the comment part of my day job is to chase PII across our environment And when I see the IP address embedded in your transaction token, I cringe Sure. The at the very least, there should be a a consideration about that. Or Yep. Well, personally, I would just remove as an example. Well, I mean, I think that, you know, the interesting thing is There are There may be, There's a couple of things. Right? So I understand the privacy stuff, and I completely agree we should have a consideration section and talk about, you know, the amount of context data that you put in, right, and and how you how you potentially could blind that some of that data, but from a anomaly detection from a security perspective having that information that can be correlated to the transaction ID as it flows"
  },
  {
    "startTime": "00:18:03",
    "text": "the system can also be really useful. So it's that kind of balance between the the privacy consideration side and the and security benefits, but Yes. Maybe useful, but the certainly makes it more difficult to chase stuff that's now embedded in tokens and people will never ever change. Right. Right. So what would you consider about guidance that basically says if you want to track information that might be of you know, personal information nature that it becomes hashed as a value you know, when the transaction token is issued, it, you know, creates a hashed value of it That's certainly better. Okay. Thank you Justin. Sorry. Just just one you're on Hey. Go back to the mic. Sorry. And like, do you support that? Like, what what do you think about the document and the SIP than than the idea, like, is that something that you think it's you should be working on, something that you you support. I I honestly haven't thought about it enough. Pickets. It goes into, workload, the So the whole workload area. So, obviously, I'm interested. But whether it's in general like, very useful. I cannot say. Okay. Later. Basically, guidance in the spec to hash or obfuscate any data that might be considered PR. Justin. Hi, Justin. Richard. So I do think this is a good and important work. I also think that it's got, two aspects that I think are going to be tricky to, help people navigate"
  },
  {
    "startTime": "00:20:02",
    "text": "where and how to use this. One is that it looks and feels like an access token and people will be tempted to just treat it like an access token, which you exactly address with, do we just put this in the authorization header or not? I lean towards No. I for that reason, but also in addition to that, Jot as a format for carrying this is almost ancillary to the purpose of, the token itself. You know, this is really talking about the semantics of the payload and which makes me think of things like, SD job would potentially be a, a a container for something like this to allow for, different bundles to be passed through the system, for example, so that they could be masked to different parts of the workload and whatnot. And I know it's definitely harder to abstract to, away from like, the simplicity of it it's a jot, treat it like a jot is is wonderful. But I think there might be something more there I don't know exactly what that is, but this to me feels like something that's not quite an access token that we definitely want to be able to carry through requests in, in a bunch of different ways, though. So I support the work not sure a fo off is the right place for it for all of those reasons because it's not To me, it doesn't really feel like an access token y kind of thing, but I also don't think that there is a better place in the IT yet for Does it have to be an access token to be able to adopt it here? Is that like like, It's a token. That you could use with there's a lot of things that I could call a token. That we shouldn't be working on here. Okay. Justin, would you mind, adding an issue about the, you know, potential leverage of SDJOT and some thoughts around that? Yeah. Sure. I can I can I can do that?"
  },
  {
    "startTime": "00:22:01",
    "text": "K. It thanks, Justin. And cedic, Yes. Thanks. So I have also a question on the proposed after transaction tokens. In Portugal, describe it as something that is used as the transaction is live. To help it complete, but, it, it also provides a strong evidence, sign the lead on to do a detailing a long time at the transaction competency and, which is interesting, but also, of the pandemic for privacy. Right? I wanted to know if it's a legit made purpose of the transaction token or if just to the account that is considered while your transaction is live. And then should be discounted. So I guess, one of the drivers for me was the sort of twofold. 1, Right? Most systems being just server to server trust. Right, that if you if you compromise an intermediate server, Right? Then you can basically change the parameters of the quote, unquote transaction and make it do something else. Right? And so being able to create an immutable thing that starts at the beginning and allows those critical elements to not be changed is a big piece. The other piece is that oftentimes depending on what kind of a token was being used internally it required going back to the IDP to basically validate it, which has significant performance implications. So, basically, making these short live, so you don't have to worry about revocation. And, and allowing them to flow through the system, right, give your performance benefit. And then 3rd, what I found in an don't know about the rest of your systems, but I'd be curious to know is that and and it's it's unusual for there to be known having through the systems. When this transaction is occurring, it runs through these microservices and knowing that"
  },
  {
    "startTime": "00:24:02",
    "text": "would be huge. Right? So having something that is immutable that carries the identifier of the transaction all the way through. It gives you those benefits. So those are sort of 3 of the key drivers. There's some others, but those are 3 of the key drivers for me personally, and, you know, embarking on this work. Thank you. Yep. Mike Jones. George, you know me. You know that I often look to see our things consistent. So, I looked at how your spec is using the TXN claim that's defined by SEC events. And was kind of surprised that the only place that occurs is in an example. That's a bug. Okay. So that's another And and I haven't reviewed the back in detail. I thought I'll look at that details. As we speak. No. That's great. Thank you, Mike. Okay. Thanks, Mike. Yeah. We we talked about it on the call. Yeah. Ned. Hi. Ned Smith. So there was a whimsy Baugh earlier this week where the main focus was on workflow you know, attestation and auditing and a bunch of other things. It seems like that overlaps with with steps 4 through 6. So potentially assuming that Buff. You know, matures into a working group that might be a reasonable place for this work. It it might be. I think you know, the the thing we're sort of dealing with there is just, you know, timing issues? And is that buff gonna get spun up? And know? So that's why we started here, right, because it's related to you know, internal authorization in some way, even if it isn't a full authorization token. So may maybe there's like a charter discussion Yeah. You know, at some point in time, So the there is a charter discussion that will happen. Like, we kind of had some some"
  },
  {
    "startTime": "00:26:00",
    "text": "initial thought about, like, what needs to be done for the charter, but don't have something specific yet. So thanks, Ned. A No. Yeah, just very quickly, I think one of the other reasons this work Peter. particularly interesting, to me is it also gets us out of actually passing access tokens throughout the system. This is a very common pattern, that gets used in architectures, but it's not standardized. And one of the the reasons that is a problem is as we start connecting multiple systems across multiple clouds, the absence of a standard wave for doing this, it's gonna come back to bite us. And so I I think you know, those are 2 just very pragmatic things. 1, it it's a security improvement and 2, it's gonna give us interoperability and aligned with that long term vision that we have. Okay. Yeah, I was was saying, do we could we get to recruit? Perfect. Brief at the nitrous talked a few minutes ago. But we thought we would still do an, a call for adoption, and then we can depending on how the charter discussions work out may need to shuffle things around, but I think that's okay. It's not a big drama. It would be get some work done and and then we see what ends up. Yeah. Uh-uh yeah. So we did get some conflicting kind of views here. So that's the reason that maybe let let's try to get a feeling of, like, yeah, I just wanna get a feeling of what's the room in general. And then after that, we make a decision. Okay? So and Okay. Yeah. Let me unlock that that cure for Brian. Glad Brian. I'm sorry. It's hard to know when or what to say. The I've I've not reviewed it in detail, but I have"
  },
  {
    "startTime": "00:28:00",
    "text": "came through it. And I I'm of the mind that it's it's not ready yet. There's some maturity issues here. Some of the main A lot stuff that it does in the use of token exchange is just syntactically not it's it's erroneous. So it's not right. There's some other problems that claims are as Mike said, at least in some cases, they're not defined only used some examples essentially, I know there's something here, but I I'm built this document is is ready to roll or be considered for for adoption at this Brian, a question. Like, when you say it's not ready yet, ready for, as a starting point for the work in the group or ready for working group last call. Definitely I hope you meant the former like. Right? Well, we're we're not talking about working group last call. Are we, like, No. No. I was choking a little bit, like, my expectation is always like, for an initial document, like, with many others we had in a group. He's like, is this, like, conceptually something that Like, there's a problem out of, we just have heard, various speakers in church, in particular, talking about in is that something, a problem space that you guys see as well is that sort of, like, a rough, first start. And then, like, we always sort of change everything afterwards. Anyway, as it gets adopted. We've had this presentation a few times on the on this document already. So like, that's the type of feedback I'm I'm trying to get I know different groups have different, a different bar for what they consider as a starting point, But that's that's my starting point, assumption."
  },
  {
    "startTime": "00:30:00",
    "text": "So may maybe we can split it into two steps like if we can ask if people are interested in solving the problem. And and after that, we'll ask about if this document is a good starting point. K. Said that fair? That's fair. K. Yeah. That's that's what I'm can I use can? Get ready to use the tool. That was that said, 2 100 what is the first part It's just the okay, sir. It's It's not interested. Yes. I've so the problem. A problem. Let's get Okay. Can you please vote. Is the work group interested in solving this problem? For, like, it doesn't have to be that the doc this document, but the the problem is space. Right? I give you a few more seconds? K. Can K? To, capture this. So we have 24. Yes. For no. 21 no opinion. 7,"
  },
  {
    "startTime": "00:32:04",
    "text": "Okay. So let's ask the second question. Second question. It's awkward vegetable. Should come up. The 2. We as now. 2. Popped. Yeah. I'm sure. I always had that stop. Point No. The point is gone. Oh, that's good. Yeah. It's it's on, like, the the whole thing. Should we adopt that transaction. Hopefully, there is a this typo just as a starting point, please put Ken. Few more seconds. K. Okay. That's it. Okay. So 15. Yes. For no and no opinion. Okay. Okay. So You good, guys? You're fighting there? Yeah. Okay. Awesome. George, thank you very much. We will take it to the list, obviously. Right. Yeah. We need to confirm it on that. Yeah. Yeah. But this is it's always, the list is is the final one. K? Thank you, George. K."
  },
  {
    "startTime": "00:34:09",
    "text": "Okay. Of course. Of course. Course. Course. It's a chestess. Why do you opening his slides. I was in a different group, this week. I won't say which one. And, there were three people interested in a in a document, and they said it's, a tremendous interest, so that the bar for what is interest and what not is very different in different groups. It's really interesting to observe that. Did you get it? Yeah, I have control. Okay. Okay. Hi, everybody. Pedro Castleman. I am going to talk a little bit about identity training trust trust domains, a little bit related to what George has been talking about because it's also about preserving, context, as transactions move across cross boundaries. So, I wanna really thank Mike, my co authors and contributors aren't. Kelly, I think you're here, Mike, and Brian, has joined, our crew of, our merry band of, identity training enthusiasts, And, that means we also get much higher quality pictures to start our presentation with. So thanks, Brian. Okay. So I'm going to talk a little bit about the challenge of identity training just as reminder, sort of our proposed approach. I'll talk a little bit about what's in the draw and then maybe get a feeling for folks in this room or in the meeting on where we should go with this work next. So I think first off, so Starting out, right, I this picture, I think you might have seen this before. So typically when, you look at"
  },
  {
    "startTime": "00:36:02",
    "text": "a, what we call a resource server. It's really sort of ends up being constituted out of multiple, services There's typically some kind of gateway. And, and then several services down. In this case, the bar service still needs to know who was the original resource owner, what authorizations did they grant, what other entities were involved and what authorizations that they have. And some of this, so in the previous, discussion, the transaction tokens that George talked about sort of helps us answer those questions within a trust domain. However, when we start moving across trust domains, we still want to be able to, have answers for the same things. Right? So If you're in trust domain 1 and you're calling into trust domain 2, you're gonna call another resource server, which is constituted of yet again a number of subservices or microservice is and again, right, by the time that the request comes down to the very lost service, you still want to know was the resource owner, What was the authorizations that granted who else was involved, and what authorization do they actually have? And so, of course, we want to be able to do this in a an environment where people are using OAuth, already. So, so here's some conceptually how we're thinking about solving this problem. And I I, again, also wanna thank Brian for helping us out with some of the details as we've been digging into, the Spark. But, essentially, we're we're really proposing using 2 existing specification that this working group's already produced. 1 is token exchange and the other is the assertent framework. So how we would like to propose and standardize, this approach for, cross demand identity training"
  },
  {
    "startTime": "00:38:03",
    "text": "is, you know, you start off with a, a client in the first domain, they they use token exchange, to get an auth authorization grant, and then they use that authorization grant and they present that to the authorization server and trust them in 2. To get an access for that. And then from thereon, you know, it's just, that client then can present the access token. So that's kind of the the very high level. And sort of looks like this if we were to draw a picture, it'll see the client sort of floating, not attached to a resource server or the authorized server. I'll talk a little bit more about that, in the next slide. But this is really sort of the flow. Right? Dude token exchange, use the surgeon framework and then present the token. So when as we've talked about that, in the conversation, that sort of really turned out to be two models in which we want to use this pattern. The first one is for one of those microservices themselves, one of the this case, the food service to actually act as a client itself. And so take whatever token it has exchange it, get that assertion grant go to the other authorization server then present it, to the gateway and the next service. And so, and that is sort of one model. And then this model, of course, from a security perspective or okay with a a client in trust main 1. No doing about the authorization servers and trust them into There's also sort of a I'm gonna we're I think we call it high assurance there's high assurance use case. Where the client's actually the authorization server itself. And so, in that case, we didn't want server and domain 1 to know about the authorization server So we didn't want the"
  },
  {
    "startTime": "00:40:04",
    "text": "client in domain 1 to know about the authorization server in domain 2. And so in that case, it is still the same flow. But, the, but in the end, it's really the authorization server acting as the as the client. K. So a little bit about what's in the draft QR code for anybody. Anybody QR code? So first of all, we sort of look at the to the deal if we ask them to scan them previously as long That's good. That is right. You're helping me, hunters. Thank you. So, so first, we describe the sort of generic cross domain identity training and, how that should be used. And then in the appendices, we talk specifically about how this looks if the resource server the client as well as when the authorization server access as the client for this, identity training example. We sort of have a At the one of the open discussion points actually for us is the token type. So you know, one proposal is maybe we should restrict that to be joint tokens only. I think and in some cases, we we're sort of balancing there between more interoperability and more flexibility and I think that's still sort of an open question for us to to figure out which way we we should go. And there's also an insertion flow profile And then I think, is sort of, a section on how claims transcription or or what claim should be the transcript it and some some guidance on that."
  },
  {
    "startTime": "00:42:05",
    "text": "And then I think the other piece, so we did present this at IITF117 there's sort of several, changes that was made. And, again, any thanks to Brian for helping us, come up with both fixing things that were wrong as well as refining and getting a little sharper on the text itself. The next steps are remaining open questions. So that's really sort of 2, 2 things. Right? So one is considering the limitation of the token formats, and then just how specific we need to be in terms of should we define specifically how, claim should be transcribed as well. Or specific, formats for how this transcribe time should be described. So I think next steps, one of the questions at this point, we've been So this this work here, was initiated. I think Kelly, you first presented at IATF 114 in Philadelphia. And we've sort of been evolving and debating and and sort of teasing out what this might look like. And so at this point, I think we really want to sort of get a sense of whether there is interest to pursue this work and whether this is something that you know, strength to figure out if there's something that that we we should if there's interest in the working group for this to continue. Okay. First, any anybody has any comments, what about the presentation? What we what you saw here. Questions, comments, and and people. Can you please mute your phone? So we don't have to hear this. You get distracted. John. Heard me."
  },
  {
    "startTime": "00:44:02",
    "text": "For the record, Christina is trolling John. Nothing. Christina captured that, please. Okay. Mike, Mark. So, Mike Jones, I'll admit I haven't read the draft, what do you mean by transcribing claims if you think it's useful to say? So I think the thing that, it is how do we if you, you know, let's say you have an access token, should we define the mechanism for how those claims are preserved when you do, when you when you sort of apply for or, get that assertion wrong, right, should that be contained and and should that be, still be available? And and how to do that. I don't know, Kelly, if you wanna add to that in terms of the the claim things. Is it like encapsulating or transcribing and preserving yeah, think of it as encapsulating. Okay. Right. So basically asking think the thing that we wanted to avoid was and putting the, an access token inside like, that kind of problem. So it's really about let's pull out the pieces that is really relevant. And that we really want to preserve and, give people a way to move that across the trust domain Thank you. Thanks, Mike. George. Yeah. So it a little bit, Mike, to what you're saying. I think there's some really interesting problems that are worth solving here. Especially when you start thinking about use cases with that involve users because the claims about a user in one domain may be quite different than means about the user and another domain and how do you sort of indent try the user correctly and what does the authorization server trust domain 1, not want to release about the user, but still be able to get"
  },
  {
    "startTime": "00:46:04",
    "text": "token from authorization server 2 in any of these scenarios. So I think that that also sort of comes into this aspect of encapsulating, you know, how do I how do I represent than right necessary information to the other authorization server get the the access token that I need to invoke the API without potentially leaking too much. So I think there's a lot of really interesting stuff here. Okay. So Seems, obviously, there is some interest, but Like, let let me let us just try to since and get the feeling from the room. If they're interested in this. So We're gonna I don't know, maybe split it again or should they just Yeah. Okay. Let's do that. Is work. Is a work group interested in solving this problem. Nuxkett. Awesome. Oh, still going up. K. 24. Yes. And 0. No. Awesome. That's what? Okay."
  },
  {
    "startTime": "00:48:06",
    "text": "Platmas, this So we adopt Talk. Let's see if I got it right. Should we adopt this document as a starting point. Again, we're talking about George's document here. Peter. Sorry. Yeah. We're working on a different thing. Alright. Sorry. No. I'll I'll take the result. Apologies. I'm sure you guys do the point twice you know, one after the other result with a different Okay. Let's good. Give me one second. Okay. Looks looks good. 17 years. 0. No. Perfect. We'll take it to the list to confirm it. Thank you. Bye bye. Thank you. Thank you all. Thank you. Black. Okay. Thanks, Peter. Okay. Let's see. Net. Right? What is that? The station. You want me to drive, or do you wanna drive? You can drive. Okay. Troussome. Oh, Close that? Sorry. K. K. Go for it. Okay. I am Ned Smith, and I'm here to talk about attestation for the registration endpoint. Next slide."
  },
  {
    "startTime": "00:50:04",
    "text": "So motivating use case, we're talking about client a way for the a client that's implemented as a confidential computing environment. And, the idea here is the client runs within this confidential computing environment and we want to be able to a determine or find out whether or not the client actually is in a confidential computing environment using that gestation, And so the first step here is The client is configured with credentials and other metadata. And as part of that interaction, work, the the client attests. So we'll go to the next slide. Alright. So at a station in dynamic client registration, Basically, the attestation can be used with, you know, different endpoints in OAuth. This just, a draft support status station within the endpoint. So we think it's complimentary with the the attestation based client off draft in in the sense that it supports attestation for client authentication and, and where the, whereas this is focusing on the client registration step it's based on rats architecture in terms of terminology and concepts, if you're familiar with that document, this will maybe resonate with you. What the basic idea here is that that, it describes the communication patterns for background check and passport models. So so that's something that's described in their apps architecture. The current draft has an explanation of the background check model and we're in the process of, adding an explanation that in the context of the passport model. So next slide. So here's basically how it looks. The you know, the purple bullets are essentially what this draft is focusing on. Which is the, you know, the registration step, but as a pre step to the registration, the client authenticates"
  },
  {
    "startTime": "00:52:00",
    "text": "and, attests to a rat's referred to it's referred to as the rats verifier. And that This is this is the process of obtaining the passport, quote, unquote, And the passport essentially is an attestation result that says Hey, this client is inside of a confidence for computing environment. That's then delivered to the AS and the AS then. Proceeds as normal to do the dynamic client registration, which primarily involves, you know, provisioning the the the client you know, context. Information, And then it proceeds as as normal from, steps 3 and 4. Where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, where you, obtain a token, obtain an access token, and then present, yeah, has took into the resource server. Next slide. So what's going on in each of these steps? So In first step, the verifier checks that the client is a valid confidential cutic computing environment. That's based on could be based on lots of detailed information. That's that can be obtained through attestation. And there's a variety of different formats for doing that. And, and then as a condition of the AS granting the access token, it essentially applies a policy that says if the if the, client is a is a within a valid CCE, then provision the DCR information. Into So this is, based on essentially the configuration of the AS As a result of that, all the downstream resource servers essentially have a policy that says gonna use this particular AS because I know that he's performing this check. Right? So, that's sort of how the entire system benefits from the knowledge that the client is in a confidential compute environment."
  },
  {
    "startTime": "00:54:01",
    "text": "Next slide. So think the standardization effort is pretty minimalistic. Mostly architectural. There's a prototype development work that's going on now. And we intend to get feedback and then, of course, any inter anybody else who's interested in working on this, we certainly like to, you know, find out who you are. And otherwise, should we adopt this? Yeah. Yeah. Yeah. K. Yeah, anybody has any comments first. K. So it seems to me that when I look at the diagram that you have, and the diagram that was in the client attestation spec that we did Tuesday, I guess it was, or was it Thursday and Wednesday? Anyway, the core bits between client and some attester are exactly the same. Right? And I think there's a huge amount of value in being able to get an out of state about the client, Right? And that attestation potentially should be more than just you know, OS based app auth, right, or or or, I mean, the OS based app at the station. Or maybe that's sufficient depending on the use case. Right? I think then there's the the separation of that mechanism from how can you present a client at station, to multiple endpoints within the OAuth ecosystem And I'm wondering if we can separate these two things. I can't remember who said it when we were talking about the last time but but but, maybe it was you, Aaron, who said that, you know, there's value in separating attestation from authentication, and we should be able to do both on many of our OAuth endpoints. And I so"
  },
  {
    "startTime": "00:56:00",
    "text": "I'm wondering, is it possible to combine these two things into a speck around you know, how do you get an attestation and there may be multiple kinds of attestations that could be retrieved. And then how do you present an attestation across a wider range of oath endpoints? So One of the things that we found beneficial in the rats working group is to sort of separate the idea of a a role from an entity which is to say, you know, the the role just identifies some behavior that that, that, you know, perform some particular you know, do set of duties or tasks, that role could be could land on any any combination of entities where a single entity can perform multiple roles. So an AS as an entity could easily be a rat's verifier or the rat's verifier could stand alone on a different entity. And just intended to have lots of flexibility Right? It's in that way. Right. And I think that's fine. I mean, just for me, conceptually Right? There's a client attestation step right, or or producing evidence about this client. Right? And then there's a way to present that evidence Right? And I think if we separate those 2 things and make them you make the the presenting of the evidence generic or have a standard way to do it that works across multiple endpoints. Right? That would actually gain us a lot of value. Actually, and post documents to that, post documents for everybody that separation, Right. So then which is good stuff. In other words, are they really solving different problems? Or can we con can we have a a single document that talks about you know, kind attestation evidence and presentation. So so I think they're solving different problems, but those problems could be combined to sort of one step. If you wanted to."
  },
  {
    "startTime": "00:58:02",
    "text": "Yeah. I think George pretty much said everything I was gonna say, but I just wanna reiterate it. I think that, I'm extremely opposed to the idea of having 2 drafts that do very similar things in different, but different ways with different terminology, especially. Is a lot of terminology that's completely different between the two drafts, which I see as a huge problem since they are are eventually very similar. So that's something to address probably in both documents. I do, again, I just wanna say that the Avestation output of whatever that is is useful at many different endpoints. In the OAuth ecosystem. There is no reason that it needs to be presented differently and have a draft per endpoint that's just not scalable. So, like, the the really think we should try to combine these 2 unify the language, unify the the presentation of it and all that and be able to then by definition, apply it to other endpoints within the OAuth ecosystem without having to create a new draft. To to say how to do that. I'm happy to work with you know, authors of the other draft on terminology That helps. Awesome. Perfect. Perfect. Thanks, Aaron. Paul. Yeah. I'm probably mostly iterating what George and Aaron now said. Again, I thing also, the similarities are very obvious, And if we take the feedback that we got on Wednesday, which was mostly what Aaron said, this should not only be maybe a client authentication scheme, but more like general and apply that to our center, then I think we pretty much arrive at that point, And, yeah, also to the point that what's called here, the rats very far. Doesn't need to be the same entity as the client is also a discussion, that we have in, in our spec, which is also what we originally started with the ideas that I had. Tubai's was a little bit"
  },
  {
    "startTime": "01:00:03",
    "text": "skeptical about it. So we sat in the end in the beginning. That should be the client back end, But in the discussions that we had in GitHub, we already loosing that up and we were ready in the process to call that, like, a general the station service, Does need to be in general, the, the client back end so Yeah. I think I think it would be better, like, just to merged the efforts and and do that. Together together together So, yeah, it's also an invitation. Okay? Awesome. Thanks Paul. John. So probably not surprisingly, I'm going to agree with all that has been said before me that, essentially If there's something that's specific about the the CCE environment, that should be a profile on top of whatever the general purpose. Attestation dynamic client registration just in time dynamic client registration, whatever we're calling the the authentication option, you know, registered to ring authentication, but is the CCE environment is probably going to need to eventually do all those other things anyways. So we should figure out we should figure out what the generic model is and perhaps do a CCE profile if there is in fact something specific So I invite you to look at the rats working group document list. There are, I think 3 profiles that are Publish there. To get just to give an example of what a profile might look like That said, if there's a sort of industry standard profile, for CCE, that would be interesting work. Again, I I think it's you have it the the wrong way around. This is a CCE profile of this access station mechanism that can be applied to different endpoints in OA."
  },
  {
    "startTime": "01:02:04",
    "text": "May maybe maybe that's just two ways to looking at the same thing. But, yeah, agree. But I I agree I agree that, yeah, there's probably interesting work around defining a profile, that applies to you know, the OS community, and the CCE community and they they shouldn't be different. Right. So my speculation is that CCE may just be a specialization. Of what needs to happen in OAuth in general. Yeah. And we should understand it and, you know, merge these 2 and divide it up as appropriate. Awesome. Thanks, John. Jacob? Yeah. Hi, Jacobir. It's Cook. Yeah, wanna reiterate what George and Aaron said as well. I I think this is a strong argument for not using at the station as, client authentication the only mechanism, because that would that would prevent this or make it hard use in this case. And and I think this is a very valid use case to address dynamic client registration. There are many good good cases where that could be useful to have at the station for. Software statement could perhaps be used there, but then again, a more general base and then profiles on top would be preferable. I think but it also makes sense to perhaps look even deeper at the claim definition of what that at the station token this and how to profile that on various ends. Okay. Thanks, Jacob. Joseph. Thanks. Joseph Keenan. I just feeling slightly uncomfortable with people putting the the the Paul's draft that targets endpoints that accept client authentication, in with the DCR cost. Sorry. So I'm just feeling comfortable that Paul's draft that really targets endpoints that accept client authentication trying to put those into the same bucket as that I am at client registration that has a different format request. It's we should have the same"
  },
  {
    "startTime": "01:04:00",
    "text": "got type of evidence presented, but it shouldn't try and force them to present it in exactly the same way. K. So just to jump, can I jump in here? No. Uh-uh. Hold on. Oh, hold on, guys. Just just one one second. Could I respond? Yeah. K. Go ahead. Yeah. So I think maybe two steps here. One is let's figure out the terminology. That we're sort of speaking the same language, And then we can take a look at, well, what are the goals of each? And are they different enough to keep them separate? Or are they similar enough to keep them the same? If we're saying put them together because the terminology is screwed up, and we want to get the terminology straightened out. That's probably best reason. Yeah. I mean, I've I think having consistent terminology is good. I think it's just when we get down to the detail of exactly how you present it. Yeah. But we shouldn't force the same mechanism for both. K. Okay. Hannes. Yeah. Chair head off. Terminology thing, like, there's s s some terminology being worked on in the in the idea of rats working group, and, the group needs to decide which terminology to use, I have a slight preference. I'm not an awesome of the rat seminar sheet nor did I invent it. So that would be important for the group to find out because it's obviously quite confusing it's unfortunate that some of the terms overlap. So that's why there's rats verifier because some of that documents, the VC documents, for them to verify is what the resource server here kind of confusing, of course. The other thing is this is one model that mimics closer to what all has been talking about, earlier this week. But there is also the other communication pattern that is seeing in existence and deployed today that we would have to also support, which I talked about last time, and that's why"
  },
  {
    "startTime": "01:06:01",
    "text": "net obviously doesn't repeat that again. So I think there's there's good stuff there. Okay. Thanks, Annes. Aaron, quickly. I closed the queue in the queue. I just wanted to say the dynamic client registration spec, explicitly says this endpoint can require client authentication. So the way I was seeing it was that this add a station is an input into the dynamic client registration endpoint. And if you want to call it client authentication, then you could actually just use this other draft that already calls the client authentication, on the registration endpoint. We don't need to write anything new. So that's why I was saying that, like, these are extremely related because it's all already it's all already there. Like, I'll But that said, so I don't wanna call client at a station client authentication. Because they are still different things. And they're just useful at all the endpoints. Okay. So so just just let me clarify quickly. So in the context of an attestation, the thing that work that's labeled client has an attestation identity that it can be used to authenticate to the ret's verifier but that may be different from the client identity that's used within the rest of the a system to identify the the client as participants in that system. Which is exactly why it's not client authentication. Okay. Enough. Enough. Brian, quick quick comment from you. And then we end it here. The that the other draft though that's doing attestation for client authentication is really just attesting to a key for, an individual client instance. So that can be used for authentication Kitchen. A a I understand, like, all the desire to kinda unify things and have things as one, but it it it is not I'm I'm not sure the parallels are actually as significant as"
  },
  {
    "startTime": "01:08:00",
    "text": "s our opinion. Put forward and there's like it it's being used in a very specific way to sort of elevate what we're previously public clients, something that can act as a confidential client So I I get I get some of the concerns around it, but we're gonna I'm worried about losing the the actual intent and and functional and functional value of that other draft if we try to merge things in and make them completely generic but Okay. F, Thank you, Brian. Sorry. I closed the mic. I Justin, go ahead. Quickly, please. Aaron is right. The other draft is wrong. Client attestation should be usable at, everywhere in parallel client authentication, we shouldn't conflate the 2. Thank you, Justin, quickly and to the point. Okay. But I think the next step is for the two groups to sit together and talk about those and see if that makes sense to merge them. And then let's talk about this after that. After you you guys get together and talk about it. Okay? Thank you guys. Appreciate it. N. Let me hand you the that I can see here. There you go. And you have 2 presentations, and you have plenty of time. Right? I I doubt it. I'm gonna try to stay on time for my own sake for the next presentation. So, okay. It's your presentation. Okay. Hi. I'm Aaron Paraki. Okta. First wanna talk about OAuth for 1st party apps, which was a draft that, presented here before along with, George and Peter. We have, presented this sort of problem space in the past. I'd wanna do a quick recap recap of that before talking about the changes, just to kind of set the stage. So in"
  },
  {
    "startTime": "01:10:02",
    "text": "awatt for mobile apps today, especially when, they are using 3rd party identity providers as most social login kind of things do. We have this kind of experience choosing how you wanna log in. And then we see the mobile app platforms, a lot APIs take over the web flow, on iOS starting with this little pop up and then going into the safe browser for doing the authentication. At the OAuth server. Bunch of proprietary logic happens here that is not specified anywhere because it's proprietary logic by definition. And we do multi factor auth and etcetera, etcetera. And eventually, the app is log Great. This is excellent for the case where we're using OAuth for 3rd party applications because of all the protections that the mobile platforms give us. Isolation between the app and the browser existing ability to to keep the session cookies for the IDP. Great. All all these kinds of things are great. However, in the first party case of building 1st party developers want a better user experience for those applications. And it is extremely driven by user experience. So people are finding ways to work around the recommendations laid out in 8252, which is the recommendations for mobile apps to talk about things like using that browser. They are doing DIY things for just building proprietary authentication APIs that mobile apps will use directly. They are just using the password grant, and then they don't have any with that with that do better with that in the OAuth world. OAuth servers create prietary APIs, to facilitate that kind of direct interaction. And I'd even see things like the mobile app opening up a hidden web view that it's able to then observe and scrape and inject passwords and stuff. And it's just lovely. The point is that all of these things are worse than not having clear recommendations for how to"
  },
  {
    "startTime": "01:12:00",
    "text": "let developers get a good user experience for 1st party applications. So, With that, out of the way. Let's go over to the world of OAuth that we have today of doing the the authorization code flow redirect based, author authorization code flow. It starts on the left with the OAuth client saying go over to the authorization server and start the flow, that contains a bunch of information, about about that request. And then OAuth says eventually the user's browser is redirected back to the client with an authorization code and state and other parameters, which again then exchange for a token. You might notice there's a giant hole in the middle of this diagram because a whole bunch of stuff happened in between the start and the end of that authorization code request and authorization code being issued. None of that stuff is defined in specifications, by design. That is all interactions between the user's browser and the authorization server where they have the account and might include things like registering for an account. How they actually authenticate any kind of multifactor off, any kind of consent gathering, other things other magic happens, it's a lot of stuff happens there. And this is I would say actually a success in the design of OAuth because that part of the system has been allowed to evolve independently of the OAuth client. So if we take this to the mobile world, and we try to provide a way to let apps give provide a a native user experience, what we could do is define an auth, a similar authorization code flow, but now it's in quotes, for for first body applications where part of the flow that's defined is just the outside start and end of the flow. But leave the inside bit still out of scope and not even try to get into how the actual back and forth happens leaving that to be proprietary as it is in the authorization code flow for the web."
  },
  {
    "startTime": "01:14:01",
    "text": "So with that, it was a quick version. Couple of the goals of the design of this document. Use existing auth billing blocks as much as possible. Mirror the web version of the authorization code flow. Which means defining how the client starts and ends the flow, but leave the specifics of authentication out of the framework as it should be. That means that the specifics of authentication can be either proprietary to proprietary to an authorization server like they are today. Or we could define extensions for them, especially if those extensions are built on open standards like Fido Web authent, which is really interesting idea that I think a lot of people would. What years? So that takes me to the design of this draft. Which basically adds a new endpoint, the authorization challenge endpoint, This is new endpoint that accepts all the parameters that would have been included in the query string or in a par request, to the authorization endpoint. It can include up any extensions that are defined on top of an auth but it is the endpoint that accepts the post request from the client to start and possibly then continue. This this this back and forth sequence until eventually an authorization code is returned from this endpoint. So we just define this endpoint, which says here it's how you start the flow and eventually you get back an authorization code. Which means importantly, At the token endpoint, there are no changes made to the token endpoint by this draft. Token endpoint, accepts, authorization code, that it got Instead of from a redirect, it got the authorization code from this post request. So I'm sure everybody's thinking why new endpoint? The existing authorization endpoint as defined in OAuth is never interacted with by the OAuth client. Is only interacted with by the browser It is explicitly a request from the user agent, which means it returns HTML. I have received a lot of feedback that suggests that people are unwilling to modify that endpoint to also return, for example, Jason just doesn't really make any sense because there's a lot of things you do to protect the authorization endpoint"
  },
  {
    "startTime": "01:16:01",
    "text": "when you're expecting it to be interacted with by a browser. So that's the main justification for having this being a separate endpoint. Because we don't wanna overload the authorization endpoint. The other thing this draft does is define a couple of error responses. So any We're not changing the token endpoint, but at any point, the token endpoint could return an error code like it can today. That error code, there's a new error code to find that word Sorry. There is no new error code to find. The new the error code Can already say that the user needs to go log in again. Which means the the we already have the path to just kinda have the app start over from scratch and, Do a flow. Do the flow again. The resource server can also include this error to say, hey. The user needs to go log in again, and it can use a step up authentication draft to do the resource server can say, hey, this access token is too old or the user needs to log in again. For whatever reason, those are already finding step up auth We don't need to change any of that. The client now just would start a flow from scratch, scratch, scratch, this new way instead of through a redirect. So, since last time we talked, we've gone through a bunch of changes on this again. Try to refine this and and make it more consistent. There was the poorly named device session that is now called auth session. It was not meant to imply that it was a persistent identifier for the device. It's really meant to identify the particular transaction of obtaining the authorization code. So, That's hopefully a better name. We can still bike shed it later. The other, big thing is that we added a explicit error code that is a redirect response. And this is kind of the, like, In some cases, authorization server actually still doesn't want to accept this kind of direct back and forth and actually wanna get the user out into a browser for whatever reason. That could be because It doesn't it no longer trusts the application because maybe they"
  },
  {
    "startTime": "01:18:00",
    "text": "attestation, changed and failed, or maybe because the, the client doesn't have the code required to do this kind of new MFA type that they shipped in the authorization server, but haven't updated the SDK with yet. So in these kinds of exception cases, the authorization server could just say I'm not gonna, you know, stop interacting with the user, open a browser, and just do a normal OAuth flow there. There's a new section that talks about about these design goals that went into this. We also had a discussion about how you can layer depop in with this specification to have have Keybound tokens. And interestingly, we removed the term native from the name of the spec. And the reason is because I went through and read what we had written and actually nothing about it was specific to native apps. Now I'm now I'm on defense about this. But it felt like a, okay change because there wasn't actually like nothing about what we're we were doing actually was tied to mobile or even native applications. However, that is the intended use of it. This is why I could go back and forth on this. It is clearly intended for native apps be that mobile or desktop? It's not really intended for single page apps, although you could technically do it. You could technically do it in a web server based app too, but doesn't really make any sense to because you're already in a browser and redirects aren't even a problem there. So Yeah. Yeah. We can discuss that. Kind of more important discussions are, There's a lot of interest in easing Fido as an OAuth grant using a paske web auth and whatever to exchange that foreign access token directly. And what that would do is let you get a extremely good user experience in the mobile app. Where no browser appears. You just do the the phone thing to do the pesky challenge and then exchange that in the back end for an access token."
  },
  {
    "startTime": "01:20:00",
    "text": "Ideally that we could do that using this as the framework to to build that that would require that the client has to get in that initial challenger that uses in that grant. Kinda like getting a depop non switch I is kind of a depop does it a weird way where it makes a request that a nose will fail, and then it uses that to get the nuns back. And, anyway, There's a lot. This actually seems to be a common theme in a lot of the new stuff we're doing is that clients need nonces and we have just kind of had to figure out how to shoe horn nonces into things So maybe there's a maybe there's something there but but Yeah. The the I guess the other question is is there any interest in actually working on, I specifically a profile of this framework where we do define and authentication mechanism, which is paskies or what about then. And I think That's it. So, metric. Dimitri. Dimitry Zagendolin. Like, In terms of getting the initial nonce, I'm wondering if Looking back up. So for Saip version 2. And for using open ID for credential issuance and open ID for presentation, implementers have this same problem. They need to get a nonce and, NAPI endpoint, which this does also to send that nuns to to kick off the the interaction. And currently This is being done by scanning a jock code. Right? So I wonder if the 2 workflows, could be"
  },
  {
    "startTime": "01:22:00",
    "text": "can either be informed by each other or reuse the same workflow because here again, imagine scanning it a QR code when onboarding onto your mobile app or secure desktop app. And So so what what you're provisioning is the endpoint of the authorization endpoint. The the URL's diarization endpoint and the deep up nonce. So that your your secure client can now kick off the client authentication. Ceremony. So that's it. Just reminder, verify the credential folks have that same problem as does sign up to. So at least should be informed by each other. Thanks. I think the I don't wanna get too deep into this nonce issue because I don't feel like that's the most important part to discuss right now, but I do think that that what you're describing of the enrolling VA QR code is kind of a separate issue. To this just because a lot of these are gonna be preconfigured with the authorization endpoint already. Kinda in the op but I could see that that you could have them both combined as that could be a way to enroll. Anyway, wanna get into that because I don't feel like that's a super relevant, point here to Okay. Jacob? Yeah. Good presentation. We I have a bunch of security concerns with the spec as it is today. We have a similar implementation of this and then and, the fact that the default posture of it is that the authentication flow, or the authorized sort of in between the authentication there is unauthenticated and not like strictly said this should probably be client authenticated at some point. Could lead to a lot of like, open implementations of this, especially now that you removed the sort of native word from the spec"
  },
  {
    "startTime": "01:24:01",
    "text": "because on the web, if you don't have the redirect URI, you don't have a provenance check, so a course course implementation of this with, you know, essentially a public client, you would have no idea to know where where that came from. In the end. So that that could lead into know, implementation that use defaults that are really, really insecure. For this, and the, the AS wouldn't have any control. So if you were to combine this, say, with at the station to begin with, you need a way to to sort of have that at the station flow through. And I guess you're thinking deep popped. I haven't read the updated where you add a deep up in there, but deep up obviously can be used throughout the authentication flow. But, Have you considered other authentication mechanisms if you authenticate in the beginning, you you essentially need a token to use throughout the flow. And then why not just simply say it it should be access token bound throughout. So you use some initial client to run the flow and then you could attest to get that token or you could strong or, or weak, but but there's a sort of security baseline that you add to it. So, okay, a couple of things in there. I agree that it would be a bad idea to build a trivial implementation of this that just opens up everything for everybody. That said, I am a big fan of the approach of layering specs on top of each other. Each one's solving problem using them all together. So I would fully expect that you absolutely could use whatever is this future client and the station mechanism. Along with this to protect this endpoint. I don't think we should require it because I think some people may actually be okay with the implications of not using attestation for it. Whatever reason, But that would be a good recommendation. The we can't really do a the the the point of logging into a mobile app is that that's usually"
  },
  {
    "startTime": "01:26:00",
    "text": "first time that you are interacting with the user, and you can't really pre enroll stuff, which is the whole point of mobile apps being public clients. So we can't really, like, do stuff with pre enrolling secrets and user or tokens in order to protect that endpoint, which is client at a station is useful in this context. So, yes, I agree that there's some concerns there. And I think I have documented them already in the document and the security considerations. I would like to add a mention of client and a station, but I don't really wanna point at a draft that is So influx are not really applicable at the moment, but I would expect to be able to do that with that draft that we have adopted Jacob, can I ask you to review the latest version if you have some concerns to to post those to the To the list, please? Yeah. Absolutely. Awesome. Thanks, Jacob. Paul, Great presentation. I think we have, like, similar setup for our high assurance use cases. But at the same time, I wondered, like, if they are, like, the same party with is there, like, a need to standardize these things So semia feels like a best best current practice more of. I think right. Now I can't remember if this is documented in the draft. I think it is. One of the reasons is that even though it's a 1st party scenario, the actual part maybe built by different people. So you may have a authorization server product that ships an SDK. That is then used by a client developer who has a strong relationship with that product And it is all considered 1st party, but they are actually separate pieces of software. So What we're seeing now is that as people are trying to do this, everybody's doing it differently in often bad ways. So I think I think it's a great idea. And, also a remark that we also intend to use the client attestation. I think kind of fits in this, in this native, scenario, and the thing with the nonsense as these things come up a lot of places"
  },
  {
    "startTime": "01:28:01",
    "text": "Giuseppe, from from Italy, proposed to have, like, something like a launch endpoint. And the more often this comes up, I think the more I think it we should evaluate this option So I just wanna put this in in the room because it seems that there's a lot of things coming up where we need nonsense. And maybe it's a good opportunity for another endpoint that, like, can dedicate to just do that. On a high scale also from, like, a scalability point of view. Feel like it's worth a discussion. Yeah. Okay. So, yeah, I'll I'll reach out to GSI and see if he who's interested in talking about this here. Thanks, Paul. I'm Justin. Hi, Justin Richard. 1, thanks for this. I think that this is, this is an interesting, gap And, That said, though, this would now be the 3rd time we have reinvented, intent illustration in, in OAuth 2, the first being, the device flow, the second being par, and now this they all do similar things, all return different things, and all expect different things to happen after that. So from that point, arguably, they you know, our different endpoints. But at 1 what point are we going to stop inventing new ways to throw a bunch of parameters at an authorization server order to get to the next step on top of that. A lot of these things end up with nonce or nonce like objects baked into them because they're part of an ongoing conversation. And, So, yeah, I think that this this might be a reasonable time to start asking Should we just abstract up from par. And figure out what this"
  },
  {
    "startTime": "01:30:00",
    "text": "type of intent registration generally looks like with this go do a proprietary whatever as as one of the outcomes of it. It's a pattern that works well in other protocols and other spaces. That I think could. It it I think it's time for us to start asking that question here. I I I do see what you're saying, and it, It's an is interesting idea, So maybe it is worth a thought exercise. Of of going through what that would look like for kinda upgrading the device flow and making that work like smash it all together and see what happens. Yeah. I mean, if we're gonna talk the nonsense that Paul was bringing up. I had to. I had to that, then, then we should at least talk about that. Yeah. K. Thank you. Yeah. Thanks, Justin. Chum, Sean, so I too wondered about the relationship with Parr and whether or not this should be layered in some respect. Yes. I'm not I I have mixed feelings about Giuseppe's idea. But we should probably talk about Think about it. My other observation is yes. We should have a more specific profile for pass keys flash web auth then, and perhaps it should be the only profile. Because if we're talking about mobile apps, There are no other than a small subset of phones in China that don't port port this. There's no particular reason why you would do almost anything else with the first party app. And you get the advantage of both identifying the user and the application. Because the webauth and assertion identifies that, yes, it is my app. Just as part of it. So there are some good reasons. We've thought about it in the past, but there hasn't been enough justification, but maybe we've reached critical mass and should We it should at least exist"
  },
  {
    "startTime": "01:32:00",
    "text": "and and maybe there's an argument for doing it other ways, but Maybe there aren't. Thanks, John. Hi. I'm also a big fan of having a lot of layers and then utilizing them to do something great. Close it to the mic. Okay. Sorry. Eat the whole thing. Yeah. Yeah. Shallan, Alright. So Jacob mentioned that they, have a maybe I misunderstood, but, like, they have a proprietary implementation and they use an access token, that they obtain through other means to talk to an endpoint like this then we talked in this era of client that station about yet another application of client at this end point as a means for your client authentication than DCR. And then we we seem to have mentioned protecting this endpoint, both with RFC 6750 derivatives, like, the pop and access token, as well as client authentication. And I would really love it if it wasn't both Thank you. Thanks, Philip. Jacob. Yeah. So so I'm I'm all for a standard in this, I think, I think, the the problems on overlaying the authorized endpoint are are big. And I I would like what Justin said there on on, perhaps building something up from par It's probably time. To go in that direction. There we could. We should not be too scared of accept types. Or or content types, so that we could use actual content negotiation and and let the client and the server negotiate a little bit on that endpoint. I mean, it is web protocols, and to comment on John's comment there on a small subset from China. I I disagree. We we we in our deployments, we see actually"
  },
  {
    "startTime": "01:34:01",
    "text": "quite a significant number of of devices that failed to do at the station because they have a incorrect implementation of the chip or they have a different trust route from Google, not using Google. And for a vendor rolling out there, bank application or their whatever application, you know, x percent is not insignificant. Doesn't have to be even 10%, but I think it is actually in in some of these or or more. Were seeing that that type of thing fails. So there there needs to be various mechanisms for besides from attestation, depending. But the nice thing is You could you could you could have a different fallback. And with first party applications, you don't have to have same authentication mechanism, if it's not tested, you could have something else that that be stronger or more secure on a less secure device. Okay. I'm I'm gonna let John just reply to this. Sorry, Christina. So my my point was that web auth then on devices is universally available other than a small set of phones from China that don't have play services, and there's work to address that. You are correct that Providence attestation of the private key that's being used for the webauth and Natestation. Your mileage may vary. But I also have a solution for that, but I'm not gonna do the ad now. Yeah. Oh, okay. I misunderstood you. I thought you were talking about the at the station from the device Thank you, John. Thank you, Jacob. Christina. 2 points. So I I don't wanna talk about nonsense, but because there were few statements made, we did spend a lot of time discussing in this and the bank foundation as digital credential product goes working group. And there is a consensus forming that a new endpoint is not a good a good idea that imitating depops pattern where There's a not as returned in the arrow response is a preferred way. Because we don't want multiple mechanisms for kind of a similar purpose."
  },
  {
    "startTime": "01:36:03",
    "text": "And so we do want AS to kind of maintain control over these nonsense. And finally, like, extra endpoint is you know, it's additional complexity, which personally, I would also like to avoid if they can. So just just saying that I'm concerned with kind of reopening that discussion internally, I thought Paul and just ever aware of it, maybe they were not, but we can hopefully get there. Second point on Babylon Sun, if you could, maybe educate me, does it have to be a profile of this first party app draft or it feels like a mechanism to use passkeys or you know, to get an access token directly is useful for 3rd party apps. Too. Am I missing something? I I think there's a lot of interesting implications of using it for 3rd party apps. I don't think it's straight one to 1. There. But the e but to get to the other part of the question, no, it does not have to be a profile of this. But if we had this for 1st party apps, there's a very clear way to slot it in in a way that people would likely use along with other things, because people Frankly, don't go a 100% pesky from for things right now. Because of all the edge cases. So people do have multiple methods they might default or prefer passkeys it's not a 100% and I'd suspect it won't be 100%. What where are you billing? So, very short answer to Christina. There is a difference between 1st party and third party in the the audience of the webauth and assertion. Is targeted in the 1st party case. In the 3rd party case, it adds a complexity because of the of of of of who the audience of the web and assertion uses pair wise. But it that doesn't make it impossible, but it is a different challenge. Thank you, John. Christina, you know, wrap it up quickly. Alright. Would really like to And this is complexities we'd like to pursue. Attended, you know, k. That Well, you know where to find me. Peter. Teacher. No. Not. Quittery."
  },
  {
    "startTime": "01:38:05",
    "text": "Yeah. Just very quickly. Some of the I think one of the things that we see with things like, yes, boss keys is the future. Etcetera. There is also plenty of customers that have other solutions deployed and will probably have for a while. So we do need some we do need some kind of cover while we transition. I know, you know, one of the ideas is that this can be a stepping stone on, and and help us get there as well. And then I think that I see the chair giving me the eyes. We're gonna leave. Thank you, Vera. Okay. Thanks. Yeah. No. No. So So You you got lots of great feedback. There is lots of work to be done. It's great work. So let's Yeah. Like, Let let's talk about that non thing, that that the the different, yeah, the profile, all of those. So let's so There's yeah. The ball button, obviously. Right? So There's lots of good feedback here. Keep going and hopefully After that, we can kind of look into adapting this argument There's interest. Okay? Awesome. Thank you. Oh, okay. Let me stop this. K. Now I'm gonna leave and come can where is this is the day. This one. Okay. K. And you have exactly 20 minutes. So I told you I told you it didn't have too much time. Well, 20 minutes 20 minutes. Alright. That's what I allocated for you in the first place. Okay. Hi. Erin Pruccy again. Christina, are you already in the queue? Yeah. I haven't even started. Dollars can you give me slides? Thank you. So today, now I wanna talk about global token revocation. I originally had a different draft in the agenda here today. I'm sorry for swapping it, swapping it"
  },
  {
    "startTime": "01:40:00",
    "text": "short notice. But I'm assuming nobody read the slides anyway. So it's probably fine. Philip did. I'm sorry. I'm sorry, Philip. I So, they are actually related problems. And what the reason I I changed it was because the original thing I was going to talk about is kind of like the two steps ahead of things, things solving the problem that's 2 steps ahead. And I want to kind of back up and solve a more immediate version of the problem in a much simpler way, which is what I'm gonna talk to you about now. So Okay. OAuth, we have a client authorization server. And, in many cases, the way that those get referred to is an app and the app's back end or API. Especially in the case of things where you kind of just treat it as, you know, you download the Slack app and you're like, I'm using the Slack app you may have actually logged into the slack authorization server in that process. Sometimes you actually do log in to these applications through an actually external identity provider that is not the authorization server. In particular, enterprise IDPs, social login, IDPs, So we actually have these kind of 3 different roles involved in this picture. Now There are many situations in which these external things external to the authorization server that to the tokens might want to revoke tokens. So that could be a signal from the enterprise provider provider. Could be things like external security monitoring tools that this application system has deployed themselves, that they may wanna be monitoring log files and sending signals back to their AS. So The reason I bring this up is because, the The the goal here is to create a token revocation API that provides Applications that currently exist today who've deployed OAuth with the shortest path to implement this kind of token revocation, interoperably. I'm a big fan of doing homework and research existing standards and documenting how do what what's out there? How does it"
  },
  {
    "startTime": "01:42:04",
    "text": "solve the problem, how does it not solve the problem, and how does it relate to the problem I have at hand? I'm gonna go through these really quick. We have token revocation. RFC 7 1009 developed right here. The reason this is not applicable to the situation is because this is client initiated. The goal here is the OAuth client that has the token sends that token to the server and says, please revoke this token. And then the server may also revoke related tokens, and that's kind of left as a implementation exercise. But the point here is that it the input is the access token itself. And it is driven by the client. And that is not ambiguous in the spec. OpenID Connect has front channel logout. From channel logout is also a client initiated. So it doesn't really apply here, and then really need to go into more detail there. Open ID, back channel logout is much more related because open ID, back channel logout does have a server side endpoint at the open any provider that is expected to receive requests to revoke things. However, it actually mostly talks about revoking sessions There are 0 mentions of the term access token in the spec, And and I read it. Yes. No. I read it. And There there is a mention of refresh tokens. However, importantly, it actually says refresh tokens issued with the offline access property should not be revoked. And That is because this is designed for a particular purpose and the purpose that I am trying to solve now is No actually revoke everything. So That is a you could maybe, you know, argue that maybe we could just update or change it or blah blah blah, or you just ignore the should fine. But there is a larger point which is that many of these applications that have deployed OAuth servers, actually don't deploy a binding connect in any form."
  },
  {
    "startTime": "01:44:00",
    "text": "They may not have not anywhere near OpenID Connect because they have only ever dealt with their OAuth client and their OAuth server. So, they may integrate with upstream IDPs sometimes through SAML sometimes not even throw up any connect. So OpenID Connect is kind of a whole new world to open up to them. In particular, the input to the back channel logout is adjacent web token. Which means Jason Webb token validation as opposed to more simpler kinda API key or or baritone validation. So it is a lot more work to say to somebody go implement back channel logout, because it kinda opens up this world that they may not have any relationship with yet. Then there's the shared signals framework. Now this is starting to get a lot closer to talking about, cape the continuous access evaluation profile That is actually much more of a hint or suggestion from one thing to another about the state of things that have happened. And, expectations of what happens when somebody receives that is not guaranteed. It's not meant to be a command. Risk on the other hand is definitely getting to the closer stronger language of, like, Hey. You know, this user's session was terminated you should probably terminate the other session as well. So that's a lot closer. However, both of these, the mechanisms that they use to kinda set them up in bootstrap, they're multiple steps involved. It's a lot of back and forth. There's exchanges that happen to even establish this kind of link. Okay. Know a lot of people are probably wanna respond to this, but let me keep going. Because the other thing that I like to do when talking about Sanders is look at existing implementations of things that solve the same problem in proprietary ways. So I found 4 apps zoombox slack and Zendesk if you are on the PDF version of the slides, these link to API docs These are APIs that currently exist by products that have OAuth API OAuth servers that have an endpoint that does exactly what"
  },
  {
    "startTime": "01:46:03",
    "text": "I want, which is the input is a user identifier and then they will delete tokens and sessions of that user. These exist and they are not consistent, you might notice. So I've gone and given you, like, a shorthand version of the API docs to see how different they are, syntactically, time. But but The behavior is the same. And the input is also the same. It's a user identifier of some sort. In these examples, it is a user ID opaque user ID or an email address or some of them accept both. So if we take all of this context, then simplest thing we can do is to create a new replication endpoint. Which is in this draft. Which I have published today. So, Okay. Sorry. Hold on. Hold on. Gonna call for adoption right now. Make it. Good. 3. Yes. Okay. But I know, like, dropping a draft on a Friday afternoon is like not very friendly, However, Not best current practice, but the draft is extremely, extremely simple. I can show it to you in one slide Oh, not that slide. That slide. It's essentially just Here is the user to revoke tokens for and, the end. So, me let me back up because I do actually wanna go through these these points. So the input to this draft is a security event token subject identifier, which is almost an RFC. It's not quite yet, but it's very close. So the input is a subject identifier identifying a user. The authentication of this endpoint is required. However, it is out of scope just like token section requires authentication of the endpoint, but is left out of I basically just copy the language from that. So the outcome of calling this endpoint with authentication and a subject identifier is"
  },
  {
    "startTime": "01:48:03",
    "text": "the authorization server must revoke all refreshed tokens It should revoke access tokens, But most importantly, it must prevent issuing new access tokens and refresh tokens reauthenticating the user I have chosen these words extremely carefully. You might recognize this End result is that the user is quote logged out. However, I did not wanna mention the term logout in the spec. Because that kind of opens up a can of worms. The actual goal though is I'm in RC6749, there is a step which is called The authorization server authenticates the user. That step is out of scope of OAuth. Great. That's good. 5th What I want is to tell an authorization server you have to reauthenticate the user. That's really what what being logged out means is you have to go through authentication again. So that's the actual goal is terminate all existing tokens, reauthenticate the user. Now if somebody wants to implement this by keeping on to some sort of session cookie that identifies who they were so they know to authenticate them faster in the future? Go ahead. I'm not saying delete all context about the user. Saying reauthenticate the user when they come back. So, yeah, the input is either a subject identifier, which would be an email address This is from the sec event identify or draft. The input could be an opaque user ID as many systems currently have implemented. The response to this is basically just are you gonna do the thing? So if you if the authorization server the request and will proceed to terminate and revoke refresh tokens, revoke access tokens, then it just returns 204. Or it could return an error code because of whatever. And I do spell out a couple of the error cases in here, but there importantly is no response body because there's not really any need to know more than just did it work? So"
  },
  {
    "startTime": "01:50:04",
    "text": "not gonna ask for working group adoption, obviously, but please do read the draft. And I would be happy to take any questions on dotcom, How about In the next 10 minutes. How about per group last call? Yeah. Even better. Run a role. K. Yeah. John. So, think that, we should or we, you, eventually, should consider adding some an optional session fire. So that was one of the things in open ID connect back channel log that we had because there are times when you may have states coming in from different places. So just because I want to destroy all of the access tokens for my web application doesn't mean that I want all of the access tokens for all of my, phones and my iPad and everything else. Disconnected. So having an having an optional session identifier would be useful and perhaps we could eventually combine the open ID connect back channel output back channel log out with any wind point or making somehow convergent so that we don't don't have duplication because this is essentially the mechanism that we had in that that's back. So that is closer to what I was what I had in the original version of I was gonna present today of doing more targeted log out, log out, from more of that different kinds of context. One input being session identifier Another input might be device identifier, That's a larger conversation And I wanted to start with the base case of No. I really do wanna nuke everything just, like, nuke it from orbit. User logs in again, simple, and we'll expand it from there. I I understand, but the the reaction we got from people like Google, etcetera, was"
  },
  {
    "startTime": "01:52:00",
    "text": "No. We can't do that because it would cause untold havoc without a session identifier. Thanks, John. Justin. Okay. So need idea. Obviously, this, It mimics a lot of stuff in the existing eradication draft. Have you thought about using this for direct token management as well, or is this really intended to be user focused and user bound. This is really meant to be when the This is really meant to cover the case of there is no token available as input. Right. Okay. Nope. That's great. The Okay. Never mind. That actually answered the second question I had, so I'm gonna sit down. Right? Thanks, Justin. Mike. Nick Jones. You made me curious about what back channel did and didn't say. When you asserted that it didn't talk about revoking access tokens, which it doesn't. It does talk about clearing all state associated with the session. Which At least my interpretation of it. Covers that. Yes and no. It does kind of imply that there is one session. When in fact there might be multiple again, it's not explicit, and you could and go either way on that when you interpret it, but it's it's ambiguous there. Fair. I'm just pointing out that there's language that you could do better than. Yep. And also it talks about some of the state associated with the session being things like HTML5 local storage and cookies. And I don't know the degree to which you want to say those words in your draft or say that you disclaim them, but The more specific we are probably the less confused confusion that will be among developers trying to do things. It's a it's a it's a an interesting point. Okay?"
  },
  {
    "startTime": "01:54:03",
    "text": "Thanks, Mike. I would generalize that to say that it's about whether it should also clear client state rather than just revoke the client's tokens, which are kind of different problems. George. George, I guess I have a little bit of concerns around the 404 response. Memory, we like the the the existing token of vacation that you get a 200 back every time. Especially if some people are gonna use API keys. Is there authentication mechanism. I don't know that we want to create more ways to figure out which users have existing sessions at cases that are relatively easy to compromise. Wait. Wait. Wait. Wait. Wait. Wait. Okay. I was on board with the first part of that. But I but I'm I don't but the input is a is not an access token. It's nothing that the client has. It's it's it's it's pre established secret API key. Right. So to me, API keys are not very secret. They don't tend to be secret. Right? So there's there's a security element there Right? And and the input is an identifier that is largely known from all of our breaches. Right. So I it it it you know, If we strengthened the the the authorization elements, right, of how the the, like, if you if you pushed it you know, you push the authorization requirements more than just saying they're out of scope. It may be okay. But So I I'm on board with strongly preferring better better authentication mechanisms like private key jot or asymmetric mechanisms rather than shared secrets. But I don't think realistically that should be a requirement for this endpoint, is I feel like it doesn't. Add more barriers to to building this. But I'm all in favor of strongly encouraging it"
  },
  {
    "startTime": "01:56:01",
    "text": "And even including it as the default, in the examples. Well, so I guess the first thing is is I would take it out because if it's not needed. Nobody's asking for it, then it's a better the the 4 04. Right? That was my my concern was the 404 response. So if we just Alright. So are you are you concerned about the 404 in a in that it can indicate whether a user email or an email address exists Yeah. And whether there's a active session of that there, Right? In in in if the expectation is, like, why does the IDP need to know that it We can we can dig into that and determine if that's needed. Yeah. So I actually just wanted to respond to George super quick. That's why I got in queue. Go ahead. So the the reason that token revocation responds with, with a 200 every time is that it is a, best effort type of response that is, that the 200 response is, or, you know, 204, no content is the AS saying, got the message. I'll figure it out. Your part's over and, you know, I'm I'm I'm not making any promises beyond I got your message, which was well formed, and I understood even if there are no tokens, even if there are no sessions, even if there aren't nothing else. Because the expectation of the client is that it's gonna do the same thing every time. I'm not convinced that's entirely the same here, but I feel like it is. And that's something that if we adopt this. We will definitely need to be very careful how we specify that in order to figure out the kinds of things to talking about the same context. Thank you Yep. Dimitry. Dimitry Zagdulen, also on same topic. So The 44 is definitely a red flag from the perspective of discovering either that, user has an account or that user has an active session depending on how, you're planning to model it. And there's only 2 real options, to mitigate that. 1 is, as George mentioned,"
  },
  {
    "startTime": "01:58:02",
    "text": "to always signal success, right? So that it regardless whether users exist or not. Just as Justin mentioned, not just because it's the best best effort thing. But also for security. So regardless of what you post there success. The other the the alternative option that, APIs have used to to mitigate this is To always return a 404 if the user is, a, unauthenticated or, b, unauthorized. So, 401s and 403s automatically turn into 404s to mask the presence of the account. Yeah. And, again, I just wanna reiterate the thing making this request is nothing to do in the user context. It is a security monitoring tool It is a IDP that the user has an account at that they use to sign into this. None of that is in the context of the user. So those kinds of considerations don't apply. The concern here that I agree with is if One of those tools is compromised someone was able to extract. It's API key, it could then use it at the IDP to for probe for user accounts, but that's pretty deep level of compromise so like, it's worth talking about, but it's not at all the same as an open endpoint that's used for registration or password recovery that's user input especially unauthenticated returning those error cuts. K. We we are almost out of time. I'm gonna give David last word here, David, two points, I'll try to be quick. First is we probably need to think about how this cascades, up and down. So to keep picking on slack, the example where I have an enterprise IDP, signaling I should, do something to affect all sessions for user on slack doesn't doesn't necessarily mean, this should cascade up, but we should"
  },
  {
    "startTime": "02:00:01",
    "text": "you know, put more fund to that. Second, is somewhat related to that because the intense, behind these are usually not captured. It seems like the primary one's actually the kind of a logout signal, which I've I've been the past summarized as a signal that the person who comes back next time might not be the same user. So we may not even need to revoke tokens if say the system itself has a way to suspend use and tell there's a user interaction. So things like removing, state a play, an additional subtext of No. You know, something malicious actually happened that we may not have at this API level unless know, we go ahead and define it. I'm the what I'm taking from that is that you're talking more about client state again. And I do actually specifically wanna target the tokens that an authorization server has issued. Not just client state. So that's Yep. K. Let let's continue that discussion from the list. Okay. Okay. Thank you. And thank you. You very much. Thank you all for all the presenters, And thank you for all attendees and and for your contribution. See you hopefully in Brisbane. Okay. Confirm Thanks for Thanks for the"
  }
]
