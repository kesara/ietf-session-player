[
  {
    "startTime": "00:00:04",
    "text": "describe and today will be a fun session described rather than yesterday thank you very much are you going to be in the ether pet for so if you if you just upended underneath what\u0027s already there I think that would be best if that doesn\u0027t work let us no one will tell people where they can help you thank you good morning so this is quick how was your ITF weeks been it seems like weeks doesn\u0027t it so this is the note well statement again if you\u0027re not familiar with this please research it it\u0027s important it\u0027s the terms under which we participate here regarding intellectual property and likewise let\u0027s remember to keep this a professional environment if you have concerns or about harassment or similar issues these kind people can help you we can help you too but these are the designated people for issues along those lines and they have an email address on this but steam at IETF dot org blue sheets ok blue sheets will will be forthcoming we have identify described thank you very very very much do we have a Java relay are you gonna do that again we\u0027re gonna go great agenda bash so yesterday was so much fun we modify the agenda slightly for today we\u0027re gonna spend a brief moment talking about the second implementation draft with Martin do we have Martin there don\u0027t see him yet but hopefully he\u0027ll be along shortly just to confirm that the document he did some editing while we slept or did something and we want to confirm that that\u0027s indeed where we want to go and then we will go on to the issues the two ones we have queued up immediately with presentations is one about quicken variants from Martin yes can I suggest Ranjit can I suggest unidirectional streams we discussed first it\u0027s a very fundamental change I think we should set a deadline and it should be today so so we talked about this and we think that that quick invariance we can actually achieve something or at least time box that conversation but we need to know something about that as well whereas we strongly suspect the unidirectional streams will expand to fill whatever time it is given does that make sense and then we conclude on unidirectional strains we\u0027ll have some presentations "
  },
  {
    "startTime": "00:03:06",
    "text": "about quick ecn and some quick multipath experiments any other fashion so those last two items you will end go a question did you did you want to give 5 or 10 minutes of the forced head of line blocking slides it\u0027s Wafi data oh of course yes we\u0027ll include that in the related work at the end of that\u0027s all right sure sure I didn\u0027t know if right I don\u0027t know what we\u0027ll get just about this background we had another presentation for the HTTP session which wasn\u0027t quite ready in time for various reasons so we\u0027re gonna try to insert that at the end here yeah but either way it should be on the materials I sent them to you thank you yeah the last two are obviously no easy end you can argue whether it\u0027s part of a charter or not a multi-purpose is you know not yet but we asked what when the request came we asked the proponents to focus on things related to multipath and things related to as ezn that I sort of can inform the current design step right so basically you want to know is there anything that we\u0027re discussing now that will make multipath much harder or much easier ideally right and so I think that should be the focus and and since folks have asked me whether you know partial reliability would be something that we would talk about it I think it fits in the same category it\u0027s not part of the initial charge as far as I remember but if you know we can make it easier later but with something now that\u0027s not in conflict with the Charter then that would be a good discussion to have the other great thing I want to mention about the inner upright we have an inner rim coming in Seattle we mentioned it in October I think we go five I remember correctly I strongly suspect that in remote inner up will continue sin until then right since we have a bunch of people that that have stacks um if you have a stack and you haven\u0027t participated on the weekend right you don\u0027t have to wait until Seattle to come you can email you know mark and me and until there\u0027s a slack that is set up for people with stacks to chat about what happens when they run against each other there\u0027s various scaffolding that people are proposing like framework to run these things you know in sort of more structured way against each other so if you have a stack especially if it\u0027s a closed source stack since I think all the ones that we currently are seeing our open source right you know don\u0027t wait until to Seattle if you want to test we don\u0027t need to run these things you know in-house and not tell anybody you can approach people that have stacks that are open source or otherwise and start the remote inner up now you\u0027ll be happier when you arrived in Seattle if you do that okay any other edge innovation okay so let\u0027s go on to the second implementation draft Martin Duke "
  },
  {
    "startTime": "00:06:09",
    "text": "yeah Martin updated this for us overnight remote attendance is great they work while you sleep and then they don\u0027t sleep while you work doing it like I did okay Martin go ahead okay hello everyone again I know you\u0027re starting a damn at the end of a long day but so I tried to internalize the a lot of the comments from I try to synthesize from the minutes about this I thought there was pretty strong convergence around around the first options of what it really mostly emphasized getting the wire image and the handshake right and really cleaning up some of the remaining issues there - not to lock that down also well it doesn\u0027t there I use that word again not lock it down but at least converge closer to a to a final solution for this that prevents a middle box from ossifying on the wrong sort of thing so I think it actually may be best to go backwards through this mark so can you just scroll down to the bottom so the things that I didn\u0027t hear real and really any movement in term enthusiasm for addressing or at least not sufficient enthusiasm where the the five things you see listed there loss recovery is a very additional course very important mechanisms but they are also concepts have been tested in TCP and they\u0027re not in the pure sense interoperability issues then the next tiers things where I thought there was really mixed feedback there was a comment about bringing PMT discovery having worked that sectional a lot I\u0027m not really sure I follow why that\u0027s urgent and then the other one that was very interesting was your RT t and resumption there was broad consensus that it was a really tough and tricky problem and people do obstacle Cluj ins from that one was that it was too tough and tricky to take on and it could sink the second limitation and the other conclusion was that it was really tough and tricky and so we needed to tackle it right away and they could scroll up mark please and then beyond just sort of basic stream mechanisms and so on I thought we converged around a relatively simple applications simplement hb2 so you don\u0027t have to bring in all that weight at this point Ian did ask to have me multi-stream so I just sort of tweaked the the spec here "
  },
  {
    "startTime": "00:09:10",
    "text": "to say that it would be a simple echo application may be used in more than one stream and then finally there was a pushback about flow control and and and that we needed something to that flow control is again sort of tricky to get right that we needed something prevent people from just sending stuff out at line rate I still think that using flow control rather than congestion control is probably going to be a little simpler for this iteration and I am happy to not to just have the basic mechanism where you set pretty coarse limits on this stuff and the the real object here just to make sure that peers are observing those limits so that\u0027s basically what\u0027s changed since yesterday feel free to now shoot at that all right Thompson first thing I think we should probably just can the go away aspect on this one I don\u0027t think there\u0027s any point in doing that we we haven\u0027t really resolved the the open issues on that and I would rather just see it\u0027s not implement that it\u0027s something that\u0027s very easy to cut so just chop that just chop that out Oh jabber yesterday I suggested we do HTTP 0.9 which might actually which might actually fit reasonably well with some people\u0027s expectations of how the echo works which is you just with a get you know get X and then you get the some theme back it doesn\u0027t really matter what it is and you close the stream and then you close this straight yeah is that it\u0027s I think it\u0027s the simplest possible thing you have to say you have to like look forget that and if you don\u0027t you can file and whatever else um I think that\u0027s pretty reasonable you do string matching basically if I get this string I\u0027m gonna send this this this content I think that would be pretty reasonable way of doing it and I think that\u0027s um it\u0027s already otherwise I think this is this is pretty reasonable let\u0027s leave the debatable stuff out and as with the previous draft if you implement more than what was specified in these sort of we agreed to do this that\u0027s cool Jen I ain\u0027t God I agree with what Martin just said maybe we didn\u0027t restrict it we don\u0027t say HTTP 0.9 but just get because that seems enough for us to be doing this testing the yeah well we don\u0027t need to support all the parameters this is all I\u0027m saying the two two thoughts one a simple multi stream the application I\u0027ll note that between crypto stream and whatever stream you\u0027re sending data on we already have two streams so maybe it\u0027s already multi streamed so it\u0027s it\u0027s I\u0027d be fine that not requiring multi-stream the "
  },
  {
    "startTime": "00:12:10",
    "text": "application because HTTP point 9th is not multi stream so if you want to make it multi she knowing how to think about exactly so so you can multiplex multiple requests right I think that would be pretty reasonable okay fair enough what is stateless reset yeah I haven\u0027t publicly said I\u0027m gonna recognize Martin because I think he wants to respond to that yeah sorry about that that I I thought we changed the term from stateless to public reset herself republic the stateless reset and that seems to be confusing everybody so that\u0027s a indicator I\u0027m a multi stream application bit or the point about multi streamed applications I think this is the oriental point that Ian made yesterday which was that we can\u0027t really exercise stream versus connection flow control if we have only one stream subject to flow control cuz stream 0 as I understand it is not open to it [Music] great hi Brian Trammell um as the person whose name is on there to like volunteered to write up a non specified thing I think it\u0027s great if we choose a specify thing so and I think that yeah so I actually came up to ask the clarification question that Martin already answered or how are we gonna multi-stream this and basically HP\u0027s here and I\u0027m get a multiplex it seems perfect so let\u0027s do it yep I am also in support of Martin\u0027s suggestion at both remove and go away and HP 0.9 would get this is dkg I just wanted to put out to the room that if you really want a multistream protocol you could just do FTP for the record there was a boo in the room yeah this seems like Hello controller this is like a pretty reasonable list of things I do think we should do multiplex to get though not just assume that crypto and everything else our or our peril all right just just for the record resumption and dirty D are fairly different and resumption is easy and zero duties harder and so that that I don\u0027t know what gosh that pushes you in but it like it wouldn\u0027t be hard to do resumption here but there are key kiddos they call there\u0027s a plus one for microscope in Java for HTTP 0.9 okay so Martin do you have enough information to do a few more tweaks and then we\u0027ll take it to the lists I certainly can I didn\u0027t really get any gazer nays on the two debatable items but i think i think we\u0027re converging on all the things were actually going to include in this yeah i mean it the first set of of items there we heard from martin that he thinks we should drop those and several people "
  },
  {
    "startTime": "00:15:11",
    "text": "agreed and several people indeed are agreeing in the room right now okay great then yeah you\u0027ll see something without any uncertainty in it and then we can iterate from there thanks and thank you so much Martin okay that takes us on to quick invariants Martin Thompson I will queue up your presentation you know what Martin has this been updated anytime recently okay then I have the most recent you haven\u0027t changed it for you thank you okay why is it not in my rep oh hi my name is Martin Thompson it has been manin I\u0027m trying to count less than three minutes since I last spoken to microphone I\u0027m layin here until these guys saw this out because we\u0027re not going anywhere without my notes on there on the screen no it\u0027s called handshake here Martin that\u0027s what\u0027s confusing me yeah because that\u0027s what I\u0027m looking for I don\u0027t care about the rest of the things um so how the reason why I wanted to have this discussion here was that it was in anticipation of people actually implementing the handshake and it seems we have at least a little bit of experience with that so next please all right so I\u0027m talking about the tax before we have a handshake complete the thesis here is that it\u0027s very easy to prevent the handshake from completing any number of things that can go wrong and any one of them can go wrong and then you don\u0027t have a handshake and you don\u0027t have key exchange and the question here is what if anything do we want to do about this what make the mechanisms do we want to build to make sure that someone can\u0027t interfere with the act hand shake completing this as a matter of here you can follow that if you like next slide please they are in the wrap out and they should be uploaded let me make sure they\u0027re also on the data tracker I thought we have been there but yeah they\u0027re "
  },
  {
    "startTime": "00:18:11",
    "text": "certainly in the quick working group materials so this is a decision point that I think we need to have can we agree on this that is during the handshake that the IP address on one side the IP address on the other side and the port numbers that we use won\u0027t be changing now we sort of assume this currently it does not work at the moment if a client receives a packet from a random IP address I don\u0027t believe that\u0027s physics if you send a packet and it comes and the response comes back on a different source IP it\u0027s not going to get through your net and we sort of have and if it comes back to a different IP address or port well it\u0027s probably not going to get to you so I think this is what we are assuming at the moment and if anyone disagrees with that I\u0027d like to have them speak now thanks about I can always rely on you man it\u0027s about anger so one point of clarification is what the scope of the handshake really is here is it until version negotiation is complete or is it that the 0rt is done no it\u0027s until the handshake is complete and that is until you have the shared case so the perhaps we should clarify that to not include the client second flight because but in my because that\u0027s that\u0027s really just sort of signaling at that point but up until well let\u0027s there\u0027s some challenges in in that as well I think perhaps what we what we might do most cleanly is to say the point at which you start packet protecting with one RT tikis is the point the handshake is done so there\u0027s a point before that as well in the current version this was true in the previous version of the draft and the current version of the draft the client will choose the server chosen connection ID in the second flight in the finished message in the yes that is the client Claire Dex packet yes so we could now allow the IP address source IP to change after that like as soon so should we redefine this as more that when there\u0027s a lot packet yes you could and that\u0027s why I think we might need you know maybe a little bit of hand waving is is necessary but I think that that\u0027s the only one that yeah it\u0027s that so I\u0027m just suggesting a change of language to be that until the server chosen connection ID is available for the client the client cannot change the source IP address that work - yeah there\u0027s some there\u0027s some other things here that I think will be using the handshake is complete rather than that "
  },
  {
    "startTime": "00:21:12",
    "text": "particular one but that\u0027s fine I was looking to simplify a little bit mmm we can make that point and next slide please right alright so um let\u0027s talk about what it is that someone can do to prevent the handshake from completing so if you\u0027re on path and you\u0027re able to see and modify packets as they transit you can block them to ask a question Oh Manju at one clearfix all right one clarification on that on the previous slide so is is that limitation is that security limitation or is that something to do with the CID assignment I think why I can\u0027t change next night yeah as Capote pointed out it\u0027s connection ID arrangement when the negotiation you you go through to get a connection ID and I don\u0027t like to use the word negotiation here because they\u0027re not really in a negotiation but yes well because I mean in principle because if that\u0027s the issue in principle if the client maintained it had both my IP addresses but maintain consistent client or a consistent client connection ID then really you\u0027re just have to associate that those two connection IDs as a server you need to know what the client was using and what you proposed and sort of track that transition okay we\u0027re not precluding anyone being clever but I think we have to take some steps to simplify this yeah fortunately Martin okay all right you clarified don\u0027t just that really doesn\u0027t like create a whole host of complications about like off path attackers and them like redirecting you like during the handshake or like right after they handshake and then I it it\u0027s possible they\u0027re all solvable but like I think in the interest of making forward progress on the transport it would be awesome to agree on this now and if we think like their constraints that this is imposing that are like really costly to applications we like them to fix them late right right yeah okay thank you I\u0027m gonna assume that that\u0027s a great move on so if your own path you can modify in an delay break oh my one interrupt I just hit an operational issue I\u0027d need to take care of and I was trying to take bad minutes I need somebody else to take over I\u0027m sorry okay can we have a volunteer for a scribe please you and etherpad right okay thank you through it so here on path I\u0027m suggesting we don\u0027t worry about that because we can\u0027t stop someone from messing with things it\u0027s "
  },
  {
    "startTime": "00:24:13",
    "text": "actually pretty easy to modify a client hello in ways that would be very difficult to do detect you\u0027ll detect it later on when the handshake fails but nothing else but the question that we have here is what about attackers that are off path maybe they can see packets maybe they can spoof packets next next slide so the standard defense here is have the recipient of a packet prove that they received a packet from you and in TCP we rely on echoing the sequence number in stun we have a transaction ID for that we actually have some more entropy than that in practice but in quick well hmm next slide so virtual negotiation echoes the packet number and connection ID the server stateless retry does the same thing after a version negotiation the client initial doesn\u0027t actually contain a proof and I don\u0027t think we actually need one because it\u0027s effectively like starting over the client doesn\u0027t really assume that there\u0027s any the server doesn\u0027t really assume anything about the client when it receives another one of these things you can actually put a cookie in the server stateless retry and that\u0027s kind of several layers in but you can put that cookie in and when the client sends another client initial with a client hello in it that will contain a cookie and you can sort of do some verification that it was the same one that allows you to do the source address validation and that\u0027s kind of the fundamental basis of that the interesting one here is that the server plaintext might include an ACK frame and that\u0027s actually something that we not concrete on because we we have the situation where acknowledgments aren\u0027t necessarily present in every single quick packet and the server plaintext is actually multiple packets and some of them will contain an AK frame and some of them will not and so when the client receives one of these things there is maybe a pack and maybe the packet number of the packet that it its initial client alone and maybe not in one and comment about that is though the G quick code is not perfect doesn\u0027t do this all the time it attempts to always include an AK frame I believe with the equivalent of the server point X and the reason is to as much as possible not require not rely on the crypto state machine to poke into the transport state machine and say well I\u0027ve done forward secure sir like nuke all this crap like it\u0027s really nice to actually have the transport layer as I mean otherwise you have to do a bunch of optimizations it\u0027s still valid but really nice light it actually if you can require that it\u0027s great I guess I\u0027m saying and and yes we could require that then the zero goes away and we only have that we have the 31 so I mean one thing which we should discuss for the future is exactly the point years raised namely I send a client initial and I get the server the server below should I assume "
  },
  {
    "startTime": "00:27:14",
    "text": "that it possibly acts finally can you speak into the mic please sorry should I assume that just implicitly acts the clan initial or should I be continued to retry the client additional even though I have like if it did prove this been received that is a good question and I\u0027m hoping the answer to that might be clear after unfinished azuz I fear the answer is not I yeah i would prefer the answer is no but if we like I\u0027m pretty sure we do that and you quit today just because we I\u0027m pretty sure we do that and go go click today just because it\u0027s the server plaintext typically includes an iframe and occasionally does not and mobile humble like we basically want to clean crap up and like move or it\u0027s not ideal we don\u0027t really like it christian we demo from a testing state machines like that in palo types things get much easier if we do mended that the self plaintext no dashes the previous packets that is that is true and we can certainly make that requirement so the other thing to observe here is the client plain text in addition to also probably maybe including an app although this and text in there that sort of suggests that maybe you want to defer that to beacon a fennec had it it contains TLS cipher text and you can you can actually use that to implicitly the server can use that to to verify that this is actually part of the same handshake that they were continuing that crosses the layers again and this is another another point so next slide please yeah this whole on path of path the tack thing is something that I consider to be a responsibility of the transport and it\u0027s getting handed off in various ways and it\u0027s inconsistent and not very clear so next slide so here\u0027s I think the options that we have if anyone wants to come up with a different one we can discuss that here I want to spend a little bit of time discussing the the relative merits of these so Mikkel on github proposed at various points the idea that we have separate connection IDs for peers and we essentially have two connection IDs one on controlled by one endpoint controlled by the other end and you actually echo them in both directions that in addition to providing additional identification you would have the ability then to use those for this sort of on path of path verification Christian you should read them out the practical threat that I\u0027m really concerned about is the man on the side right and on the man on the side case we have to assume that the man on the side have seen the content of a client hello "
  },
  {
    "startTime": "00:30:17",
    "text": "so a the only actual security that we can get is it if we do involve the key and the defense against the man on the side has to be something like to your connection do your handshake on a secure Channel somewhere and then we use that on your concept network yeah so the that\u0027s the the observation there is that them if the man on the side can can race your genuine handshake packets because they\u0027ve seen the other ones they can certainly cause damage and without a key without a key you can\u0027t really do anything about that I mean I think Eckhart selection suggestion seems totally reasonable I as seven the issues kind of one a thread change the hatch again anyway because now I\u0027m super concerned about ossification of our handshake I would prefer anything that encrypts it based on both connection ID and some version number or something some other some other knots that basically makes it a hassle for middle exes unless they upgrade frequently so I your suggestion was actually encrypt this but with effectively with a fixed fee a fixed key perversion it\u0027s a perfect pretty quick version for connection ID sounds is that\u0027s approximately might interesting well I I think maybe I\u0027m just restating what I think Ian said but let me put things new concrete which is that the client can the client offered connection ID is used to and safer as used as the cryptographic key for otherwise bog-standard AES GCM or aad protection if you want to pick cha-cha or something I specifically with that of the packet so it\u0027s always the same transform and it\u0027s just and just prior to handshake completion it\u0027s key with the connection ID or something each KDF tawfik okasha yeah and and Kristen\u0027s point if you can see that connection ID you can break this thing and ask yeah you\u0027ll be able to read it that makes inspection of the contents of the handshake message is difficult for a middle box but not impossible but actually I won\u0027t add that I still do want it to be a function of the quick version because I want the property that as quick moves forward as a I do a version bump and we had enough with TLS one point for that in order to see inside the handshake packets you actually have to upgrade your middle box to see the sni and all that stuff because otherwise okay suggestion would be we we roll the dice and come up with a key that we put in the speck and we take the connection ID and the now we work it out yeah I don\u0027t care about the details I just want that feature and we do it Gemma and God I I do have a concern with this we\u0027ve talked about this in the past and we decided not to use PSG same for plain text packets because one of the reasons was because we would not be able to duplicate it ever we\u0027d be stuck with this for the rest of our lives and "
  },
  {
    "startTime": "00:33:17",
    "text": "that\u0027s a concern that still exists not not not with the in suggestion so with the in suggestion it would be version specific the transformers being used hope so and so if we decide that we want to use so 13 for the next version of quick then that would be perfectly this is what all here to expect it\u0027s very including the plan to do the grand initial so as he defined initial and I don\u0027t know what version it is how am I going to decrypt it the versions in the header so we would we would protect exactly the same way as we would project any other packet it\u0027s just that we would have a fixed cipher and a fixed key oh thank you yeah I\u0027m sorry yes I think that that works right so not to be arguing against interest but um there is an implication of this which is that you will be unable to validate the not the the quick validity at all of these packets unless you speak unless you have a es so um so that\u0027s the appreciation this is they will just lock it like you will Michael distinguish random nonsense if you don\u0027t speed that version you know there\u0027s a random nonsense from there there will be signal in the version field okay so you\u0027ll be able to look at the version field and guess that maybe this might be quick but there\u0027s not a lot of signal there\u0027s not a strong single yeah design this offline because you rapidly running out of time I\u0027m happy to send us a concrete proposal based on thing as a research that\u0027d be great would you be men debate is a possibility right or are these all right if they want to see your proposal has been the work on it right and so just just to put a try to put a pin in this one Christian go and I\u0027ll try to summer summarize well I mean now I\u0027m the proposal is fine I would insist that we do it the way that we specified clearly whether we do that for the second implementation or not correct yes we will make that very very clear because because it is going to make the interim interesting yes I agree yes are we we found that FMV won a despite its simplicity was not actually something that everyone agreed on there were quite a number of problems with that which is an interesting thing that we kind of missed in the report yesterday so um the advantage of doing this is that for all the clear text packets we\u0027ll have some proof that this is part of the the original connection and you will have to be effectively able to see in the initial client packet in order to generate a valid packet that will be accepted by anyone further on the handshake that\u0027s great thank you excellent right a badly form frame is a connection error but if there\u0027s no handshaking it if the handshake hasn\u0027t completed are you sure "
  },
  {
    "startTime": "00:36:18",
    "text": "that it\u0027s actually from the other guy or is it from an attacker trying to break your connection so the question is to ignore malformed packets and whether do we actually kill the connection as a result of various problems that we have during the handshake NIST so here\u0027s my principles next please okay so we have an example here\u0027s version negotiation we can skip this one okay so the idea here is I\u0027m going to suggest that we rely on the defense we have against off path attackers we accept that disruption of the handshake is possible if you can see the packets and inject them and if we want to and we\u0027re doing resumption we can add extra defense later not now I don\u0027t think that way I\u0027m interested in in having a another design team on what is essentially a corner case in Chennai anger IEP with this this bad forward we have thought about we\u0027d for Google quick at least we thought about this quite a while and and they see Lee allow for connection clothes packets to be received at this point you know in plain text that\u0027s what happens and yeah it\u0027s not a trivial problem to solve yep okay if there\u0027s no objections I think we\u0027ll move on so what happens if the handshake fails how do we actually signal this so prior to sending server clear text the server hasn\u0027t committed any state maybe this maybe you can just sort of ignore what anything that looks bad and prior to the client receiving that the client doesn\u0027t know if the service committed any state so think about those things when we go into the next slide and we mandate currently virtually all of these things for Erica cases so in some cases we send a version negotiation packet sometimes we ignore things sometimes we drop the canipe the the connections silently for instance if it\u0027s particularly find initial packets we basically treat them as internet chaff and and ignore them sometimes we send a connection close in the clear or we could but the draft prohibits it and it also mandates that we send TLS alerts but we don\u0027t really say ways so there\u0027s a bunch of things that we need to clean up in the in this respect next slide please there\u0027s reference next so there\u0027s a bunch of things that can go wrong before the handshake completes I think this is not exhaustive but it\u0027s pretty pretty close to what we have and I want to go through this list and apply a set of principles rather than go through each one of them make a decision so next slide so is my proposed set of principles for which we\u0027ll go through this I want agreement on these principles so that Jonah and I can go back and actually apply those principles so my my rules are if it looks like it\u0027s going to move your state forward and it does we\u0027re good if it\u0027s redundant because it looks like a retransmission of something so it\u0027s a version negotiation "
  },
  {
    "startTime": "00:39:18",
    "text": "that contains the the version that you picked just drop it move on that\u0027s fine maybe you can fire some spurious retransmission or if you want to keep tracking these things whatever do what just basically the draft will require that you should just ignore it clarification question and you see use connection clause if you can are you actually talking about using that in PA text yes yes so if it contains an error if it looks good but it\u0027s broken in some way send a connection close give up in the clear doesn\u0027t matter and if it\u0027s a TLS error and it\u0027s generated an alert shove them in a stream frame and and and shuffle it across because that\u0027s useful information of the other side they can diagnose a it\u0027s about civil anger so by redundant you mean the the packet number has been sent again like you got it yeah it\u0027s not gonna be the same packet number but it\u0027s gonna be the same content so if you receive the string frame that for data that you\u0027ve already already got it\u0027s just a retransmission right so if you receive a second client hello as people discovered in in the in the hackathon people retransmitting claim hellos before the server flow arrived even on localhost I don\u0027t know how that actually managed to happen but this happens you received your client Hallows if you\u0027ve processed the first one and sent out the response just ignore the second one that\u0027s fine right I\u0027m I\u0027m wondering more of this is the packet layer this is a stream layer that that seems like more of a stream layer question right like versus a this is this is a an expression of principles because it operates it overlays version negotiation is one of these examples yes so yeah that\u0027s what I got up to say Jen I got that yeah this applies across the board because version negotiation is one of those things which we currently actually ignore and that falls under that print and then understand the stateless retries another one that that also falls into that category you receive you send to client initials you get back to stateless retries just one of them used in the other one throwaway so just make sure I understand these principles I wish to apply them in one case say recent receive a second a parent client initial that contains different contents or as longer or shorter than the first time I simply direct sure um so Warner was actually quite interesting shorter is less interesting so that\u0027s an interesting one because it\u0027s apparently done stream zero that is yes Chennai and God I think at the moment we actually require exactly one client initial so I suspect I don\u0027t know I\u0027m not sure but nobody would you rebuild the client initial and if someone\u0027s got a bug in the code with their ex they\u0027re actually rebuilding the client initial that\u0027s what you mean okay then then you you might have end up with two two different ones well the duplicate client initial is also a signature of a man on the side attack that is that is the point that I think we need to consider in this case "
  },
  {
    "startTime": "00:42:18",
    "text": "so I would say that maybe yeah you don\u0027t know if you receive two of those message and the same goes for the server plaintext you don\u0027t know at what you receive is but spoof by a bad guy all odd the ghettos or some he cut part of the client service at the minimum you want to have some kind of logging that these things happening right but but in terms of principles I think the the the rule here would be particularly for Akers case where there are different lengths and different contents if you can detect that file would be the the application of the principle way but I wouldn\u0027t insist that people detect that I mean the retransmitted client hello should have the same stream zero data sure might have to be a hacker number different pack number yes exactly so that case you can actually distinguish um which is the you know but yeah but the other case is when somebody regenerates the client hello erroneously then it looks like an attack loss what will happen in the case you cited here we receive two firms that were caught to send data at the beginning of stream zero with different lengths and so if you just apply the current mechanism backward what the that echo was mentioning you we serve first and hello that as a hundred bytes and a second way that that how did ten bytes the the state of behavior is to Paterno\u0027s or ten bite at the end of Jim see I agreed what I\u0027m saying is the case we are doing the inner up is a retransmitted client hello that basicly had the exact same stream zero data as the first one and that\u0027s that\u0027s valid retransmit and that that should be able to ignore because the stream zero data is exactly what you got in before we have a principle already for this one so the current draft talks about the possibility that you can receive different values for a given byte on a string and it says that you may if you if you like detect this thing and treat it as a connection error yeah and if the length of a client hello changes that\u0027s a change in the byte that has a lesser linked feel in there that will be changing the stream data if the first the second strictly extends the first if there\u0027s new apply even at the no no implicator cannot okay it cannot and be valid at the same time well yes and no um so Jeremiah in the client flow is just a stream frame so I receive a client itial with a stream frame that is longer that is a properly formatted client hello plus say made properly unfor meds you know she lost record for um for client finished right dozen companies I think I think that the there are there are two principles what can imagine applying here one principle is just drive the state machine forward "
  },
  {
    "startTime": "00:45:19",
    "text": "using the not the nominal like reassembly principles you ordinarily apply and in this case as Kristin says either on the side or you\u0027re talking to mink it doesn\u0027t matter which one but hum you uh you know you end up with two copies and you just you know and and if they are scurrying this way you end up with that extra data being prepended to the server finished and the client finish and that should eventually fails um so that would be the nominal behavior the other behavior you could imagine applying which would be say be in this particular case be extraordinarily aggressive at double-checking for anomalies and attempt to recover from them I think that won\u0027t be a and so in the way you this is you describe that second quite a low as bogus um our rule special rule for client initial on I hate it\u0027s probably not worth doing I mean it\u0027s it\u0027s happen to be very communal for me but if I process my initials always separately for anything else but I think in general that\u0027s like not not like great role to have so I think I I think until and I think probably I won\u0027t do a very good job of fixing the problem anyway so I propose we just say ordinary processing applies here and because the man is like it just as well send you a packet which appears to be a client plain text and contains bogus garbage for that for the finished yeah I\u0027m gonna jump to Martin in the remote cue yes can you please clarify what the difference is between a peck that is in error and is in clearly bad and also what the asterisk means at the end of ignore it I think we close that one declining shoulder sorry clarify which one understand um yeah so that there was notes on that on the slide and I think the client initial was one of those things there\u0027s the length thing as well that I wanted to mention if a client additional comes in and it\u0027s only eleven hundred octet Sloan that ones one that we just throw on the floor anyway things like that I don\u0027t have enough room on the slide to do this and I can\u0027t remember exactly what I wrote down all right look let\u0027s try and let\u0027s close the queue I think because we do need to get on to the next topic these are right principles this what I\u0027m gonna get into I\u0027ll be really quick and it\u0027s done correctly what what I could said I actually heard that we have a special case for the client initial just because the Veda the stream reassembly would work we don\u0027t actually we don\u0027t actually say exactly which copy or data should be delivered to the application if the transport receives the first copy and then the second copy and they\u0027re different at stream offset zero we don\u0027t specify what happens at this one defined behavior yeah you you can generate an error and it does sort of encourage you actually you do so that was it opposed awhile ago yes there was a stream overlapped error if you remember that that be removed yeah and that actually was to check and see if if we receive I was a proposal that "
  },
  {
    "startTime": "00:48:21",
    "text": "we check to see if the data that we received if it overlaps and is different from what we already buffered then you spit that error out but we can talk about this listen oh yeah I don\u0027t think we should go there yeah so the the conclusion there I thought was that you we used to have a you must check and that was going to be particularly onerous yeah no I don\u0027t think we should do that so just I\u0027m just I\u0027m proposing that we specially give the command in special cases yeah I think that you you had the first principle that said that we accept that the clear-text part of the exchange is not protected okay and that means that he people play games back inserting data on streams you owe by values firm etc that\u0027s too bad it\u0027s as long as we don\u0027t have the key negotiated we cannot protects against that that we accept it and that\u0027s it all right I\u0027m done you guys have the information you need I have the information I need it which is good thank you John okay great thank you so um we have unidirectional streams and then we have three presentations if we want to get to those three presentations we need to finish up the intellectual streams by about ten fifty five so when we get to that yeah that\u0027s totally achievable I guess when it comes to 10:55 we\u0027ll we\u0027ll stop in this ask where we\u0027re at in while Ian\u0027s coming up does anyone else need the blue sheets raise your hands nice and high cool given out yesterday whether I have high expectations unidirectional and bi-directional stream so there\u0027s been the pheromone discussion in the last about a month on various like kind of streaming models that we might apply to quick so next slide background Beck needs to support HTTP is in the charter HTTP to supports both quest response and server butch server push essentially only sends data in one direction and does not actually send any data in the reverse direction from client to server so the transport and application combined need to support both bi-directional streams and unidirectional streams so on a high level there are two ways to get there he\u0027s only one direction of a bi-directional stream they\u0027re kind of two different ways or maybe three different ways depending on your perspective of how one might accomplish that or build bi-directional streams on top of two unidirectional streets cool let\u0027s go the current draft describes pairs of incoming and outgoing streams than TCP it\u0027s a it\u0027s a very standard you know bi-directional streaming model it\u0027s pretty ideal for HTTP you requests and responses I mean it obviously fits fairly well with most request response "
  },
  {
    "startTime": "00:51:22",
    "text": "protocols we have a bunch of deployment experience with it it seems to largely work the cons right now where requires are sending an unnecessary stream frame with a thin for serverpush at least in the context of HTTP that\u0027s kind of the main the main con so yeah mutton Thompson there were a couple of bugs that I went through in the presentation in Paris okay they issues down there but then you didn\u0027t add any issues no thing I dropped the ball on that one I\u0027m sorry on that I had to look them up and work up like 7,000 of them so okay that\u0027s fair I I noticed that they were there and I was wondering I was like oh I wonder if he\u0027s gonna have these fit now okay so okay so apparently there are some issues I do not know what they are next byte or channel so this is actually what Google quick does today apparently I didn\u0027t know this before this old discussion came up and we do bi-directional streams but instead of centering to send the fin we just close it we\u0027re just like mmm I know how server Busch works from the application layer I\u0027m just gonna like shove this half down this is ideal for HTTP it works really well like you don\u0027t require any unnecessary state management it requires a potential layer violation on the negative side as you depending on your perspective and you can\u0027t tell from the transport state exactly what\u0027s going on so if you\u0027re looking at it on the wire and you were trying to just terminate quick as a transport you would have no idea that like the stream has already have closed unless you knew how the application mapping worked but I mean this does work fun but it\u0027s little bit unseemly alright next one so this is a proposal to allow you to open streams half-closed adds a bit in the stream frame to indicate this is going to be a half closed stream it saves you sending an unnecessary thin for server push it\u0027s a relatively small change the existing draft uses a bit in the tight bite on the negative side add some transport complexity particularly around implicitly open streams it\u0027s possible this requires an extra state just to explicitly deal with that and we don\u0027t have any actual deployment experience with this as is true at the next year as well so this is essentially an optimization expiration say it\u0027s a high-level this is essentially an optimization on top of the bi-directional model to just say you know I don\u0027t really like the non-explicit close of the Google quick approach and I also don\u0027t really want to deal with sending an extra like fin definition your brain just a clarification point am I in God there was actually early in the earlier drafts or at least in the input draft we did have in the stream state machine there was the application close on both sides which was the transition used to "
  },
  {
    "startTime": "00:54:24",
    "text": "implement Google clicks you know directionality function and I also just want to clarify that the difference between the unidirectional stream case sorry the the the Google quick case and they do nothing bi-directional case is that in the bi-directional case we\u0027ll actually be sending a fin that is in Google quick we just don\u0027t send one thing that\u0027s what it is yes so the new proposal is all streams are unidirectional you pair two of them together to create your own bi-directional scream if you need you at the transit support at the application we are not the transport sorry so with the transport dock you only have unidirectional streams for example you can create a bi-directional stream from 5 \u0026 5 or you can create it from like 5 and 18 like so it\u0027s especially in the presence of mixing unidirectional streams and bi-directional trains it\u0027s very reasonable to assume that like the IDS would not line up that they may ends on the application mapping alright next like in clarification question um is there a difference between two unidirectional streams and the current currently current bi-directional stream I think it\u0027s confusing calling them pairs if there\u0027s no they I I guess that was kind of one of the points of this side is that they they need not be there they can be and that\u0027s fine right because it\u0027s just the same number or not but if a tie so I mean let me let me rephrase that and it\u0027s kind of Martin I don\u0027t want to confuse that kind of trying to I want to my clarification go through my head and I\u0027m going to ask again you know I think I can help you so the I think one of the fundamental differences between saying I put a unidirectional stream and another unit unidirectional stream paired is that at some point in time depending on your upon your interaction patterns in the pairing case you don\u0027t have state that bridges the two of them together and so if you have the if you have the bi-directional streams and you look at a typical HTTP interaction where you have a small get request the transmission of the request completes but you still have the state associated with that stream even though you have no ongoing transmission for that thing you have state at that point and in the in the unidirectional stream where you just sort of stitch the two unidirectional streams together at the transport layer you have the get request go out as one stream and then it disappears and you have no streams right and then later on the response comes in and you have a again and so this there\u0027s nothing at the transport layer that bridges the the state between those two things yes yes modulo loss modulo Lawson overlapping analysis of other things that we do right there there\u0027s a lot of cases where a request comes in and the response is going out at the same time and it\u0027s all "
  },
  {
    "startTime": "00:57:25",
    "text": "down to whether or not your perspective on things as to whether or not those things that can hang over concurrent a lot but the transfer present so so yeah so the key thing here is it\u0027s in the transport dock there are only unidirectional streams and if you want bi-directional streams or any other pairing options which may be more complex such as they were don\u0027t HTTP to mapping you need to build that at the application layer that\u0027s it yet yeah that might be maybe the right way to summarize this is a BYOB is it bi on Ambreen you\u0027re being irrational but the way i bidirectionality yeah that\u0027s like okay let\u0027s keep moving so this simplifies the transport dock I definitely sympathize server Bush makes the HTTP maxing document more collects each application needs to implement request response mapping if it needs that and there\u0027s kind of a weird quirk around back stream limits where you can potentially get in a case you can send a request and not get a response I mean it\u0027s up to the application implementation to like make sure that doesn\u0027t happen but it\u0027s a possibility it\u0027s kind of weird edges yeah so Martin Thompson it\u0027s also unclear as to whether is actually a con that\u0027s what I that\u0027s a fair point so you might just wait oh wait we\u0027re cool with this and we wanted to send all these pushes and you know your us enemy requests okay yeah right so that\u0027s yes it\u0027s a little bit hard but that that\u0027s I think the the only observation you write that\u0027s very it\u0027s certainly odd but you are it may or may not be a con D I only have like one Morris do you me to get through them can we let him thanks okay next oh yeah waste the clock one just a clarification listen on the previous slide do you want me to swap that is it okay hold on a second then no Jenna I have a clarification Chrisman in the previous slide you you said there\u0027s no it it says there\u0027s no deployment experience my understanding at the moment is there\u0027s no implementation experiences that incorrect yes so I probably should have said implementation or deployment I don\u0027t think any of the last three have implementation yeah so there is no diploma in the experience in quick obviously because then I would personally have no deployment experience with any of this stuff you guys have in the second one that in presented you certainly have some experience with that one for sure so the the observation was "
  },
  {
    "startTime": "01:00:26",
    "text": "that there are other protocols that do this and the question is whether or not you consider that to be the climate experience do I believe that chatroulette runs on one of them okay if I was not I actually I think I asked about this in the past and I was not aware of like which ones actually used it because I was hoping to take a look and see what it looked like yeah my understanding is that that\u0027s the underlying protocol model that chatroulette runs on it\u0027s very freaky example note that that\u0027s something that\u0027s particularly like maybe I proposed nothing but yes that\u0027s right no no I believe that\u0027s what it was Cera\u0027s Oh Justin said it oh that was a test application is yes so Martin has a ton of something Pro is is more unidirectional streams are are more generic which is that\u0027s reasonable applications in to define their own mapping they both can and must so like it\u0027s a pro and a con but like if you a super optimized mapping then you know I think it\u0027s reasonable to think that like you might be able to do some things more easily with this although I mean I guess you could only use one half of a bi-directional screen but as stated earlier like the more you use that the more it and it becomes a little bit like okay I guess unidirectional plus a binding layer I\u0027m not this didn\u0027t get as much discussion on the list so I\u0027m a little concerned that some people didn\u0027t end up reading the PR in detail but this was an idea of we\u0027re gonna take unidirectional streams but add a binding layer back to the transport document this is partially motivated by the fact that you know a lot of people including myself we\u0027re unhappy about bi-directional streams being proud of the trans word document because I was concerned that everyone would just like reimplemented them and the so this adds a very functional binding layer back into the transport document on top of unidirectional streams so it\u0027s it the transport document allows more things than certainly unidirectional streams would and even bi-directional streams do it alone including many to one it\u0027s the most obvious example it is it\u0027s it\u0027s kind of less general I don\u0027t know I mean I guess you can also just use unidirectional so my sure if it\u0027s it\u0027s certainly more complex than either of the first two options it\u0027s sort of like we want all the options allows many-to-one which is as well and of course there\u0027s no deployment experience the other thing I wanted to note about it is that it it does this with one byte and one number at the beginning of the stream so it\u0027s sort of like shows the framing in the first few bites of the like stream offset zero which which is a pro and a con so the nice part is all this configuration stuff is set up think being in the stream one major con is if you start receiving data out of order you have no idea if "
  },
  {
    "startTime": "01:03:26",
    "text": "it\u0027s like a unidirectional stream or a bi-directional stream or like a multi-directional stream or a level what you basically just have to buffer it and like deal with that later yeah so nan Thompson I think the details of the pull request are probably only there as illustrative there\u0027s a bunch of things in that pull request that I think go a little bit further than I would I think that it could be very simple but that one\u0027s got a little bit further than and there may be ideal and as you observe that particular bug whether you consider that a bug to the extent that you consider it a bug don\u0027t consider that to be a problem that\u0027s inherent to the proposal we could put a reflective stream ID in every single stream frame if we wanted to or I don\u0027t necessarily this is YouTube but I don\u0027t think we need to pointing out that there\u0027s a quirk and one of the advantages of the bi-directional stream thing is that every packet that you receive every frame that you receive you know which one it belongs to when you receive it super okay yeah cool actually sorry this is dkg just to clarify I may have misunderstood the poll request here but I believe it actually allows many to many not just many to one oh and I might be you I think you\u0027re right so John and Martin you\u0027re distracting from I think I think you\u0027re right yeah so I think it\u0027s significantly more complex and confusing and it makes me that makes me nervous yes it is definitely as yes it\u0027s fairly complex but thank you for noting that I know my need a menu correct Martin oh it\u0027s easy enough to pull as much of that out as we need just they were and there were four bits might as well define it if we think we might use it yeah that was one of the features that I really really didn\u0027t like so it\u0027s like many dominions can undefined them my wheat brain exploded when I saw that all right last slide server crushes rare at least in my experience it\u0027s well less than 1% responses maybe deep larger experiences but it\u0027s it\u0027s like at this point the optimization is just like not really a critical optimization for HTTP Sigma the current draft is an option if we if we can\u0027t reach a clear direction forward on anything else it does work as I said before only plain bi-directional streams actually have implementation and deployment so it\u0027s possible this is something to revisit when people have more running code and finally quartz which is quick Webber to see over quick not quick clover Webber to see you thank God uses dreams in a unidirectional way pretty abusively and the link is on there for the code but it should provide us with actual real deployment experience in the relatively near future of an application that uses "
  },
  {
    "startTime": "01:06:27",
    "text": "a lot of unidirectional streams so okay anyway thank you in that\u0027s it yes okay so we\u0027ve got 20 minutes unless we want to start eating to our presentations to figure this out from my standpoint and I think from our standpoint we\u0027ve talked about this a few times and in those discussions we\u0027ve kind of said that we need to make this decision relatively soon if it\u0027s going to happen the longer we wait to do this the harder it is going to be for people to rip it out of our code they\u0027re gonna know build abstractions and build api\u0027s and build applications based upon the current approach or whatever approach we check so there\u0027s a certain amount of pressure on us to figure this out the only other thing I\u0027ll say is is that we\u0027re seeing a couple times on the list and here it being inserted we have deployment experience with one thing deployment we don\u0027t have a deployment experience with another thing all I would say to that is in a sense that\u0027s true and that we have deployment experience with TCP and I think that\u0027s we\u0027re modeling a lot of what the Carn approach on the deployment experience of quic is something that the whole working group doesn\u0027t have a one or two members of it have so don\u0027t personally and this is not really with a chair head on but personally I don\u0027t rely on that completely you know we need experience as a group to make decisions not just from one or two implementers but I do see the TCP is a precedent there that that is something we can so what\u0027s figured out Christian Rita mom I\u0027m going to speak there on these idea of having a mapping layer inside the transport and I have a good reason to not want to do it the good reason is to the analysis of what it takes to Deanna\u0027s push which is a subscribe notify kind of model and it\u0027s just that it\u0027s not just a question of mapping application transaction to streams but we need an application model in that case to make sure that we have the right sequencing of application messages sent on multiple streams I mean they are like mashallah other enforcement\u0027s and says like that and and if we add a minute I could map that to either a be directional model or unidirectional model but I would was or not have to fight with a predefined mapping at the transport layer Tommy Polly Apple so my inclination would be to stick with something that can at least above the transport layer provide a simple way to do by directionality since that is going to be "
  },
  {
    "startTime": "01:09:27",
    "text": "such common pattern in applications whether or not this is done by implementing the transport layer as unidirectional that is bound or as truly bi-directional in which you have the thin to close it I don\u0027t think matters quite as much to me but a kind of wild west of unidirectional seems problematic my main concern is that as we are focusing on HTTP now which is great but we want to use this for more things and as we go ahead with that everyone\u0027s going to have to come up with their own mapping in that case and it\u0027s much more likely to get it wrong or add unnecessary levels of complexity there to the API point even over TCP we do have experience with api\u0027s that expose the reading right side of it as like separate streams versus a fully bound connection and at least in the experience I\u0027ve had trying to manage these separate stream objects actually ends up making things much more complex for the application because now they have two separate sets of state to deal with as opposed to having a notion of a strong request reply which is usually a better abstraction for them so I think you can build anything you need with bi-directional that you just immediately close if you want to do fancy things like unidirectional you can do that but it\u0027s just going to be such a common abstraction due to bi-directional I don\u0027t see the benefit of really breaking out from that now thank you cuz with all cool possibly regarding which approach to choose I\u0027m afraid of the complexity or the any direction on the only approach I think that the cost of BYOB I mean build your own personal approach carry founding the changes that are required to the HTTP mapping I mean the existence of the cancel request frame as a request is a frame for cancelling a request after a stream that has that was having clothes with a directional only approach a way to transmit such a kind such kind of frame becomes a must for any request/response application protocol in other words if we adopt the injection I\u0027ll only approach every request response protocol that will be built on top of quick either needs to defy its own control string or refrain from using thing to indicate the end of the request I don\u0027t think that we should have such a requirement for every application protocol even though it\u0027s not problematic for HTTP since we have other needs for upholstery Thank You co-partner yeah I just wanted to respond to Christian part of the point of this one here was to it was it was in reaction to those people who thought that the transport needed to buy the bi-directional primitive and for those people that wanted to provide their Bible written by directional primitive in their api\u0027s this would allow that to be to be both "
  },
  {
    "startTime": "01:12:27",
    "text": "relatively trivially it\u0027s not a lot of not a lot of complexity it\u0027s I believe that it\u0027s actually strictly less complex than the unidirectional one because it makes a good point regarding the cancel request thing I hadn\u0027t considered that at all however I think we need that anyway for other reasons but primarily that\u0027s the push thing that we were talking about doing anyway I have a question what can i clarify why do you think it\u0027s less complex because fundamentally you\u0027re just building on top of the the unil thing and it\u0027s it\u0027s there come in to the extent that it has complexity it\u0027s emerging complexity and and it is because you\u0027re providing fundamentally simpler building blocks that are more capable and you can you can build more complexity with it but equally if you want to and I would suggest that most people building one of these things would probably do this is that you would do the absolute simple possible thing you would either provide a you send messages one way and you send messages the other way as an API or you would provide a please make me a stream that is bi-directional as API and you can do both of those things relatively easily with this sort of thing and so I think from a both implementation perspective and a usage perspective it is simpler the fact that you can go too many to one is such as is a complexity that you gain but it\u0027s not necessarily complexity you have to take it\u0027s optional okay and the reason I ask is because both of the PRS when you stack them are like over 400 extra lines and so I don\u0027t know how much of that is due to some features we need to work out and now that is mainly editorial and I think that when you look at your proposal to add the extra bit there was a there were a number of things there that I didn\u0027t really push on very much yeah we need to like there\u0027s implications throughout and I actually went through and did an extremely thorough pass of both of like all of the documents and found that there were a lot of inconsistencies in the way that we treated the state of streams and I fixed a lot of those in the process and so what you\u0027re seeing is editorial collateral in those things more than anything else and so when it\u0027s 400 lines I wouldn\u0027t read too much into that no I think the core question here is whether something like cancel request is too costly and I think we discussed this briefly but the the idea of assigning a different identifier to two pushes and having that sort of identified independent of the stream identifiers was a valuable thing and we probably want to pursue that anyway and then we lead into the cancel request thing as a natural consequence of that so just just saying that some of the "
  },
  {
    "startTime": "01:15:30",
    "text": "complexity here is is is stuff that we\u0027re we have to take on anyway it\u0027s just a consequence of you know the way the documents are structured and whatnot that you\u0027re seeing that they look somewhat large you\u0027ve got a pretty deep queue so try and keep it brief folks I suppose that you are so I\u0027ve had some experience implementing the bi-directional stream API by dorsal stream at start for the transport some one of the complex things that during the implementation was the half flow state so initially when Martin proposed the pure unidirectional stream I was very drawn to it because there\u0027s no half closed date anymore but the more I thought about it and discussed with some co-workers is that you can actually model even a bi-directional transport with do you need directional state machines and it gets most of the way there and I\u0027d rather take on the complexity of implementing all that than like shoving complexity packing the applications which have to and your complexity is now split between two places so in that case I am I favor either the do-nothing approach so that\u0027s I don\u0027t mind sending the extra Finn but it\u0027s there\u0027s no extra RTP is incurred by that it\u0027s just awkward or the app directed close approach so something that was brought up during the during in the mailing list was that one enable generic application for proxies to be built but I think that that\u0027s a use case that I don\u0027t know whether we should be thinking about because we\u0027re building quick as an integrated TLS HTTP transport and it is inherently integrated with the application and that\u0027s where most of the performance advantages of quick do come from so layering in an artificial way seems counterintuitive the design goals of quick to build an integrated transport that being said I agree with some of the proposals some of the things have added to the unidirectional streams were kind of very unique stream correlators and stuff with that I would like to see that in the HP mapping and cancel it request as a as a substitute for disinterest or something about that that would be much better to do those disinterest things in the application there I could talk about more all fine Carola one second we\u0027re gonna close the mic lines pretty seen the back finished just in case the queues closed there you guys I\u0027ll just filibuster that\u0027s okay yeah I\u0027ll just at 201 minutes 50 seconds your honor remark try to keep me up and so first let us not use Mac of changeset as a proxy for complexity molest people behind to produce change that\u0027s reserved the incentivize appreciations are far less completely necessary in an attempt to make their thing if you\u0027re less complex so you know at that the half-closed thing is a total disaster everywhere we have to do it so like suppoed I was initially extremely "
  },
  {
    "startTime": "01:18:32",
    "text": "drawn to you directional only which completely eliminates the helped us having to mess around with that crap unfortunately I think it is the case that complications are going to desire some kind of thing and so either you know either we\u0027re gonna need a vertical or a needed convention and if I\u0027m in a circle convention store clerk a lot like a protocol so um with that I think that uh but said I think it\u0027s pretty clear unidirectional is a more fundamental design primitive rather than bi-directional so um I think on balance we should be providing a layer that builds you bi-directional top unidirectional I\u0027m I\u0027m pretty unmoved by the deployment experience argument in this case the you know it this is this is a programming concept um it\u0027s not one that is a matter of having huge amounts of scale so you know I mean certainly we have plenty experience we\u0027re trying to map you actually have a by direction that is a mess so you know I can understand people saying oh I like to see implementation of this I think that\u0027s not an unreasonable request but I don\u0027t think that like we have to have you know five years depending experience is like a possible arguing for this change okay but I should have clarified that none of the last three options have either implementations law deployments I agree with that and I think it wouldn\u0027t be unreasonable to say that you like that a further decision until we have Malaysian experience I don\u0027t think it was more the way to say fix it on the importation experience we should sigh for one way I friend trauma let me add to the course of people saying I intended to come up here to say unidirectional is all you get beginning and I\u0027m actually kind of convinced that we need to do something where you have permanent unidirectional underneath and something bi-directional on top to keep applications around me would do it themselves it seems like sort of the way to go I so yeah I agree with a vote I completely disagree this framing I think that if if we basically say that quick is just for http/2 um so um then we are likely to make reasoning a little bit further down here that\u0027s going to be hard to pull ourselves back out of I would point out that we do have a lot a lot some experience with hacking unidirectional protocols on top of I directional streams anyway IP fix is a very good example of this uses it was designed for UDP unidirectional only and then it went a is G and they say congestion control and then for like uh or transport people you have no idea with it um and you basically huh please continue right it\u0027s Friday shit there what my train of thought oh so yeah I mean so basically you have you know a fundamentally bi-directional thing you\u0027re running things on top of you right on top of and usually what people have done there is okay well I\u0027m going to open a full bi-directional scream I\u0027m just gonna use one half of it right and I don\u0027t really care about the fin at the end rate so having a there but there are other ways that you could do that right you could also say okay I\u0027m actually gonna go to half closed and maybe one application will say okay well half closed means that I\u0027m going to tear everything all the way down and the other gratification says no I have to think open so really "
  },
  {
    "startTime": "01:21:32",
    "text": "we need a way to keep applications from doing this on their own that we haven\u0027t reviewed from implementation experience of inter directional applications over bidirectional flows I don\u0027t know if that was useful so I\u0027m gonna sit down now it was thank you Brian um Jen I ain\u0027t got just a couple of quick thoughts one I I didn\u0027t want to say that there\u0027s in the unidirectional stream here that is actually one idea which I like quite a bit the correlator for the push streams is actually quite a neat idea and I would like to see that separated as a PR and not just like bundled with all of this but I think that\u0027s a really cool idea that we should use no matter which way we go but in general I wanted to say that there\u0027s there\u0027s as other folks have noted before me transports transports generally build common design patterns into them this is not just for quick it has traditionally been the case SCTP did the same thing the whole idea of offering an API is to build things that the simplest transport would be UDP of course it is technically a transport and the application could do everything some people might in fact call quick and application protocol the whole point here is that we are taking common design patterns from things that applications build and build them into a shared piece which we call the transport the chat piece is condition control its loss recovery its multi-streaming and as it turns out in the bi-directional streams is a common case that almost every application that I know uses directional streams are things that they may use with HTTP - we do see that to some degree it does use it and most appointments actually don\u0027t as he pointed out server push but bidirectionality is something that we really really should retain in the transport Cairo\u0027s rather than rehash all the previous arguments I just want to say it seems like we should optimize for the bi-directional case which is the common case and they definitely be so so I like the simplicity of the single bit approach I did have one question about the the many to one did we actually have an application that we intended for that that was Brad\u0027s question as well I don\u0027t know okay yeah business that did Martin do you maybe Martin has an application he invented for that or I mean let me sit from you yeah so Thomson the application that we have is HTTP does it make like the way that Age 2 works is its many-to-one no not necessarily saying that I would use that particular primitive build that in HTTP 2 because we\u0027ve particular requirements that mean that it it would be a better fit to do all of this at the application layer and we have the flexibility to do that so if Kyle is out I wanted to touch on a couple of points this builds on disinterest which was a "
  },
  {
    "startTime": "01:24:34",
    "text": "proposal that Mike put together and we haven\u0027t managed to close on but I think everyone basically agreed on that one which moves the bi-directional model a little closer to the interactional model but keeps keeps the bridging state what else was it oh yes Jana\u0027s plea I actually agree with and are convinced with that you could you could if you like consider the original unidirectional streams proposal as simply shifting the Overton Window but I\u0027ve Overton Window look it up in Wikipedia I\u0027ll explain later but I\u0027ve been convinced by the arguments about the transport needing to provide this common set the set of functionality I\u0027ll point out that we did bumped something off the presentation where China will be arguing for removing a common capability from the transport because the transport simply cannot actually reasonably understand the application semantics so in summation I think I would rather build up rather than build up then down and I prefer the the the binding way a1 I think that\u0027s that\u0027s where I met for this one simply because we get the primitives and then we build on top of those primitives rather than build a more complex primitive and then have to wind it back that\u0027s just my preference that\u0027s just the way I like to build things and I think that gives us the flexibility that we that we actually need and maybe we\u0027re not using an HTTP two because we actually need more complex things but because we have the simple thing we can build a more complex thing itself Carly you can if you want to say other than if we go with the layered approach where you start with you know directional and build by direct row on top of that it\u0027s almost like you\u0027re building two separate state machines and I don\u0027t know I like the simplicity of having the one state machine the overhead of sending a single bit along with the type saying you know just ignore the other direction and seems I don\u0027t it seems simpler to me we do matter all right thanks so we\u0027re eating into our presentation time officially now I think can we it does anyone want to advocate for any of the other and apologize if you already did and I missed it the other unidirectional proposals or can we consider this the unidirectional proposal on the table right now is that a fair assumption the binding layer one yes he\u0027s sorry it is a binding layer is it inaccurate there you want to clarify "
  },
  {
    "startTime": "01:27:38",
    "text": "yeah I think there\u0027s strong agreement that we need something in the transport the question is do we start with uni direction as the basic principle of by direction as a basic principle but that\u0027s a that\u0027s a good thank you yeah that might actually be something we can have more show of hands on I think so come yeah so how should we compose this hum if you do three three I would do I would do not enough information to make a decision or hum one and two oh okay just clarification are we humming on the proposals or have eme non-transient so the what should we start from I think Miriam made a nice suggestion now how very much yeah the problem though is that we have specific proposals attached to those principles we do so I don\u0027t know we separate those yeah it sort of a section we are it is and you can choose to view it as if you hum that you think we should start from bi-directional streams the implication is we\u0027re going to stay pretty much where we are but of course things will change as they are changing but that will be the basis that we\u0027re working on so let\u0027s do unidirectional then bi-directional then not I\u0027m frightened of not enough information yes oh yeah I think that information might be valuable I think there there our people in this room probably who have changed their opinion recently and/or have not liked riddled with tiaras early no kind of thought right I think it\u0027s probably worth so the first come is if you believe we should base the abstraction in quick on unidirectional streams the implication being that we may provide an additional abstraction on top of that okay it\u0027s not helping him rise that spring just look at the beach in relax occur it\u0027s all okay so please hum if you believe we should start on a basis of unidirectional streams and like Bishop and Java is also humming healthy healthy hum yeah pretty good please hum if you believe we should start from a basis of bi-directional strengths oh that was very close close provides a slight slight bias towards bi-directional slight hum if you don\u0027t know or you need more information or time to think or okay weird weird view in the jabber for bi-directional we had one in the Java for unidirectional just "
  },
  {
    "startTime": "01:30:38",
    "text": "for the minutes so maybe would be interesting to find from the folks who Humphrey in a directional whether it should be unidirectional only or with with the bi-directional abstraction on top of it we\u0027re not only from both in general so if we were to Joel if we would be directional so mark I would I would actually request that you instead ask anyone who thinks we should have unidirectional only to stand up and advocate for it because I don\u0027t think there\u0027s any of those people I suspect you\u0027re correct do we have anyone who wants dead became for unidirectional only okay so that seems to be clear then your wool okay I also want to make sure that it\u0027s clear that the bi-directional stream support 1 means that it\u0027s by directionality with the potential for unidirectional support which either a bit or with application-layer logic it\u0027s we are talking about similar abstraction and that\u0027s important or not even though it started by directionality it it can easily encompasses interdiction ID as a as a as an extension or as a case we already do it okay yeah I would state that I don\u0027t think a lot of people are very person ated about one or the other approach so that\u0027s good because that means we can find some agreement at some point I believe and I would propose to actually go and go into the details for both sides and and propose one proposal for both sites and figure out all the details and then make a decision so III did hear what other complaints about you know any of the irrational Steve Grove rules was that no one had tried to do it um so I\u0027m just going to try doing an implementation and mink by Seattle so that you know either I\u0027ll be able to report that I was wrong on idiot and it sucks or I\u0027ll be able to show that that can be done and if you want take a look and see how much they think but they think were themselves okay and that that\u0027s actually interesting if we can get some running code which implies that I think it\u0027s a pigeon it\u0027s on on to the proponents to come up with a proposal get an implementation together get some running coding and then report back I think that\u0027s I think it\u0027s reasonable to say even more than that I don\u0027t know it isn\u0027t reasonable to have that that code be kind of similar to your existing bi-directional implementation like so like in the same codebase or something one could code review yeah like we write it in rust I mean yeah okay that\u0027s great so that sounds like next steps I mean I guess I don\u0027t have a fully fleshed-out bi-directional thing yeah either but um I have enough to do I have enough to do this HT p09 things so I sure hope so so if you want to do I do it as a branch and I\u0027ll figure something out okay I "
  },
  {
    "startTime": "01:33:38",
    "text": "meant on the spec I\u0027m looking oh yeah for the back part as well as the code just the longer we go without you know making decision here the decision kind of becomes more difficult to change from the status quo so yeah so um I will make a pull request conveniently I have a unidirectional stream pull request that I can build on on the principle of unidirectional abhi first and I think that would be pretty straightforward let\u0027s close this off then is that Martin from that perspective is there anything else you\u0027d like to know from the room that would help you when you\u0027re going in that direction so um one thing that I was considering doing was pulling out the push ID thing that was in there if people object to that then I\u0027d like to know but I\u0027d like to sort of try to pull it out somehow and and make some progress on that that independently there\u0027s gonna muck things up though if we can\u0027t get that resolved so I\u0027d like a pretty clear signal that this is the right thing to do I\u0027m good I support that in at least um if anyone doesn\u0027t want that then please speak now because it\u0027s going to make it a whole lot more difficult with parallel changes for Bush IDs and rebasing and all that sort of other mess to get this to to works just making that clear oh and the other thing is I want this interest can we please have this interest if anyone doesn\u0027t wants to object to that then please state otherwise I want to have that in as well before we we start on this process because that one\u0027s kind of foundational as well on the bi-directional side okay one more question and both clarification is can we get an idea of people actually want many-to-one that was kind of seen as a I think a somewhat controversial pro and con do we do we think that no I don\u0027t think I think we can talk about later okay okay thank you we\u0027ll look forward to hearing back from you in Seattle then so next up we having tomorrow we are overtime high-five all right so we have the three presentations so if you could be is as quickly you can we\u0027d really appreciate it I\u0027ll try molesting I won\u0027t try my best and I hate my own boys quite like golf and okay I\u0027m bringing up should I bring up the presentation or it you\u0027ll bring it up on the screen we have it oh I\u0027m sorry we don\u0027t have it on the screen one moment yeah it\u0027s on my screen but that doesn\u0027t have coming the room okay great I know we can briefly go through the introduction I hope that most people around understand by now what the easiest and there was some discussion on the mailing list a couple of months ago and there was a an on button to make it "
  },
  {
    "startTime": "01:36:39",
    "text": "real quick is that it makes it possible for congestion notes tomorrow instead of discord packets and that we forget if you need more information there is a truckload of information out there one mystery one good ways to talk with oracy 3168 for instance and and also that what is more as more traction right now is that is a key component in low loss low latency was scalable he\u0027ll put that is subject to forced initiation in near the transport working group and the objective is to get these yen support in a quick already from the beginning and and the port is that implement necessary support fees and that new involves negotiation or capability exchange and the feedback port for it and this is a draft that is written but it\u0027s not quite natural that this will be a working group I it and because I\u0027m much much of the force will likely end up in in separately net for instance the other third loss recovery and the protocol drops that are already existing and we have heard some emissions in limited circle and people opinion who has been involved in that this or a listed below can take the next slide please and the outline of the drawers just the quick specific ports history Zn negotiation or capability sensing and and at least for now is sort of a suggested to be performed off their connections at top but that this can be subjective exchange and probably something that needs to be discussed in a work in loopy can he do it already at connections at top and then I said there is a description all the EC and feedback that now goes into AK friends and then it was important so that or less covered in a draft and it\u0027s more sort of text is a how to do monitoring and who I to do it and also some general fall back issues and over operating system socket specifics the there are sort of a more sort of an implementation specific divorce it\u0027s a Oh a circuit specifics ok next one and then here we have this negotiation capability sensing and full now it takes place all the connections set up a little the rationale right now is to boil it easy and failures delay the connections are top and it\u0027s no matter how unlikely a test and also for entities at will work that has been done and should to look at the how sensitive it is to run run his genic negotiation "
  },
  {
    "startTime": "01:39:39",
    "text": "for TCP and it seems like there is no there are no major issues with easier coming in the Asian bit serves at today and also algorithm work on color relying for this as to the door to our direction from this is the regional GCM work that is in TCP and working group but anyway it\u0027s at implementers at you of the TC n negotiation frame and for now that both peers and easily see a negotiation frame and they echo echo turn back and from from Dan from that exchange you cancel to determine if you can run he\u0027s young in one or both directions and there are some combination there but that needs to be clarified the IP header bits or the current if set to 1:1 but it could be for when the easier negotiation frames are transmitted the question is there should it be easy T 0 easy t1 that\u0027s it doctor one that could be more rational more reasonable to the he\u0027ll have them set to be ZT 1 or 0 okay we can\u0027t take the next slide the easy an echo is the implemented as a byte counter and it\u0027s sort of a rival length field that depending on how this easy to you easy T 0 is e t1 and see bits or more so we don\u0027t play in though in a minimum case if you don\u0027t have any more practice at all either non 0 C or there the overhead you get this one octet unless it\u0027s at the first bite here a no and it is possible in at least in theory to report easy and even the reason is not negotiated well for some reason would like to have it like that and the question is that at least on that also the recovery trough this toyline tossed in is a our Vice counted do we can\u0027t count the only the quick header or is it a quick toss UDP ahead nor is it also the IP eternally that this B doesn\u0027t need memory needs to us erase an issue in the tractor on oil I haven\u0027t done it yet but maybe somebody has done more a clear point of how he should be counted clarifying comment in the there was an issue opened and in the most recent recovery draft bytes in flight is explicitly defined a part employed that means including the UDP header or a quick header I believe it is it defined as including the quick header and not the UDP or IP header okay as long as you\u0027re clear on that one okay thanks Ingemar I\u0027ve a clarification "
  },
  {
    "startTime": "01:42:42",
    "text": "question as well um for it is there any value in tagging this information onto the AK header since I don\u0027t think you use anything in the actual AK header this could be a separate frame in this form right possibly I\u0027m okay filter that\u0027s the reason I would put it so if we put in any egg frame I wonder if it\u0027d actually be useful to have her AK block information about what was marked or you could even do something like the time stands and for the first 2056 report individual marks rather than just aggregate five levels I wonder if that would be interesting from a pedestrian flow standpoint but just a you know something to think about yeah we have the original I\u0027ve done more detailed information about exactly which easy and reach effective tour left for easy and marked in whichever way but you couldn\u0027t really find out any good reason to keep that detailed information but I am good I think for accurate easy and that might actually be useful though what you\u0027re pointing out the what large pointed out that would be useful for accurate is him but for for otherwise for easy and it\u0027s so just general 3168 this should be adequate and I agree that doing in a separate frame seems completely plausible I guess I recommend us if we wanna put this into the AK frame it would be useful to support this information as possible into the encoding rather than with just reporting aggregates right good because they can go into different frame type um it\u0027s especially if we can encode it in a very lightweight it doesn\u0027t react very much longer yeah I agree with that let\u0027s continue okay that may be something that needs to be more on how which is alternate is the best and I believe on both of them positive to almost a new way of implementing it and as soon as as long as we have ACN support in some way so it\u0027s nothing okay we can take the next slide up don\u0027t breathe air is much okay there were other the Andes monitoring and it can be useful for indication of all that do not implement easy and support correctly and now River we have a Yeol\u0027s always see sort of a real life issues that that doesn\u0027t only deal with this young loss it could be the fact of tourism mysteriously dropped in the network and here is we had an extra element of uncertainty on that easy and more tech in various ways can be sort of dropped and can be removed and the "
  },
  {
    "startTime": "01:45:42",
    "text": "details are to be find and also how it did you easy and fall detection fall back and it sort of a different sort of alternative that they can tell you them and large part is that the operating stock get specifics it that my question is of course here that should a quick working group deal with that or is it something that should be left up to implementation it\u0027s very separate roles needed to live cover it is summer last point I think this is not in scope for quick but um the draft or or a document might talk about what is required from the operating system to actually implement this like access to the bits right yeah okay thanks to the next slide yeah and the way forward is that suggestion why is that there is to that easy and aggravation and easy and a co2 during the transport draft and easy and classic contains a quick recovery because there is also I believe is a student that you that Rena is used and Rankin a dexterous or Torah so tiller till the corner whatever to the quick recovery draw recovery is young as well then we have e ZN j l4 s handling and at the end we\u0027re still total work in progress it\u0027s probably too early to bring l4 s handing into the drafts and but maybe some kind of spray shoulders to Toto keep the door open uh and avoid that your misuse of the ECT one code point for instance how do you that\u0027s about theater no no it further mercenaries yeah I questions I got them at all which welcome there we few minutes for discussion one sort of Kenny go back one slide mark so one comment from me would be that if we want to do this I think these negotiation and and the reporting what we need a nail down first so that we have a stable wire format that how it applies in draft recovery and whether it\u0027s classic handling or or something better name I think it\u0027s further off and I think l4 s specifically is it\u0027s pretty far off stilton\u0027s transport CSV WG doesn\u0027t even quite know what that\u0027s going to look like and how it\u0027s gonna hit them know so if we do this I would really focus on the on the first bullet here Corey thanks last gory fares and TS vwg share in this case and I think the the key thing is exactly as last said so I give it last let\u0027s pin down whether we\u0027re "
  },
  {
    "startTime": "01:48:42",
    "text": "sending ACN on the wire let\u0027s pin the basic feedback let\u0027s make sure ECT one is TC 0 are different and let\u0027s avoid defining a new vcn reaction here and other groups are doing that TCP and got some active work TSP WG has active work on the algorithm for how to respond but the feedback friends or whether it goes on the wire image are absolutely things that I think are important to consider here sto Cheshire Apple I expect many of you know that I\u0027m a big proponent of ezn and listening to this I was thinking why negotiate it at all why not just specify that we use easy an and and I realized the answer to that question is actually not the network itself I think Apple has done a good job flushing out all the cobwebs but the OSAP eyes are an issue that and we don\u0027t the situation where some of the implements quick on a device where the API doesn\u0027t let you get at the seee bits and then we just end up with a misbehaving een klein that\u0027s ignoring the mark so unfortunately we do need to make sure that the receiver signal to the other end I can\u0027t do this correct so Tom\u0027s comment the ability to separate this into separate frames means that we can incremental implement this though I do see Lars point about the integration with the timing and whatever else if there is an optimization there I think perhaps we want to talk about making that optional or thinking very very hard about whether we integrate it tightly with without frames or something like that because it\u0027s going to make our already difficult implementation tasks that much more difficult and add frames are a nightmare as they are and this really only makes them worse Jen I ain\u0027t got a I disagree I think that if but actually maybe not no I I think that if it can be done if it can be compressed into the a frame it\u0027d be much better because going into the future we are TCP MTS vwg they\u0027re all looking at proposals that actually look at more detail the easier information this is what I meant back here at ecn and if we can put this information to the AG frame it obviates the need for revisiting this framing again later so I think it\u0027s useful to be able to do that I do have a question about the the the current state of affairs do you know which Inga Medina which operating systems currently support the API to "
  },
  {
    "startTime": "01:51:42",
    "text": "expose sieep it\u0027s up into user space and allow for the application to write can do yeah yeah I don\u0027t have all the details and look too much into it myself but uh appear so handled you know quite extensive sir wave into it year is over back and it can probably changed on there I don\u0027t tell the details unfortunately that may be useful to actually document in the draft we\u0027re eight we have to cut the cue now so quick and metric we\u0027re not gonna get to any of the other presentations related work very sorry but I think this is we want to let this run because we might want to take a home at the end whether we want to see PRS for this first part I agree with John or maybe disagree I more seriously um I I think I would really rather see this in a separate frame as Martin said the iframe was already like he\u0027s they were complicated the other thing is you know in the service of some notion of later hey you know what might imagine running quick over a network trick don\u0027t have IP and don\u0027t have ecn and like saying this is an integral part of like the system just seems like goofy in terms of layering you know if at the point where we think this is like essential on bait we can invent a new act rate and it is important to put them in a frame we can invent a new act frame which you know which generates them properly when they did well understood and you know when this problem is actually well understood I mean the notion of hanging is that some protocols you could those kinds of things so I think in most cases no matter if you have in the ex frame or in a separate frame you can find a way to cover the case where you don\u0027t have easy and supporting we have like no overhead like it could even find 2x times one without and one with easy in well like oh like if you have it in separate frame the concern was that you don\u0027t get enough timing information but then you can decide how often you send the separate frame and then you also get this kind of information so you can you can do both of those things with both approaches the difference is like how much is the overhead and I think we can actually do some more analysis and going so those approaches and then making a solution but how much markings you get how much does you get and then actually calculate a number how much over it it worked in overhead it would be in those situations Kunis Kepler I read that we should focus on the wire protocol and that we should make that wire protocol as simple as possible and and the focus is on showing what the application can see as the received packets in the IP header and echo that state to the sender "
  },
  {
    "startTime": "01:54:45",
    "text": "so if that is fixed we can build the dynamics or units in the sender only and so this protocol should be as simple as possible to implement by the receiver it should take as less as header room in the AK frame and well in that case it should also be mandatory I think on every AK probably so it\u0027s probably best to fit it inside the egg frame and not spend another header or or room in an extra separate energy okay okay thank you so my suggestion would be that we do quick hum and and the hum would basically we understand whether we should devote working group time to ecn going forward or not right and not doesn\u0027t mean we don\u0027t ever do easy and it means we revisited a later phase at a later time um in diverting time towards it doesn\u0027t mean it\u0027s a sure thing no devoting time means that we talk more about it now Gouri clarification question are we talking about just including the possibility of supporting it and not necessarily going in the algorithms or are we talking about the two together so it\u0027s all I think so personally I think them if we do this the most important thing is understanding whether the integration of the signaling information where the act frame is required for efficiency or whether it can be efficiently done in a separate frame type if it can be efficiently done the separate frame type that is nice because it decouples the tool right if they need to be coupled together because otherwise you will duplicate a lot of information that\u0027s already in the air-crane right um that would you know make implementations much more complex but so I don\u0027t know if it\u0027s required right I mean if we do this I think this would be what I would like to see analyzed first right whether there\u0027s efficiency reasons for having the easy end information in the egg frame I hope the answer is no but I don\u0027t know all right so that that that but it\u0027s actually step two step one is does the working group actually will think that ezn is something that we need to begin devoting time to going forward I think starting I got an answer to my clarification question okay thank you it\u0027s just a clarification question okay okay because we\u0027re almost out of time right so let\u0027s do this this how do you if you believe that the working group should start to devote some time to easy end starting tomorrow please hammer all right if you believe "
  },
  {
    "startTime": "01:57:49",
    "text": "this is not necessary at this time please hum okay I will summarize this has pretty strong consensus for devoting time to easy end going forward while on strong interest in yeah consensus assumption I\u0027d encourage those people who hummed against to take this to the list it seemed like the hottest among the concerns maybe obviously we\u0027re gonna spend a little bit of time beating on this to get it into shape so they\u0027ve integrated into the drive so I\u0027m not concerned about that we need to understand those concerns before we sink a lot of effort into into that integration so that we can deal with that so that\u0027s fine and I don\u0027t think this is something that is blocking our other discussions or that we should divert resources from I think that I would give sort of the East End proponents maybe some homework assignment and specifically to think about two different options right one having easy end in quick in a way that is its own frame types and if that is if there\u0027s some significant disadvantages to that approach to you know discuss them and and come up with an alternative that would be significantly better by for example integrating information with the AK frame but I think personally I would really prefer if we could you know we have frame times let\u0027s use them right so Jenna anger just a quick note that something that\u0027s important I think here is the ability to actually use this in real implementations right now as it stands most operating systems do not offer an API that can be used to actually do ezn so we can choose to spend time on this right now but bear in mind that it\u0027s not it\u0027s gonna be hard to actually use this in the real world at the moment agreed which means that interoperability testing will suffer I didn\u0027t catch your acoustic wave which means that you know testing will suffer interrupt testing will suffer or you get the last word yeah cool gory fast and yeah and the first thing to decide actually is why do we want ecn in the framework and that\u0027s going to inform that whether the wiring should allow it setting those bits on the wire whether it\u0027s possible and yeah okay and I\u0027m not I\u0027m talk because I realize it\u0027s time to leave all right thank you all very much we will see some of you and see yeah and many more of you in Singapore Isis I think we if we don\u0027t have the doodle registration doodle live yet it\u0027ll be live soon and I\u0027ll send an email to the I in his life which it is no Center aligned right registering for Seattle if you plan on coming because I\u0027m sure Martin Duke would like to have some accurate numbers soon for how much coffee he needs to buy yeah thank you Ingemar thank you thank you "
  }
]