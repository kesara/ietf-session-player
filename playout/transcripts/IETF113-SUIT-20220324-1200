[
  {
    "startTime": "00:00:08",
    "text": "yeah exactly that's true so david or do one of you guys want to try sharing i'm fine with what you're doing nancy dang i think dave went [Laughter] we have the advantage they got masks on we've only got an hour and i have it right at time right now do we want to go ahead and get started yeah we really do need to start because uh there's a very very full agenda uh you've got a few people here in the room by the way i know they they look like dots but it looks like five or six people from here no you you've got about double that oh good all right let's go ahead and get started um welcome to suit we have a very very full agenda today um and so we want to start on time with a hope of therefore ending on time so next slide please just a reminder of the note well given it's thursday you've probably seen this a lot but if you're going to contribute please make sure you're aware of what your obligations are next slide so we have some administrative tasks and i don't believe we have somebody agreeing to take notes in cody md could we have a volunteer please"
  },
  {
    "startTime": "00:02:08",
    "text": "we need volunteers to be notetakers well we really can't proceed without this well in the interest of time i'm happy to be a backup yeah brendan you're you're a presenter you're not it no bren brendan's off the hook okay mike jenkins volunteered thank you mike second one uh dave and i will watch as well so awesome that'll get us there thank you next slide so this is page one of the agenda which is basically hackathon report suit manifest and how it has been broken up and then firmware encryption next slide and then suit report and then suit related claims and then mud which we just got added to the charter so that's the intended sequence of events are there anybody who wants to bash the agenda no one in the queue here nope i'm not seeing anyone i don't see anyone chatting so all right brendan we're going to turn it over to you to explain what's going on with the suit manifest the the hackathon summary so before we go into the slides was there anybody that wanted to report at the mic about things happening at the hackathon"
  },
  {
    "startTime": "00:04:02",
    "text": "which one goes first uh suit manifest go ahead hi this is honest um just because of the hackathon um yeah it was um i was there at the hackathon like many of the folks in like who obviously remote or many people couldn't come to this idf meeting who are typically participating at the hackathon which was unfortunate so i've been working on the firmware encryption and i'm um i i'm going to talk about that a little bit later so i think i think it was uh we had about i would say 100 people maybe at the hackathon uh so it was well attended um like um relative to to where we are today with the restart of the face-to-face meetings uh so it's really good but uh different experience than then we had uh pre-copied so hopefully next time um we'll get folks to participate in in philadelphia at uh in a bigger setup again see it's getting cranky i'm trying to share okay uh brendan's up next with suit manifest there we go okay um so this is the suit manifest draft um as you can see it's still version 16 that means it hasn't changed since 112. uh next slide please that doesn't mean we don't have any open issues the primary open issues that we have today are mti algorithms and crypto"
  },
  {
    "startTime": "00:06:02",
    "text": "agility next slide please so um it really makes sense to me that we should have some kind of pqc mandatory to implement algorithm but the question is what does that actually mean does that mean that authors are required to support pqc or bootloaders or update clients or all of them um i guess at minimum it seems that authors should be required to support pqc next slide please so uh there are a number of ways now the one that we've discussed really is uh hss lms now we have a research paper uh which is linked at the bottom there um which has some details on exactly how this would be configured and what kind of implications it has so uh comparing ecdsa to hss lms with the parameters that were selected for that particular research paper we see two fifths verification time and 74 times the signature size one and a half times the stack size double the code size and i think that the key question here is whether a 74 times signature size is acceptable um this is four kilobytes just for putting a concrete number on it um there's another parameterization obviously uh where we could do the w8 parameter rather than the w4 that drops the signature size to i think 1280 bytes um but i'm expecting a much higher verification time because there's a lot more hashes that have to be done so the question is can we realistically expect this from bootloaders and i'm not sure there's a clear-cut answer on that it may be that we have to specify that"
  },
  {
    "startTime": "00:08:00",
    "text": "this is only a requirement for update clients i'm not sure next slide please um there is an alternative uh falcon 512 actually looks pretty good um it doesn't have the same kind of key management overhead uh the signature size is smaller than all of the hss lms implementations and it is incredibly fast um it does require a fair bit of ram around four kilobytes based on the aforementioned research paper the real issue is the code size which is looking at about 57 kilobytes just to implement that one signature algorithm and it's not yet accepted by nist though it is in the final round so there's a possibility there maybe someone will come up with a better code size implementation i don't know i'm not sure what's driving that next slide please the next question is crypto agility now that's quite plausible for update clients um within the uh the constraint that they will have to over specify hardware or implementers will have to over specify hardware and essentially be planning for this from the get-go um however it's not plausible to have crypto agility in a non-updatable code so how do we handle stage zero boot loaders um is that just a different requirement um we we need to essentially say where our crypto agility mandate ends um and i guess the final question is do we advocate for dual signature the idea there is that you use a classical signature algorithm for the bootloader but you use uh pqc algorithm for the update client itself next slide please that's the last line i think that's it yeah that's it so uh discussion"
  },
  {
    "startTime": "00:10:09",
    "text": "david brown am i on yes all right so i guess the only comment i would make about something like 57 kilobytes of code is like several times larger than npu boot is currently and that's not going to work for i mean we can declare something as mandatory but realistically they're going to be config options and people won't select them if they aren't going to fit in their device so i kind of wonder what mandatory is going to realistically mean yeah you're absolutely right david and that's exactly what i'm trying to highlight here is that when we talk about mandatory to implement in the bootloader we need to be really clear on whether it's even plausible in the first place so brandon i had a question about that that code was that a verify only implementation because i would expect that to get much smaller sorry uh which code um the code size is that for generating signatures or validating signatures or both sorry i i appreciate that the question was are you talking about the falcon or the hss lms i'd be interested in both but um um well on that one if if he's on the call i will defer to either or emmanuel since it was their research paper that i pulled this out of go ahead a manual and then harness i yeah emmanuel here um so uh yeah it's it's it's for both uh signing and"
  },
  {
    "startTime": "00:12:00",
    "text": "and uh verifying and so uh we definitely uh you know these are our numbers we got with a an implementation that we made as much as possible uh embedded friendly but there are probably ways to improve that and we're actually working on that right now we don't have the results for that but i expect we can i mean as russ said we can do slightly better uh there are some stuff which i think won't get better like the signature sides and things like that uh but it might be that uh and there are like more embedded friendly implementation out there how how much more friendly that is gonna be i don't know uh but um russ is right that there's probably like some some some level of improvement that's possible here okay that's that's good information um my my understanding from having looked at this a bit before was that that um that 57k in particular seemed very large compared to what i saw on the um on the site uh the falcon sign site and i thought that it was possible to do smaller than that but i i took you at your word so i'd be like very interested to hear what the verify only sizes look like yes me as well go ahead hollis hi yeah i um i wonder whether it's possible to get away without specifying a mandatory to implement in this case because as friends said like there are different pieces in this um or software components in this whole um sort of picture you have obviously the stage zero bootloader or the like the the one that is kind of the the root of trust and uh that's one thing but then you have um maybe other stages um you know in a more"
  },
  {
    "startTime": "00:14:01",
    "text": "complex system you also have uh the update client which which also has some some code in there and and of course it will depend a little bit on on the specific deployment case uh like how long these devices are supposed to be out in the field and so how can we make generic recommendations um given that the this competition also hasn't been completed yet and so on and so on so like do we really need to sort of like can't we table that and maybe have um profiles later on for example say a specific deployment um sort of setup that has uh let's say a combination of different stages of bootloaders and firmware update client and so on and have have for those a recommendation versus something that is um sort of very simplistic short-lived etc or shorter lift a different um sort of story hannah it's just a clarifying question are you suggesting that maybe we treat this in security considerations then leave it up to additional work yeah maybe to do more or less describe the challenge that someone deploying a firmware update mechanism has to go through like they have to um sort of figure out for themselves on like how long are my devices going to be out in the field um is uh post quantum sort of the post the emergence of these computers um is that a problem for me or do i consider it an important how how much space do i have for the device and so on and so on do i need encryption uh for my firmware etc etc like or how is my whole software architecture sort of laid out"
  },
  {
    "startTime": "00:16:00",
    "text": "so i'm going to jump in and respond to that since nobody else is in queue right now my prediction would be that um if i were to look into a crystal ball that uh it might not pass uh iesg review if it didn't actually have you know mandatory to implement stuff because you would not have an interoperable spec per say if you required a uh profile that didn't exist in our fc forum to actually uh interoperate and so i'm not sure that it would actually save us any time to the rfc process to try to split it out it's a good question you're making me think about it but that's my guess right now go ahead emmanuel yes so uh i think that this question was raised uh because uh we wanted to make uh lms mandatory to implement right where there are like some questions about like is is that like today uh something that people are going to be able to do um and so so the question is not like uh do we want to have nti uh or not it's like what do we put into it yeah right now i think that was the discussion and we observed that we had this post-quantum hm hss lms opportunity which would allow us to have a transition to other algorithms under the protection of a post-quantum safe algorithm so yes it's a huge signature but firmware loads are usually not small in there in the first place so this is a place where you could amaterize a large signature i'm surprised about the code size okay i think we need to continue this on the list"
  },
  {
    "startTime": "00:18:00",
    "text": "oh we have a new new person thank you go ahead so uh we i just wanted to relay we had a few other points of concern about the hss lms uh one of them is that since it is not uh part of any of the like big standardized libraries there is a greater risk that we don't know when we use it whether it will have support whether security issues will be will be handled and fixed in the future and also that sorry i'm blanking well that's at least one of them but um uh yeah i i couldn't remember sorry go ahead thank you brandon i just wanted to respond to the comment that firmware loads are huge uh while that may be the case for a full image update uh that does ignore that it's absolutely possible to do differential updates that are small and it's also possible to do uh small asset updates that aren't the entire firmware image so i i don't think it's fair to say that amortizing a kilobyte or four kilobytes of uh signature size across a firmware load is necessarily going to get lost in the noise i think that very much depends on the use case and on um on exactly what kind of compression you're using and just to put some concrete numbers on this the energy that it takes to transmit a byte of firmware over a lora network is i think on the order of 80 times the amount of energy"
  },
  {
    "startTime": "00:20:02",
    "text": "that it takes to write it to flash so when it comes to saving energy on low power uh remote nodes the firmware size is absolute like over the wire is absolutely crucial good point um i think emmanuel's next and then thomas yeah so um i wanted to uh also um violently agree with uh with brandon here uh we detail like different different cases uh in this um uh paper that uh um brendan was uh was citing uh where you see the impact of something like lms in terms of signature size uh on on the data you need to transmit over the network depending on what you're actually updating obviously and there are different sizes indeed where where 4k is a lot that said so we um we are working on a uh improved implementation of lms um with our colleagues uh at interior who are crypto specialists um and uh so we are we're going to follow up on this on this paper with um with some more work uh and hopefully we can actually bring some of these some of these numbers down not the signature size but others at least uh that's that's our hope and so uh stay tuned on this and we'll get back as soon as we can on this thanks thank you hollis yeah i wonder um we wanted to finalize the suit um specification and manufacture specification rather soon so i wonder like what are really realistically the options uh besides hssm lms um because i don't think it would be it"
  },
  {
    "startTime": "00:22:01",
    "text": "would be wise to pick something that uh from the nist competition which hasn't been finalized yet let alone that obviously there's even less code available um so that may be maybe a little bit of a unfortunate uh um situation in the end i think that the choices are kind of limited right it sounds to me like we have a timing problem here right that there's desire to make hhs lms work but um we haven't had enough time for implementation to kind of catch up um one of the things that we did in ipsec me you know was we had a separate um algorithm draft that we would work on um and update over time and we use things like must minus or should plus um as a way to signal a desire to advance or or retract um specific algorithms over time as a way to kind of signal to the implementation base um the direction that the standard was going um maybe we could do something like that here as a way to you know to break the logjam any thoughts on that um no thoughts on that sorry i just want to update uh on the local numbers okay so if there's anyone who wants to respond to uh what we just said uh the please go ahead first"
  },
  {
    "startTime": "00:24:05",
    "text": "so you say 10k for falcon verification did you look at hms uh hss lms um so what i just did uh to get the numbers was quickly take the benchmark the test application we have for falcon comment out anything that's related to key generation and signing and wrap the numbers from the elf file uh that take up the falcon bits and that's around 10k so that's for falcon probably what you have to work with for this implementation if you want to have the bootloader added thank you topple yeah i can get your numbers for hss lms but that takes around a similar amount of time for me to get those okay thank you okay harness um yeah i like i like the idea that david just raised but the problem is it sounds like a little bit to what um dave taylor was previously referring to because we basically then have no mdi in the manifest specification move that the separate algorithm draft but then presumably um they would have to go together right while there is a benefit of having the ability to update um that algorithm draft independently without sort of revising the manifest specification which has um is attractive to me but i think it will not uh sort of like really um allow us to get us off the hook of the question of what mti is because even so i haven't looked at that ipsec but presumably it also has an mdi version in there"
  },
  {
    "startTime": "00:26:00",
    "text": "right this has been done for lots of protocols to separate the algorithms out just so they can be revved over time without changing the protocol spec s mime ipsec um tls lots of them do it but the tls doesn't registry with the recommended not recommended thing yeah now i i like that idea um but uh even even then like would it make sense to let's say um have ecdsa india as uh for example currently as the must and uh i've recommended or should for hss lms uh and then as we make progress and say okay we can get the code size down and we can do all sorts of other investigations uh we be revisit that that document and then uh maybe make some other recommendations is that sort of the idea david the idea and that would allow implementations to catch up and we can make better decisions you know at some time down the road okay yeah i like that if anyone thinks that's a bad idea please put something in the chat or come to the mic brendan morin here so i think that honestly the direction we're gonna have to go here is to specify an mta mti for update but not specify anything for boot"
  },
  {
    "startTime": "00:28:02",
    "text": "that could still be done as uh as dave suggested by putting it in a separate document that's a normative reference that's easier to change without ever changing the base spec yeah fair enough i guess what i'm trying to say here is that uh boot loaders can end up being so application specific that if we are too normative about what the boot does all that means is that this will not get used in a bootloader and will inflate sizes artificially because there are multiple manifests flying around okay hannes is that a new hand or an old one okay so um i think we have a basic direction uh for for brendan to finish this up and um it's very clear that we've spent half of the time on one document so that we're not going to get anywhere close to through this agenda so we're just going to keep going because i think the decisions we're making are important but we're going to be scheduling a virtual interim in a couple months so let's keep going uh brendan up next is the trust domains okay uh so there is not a lot of update here um this is just the uh resubmission of the previous individual draft as a working group draft next slide please"
  },
  {
    "startTime": "00:30:01",
    "text": "just as a quick recap this is the portion now that contains delegation chains dependencies integrated dependencies multiple suit processors and the unlinked directive now this is important specifically for t so we want to get this one through quickly uh well quickly after the manifest primary document and it is specifically because teep depends on dependencies and unlink next slide please now um i say that there's no running code for these things but to be frankly honest i could well be very wrong i know that uh akira has been working on um running code which may well do all of this so when i say there's no running code i mean that i haven't spotted it yet um so if the if there is running code please do let me know um really the other thing is i'm not 100 certain that we're using the cwts correctly so if there's anyone who is um who wants to review the use of key claims in cwt i would appreciate that or sorry proof of possession claims um and i would very much appreciate any contributors and especially if they come from teep i mean anyone is welcome but if they come from teep doubly so that's that's all i have for this document basically i'm hearing a screen for review yes please any comments from anyone who has either implemented or or read the document seeing nothing let's go on to the next one whoops here comes ken"
  },
  {
    "startTime": "00:32:06",
    "text": "hi brendan can you hear me yes oh yeah uh yeah as i mentioned in the chat uh my lips suits support uh dependency and uh also integrated dependency uh but i'm not sure that there is support because there's no uh sample binaries in the uh document so i report are an email so uh please review my sample binaries and mr rip sisu versus behavior thank you ken uh i guess what that that really says to me is that i need to make sure that there are some examples in that draft okay i'm not seeing anyone else in the queue and let's go on to suit update management okay and once again this is a resubmission from the previous individual draft next slide please all right uh just as a refresher what this contains is update management metadata um so this provides information like um certain conditions that you might care about version number matching battery levels um expiry dates of manifests um an explicit check for if an image uh does not match something um an authorization check which could be used for end user approval and i think that's an important consideration with rfc 8890"
  },
  {
    "startTime": "00:34:00",
    "text": "you want something that allows the end user to have some degree of control so that one fulfills that particular requirement and then there's also directives for managing updates like wait for event and metadata for non-recipients next slide please so currently we are specifying coswood uh which is what was available when the original draft was written but it looks to me like co-rim would be a much better option the problem is that co-rim is not a working group document yet um and so that that would essentially put a blocker on this particular draft so um it strikes me that it might be better to go ahead as it is and add another extension document later much as i'd rather not have so many extensions um it's not clear that the update management document is anywhere near comprehensive or complete once again if there are use cases that you care about i would very much appreciate hearing about them and feedback is absolutely welcome if you want to contribute please do and that's all i have for this one as well again a big call for review and there's going to be a common theme okay seeing no one joined the queue up next is hana"
  },
  {
    "startTime": "00:36:01",
    "text": "okay next slide briefly talking a little bit about the firmware encryption so what what has changed since we met last time so there was this intra meeting in the cozy working group where we presented the cosy hp key draft and there the decision was made to change the underlying structure of the payload um needless to say that that had to be backboarded so to speak into this document um and i've also fixed references which apparently got somehow garbled um ice bento we spent most of our time focusing on progressing the cosy hb key which we extracted from this document or from an earlier version of this document and moved into that separate document by the last idf decision of this group um okay and in the meanwhile i had added code to a code to hp key to embed tls which you can find there i'm using that code in the decocy library which you find there and updated the code during the hackathon which i was previously referring to which uses this um the crypto adaptation layer that lawrence has uh added decoys he supports openssl and also the bsa crypto api which is why i had used the bsa crypto api what you will also notice when you look at that code is that the firmware encryption is for use with aes keywrap is not yet there because um the bsa crypto api support for the aes keywrap is still working progress in the last link here so as soon as that is done i will copy that code in there as well okay so there's at least something to"
  },
  {
    "startTime": "00:38:00",
    "text": "look at and that's how i create the examples as well next slide so but there are some open issues still um not only with this document but also with the work of the cozy hb key document so we will have to work on or take the decisions that were made earlier this week in a cozy working group um and update this document as well um the examples are kind of rudimentary uh so they don't include uh for example the whole wrapper let alone the the suit part um sort of like this the outside manifest part which i would also like to include um and there's also um sort of some homework to be done when it comes to binding the context to the encryption itself and i want to talk about the last two items in the next few slides briefly okay next slide so this is what i mean by a more complete example so what you see in the document um right now is the left-hand side which shows this um cozy structure in a sort of debug format um with this new two-layer structure which is um which is essentially the sort of the the the first layer the first part on the top is just uh the regular encrypt function functionality cos encrypt with algorithm information with the nouns included in there detached ciphertext um that's the first part and then what follows afterwards is the recipient structure or the or if there are multiple recipients multiple recipient structures in that area and that's for example where the hpke goes or the aes key wrap so this is now unified in terms of look and feel which i personally like a lot um there's obviously some of the things are abbreviated for"
  },
  {
    "startTime": "00:40:00",
    "text": "better readability so obviously the keys the public keys and also the encrypted care case would be larger this however needs to be in order to provide proper security um or at least the authentication part uh it needs to be bundled up with a sign so um as i try to uh show here graphically is that once you generate this cosy encrypt structure it gets sort of um the binary gets included into this payload structure on the right-hand side of the slide and then the the cosy sign wrapper is sign one rapist and use to to actually sign that payload i hope that makes sense uh so for example if you have uh um [Music] well um not for example but this this would be the way to be done for the uh for the use with the hp key when you uh sign it but then with key as key wrap when one if you have a shared secret um in this case multiple shared secrets then you would actually use the mac operation instead so that's um those are some of the examples that are still missing in the document i will add them as well based on on on the code i have okay next slide so if we actually produce that example on the on the previous slide there uh there is the sort of for the topmost part there is the encrypt operation which um for which the cosy specification defines that you have to come up with a structure which i copied on the screen this underscore structure which um is then used as input to the additional authenticated data for this operation and um the so there's some context in there namely"
  },
  {
    "startTime": "00:42:00",
    "text": "the operation you are going to perform there's also information copied over from the protected field which is uh from for example on the previous slide we used aes gcm 128 to encrypt the firmware image so that would be put in there and then there's um in in our case there's no external aad here so this would be used and then uh that would be input to the regular uh in this case aes uh gcm 128 operation and uh that's what the the output would be next slide but there's more than that um so the the courses back also talks about this so-called context information structure and refers to sort of it as a way to bind the context uh or the context of the transaction uh to the whole sort of sort of construction if you will and as far as i understand it and at this my reading of the the cozy specification is a little bit uh i'm i'm still learning in some sense on how to read that cozy specification but um i understand that it's not used for k aes keywrap but it would be used for or it's currently uh used for all these um elliptic um curved tiffy helmet um static static or semi-static uh operations and so that's why i had put that um sort of a way to populate that structure into an earlier version of the document which is now found in the cosy hb key document um so i have spoken to a few folks during this meeting about um how they interpret that text in in a cozy uh specification and um it's not entirely clear so i'm going to reach out to some of the experts here in"
  },
  {
    "startTime": "00:44:00",
    "text": "the idf for like uh cast and others to find out whether my understanding is is correct but um it's it's a little bit uh tricky um because there's i don't want to have too much redundancy here because some of that information is already included in the um kdf in a key derivation function of the hb key itself already um what is not included is because we are using the base mode of hp key is the identities um so at least at the minimum we would have to wrap in the identities um and the recipient identity itself has if um actually we could go back to slides to show that to see the example here no one another one this one yeah so if you look here this obviously there's the key id shows here up in two places and one is for the for the sender and the other one is for the recipient so in the cosy encrypt that contains the recipient um the key id for the recipient i don't know if you can scroll over them if you have a way to mark things but you maybe you can see that if you can go down with the mouse point a little bit um so as part of this recipient structure there's uh the key id that identifies the static elliptic curve if you have in public key and that would be the recipient id that would be yeah exactly um that would be the recipient um identity included into this structure and what is a little bit inconvenient is that since we have this layering of the payload the sender's identity is actually outside in this cozy sine one structure but that's how it is so if anyone has an idea on how in cosi this was meant to be used um being applied to hbk or has some other sort of like experience with this i"
  },
  {
    "startTime": "00:46:00",
    "text": "would uh obviously value that input um but i understand it's a little bit uh a very specialized uh aspect here and um yeah so this is so honest yes this is russ uh this goes back to rfc 2631 which is based on nancy x942 um where you're trying to derive a uh shared secret and you want to make sure that both parties are applying the same context to that secret that's where this info struck stuff is rooted and uh here we're we've got a lot less concerns because of the it's always used with the signature so the question uh to my mind really falls to the cozy group uh to make sure that when they're using it as a building block in other contexts are there any concerns and i think we need to make sure that questions raised there but in this context i'm i'm pretty sure there's no problems yeah yeah that was my um that was my impression as well um because um i don't want to sort of blow things up with some um redundant payloads that are actually then not adding any additional value but yeah so currently what is currently in the two documents is that we don't use that structure and the cochbee document says if you have an application specific context here's the structure and you populated with the respective fields but i wanted to sort of be sure that you guys uh agree with that um that's that's yeah was that your last that was my last line yeah yeah so if if anyone is interested to contribute"
  },
  {
    "startTime": "00:48:00",
    "text": "um uh drop us an email uh yeah quote there a lot of fun any further comments okay hearing none we're going to go back to brendan for suit report you're on mute brendan got it thank you um so once again this is uh an update uh this one actually does have new content next slide please so uh just a a quick recap of what this is it carries a record of decisions made by the suit manifest processor that you use alongside the manifest tree itself in order to reconstruct what a device did decisions are appended to a log essentially in the order that they're made and if you want to make this efficient in a small device you can use indefinite length encoding to construct that whole sebor structure on the fly next slide please so what we have done since the zero zero draft is added a list of suit parameters and component ids to use as system properties uh what this can do is enable attestation of system properties and though it does have wider applications than just attestation and it ties into the suit reporting policy which shows up in the manifest draft itself next slide please oh that is the last slide oh okay right yeah sorry"
  },
  {
    "startTime": "00:50:01",
    "text": "yeah sorry i i had originally planned to have this one come after the one on the uh suit and rats claims uh so that's hence my thinking there was more content coming there um so this this i guess sets the backdrop then for that particular discussion so i think it in it makes the most sense to me to put these two together and maybe we should uh go straight into the next one and then we can have discussion about them together because i think the the issues really are tied together okay then let's go to draft burkholt's rat suit claims the slide deck is called suit-related rats claims you want me to switch yes please please got it great next slide please okay so previously we had a draft of suit claims in rats to define suit specific elements that require attestation um the thing is that the suit report could also carry these uh elements now we proposed this at the rats interim and suggested that we merge the this document with the suit report document now that was rejected in the interim um and the reason for that was that some of the claims are duplicated by elements that have been added in rats i don't think that this is the correct decision and i don't believe that hank does either and i want to revisit that within some additional explanation of what our reasoning is so i don't think that we managed to carry that across properly during the interim next slide please so essentially this is a debate about"
  },
  {
    "startTime": "00:52:00",
    "text": "semantics versus structure eat contains data with specific semantics and specific structure and the suit report contains data with similar semantics and a different structure the suit report structure is designed specifically to reduce overhead on constrained devices now what that means is essentially that you don't have to hold in memory uh components that will go into the uh the eat claims later the idea here is that you can actually just directly encode on the fly as you uh as you encounter these decision points um the this may seem like it's a premature optimization and i suppose it might be um but it's consistent with the the non-attestation side of reporting in suit so by putting those two things together it seems that they do make sense um on their own like the the the the the joint code size reduction and memory reduction that you get by doing both things this way uh seems like it would be the right choice um obviously this is something that we don't have measurements for yet but that is something that uh makes sense to me from a high-level perspective it's really tightly coupled to how suit parsing is done it happens in exactly the same order and so eventually we get down to the the heart of the matter which is that it's got similar semantics but different structure for a reason next slide please and so this is where i think we come to possibly the contentious side of things um suit reports could potentially be treated as evidence but they should not be treated as attestation results so arguably a verifier should translate a suit report into generic e-claims so"
  },
  {
    "startTime": "00:54:01",
    "text": "now we look at these as two different pieces within the rats architecture and so this is why we believe that it makes sense to add one claim to eat which is a suit report next slide please oh i just i just stole my own thunder um so that would be consistent with uh using it as evidence the verifier would be perfectly capable of translating claims from evidence to results where appropriate it moves the trans the format translation overhead away from constrained endnodes and puts it in a verifier in a data center somewhere which is where it belongs um and it would allow us to merge the uh suit rats claims document into the ietf suit report document and then only have one claim added in each which would cover all of suit and that is my slide deck so questions comments go ahead dave uh dave filler as an individual participant and uh editor of uh t protocol i think this is part of the right question um what you have on the slide might actually be the answer but i wanted to uh [Music] up level the question into multiple possibilities and maybe get your feedback and the rest of the working groups feedback to see if this is the right one because i can see multiple different ways one could go um that i think are consistent maybe with the original principle and this is one way to implement them and it might be the right one okay so i can imagine uh of uh for completeness i can imagine you could use the suit report as the evidence format say instead of eat okay you could use the suit report in evidence like encapsulated like you have here which is you're doing it inside of a single claim inside of an each right"
  },
  {
    "startTime": "00:56:01",
    "text": "so you have this report inside of a need you could do it uh translated where the information in the suit report becomes information in the eat and i think that's consistent with what you're saying maybe about attestation results or portions of attestation results and portions of zero reports maybe you could also send the suit report in addition to evidence and it gets to um the evidence is stuff that is interpreted by a verifier and here in the tea case the thing that needs the information the student report is the relying party so you can say well how do i get the information from the uh a tester or or you know suit reporter into the relying party and so you might be able to do that via inside the attestation exchange in which case the all the information that's needed by the uh updater it has to be in the um at the station report in some way so you got to go through that pipeline or another way that you could do it is to say okay independent of attestation you send the suit report directly from the attesture to the to the relying party which means it would be in in the teap case that would be in a query response message um separate from the evidence field okay and so in terms of what we do in the t protocol spec we can add another field into into a query response that says here's how you could reply here's how you could pass in you know the boot time suit report or something like that separate from the evidence field or you can put it inside the evidence field but then you've got to make sure it gets translated into attestation results just so that the team could get it rather than getting it in parallel to the evidence so those are the different possibilities that i see i have no objection to doing what brendan what brendan is saying here on the slide i just don't know if that's the most efficient way to do it in in teep or if we should also have a way of having suit reports directly in the query response sorry in the career response in addition the evidence field just so it goes directly to the relying party and it only pays attention to it if at the station succeeds so open and feedback"
  },
  {
    "startTime": "00:58:00",
    "text": "hey dave real quick um you you you said a lot and it was very difficult to capture in the notes would you mind um typing some of that into the notes for us uh i would be happy to although it would be more concerning if brendan didn't understand my question so no i i did understand your question it does make sense to me i can see there's i think it was four different ways that we could go about this the argument i'm making is that it doesn't make sense for a constrained node to have to do claim translation when that could easily be handled by something higher level one of the questions is tied in and i know we're just about up on time here and so you may have to defer this to the to the list but i am looking for a direction as to what to do with the t protocol one um is today there is no requirement for a teep device you know a teep agent capable device to actually keep track of suit reports at boot time right you can argue that there is a requirement to keep track of suit reports at update time okay but there's not currently a requirement to keep track of them at boot time um if we say that there's no claims directly in eat then i think it does introduce a requirement to have suit reports at boot time and there would be a dependency there requirement for for for the tp agent so yeah i think on this one i'm a little bit less concerned um about what happens in teep because so far at least it appears that teep devices are typically larger and uh have more power available more code size available more memory available um so maybe that's not quite as big of an issue and it's fine to do things the way they are i'm i guess i'm more thinking about more constrained devices uh i think this is something we need to discuss on the list a bit more um so maybe we should defer or we should take this discussion to the list because i think we are out of time yeah uh so yes let's continue this"
  },
  {
    "startTime": "01:00:02",
    "text": "discussion on the list i'm really surprised given that the first presentation took us a half hour that we got through this much of the agenda um but yes let's take this to the list and we'll schedule in the room so that we can recap what we we do on the list reach consensus and then talk about mud so expect a doodle poll soon and uh for those of you in vienna safe trips home uh after the meeting ends tomorrow thank you very much uh to the note taker especially thanks everyone thank you okay yeah oh"
  },
  {
    "startTime": "01:02:00",
    "text": "you"
  }
]
