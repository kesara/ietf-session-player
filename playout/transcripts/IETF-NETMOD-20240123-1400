[
  {
    "startTime": "00:00:11",
    "text": "hello all uh this is the net uh first interim of 2024 um thank you for joining I'm going to get started uh on time uh with the expectation that we're going to see a few more people come in as we uh go through the intro chair uh chair slides uh this is a formal ITF meeting so our not well um applies and everything we say here becomes part of our record and as we know this we are recording and we'll have the video and transcript available after the session um our code of conduct also applies please treat each other with respect um it's we're a small group but uh we still should act uh professionally and uh uh give each other uh good turns to to speak um the please keep your audio off um we are going to use the tool for raising hands uh again since we're a smaller group we could we will loosen that a little bit if we have some good back and forth discussion you know please feel free to to um uh have the discussion we will moderate as necessary uh if that if we're we're finding that that's not working um so uh please do use the Q control particularly when someone else is speaking and uh we don't have a separate blue sheet it's coming from um uh the tool we are we do have chat available uh to the group and and um"
  },
  {
    "startTime": "00:02:01",
    "text": "often that gets used also please join us for note taking and as usual um only the discussion needs to be captured not what is being presented all session information is online the tool also has seems to have been reformatted a little at the top there's a little folder if you click on that there are nice links to the the two slide decks we have for this meeting um the agenda is small which is nice and and we have a fair amount of time available uh we scheduled it for a good amount of time so we could have good discussion but we're under no obligation to use the fulltime so as if the conversation ends earlier we'll end earlier we do have a second planned interim coming up um it is February 6th I think that's two weeks from right now uh we there was some discussion on time and time zones uh we have selected these times based on um making it available to the uh we we really wanted to pay attention to the authors and make sure that the authors could participate and yes there is a balancing act between authors and uh others in the working group so that they can be you know find a good time for lots of people to attend but of course if we don't have the um key contributors available we're not going to have much of a meeting so that's a little bit for on the the time that is my last slide I'm going to change over to shuang's deck and I'm going to try to pass you control let's see if I can do it okay Kent it is not letting me pass for some reason the way you said I was kind of curious to see what would happen I think it's because uh I passed the"
  },
  {
    "startTime": "00:04:01",
    "text": "control to you in the first place let me umove uh how do I do this oh you got it did you do that uh I don't know I did not do it but uh thank you for doing it okay I may have done it let me pass control to chiffon chaan you should be able to um yeah yes I can perfect okay thank you thank you Ken thank you Lou so I'm going to lead this uh system define configuration uh discussion today and hello everyone my name is t by the way um so before the presentation I want to highlight that this presentation actually represents a lot of viewpoints from the working group instead of the authors themselves so the intention is try to make the uh presentation as informative as possible so for uh first of all I think it's worth some time for me to give a recap and overview about the agreement we have already reached so we have a draft uh which defines how a management client and server handle young modu configuration data that is divided by server itself so we call it a system configuration actually the concept of system configuration is uh touched by MDA a workor already we published as RFC 8342 and in the system configuration draft in order to uh better expose the system configuration we Define a system data store uh which is config true and"
  },
  {
    "startTime": "00:06:00",
    "text": "read only and the client can reference and override system configuration as well as configuring descending notes of system configuration and this is actually achieved conceptually by aling both system and intended uh merged into running oh sorry into intended data star U during which process running tax precedence over system and of course this is after the configuration transformation uh defined in RFC 8342 which actually refer to the configuration template expansion and in active configuration removal and also we have defined two ways to satisfy referential Integrity constraints in running either the client uh explicitly copy the reference system nodes into running or use a resolve system parameter to allow the server to copy the reference system nodes automatically into running so two ways to satisfy the uh a referential complete configuration in running and so for this presentation uh I'm going to mainly talk about uh two issues that uh we have uh already discussed before but I don't think we have reached um any agreement the first one is the origin issue which is uh specific to the system configuration that is copied from system into running and the second is about the validity of running alone this is an an issue I think is not limited to system configuration but kind of uh a"
  },
  {
    "startTime": "00:08:00",
    "text": "quite fundamental uh concept has already been touched in MDA but maybe not that clear enough so I think it it would be good if uh we can reach some agreement and then the outcome could be documented in the system config draft so so by the way if you have any any comments or question please feel free to join the queue or inter wed me during the presentation and so for the first issue uh the origin issue for system noes copied in Kent you in the queue uh yes hi um I was just the previous slide and and or the one before that you it's obvious to everyone but you were we're talking about system configuration and in the system data store being for uh readon config true uh I I mean I imagine it's obvious for everyone but of course the Yang modules that would be implemented inside the system data store uh may have some config false nodes as well and uh of course those config false vote nodes would not be visible in the system data store they'd be visible in operational data store um but just wanted to in case there was any you know if it wasn't obvious that of course the system may have some config false nodes in addition to config true nodes yes exactly so the system configuration is config true but is provided or predefined by the server so that system configurations config true right and for the the the first issue the origin issue for system nodes copied into running and this issue is actually independent of the uh discussion of our second issue which is the validity of running a loan because anywh we would"
  },
  {
    "startTime": "00:10:00",
    "text": "allow we would always allow a client to copy any system node into running this is something we should always be we should always allow so we have uh some nodes in system data star uh which and never uh being which is never overridden by the client in running would be present in operational with the re if it's actively in use would be uh would be report the origin value would be reported as system I think this is consistent with what has MDA has defined for this origin value system and we also have a lot of configuration in running data store and it's it's the configuration controlled configured by the client and it's is not system configuration which is represented by the the yellow node in the running data store is if is the Soro could apply it successfully it would be present in operational and then with the original value reported as intended I I think this is also no doubt but the the grand area might be for the uh the node that is created by the server and that's present in system but then copied by the client into running so the question is what would be the origin value for these system nodes that is created in sorry for the configuration copied from system into running should it be reported as system or intended and maybe it seems that maybe it seems that uh we since it's it's it's present in running and running tax precedence over in system so maybe the intended should seems like a solution"
  },
  {
    "startTime": "00:12:01",
    "text": "but I think the question behind this issue is that whether we always want a copy system not in running to always override and take precedence over system one of the exception I could um cons think of is that what if the copy system nodes are immutable for example if it's a interface type and immutable system configuration I think this way the client is allowed to copy it into running but this is a case where configuration in running should not take precedence and I I I I'm not convinced that intended would be informative uh as the oring value being reported in this way okay Rob uh hopefully this mot working can you hear me yeah yes sorry um so my my take on this is that effectively so originally when we we Define the origin Behavior we were thinking of system coming into the operational data store from a different place and hence we're differentiating between the configuration coming in from intended SL running and the configuration coming from other sources and the idea there was that the in my mind the intended was the configuration that's coming from the operator so this is what they want the the want the device to be doing this is saying this is how you intended to be behaving and so from my perspective if if um somebody either using an RPC or does it by hand copies some configuration from system to intended that is what they they that's how they intending the system to behave so they're effectively saying yes these are the values I want you to be using and in essence it's not guaranteed to overwrite other configuration nodes that are there so my impression uh Instinct here is that if you copy system nodes into intended then the um origin for them should be intended and you'd only"
  },
  {
    "startTime": "00:14:02",
    "text": "report them as um origin system if they hadn't been copied into running does that make sense have I given a clear answer yes so what would be like for something like um so even is some immutable system configuration still should be intended right is yeah that's my so even in this case you take interface type so you copy the interface type into intended you're actually making slightly a slightly stronger guarantee you're not just saying uh and I'm and I'm copying this this system uh system configuration into running you're saying if my configuration to be valid I want it to have both this interface name and I want to have this interface type as I want to be knowing that I'm running on an Ethernet interface rather than just picking up whatever is there in the system and hence you are going one step further um and saying this is my intended configuration for this this interface I want to be both this name and have this type so it's slightly stronger guarantee okay thank you so Jason you in the queue yeah um I I guess I I I just want to support uh kind of agree with Rob there um part I guess a couple a couple reasonings for me one is you know just a reminder that um things don't have an origin up in the running or intended data store origin only applies to operational and the system config we're talking about that gets copied or explicitly written flows down through intended so uh you know along with Rob's other arguments I I also see it as making sense for it just to be called intended the other thing is um you know we have that that autoc copy uh function like I I see that as just a one-time convenience copy you know it's copied in and it's done and at that"
  },
  {
    "startTime": "00:16:00",
    "text": "point it doesn't it's not really relevant whether it was automatically copied in or manually copied uh by the operator um I see those as equivalent it's it's it's it's now in the running and uh it's just it's just normal data like anything else that flows down through intended um you know when I I think we clarified this but when something is copied in automatic or manual or sorry automatically it's never automatically removed in any cases right um right like it's not it's not managed data that's managed by the system anymore it's stuff that was just one time copied in so that's my view on it uh yes we we we yes we do have the statement in the draft and I I I think I also agree that once the configuration is present in running then there's no difference from whether it's copied by the server automatically or explicitly configured by the client so I would agree with you about this point Kent what do you think uh I also agree with Rob um I think that if it it reminds me somewhat of uh defaults and uh and like the with defaults draft how you know there's the notion of like did you get the default is it the default value or did you explicitly set the default value and if you explicitly set the default value then it has more meaning and it it it seems very akin to that where instead of defaults we're talking about the mean system value so if you explicitly set the uh system value which is immutable possibly um but still you explicitly set it uh it cannot be overridden unlike defaults but uh still you explicitly said it and so that that maybe it has more meaning um I do also think that uh this dovetails somewhat with the second topic of the of your presentation which is the um you"
  },
  {
    "startTime": "00:18:03",
    "text": "know do does running alone have to be valid and and ultimately that that discussion is about uh the numerous number of uh you know nodes that might appear in system that are needing to be copied into running solely so a leaf Ruff can become valid there's no other reason for them to be copied into running um and uh and and and if they weren't needing to be copied in a running if it was sufficient for them to be resolved externally um then in that case the running plus you know or merged into system equals intended uh in that case I I think it might make sense for those config true nodes to appear as origin system um because they weren't explicitly copied into running okay yen it's been set up by Rob Jason and Kendall I just want to for record note my agreement okay so then should the authors um specify in the draft clearly that in this case the origin value should be reported as intended right so the author do that in the next version Jason um I guess uh I just want to clarify one one part of the the last few speakers um I know when I was talking about support of Rob statement I was thinking more of anything that got copied into running um it Kent brings up an interesting question though that I'm not I'm not sure if I'm not sure if uh if if everyone was in sync with and I'm not sure myself but I guess what"
  },
  {
    "startTime": "00:20:01",
    "text": "I think what Kent was saying was if there's uh stuff that's in system that is not copied into running um and it appears in operational it in the current draft that flows in Via intended even though it wasn't copied into running right like the system the system merges into intended and I think Kent was saying that those objects would be um marked as system so even though they even though they flow down through intended um uh you know I I guess there's a question is whether those would have a different um a different origin yeah I guess it's the uh red versus the Green uh that you're showing here yes so it's not all intended yeah right the SE now needs to remember a particular note from intended is actually a system configuration or a configuration configured in running yes I and this I I also agree that this some seems like a little inconsistent with what MDA has defined that the origin intend the intended origin value is actually uh from the data that is flowed into intended so also some kind of in consistence from my point of view Rob um yeah so I I do get you saying consist I think effective what it means is probably this document needs to um formally update RFC 8342 to say that it's changing this Behavior but it in one sense it's inconsistent it's flowing through intended but the other other sense is consistent with how um the nmda um architecture was uh specif how system config flowed in anyway so if you took"
  },
  {
    "startTime": "00:22:01",
    "text": "two devices before and after with or without this data store then their origin would be the same so nothing actually changes there there'd been marked a system before because it' been system injected directly into operational and now it's system configuration injected in Via into intended so the only thing that's changing from that perspective is like validation of is uh is intended valid but it doesn't change What flows into operational so I think even if we we draw the picture slightly differently I still think it's fine uh and I still think you just clarify that uh that the stuff that comes from system um is Mark a system stuff that comes from intended is intended okay thank you and I can't remember on NBA what it says about default Valu so they not I think they have an origin is an origin default yes origin default so that again is very similar in a way that is the same sort of argument that that you still have those default values in intended when you do the validation so I still again think that would make it consistent we just need to update the nmda draft and make that right clear okay that makes sense to me Kent uh yeah first I want to thank Jason for uh surfacing that um he picked up on what might have been a subtle comment and and brought it forward thank you um just looking at the slide uh the the three question marks in the lower right corner uh I think that we're now just to make it very clear we're saying that that should be intended yes the green nodes are intended yes I agree and and the conversation we were just having was about the red nodes and uh we're in agreement I believe that they should continue or they should be Mark a system yes and I also want to uh respond to Jason that I think the system aing value should be the right value to be reported because it's system conf configuration is not other data source"
  },
  {
    "startTime": "00:24:01",
    "text": "not other source so I still would like to use system as the the value instead of others yeah for the red I'm that yep I I like Rob's explanation that even before this work we did have different nodes flowing through intended with different Origins default versus intended I'd forgotten about that so yeah consistent that not every single thing that flows through intended had the same origin even before Soh okay okay thank you and there is another point about this issue is about the servers upgrade migration I mean um if the device is upgrade and the system configuration could possibly and update and in this case if uh an outdated copy is still in running I'm not sure whether we want to this uh migration to happen on nodes in running as well I mean it's already the case that if the the system configuration upgrades and it will the system data star will update dynamically but whether we want this upgrade migration to also happen on the nodes in running I mean all do do you think this should be connected with the nodes with certain origin value because if it's in running then the I think the the consense is that we want the Val value to be reported as intended and then in this case should the migration also happen on running Kent thank you uh I this is now"
  },
  {
    "startTime": "00:26:04",
    "text": "um uh the the issue if we don't migrate the data that that got copied in the running then it seems like running might become invalid like during the software upgrade process the uh underlying structure of system changes we don't migrate running but now running it doesn't match and and therefore it's it moves simply upgrading the software moves running from a being in a valid state to an invalid state which seems wrong uh I mean I can't imagine anyone wanting that so um okay so so let if what if the uh Suppose there is a copy system node in running and then the the value has been updated after a device upgrade then would the Le reference would this infect the client Le reference would that be invalid invalid could could that be possible if it were if if it was just a leaf reference like the the like and I know the second topic is whether or not we have to copy things over that are just Leaf refs but if it were just Leaf ref and and system migrated I don't there's nothing to migrate in running running would still have to Le for Le for would still be a valid ref um I'm more concerned about the like for instance if you want to configure a descendant node underneath a system node um but somehow that system node change I mean I guess we're talking we're in the world of NBC type changes where where that might uh occur but um and maybe that's that's a good question maybe that's the that's the question right what are we talking about uh that would cause running to become invalid would it be an an NB BC change and um and maybe when it's not a NBC"
  },
  {
    "startTime": "00:28:03",
    "text": "change then everything works fine but when and and no special handling needed but when it is an NBC change we say um it's possible that running could become invalid after a software upgrade I'm going to step out of queue to see if Rob has anything to add to this so I I think there's different choices here and I I actually wonder whether the answer here may be to rule this is out of scope and just leave it as Ser defined Behavior so I think one choice is as you say is to update Running to keep it valid but I'm not sure in some like the modern systems how much that helps because it will still leave the um the controller with the wrong configuration because the the server's modified running configuration so I like the architecture where effectively what gets written into running is directly in under the control of the controller and hence um you don't change it like the device doesn't change it without the controller's author authorization um or agreement to change that configuration I think uh other way to approach this problem is as you say is to not update Running but flag is being invalid and then have a requirement that the controller comes in and up corrects the configuration before it does anything else you could also reject the the upgrade or the install operation and say no you have to change this configuration first before allow to go through so I think there sort of different choices as to how you could do this um I don't know whether we want to solve this here or just say actually uh this is left out of scope pragmatically okay personally I would like to leave this as out of scope but I would also like to hear what others think about this blush I think there are some changes to the system config that yeah you just can't handle really so if if you make a"
  },
  {
    "startTime": "00:30:01",
    "text": "mandatory new new leaves or new attribute then and they are not there you just can't handle it in this case I think upgrade has to fail there's a big category that you can handle in an automatic way it would be interesting to separate these two categories but I think at least we have to state that if the system config changes then the trans the risk of either failing or invalidating the running confli so the risk must be stated whether we solve it yeah that's a question okay thank you Jason yeah I I agree with without a scope um well I think it' be very difficult to Define one behavior um that everyone's going to agree on uh it may be worthwhile uh you know saying it's out of scope but I I sometimes find it useful to have illustration of examples of behaviors that could be possible so uh I I find sometimes that helps actually like just staying silent on something's out of scope is one thing but sometimes it's helpful to explicitly say that this problem is out of scope in the draft and maybe even give a few examples of different behaviors that could be possible it'll help people understand in more detail what is out a scope so just just a thought we we we may want to explicitly say it and and even give a few examples of different behaviors that could occur okay okay so Kent okay I think I'm I I want I I kind of want this to be in scope but I respect that um maybe as Jason says some examples would be enough uh rob you know"
  },
  {
    "startTime": "00:32:02",
    "text": "surprised me when he mentioned uh the concerns of a controller and and that if it m if the if a server migrated the data the controller would be surprised um I mean I would hope something like eags might You Know cover that scenario but but that not withstanding I was I was not even thinking about the controller at all it wasn't even in the picture I was more just thinking about if the the server gets up software upgraded and something about that software upgrade causes running to become invalid and and now the server I I won't say it can't boot but it's not operational it it I mean usually when people do upgrades it's sort of an inline upgrade uh temporarily the service is down you know traffic is not flowing through the device but um it you know potentially a Ser a software upgrade and now this the servers is down traffic is not flowing um until the operator manually does something uh I I I would I I think you know going to Jason's comments about examples and POS possible remediations um Rob's uh suggestion or third point about POS the server possibly refusing to do the upgrade because of it it knowing this and then maybe a force flag like a-f many commands have this notion of a you know are you sure you want to do this and and maybe it's okay because it's in a clustered environment and they're doing um you know they can take down one cluster member and upgrade it and then bring up another and so it can be done safely but but it it seems like some guidance might be uh desirable so thank okay okay so we may do this as future work but now I agree it would be good to open the do in the system config draft and leave this as future work okay Rob I yeah I think that sounds like the"
  },
  {
    "startTime": "00:34:01",
    "text": "right answer here I mean um going back to K Point again the thought is if if you've got some scenarios where the controller is defining the whole config for the device and there's cases where like the zero um uh DP scenarios where the device just boots up and pulls down configuration it's always the the device should always be using the configuration the controller is giving it so for it to be running a different configuration isn't necessary helpful State um further to that point is that when you say like if you can't change the keys there's different ways you might resolve that configuration when it becomes invalid you might say okay I know what values these leaves should take so so I'll update the configuration to take those leaves uh but you won't always necessarily know that you might say I want to delete these leaves because they're invalid and I'll apply the configuration I'll keep delete deleting bits of configuration until it becomes valid but that might mean you start to remove ACLS off an interface or something so it's really risky to know whether the device ends up with a configuration that is secure and what the operators wants uh want it to be running so I think I think there's so much complexity here and choice that that's just saying uh that this is out of scope I think is the right answer I do agree with bag's comment earlier where he says we should certainly highlight the risks in that scenario that this might change I think that's a sensible thing to do um as to whether having examples here uh maybe some in the appendix but I just worry that maybe that will bind us in future I I wonder whether having a separate information document future about describing what might happen on uh during an upgrade might be a better path um because I don't want this document to slow down a lot because of that yeah so I guess I suggested the examples I I see what you mean Rob I guess I would just want want to make sure that uh we're clear in this draft"
  },
  {
    "startTime": "00:36:02",
    "text": "have other we don't have don't have to do it with examples I often find that very illustrative for people to figure out what you mean as out scope so as long as we're clear about what is oscope and we don't we don't have to put all the examples the other thing is um this discussion we're having about upgrades I know the system data may add some complexity to it but fundamentally we're discussing something right now which is completely independent of this draft like we would have this exact same debate about what to do without system you know without the system data store discussion you know what do you do for upgrades can your running become invalid Etc so system may add a little complexity to it but fundamentally we have an issue around this that's that's independent of system and one statement rob you made that might be uh overlap a little bit with the other issue we're going to talk about is you know during upgrade you mentioned well maybe maybe the running becomes invalid but uh I don't know if maybe that's going to tie into the next topic but I'm not I'm not I'm not I'm not sure conceptually it's it's really going to be allowed or advisable for us to have such thing as a state where the running is is an invalid data store but uh maybe I guess we're going to get on to that soon yes so just going to very quickly respond back to Jason so yes I agree that the upgrade topic is completely sort of orthogen all to this data store really um and go back to examples having a couple of examples would be okay with me as long as you're not trying to write uh a complete list and it's just a couple of examples of how systems could behave yes that would be fine okay I would very much like a few examples examples not not recommendations"
  },
  {
    "startTime": "00:38:16",
    "text": "so maybe um we can try to document some a couple of examples in the appendix and and then let's check whether be useful or not a document this is out of scope in the the normative text as normative test and then a couple of examples in the appendix will that's be useful I'm not even sure appendix because that may make them beefier like bigger than we want I I was more thinking you know eight eight-word summary of a couple of examples in Brackets um I'd be slightly worried if we make it an appendix it's going to uh we're going to put too much into it okay is bagean Q sorry no appendix can be short but nothing special U just picking up on what Jason mentioned about this is not new or or it's not specific to system already a server upgrade might update Yang modules that are you know in running and uh but we never discuss whether or not there's a need for migrating the that data because at least with 7950 section 11 all updates have to be backwards"
  },
  {
    "startTime": "00:40:01",
    "text": "compatible um and so it would follow that any update of a Yang module that's implemented in the system data store would also have to be backwards compatible um per 7950 of course with the versioning um effort that's in the way there's a possibility for NBC change to occur um but I think maybe we need to move it to that draft to solve this problem um if there's a need for a data migration to occur whether it be in running or system that draft should speak to um the server Behavior so I think for this draft it doesn't need to do much other than to um acknowledge the fact that um NBC change may occur um and uh and and with the system configuration data as well and that the other draft would have to discuss how the how that's resoled okay okay thank you sorry I as one of the people invol authors of versioning I don't think versioning wants to take on the full upgrade discussion yes NBC changes will be documented according to versioning but NBC changes happened in real life before and versioning people I don't believe will solve the migration and upgrade problem I I guess somewhat along the same lines as balash uh I think I think maybe Kent's right that this uh this problem of upgrade related to NBC changes is kind of in the scope of the larger versioning work uh I mean the versioning work as a whole is a huge topic right with uh five drafts underway Etc so I think it it kind of does fit in"
  },
  {
    "startTime": "00:42:01",
    "text": "with the scope of that work but uh we are definitely not going to try to solve it as part of the first two drafts we're going to go to RFC with that just that would just slow that work down that we're desperately trying to wrap up so I think we could consider you know treating it as part of versioning work it just uh it just I don't think we should hold up the first two drafts uh with that issue so just thinking a little bit more about this it it may not be that the an NBC changed occurred but that the the value changed uh so in system maybe uh the value was originally 100 and the operator you know copied 100 into running and so now they made it explicitly 100 but during a system upgrade now the value is a you know one uh so the the value that got copied so it's not that the the schema changed the data model didn't change the the the value changed and uh that that that might be a slightly different issue it's not an NBC issue yeah that's a great Point uh Kent I think uh that that is different and maybe actually worth talking about here um I I don't I don't I don't off the top of my head know the right answer there except that I think once it was copied I kind of view it as you're done like it's not data that's actively managed by the system anymore so if you upgrade and your built-in quas profile in your system data store has decided to you know use 101 instead of 100 uh I mean my initial view would be that's nice but that's that's too bad if you already copied it into running um but don't forget often the use case for this is someone will just Leaf ref those buil-in policies Etc they may decide to override the parameters but if they do it's"
  },
  {
    "startTime": "00:44:01",
    "text": "because they've thought about them they explicitly wanted to set them or override them um so if they're just referencing them they'll pick up the updated value for you know for child leaves but I think we should think about the more some worse cases where let's say you have a cap ability in system that says you can use one two or three and then after some time you take away three anyone who used three will have a must statement or a Le ref and that really makes the configuration invalid it's not just that it's slightly a different value and okay we use it no invalid three is not allowed anymore you try to use it it's invalid and Jason's correct about uh if it's just a relief ref then and the and this value changes there's no um effect to running uh I guess we're discussing the values that actually did get copied into running and and again this might the topic of the next half of this presentation uh it might be well what values need to get copied into running so you know and many times so like and the reason why you're copying anything they running anyway is so it um uh so valid so can running can be valid alone and uh do do all those values need to be copied into running or just the key values need to be copied into running um perhaps there's some discretion and and it turns out that the values that get that could get changed uh are not the key values and so it's un on issue I think maybe the draft has a proposal earlier saying that only the keys need to be copied for the system to"
  },
  {
    "startTime": "00:46:00",
    "text": "be able to use those objects for for the OS to be able to uses objects um I kind of align to that um and back to bag's point belage if if option three is no longer valid I think that's an NBC change of the data model right because um it's don't forget anything that's copied from system into running means the same Yang module applies to system and running um in fact I think that's always true I don't I don't think a Yang model is bound to system and a different Yang model is bound to running um and there's not like it's because stuff moves back and forth between system running it's the same Yang modules so that might be an NBC change you're talking about or I might be misinterpreting I think it's just the data change really think about the leaf uh Leaf list that lists allowed values and then you have either a Lea ref towards it or maybe a must statement towards it and then suddenly that value that you were looking for is not there the model didn't change just the values of that leaf list coming from system are not one two three just one two yeah I'm not I'm so I might I'm not sure I'm totally following it uh maybe we come back to that point op stored in the Lea list and until now you had one two three as the values of that leaf list now you only have one two the model hasn't changed in system yeah in system you took away one value from this this Leaf list and that if there's any reference to that leaf ra instance identifier when must statement to that specific data value then you are invalid so if a system configuration references"
  },
  {
    "startTime": "00:48:01",
    "text": "another system configuration that which is no longer valid so that server adjust that reference so that be the respons of the about the client to do that adjustment I think we should just list the risk and some short examples of what you can do with this but this is the bigger upgrade problem part of that okay I was going to comment on the copying stuff into running but I wonder if that's actually straying on to the next issue anyway but um I was just going to make the comment that if you copy keys across one thing we need to think of very carefully is about does that then employ you write the data models differently to do that so Kent's uh drafts related to uh keys and Key Management all of those there's there was question marks was do any review of those as to whether you mark some of the children as mandatory true or not and um I think semantically the data is mandatory true but then you want to have just the keys in running you have to force it to be Mally false now the conclusion I came to was you should make the data model so it's right so correct regardless of which data store it's in but that then has this impact that you can't just copy the keys across unless you start to say You Know M mandatory true doesn't have to be enforced in this case or something that but that might be a Yang next rule okay bash are you still in the queue or no sorry okay so so Rob you mentioned when you said keys I wasn't sure if you were talking about Keys is in the key store or some security thing or you meant Yang list Keys uh so I I was given the example of when you're referencing like a quas profile object um"
  },
  {
    "startTime": "00:50:02",
    "text": "but I I think if if the system data store contains nodes that are mandatory in the data model those would also need to be copied across in order to make running valid so I know I was using leafre because it's the most common and easily understandable use case for system data store um but there's other constraints that need to be resolved in order for running a data store to be valid and I think all those constraints like if we're going to say running has to be valid then you'd have to copy over you know list Keys you'd have to copy over mandatory nodes you'd have to copy over things that I guess resolve to make must statements true uh so it's I don't think it's as as simple as just the list keys and and just uh just to rep back to Jon and that's sort of the Croc to the issue that I had when I was reviewing Kent's drafts was that you then get to this dis this discussion or consideration of saying should we Mark some of these should we sort of take the magy true off some of these nodes so that they don't have to be copied across because you might not want to copy the some of the private uh key data into running for example or or even other key so that was the sort of case where I'm worried about people changing the data model so that you can make this copying easy and I think that that's not necessarily the right way to go I think get get the right often for these system objects don't forget it's it's what we're talking about is instance data populated in in the system data store so I keep going back to like a quas profile so you have a built-in quas profile but there's also operator created cost profiles in the same model and you need to express that hey when you create an operator specific profile this parameter is mandatory so you don't want you don't want to lose that information yeah I'm not that's the tricky point I think"
  },
  {
    "startTime": "00:52:04",
    "text": "agreed okay so I think we Ken Canen no I was just gonna say that was a great discussion um it looks like we may have run it to ground and we can move on to the next one yeah yeah we we kind of touch the already touched the second point so rad do you want to comment yes I just have a question I I got distracted and I know where talking a lot about software upgrade and all that for that second bullet there what if the copied system nodes are immutable did we agree on that I mean my take is running should always be valid uh yes the note is immutable it just the client cannot override it with a different value but should be allowed to be copied into running mean if it's like like uh uh an interface type value with uh the same exact value as what is already defined in system data store that is okay and we just agreed that in this case even it's immutable then the Regin should still be reported as intended okay the other thing Rashad if you're if you're off for a moment you might have missed is we we decide to make the upgrade issues and data data migration conversion out of scope of this draft so if yeah if you upgrade your software and your yang models change in an NBC way does your server does your router you know convert data Etc that's going to be out of scope okay thank you blush I think it's not just the up this model upgrade that should be out of school but there should be some statement like that if the system data"
  },
  {
    "startTime": "00:54:01",
    "text": "changes because of upgrade because of I don't know weather patterns what for whatever reasons that might make either the validation in or invalid or may be impossible to execute if there are constraints yeah same way as model upgrade the instance data upgrade in the system might be impossible or or just implementation specific yes and out of scope except for a few examples and the risk okay that would work for me okay so then we are going to uh talk about the the second issue which also the key issue about the validity of running alone and the question is it's very easy to understand that whether the copit uh system uh in the system config context is that whether we always need a copied system node to uh whether we always always a reference system node to always be copied into running and to be more General that the question is whether we always need a referentially complete configuration in running and here we use uh I use the uh an example of the reference could be le reference and could also be the mandatory true or the system defined configuration defined as mandatory true or present in the when or M constraints and that could be also considered as reference and if there is a reference to the system configuration in system data sty should that be copied"
  },
  {
    "startTime": "00:56:01",
    "text": "into running to make sure running is referentially complete so that's the the question and it's it's very direct that we have two options now and the first option is we don't copy the reference is not copied into running and the second is that reference is copied into running and so this is the the issue we are going to dis discuss and before we are getting into details I want to um mention some Concepts that has uh been mentioned a lot in the online validation blash uh I have a more basic question can you go back to your previous slide uh is it a requirement to have a a this readable run intend configuration for this to work so what happens if you don't support intended or maybe it's just hidden somewhere in your software so you don't have intended data St the server did not Implement that right I guess that way maybe there is still another conceptual uh um data star which may not be visible to the client but still has the conceptual intended data star that's my understanding Jason yeah I guess I I I think I agree with what you're saying shiang I I I don't think this draft we're talking about today is going to mandate that an implementation uh supports reading the intended data store I think that's maybe a bit orthogonal but that I don't think that changes the fact that there's a conceptual intended data store so so bash I don't I I don't think"
  },
  {
    "startTime": "00:58:00",
    "text": "this draft you know is fundamentally requires an implementation to support reading the intended data store Le that's not my impression from from working with it yeah please stay that somewhere thanks okay so we're going to talk about the online validation and offline validation in this slide since they are not defined in any of the existing rfc's but both are heavily mentioned in previous discussions and in this presentations so for the online validation I try to Define that it's about the protocol operation I.E the validate RPC operation enced at the server site to validate the contents of the specified configuration and for the offline validation it means the the operation performed by the client or offline tools to validate the configuration which is fed from the server performed at the client side so online validation and offline validation and also I try to uh give some quotations from existing rfc's just um we need to keep this in mind that this is something that has already been defined in exting rfc's and many and maybe uh any of our decisions we're going to make today need to take them into consideration so both the RFC 7915 and RFC 8342 have explicitly St that running configuration data store must always be valid and besides that MD also states that intended is subject to validation so there is a figure"
  },
  {
    "startTime": "01:00:01",
    "text": "architectural model of data star figure in MD RFC and it states that intended is subject to validation and there is also some normative text to show that intended must always be valid so some just some quotations from the rfc's so Jason um just on that slide where we're kind of quoting the current um rfc's another another thing we should probably also keep in mind is um just the concept of kind of running code so there are also I mean part of part of the complexity of this issue is that there are implementations out there you know fairly fairly major implementations uh that do have Transformations between running an intend Ed like an active configuration or template expansion and some of those implementations uh you know don't don't uh basically they don't they don't require a valid running on its own like they they they validate uh after the template expansion for example so it gets a gets gets a little bit muddy when you also take into account current implementations that kind of some of them don't really require running on its own to be valid um and there are some imputations that do so I know some client side tools that do expect offline validation to work and they will actually validate and declare a problem against a device if the instance data doesn't uh match up against the uh the model for running so okay that's a good point thank you blash uh just to add complexity and I don't know what is the correct answer there are a number of groups that are speak that speaking about what is the"
  },
  {
    "startTime": "01:02:01",
    "text": "master configuration and they say that the master configuration is not the thing on the device but something in the management system now if we say that only intended is valid I think then we run into problem with this thank you okay so I'm going to I'm going to um split this um issue into two different parts actually it's a from a long-term consideration and a short-term consideration so I guess we uh let's discuss the long-term consideration of this issue first and for the long-term consideration I'm not sure whether whether we should consider moving to MDS interpretation of validity of running alone and here the by long term we mean the young next or NE conf next and R conf and as uh uh okay blash uh maybe coming back to the previous uh comment that if the intended is not visible not readable then at least the running should be valid all the time because you should be able to read at least one of the one valid configuration just saying that something black magic happens inside I don't even tell you what it is and check operational that's that's I don't think that's good okay so I'm I'm going to uh uh the the authors of MDA has maybe has acknowledged that the mda's"
  },
  {
    "startTime": "01:04:00",
    "text": "interpretation from a long-term perspect the interpretation is that the validation is unintended because running alone is incomplete so for the online validation running is invalid implicitly if intended is valid and for the offline validation of running it would require the client to perform the configuration trans information to running this would include the template expansion and inactive configuration removal defined in in in MDA and as well as to uh merge the running into system to become intended and then validate resting intended data store and this is uh easy to achieve for system aware clients but but might be uh need Pro proprietary mechanism to fch system configuration for system unaware clients and I guess uh this is the MDS interpr interpretation about this issue and but let's assume that I think it's fair enough to say that MDA only applies to MDA servers right so a client connecting to an MDI server would know to write thata intended maybe in this case so maybe if uh it's for an MDA server and a client connecting to MDA server there is no issue because it knows to WR that intended all the uh the the configuration transformation and uh merge running to system and then to validate the resting configuration instead of validate the running alone and another question might be whether we want this to be uh to to we also want this to be applied for non-mds servers and I'm I don't know the answer but just"
  },
  {
    "startTime": "01:06:02",
    "text": "just thrw away this question and for your consideration okay in my view there are a lot of servers out there that Implement don't Implement an MDA or Implement only parts of nmda so accommodating them would be nice okay there any other issue any other comment Jason um I've raised this before but and so I apologize I go back to I don't I don't really have a clear solution but I I guess I'm I'm feeling like in a real quandry here because I can see how it's it it kind of uh it kind of offends my engineering sense that somehow running isn't valid uh it just feels like it's supposed to be valid that people should be able to validate instance data that they control back up on the client against the Yang models on the other hand um you know if I if I just ignore a system for a moment and we think about things like uh templates or inactive config which are you know out there in the in the router Marketplace you know I I don't see how it's at all realistic that that we could enforce that running is valid uh when you have template expansion which can which can expand out and and and and actually make the data store you know the actual config valid so I'm it just it feels like I I don't I don't know what to do here it feels like there's no solution I feel like we're stuck we could maybe solve it for system we have a solution for system with this"
  },
  {
    "startTime": "01:08:00",
    "text": "copy into running that I I would I would like to support but then I worry about uh template expansion and you know I'm not sure we can just ignore that um and I don't see how with template expansion you can ever really say running is is valid offline and and I I don't think it's realistic that a client can reproduce all the rules subtle rules of uh you know different servers template expansions it's it sounds simple at first but um I know from being involved in implementation of nokas that there's all sorts of subtle cases um where we might differ slightly from other implementations on template expansion so feeling a bit stuck yes I I would agree with you that I think it's already the case in MDA that running uh because of the configuration template not being expanded and inactive configuration not being removed so running alone cannot be valid that's my interpretation but seems that I I I I don't know I I I don't know the answer but Rob so I I wonder whether one a different way of frame this is to say that it it should always be possible that an operator can manage their system with a running that's always valid so uh so if if an operator wants running to always be valid then they don't use templates they don't use inactive configuration they don't rely on system without explicitly copying those nodes in and then they get the property that running is always valid uh and and intended is very close to running that case as well and that sort of potentially keeps their life simpler and you could have a config knob on the devices to enforce for that and say that's the case but I also see the ability of saying actually for if you want clients want the extra flexibility"
  },
  {
    "startTime": "01:10:01",
    "text": "of doing template expansion things there's some things that have to give to be able to do that and one of the things you're going to lose is is this ability to potentially to validate off the box or you have more complexity to doing that and in those cases I think there's a benefit of relaxing the rule and saying actually it's intended it's valid in those scenarios rather than running so in to summarize or it should always be possible to get running to be valid there should be a way of achieving that but might be some configurations you can't do but uh if you really want to use templates and things and rely on system configuration then those are the corner cases where it may end up not being valid okay yeah thank you so we have been talking a lot about online and offline validation and so uh and those terms are easy to understand and well defined in some way but I think the real problem that I have with this is not whether you can actually validate offline or not it is about the client being able to predict what happens when you write something and that is the real problem for all those offline validation things there's lots of magic going on behind the curtains that's why it's not possible to validate online and we need to know what that magic is exactly so there's basically two approaches to it either we say that we have to Define what that mag is so that we can predict exactly what's going to happen when I say this to you in running and including these templates and in uh inactive configurations and so on I know what's going to happen in intended it sounds like a difficult path but maybe possible or we say that this is not so important uh I mean net conf conf are mostly machine machine interfaces right and being able to have shorthand notations for different kind of things is not that important if I wanted to have a template mechanism I can very"
  },
  {
    "startTime": "01:12:00",
    "text": "well put that on the client side as well I don't need to depend on whatever magic you are doing on the server side so maybe that is not so important in these use cases okay thank you blash well actually be good to know for a specific node or specific server will it produce a valid uh running or not yes if I read that thousand pages of documentation there somewhere is an answer for that but maybe it would be nice to see that as a capability that I can just read of thanks the uh the one slight problem with that bash is if we go with Rob's proposal which is actually kind of appealing to me at the moment um it would depend on whether the operator is deciding to use templates or uh inactive config the server side versions of those features versus maybe as Yan mentioned maybe the operator would instead use the client side version of templates and inactivate an activated config um I'm trying to think what my point was I was going to make now um so so I definitely think that there is um that's point I was going to make was I think uh in this terms of these conversations the templating and inactive configuration is two are the ones that we should consider the other one that is obviously very pressing is the uh is like the key store and things and accessing keys I think that's the"
  },
  {
    "startTime": "01:14:00",
    "text": "one that uh having an answer to would be really useful in the short term because I think the ITF models are somewhat relying on be able to reference these things and those are ones where I don't think it's necessarily the case where you can just say you can do this off the box or potentially ignore it if and K probably correct me if I'm wrong where security best practi is that you keep some of these keys in TP M on the device and hence you should never be able to really uh copy those into the configuration unless they're encrypted just to answer that question um right exactly if it was important to the operator to ensure those uh secret values did not um were were not revealed uh then they should either be encrypted or hidden if they're neither encrypted nor hidden but in the system data store that's not really making them secret um yeah they're built in but they're still visible in the system data store uh and you know sure it it no I I mean it's not it doesn't make things any better to copy them into running but it doesn't necessarily make them worse either okay so what's the the conclusion about this long-term consideration so I I don't feel like uh sorry to jump ahead of Jason here but I was actually hoping you mov the next slide I think it speaks to this okay Jan do you want to comment uh well comment and question so uh I must admit I wasn't I wasn't really I haven't"
  },
  {
    "startTime": "01:16:00",
    "text": "been following this key store work um and Rob raised it as uh a very important other scenario we need to take into account for figuring out what we want to do here so I wonder if others are in the same boat and um I mean I kind of feel like I understand the inactive config and the template expansion stuff but um should we maybe talk more or explain more about this key store thing and how it affects this problem I don't know if others feel that way but Rob if you and Kent think it's really kind of structural for figuring out what we want to do here uh more of us may need to understand uh a little bit more about it I'll just speak to it briefly I I don't think it's fundamentally different um but you know something that needed originally the key trust to drafts were trying to speak to but uh what what those drafts were referring to are built-in uh certificates and or uh built-in keys and so certificates are the easiest to understand uh many systems ship with um you know a set of certificates that like their trust anchors your web browser knows which root um certificate authorities it trusts by default so there's B like built-in certificates um so those certificates uh would be presumably in the system data store and leaf rft uh from or or or the the bags of those certificates would be Leaf ref from uh configuration in running um but that's no different than any other Leaf ref that we've been talking about to date um and likewise with the keys keys are a little bit more involved because well first off built-in Keys um it's highly recommended that any the system if it has any built-in keys at all that they be hidden or encrypted um it really does not make sense for a built-in key to ever be clear text but uh if it were"
  },
  {
    "startTime": "01:18:04",
    "text": "then you know like I mentioned before it it's kind of a problem but it doesn't make this doesn't make it any worse um but the thing is that with keys uh because we spoke earlier about the mandatory tress of that data uh it would be necessary to kind of copy all that data into um running as well but I don't think that the fundamental nature of the cas or and Trust to our drafts doesn't change anything that we've been talking about today they're just different kinds of configuration and just to so the reason I'm saying they're more important is I I can see I can't remember who made the comments that was Yan actually saying that uh maybe you don't need to do this in active config you don't need to do um template expansion because it's a machine to me machine interface and I sort of see that I have some uh a lot of sympathy with that view however having accessing the built-in keys or certificates of the device feels like something that is is fairly critical and doesn't fit into that same category something else where uh it probably really is important and you can't just say don't do this I think so that was why I was saying it's I think it's a more of a critical issue yeah well to some extent it is possible already today if you model your things properly you can do references to you can do template expansions and things like that even today and keep running referentially Integrity okay you just have to I'm not saying you can do everything you might ever want and but you can do a fair amount already as it is today and we can certainly go beyond that and expand this but then we need to I mean the important thing for me is that clients should be able to determine"
  },
  {
    "startTime": "01:20:01",
    "text": "exactly what the device is going to do um yeah I guess on the slide here just reacting to Rob's point you have one and two listed and I guess he's saying that one is not critical to Yan's point the machine to machine interfaces don't have to do these things um but two is something that we are it is front and center and I think this just comes this is the whole discussion about it must uh Leaf rft values be copied into running okay maybe I think we need to move on and then we can still uh continue our discussion so and another question is about can we do this now so that means we don't wait for the young next or n conf next or res conf next and still there are actually I have give three options here and uh here I added another option as option three and instead of uh uh explicitly St that running alone is offline valid or not that is required and option three would like just state that running must always be valid and it would be depend on the interpretation of this statement so three options we are going to discuss blash I think if you go back to option uh option one I think a readable intended must be a precondition to this I don't think that's acceptable that machine does something inside but I don't don't even know what it"
  },
  {
    "startTime": "01:22:01",
    "text": "did okay I don't know if we want to choose this but if we want to choose a read readable intended is a precondition okay Rob I just going to say I also think there's an option for here which is this document says nothing at all about whether running is valid or not so it just relies on uh 7950 and um uh 8342 that and relies on those so it doesn't say anything whether it has to be valid or invalid so I know it's kicking the can down the road and that's what just saying we have to wait to Yang next to fix this uh but that I think is an option actually I think that is option three it it's trying to say just it's kind of it says just State um you know quote running must be valid but it's not saying that running alone must be valid it just it as you say defers to uh existing um loose interpretations okay I was interpreting just St as this document would say running must always be valid and that's the one thing I don't think it should say if that's the conclusion so I guess Rob means we don't even St running must always be valid right we stand nothing about this point correct because you don't need to say anything because that's always that's the default case already is that running must be valid so unless we're going to change that that and say with some Su that it's not valid or doesn't have to be valid then we don't need to State anything at all okay thank you okay so for the option one I I I don't know I should present this already because but for the option one if we do not require running alone is offline valid and we might treat it as a clarification or back fix in existing rfcs but the"
  },
  {
    "startTime": "01:24:02",
    "text": "only concern is that this option might break lexic lines and two chance for example if a client makes an implicit reference to system configuration and there is uh Lexi clients need to do the offline validation of running so seems like a breaking change that would have a lot of impact on the lexic lines and two chance and also if we choose option one I wonder if we have we we need to First standardize the configuration transformation between running and intended for example the template expansion and inactive configuration defined in MDA so blush uh I come back to my previous comment let's say I have an old client I at least like want to know whether the server I'm connecting to will it produce a uh valid running or maybe not which one is it if I can at least know that I don't know clients five and six will always have a Val running then then I can code accordingly but if I don't even know if that's required or not that's a problem okay so if you mean if we allow running alone to be invalid then we at least to know whether the running currently in the server now is valid or not beside the readable intended this let's say indication whether it is might not be valid must be there okay I don't know this applies to Legacy clients and things but my interpretation when we're doing nmd when that discussion was that running is the is intended is always invalid even if it doesn't exist as an external data store"
  },
  {
    "startTime": "01:26:00",
    "text": "and running is valid through implication because you always valid validate intended at the same time whenever you change running and if intended doesn't validate then you reject the change to running so it's it's implicitly valid rather than explicitly being valid that's what my interpret nmda was and I wonder if Legacy clients effectively the same so for those devices that that assumes you're referencing some system configuration um they'll validate it with that system configuration there and say yes it's fine but they won't validate running without a system config I I think there's almost C like Rob I don't I don't think that can be the complete answer for offline like there's definitely so offline includes a lot of people using tools like uh you know Yang Yang lint uh where you do a read of the running and then you Yang lint it against the Yang model that that doesn't work right if we if if it's if if running is only valid uh implicitly because intended is valid and I'm sure there are clients well I I know there are clients that uh that that do a get config of running and complain if it doesn't match the Ang model so there may clients that are okay with uh implicit running validity through the server saying it was it was okay but there's definitely ones that uh clients and tools in use that uh that would be broken with this I think my respones back to bel's comment I think that's what I was trying to reply to which I think was on server Behavior okay then for the option two is that we require running alone must be offline valid and the question is are the"
  },
  {
    "startTime": "01:28:03",
    "text": "complexity necessary even for the system configuration only the parts that are required to make running valid need to be copied for example the key Noe so only the parts that required to make run valid need to be copied not all of the parts of the system configuration and uh the the second part is kind of the the discussion we had um just now which about the server migration of some system no into running when the device upgrade but now I think we agree this should be out of scope and the third point is about uh I think is also touched by Jon just now also it's about how to handle the configuration templates and in active config figuration if we required running alone must be offline valid and for this option I think there is no um NBC issues seen so it's the option two and then for option three I think maybe it could be uh treated as a possible compromise and even the option for uh suggested by Rob just it mean just state that running must always be a configuration data tree and add reference to RFC 8342 and 7950 and all just do not even St this at all so this way we don't have to St explicitly whether the reference system node must always be copied into running or not so this would leave it up to the interpretation and this keeps the behavior as existing uh specification s okay blush for me the difference between option two and three is far from"
  },
  {
    "startTime": "01:30:01",
    "text": "Clear if it must always be Val than that yeah yes yes yes I agree either there any other comments yeah if you go back to option two I'll make a comment there so here I mean I think it's perfectly right from my perspective that you only have the keys to those system things and the system will understand what to do and the client will understand too as long as we still mean that okay if you have a model which says that some attribute is mandatory in whatever you are creating there this list entry then of course that needs to be copied as well not only keys but if you model things that everything is optional below this point I'm perfectly happy but I still want traditional Yang rules to apply okay yeah just just say I agree if we're if if like so if we're going with option two or even option four in option four where there's kind of flexibility um I think you know in scenarios where someone wants running to be offline valid uh then it it doesn't I know we keep saying keys for Simplicity and discussion but I think it it it means Keys mandatory nodes and potentially other things to satisfy must statements Etc yes that's right just an example to use the key node if there is any other referenced no like mandatory tool and where must State uh statement be present at system configuration that should also be copied yeah Min elements is another example oh right right yes mean element I think the most difficult would be that you have to analyze the X part in must"
  },
  {
    "startTime": "01:32:01",
    "text": "and when to find out what it is referencing uh when blah says that we must analyze the EXP paaths I I I'm wondering who is the Wii in that statement um because I don't necessarily think um any you know tool needs to do this other than if they if I I if the interpretation of specific server that running alone must be valid then um if if I mean it if the operator doesn't copy enough data into running and then they try to validate the server's going to refuse it'll just say you haven't copied enough data and um it's up to the operator or maybe I mean I was going to say the operator the human in the loop but possibly we could extend it to the controllers as well um just need to keep you know adding more data into the running until it becomes valid a a warning message a meaningful warning message that points to exactly what the issue is uh might be difficult I mean we have the validation constraints and they'll of course flag you know what the issue is I suppose but um I mean it it's not it it it might be iterative they they first try just the keys and oh it's not enough there's a men element constraint so they add more men elements and oh it's not enough because it's mandatory true so then they you know just kind of iteratively they would finally get there it doesn't sound elegant but I think um that's what we"
  },
  {
    "startTime": "01:34:00",
    "text": "lead would it would lead to so one thing uh Kent along the lines of what you mentioned of adding more data you know otherwise it would be invalid um I mean currently I'd say uh the way this is kind of happening at least in a number of the major uh router implementations I'm aware of is that the servers are typically um uh they're they're validating intended um but it's actually um clients and tools that are trying to do the offline thing that are declaring the invalidity So when you say you'd have to add more and more data until the server accepts it I I think it's actually the way around I think the server will always accept it you the operator would end up adding more and more data until their offline tools are satisfied so I I I just flip it around there I think that's that's the way I would see it working based on the current implementations doesn't preclude adding a mode in a server like I don't know strict mode uh but I can immediately see performance implications of doing a second validation so like in our implementation if we had to now also do a second uh you know strip out some data and do a second validation that's going to be costly from an Performance Point of View so it's the second validation happen on the client on or on the server it's offline or online validation well I don't think we need to preclude or mandate this second validation personally uh all I was saying is in k example where you add more and more data until something is satisfied I don't think it's the server that gets Satisfied by adding more and more data the server would always be satisfied all like most servers today"
  },
  {
    "startTime": "01:36:02",
    "text": "are fine they they they actually validate their intended after template expansion Etc I think it's more the operator to add more and more data until the tools or clients are satisfied okay yeah yeah so we keep referring to these two main options as online and offline validation and I think that's somewhat unfortunate because I mean of course we are also validating offline and but that's not the important point and if it's happening twice or not that's not at all the the issue that I'm concerned about it is the perfect understanding of I tell the device to do this what it is going to do that is what I need to have answered and that unless we get that pasted we don't have to care about vitation offline or on or otherwise Rob I'll uh turn my mic on um I was just I was just thinking about the inactive configuration as an example so if you take that then I can it makes complet sense to me to validate what does the configuration look like with various bits of configuration commented out it makes less sense to me to say and you must also validate it with that inactive configuration being active so you need to say that you have to if you add in configuration here you have to both make it valid for the stuff that's commented out and also that configuration is not commented out which is what effectively think making running valid and intended valid in the case that you have inactive configuration and the answer may be don't do an active configuration but"
  },
  {
    "startTime": "01:38:01",
    "text": "otherwise I don't see how that actually works um I was going to respond back to Yan's point but just quickly on Rob's I guess plus one to that I guess now that you mention that um it's not obvious that that uh it's easy to construct things that they're always valid whether the inative config is there or out uh I don't know maybe that that could that could get tricky um and the same May apply to templates I'm not sure um but Yan I was going back to your point because I I'm hearing you um kind of mentioned that you know offline validation isn't the key it's understanding exactly what the server a client needs to know precisely what a server is going to do um I'm not totally following that and how it's different and I'm hearing a lot of Silence each time you're saying it so I'm worried maybe uh that's similar with others in the group um maybe you could give an example of of what you mean there that's different than offline validation Yan are you on mute I'm just waiting for the Q to speak okay um yes so I mean I think I think we are in almost um violent agreement about about validation and offline and all these things it sounds to me anyway uh I definitely think it's a problem if we remove offline validation possibilities but I don't think it is the main problem because I mean and I didn't want this conversation to diverge into those"
  },
  {
    "startTime": "01:40:01",
    "text": "things about performance of validating twice and stuff that is may be important too but in my mind it's much much more important that we solve the basic integrity and understanding as a controller I want to be able to control and tell the device this is what you're supposed to do and if uh if running is the whole truth okay it's kind of simple I write this uh there's some validation going on on the server and then if if that goes through it's going to do what I ask it to do if the server is not going to act on on running directly but on intended okay sure then I have to sort of reverse engineer uh what intended what I need to tell you as a server in order to get what I want into intended uh if that is a blackbox that's a problem is that better explanation now BL go ahead so that's why one of the reasons why I said that if you want in invalid running you must have a readable intended and a side comment which I know many people don't like but all these difficulties about offline validation what is valid that's one of the reasons that many groups actually have allow the system to modify running and that's a valid Community still because yeah these are complex questions we are discussing and they want to start wanted to sidestep that thanks uh responding to Yan first the uh the concern for whether or not the controller can exactly tell the um server what to do and I think the comment was a black box we definitely uh I I don't see any um anything that's not programmatically uh exact the the"
  },
  {
    "startTime": "01:42:03",
    "text": "blackbox uh I mean ideally um ietf standardizes inactive configuration and some kind of templating mechanism someday but in lie of that if we're working with a vendor you know proprietary um equivalence which do exist today um the vendor would have to publish uh documents that describe how those mechanisms work um and but in case they don't or if those documents are incorrect um not kept up to date maintained something's wrong unclear whatever the case might be um then to bash's point which I was originally not keen on that um that if running alone is not valid then uh sorry intended must be readable uh perhaps that becomes a more true statement um I wanted to go back to uh a point that Yan made about so I think I think yanan's argument is effectively that we should change the data models such that uh running can always be valid so I think that that says that in the case of ones where you got keys and you're and you're writing to an inbuilt key or access or reference that in inbuilt key with a leaf ref then you have to be able to express that reference without any dependency on like mandatory children and I I I just I'm worried about effectively that we are changing what is semantically the actual underlying data model is we modifying that um so that it fits this Paradigm that running is"
  },
  {
    "startTime": "01:44:00",
    "text": "always true so you say actually going to take this maning statements away so that we can represent keys that have no uh uh no public or private data because we want to be able to reference them by name without uh uh without breaking this rule but at the same time that doesn't actually make sense for key that you can't really have a key that doesn't have private data go ahead Yan I guess I'm in line then yeah thanks so I mean we could even invent new or I mean new reference types we are using Le today and they require things to be there in a very strict fashion but we could invent a new one in a draft document or a separate document RFC such and such uh here's a system default kind of reference that will point to things in this table over here or something I mean we can create additional things in Yang to express these ideas without watering down what we have already so just rep that's sort of true and you can solve that but it still fundamentally means that you just take the contents of that running data store uh and try validate it without access to the system data store whether it's on on the box or off off the box then it wouldn't be able to validate you still got some dangling pointers there and it's whether having those dangling references is logically acceptable or not I think well there's no way around that I think since the system data store isn't known by all there will be dangling references for those that don't see it but if you do know about it you could certainly do more with that sort of special kind of system reference type I'm wholly opposed to the idea of"
  },
  {
    "startTime": "01:46:02",
    "text": "for instance a key being copied in a running without its mandatory Leafs uh that doesn't make sense to me at all I Rob I think you're exactly right in your ad0 reviews that that the uh the data model should be you know accurate to what the data model should be regardless if uh you know uh if the you know to to support the scenario where it might be copied from system so um and and somehow it not being a complete object in running makes no sense to me I I think um really it kind of goes back to the question that uh chiffon had was can we do this now or later um absolutely we can do it later absolutely with Yang next and Ne next rest conf next we can assert that clients must be able to do the offline transformations in order to uh offline validate running um even though it's not valid validatable alone uh so then I I mean that's my assertion I think we absolutely can do that uh in the next series uh but the question is can we do anything now um and you know we leave it up to interpret the three we had the options maybe the the three options slide would be a good one to put on the because ultimately that's what we're trying to answer in the remaining 13 minutes of this call i' propose we kind of I don't know what others think but I I propose we kind of abandon option three and instead look at one two and four or four is say you say nothing because I think we already maybe kind of agreed that three was going to be a bit confusing and and maybe what we were kind of meaning by it was just just to say nothing I know what other think"
  },
  {
    "startTime": "01:48:00",
    "text": "others think about that yeah I option four is a better option three in my mind agree so so my preference is that we we effectively say nothing now and we rely on what's in 7950 in 8342 and that when we come to look at Yang next we add an issue specifically to consider this and see if if there should be either changes to whether running is always valid or whether we should add extra uh Yang rules or Primitives in there to to be able to model this data in a way that's like not man true but mandatory in in intended true but doesn't have to be mandat true in running for example or or something else or or different sort of reference that the Yang mentioned so I wonder if when yang. Nets we could flag an issue for this and then not worry about it now we just say nothing and servers behave the way they do today in a sense and they follow the rules they don't follow the rules tyon um I I think I'm kind of leaning that way as well and because I'm still I'm still stuck on the fact that we don't we don't have a clear a clear Direction one way or the other and I think it falls into the suggestion that Rob made um and I'm not sure if there's any text we want to say about it maybe maybe not at all but that if an if a user an operator is working in an environment where they need running to be valid uh then there is a way to achieve that but they have to make some choices to not not use templates in a way that"
  },
  {
    "startTime": "01:50:00",
    "text": "makes running invalid not use expansion in a way that makes running invalid and they would have to copy stuff into running to make it valid I think that is actually the Practical approach that is possible but you know I'm not sure if operators are going to run it because it puts a little bit of onus back on them to make those choices and on them to keep the running uh valid for their tools or their environment yes we can do that but we just keep silent about whether that is always necessary right you you the client and operator can do that but we do not stud whether that must be down or should always be done Shan I'm curious do you have any more slides in your deck just want to make sure we get everything okay let me check okay the the I think this is the the last slide but maybe I I mean if if we can reach any agreement and have it explicitly St it would be good but in see it seems not seems that we are not ready uh now for this to be done so and we if we agree to use the option for then it's okay for the authors and then maybe we can consider to update the 8342 and 7950 in the future when once we feel we are ready to do that or we have more direction to do that that's the last slide of my presentation I took myself I never left the queue but then I came back um the second po point is interesting it says uh should 8342 be updated to clarify and I think these"
  },
  {
    "startTime": "01:52:02",
    "text": "clarifications aren't specific to the system um you know config draft but in general like there's seems to be some in um misunderstanding with regards to what nmda was trying to say and it it almost contradicts itself with statements about running must be valid and yet intended is subject to configur uh to validation um a in you know as a completely separate activity updating 8342 to make clarifications so that we don't have to come back to this would seems to be that would be helpful okay I that may be true but I'm not sure that's going to be any easier than the discussion today I mean I guess we can take it off the plate of this draft uh but moving it to a different plate I don't think it's going to make it any easier or faster I think we should State whether updating the 8342 is it a condition for this draft or is that a separate task and I think Qui probably like separate TK better yes I tend to agree I think it's a quite fundamental concept regarding young and that conf and should not be limited to the system configuration and thus maybe could be discussed separately right uh yes I also agree that I don't I think it's best if this one leaves 342 and 71501 well actually I think it can update 342 to talk about how the system data stor is uh is in is connected in but I don't think it should be updating"
  },
  {
    "startTime": "01:54:00",
    "text": "to change the behavior of running I think that's that would be best done in Yang next yes sorry Rob I don't know if it can be done in our uh 7950 Biz because uh 8342 is not the on it uh I think 7950 bit because could always update 8342 that would be allowed I think under the rules don't think you I don't think there's anything would stop that I'm sure whatever the process is that could be done all I'm saying is I don't think we should have a third document sort of update either updating running or restating that running is always valid I think that would just make life more tricky in the future because we got to update more places a few places we say it the better and then if you have a separate document then you can have the option of support that or not so that's not a nice idea okay good point um Rob and blush we can uh hold updating 8342 till later um okay so uh five minutes and I think we've come to final conclusions uh but I want to just ensure chiffon do you feel um as you know authors that questions have been resolved are there any open issues that you you want to think some more or you need more discussion yes I think uh no actually I think all of the uh open issues should be resolved today and really good discussion so the authors are happy to make updates according to the discussion we have today that's what I want to"
  },
  {
    "startTime": "01:56:01",
    "text": "say excellent that's the outcome we we wish to have um so in terms of unless anyone else has comments to make uh next steps would be to uh an update to the draft and then um hopefully we could run it through working grou BL call and I saw in the chat that Rob suggest that the draft should perhaps update uh 8342 to clarify the system origin and I that that's right and I agree so it will be reflected in maybe in the next verion oh it's already the case that the draft updates 8342 but maybe the origin handling need to be clear okay okay well thank you everyone um I guess we can give back three minutes very much appreciate everyone joining and and Lively discussion it actually carried on longer than I expected um or Lou and I thought that we might end earlier but uh it apparently we had a lot to discuss so I'm very appreciative to uh chiffon and you know preparing these slides I think they were very helpful and um and uh and this is why we do virtual interims right because the 10-minute slot that we have in the meetings just aren't sufficient to get this to this level of detail so thank you everybody have a good rest of day thank you bye all bye thanks bye thank you bye thank"
  },
  {
    "startTime": "01:58:05",
    "text": "you"
  }
]
