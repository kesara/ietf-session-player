[
  {
    "startTime": "00:02:11",
    "text": "Good morning, everyone. Oh. Let's mute the computer. Okay. Alright. Welcome. To the second part of Http this at sixteen. U. Hope everyone had a good week so far your almost at the end, just two more two more sessions to go. If you hear last time if you're at any of the other recessions, you should be familiar with a know well. This is the terms under which we participate and contribute to the. Please familiarize yourself with them. Do we wanna look at our agenda. We do have a note taker. Thank you, Eric for doing that. How do we switch? Okay. Cool. So on our agenda today, we have several items that are adopt it already. We're gonna start with presentation on uploads. Mark's gonna talk about some structured fields drafts, and then we're gonna have a longer discussion from Mike on all service. And then at the end, we do have some other proposed work around Websocket discovery, Connect proxy and Http availability. Alright. Sorry, we're having some mid echo issues. So if there's any agenda mastering, let us know and I think there's also a one extra thing that Mark wanted to cover for the group. So I I'll I'll just let's at at the beginning. Just so folks who are aware There was a presentation this week in the Http Api working group. Oh, look,"
  },
  {
    "startTime": "00:04:02",
    "text": "Meetup who's coming back. Oh, that's you. Okay. From Austin right, who's appeared the front And and I guess there's a couple of different ways you can look at this work. One is is, you know, how do we do a bike range update or or or, you know, patch or or or whatever of a resource. Which is, of course, deeply integrated into http and we have probably lots of things to to to to say about that. Another way of looking at it is is that you know, how do we create a new patch format you know, by payload that that happens to use a bike range like mechanism. And so I I didn't get that clarity of which end of the spectrum was on from the discussion I think Austin still thinking about that. But I wanted to make sure folks here were aware because especially if it's getting into the content range mechanism or relating into that or or or saying well, this is the best way to do this particular thing for H. I think this group would probably want to be involved in that So Austin, I don't know if you wanted to say anything else, but I just wanna make sure folks here were aware of that discussion and and that it was, you know, undoubtedly, the H Api chairs and tommy me, I will have a chat if if we feel like there needs to be coordination or if the work needs to happen to one place or another or whatever. So Anything else or at the mic Or this one sure? Yeah. I I brought the range patch to H Apis. I did some form jumping. It the mechanism, I hope will play in a little bit to the next agenda item which is both. Thank you."
  },
  {
    "startTime": "00:06:00",
    "text": "And the central mechanism is creating way to write to a specific byte range in a file, which is essential a lot of working with lot to file media types. But it could easily be purpose for Like, pending to streams or know, if you need to pick up an upload to a stream at by offset, two thousand bytes. You'd would be able to use this media type with a patch upload to be able to signal that. Something that I think would be really useful for next to agenda item. And The reason it might be a little bit of controversial is because at least one of the the media type formats that I'm proposing uses the content range header as it would which is already permitted in R twenty one ten with a put request but it also proposes to do indefinite length requests, which is not something currently permitted. So there might be some there is a little bit of overlap with Http Potentially, at least. Thanks, Austin. So yeah, well just wait for on that, but just so folks where at this point. Great. So let's get started with uploads. On Hello hello everyone. My name is B, and I work at Apple. Today I'll be representing the upload draft, guy and Mari couldn't be here in person. So I'll be presenting the updates. So what's changed since the last draft?"
  },
  {
    "startTime": "00:08:02",
    "text": "There two major changes. First is the use of server upload which replaced the client generated tokens from the previous draft. And the introduction of a new header called upload incomplete, set defaults which is used for advertising flight support. More updates, there's now test dot net experimental server support. And Apple is actively investigating client implementations. Piece moving on to open issues, the first... There there are two major open issues and first one that's being actively discussed is how does client advertise support for uploads. Doing this via the expect header doesn't seem to be a good fit based on the discussions right now. The preferred header is still being discussed. And there's also the introduction of the new header. Which the draft calls upload incomplete, which is which one set to false. It's double navigation and it's kind of hard to Comprehend. So maybe it's as I think Guy is suggested in the discussions to rename that to upload complete. Yeah. Just out of curious do we wanna have feedback and discussion on these as we go through them know, I think we just have a couple more slides for the different issues or do we wanna come back? I think I'll come back because that way, other can jump. Q online. The next open issue is what happens if a client receives of five hundred"
  },
  {
    "startTime": "00:10:03",
    "text": "from either the upload creation, the procedure are upload. Pending procedure. Should it retry. One way of solving this could be to use the upload complete header mandate that in all the server responses. That we if a client gets a five hundred and the upload complete is set to through the client should not retry. Next slide. Please This is just a list of other things that are being discussed right now. First is hash of uploaded files Second is prioritization of concurrent uploads, which sounds mostly like an Api issue or, like a client implementation saying that may not be part of this draft. And two others Z mobile upload with phones and upload progress where informational responses, which sounds like a good thing to do, but doesn't look like it's gonna make it to the first draft. And also we need to sync up on the quite range the the patch mechanisms, and I'm sure go and others will be talking reaching out to you on that. I think the next next steps would be to close on these discussion items and get more developer feedback. And incorporate that in the draft moving forward. Questions. Do you we have specific smartest. Hello? Hopefully, you can always us in. Building the issue about the error response would say like, for my feeling of"
  },
  {
    "startTime": "00:12:01",
    "text": "using removable uploads in production. If the client receives a five hundred or something similar and it doesn't indicate that the upload was complete. Then I would say, you know, this could be some intermediate proxy that has responded with an arrow. So I think in that case, it should be retry. Because the client couldn't confirm that the output was complete. And therefore, it should, like, retry as specified. One having having this indicator from the from a proxy or something that would be very very unusual, I would think. I imagine that in in the case where you you got an error from a proxy, and it indicated that it had completed the process of uploading, which is essentially what what this is supposed to indicate. I would ignore that at that point. I would not believe it. I would not believe it if the server did that. Okay. I'm looking for it. I would be looking for a two hundred series response with with this before I started paying paying attention to it at all. Alright. I did wanna briefly coming on the use of this label one requests. That's going to be quite confusing. I think. Because as it is used by the server, it's it's a statement about the the the conclusion of the process. It's saying that this process has concluded. Whereas the client saying this process has concluded even before starts that process. Is is odd. I think Got it. Yeah. Yeah. Yeah."
  },
  {
    "startTime": "00:14:04",
    "text": "Right. So Thank you for making progress. Regarding to you want to that we're having just making comments. I think it's a good idea to provide the response from the as we have in the signal little modify pointed it out. Probably my make I mean, to me it since that probably makes more sensitive but in the body rather than the header, I'm using a head request. Also, I think that probably we should have a tutorial section saying that the response has to be cast by the server because the client might after pulled then the collection guys under then the client has to refresh the response. For time think I would it'll be good idea to have some up or like that, but this Thank you very much. Thank you. Good. Thank you. Alright. Next up. You marks Try and share my whole screen and see if that makes it bear with us on the mid. It's doing some interesting things today. Of the simplicity of h. Well, we don't necessarily need to to I'm I'm just gonna go over the issues and and and so forth. Yep. Yeah. It didn't work. Okay. So the first spec to talk about here is structured field values this."
  },
  {
    "startTime": "00:16:05",
    "text": "We we through a number of the issues on this in the last few weeks. And there's currently... The editors draft reflects all those changes. We missed the submission deadline and I have neglected to push the button during this week. So if you look at the draft, that should be up to date. I'll go ahead and put the button after the session. So we have a current draft. Once that's published, the only open issue we have is twenty three forty three, explore the solution space for for non ascii characters in strengths. And so for this draft, you know, since I'm editing it, Tommy is asking... Is acting as the the sole chair for this draft. And in consulting with him, his advice was that the... Because this issue do was out of the scope that we agreed to when we opened up structured fields best. We'd hold off on discussion of it until know, last call and see if it comes up during the last call. So I think we're pretty much at that time. I I still hear a little bit of back and forth about the date type and and and whether it's going to be used, but I think we have pretty consensus in this group that it's it's in the form that we that we want to be in. So that that seems to be concluded. And and so I think the next step I'll press the button on this spec and we'll initiate the working group last call. For the spec. I I don't know if you think it'll be useful to discuss this issue hold in this meeting or not or If we can get if people do have any particularly strong opinions that they'd like to express now. I think that would be useful since we are in the room and here and we can potentially have a higher throughput discussion then on the list."
  },
  {
    "startTime": "00:18:01",
    "text": "Okay. My name is martin Introduced and those who know me will probably guess that I have a strong opinion on this issue, There are very very few to header fields where there is a need to actually have non ascii characters. But In those cases, they have an eat and they kinda Well, they missed master... Yeah. There they're for different solutions there and it's it's not it doesn't look good. And Hd behavior actually from the start predefined this One, which was at the at the time when league came up with Http was kinda only the game or the main came town so but it would be good to be could fix that And what I was a little bit disappointed is that when this is this issue was discussed on the list I don't want to... Say which edit say with thing, but The edit said things like well I have problems with my own email and I I get we get things non ascii characters Are messed up, And if that's the case, this editor Maybe should should somehow update is software because that's not how it works these days. Yeah. It looks much better fortunately. And I think the other editor said something to to the point like"
  },
  {
    "startTime": "00:20:01",
    "text": "I don't want to people to use non ask characters where it's not necessary. And it's in most cases, it's not Necessary and I gave you with that. But then he said well, And in order to make that even just this case stronger I wanted to be that there is a mess and people don't really know what the solution would be and on. And I think that's not exactly what the Is about. Okay. So Thank you. So speaking as the other editor in that scenario, I'll let you infer who the first editor is, I guess. I don't think I said I'd prefer to be a mess. I I I just... I have reservations about making it too easy because, you know, because of the history and because that we train developers, people reach for uni code by default, which in many contexts is a very good thing. I I think in the context of Hd we head of processing for for protocols. It is more complex or or or or or or Nuance than than most people realize. I'm not against enabling it if if we need to enable it. I I think it's just our our current Solution for it is is that you use either a a a binary or you use a, you know, string with a particular encoding like percent coding, which we had in another back and then we ripped out it at a letter point. I... You know, the the other solution that would be on the table, I think would be to add a new type just is we've added a date. Two structured fields to handle uni code characters and encode them in some fashion."
  },
  {
    "startTime": "00:22:03",
    "text": "I think there are there are a lot of arguments for against that having one way to do it is something that Julian would like to see and I can understand why? Because we did have a a preferred way to do that beforehand or a c sixty, whatever it was. For for Parameters. That was just for parameters, unfortunately. So so we we could do that. I guess the concern here is is that when we open up this work, we scoped it pretty tightly. And that adding this I think technically is not terribly difficult. Whether it's gonna entail a tremendous meta of discussion in the group. Is maybe another thing. And I think maybe the high order bit decision here is do we do it now when the spec is open and reduce the number of times we have to iterate on this spec do we say we'll do it in the next iteration and and give ourselves more time to to discuss it properly and and because a lot of... When we open this work, and I think maybe Other big piece of information is that lot of people wanted it to be done very quickly. And and that's why we that that was the context of why we did this. I I think that's the decision that we have is is no. If we're get. We're going to do it, We do it now, or do we say we're gonna do it later? Martin. You know, I'd like to have a discussion about the discussion that we're gonna have to build a plan to discuss the to discuss that in we can drive. thing. We need On a top of the issue. I I think we should I think we should do this. I think we should do it. As you say in a in in a raised fashion But let's talk about the issue right now. Right here. I think we have a number of options in in front of us. We can we can look at sort of escaping system or encoding or what have you. That's on the sort of end of things that We tried before and"
  },
  {
    "startTime": "00:24:02",
    "text": "it's ugly and people don't really like it it hasn't worked out particularly well. We can go the complete other end of the spectrum and say, Look you can just for uni code in the strings. In structured fields. It means that new structure field pauses will generate and accept uni code and all ones will be in an interesting position. So has some interesting compatibility concerns that we we might wanna work our way through. We decided that when we had a date there were some interesting implications for for pauses, and it meant that new specifications were the ones that could really up the new type. With that with any expectation of interoperability. And then it's sort of the third option in the middle. Which is to define a new type that allows you to do strings with coding, which has much of the the same properties as the dates. Mute new deposits would be able to do the new thing and all pauses when and and you'll have some surprises in those cases where people sent the new thing, then you type into the old parser, but that's not a big deal. I'm not particular concerned about that When we have some tech draft, but deals with this particular problem. So I kinda like that one. Was originally a big fan of the of the the just shove the unit code in there, that seems to be the approach that some head fields have taken on the web. Out of our control perhaps, but that's how the... I think content is position. Is one of the ones that that works that way or is it location? Its location. Location will take free unit code in in browsers and that's not great specifically in browsers though. Yeah. I I I specifically said in the web and I web not just browsers. That's not great. Well, we don't do it because wanna do it. We do it because the service sends us these things. Right?"
  },
  {
    "startTime": "00:26:02",
    "text": "And for some reason, we'd to learn that sort of thing. Thank you. So I'd like to set those options up, if you can put them on the screen, that'd would be awesome. If you can't, well, thanks medic. Can. Yeah. But I'd I'd like to have a discussion about those options and say what people think about them. Now I I don't know if you have time for that here. We're running out of bit rapidly. Okay. Let's got man. So so if I can respond to that briefly, you know, to get my cards on the table, I I think I agree with you I think the right thing to do here. Is to define a new type. I I kinda did a thought experiment of that. Using the presenting coding approach that I had out in the h Back. It's very simple. It... You know, it looks like structured fields it works. I think the problem here is is that this is a contentious topic. There are people who think the right thing to do is is to just of uni code into the headers. And that is a very complex and probably contentious discussion that is not gonna end at any time And so, you know, we do need to talk about we're gonna to talk about because some people came into this whole endeavor with the notion that we were gonna get done quickly. Let me briefly respond that. I think we have this discussion we resolved this discussion at its at the pace that it resolves itself. And if it does resolve itself before we get too far down the path on that, on the revision of the document, we we can talk about bringing it in, but we don't we don't proceed with yeah eighty nine forty one beers. With the understanding that we're gonna include the string thing. We just go ahead and publish it. And we'll do a revision like next week if we have to you're saying launch the working group last call keeps keep processing going, but see if we can resolve this in meantime. Right. And if we come up with a solution really, quickly that that makes sense and has long agrees that it goes back in, we just we we just think that's what you wanna It doesn't sound I was leading to. You,"
  },
  {
    "startTime": "00:28:01",
    "text": "We do last call it yeah it wasn't in the scope. Can always revise more And if we'd all agree, we can edit it in. What did you wanna Okay. Yeah. So first point, I wanted to apologize to mark if I that I somewhat side to him not exactly correctly. And second is that I'm personally fine with in both in terms of technical under in terms of procedure either to do it in a quick thing after this one, or to do it with this one will managed to be even faster and also in terms of that solution that we take I definitely a person would prefer to have faith, not just uni because that's Yeah. Yeah. I know that mean it. But but that's not that's not it if if people say we want something different and let's do that when if that gets consensus. Thank you. Thanks, Martin. No no offense taken for what it's worth. I I would note that if we do decide, you know, if if we are able to come consensus that putting Ut f in and hers is right thing to do we'll need to open up ninety one ten as well. So that's the end of the queue Julian, you had been in the queue and you turn on your audio and I muted you, but would you like to speak? Yeah. I shoot myself several times because lots and and martin were saying the right things. So"
  },
  {
    "startTime": "00:30:05",
    "text": "one one thing I I wanted to reiterate that When we had to speak discussion in November, I think, one thing that we've actually found all this that the ex model of structured fields not as was not as clear as we saw it both. Meaning that it turned that's actually modifying smart fields and implementations a bit harder than expected So I I think we met made good progress on clarifying. That's so I'm not that's concerned about future evolution anymore as I was before. So if we are saying we can't with right now you may want to look at this because as a next step, that's good. While I'm on on the q I'm bit that Martin was still saying you have the only sensible option I guess we should probably have for those who are actually interested in this maybe a design team make a comment from proposal and then come back to the broker group. So that's we don't spend too much work time coming up as a single proposal. And that's it. Cool. Thank you. So I'm hearing is I will do the last call and let's in parallel kick off proper technical discussion on this issue and do the work. Move on No. Right. I think that's that covers structure fields Yes. Don't have anything to say on retrofit? Sorry. On right richard. So the retrofit spec is the next one and that's"
  },
  {
    "startTime": "00:32:03",
    "text": "in much the same state. Almost all the issues been closed. I need to publish a new draft. I think it's it's more straightforward. The only issue that's remaining is twenty two eighty, which is to add mapping for the authorization and W w Authenticate headers. And I think we we got into a discussion where you know, because these... This is a very ex field, you know, they're different schemes and they have their own syntax and they're own and and their own especially parameters for example, and those have different types. I felt that that they a... If we were going to do this, we would need to create a a mapping that included scheme specific information. So went and en when you see this parameter or the value has this type and so forth and so on. Other folks didn't seem to think that that was necessary. So I I think that's the sticking point on this one. We could publish this spec without that, and of course, another spec could go into that detail and maybe that's the right thing to do here because this spec doesn't... By its nature have to be completed. Just has to be a start of, you know, this this idea of retrofit headers in structured fields. Does anybody have any thoughts about that? Because, I guess as an editor, my my end inclination is to close this issue and and go to working group last call. And sorry, I'll I'll paste the link since Although we're now having trouble with both with Mid and Github. So Yay Friday. Let's see if Z still works. Any comments to this is essentially should we retrofit. Authorization and authenticate. Like Mike Bishop. I guess by inclination would be that if it's going to be"
  },
  {
    "startTime": "00:34:00",
    "text": "fairly complex to not just to do it, but to known for right. We're too late in the process for that and maybe it's better to do that as this draft. Although I'm aware that pushing additional is cost money, but I don't wanna hold this one up. Just as individual here I think this issue is filed in some of the discussions that Chris and I were having for, you know, some new off schemes, etcetera. I definitely appreciate that. New all schemes even the existing ones can have you know, different interior formatting. So being able to fix this holistically as tricky. Do we think there's anything we could do at least for, like, you know, as we are defining new off schemes give advice for how they represent things because you, at least let's say the actual scheme itself is a token or we we we we can retrofit that part say. And there are other things And if you're writing one of these, have to do that. And so we don't try to the existing ones, but maybe just give something So that new specs can reference it and not to say you're in the wild west. Right. I mean, certainly, we we... The kind third we could do this would be to just to find the fields and say that, okay. We're gonna define the mapping for, let's say, basically can digest. And, maybe bear or something, you know? And and any other scheme either has to define its own mapping where you can't use it with this this retrofit header. I think that would that would be workable and and"
  },
  {
    "startTime": "00:36:01",
    "text": "pretty safe to do. So that... I think that would lower the bar for new schemes be able to do that is what you're saying. And that's that's not a bad thing. But... Yeah, if we try to be completed about it, I think that's a lot of work and and as Mike points potentially a lot of risk. That we're doing it right This does involve kind of a background concern I have about this back that... I think we can address, but but by defining these mapping and... And and and now whether it's the compatible router or the mapping that we have in this back we're implying that fields are future extensions to those fields are going to work. Within the constraints we're setting. Or at least have a good chance of working. I mean, the whole concept of retrofit is is that if parsing fails, you fall back to, you know, or you can't in letter. You fall back to the quote unquote normal representation, the non structured representation. But it does kind of imply some it has implications for for the ecosystems that are using those headers. And so for example, when we did the cookie work I went and talk the cookie folks to make sure they were comfortable with the fact that we were saying how to interpret or how to represent the data structures that they have in their fields. In separate structured fields. And they were comfortable with that. That that's good. But I think we probably need to do a little legwork work in working group last call. And talk to the other communities that there's much might touch upon to make sure they're okay with these implications. But the... You know, and and that includes I think if we do dub up authenticate the the security folks who are using this. So, yeah, all that said for this issue. I'm I'm fine with that third way. I don't know if Mike if you have any thoughts. But that that seems reasonable to me. Julian. Sorry. It's still don't completely get why you're saying that speeds all scheme specific mapping for structured fuels. Right now the cost schemes in texas essentially a scheme plus parents and both"
  },
  {
    "startTime": "00:38:01",
    "text": "Let's saved toll springs. It's essentially the same type of grandma as in edge control. So if we need as all schemes by we not we have that structural So what if one of those tokens is an integer? Julian. Yeah. So what I don't don't... Same question for cash control. Pest control is controlled by registering and so far. We haven't had choose with with the mapping there. So so what I'm trying to say is I think you are all with the issue. Because we already have of relatively flexible syntax for our schemes, although It's bizarre wire. And order here that we need more than talking and spring and I'm not sure this is true for our schemes. And if it's true false schemes then probably is true for many other fields where we don't have a either. So So I new. I I agree with you. I'm I'm not sure either. I I I... But there are a lot of what schemes out there that aren't well documented. And I'm I'm just concerned that we're gonna come across the situation where one of them passes a token that is for example, the number one followed by some some characters, some some, you know, letters or or a hyphen or whatever. And that will fail to par as a structured field. But it's completely valid by the semantics of that particular ot scheme. And I I don't know if such a situation. I can go and try and find it in the existing registered"
  },
  {
    "startTime": "00:40:01",
    "text": "schemes. But, you know, you mentioned cash control. We we have a pretty good sense of what is gonna be in a cash control header because we control the registry. And there are relatively few un cash control. Directive. All schemes are a bit more broad. And so I wanna be careful before we make assumptions about what's in those data structures. So I'm I'm perhaps I should go off and and and look around a little bit more and see if we can find some examples. Illustrate this join. Okay. So when don't we try and resolve that a little bit more and then we'll go to work last call? That makes sense. Okay. Okay okey Okay. So next up, I think we have mike. Mike you wanna wanna share from your front Review. That you could So can't do slides but maybe do So we can do slides. Then I'm just suggesting you can do it in that way if our computers kicked up. We can we can switch off. I was able to share. Two Alright. So we've we've been talking about alt service for a while. And this morning, we're going to be talking about an alternative to all service. Which seems be appropriate. Really, this feels a lot like You come in to restaurant. You get the menu You go to order... Let they give you a different menu and ask you to order off of that one."
  },
  {
    "startTime": "00:42:04",
    "text": "So what we've arrived at so far is that we'd really like have a division of responsibility between Dns. And this alt service header, which currently can give you all service can give you anything from a different host to different port, a different protocol and potentially parameters for connecting to those things. And the realization that we had last I'm around was that really, Dns is the best place to give you authoritative information about the in point that you're connecting to. And the only thing we really need to get in real time from the server is a directive to switch to a different point. Which might have different properties And you'd really like to get those from the Dns too. So that's the way the current alternative alternative draft is structured. So there are lots of cases where this might be an capability, whether that's Dns pointed due to the wrong place or any cast landed to you in the wrong place. Or you know, we've discover now that we've talked to you that you an enlightened client who supports more features than we have on the server, so we'd like to send you to a similarly enlightened server. Or, you know, load jet. It's not critical yet, but you will have a better lifetime if you go somewhere else. Quickly. So let's walk through some examples. We're now relying on service b record to gps records to make these this decisions at connect So let's say you look up your s records for example dot com. You find these three possibilities one of them is h three. It's got each support There's a fall back that Does h two, and there's"
  },
  {
    "startTime": "00:44:01",
    "text": "another fall back that says, you, really only use this one if I told you you needed to. And so, of course, we'll take the top. Priority one because it has all features we want and it's the top of the priority list. Okay. That's what we want. Then at some point, while we're talking to the server the server realizes that it is on fire, and it would like you to do some else. Probably in an emergency situation that would be a go away connection cannot continue. But if it notices before it gets that point, it will start showing trying to shift clients to go somewhere else more gracefully. So it gives you this header. That says you want the Yokohama fall. You go look that up. And you find... Well, here are some alternatives that you own the work in the York oklahoma area? You might have a backup that support to three. You have backup two. Supports h and Ach. You have... You might wanna go to Tokyo and support something there. So top of the priority list? We take the top one that doesn't support you see. That's what the draft currently says. We'll get to that in a minute because that might not be what you want to do. But then on a future connection, you go back to that same lookup you find the same results, This time around, you noticed that the backup you were told to use before is in the list even if it's not in most preferred one. So we keep using the backup because it is still in the list that we found. And if we come back at some point in the far future in the back visit there. We're in the same selection process. Originally. We just go back to what the list is in real time. So that is a very quick walk through of how the current draft would function But that leads us to a lot of open questions with this graph."
  },
  {
    "startTime": "00:46:00",
    "text": "I think we need to resolve and we need to get interest force. So we know what's put in there and where the staff headed? So let's talk about some them. One of the pieces that this draft throws out support form. That alt service currently gives you. Is being able to point directly to some other host she want the client to go do. The the graph right now gives you a huge name. That you do need Gps query for. Can't do any Gps query for an Ip address? If you do an h s query for a host name and don't find any results. Don't connect to that host name you were given. So if you don't have the Dns infrastructure to put up some alternative Dns host names, to to hang these records off of you won't be able to do this. Now Likely, if you're going to be using this, you have enough of a Dns infrastructure that you can spend some host names add some extra records that should work. But this is definitely a capability loss And so I think we want to confirm with the working group that that is something we're days saying we don't need that problem. We don't need that capability. So does anyone want to line and say, yes, we need it. Or no comfortable jet it. Or do we just not care? Alex. Hi. Alex. Wireless this Mike has a lot of. I have more question then a comment here. Because this looks a lot like quick server migration to me. Like, you could specify, like, here's and new preferred server address. And"
  },
  {
    "startTime": "00:48:02",
    "text": "it'd be kinda cool to do that with h two and not have to you that with h three? And that's what you'd be giving up it feels like. Because if I had for example, a Cdn with customer search. Mh. Even if I could spin up another host name, it might not necessarily match the host name of the original cert. And presumably, the browser was to follow that. I'm assuming you'd be the host name there? Like, how would do you expect that to work? So the way it works when you make the new connection is similar to the way service did that it specs the new endpoint still have a certificate for the origin that you're talking to. So the what you're giving up here is just ability to specify an Ip address with dns isn't actually gonna play into the certificate matching. Dns does not plan the certificate matching at all. You always you start with an origin, you're looking for a resource at a particular Url. And you will always be looking for the cert that is in the origin of that You Okay. So it sounds like and then you're not giving up that much. Am I understanding that correctly? Like you have to build a Dns infrastructure to serve these records, but you're not actually losing the capability. Right. The capability that you're losing is just to be able to point directly at an Ip an Ip address or host name, with a port number and not have to have any coordinated coordinated needed Dns updates. Okay. In that case my opinion is that sounds fine. Okay. Alright? Alright. Good. It's still connected. Alright. Then we will move on then. So the next piece that I called out while we walking through the through the example, there is currently no requirement in the draft that the alternative has to be equivalent or better to the host that you're talking to. Right now. So For example,"
  },
  {
    "startTime": "00:50:01",
    "text": "you had an Ach capable host that you found a originally rejoin? It told you you need to go to the fall back list. And the top boost on the full back list was not easy capable. Technically, there's nothing in the draft that says you should not do that. There might be a uc draft. But that doesn't quite cover this situation. So we might want to add some tax that says you filter it we might wanna say something about only if you use Dc on the original case, do you want to require On that one or we might say if you're in a fall back situation or the servers telling you to go elsewhere, then the server knows best. Follow normal logic. Do we want to be prescriptive here? Or do we just want to follow the usual connection selection logic and if that incorporate Et should incorporate So I think that the dns service be dropped before the recent changes to remove all of the Ach stuff was very good about talking about the things in this particular area in terms of how you might think about it. I think the way we might sort of frame this is that clients will have a particular policy with respect to the endpoint they select when they're presented with a list of options in extra Dps records. They will they will then initiate connections and ultimately, maybe one of those connections will succeed. If that connection contains Ach the client's policy may well change in response to that. But ultimately, it's still just a question of what the what the client's policy is at that point. And I think if we frame the the text"
  },
  {
    "startTime": "00:52:04",
    "text": "in that way, we may be able to to sort of work our way past all of these problems. So let me make it more concrete. If you if you connect to a server, you get quick. And you like quick you might decide that you want entertain any alternatives that don't also provide you with quick. Right. That's that's a perfect the legitimate decision that you might make at that point. You might extend that to Ach. If you get Ach? Okay? With we're now. Successfully protecting the client alone. And particularly things like it S and I. I would like to retain that property any alternatives. At this origin, because now this origin has given me the opportunity to use Easy and I like that very much. And would prefer not to see it reg even though the server might prefer that I go to an alternative at this So I think if we frame it that way, which is not quite the same way that seventy seventy thirty eight did, I think we might be in in a better position. Okay? So to restate that, I think you're saying that the client will have a selection policy and it should apply that selection policy to the alternatives that's given. And one of the options that it should consider is not following the alternative not using an alternative is always possible. For a client. Yes correct. I think the the refinement here is that the client's policy may be updated for a given origin based on it is communicated with that origin in the past. Particularly when presented with an alternative. Now it might be the case that you connect to an an origin and it has Ach. Then you later connect to the origin and doesn't have Ach. That's not really that a situation which in which you have an existing connection. Then you might"
  },
  {
    "startTime": "00:54:00",
    "text": "have to accept that fact and deal with the fact that Ach has been turned off on that origin. But then when you when when you presented with an alternative in this way. You do have a functional connection that has ach it might be the case that you decide that your policy is refined in this particular case. David benjamin. So that works for Hp records very straightforward because we see all the examples at once don't need any kind of stickiness. Like, the problem with stickiness is that it means that Like, ...well that's strictly a client policy, if the server it it has implications on whether the server can safely turn something off. And anything and any kind of policy here, I think you're sort of alluded to this in the second half, but like, inherently involves some kind of client's stickiness. Like, maybe not like right at the time week get the all service all because we have two connections. But assuming the old service b is going to last for, like, a couple of requests at least. And then we like, I think that we might need to be a little more careful about the bounds and I personally would prefer solutions without stickiness. We just don't to think about this, but it does mean we still need to write down, like, what this is. Because, like, in in other cases when a service is multi honed, like, we we already have to say, like, Okay. You you your baseline security is like the weakest of all the services I can speak on on behalf of this name. Like, suppose you have one server that speaks tls one two and one server that speaks Ssl three, there's a client that still supports both. Then Like, it doesn't matter what the Dns does, and attacker can always direct you to the week one. And so sort of already have this baseline un policy that like you need to, like, roughly equivalent deploy all of your servers roughly because you know, in transition, things don't work out. So I think that might be the better story here."
  },
  {
    "startTime": "00:56:00",
    "text": "Rather than, like, trying to rely on, like, client's stickiness and have us like remember every single little policy and like a sort of apply there. So can I ask you if I'm stickiness as you're using it there I'm about to talk about stickiness this, and I don't think we're things It's quite possible and misunderstanding the scope of all service b, stickiness means like I connected to you previously and then I sort of like, I hoc remember like, oh, you know, five minutes later or an hour later or a week later, this? The the fact that I previously connect information about how I previously connected to you impacts how I connect to you now. Okay. Let's do. I'm a little bit. So so I'm only talking about the the the action that you take when you see the new header field that at that instant when you have a connection, and you're looking to decide whether you make a new connection and use that instead for future requests. It's only that decision that we're talking about right We're not talking about in three days time or four days time or any of those sorts of other things. We'll get back to the stickiness question lei. I think. Just taking this one is, nasty in this one, and it's one of the weakest parts of this, But this is just that decision where you you've got a connection and you're presented with the option of replacing that connection with another one, what policy do you apply to that decision. So I guess the So then I guess the question of how what we decide for stickiness for this thing will impact our options for the other question. Alright. Cool. We are on the same page. So if we look at the example of when it gives you the alternative list, You're currently connected to a server that supports h three and Ach. You get this list of alternatives the top one support page three, second one support gc. Do you take either of those? None of those. And I think that's that's really the question here of"
  },
  {
    "startTime": "00:58:02",
    "text": "do we follow the direction to move? Or do we say, no. Neither of these alternative is good in my opinion as the host I'm on. So let me see here. I'm I'm clearly having trouble imagining case where our client would what the down c h there? All going to be in the case where if they have Easy before they run when you wanna to keep having Ach, And so... Yeah. In some cases, the client has the ability to enforce that itself it has a nice Ecg phone connection he looking out terrorism school that we're not gonna go of those. But in other cases, it's especially depending on all stickiness and stuff that not being completely discussed yet. It's might be difficult in some cases for a client the least it should be in the draft that much more strongly so what other stuff like Sv that you should not be giving clients options that would downgrade the Ach. If you have you should only be offering Ach and in the that should be a assured maybe even must. But. Nobody's they down great and we wanna make it so isn't any case as possible possible for the client to not downgrade. Right. Eric Apple. I think this is nice to think about and we could totally define our ramp of what we think we should switch to or not. But at the end of the day, there's always a chance that we can't get to the place you're telling us to go. Mh. So gonna have to deal with the fact that a client might choose not to switch. Yes. So, like, I mean, yes, it's nice. Yes. Should for please don't offer people wildly secure things when they were currently on an security thing. Like, let's try to reduce the chances that somebody who's not paying attention screws it up. But at the end of the day, like I don't think you can it's not worth putting a ton of energy into trying to funnel exactly what the client behavior is gonna do here. Because we may or may not be able to do whatever it is that you're asking. And what we've seen with the original generation of Old services"
  },
  {
    "startTime": "01:00:00",
    "text": "behavior may not be what we expect. Okay. I I jumped in the queue. Yeah. Sorry. Just as one follow on to that. I I agree with what people are saying I'm wondering if we're in this edge case. Where all of the alternatives no longer have good properties that were present in the original. I know that when we're when we're following this, we are resolving the alternative as the query but I think earlier someone had mentioned Well, it could be that the original names also drop Ach for, like, the entire all of the servers could drop it at some point. Right. It was great about to get a go away. Then you'll be in which case there's no point. And I imagine maybe we could have some non norma advice that if you see something, it looks like this configuration is totally changing. Maybe if you're about to make the decision that you don't want to have any alternatives, In parallel, just issue a new query for the original name. And see if that property disappeared from the main one because then your essentially under the impression that this is about... This property disappeared everywhere. And so maybe I may as well take the alternative. And that allows the Dns deployment the server deployment to make things work better if they uniformly remove Ach. And essentially the only bad case that remains. Is a case in which their primary has a good property and they're all of their alternatives have bad property mean to say you know, that's just gonna discourage clients from switching if you actually care about doing all service. Don't do that. Yes. Or you could just stay on your original connection and see if you need a go. Yep. Alright. So now talking about stickiness."
  },
  {
    "startTime": "01:02:00",
    "text": "The way the graph defines it well. Before I get into the way literally have to find it right now. What we would ideally like stickiness to look like is that once you've been given an alternative, You continue to use that alternative as long as the server that gave you the alternative is still authorized to do so. So you're still being routed to the same Cdn if you're in Multi Cdn case, The server still want to and the origin still wants you to be going there. And the client should immediately stop using the alternative windows condition change. Which is a great exercise clair and I will never actually know when that's the case. That was kind of the problem with assistance in the original service that if you said a long lifetime, then Dns might change out from underneath you, and you wind up to an alternative hosted by a Cdn that no longer has that host name on it. Or you look up a host name that now point a different Cdn and doesn't support each three. Those are some of the pain points from the original service. So we'd really like this to go away when it's supposed to go away. And the response to that has been set ridiculously short lifetime when all service, like say, one minute. I I'd really like you to go over here and then I guess you have to ask me again I semi you make connect. None of those are great solutions. Trying to do a little bit better this time around. But that is challenging. The way the staff currently achieves that is with two pieces. First, there is a new service brand defined for each Gps records. Which is ultimately It means even though this host is in the list, Never pick it unless you explicitly told you. And secondly, if you return when you are returning to an origin and you do your look"
  },
  {
    "startTime": "01:04:03",
    "text": "If you find the host that you previously landed on from an service keep picking it. Even if it's number three on the list, even if number twenty on the list, keep picking the one that you picked before. So that has its own issues which means as long as you want that alternative to continue to be used, you have to continue listing it in B gps responses. Which I work for a Cdn that does not particularly want to publish all of its nodes. In every... Every dns response? And even if we were willing to, that gets to be a really, really big Dns response we have a lot of notes. So probably that only works for particular host names if we can guess where you might have been routed before. It might be nice to have some kind of named way to invalidate or re authorize an alternative. So far the only suggestion for doing that would require changes to how service b records work fundamentally. And that's not likely to happen with it in The Queue. Again. So This is not a great design for stickiness but it's the best one we've come up with so far. Do we have other suggestions here? Do we have requirements that we might want to loosen, or is this acceptable for moving forward. Or maybe has been... David said, we don't like stickiness us and maybe we just drop this. I think we want some stickiness, but we need to figure out exactly where we are. Then Hi. Ben. The first thing that comes to mind is"
  },
  {
    "startTime": "01:06:00",
    "text": "If your example, before you had a backup dash yoko, You know, I could imagine saying, okay. The service is alt equals backup dash yoko. And that's how the the main H https records on the origin authorize a backup set. So, you know, that allows you to retract the authorization immediately, but doesn't require en the entire backups set in the main r. So service that that lists the host names the domain names that you have been asked to look up before. So it essentially adds adds one layer of batch where instead of needing to con q all of the distinct Https r's for all of the alt into a single r set. They can be broken into various r sets, you know. Ten each. And then I can en each of those in the main one. Okay. Yes. That might work and that might be cleaner than the current design. So Let let's extend the mail about that. We'll see if we can get a p together. And see what that might look like. Eric? Another approach that I'm fully thought through would be to have a service proud that say this a label that would exist on both the original as well as any of the old services. And the requirement would be that whatever the label that labeled service prem was would be like, a group label and it needed to it need to match between the between the two for stickiness. I'm the thing that might not work so well. There might be some adverse area cases. There's nothing really"
  },
  {
    "startTime": "01:08:04",
    "text": "forcing those to match. But if but we can think through what those efforts are okay it would be it may that that least for the that, like, if that was the name of the Cd, it's example as as a label. Then when there's a missed mismatch between these equivalence classes, you'd be able to detect detective not using. So we're which record would you put that service prem on? Because there was a proposal un github, that we add a service brand to any node record? Which isn't supported and the the service we have right now. But would maybe have a nicer solution but without that, I'm not sure which which record should get the service plan that has to match. And I was thinking that all that all of them would have it So it would require that you that the that the host returning all service b was one you was a path you got to through a service fee record. Wouldn't work if you got to it directly why a fall back. But if through a service record that all of the service new records for that I five all of that same so it's prime label. Okay. Thank you. Cool. Yeah. So just on that particular point, I think Eric's idea is one that that was floated by... I think, Jeremy I github. It's it's it's a perfectly reasonable idea. And I think it's one that we should probably explore. The the option that we chose here is a little weird. In some ways and and it might be at the cost of extra bytes in records we're able to to do something that's a little more direct and explicit. So I I definitely think it's worthwhile explain this. I just sort wanted to point out that"
  },
  {
    "startTime": "01:10:02",
    "text": "the why that we've built this some of the stickiness that we've we've got here is necessary in particular there's one of stickiness this that's kinda of critical, if you have a server that advertise an alternative. On every single response that sends to a client. We don't want the client. Trying the same alternative on every single request. That would be unwelcome, I think the best. The The design that we we're talking about here is is probably more for the when you come back to the server. Right. What what are you doing that in that I sense I think. I think there we've got a number of different options. I'm not particularly happy with the one that we have. I think it what kind of works, but it's a little I guess sort of it relies implicit identification to some level that's not really very So if if we can get away from that, that would be nice. I think that a lot of this comes down to people who are provisioning Dns and and setting things up what what they would prefer and and what their requirements are. And how quickly can I update it? Yeah. I I think I think one of the key realizations here is that we need a we need some sort of label that that sits in the dns that you can just change to completely invalidate all of the things of what attached to the previous label and and we we using names here and I think because their names that's a lot more awkward. And so for if we as much as I don't like adding extra lives of attraction when they're unnecessary they block things out, but this won't maybe one of those cases where we wanna do that sort of thing. Alex? Hi, Alex. So I think I managed convinced myself sticky is actually probably a bad idea from a load balancing perspective."
  },
  {
    "startTime": "01:12:01",
    "text": "If we go and look at generally the three types of load balancing that we have, we have either Dns based balancing any cast or a strategy that Youtube calls client mapping where we base like, give you where url to a unique. Specific to where we think the content should be. And particularly in the Dns low balance in case and the client mapping case. We frequently end up with servers with the same sort of wild certificate covering them and the types of origins that they can serve. And if we have these really long lived, h two or h three connections, it's frequently not a good idea. To have the stickiness information there and have the client remember where it was. Because it increases the latency for a long tail how quickly we can shift traffic around with to use feature. So you basically end up in a situation where the Dns or otherwise mapping request that you get has sent you somewhere. Different from where the client thinks it should go and you end up taking like, at least another round trip to actually end up with the server, which has your content or is not overloaded. So I think my preference here is try to leverage existing Dns h to connection as is possible with those other balancing positions and only really use these sorts features in exceptional cases. And that means no stickiness and no additional complexity. Okay. So either no stickiness at all or a way to say don't be sticky Yeah. And I think more specifically, like, one of the things that I was thinking about was skimming the draft here is I also have questions around how long do these information last and, like, how frequently do you follow them? Like, especially with the record. Or sorry the frame type. Like, what happens if you have an connection and then every minute, you get all service be redirected somewhere else. Do we have a limit where after, like, seven x, like, with three zero three hundred? The x series you fall off the chain or Like, there's just so many questions here about, like, this becomes an active control channel for load balancing that, like, it feels like a lot of complexity. So I feel like we need to"
  },
  {
    "startTime": "01:14:00",
    "text": "cut off the complexity at some point and say, beyond this is out of scope at some point. Right. The way that Graph currently addresses that is if you get a keaton a repeat frame telling you you the same alternative. You ignore it if you've already tried that one. You two is not... Right. But what happens if, like, if they alternate between Go to backup up yoko, go to backup up Tokyo. Backup up yoko. Backup up tokyo. Currently, there is no I don't think there is anything that says you should give up on alternatives if they keep sending you a different one. Yeah. But I feel like that could end up dawson a client. Like as a result, my inclination is maybe cut back on the minimum of problems we're trying to address. Make that iron cloud, and then maybe those start adding some more of these features. You know david? Data benjamin. So to briefly pick up on the thread that I dropped previously, if the stickiness answer is anything but like, no across the board. So, like, even there's optional stickiness, now that limits what options we have for the x question because if there's a stickiness thing, now we like now the client doesn't have the full information to apply some policy because we might not made the origins. I guess if we made the origin organization you guys query like in parallel, but like So I don't have, like, a concrete point here or chair just like if we say yes here, we need to go back and revisit the other thing. So the way stickiness works here, you do make a query the origin Gps records? Okay. And then stickiness only applies if in the list of options, you see the alternative you landed on before. Okay. So I guess, yeah. Alright. That's works. Alright. Next."
  },
  {
    "startTime": "01:16:01",
    "text": "So I I do think we we need some stickiness. And so let's keep having the conversation here. Of the alternatives. I I like both with then and Eric we're saying I originally got in queue to suggest both of those they said them for me, which was fantastic. To to clarify, if we do, let's say what ben was suggesting I think we can get rid of ul only. Yes. Probably. So I I think potentially getting rid of all only would address what Alex is bringing up because given the way that stickiness works, when I come in, from a a brand new connection. I always am doing Dns again for the origin. And in that list, I get back multiple options. All of these options are ones that I am allowed to use as the client. I do not always have to pick just the first one on this highest priority. If you were giving them back to me, I can choose. I can do happy eyeballs I can do whatever I want with them. So from a load balancing perspective, the origin still is in control of that. And the only stickiness exists within the list of the things that you would be allowed to use regardless of any other previous connections. So I I think when we limit that, then I think it fits well into existing low balancing models. And I think the only tweak is, like all only does bias that because in alt only means that this is not something you'd otherwise use. Right. But if we don't have only and we use kind of like, the hierarchy that doesn't referring to. Then I think it is the same as like a blank slate client, you know, you're kind of bias amongst the allowable results, and therefore, it shouldn't fundamentally change the properties Okay. Slow balancing. So I think in order to do it that way, you would also"
  },
  {
    "startTime": "01:18:03",
    "text": "you might want to be changing your Dns records in real time to say, I would like to not use this one as much, so I might need to then in real time turned down its priority in the list. Yes. So less critical functionality to be balanced by additional operational Yes. Okay? Alright. And then I think the next one is our in room alternative selection. Where we have an adopted draft that is patching up we know our issues with seventy eight thirty eight. We have an individual draft that covers all out of the same ground with this new header Do we still want Fixed seventy at thirty eight do we just say, okay, That work is not worth doing because we're about to call it obsolete. Do we adopt this an obsolete seventy three with this draft. Does this draft become the revision the seventy eight thirty eight and also describe the legacy thing. We're just say the legacy thing exists. This is more of a process question, but what do we want to do with these documents? Exposes place. Big bucket of cold water in this I like a lot of this strat. I've been speaking to many closer than Google dot Chrome and Google's sort infrastructure. Mh. And the general consensus is minimalist gives us enough advantage over out service to be with the massive complexity of implementing it. So back that perspective is, like, Chrome and Google servers do any of this. And alt service as much as we hate, it's still the old terrible thing. It's what we're stuck with because that's what we already have implemented. So So you also know implement the functionality of alt service that does this function Functionality be to redirect?"
  },
  {
    "startTime": "01:20:01",
    "text": "It. I wouldn't forward very much it all. So And the protocol selection piece is already covered by... Yes. So I think what I hear you saying is dot this and seventy thirty eight. Possibly. But yeah. Well, I don't sound good. No I don't know else could completely say. They'll adopt this, but for doctors told either find more advantages that this can give us the other solutions couldn't give us or find ways to vastly reduce the complexity. Unfortunately, I have suggestion to those, especially since western the complexity sounds good, but everything we just been discussing with me so far is Yeah. Let me keep that complexity because everyone has different requirements here and we need those to get done whatever wants to do. So Okay. Don't have a good solution, but as it stands, it's the case of... Yeah. Sorry. We're Not can implement this even though. I like it. It's just can't justify anyone spending time on it. Fair? Thank you. Hey, Lucas Pod cloud. I think having... I mean do on this a bit Like I'm not... I work on the server side and of of the possible options here. I think maybe we just change the seventy eight three best to kind of took the tax, but then obsolete, the the feature because effectively Hp record or deleted, what old service provided at the time that there was no other thing. So we're kind of just reflecting the reality we have here. But that this draft is is we're potentially work with doing that could be done in this separate document. To then just make things better, but that we do have a completely usable solution today. And let's just make that clear to to folks who who think they want to use old service to the problem that is sold by something else already. Okay. So that's seventy thirty bi."
  },
  {
    "startTime": "01:22:02",
    "text": "And then this is a separate work item. Eric near Apple. I'd second what Lucas said, I'm a match the future conversations of, hey, seventy eight thirty eight, misses is actually a totally different thing. And it'd be kinda nice if if those were separate, So I would obsolete that. A adopt this. And say this is the reality of the world that we're living in. Two actual implementation intent and things like that. I think some of the strategies employed by a number of websites Youtube among them. Require clients to do some things that cause problems in in other areas and and moving more towards H https records and something like that. Would help fix it. So maybe we should chat off offline, but it'd be it seems as though there is a clear need for implementation by multiple major providers. Youtube among them. Air Prism Apple. I'm in support of this work. I think this a a problem where it's solving. And I think this is a more elegant solution to something that we're doing. That's very similar. So eager implement this and think the questions around how the Dns resolution looks exactly our good ones. And we should keep talking about that, but this is heading on the right direction. Thank you. Alright. Yeah. I was trying to so? I guess another question maybe like, I think an important thing before going it out in this complexity is trying to think can determine that we do have enough critical mass and people willing to implement this. That was a problem we had with the first service but was it was some nice functionality, but there wasn't a but outside of the upgrade to quick. We never really got critical mass I people wanted actually you for things. So"
  },
  {
    "startTime": "01:24:00",
    "text": "with this a question might be are there some other bits of functionality that are worth bringing to this that would make it attractive enough to actually cross it, bring it across the line. So for example, we talked early on and about would we wanna have it be able to have these pass scoped. And being able to have this be pass, especially once we pick some of these signature issues might solve enough problems to to make it more worth worthwhile four steps of people. Pickup you. Morning. So I want make it kinda clear. There's there's no real advantage to clients in in doing this except indirectly. And and the reason that I'm participating in this work is because I'm hearing from people who upright larger server infrastructures that this is advantageous to really least some of them. I'm I'm hearing from some of them they're like, we can't just do not care about this stuff. And we would we don't see any use for it. But to hear Eric say, well, you know, it's no good for Google therefore we won't do it. I think is I understand it. I I don't think that's the attitude truth that mozilla was taking on this one. And and so we will look to implement something if we can say that this there's enough value to the the community of service out there. If we can make the serving infrastructure that much more reliable or robust or efficient. As a result of this, then that's something that's worth doing. This is gonna take some time for us to get to, but we would we would like to do that as well. And I'm hearing that there are people that really want this, so. So that's good and and we're at time now. So unless we have last comments, I think we should probably move. I heard you. But"
  },
  {
    "startTime": "01:26:01",
    "text": "Oh. Yeah. Yeah. I I was just gonna agree with Martin there. So speaking for, like, client implementation on Apple side. I think we would absolutely be able to support implementing this we already do a lot of s work I agree that for the client we don't particularly, but I'm aware, you know, as we work with our service other server teams that, you know, we can kinda melt servers down when they're in the middle trying to load it and I think yeah. There is a benefit to not melting down the services we care about. And this is a very nice solution to that. So and, you know, we would be very happy to support it at the lowest us level for all apps. And so thought all browsers have to support it, but we can definitely have it be applicable very, very broadly. Alright. Thank you. Great. Thank you, Mike. That's encouraging. That seems like I could path forward Next up where we're off of our active drafts now and next up where talking about other topics. And first up is Lucas Par. Talking about h two and h three web sockets discovery and detection. Lucas. Are you? Oh, I can't. Can you request yes. I can approve. We're having issues. Okay. Hang on moment. Oh okay. See how long it works for. I just need to approve him. Oh, that's all I need. Right. Let me could help that. But Alright. You should be good. Right. Yeah Thank you."
  },
  {
    "startTime": "01:28:00",
    "text": "Okay. So so this is a a on discovering websocket over H two and H three. This is kind of a joint piece from myself Memo Kendrick ghana. So the idea that we'll I'll present some the problem based that we've been discussing for the last couple of years. And then we'll have some proposals that we think are solutions are complementary to other presented by M and Drag garner. Themselves. Then has some discussion to think if yeah we should be trying to solve this at all and maybe which of those ideas are with working on Next slide, please. You're you oh controlling. I have the power. So the recap here, we have two drop already third adopted, want publish our I see eight four four one and nine two two zero, which basically to define how to bootstrap websocket over H two and h three respectively. What this gives you in a nutshell is a websocket per request stream. And you take a request stream and convert that into the websocket carrying thing that just shuffle data back and forth, and you do that via the extended connect method which looks like a normal Hp request, but it has these special additional rule changes compared to the normal connect method as defined already in the call specifications for h and h three. So effectively, these three items protocol scheme path if you receive those with Without negotiating this extension first, And so this is a connect method. You should blow up and basically completely reset that stream without processing it any further. Which is is good it's strict it's rules. But what that requires therefore for is that the client having received Next The settings enable connect protocol value before"
  },
  {
    "startTime": "01:30:03",
    "text": "having said that request. Obviously, you have some timing and risk conditions here. But effectively, what we did is solve the problem of providing websocket kits. For h two that we didn't solve at the time of Hp two standardization. And subsequently did. And amazing. But what we didn't do is kind of constrained that specifically down only to websocket. We created this new ex mechanism and didn't really think through all of the ways that people might do this wrong. We we create back to fix a problem the same time implemented a bug without really realizing what that was until people came I use it. So make another topic for Ed Monday told me. But Yes. We have this protocol pseudo header that is effectively an infinitely variable value. So we have the value itself is is something from the Hp upgrade opens registry, which is it's going register stuff like, there's not much control. The ones we have already is is the websocket capability itself. We have connect Udp now that's... Where that was publishers are c from mask and and we have work in progress things like web transport or connect Ip. Kite Tcp. I expect other things to come And so it everything works, but it's specifically for websocket say it's difficult because I just mentioned masks, that with the way you discover a mass proxy. He was an item on our agenda this week. But effectively, it's it's kind of an band thing that you know, you don't... You don't go Browse with a website and discover you have a mass trying and to use this thing. It's something else. The websocket you potentially do. And so you would see the scheme w s colon slash slash. In in the rear world, That's that's the way it happens. And so if you see that at the same time of having a connection to the same"
  },
  {
    "startTime": "01:32:05",
    "text": "server that is serving this, which is necessarily true, but typically is the settings enable connect protocol value is is really strong signal that extended connect is sorted. But the potential week one that that websocket are. He would think that if you served up the a Url that you would support the thing, but that's it's always true. And so what happens is the client has to take a bit of a gamble. And pick something that it thinks has got the best chance of succeeding. In order to succeed and not have to hit some kind of re retry logic or additional run trips or trial... Whatever what the where you do that? And then some kind choices that kind has to make or gamble great new Hp one point one connection and do it upgrade, like the old style of websocket. That's most likely probably gonna work because it's been around for so long. And we have the legacy and blah blah blah. But we wanna do the new cool thing because it's as advantages to doing websocket over H h three and that you can multiply things and got a shared congestion control over all of these other stuff, and we told to find that. Extension point people should tense you wanna use it. So I said you have to wait for the settings and then you send the request that might fail because actually the protocol value that you send in there isn't actually supported and that can be signaled by response. But If you do already have h three, you probably do already have the setting as well. And you can send the extended to connect, but back potentially fail again as well. One. I think there's one thing that is worth observing here is that you've been given a url points at at this particular name. And so for your new H two connection, this is really only a sort of gamble in the sense that"
  },
  {
    "startTime": "01:34:01",
    "text": "could maybe it's available on one and the h one is there. But you've negotiated up to H when the Edge server doesn't support it. I think that's really the the key here is that you've got multiple underlying Http versions that are available and only some of them contain the capability that you're looking for. U. Which just really terrible by the way who's this is an awful situation where Thank you for that clarification. That that's great to me. I was also trying to get clarification. So is the entire scope of what we're talking about for, you know, the gambling of the different options just different Http versions to the same origin. I I'm trying to load a particular url. And I could connect it over h one, I could connect it over h two or h three. If I know it supports stage three, and I just wanna know what I should try? Effectively yes. But it's it's complicated because it's know we have multiplex in h H three. So you could... You could reuse the connection you have. But if it's one point one you you couldn't because as soon as you do the websocket, upgrade, then you would, like, try over the connection you do have already. So you would typically have maybe browser of people speak but you'd have another set of connection calls. For or a connection tool to do this and and that has its own problems and restrictions and caveats. Because it can interfere with the pooling behavior that to some too. Okay. I guess my kind of reaction here because it seems like the main benefit we're getting. And again, could please clarify if I'm, but is that we would be losing a round trip because we have to do the connect request and see that it fails. Assuming we already had H. So can we start from Greenfield we haven't don't have a connection pull up. We... If we're gambling, we already have to bring up potentially two Tls less connections wait for settings, do a connection and"
  },
  {
    "startTime": "01:36:03",
    "text": "So I just wondering is that one round trip in this failure case for a deployment that has inconsistent deployed their websocket socket support. Like he's that round trip going to be a big enough benefit to justify a new setting or, like, kind technical work. But... Yeah. I mean, in my opinion yes, but I think the ambiguity here is that isn't a... You I don't. You you go and do it over H two and and and it fails and what is the failure like I couldn't I can't actually do that that it failed because that websocket resource doesn't exist did it fail because you asked for over the wrong vision. It's not a long. So some of the slides will come onto to this, but there's not a good strong signals that we can give to the client to tell it what the situation is those weak signals with Us the definitions of what they should do. Hence we keep spinning on this problem that should be fixed well, we can probably just do it on the implementations. And there's lack a consistency here. Generally in the the ecosystem. Okay. I'm Bob. From Apple. Quick question. I sat through the last b presentation, how difficult would be to fold this step one, two three into the previous proposal because this makes it harder on the client side. Just good bootstrapping a websocket is gonna take a long time because we have to try multiple. Options. But we have far in the upcoming slides, so you've given us clair as mike might say. And and Cool. Thanks. You've got like somewhere a little less than ten minutes minutes. Okay. Google. So I'm just wondering if we have a server that supports different on different paths. Like, The setting applies to the whole connection. So you still a chance is not supported"
  },
  {
    "startTime": "01:38:00",
    "text": "when you send the connect request. True. That that's just another dimension a problem that we might might have. Yeah. So I don't have the answer. That's well. Makes it today. Cool. And so we probably covered some of this just doing the discussion, but Effectively if you do some archaeology on the mailing list, we've been on and off discussing this for about two years. It's We never have different views not shared by. These are kind of my interpretation of what the list have said that the availability of a resource and authority not tightly linked to the Hp versions available when connecting to that authority and there's latency risks, but maybe they're fine, but you know, a bit like how many retry you do how diabetes deep is that recur happen, like It's it's all complicated and hard to explain to developers. Who typically just wanna use these things to go and and create interesting experiences on the internet. Say so it's so opaque it's a bit non deter. And and that doesn't seem like something protocol should do. And and we have more extended connect on the way. This problem didn't really exist when the initial to finding the same came out, but we do live in a world now where there's things going down the pipeline, and, I think it's personally, it's time to try solve this problem before we hit the the heart kind cold face of the internet. Why people start deploying stuff and and clients, people who would implement these things. Just to say it's it's it's too hard, and meet we give up that that had just a horrible friction to adoption usage of the the technology we're defining, which again seems to defeat the purpose of defining them in the first place. So"
  },
  {
    "startTime": "01:40:03",
    "text": "question we have for the working group is should we fix this? Should we try and mitigate it should trying to void it. We'll just ignore the problem, and say live with it. It's fine. So better advertisement could provides from hints. Reducing the risks. This isn't about saying we have a complete missing in a world view that's gonna always be correct. The internet internet things will fail. But if we can give stronger hence, we can probably have a good enough solution that solves the pain points that have been trying to highlight. And for that, we have two different complementary proposals from two different authors that one or two could be adopted. I don't know we're trying to figure that out today. See the next slide. Maybe there's some other options we're not thinking of. We could just have better semantic Hp feature discovery altogether. Which is, you know, something of feature discovery in Hp. Kind of exist, but not this level. You know, we're talking like options query Hp vision specific features. Maybe. But I can better response status codes. In the past we talked about using four two one forty six so all the the kind of the error codes we have in h h three of a vision fall back. But in my opinion those things are not really Suitable we're expressive enough. Precisely for this other problem. To finding a new error code just for this thing seems like way to too much effort and not really with it. In my opinion. We could require just deployments of for everything. So that the client doesn't... It's still gamble, but it's gonna the house other moment. But you know in my view that's not realistic. There's always gonna be a new thing coming down the road. Can't support it on everything. We might add new versions of Http in the future. And you have keep increasingly the matrix of potential problems or or work do. Would gonna just deliver with things and do nothing. I'm not that could be fine. So"
  },
  {
    "startTime": "01:42:04",
    "text": "We're going go on to the proposal aspect of it now, some Mo. Hi. So this will be the current problem with just extended connect knowledge. So if there is a current connection there if there is an existing connection with an h two server And we and the client discovers that we assist scheme. If this service supports web websocket d two, It'll be best for the client to send websocket request by using extended Connect and making Websocket connection. And if the client I mean, if the service does not support websocket over that Http connection, it'll be best if the client creates a new Http one connection and does upgrade. And if The client does not choose to do those things, it will have penalties as we have talked about. So my proposal is adding a new settings enabled web websocket settings for me, I I don't think this is, like the best solution, but I I think this is the easiest and simplest solution. Because we already have a settings enabled connect protocol settings meter. And websocket has settings enabled web transport. I'm, like, why not have a settings enabled websocket settings spam meter. So if the service supports web websocket over h two three, it will it said the settings enable websocket to to one If it doesn't, it will send it to as zero. So what the client be behavior will be. So if the"
  },
  {
    "startTime": "01:44:02",
    "text": "settings if the settings enable websocket per meter is not sent from the server. The behavioral of the client will I guess, it will depend by the implementation. Am I just do. It it I make new Http one connection and do upgrade in I try to use websocket over two it will vary from implementation. But if settings enabled websocket equals zero is sent on the settings for we do. A new Http one connection will be made and upgrade will be done. If settings available websocket is equals one is sent, the client will use the current connection. For and create... The extended the connect and make a socket connection. K. So I think now it's drag jen. Can you hear me? Yeah. Yes. So my proposal... It's it's really old one. I I just did update on that is to try to discover which versions some agencies entities most that sockets before actually making a connection and this will be using H https records be used now for discovering, for example. Next slide, It's just adds a new key that Ss then has the value as a list of l, that supports web websocket. And So of course, the endpoint needs to support these versions as well. So I Mp I need to be listening the here as well. Next slide. And what the client behavior will be is just... If the key is present, there is strong indication that supported over"
  },
  {
    "startTime": "01:46:03",
    "text": "h two or h three or both of them, and certainly client can can start using them. If this is just a attempt. Connection fail because some change happens in infrastructure. If the keys are present, the client can... She just phone back and actually, was Http one forty five. Or choose to Gamble. Yeah. That's that's it. Next slide it's Yep. Conclusion. Okay. I'd like to write things up and I'm like So yeah, because It's been going on for two years. Like, I think what what we're looking for is a group the group of three of us here, the group of the working group is we... Can we get any consensus that we should even try and fix this thing? And if so, let's like quickly along on what those fixes should be. We have these two proposals. Should be adopt one two, come up with some new ideas, can we just draw a line under this thing and give some clay signals to well done the heck they should be doing? So we have a pretty substantial queue and we also have very little time. So I guess, my interest as a chair is does the working group feel at this is in scope for the to be working group and then is this an interesting problem for work on. Does it make sense for us to do those homes. I mean, do we wanna try and get to the queue? I'm I'm still little worried that we're gonna use all of our time and not even get through that queue. Do we think it's more important to get through this than the other. Right. Right. Yes. That bends in the queue come. So I I personally I'd like to hear from ben because I know Ben has had"
  },
  {
    "startTime": "01:48:01",
    "text": "some different opinions to myself on the list and we got some discussions maybe Okay. So just just in case it's a contrasting opinion to what has been presented I think we'd could presentations to the degree. If if the cute folks who don't have issues they wanna bring up if we could ask you to d queue yourselves if if you feel that that's okay, that'll be really helpful. Oh I saw the queue update. A least, which is a good time. Yeah. Let's go through it and and that's very brief. Mike. Night bishop. So you started off your presentation with an explanation of why this is a general problem with Extended Connect. Then you presented solutions that specific to websocket. And there's a disconnect between that strategy. I think we need general solution for a general problem. You. Pen Oh, sorry. Tell me he wouldn't... Yeah. Kind of actually contrasting my mic was saying. I'm concerned that this would become a precedent particularly for the settings because I guess as N was pointing out, it doesn't actually solve for problems, So I I don't think it is really sufficient and it present for having tons and tons of settings for which we already have an ex accessibility field, which is a protocol. I think between these, the r, it seems to be the only one that actually would guarantee fewer round trips. And so if we're gonna do anything, I would prefer that we do that But I just merely wanna see that we don't propagate this, especially because, like, It seems like once you have newer newer deployments, like anyone who's supporting a supporting web transport? Could also support each two sockets. And so I feel like this actually can be a non problem because if you support web transport. Then you have this potential conflict but it's very unlikely that someone's gonna have a websocket server. That is the same host or the same path as something that's also doing, like connect Ip or connect Udp so I don't think it's actually practical issue."
  },
  {
    "startTime": "01:50:03",
    "text": "Ben And again, briefly, please. K. So Yeah. Yet had another variation I I don't have any real objection to either of these because they're narrowly tailored to the websocket problem. We have this very specific weird websocket a problem. I I don't really view it as worth solving. I think websocket are know being replaced. And if you wanna if you wanna use modern, then you should use web transport And I think we have evidence now from connect udp and from web transport that actually we can when we define these things define protocols that work across all Http versions. And so we should be leaning into solutions that do not require the client to try to figure out which version support which features. It's... Everything should just work on all versions except for websocket because of this historical problem. And if we want some kind of like escape hatch stream situations, were like, sorry, it doesn't work on this version, retry on a different version. I would be okay with that as Yep. The request. Okay. Ba. I I I agree that this... This needs to be solved mainly because stickiness to websocket is not gonna go over away anytime soon. So this is a problem that needs to be solved. However, there's is one thing that I didn't understand in either proposals as to how you would how the client would pick that the application level protocol that it needs to talk to with the different servers for the it's h two or one. For with traditional sockets who can, like,"
  },
  {
    "startTime": "01:52:01",
    "text": "queue, you can add which protocol you're interested in. Talking to in in one of the headers. Just that is something that whatever path you're gonna take that needs to be addressed as well. ...Yeah. Eric. Eric you. Two thoughts one, I think using the R is tempting because it's really nice to know everything is a front as we can and not find out like, we've kind of gotten there. This is essentially trying to optimize an edge case and so if we're gonna optimize it might as well. Actually optimize it. The other piece is in extended connect. The protocol field is currently single valued. And if we're talking about optimizing the case where we might have wanted one protocol and there might be another. I could imagine a world in which it would be nice to say, hey, I'd like to talk web transport to you. But if you don't I'd be okay talking sides. Let people pick from there, but that's a whole another can worms so we may not wanna open. So it seems a little iffy. And David. Take the. So I agree with ben all the like, we really should just get out of this heterogeneous like support thing. It causes too much of a headache. For the Dns thing, the problem is the problem is there are multiple patterns of protocol negotiation. For quick, we we do basically server presents the Ns level and client shoes, but for h one versus h two, its client presents the Tcp in the Tls clientele and then server chooses, And so we do something that only works from the Hp record we we we still have this retry case where because of mismatch between the server and the Dns, we think there's h two but we're actually out of date. And so then the server picks h two because we didn't tell it, Hey, I only want h two if you websocket. So I think if we're gonna do that, The right answer is to go reflected it into Lp because Is something that"
  },
  {
    "startTime": "01:54:03",
    "text": "is equally supported on both. And I know now everyone is. We really need to get more comfortable to finding Nlp values. Okay. So I guess, from my standpoint, it sounds like there's definitely interest in more discussion here and there's interest in in in solving the problems that people have I think it sounds like it is in scope for this group. I I don't think it's in scope anywhere else. It seems like we need to talk more. And so maybe what I'd suggest is let's take it to list. Maybe if if you wanna form a design team, we can talk about that. And if we if we can get to a place we think we we know what we're doing on the list, we can do a call for adoption of of of proposal and go forth. And and if not, well, we we have San Francisco and we can give you a more substantial block of time, I think. That some reason yeah I think I think I think a design team for this would be the most efficient use of everyone's time. So some of the folks who who talked in the queue today would be interested in joining that design team now be Great. But we we can take that on this. Right. K can we make you the point of contact for that credit coordination Yep. Yeah. Great. Okay. Make sense? Yep. Thank you. Thank you. Okay. Got five minutes, Dave Benjamin is necklace. Works. No. Sorry. Schwartz. I don't know if we need to do something around lost. Requested click the green button from. Okay. Let's be quick. So Last time I presented a thing called modernizing H proxies, people said, you know, just that I've covered two different things, people said, let's just talk about Tcp proxies. Okay. So this is basically half of that draft. So"
  },
  {
    "startTime": "01:56:01",
    "text": "Just a reminder, this is status quo. You've got your class http connect where you you have a proxy that's defined by an origin. And then you wanna connect to something through that proxy so you specified in the west and also the host header also specifies the origin of the thing that you're that the host import that you're trying to reach, not the proxy host port. That is something that I learned in the process of writing this, and thanks to people who corrected with me on that right. The mask proxy systems that we've just defined for Udp Ip the proxy is identified by a Uri template and it uses the extended connect paradigm. To to reach the destination So the destination is encoded in that case in the path and the authority or host header identifies the process. So That's very different. And for old fashioned connect. This creates in my view some pretty serious problems. There's no path you can only have one proxy per origin. If you have different proxy disciplines that you want we want to apply a different exiting from different points in the network. Whatever you wanna do, you can't do it because you can only have one proxy per origin have to split any any distinctions and behavior across different work. And there's also no host header to identify the origin within the connection. So you can't virtual host proxies on a on a shared Ip. And you also can't use the the defenses that our draft recommend against origin identity mis binding a attacks. Subtle point. So the proposal here is to define something that looks very much like the mask proxies except simpler for Tcp."
  },
  {
    "startTime": "01:58:01",
    "text": "So it just works exactly like connect Udp and connect Ip but for Tcp. Proxy is identified by a Uri template and And otherwise, everything is very similar to that. Notably, this is not using the capsule protocol. Because it's unnecessary. So it's much much simpler than connect to. So I think this is a useful thing it's basically a prerequisite, if you want to be able to support Tcp proxy on shared infrastructure, it makes it a lot easier to play Tcp Udp and Ip proxy support together hannah I'm seeking adoption here. So I keep myself, I guess I clarification question maybe a bit of an opinion. Do you intend to d the original connect mechanism at all. Or is this just I do that as as something that happens to view that as something it has an enormous enormous install base. I I can't really conceive of d deprecating it. I guess we could, you know, recommend that new systems use this new thing. If people really like Okay. I I think, you know, if if you wanted us to define this as, hey, look here's a convention to have a resource that has a certain interaction mechanism, you know, that's fine. I have no issue with that. So I I'd I'd support option on here. David david it's Mask. So first, speaking as someone who is like deploying a fleet of mask servers as we speak, I don't really see the need for this. We already have connect implemented and it works. So we probably wouldn't implement something"
  },
  {
    "startTime": "02:00:01",
    "text": "and we already have something that works. Where what this concerns me is I just interrupt we are almost happy... Well actually time. So really quickly then. This... Now you have two ways to do things, And you run into all the problems that we just had with the websocket at over multiple things discussion and this is gonna make all that really hard from a browser perspective, like when I get configurable a proxy what I do. So I think this will make things more complicated. So I would would be against it this personally. I think that from the browser perspective, it's extremely straight forward because there's no ability between the configuration strings. So if you're configured with a Tcp proxy identified as an origin, then it's a classic connect proxy. And if you're configured with the Tcp proxy that says target host a Tcp port and a Uri template. Then it's a a this style of proxy. There's no good point. Then I'm no longer object gang. I am neutral. Thompson, and I think this is a a vastly superior design. And we should probably adopt it. Are you gonna update proxy dot? That's a trick. There is the standard definition proxy. I agree with Martin. So I I I do support this. I think it'll take a long time before you see a lot of people moving to this. But I think we should define it now and then we expect them like five, ten years, maybe something will actually move to it. I like the fact that we can differentiate by the path for configuration. And one feature I would like you to put in there is doing what connect udp. Said that you're allowed to send data before you get your response. Make sure that you can get things faster that's ambiguous in the current connect. Okay. I just wanted to ask how about the use case. And mean The it seems that the use case being sold here is that there could be multiple connect endpoints."
  },
  {
    "startTime": "02:02:01",
    "text": "Running on the servers all I I wonder if I mean, we can get the same effect by using the authorization. Because if you open multiple connect endpoints. Without authorization then, the client can use You. I kinda wondering what the point. Is what the application that you have in mind is Sure. For me, the the clearest application where this is is una needed is if you have an extended connect capable Cdn, that is just that is forwarding or forwarding extended connect request. Back to an origin back end. We've set all this up very carefully so that Cdn can be protocol agnostic when they are when they're doing that. They don't really need to understand the colon protocol. Field. And They certainly don't need to perform the Tcp proxy there themselves. So mask is can be routed through a Cdn in this way. Connect Connect Ip. We don't have an equivalent capability for Tcp I see Thank you. So it it sounds to me like there's enough interest here to by taking a list and maybe do a call for adoption. Yeah. So tell me, I we'll we'll talk to you and yeah, expect to hear more about this one unless. I'd say. Thank you, ben. Alright. So we're out of time. We had one more item I have the availability hint spec, which I put out a little while ago. Take a look at that if you can, we'll we'll take that to the list. But the intention is to replace the variant draft, which previously replace the key draft. So we'll we'll see how that goes and try and handle that on the list and if we can't do that, We'll talk about it maybe in separate francisco. Okay. Thanks everyone. See an extent."
  }
]
