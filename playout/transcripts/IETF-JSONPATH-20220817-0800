[
  {
    "startTime": "00:00:05",
    "text": "or at least the majority of them so um yeah that's that's a really big request that i have just 24 hours it's it actually is not a big request it's it's not much but i don't want to open that can of worms again yeah the problem with uh things like that is that can uh serialize uh changes that are easier to do if they actually stack on each the other and uh really should be the discretion of the editors whether we can fix a typo or something like that or rearrange sections or changes like that which really need to be done in a sequential way or gets in the way so i'm not not a big fan of uh shackling ourselves to some rule that that really isn't necessary on the other hand i i do respect that uh if if we actually uh have have a serious uh technical discussion we need to use some time and then even 24 hours maybe way too little yeah typos i don't mind so much uh section reordering i'm not sure about but um i don't know if if the concern is that we won't move very fast as you know as developing the spec then in all honesty we're not really moving very fast as it is um i i doubt that 24 hours for an open pr is going to be all that much and if you have multiple pr's that need to be stacked on each other then um you can put a like it depends on"
  },
  {
    "startTime": "00:02:02",
    "text": "um thing in the the comment and you will know that the the one pr depends on another one and you open them all at the same time and they can all be reviewed at the same time yeah it just means there's some rebasing required then and it can you can end up with delta clashes and extra work um right now i would say that um the pace might pick up as we uh do uh increasing sort of fine uh polishing of the document just a wording because that's gonna be scattered all over the place and it's not going to be particularly deep um so that's my concern but um i think for any substantive change yeah the 24-hour grace period is good idea yeah i i don't think it would be appropriate for us to um make an uh official pronouncement on this subject aside from we should ask our editors to exercise judgment in not russians or anything that hasn't that that is that it's actually substantive are you comfortable with that greg i suppose in jason schema we have a two-week period so and we're moving at you know we're moving i would say faster than what jason path has moved so far so i i don't know that the uh the the slow down argument is is that big of a deal well it depends a lot on on on how people work so i'm i'm not a full-time jason pass person so when i actually allocate a block of time to work on this stuff"
  },
  {
    "startTime": "00:04:01",
    "text": "context and then i actually need to have a period of rapid progress and then i swap out that context so um you're trying to to force me into a work schedule that is not compatible with what what i'm trying to achieve um so plea please have a little bit of lenience for the editors here that it really makes sense for us to have bursts of intensive activity shall we get started folks and get the uh boilerplate out of the way yes please okay so uh just to do the formalities this is the json path working group interim meeting for august 2022 uh as this is a night official ietf meeting the notewell applies here um [Music] i don't need to run through all this uh i will note that our ad francesca is now on leave so you'll have to talk to me on twitter uh just so don't forget note takers are we just going to do it as we usually do which is i try my best to subscribe the um the bot asset once it appears on youtube otherwise if you have you want to help me out that would be appreciated blue sheets are automatic because we're using meat echo um i'll try to keep a tab on the chat if uh anybody else joins or whatever you need to be textual i've put a couple of things on the agenda i know that we've got a bit of an email thread going with some more detailed things on it is there anything else that we want to include in the agenda"
  },
  {
    "startTime": "00:06:03",
    "text": "or any gender bashing no oh yes please i'd like to yeah please i'd like to include just a check in on iregx oh yeah that's that's a good point um shall we do you want to do that now and yeah if possible let's do that first okay so if i recall if i can just speak to that if i recall correctly we agreed that we were ready to take that one forward to to to last call but we uh need a document shepard which can't be me since i'm a co-author and you didn't you didn't have time to do it as i recall james or no no no i have i've i do have time to do it and i've marked myself as document shepard but i have dropped the ball on it but the working group last call can go out before the shepherd write up as i understand right would anybody object to a working group class call on that at this point excellent okay so i guess the action there is for us to do the working group last call and for me to put some time in and actually doing the document shepard right up and james i'm perfectly happy to help with that i mean whereas i can't have my name on it i'm happy to pitch in if it needs anywhere yeah i there's uh separately that i know that there's been a lot of work done uh else from the ietf around the template for it so i'll just read the documentation there and perhaps find some other write-ups to give me some inspiration for what should be in there and what it might look like i might i might clean up a pre-emptive version of it out just to get some feedback pizza rings is my"
  },
  {
    "startTime": "00:08:01",
    "text": "first attempt at this but okay okay um no uh kristen you have some slides do your slides roughly line up with our that issues list kyrsten yeah you always have to remember that there are two mutes with uh um i have some sites but these are just on the the issue of extension points okay in that case i guess our first issue agenda item is equality and inequality of structures um and under structure types so glenn brought this forward and i spoke up to it a bit to my knowledge nobody else has so um what do we have there no that we have something from stefan there yeah i mean that we're talking about duplicate keys before we get to duplicate keys um i would like somebody other than glenn to have an opinion about whether it's okay to go ahead and support inequality on arbitrarily complex structures and arrays on balance i am slightly against this but not enough to scream and lie down on the road so other people please go ahead carson yeah i'm in favor of putting this in and the main reason i'm in favor of that is that if we don't put it in it's really hard to fix later and uh that will be a violation of the principle of least surprise for for at least some uh people and it doesn't seem like it's"
  },
  {
    "startTime": "00:10:01",
    "text": "really complicating implementations so we might as well do it greg yeah i'm in favor of this as well um i think jason equality is pretty well defined even for structured values um objects are equal if they share the same keys and the values for those keys are the same between the two values and then arrays have um there's a term for it i'm forgetting but it's it's the same same index values between the between two arrays are equal then the arrays are equal um the only question is that duplicate keys thing which uh i i would like to speak to once we get to that as well stefan do you have an opinion yes uh at the beginning i'm i was against the equality of structured values but i gradually changed my mind and i think now it's it's really much more consistent with with any anything else equality is one thing the other thing is [Music] comparing [Music] with with with smaller or greater than but we can exclude this for now and i'm in favor of this year uh carson oh i did let me let me just raise one issue i put myself on the q4 which is if we do this do we need to add literals so that i can do a literal equals against uh you know a an object literal provided in"
  },
  {
    "startTime": "00:12:00",
    "text": "in the in the in the json path itself that's just a non-rhetorical question okay i'm done karsten yeah i think that that's a good point um and um the the other thing is about uh um doing um inequalities comparisons less than and greater than that the same issue applies here that if we don't put it in it would be hard to fix that data and um inequalities of arrays is pretty easy to define and um so the the question is whether that shouldn't be very easy to put in and inequality of maps is indeed not so uh easy and uh that's probably a place where people will not be surprised if if we don't support that on literals um i would say it's not um doesn't add a great deal of useful function if we added literals but also it could be added later painlessly would we need an extension point for that or don't think so we just extend the syntax okay well we even could do this using the extension point i'm proposing but this will be a bit ugly okay okay you know in our position i think uh an extension point for greater than less than this is no no no good solution from a mathematical point of view you cannot easily memorize"
  },
  {
    "startTime": "00:14:01",
    "text": "or other vectors matrixes and uh so there might be no surprise from users if we cannot do this with arrays so just to be clear stefan you're saying even with arrays it would be okay to leave that out the arrays you you cannot order different arrays right okay um so in opposition to this my probably my primary concern is is this actually good practice would i actually want to do this in an application you know have you know some especially since there's no literals do some you know comparison of arbitrarily deep structure nesting uh in a stream of of json coming in over the internet uh i if you know if somebody did that in a code review and sent it to me i'd probably say you know you shouldn't do that to counterpoint that um dot net released the their json uh model that that i use in all of my libraries and um one of the huge outcries that the.net world had was why isn't there a jason compare or the adjacent equality in included in this model um people want that nested equality at least to have the ability to do it um so i think if we don't include this then there will be uh there will be complaining so go ahead what's that carson i just put in an example in the chat"
  },
  {
    "startTime": "00:16:00",
    "text": "um also in my on my question um by the word inequality do we mean the mathematical sense which states um you know a comparison a less than or a less than or a greater than or do we mean not equal for the purpose of this pr i've intended it to mean not equal okay yeah i'm talking about less than and greater than yeah yeah in the um in the the issue uh that spawned this pr i listed a number of things which i made out of scope and one of them was less than or greater than of structured types so i kind of deemed that out of scope for this pr but i think also the agenda i think also you put out of scope for this particular pr that greater than equals and less than equals yeah um because we can come back and address or once we've defined what this is then we can address those as well as uh as a greater than or an equal but we can define that separately yeah so i would expect that we can use the the definition of the the bank equals operator as not equals equals operator and that should always hold and then we can simplify this discussion yes by the way those date comparisons uh all date should always be in in you know rfc 3339 format so wrong it'd be a string"
  },
  {
    "startTime": "00:18:02",
    "text": "can i just say something to tim's point about uh stretch deep structure comparisons being uh you know an anti-pattern useless uh i somewhat agree but i think the surprise factor of if someone actually found a used for it and it didn't work i think that tips the balance for me that's why i wanted to do it uh for what it was like i looked at c bergman's comparison and it's all over the map you know some do some don't so it's it's not i didn't actually count or anything like that but this is certainly not wildly out of sync with what at least some implementations do okay just to save time i'm going to say that i smell rough consensus here which is that yes we should go ahead and do this and that we should also uh support uh so at least we have i think we're just consistent at the very least we would support inequality and inequality as in not equals um i i'm not sure if if there's full agreement on supporting ordering for a raise anybody who's really against that i am i don't like ordering for a raise no well as in one array is less than another array that is bad i don't think that that is i don't think that's a thing that's been defined uh okay it certainly hasn't been defined but i think there's a straightforward definition to be had what is that definition it's just that the um uh the okay the array uh one raised less than another if it's a a prefix of the other array in which all the elements of the prefix are point wise less than or equal to the corresponding"
  },
  {
    "startTime": "00:20:00",
    "text": "element in the longer array that would be analogous to string comparison yeah an ordinal string comparison yeah responsibly i could get behind that but i've never seen that before okay well it's standard javascript so people who come from javascript or from from other dynamic languages will expect that okay i'm detecting that uh given a nice clear uh explanation which i don't think is in the draft currently glenn that's right correct um people might go for this so i suspect glenn if you go ahead and write this up and do it nicely it'll probably sell through yeah and if it doesn't they'll throw that one as well uh i'll write it up and we'll see what happens now i would like to see um some level of analysis for um where this might be in use because as i mentioned i've never seen this before yeah and i i haven't thought this carefully but i'm thinking about you know areas that have non the things that aren't just integers and just numbers you have non-comparable things at various positions in there um it smells kind of wormsy to me so i'm i'm yeah how do you compare an array of strings against an array of integers yeah i'll certainly take that into account when i'm writing the pr and if it turns into a count of worms i won't even push the pr up okay okay okay good enough no i think any unless somebody has more to say on the subject we should talk about duplicate keys kirsten you wanted to say you had a presentation on duplicate keys no on extension points or on extension points right okay so duplication"
  },
  {
    "startTime": "00:22:02",
    "text": "so i cannot make a presentation on that um so i think on duplicate keys we all agree that uh this is bad and we're not going to specify in detail uh what the we're not going to try and be the what wg and specify in detail the exact semantics of all the possible error permutations um and and you know we're going to do the moral equivalent of 8259 when she says this is you know the behavior is unpredictable um and there was a lot of argument about but the best way to say that was which i got bored and stopped reading is um somebody have it yeah i think i think it comes down to the fact that different languages or even within a language different parsers have different behavior when it comes to duplicate keys because it's not specified and if the json path implementation is using some external parser for reading the json then um it's dependent upon whatever the behavior that that parser has decided to use so i don't think i don't know that it's right to hold json adjacent path implementation to a specific behavior when the when the parser that's depending upon has its own behavior so glenn you pasted some uh a link to yeah i did a pr uh late yesterday um to uh clear this up essentially um and i made it i made it undefined behavior but the behavior of a comparison is that the result has to be true or false so it's implementation dependent so i think i use the term implementation dependent um the um the details in line 11 lines 1180 to"
  },
  {
    "startTime": "00:24:02",
    "text": "1183 can actually be simplified with that precondition on 1179 but let's not get into that here i'll follow up with the simplification but basically i've just said that the um if there are no duplicate names keys if you like um then we can define object equality and then on line 1186 i said if there is an object and at least one of them either of them has got either or both have got duplicate names then the result is implementation dependent but must be true or false is there a case for saying that essentially at a much higher level point in the spec yes because this whole issue of duplicates is not you know strictly there for comparisons it's it's it's at the basic semantic level of what you can expect jsonpath to do on anything at all i think we can make the general statement about uh the behavior being implementation dependent at the high level but we have to tie it down to sort of uh you know not launching nuclear attacks and that kind of thing in the detail now dotnet's parser uh will throw an exception when it encounters a duplicate key um so i don't even know that i could get to the point where jsonpath is executed if an object has duplicate keys so maybe that means that this doesn't affect me i don't know yeah i think it does kirsten yeah so my point of view is that duplicate keys is an issue about json texts it's not an issue about json values the the implementation defined thing we have is how does a json decoder"
  },
  {
    "startTime": "00:26:03",
    "text": "and that that of course is is an issue that would have needed to be solved in json it never was solved so we have this ambiguity here uh it's not at all clear to me that on the json value level uh we can still have duplicate keys so greg has one example in javascript uh and many other implementations just one of the the keys is selected and the other ones are discarded and i think we would have to search long and wide for implementations that actually carry duplicate keys from a json text to a json video and i think we should simply exclude that from consideration for this document and uh yeah that's not something that that's a problem in practice because the problem is on the way from the text to the json value that is a real problem in practice but that's not the one we see in json parts where this is actually a rise in practice is when you're using a streaming tokenizer which i i've actually done a lot because you know in high throughput event processing things you don't want to take the time to parse everything into an object model you know you want to you to use a tokenizer and in that scenario it is certainly the case that you know you can you know you your partial callbacks could be called back twice for the same member for a member with the same key um and i think that's true in at least you know the popular mainstream parsers in in in in multiple languages so you can get you can run into this actually okay what you're saying in in in this in the case where um"
  },
  {
    "startTime": "00:28:03",
    "text": "where you're using i i use jackson a lot so uh jackson has a json uh next token api and it also has a an object mapper object is that what it's called i think api and if you use the object mapper api well the these one of the keys vanishes you only get one in the object model that makes all sorts of sense if you're using the the next token api yeah you can see the same member twice yeah i've even seen parsers where i forget which language it is um where it's non-deterministic which key you get you only get one but it's not deterministic which which one you get and you could run the program you know multiple times and get either key so we should run in here but i i think i disagree with you carmen that uh you know you can count on this being taken care of and you'll never see it um yeah you could yeah okay so um uh go ahead a similar example occurred a few years ago where i uh made the assumption that any sane representation of linux environment variables wouldn't have duplicate keys and i was wrong and so my point here is that it all depends on the representation that's chosen for the data structure you know the representation of the object uh the parser can run do its stuff but if there's a representation that allows duplicate keys then uh you know all sorts of strange things can happen but my second point is that if i was a tester and i was going to test jsonpath uh i would create a hostile implementation of json json that did all sorts of strange things with duplicate keys i know push this back to its limit um you know uh it won't happen in practice i don't think uh it's unlikely to happen in practice uh but in terms of the robustness of the spec i think we need to take it into"
  },
  {
    "startTime": "00:30:01",
    "text": "account i would i would you know whereas i disagree with kirsten that you know this just you know doesn't happen at the jason value level i would agree with him that i think this should probably uh that this is really an issue at the jason text level primarily in terms of right way to think about it so i i would probably disagree with you glenn that this needs handling down at the detail level i i would i would think this would be best handled by a statement relatively high up saying depending on how the you know the mapping from json text to uh nodes in effect is done the behavior in presence of is unpredictable and that applies to every statement in this spec that concerns behavior concerning a key that's extracted by a a member that's specified by kiva and then just leave it that your voice wasn't good there can you say that again i i agree go ahead stephan i agree it's uh only a matter of the the parsers and so we really cannot do a lot here neither the implementations nor the we the spec fighters we are referencing at several places i uh jason so my question is why shouldn't we use or referencing or demanding"
  },
  {
    "startTime": "00:32:01",
    "text": "the high json compatibility here so because i jason is explicitly excluding [Music] the same the same value the same name so let me speak to that so in principle i agree with you stefan unfortunately whereas i jason is used uh quite a bit in in in specs i have not observed it being available in parsers i i don't i i haven't seen really say you know let's create a parser put it in my json mode so so whereas that what you say is correct i'm not sure it's that useful um yeah if we make a general statement about unpredictable behavior are we comfortable with not tying down the behavior of comparison you know equals equal to giving true false or you know potentially error do we allow it to just do anything um i i think if we do a good job of writing that statement we really shouldn't need to then go and you know reiterate it uh at every point where a reference to a member object number by key value appears in the spec yeah exactly so things like dollar.a don't mean anything in a world where you can have duplicate keys um so we we have to have a very very general uh statement about this um and uh i agree with tim that that we should do this in such a way that it simply takes away the consideration for the detailed places of course we still have to check those detailed places um if what we wrote there actually measures right with the general"
  },
  {
    "startTime": "00:34:02",
    "text": "aspect of handling duplicate keys and tim of course you're right about the streaming parsers but again a streaming parser is an implementation that is making some compromises for instance in being able to properly evaluate dollar dot a um and it will have to have a compromise on on comparison as well so it's this is not a surprise well um yeah so i'm coming around to this idea of a general statement of unpredictable behavior but just want to be absolutely clear if we look at the text on the screen um we delete line 1186 so we wouldn't actually make any statement about what happens when there are duplicate keys we just um spec the case where there are no duplicate keys is that correct i think that's right yes okay there's also a problem with line 1186 because an implementation might might internally fail um if it is fed uh things that aren't even json yeah okay okay i think that we're heading towards a situation where we're going to have one statement about this somewhere relatively high up in the in the spec and then we can argue about what exactly that says what words it uses as much as we want to and then uh leave that to cover the rest of the spec you good with that glenn yeah and uh respect will have to kind of uh allow for that general statement if it were not contradict that general statement correct okay i think we're done with this now just one more thing which is uh the"
  },
  {
    "startTime": "00:36:01",
    "text": "uh should lessen or equal be equivalent to less than or equal which god was talking about that was one of the out of scope issues for this pr i think that's really straightforward i would say the answer is yes well it's pretty straightforward for me that the answer should be no because a less than b must be the inverse of a greater than or equal b and if you don't have that uh then things become complicated and i see that that you want to have the other equivalents as well and our fail falls approach unfortunately doesn't provide us with an obvious answer here but i think we need to to acknowledge that conflict and just state that we decided in favor of one of the equivalences and and uh against the other equivalents uh that's probably the thing we can do i don't think that i don't think that there is a conflict if you have a is less than b and does logically imply a b is greater than i think i'm sorry a is less than b inverted is a is greater than or equal to b or not not yeah a is not greater than or equal to b so that's greater than or equal which is what we're saying i think we're saying the same thing coming from the different direction yeah i think it's logically consistent too actually so casting can you talk us through that why there's a contradiction there yeah i forget the details"
  },
  {
    "startTime": "00:38:01",
    "text": "so i haven't completely swapped in json path automatication yet but that's of course true for all reasonable comparisons but the ones where we we want to return faults for failure we have to be careful uh and uh i i seem to remember that there was a case that that we actually couldn't get right uh but i have to worry about those if we are retaining so okay that's in the case we have a tight mismatch and a tight mismatch right you haven't changed anything right in the type mismatch it's just false and that actually breaks the rule of you know if if you know if the word foo is tested to being less than three and that turns false it does not mean that foo is greater than or equal to 3. right both both sides of that are just pulse yeah so i think we're saying that the equivalence less than or equal is equivalent to less than or equal four compatible values and these at the same time correct right even if they're type incompatible less than or equal will still return false because the the less than will return false and then the equal will also return false yeah sure yes but the greater than equal will also return false so it's not the inverse of just but in a tight mismatch it the greater than equal will to return false they both return false yes with the tightness and that is uncomfortable because you can have a comparison where less than is false and greater than any equal is both or is also false and that makes some people uncomfortable it doesn't bother me it just means that you have to to apply extra care when you are rearranging formulas making use of comparisons and right but i think that comes"
  },
  {
    "startTime": "00:40:00",
    "text": "i think that comes at the the type mismatch uh level rather than at the greater than or equal level so if we if we in the spec define greater than greater than equal operator as greater than or equal then the type mismatch thing still applies it's still uncomfortable but it's still logically sound i think if we would only would solely talk about areas containing numerical elements then i would agree carson to apply lexic lexical ordering here but that isn't uh the real world we we can have arrays in areas and i would like to know what about comparing objects it's i think we agree that comparing two different objects that it's it's very hard to get some kind of ordering here so what to do with objects and what to do then with aries if some members or only a single member is a single element is object also yeah i think glenn's going to be digging into all of that rat's nest with his uh pending pr we will see if glenn can produce a pr that convinces us i'll take no pressure i'll take another action i've got an existing action to do"
  },
  {
    "startTime": "00:42:00",
    "text": "a pr for ordered comparisons less than greater than of arrays i'll take another action for this um lesson being equivalent to the inverse of greater equals i think that might start to fall apart but i'll have a go at it yeah also glenn when you do the pr4 uh ordering on arrays you do have to address the subject of what happens if there's a tight mismatch or uh an object comparison that falls out of the middle of that okay yeah yeah okay okay okay are we done with this for now in that case we should give the floor to maybe we can quickly uh just call consensus on on what i seem to hear here that we are not going to try to define the ordering on objects correct i think i i think we have content on that good okay phew thank you okay kirsten tell us about extension points yeah um i i only just returned from vacation and then so this is about the minimal presentation i can make about this uh subject uh so we had a lot of discussions about extension points that were kind of on the implicit level without actually writing down things and the the one extension point that that we we have identified really is this this functor extension point where we had length as a long-standing example so you can distinguish a 10-digit"
  },
  {
    "startTime": "00:44:00",
    "text": "isbn from the 13-digit isbn or something like that and we can generalize this to to uh a functor with zero more arguments which are uh comma separated so that that would be the overall syntactic form of this extension point and the specific name the functor length current here compare normalized and so on those would be registered extensions and to make sure that the extension point mechanism is actually implemented uh we would use length as an extension that actually comes with a json path so so people actually write the code to pass this um so that i think that that's essentially where we are at now the question is where does this uh syntactic form go to so what where can that appear and that turns out to be a little bit more complicated because we have pushed some some of our typing system into the syntax so having a common syntax for various things that that might want to be addressed by extensions might bite us i haven't generated actually examples where they bite us but this seems pretty obvious when we think about the way how we separate boolean expressions from compara comparables from singular paths and from a special case string literal which is allowed in some places and not others and i think we have to to look at all these and see whether something weird uh happens so if we have an extension that actually operates on paths"
  },
  {
    "startTime": "00:46:01",
    "text": "then of course you only really want to use it in the place of of the production singular path and if it occurs in a different place it's not going to work right so i think we have to to discuss how uh the things that that are still tractable not easy but tractable with the current syntax uh change when we use uh the extension in different locations and the inverse of course also holds um the the extension can have arguments and these could be boolean expressions these could be comparables these could be singular paths these could be string literals and right now it's not clear to me whether an extension actually has to say how its arguments are supposed to be interpreted or what are valid arguments to give to do this extension so we we have kind of the location problem on the the top down and we have the argument problem on the bottom up and we have to make sure that we fit into the syntax uh with that and that's why i didn't just throw out a proposal because every proposal i came up with immediately ran into complexities here so there are many ways of serving that we could have singles something like that um i'm not going into that um but i think we really should be uh coming up with a number of examples where we want this to work right and then and then of course examples that that are supported by by people actually doing something in existing uh json path and json path like implementations and then work from there and and look at the syntactical issues and look at the the potential semantic"
  },
  {
    "startTime": "00:48:00",
    "text": "uh impact of of having to distinguish a singular path from a compare comparable for instance i think it's a good way to go to start with a single and take the less the the length extension points and show what it leads us to greg um i think uh this is great um one thing i would add is um order of execution um so in c sharp if you look at the compare normalized um in c sharp what that would do is it would evaluate the the at first name um and then it would have tried to evaluate the the string constants but if you're if you didn't have a string consonant there's something evaluable it would do that so basically it evaluates all the or all the arguments in order and then it passes those into the function um that passes the results of those into the function um do we want to do that or do we want to say the at first name is a path that gets passed into the compare normalized function um and uh i'm not saying that we have we have to have an answer right now but i think at some point we do need to have an answer for that yeah first of all i think don't think we have order of execution issues here because this is all strictly functional so that there are no side effects that where we're doing one thing first and then the other thing later uh what would influence us so whether you evaluate jerk first or first name should not have an"
  },
  {
    "startTime": "00:50:02",
    "text": "influence on the result but we do have uh type typing system issues and and you of course picked exactly the the one thing that bothers me here which is that that dot first name really is just a path and the the extraction of the json value uh that is at this path um is that something we we do implicitly by defining compare normalized in such a way that its first argument needs to be a comparable and we know how to turn singular paths into compara comparables um or um is this something that uh actually at the point of application of this extension uh you would have to write so so you you would actually have syntax uh for saying ad.firstname here really is meant as the json value there and not not just the um the path um so that's a decision we have to make at some point and we have to see whether uh such a decision um can be reasonably made by an extension and uh how how difficult it gets to actually implement all this when when extensions suddenly have these interesting additional properties in terms of interacting with the typing system i think that's roughly what i said yeah yeah i think the um this is really good step forward carson so thank you for this um just a query about the terminology it's a minor point but why do you say functor and not function because i don't want to restrict this to functions you see the current year this is most definitely not a function"
  },
  {
    "startTime": "00:52:00",
    "text": "because next year it's going to have a different value okay in terms of the mathematical function yeah we don't have to call it function that's just the name that that came to mind uh i'm sorry my mind is overloaded with the category stuff and it's a bit scary yeah i think given the i think given that we're in a computer programming space i would take the computer programming definition of a function in which current year would actually to me fit the bill but it's splitting hairs and i don't really care yeah we let's just take note that we have to find a better name for this this thing that is called funko on this slide one one question are there already uh other specs who that are successfully using these extension points that we can learn from i think programming languages in general no no [Music] other specs is this completely new uh is chosen past the first spec which intends to use extension points or is there already some practice which we can learn from there are lots of specs that use extension points but this specific syntax uh here um came to mind quickly because it's a pretty common way of doing extension points so i i would have to dig in in rcs which rcs actually use an extension point syntax like this so the ones i have recently written use different syntaxes but these are not syntaxes we would want to copy here"
  },
  {
    "startTime": "00:54:00",
    "text": "but the function function argument notation is so familiar and we already have um examples like like length and wasn't there a size i don't remember so we had several examples already that took the syntactic form and adopting this syntactic form as the syntactic form for the extension point we want to have in uh jsonpath seems to work very well i think the other example we had might have been index of uh at because yeah because that doesn't really work in this context i think another argument for using this syntax is that there are implementations that are doing something similar plus james path does something similar so i think that's another argument for this syntax um the type system a little bit um it's it's i mean json has a type system of a sort it's it's well um but it's complicated because you look at that length function and um you say well if you're going to write the definition of the length function it's perfectly reasonable to apply it to a string to an array it's even reasonable to apply it to an object you know how many members does this object have like on uh lots of programming languages allow you to apply the equivalent of length to a hash map you know or whatever it's called um and but it's not reasonable to apply it to a number so um i don't think it's reasonable to remember um actually there are languages where you can ask for the length of a number"
  },
  {
    "startTime": "00:56:00",
    "text": "you get the minimum number of uh bits you you need to represent that number in binary that's right what about a boolean yeah so so the point i'm making is that um to write if i were going to write the definition of length i would feel the need to say you know when applied to a string it means this when applied to an array it means that when applied to an object it means this other thing when applied to a number what happens it has no meaning it throws an exception [Music] so you know i think that in the year 2022 we can't be sloppy about what types okay we have to be um we have to be consistently and sanely typed in in the behavior and i'm worried that that's going to be quite difficult you have to make a bunch of abstractions like to to define length properly are you going to have to have a new abstraction of sort of thing which has a length you know um or well it's all localized in in length uh the the first thing you would need to define is what happens if there is no isbn member in in the current item so that's a problem that every uh functor that can take a path as a parameter as an argument uh will need to solve and we could also go the other way and say we have a length for strings and a size for for arrays and something else for for objects so we don't need to uh make this uh generic we could define uh very specific ones which would make it easier for people to to actually uh catch uh problems where array"
  },
  {
    "startTime": "00:58:03",
    "text": "occurs and length still returns something useful so you match on on the wrong thing so the design of the specific uh extension point and what i'm trying to do right now is designing the the whole concept and of course looking at examples is useful but we don't have to solve that problem right now well we do have to if we're going to define this thing we are going to have to write language about the way it interacts with types and also as you point out with like arguments that just don't work right you know that aren't there uh so i'm just saying let's not underestimate the um the necessity for being careful and and thinking about this glenn please go ahead um i'm just wondering if we could get away with uh a set of restrictions on these functions that says that the arguments must be um um type adjacent type or absent they're like in uh at dot isbn it's either the result is either jason type or absence and if we made the result of a functor all always the same the same kind of type you know adjacent type or absent then we might be able to um uh you know say that every every function definition has got to cope with those half a dozen cases greg yeah i was going to say the same thing i was going to say that um you know the json path specification where we're defining what a function functor is um we say that the arguments can be of these types you know these json types or uh some internal representation of absent um and then it's the responsibility of"
  },
  {
    "startTime": "01:00:01",
    "text": "the functor to handle any of those possibilities and then where we specify length because we have to do that because we're going to include it um it's not we show an example of how to do that basically what you were saying earlier tim of um you know if it's a string do this if it's an array do this if it's an object do this otherwise you know return x value for length that could be negative one because that it's a nonsensical length it could be returned right it could return absent um but that would be a that would be the responsibility of the function basically the function mini spec to define right in effect in effect what we're going to have to do i think is for the spec to contain language that constrains the future definers of functions uh such that they do don't define something that is nonsensical in terms of the json type system i don't think writing that would be much fun i'm not saying it's impossible i'm just saying that we are stepping onto some shaky territory here well i think we need to make a decision and then it will be trivial what decision is that yeah for instance what just was proposed uh only allow json values or absent as arguments and return values and then it suddenly becomes very very simple and then i need to ask you what what exactly is absent as a return value absent as an"
  },
  {
    "startTime": "01:02:02",
    "text": "argument uh absent means uh is not not found it's uh undefined but undefined no no valid uh type so what what what what is absent as a return value it just means that the whole construct was based on something that isn't there so it should be treated in the same way we we treat things in other places that aren't there so wherever we have a singular path and use that uh in place of a comparable we have to deal with absent so we already have that i understand this length would be a functor that is supposed to return as a result a numerical value so if i want to know the length of two uh what what will it return uh absent is not a valid right type or we need to return false no we should really absent because it doesn't have a length correct so current with their current expression syntax the way that it works is if you have a path that results in an absent value that absent just falls through and the entire expression returns false same thing would happen here if you do the length of two it would return absent and the entire expression would just return false okay that works if functions can only appear where paths would right"
  },
  {
    "startTime": "01:04:05",
    "text": "we essentially have the problem through the the entire um expression language with a possible exception of the right hand side of regex which is limited to string literal and i would probably want to open that up taking what you said there i wonder if it make any case to say that a an extension point is a kind of path yeah that was what i wanted to enable uh here uh so this is the the alternate approach to saying we can only have json values uh there um but yeah now you have all the complexity in the definition of each single extension how to handle these different cases i think it's not a big complexity but we certainly should make sure that in the lengthy example we handle this in such a way that implementers of other extensions will know what to do there okay i would like to experiment with this and and try to start with the length functor and i'm curious where we get to i like this approach yeah so um we have a issue i forget the number of that and may we can agree to put some"
  },
  {
    "startTime": "01:06:02",
    "text": "examples uh we find in in other json paths like uh query languages or in existing json path implementations about something that that would fit into this space so we have a number of examples to look at and can can make reasonable decisions based on that knowledge base so that would be my next step here yeah i i was going to say okay what is the next step the next step is to kirsten would it make sense as the next step to actually write in great detail the specification of length and and handle all the places where that might ripple around the rest of the spec makes sense to me i still want those other examples so we could do the definition of length at the same time because i i my my my intuition is that if we do a really good job of that because obviously it's going to be used in places where comparisons are expected right otherwise why would you be doing it um uh so it's going to force us to say what happens in various failure modes in those comparisons maybe that's already covered by the language i'm not sure um like you know if for example if i say length on a path that's broken then any comparison that shows up and returns false i guess because it's a tight mismatch or something like that um but we need to write all that down and my intuition is that if we do a good job on that with length because it has a parameter um and you know and has a result that would be expected to be used that there should be some hope that would you'd have to solve the larger problem to do a good job of doing that okay glenn um you could also use uh length as an"
  },
  {
    "startTime": "01:08:02",
    "text": "index yeah we would need to add and subtract to make this really useful we can we can define plus and minus as extension functions so maybe i should just assume that we have plus and minus as extension functions uh just to to make sure we play with these length as index examples i think for now i think for now we we leave linked out as an index we come back i think that can be added after we've got the extension in there somebody somebody said index is not a good example for an extension point because the only the single argument index would get is that the during iteration there any any other parameter would or argument would make no sense so we need to discuss index not in this context of extension points yeah to do a real index you would have two parameters one one is the object or array uh the item in which you are searching and the other one is a filter expression that tells you whether you have had a hit and that of course requires"
  },
  {
    "startTime": "01:10:02",
    "text": "functions as arguments which is a lot of fun which then goes back to my original opening thing about about evaluation order um one thing that i did want to ask um carson did you put in um any consideration for having one of these functors in place of a boolean expression for example in place of an a is less than b so that you can combine them with ands so like if i wanted to check that isbn existed so i'd do it at isbn and um is empty at a so i wanted to make sure that isbn existed and um an a key existed with an empty string for for some fictional is empty extension so the answer is yes it's on the slide and of course we could emulate this by restricting input and output of extensions to adjacent values because we do have true and false there so that's that's not a type system problem that's more of a problem with the way the syntax uh works um so i i hope this can be solved but we would have to uh look at that okay would it be beneficial to not include that first as a as a first go well these are two different proposals limiting to json values and and having the whole gamut of types that we have in"
  },
  {
    "startTime": "01:12:02",
    "text": "json uh path these are to me these are two different proposals and they should be evaluated against each other yeah i think the reason i bring it up is because we've already declared that a false literal in an expression is different than um the a is less than b result of false yes so i think that there's some i think it brings in some gray area well you cannot leave it grey you you have to to define it um right so um we would have to define what uh what allows us to put in a function in a position where a boolean expression or actually a parent expression is expected in the syntax yes okay glenn um just wanted to say i'm i'm fairly uncomfortable with all this uh in terms of the benefit compared to the cost um i think this is the right direction to go in terms of exploring the options we um extension points at this stage to being in filter expressions i don't think they they we have an example of using them anywhere else oh in indexes you mean yeah sure well yeah for example but you know i'm very happy if we scope it down to say inside filter expressions get a handle on that first and then consider expanding it later which is in the pro well what do you mean i've seen i have seen people you try to do a dot link at the end of uh adjacent path in order to try to get the the length of the array returned"
  },
  {
    "startTime": "01:14:00",
    "text": "um i don't know if that's what you're talking about glenn uh no it's just a general statement but that's a good example i think that um you know that that might be advantageous if we limited the extension point to be applied in filter expressions then i think that simplifies the task of dealing with errors and you know absent arguments and things like that because it you know the the filter then just simply does not return anything right or it did yeah i tend to agree to dim to restrict it to filter expressions at first yes yeah i agree with that except if we find out it's just so cheap too loud in other places that we just can just do it suggestion about the tactics that we adopt you know let's look at filter expressions first and if we get a nice clear spec for that then we can look about extending it if doing filter expressions torpedoes the whole thing then we don't need to worry about the rest um you know so putting my my co-chair hat on here um if this there's some there's some what's the word i'm looking for dividing line in terms of complexity if it becomes apparent that getting this right is going to require 14 more months of professions at that point i would be inclined to hold that that's a demonstration that the cost benefit of this work is not favorable and we might have to live without it so you know yeah i think i think the way is clear to uh"
  },
  {
    "startTime": "01:16:00",
    "text": "taking the next steps which i think is focusing on length to make sure we understand at least that and probably restricting ourselves to filter expressions but there's a limit to how much we should invest in this that's all yeah i think i'd be happy if this if if we released and then this showed up in say a v2 of jsonpath yeah we just have to make sure that we don't uh put roadblocks in the way of doing that so kirsten are you going to take the next step here and i certainly will do the length thing i would ask everyone to to supply examples so when you find anything uh in your daily work that could look like an extension the exercise of an extension point and json path please submit that as a comment to the extension point issue what's the number for now are we considering um only singular paths inside or as arguments not like like we only allow singular paths in expressions would that extend to functor arguments as well likely but if you find an example for in another in the related language that is not bound by that that would be an interesting example so plea please don't restrict your searching for that okay i think i might be able to devise a few use cases for having a multiple path as an argument okay okay so i think uh we have you know made"
  },
  {
    "startTime": "01:18:00",
    "text": "some progress in understanding the complexity of the issue and and i think the idea of limiting this to filter expressions is is is has merit and is worth serious consideration and i think we've uh and so i think the next step here is for kirsten to uh convince us all that this can be done at least in an example by doing uh by doing the length function um right up is that fair statement of where we stand fair enough yes um i don't see other agenda items but i do know we have a couple of open issues should we turn our attention to those at this point greg one more thing on this extension method thing at some point we will need also to define how other people define extensions and then what that interoperability looks like because if if you have a json path implementation and you define an extension for it and i get one of the jason pass that was written for your implementation i might not know what that extension is um so we would need to we need to take that into consideration at some future point we've got enough to do i'm just bringing it up yeah that is pretty much standard fare in in this space because if you make something extensible you have to live with uh interoperability between components that have the extension and don't have the extension and there are a number of things you have to get right and the most important one is not to create false interoperability"
  },
  {
    "startTime": "01:20:02",
    "text": "which is where where one implementation thinks uh it can act on the extension but but doesn't have everything uh it needs to do that yeah we're dealing with that in uh jason schema right now are people okay with looking at a couple of other issues we have uh time left yep okay so um so let's start doing the reverse order we have number 195 which is for exist expressions does it really need to be a singular path um and let me see did this discussion converge um i mean just on the face of it it strikes me that there's not a real big benefit of having a singular path and so i think the answer is possibly no glenn karsten did you guys come to a convergence on this well i just noticed it as as something that that looks odd um if you look for something and you have to make sure that you you cannot find two before you find out whether there is one at all that's weird to me um but i i didn't make a specific proposal what needs to be changed to to allow that yeah my concern with this is um do we mean existence of a you know suppose we've got a path that delivers two values or one value okay yeah sorry actually yeah sorry i'm i'm talking nonsense while shut up"
  },
  {
    "startTime": "01:22:02",
    "text": "i mean i it seems to me that if i say exist and give it a path and what comes back isn't empty yes it exists okay i mean yeah seems reasonable actually i haven't actually looked at the at the comparison page about how other things do this but it but this restriction does really feel very artificial here it is very nice though that only singular paths are um used in expressions just in general it's convenient for for us it may not be convenient for a path author so we're really just talking about extending the the syntax a bit don't we so that we allow non-singular path general paths for existence does that screw up the grammar for the rest of i think and i mean is this going to be awkward do we have general paths that start with the at symbol i don't think we do we do not know well i don't think we have that because that will return multiple values yeah but that's the point isn't it if we allow yeah yeah okay"
  },
  {
    "startTime": "01:24:02",
    "text": "i mean even even descendants can return multiple values right yeah and you know i think it's perfectly reasonable it does there it doesn't it does a particular descendant exist and if you know it exists in five places you know i mean i still want i don't want it to be false because there's more than one yeah so the the observation here is that uh we currently don't have a way to do relative paths at sign based paths that are not singular it would be a little bit more of a grammar surgery then i expected it might be worth making a note on that pr just to say that this would require us require us to put a full path grammar for the the local item at symbol [Music] why does this require introducing that it won't happen because the syntax at the moment it just doesn't cut it it would mean there's no symmetry between dollar and that in terms of what you have to do okay right i've got a general concern about this that i wouldn't want this if we do this i wouldn't want multiple paths to creep into the rest of the expression language"
  },
  {
    "startTime": "01:26:01",
    "text": "for instance in comparisons because i've been there and it's pretty awful i think what you're saying is if we did this then the rules for exist expression would be different than for other kinds of expressions and is that okay or is that just too awkward i think that was greg's point wasn't it i do not have a strong opinion on this um if it requires major spec surgery you know you could easily make an argument that is not a good investment of time but it does seem a little bit counterintuitive as it currently stands yeah i think it would be a very local change to the exist expression production yeah i don't mind that so if you inside a filter expression as it exists that would filter out anything that isn't that filter out any item that is an array or an object so you would get arrays and objects back and if you have arrays and objects that results in an empty or a non-empty set yeah non-empty arrays and objects yes"
  },
  {
    "startTime": "01:28:08",
    "text": "okay so i think the action item is glenn is going to try and see if this can be done without grievous ugliness in the spec okay what else do we have here in our issues okay so we have um selector classes don't feel right from greg uh let me pull that out this is number pardon me this is um number 201 yeah so the way things are specified the way the grammar is specified just doesn't line up with at least with how i've implemented implemented it and um at least one person has agreed with me um but it seems like the the uh sentiment that i got back was that it doesn't have to um my feeling is that if we were to say that the if we look at the list list selector it's basically just a comma delimited collection of the other things so if we if we say that the list selector is the only thing it's got you got the square brackets and then a list of the other things in between it and you know if you only have one then that's just the other things i think we could collapse things a little bit better in the grammar um and it would actually align with how at least i how i've implemented it because i don't have a separate"
  },
  {
    "startTime": "01:30:01",
    "text": "list selector i just have okay i've gotten a bracket i expect a list of indices and an index can be what we explicitly call an index which is a number it can be a slice or a range it can be a filter expression a name can be any of those things that exists inside the brackets comma delimited but i don't explicitly have a list selector per se does that does that really make sense at all well this is essentially an editorial comment on how we name things i think so but it may impact how other people implement the spec and i don't know um um yeah i mean just responding to that last point uh it could affect the way people implement i think the spec should be geared so that it's readable by users as well as implementers and in fact i would expect the number of readers to far outnumber the number of users i disagree with that um having lots of spec experience in jason's schema i can guarantee that the vast number of users do not read the spec they read blog posts they read other people's like you have some people a small set of people who implement this back you have another small set of people who read the spec and then go write blog posts about what they think the spec says and then the vast majority of people read those blog posts or they don't read anything at all and try to figure it out for themselves and then go post on stack overflow when they don't get it right yeah yeah but this my involvement in this came about because a few of us in our team wanted to use jsonpath and couldn't find us back"
  },
  {
    "startTime": "01:32:03",
    "text": "yeah i think we have to be realistic on what percentage of developers want to read the spec but we also have to accept the fact that those people who actually explain things on stakeoverflow actually do need a spec to work from so we we have a priest class here that that kind of mediate the the connection to god um and the the specification has to be good for that priest class yes do you think the priesthood is larger than the implementer class okay that's fair but i don't i still don't think that the uh the way that the the grammar is specified is ideal for the reader whether it's implementer or not greg have you produced uh have you proposed a concrete alternative here i am looking um it is in there it's it's not uh it's it's in the first comment where i i've i've posted the alternative but um i could probably rework the a and b f a little bit better a b and f a little bit better would it be fair to play greg completely i mean would it be fair to say that you'd prefer a grammar in which there was less duplication essentially yes yeah you see i i think duplication is actually helpful for readers who want to examine a particular selector because they've got fewer depth levels of uh selected to go through a few levels of documentation to go through you know for example uh you know list they can just go there and see that it's a list and then uh they um they can then refer to one of the the other selectors and they're done"
  },
  {
    "startTime": "01:34:00",
    "text": "rather than having what is it a list of that's the question the other selectors are just singular instances of whatever the thing inside the list is i think the the problem we're running into here is that we need a second term and and you are trying to really find selector to be the second term and then we are in lack of the term term for what is called a selector right now and i actually would be happy if we could find a term for that we briefly had index for that there may be other um ways to to call this thing but really we should come up with a term for for the thing that goes into the comrade common separated list uh within the brackets uh first uh and then it it suddenly will all be very easy okay i'll see what happens okay i think i'm gonna say that um this does not actually affect the meaning of what we're trying to say and is thus primarily an editorial issue and it is anybody who wants to uh propose a better wording uh or expression to propose it concretely as a pr and then we'll see if we're if if if it convinces us yeah i can take that okay good kirsten you're still on the queue do you want to say some more no i just uh wanted to say what i already said okay okay let's move on to another issue then um do you do extension point branding i'm not going to talk about branding here um oh right and the last one is glenn's issue about the list form of the dependent selector which is like which i can summarize as saying that uh our our current draft departs from the consensus which which issue is that two through two number two three two"
  },
  {
    "startTime": "01:36:02",
    "text": "it's yours glenn yeah but a question remembering it uh i mean i think our charter is pretty clear that whatever we whether we like it or not if there's a consensus among the implementations that's what we should do right is there that's what glenn says according to comparison i think it was later argued though that the consensus didn't exist because something about how that report is generated yeah that's right in the comparison site that i wasn't aware of my paging mechanism isn't working very well on this issue and i don't remember much about it so definitely go and read it again yeah i i agree that it needs to be that um the descendant selector ordering needs to be specified i think we do specify it though i need to go find that um it's where i think we do specify it as you select the item you select its children and then you select the next item in its children etc i believe that's already in the spec yeah uh it's coming back to me now i think the comparison site sorts uh the results to get a kind of"
  },
  {
    "startTime": "01:38:01",
    "text": "better better handle on a consensus but these sorted values are actually not what the implementations are giving back so i think some of the main implementations in terms of the behavior as far as i had understand this issue part of the problem here was that you have two iterators one iterator is iterating over the list selector and the other iterator is uh iterating over the uh the descendants in and so if you uh swap what the outer iterator is and the inner you get different uh result lists and i'm not sure if yeah we could explicitly define it maybe it's in one sentence we should mention it how it should work to to get always uh reliably the same results yeah i think there the two orderings can be uh described as a recursive ordering which is what i described earlier or um what i'm gonna call a queuing order where you cue all the the first level results and as you visit each item you then cue its children um that way you get the first side first layer of results then you get the second layer of results the third layer etc is this depth for this breadth first search yes uh sounds like yes"
  },
  {
    "startTime": "01:40:00",
    "text": "okay i now re remember pull request 233 uh which addresses this issue attempt to address this issue um and i think uh the only objection to that came from tim on a kind of technicality one of the side points regal so a way forward would be to have a bit more of an extensive review of this pr i think yeah oh right right right right right oh i did not connect to the issue and the pr in my mind yeah at the bottom of the issue is the link to the pr that's what saved the day oh and i'm up for a review there sorry yeah so the action point is for the people who are listed as reviewers to review the full request yeah um ah dang it i mean tim i don't know whether you want to discuss that detailed point your comment um major changes but wait a second the thing i objected to does not seem to be related to the ordering of the output does it am i missing something it's not i mean really i should have kept that to a separate pr um but i i just noticed it on the way through so i put that in it's just a simplification because we we preserve duplicates so we don't need to make that uh okay okay i get it i withdraw my issue that's my objection that's fine okay thank you but i i now that i i didn't actually look at the wording change on thinking about the order results in my"
  },
  {
    "startTime": "01:42:00",
    "text": "head so i'll go back and have another look perfect okay so our action item there is to look at pr233 and see if we are happy with that in the context of this issue okay so oops okay going back to issues so that as far as i can tell um more or less kills all the issues modulos some incoming prs uh with the substantially only remaining substantial thing being the extension point proposal which we are going to see so what is our scheduling from here yeah that's that's a good point um i think it depends a lot frankly on extension points i could i i'm worried that that's going to lead to a very long delay but it's impossible to say without looking at it so what what time books do we give ourselves for that so it's now august um how's your schedule carson when can we expect to see well term starts in mid-october so i'm in a position to get some work done good okay so i mean if we can"
  },
  {
    "startTime": "01:44:03",
    "text": "do that you know in the next month you know before before in the next few weeks then we could potentially do a working group last call this year right yes i would like to do that i would like to do a working group last call this year i think we've worked on this for a long time i actually would like to do it be so that we can close the working blast call at iitf 115 when's that november that would be great at least one more interim yes shall we put something in late september i can't do week 38 but everything else works for me uh which week is that september last week starting the 19th of september why don't you go ahead and do a doodle uh for week 39 is that look for you week 39 cast and the week starting september 26th yeah i'll put in a doodle poll for that"
  },
  {
    "startTime": "01:46:00",
    "text": "week unless folks have better suggestions um just to be clear uh i think we've been doing these at this time maybe to get around my schedule now that i'm doing this kind of thing full time my schedule has really opened up so we may be able to do these things a few hours earlier if it suits people like tim who are up at what three in the morning now something like that no it's not it's not you greg it's the fact that aside from you and me everybody else on this on who's contributing is in europe and so we've been doing this at a convenient to europe um i i you know i may have dark feelings in my head but it actually makes practical sense to do that and i can handle it you know once every six weeks okay yeah my main concern is it doesn't interfere with me taking the kids to school and picking them up that's my schedule right now this is an okay time for you then oh yeah 10 a.m euro works much better for me than 11 a.m because that infringes on lunch time and never to a central european good to get your priorities right isn't it yes okay okay i think we are done for now then no yeah very good okay thank you everybody thank you i have written notes into the the hedgehog so uh of course these are not official"
  },
  {
    "startTime": "01:48:01",
    "text": "notes but if you need some reminders for what we discussed of course i was also discussing so that the notes may not be complete uh on the other hand uh this is a hedgehog so if you see something wrong with those notes and want to fix it uh that could also help so just where are those do you say i just put it in the chat oh right grab that before i delete the window thank you carsten all right thank you everybody good night thank you thank you thank you have a good lunch you"
  }
]
