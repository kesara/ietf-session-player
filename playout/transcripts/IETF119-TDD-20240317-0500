[
  {
    "startTime": "00:02:06",
    "text": "Everything, you'd get out of reading all the RFCs. Is to give you a core flavor with the protocol dense. And, you know, as we're seeing the slides here, this isn't talking about any specific implementation. This isn't about Internet routing as a whole. And this is not a deep dive around security stuff, although we'll talk about that a little bit on through say. So in terms of what it actually is about, This is about high level protocol elements. You know, pretty much everybody in this room probably has written at least some is that PDU? So this is not going to be that"
  },
  {
    "startTime": "00:04:17",
    "text": "So, PGP is a, a path factor protocol, which really means dis inspector protocol, which really means that it's just ripped. And there are, a lot of people in here who really don't need to be at at this talk because you already know know, everything there is to know about BGP, but you're just here too. Throw peanuts at us and, you know, make sure that we stay honest. So I'm I'm gonna assume that everyone knows enough about it means to be, you know, disinfector protocol or a a bellman Ford protocol. And that's all we're gonna say about it here. So it's in 4271, and then a cast of 1000 of or at least dozens of other RFCs And, it's it's the internet routing protocol. They general, the the the the main abstraction unit is, you you build, you, you know, you have ASSs Probably everyone in the room has heard of ASs. I hope. And, You can abstract the internet as a bunch of ASs that talk to each other. And you can look inside the ASs and look at the routers that make them up. It started out as a ipv4 only protocol because I IVV 4 was the only thing and it turned out to be extensible enough that we could wedge ipv6 into it and then we could wedge a lot of other stuff into it and we just keep wedging things into it over and over again. And Jeff did a very nice"
  },
  {
    "startTime": "00:06:00",
    "text": "talk on it, and you can see it at that. URL there? Yep. In terms of wedging stuff in, that's a lot about our Thursday talk is about. So look at that. We left my tag in there. To So, Yeah. What what's an AS? It's a collection of resources that are run by the same administration. It's defined by an AS number, which is the 32 bit thing that you get assigned to you. And There are 2 basic flavors of BGP. There's IBGP internal BGP. That operates inside the AS and there's external BGP that operates between assets. Generally, the, the, the idea on IBGP is that you wanna have consistency between all the routers in your AS. Generally, the rule on EPGP is that people do policy, and they can choose between what their neighbors send to we send to each other. And sort of building out that you can think about the IPGP piece, you know, very much like this is your work. I b or IGP flavor of BGP? It's very boring, or at least we try to keep it as boring as possible. BHPS John said is all about policy. BGP is actually a very straightforward protocol when you work from the RFCs. Most of the challenge for BGP is making it scale. And providing mechanisms to operate it with some, you know, simplicity. So most of the headache for BGP, like I said, is No. How to operate it, how to make it scale, we're gonna talk in this, discussion about what state is that we're passing around. So the the key concepts in B2B that are important is that We have network layer reachability information, and LRI basically, you know, the thing you would normally think of a route. But for BGP, an actual route is a pairing of an MRI"
  },
  {
    "startTime": "00:08:03",
    "text": "plus a set of path attributes. The path attributes are a set of properties that go along with that destination. We're gonna talk about what those things are. BGP is a stateful protocol, you know, unlike rip, not gonna get the same message over and over again every 30 going to hear it once and you're expected to remember it forever. And that impacts an awful lot about how the protocol meets the past stuff around. Actually one of the things that makes it popular. Gotcha, of course, is that if you lose something either because of a bug because you've intentionally thrown it away using policy. Well, you have issues, their mechanisms to get stuff back. And, you know, again, that's part of discussion how BGP is involved. Just to add, there are mechanisms to get stuff back. If you know, there's something you need get back the protocol will not be kind to you, though, in terms of telling you that you lost something many of our other protocols do have ways to, to notice that you've lost information. PGP is not such. Easiest way to think about BGP at a high level, and this is one of the things that's made it attractive target for a lot of people to do interesting things with, it's effectively a key value protocol. If you think about it that way, a lot of BHB seems simple, and that's what the trouble sometimes. Right. So, We anybody who has done anything with BG for more than a few minutes has talked about update messages. And That's team. You know, almost the entire life sa life cycle of any given BGP session is just a whole bunch of exchanges of update messages. It's what you carry routes around in. And you either advertise routes, which, inject new state or they change state. Or you explicitly withdraw routes. You, a lot of the Effort. In building BGP extensions has to do with trying to make sure that you maintain,"
  },
  {
    "startTime": "00:10:01",
    "text": "packability, meaning that you can if you if you have multiple NLRI that all share the same set of attributes. You wanna be able to gather them together. In the same update message. This ends up making a big difference in efficiency. And the efficiency, and this is one of the hidden messages behind BGP. Reason why you care about packing is that you tend to see the CPU load for BGP. Mostly on a per update PDU basis. Most of the work is taking your path attributes and building your data structures and doing stuff with them. There's a good incentive to try to amortize that work. Now in terms of that work, well, you've done all the work for parsing these things. They have to go into something. Well, you know, it's sort of, an OSI type speak because that's where we started this stuff. At should be routes go into the routing information base bases, the ribs. The ribs are keyed on those annual rise that we talked about. Again, why it looks like a key value, protocol And we have 3 views that BGP tends to use, 4 things. And if you look at how they would classify things later over the years. Sort of 5 logical views of a pre policy post policy flavor. But the the important pieces are there's a ribs in where you store the routes that you've been given, have the local rib that's where you actually select the route, which we'll be talking very briefly on, but not as much as, you know, deserves in the topic. As the active route that we picked then when you go to distribute the thing, you have a ribs out view. Okay. So, again, it's a super simple protocol. It's connection oriented. It's all configured it runs over TCP. Although there are some proposals to run over other transports, but they all have to look kind of TCPish in terms of their semantics. And, yeah, we exchange PDUs or the TCP sessions."
  },
  {
    "startTime": "00:12:03",
    "text": "Yep. And one of the challenges for BGP is a routing protocol, especially if you're sticking to ritual fix. The timers slow because this is running on top of TCP. are You can't count on the things coming going fast. It's at the order of seconds. If you want something faster, you're gonna have to augment with something like EFD. So, yeah, TCP, like we said, what's good about that. You know, the founding parents of BGP didn't have to invent their own Transport and, transport semantics. You know, you can know, just all the good things about about a stream oriented protocol. The bad things are, every BGP developer has to eventually become you know, somewhat expert in TCP and all the things that make it interesting and edge cases. And every BGP implementation has to do its own framing, which is kind of a pain. Yeah. And if you attended the IAPG talk earlier this morning, you know, talked about DNS and, you know, what transport it actually impacts that. Very much the same here for BGP. No. No. Actual TCP properties you're getting, how the network's behaving, what packets are getting dropped, makes such a huge impact to how the protocol actually works. Again, again, DGP at the top level is very simple, but this is a sharp edge that people run into his problems. In terms of once you've actually gotten your session up, You know, you guys swap messages. You know, BGP calls the messages instead of PBUs. Everybody starts off with a common header format, which You have this big marker thing in the beginning here. It's like, what's this thing for? Well, BGP is a protocol that's evolved over time. One of the things that you have to watch out for, and this is true of most IETF protocols that lived for a while. There are strange things that don't make sense based on the text."
  },
  {
    "startTime": "00:14:01",
    "text": "Better, really, vestigial components from how the protocol evolved. Marker here, Richard, this work, know, security information was put in as one of the earlier proposals. These days, nothing interesting goes in here. Just, you know, gets a bunch of ones. But that said, you know, we've actually managed to have BGP evolve and we're up to each before. We've only burned 5 message types. Right. So, yeah, the lifetime of the the session is you come up, you exchange a pair of opens, They endpoints tell each other their AS numbers. And, a whole time. The whole time is basically a bid for for how fast you need to get, keep lives, which I think we come to in a minute. And a a We don't call it a router ID in BGP. We call it a BGP identifier, and it's, you know, formally just a arbitrary 32 bit integer. And then there's this thing called optional parameters. Do we have another slide that ties down in there? Yeah. We actually dive into the open message here. So Nope. This is, again, very boring. This has roughly been what Beach has been since version 1, you know, with very, very minor changes. As John saying, these optional parameters that are glued down here, this is an example of something that was designed in from the get go but didn't really have a solid use case. Extensibility was built into the protocol without an idea of exactly what we're gonna use it for, the very first optional parameter that went in there was originally the security thing that populated that marker field we're just talking about. Thing that all gets used in there right now is EGP Capabilities, which we'll talk about a little bit later. Right. So I think we already kind of talked through the Beginning of that, there's a state machine. We're not gonna to explain the state machine, it has lots of"
  },
  {
    "startTime": "00:16:05",
    "text": "pointy bits and sharp corners and Jeff worked on it a lot and sorted too. And, I shouldn't be talking to it. They should be. Well, and actually the useful thing out of this is, you know, if you look through the history of BGP, partially see this presentation I gave for analog. The state machine in 1771. Know, was very simple. There's a small number of states that transition for very straightforward. And as part of the process. We're we're trying to actually flush out the RFCs. We found a ton of corner cases. Wouldn't think there'd be that many things, but people, you know, kept on finding, you know, these sharp edges, the state machine, therefore, grew in complexity. So, you know, we try to actually cover a lot of these things inside this 4271 it still doesn't get it a 100% rate. So Yeah. TCP turns out to not be really the right tool for keeping track of whether the thing on the other end is still alive, at least if you're trying to route a network with it. Because having it go away for a few hours is not okay. So We just use the spray crude. Approach of sending keep live messages, and actually, the keep lives only need to be sent That basically, anything that happens on the session resets the whole timer. So, normally, if you're exchanging a lot of routes, the date messages are quite sufficient to, to keep the keep, keep a live going. If things get quiet, then you send essentially just empty headers. Important thing to take out of this is a hidden property. PGP is a slow protocol. You know, you're not expected to necessarily worry about how quick things can come up or come trying to pass state of the loan and you need to expect that it's gonna take it to, well, to go as that something has changed. Accustomed to me, by the way, that we don't talk in this, presentation at all about the interaction between BGP and the IGP, that's important but not covered here."
  },
  {
    "startTime": "00:18:04",
    "text": "Now once the session's up, you have to figure out what to do to take it down. Clearly, if the TCP session just goes away, you know, let's know, one thing that has to be handled, but if you're intentionally trying to signal that you're going down for any reason, one of the messages that we pass around, is the notification contains a error code a sub code, and it contains a whole bunch of data that might be useful for things. For the most part, notifications are very boring. It's a bit of diagnostic information why the session went down, n, No. For 90 something percent of the types, It has no impact on the state machine. There's a small subset of things like Grace will restart and other things that do actually care about this. Things like version negotiation. As much good as that status, know, VGP's version 4, it stayed that way for a very long time. Right. So, yeah, As mentioned earlier, All the good stuff is really inside the updates. And, yeah, RFC 4271 itself, only carries ipv4. So we will cover that first and come to the, extensibility parts in a minute. In terms of the actual message, you know, one of the things that's, noted here is like be curious as we talked about in prior slides. Positive state, negative state. No starting the PDU is the stuff you're withdrawing, the negative state, The set of half attributes, and the actual, you know, reachability, the positive state. Things to note here, you can put positive and negative state within the same packet. The packability is part of, you know, how we get through here. One of the things that's sort of annoying, and, you know, again, this all small sharp edges that don't bite you when you're not used to things. And, you know, we do better these days. BGP is not a 100% a strict No, re rigorous Tlv protocol. You know, in this case, you know, the some of the, you know, field things are implied."
  },
  {
    "startTime": "00:20:04",
    "text": "So you have to realize that the math is not actually done for you in some spots. You know, there are actually a bunch of places in BGP where when you look hard, you can tell when different pieces were developed because people were more or less, strict about really trying to squeeze bites. So, anyway, the prefix encoding should be familiar by now, it's pretty much universal across almost all of our protocols. One thing that tends to bite implementers is, You, you're supposed to ignore the trailing bits. You should really make sure that you course then to 0 and don't count on the, sender to send them to you as 0. There was, you'll be unhappy at some point. One of my favorite bugs is somebody fails to strip the trailing bits. Reachability is technically the same, but you've stuck it into your favorite patricia tree data structure and Well, things don't index correctly. One of their sort of interesting works about, you know, prefixes, you know, encoded in BGP, you know, effectively, it's a stream of these things. They're not separated individually by separate TLVs. They all appear just back to back. And, you know, So we talked about you need to ignore the trailing bits. This means that we have ambiguities. You know, these ambiguities are things that can bite us, you know, at very points, points So if you have 2 byte patterns that have the same, you know, destination if you ignore the trailing bits, but different bit patterns. Well, the spec doesn't really give you a lot of, you know, guidance as to what to do about that sort of thing. And the bigger problem is when you actually have this stream of no prefix, is the only way to tell if the thing is properly formed is try to purse it. You're lucky, you're going to end up at a, you know, proper byte boundary for the next envelope in the packet. The side effect of this is that if you have you know, a malformed set of data inside of your NLRI"
  },
  {
    "startTime": "00:22:01",
    "text": "but it successfully decodes The protocol looks like it's working, but you're sending around trash. This is one of the things that makes, you know, bugs very hard the diagnose. One of the things that, would have been very nice to have added in the protocol have then have at least, like, account of the number of prefixes as a, you know, there should be this number of things present. Next time. So Right. BGP, in the base spec has just 7 path attributes they're very simple, especially because we Bunch of them are vestigial. For example, origin, Yes. Just has 3 possible values. It could be from the IGP it could from, be EGP protocol, believe it or not, And it could be Incomplete. Which means, I don't know. So this attribute is almost completely vestigial. It's just In in effect, the only thing it's good for is it's kind of a course three level metric that people use sometimes. Yep. Can be useful for tie breaking routes. Actually more than one person in this room that actually is, you know, been in a environment using ebge AGP. I am not one of them. Probably the most popular attribute out of BGP that most are familiar with is the AS Path. We talked about earlier that Beach B's path vector protocol, all the the vector of paths in this case is the autonomous system numbers. And, you know, the main purpose for this thing from the get go is This is just simple loop detection. Know, if your AS number is in the path, it's a loop know, very easy to decide if you're dropping things. Very early in the history, BGP, it branched from this is just a thing to use for loop detection."
  },
  {
    "startTime": "00:24:00",
    "text": "Also use it to, you know, provide one of the default ways of choosing routes. Gonna pick the thing that has the shortest number of ASs and AS Path is one of my criteria. These things are only added when you've crossed an ABGP boundary? One of the things that's complicated about this is a feature. This is actually, you know, more than one thing that AS Path can contain multiple types. We have sequences. We have sets, which is mostly deprecated. We'll chat about that a little bit later. And as a course metric, it works okay. And know, if You're a service provider. You start caring about AS Path link your connectivity to various providers because this can actually impact Whether you receive traffic or not, Now, again, HP is a simple protocol. If you're trying to make money with this thing, you want to be densely connected. Therefore a short day s path. Yeah. So the next hop is what it sounds like. It's, when you're affording toward this route and what's what's the next Up. So The most common use case on EPGP be a first party next hop, send the packets to me. I can use a 3rd party next top on EBT. Send the packets to Jeff. In IPGP, commonly. Next hops might be a 3rd party, especially when route reflection is involved, but we'll get to that. BGP also adds in 2 types of attributes that are metric type of things. No. Is not strictly tied broken on the, the, as path length. The first one is this thing called a multi exit discriminator, the med. And, you know, both of these types of metrics are 32 bit values that have opposite you know, importance for, you know, which is more important. Meds, you want to have smaller."
  },
  {
    "startTime": "00:26:01",
    "text": "And the idea for this is between 2 ABGP speakers for this, you know, same AS you want to prefer the exit that is, you know, got the lower number. Oddly enough, this is across the entire autonomous system. This feature causes more bugs in route selection than any other thing in BGP. So it's latter sharp edges here, do it anywhere Years ago, we tried to get rid of it, but it turns out to be beloved of network operators. So you can blame the network operators for this, but terms of your internal stuff, as part of receiving this, you're going to sign a local preference to it. For strange historical reasons. You know, this value is no pretty consistent across implementations. In a a network so that I would pick whatever magic value it wants to do. Higher number is better. Aggregation I can do it this way. Aggregations a feature that seemed very popular at the time. So BGP started, you know, 1 through 3, when we are still working on classful routing. Beach before is what actually got us 2 classless routing. And the side effect is, you know, especially at the time, people cared more about doing programmatic aggregation. One of the things you do when you're making a less specific route out of some set of more specifics you have to figure out how you're gonna handle the tie breaking for these properties. One of the things that went in there is that when you did the aggregation, you would throw all of the contributing routes AS numbers into a set. Dalo. You got all the nice loop properties of this event that all the contributors did not actually get the less specific route. This helps for forwarding and know some circumstances. But it also complicates things for the future. You know, we're actually doing work to try to get rid of this thing as among other things, it complicates B2B security features that we've developed since then. Like RPKI origin validation. So we have sets as one of the pieces for this. Part of the signaling we add to this stuff is there's this aggregator attribute that says I'm the one that did this work."
  },
  {
    "startTime": "00:28:00",
    "text": "It's only informational. Terribly interesting beyond that. Atomic aggregate, if you go reading through the history of things, this one you're trying to implement the protocol, No. It's very clear what it does these days, but if you're looking at how it evolved, you're seeing that this is, you know, actually create a deep pain. This is actually a history lesson in terms of a feature that start off with some reason, got complicated and eventually got abandoned. Makes it difficult to implement the protocol. So in terms of protocol maintenance, this is an object lesson. Yeah. So the encoding is Fairly straightforward, but only fairly. There's you got a you know, sort of typical TLD look. There's a, a bite of flags So there's the optional or mandatory plag. Everything you're ever gonna add to BGP is optional. There will never be anything else mandatory. That's not already in 4271. There's transitive or not transitive. We come to that in a slide or 2. There's partial, which I don't think we cover, and it's Yeah. We'll just skip over that. And then there's this really annoying thing, which is be, This was part of the byte pinching, era of BGP where the length field can either be 1 byte or 2 bytes depending on whether that flag data set. Just annoying. Yeah. And and as John mentioned, it's the the regularity of this is one of the things that makes Parser's lit harder. The gotcha is, you know, The protocol's lenient. We follow the postell's, you know, through them here. You know, you theoretically should absorb as many bytes as the field tells you."
  },
  {
    "startTime": "00:30:00",
    "text": "You're expected to try to be minimal. We have had bugs when people know, decide that, you know, this thing is, you know, less than 255. It should only fit into one byte. They only decode one byte in the wire. This is a case where paying attention to what the protocol actually says you're allowed to do. And, you know, leniency could be very critical. Yeah. So transitivity. Transit this has been, like, the, the source of quite a bit of angst over the the life of BGP. But it's also a source of a lot of the power, I guess, with with great power comes great ability to issue yourself in the foot. So, Path attributes can be transitive or non transitive. The transitivity that we're talking about is across routers, not across any higher abstraction units than that. If, if a path attribute is non transitive, That means that, the router that receives it had better be able to decode it and understand it in you know, if it does, then it'll do whatever the specification says it's supposed to do. Including, by the way, transiting it, I mean, but which is sort of semantic legally regenerating the attribute, not passing it through. If it's a transitive attribute on the other hand, if if either router received this thing, and I don't know how to decode it. And I say, oh, that's fine. I set the partial bit. Remember that? And I just go ahead and pass it through as a bag of bits. This is powerful because it, is actually what has driven a lot the You know, long life of BGP because you can push in new features without having to to forklift your whole, network. But, I think in maybe the next slide or so, We No."
  },
  {
    "startTime": "00:32:01",
    "text": "Anyway, it, can really lead to some fairly severe pain. One step down. Yeah. The the only relevant thing to hear mentioned Do we have another slide on that? optional piece. You know, as John mentioned, pretty much everything outside of a few attributes from 4271, you know, are gonna be A few of them are mandatory. Mostly what this has done for us outside of historical nature has led to bugs. You know, there's a lot of interesting security headaches that have popped up over, recent times. With people, you know, being more or less strict about this sort of thing, you know, based on what the RFC says, and I think this helps us with. It doesn't really help you to say if this is really, you know, mandatory or not, you care that the actual data is there, the bit just to say this visual thing that causes issue. As John's saying, you know, we get to what does this transitory do for us for adding new features. Yeah. So, the reason that we're still talking about BGP 4, 20 years later or however long it's been. Is because it's fairly easy to shove new stuff in. As long as the thing is transitive. It can go all over the internet even though the whole most of the internet doesn't know what the thing is. So, right, one of the I don't know if it is first example, but, you know, certainly the first well known one is BGB communities, which are you know, just bags of bits that you can write policy related to. And and one of the things that this is, highlighting for BGP as a property Now do you know about this thing? Are you ignorant about the feature or not? It also gives you a sense of scoping for the protocol as well. And, you know, Yeah. We get to all these fun pieces with transitivity as John's getting. If you're ignorant about the thing and you manage to pass it across some portion of the network that doesn't understand it, and then it pops out somewhere else snow at a place that does understand it. And it's broken. Well, the original piece of the protocol said, Well, you just sent me a bad packet. I'm tearing down the session."
  },
  {
    "startTime": "00:34:00",
    "text": "Which was penalizing the messenger rather than, you know, the person that actually caused the problem perhaps far away. This is one of the reasons why BGP from a, you know, security and a appointment standpoint has been sort of scary because when stuff happens, the blast radius is undetermined sometimes. Is one of the security discussions we regularly happen. We had a series of, choose along these lines that eventually causes us to say it's time to change the court error handling for this so that we don't penalize the messenger. We have to decide what things are correctable and what to do about it. Okay. What are we talking about Yeah. The decision process is, super important and, super fiddly, and we're not going to dive deep into it because of the super fiddly part. In particular, within an AS, especially if you're doing hop by hop forwarding, it's you know, of paramount importance for everybody to be running the same decision algorithm, And it's Unfortunately, fairly common for people extending the protocol to think, oh, Yeah. I just need to change the decision process a little bit for my new attribute and to not really think through what the implications are gonna be, when that thing is deployed. So that that's, I think, probably a a a fairly big hassle for both the protocol the implementations and the working group to, like, sort of come in at the last minute and say, this specification you wrote for a thing who you didn't really think very hard about the decision process and now we have to cycle it back through the working group another time or 2. And part of what's being highlighted here is"
  },
  {
    "startTime": "00:36:02",
    "text": "difficult it can be to do incremental updates when you're doing new feature that's just carrying the new state, that's easy. You know, it is we're gonna get to when we talk about V Six and later, you know, adding new you know, things that carry, also not hard. Changing core behaviors, You have to do it within a scope, though, so that is consistent. And that means that not only considering how the feature is being encoded, which is most of what this talk is about, also how it's incrementally deployed. Okay. Well, ipv6 is was obviously sort of like the first big test of BGP's extensibility. If BGB hadn't been extensible enough to carry V Six, we'd have BGP 5 now or something else, but it turned out that it was extensible enough So And As we talked about it for, like, several slides back, Death attributes are The Magic tool for extending everything. Yeah. And in terms of, you know, what do you do? Well, just gonna shove this stuff into an existing container. This should be familiar anybody who's done other working groups where this just can go into a sub sub sub sub Tlv and, well, we'll get away with no murder. What do we actually do here for curing multi protocol stuff? Well, you know, part of the things that was created for, you know, BGP is not only rig a carry. Know, the address family in there. We're also gonna add the idea of a subsequent address family. The original, you know, version of multi protocol BGP, this was because not only where we were signaling, you know, the 4v6, we were also having, you know, a lot of fun multicast stuff going on during this era. So the original use case versus the staffing was You know, is this unicast apology? Is this a multicast apology? Later on, we got very clever and started doing other things like VPNs and people are very unhappy about that, but, that's where we ended up."
  },
  {
    "startTime": "00:38:04",
    "text": "As part of this field, we're also gonna carry along not only the Afi Safi, we're gonna carry around the next top itself, and then you start carrying around the not IPV for reachability. So remember, transitive, nontransitive, turns out that it's really important for everybody along the path of the update to understand outed, outed, outed, do the forwarding. For the routes, So it's non transitive. Meaning that everybody is really required to be able to decode it. For it to propagate. And, The this brings in sort of like the other important extensibility piece. Which is how did 2 BGP speakers know that they can talk a particular f. You said f either one another, They do it with capabilities. Well, to hear your ability, it's a thing that you use to advertise support for an extension. And almost all the time, is it's not required in the capability spec that they be exchanged bilaterally, but that is usually the case for for most of them. They're encoded into that. I remember at the beginning, we said there was an optional parameters field. There's essentially only one optional parameter and that is the capabilities parameter. And the reason for that is kind of lost in the mist of time, and I don't wanna dive into it. fault. Yeah. I'm sorry. It's all John's It's not all my fault. Just half my fault. And, yeah, why don't you talk to the, annoying bit there? You know, so one of the gatchers is that, the the clarity about what happens if things pop up more than once. What's the level of clarity, especially since one of the"
  },
  {
    "startTime": "00:40:00",
    "text": "perks that got within the protocols. And, you know, it's like you're making up as you go along. This is, again, a piece of the lesson here. You can get away with doing something that makes sense at the time, but whatever choice you make, the inconsistencies are gonna bother you later on. And one of the things that capabilities have is that you can encode them either as one optional parameter capability, with the vector of the capabilities in it, or potentially more than one of these things, this leaves ambiguity about what happens if giving capabilities present more than once. Does it actually mean? Actually, the, it's not on the slide, but the moral of the story, for me about that particular annoyance is that that crept in because the original capabilities spec wasn't the cryptive enough about that exact question. So one set of implementers implemented it one way. With all the stuff implemented under one capability and another set of implementers. Decided to repeat the capability again. And by the time we worked out that there were these 2 different behaviors in the field. It was kinda too late to go back and fix it. So we just permitted it both in the specs. So be prescriptive. And, become prescriptive, you know, what goes inside of the multi protocol capability. Oh, it's an Aphi savvy. And there's this reserved thing. And one of the things that we know as designers protocols and IETF reserved often means here can go extensions for the future. If you're very lucky. And the problem that we've seen over the history of EGP is that Sometimes if you're very careful about your text for this, and people are careful in implementations. Reserve fields can actually be used. But sometimes the reserve fields are not carefully set aside and No. No. Extension tries to make use of it, and then it explodes. So unlike a lot of other, you know, protocols that we have, since the blast radius is the internet, even if people are not technically following the specifications, Well, we have to adjust versus reality."
  },
  {
    "startTime": "00:42:03",
    "text": "So, yeah, BG as it was originally conceived and deployed. At a very similar or as a very simple rather deployment model, which is for IPGP within an AS. Every router simply talked to every other router, and they all told each other all of their routes, and life was good. As you can probably imagine, when you get up to even a few hundred routers in your AS, that starts to be a real pain every time you wanna add a router to your network. And furthermore, will you consider that the router needs to, like, for every route I've got, if I've got a 100 neighbors. I have to copy it out a100 times out at the same interface. It makes me sad. So are you gonna do about that? have to have a couple of core properties anytime we try to remove You know, we sort of, you know, full connection where everybody gets everybody else's routes. Thing number 1, we have to do something about, you know, loops if we're going to add another thing that routes can pass through, how do you make sure they don't ping pong back forth with each other. You know, each of the mechanisms we could talk about have some flavor of extension to handle additional loops. And just as importantly, as we're talking about the incremental deployment of new things, If you're going to change these things, how does that influence the path selection. So you're now adding additional things that it has to tie break on. So I think the first scaling thing that that was introduced. And my name is on this RFC, but it's not to me. I just came along later and and helped fix it. Is the idea of taking an AS and breaking it up into a bunch of subasses, And, within one of these sub ASs, you just have regular IPGP semantics, and in between the ASs,"
  },
  {
    "startTime": "00:44:02",
    "text": "you have essentially EPGP semantics, and, you know, it's just recursion. Recursion is great. As a recursive data structure. The I think Well, there you you can have argue various reasons why this didn't take off more than it did. But, I think the biggest one is that, it kind of requires a flag to ASU deploy. And, Turns out that People owe it to flight days for good reasons. Yep. And, you know, one of the things this also illustrates is that as, path, add additional types that go out here. This was the first example of extension. As John pointed out, this didn't end up being super popular even though some very large service providers do make use of it, and it does have some very nice properties for allowing you to you know, keep things basically in house. Where people went to eventually as the popular, thing was No doubt reflection. Nice thing about this, as top of the list, as John's mentioning, well, don't want to have to scale out the entire network and change all your configuration. Well, you can insert route reflectors basically in the middle of your network with very little change to every anything else. We reflect her becomes a transparent thing. Everything still thinks is just and the reflectors are the ones that have to understand the additional complexity. Well, you know, meant that we solve a couple of our problems. We no longer have to configure a pairing session, you know, for a full mesh. The gotch is that it actually hides paths sometimes. This can be a feature. You know? So instead of having end routers and copies of the route. Well, you have a subset of that If that's fine for your forwarding diversity, great, great, but, you know, there's an awful lot of reasons that people want to add additional paths in there. Loop prevention got solved unlike ASPATHing for confederations by adding a new cluster list in there."
  },
  {
    "startTime": "00:46:00",
    "text": "And as a side effect of that, we also add on a originator ID so that BGP can do normal path selection that would normally tie break at the router ID step, based on, you know, how this thing had got added because this directly connected to the decor. May you check this So one? In terms of, you know, the deflectors, we talked about, you know, some of these features are idGP. Headaches that we have is that, well, what do we want to pass through the network, what do we want to actually, you know, get around the network? For reflector, know, the reflector has to understand each of the things it talks to. We're not in that full mesh anymore. That means that if you want to add on a new feature, path attributes, work fine. When we add on new address families, this means that the reflector is no longer a dumb distributor now actually has to participate to understand enough of this to do the reflection. One of their headaches that we have and based on that, this is a slightly older slide deck. We also have some issues with, you know, what path attributes need to go to the various places of your network. No longer get quite the same ability to, you know, scope them. So we don't have to worry about attribute escape, you know, what features are internal only, versus features that's true only. Yeah. So we invented this Great thing called route reflectors that we gave us, scalability and how the network is configured and give us, give us path heightings, which gave us storage complexity of scaling and communication complexity of scaling, but it lost us path diversity. So then we had to invent a way to undo some of that. And it's this additional feature called AdPaths, which essentially, at a very high level."
  },
  {
    "startTime": "00:48:01",
    "text": "Remember the NLRI is the key that we use, on our database, if basically just extends that key with a thing called path identifier, which is no pick number. So high level summary. No. We started just carrying IPV 4. We obviously carry a lot more things these days. Not just V Six VPN families. We carry a link state in there, not only just just just just just so. Curing the IGP into BGP. But we also have a link state vector routing, networking group based on, you know, that technology. We're also getting you know, discussion now with the cats working group procuring, you know, compute information in terms of compute capacity Extensibility mechanisms. Were built in from day what? And we managed to leverage them. So for people that are looking to prune the protocols down bull thing, and I have great sympathies for you. you know, you know, But we have no These sort of historical pressures that show us that they can actually be a necessary and helpful thing. Yeah. What else? Yeah. That's really it. I got no Yeah. I'm scoping. Scoping is very important. So one of the things you'll be seeing worked out of IDR right now is discussions about you know, after we escape, This is where things that are maybe your VPN stuff that's getting out on the internet and causing clarity. Yeah. Let's yeah. Part of our security discussions. One of the other bigger discussions that this is moving into is how do we actually continue adding things in the BGP making sure that, you know, we don't break the popular, you know, things that you care about. Internet service providers don't want the VPN feature of the day. Crashing their net And, you know, a lot of our discussion on Thursday is going to go over the, you know, the how do we shovel additional things in the BGP and, when is that good?"
  },
  {
    "startTime": "00:50:00",
    "text": "What is that bad? But, you know, the feature. answer is when it it's good when it's my feature and it's bad when it's your Yep. And if you're trying to ship RFCs for a living, well, you know, certainly BGP is a popular tried to do that. You know, DNS being the other one. And and that's at, you know, the sort of like the final point is know, going through the history of BGP, get to see all these strange encoding issues. You're seeing history we got there one step at a time. Eventually, as the new coder, you're willing to say, why why did we get to your is making for messy code. And unfortunately, this makes for bucks. Now, BGP is kind of the English grammar of, of protocols. It's, you know, it It shows its, multiple inheritance and, and it history in all of its irregularities. And that's what makes it beautiful. Yeah. So we're not trying to cover anything else further in the protocol. You know, these are all high level details, some of the things that actually have helped it, no grow. Certainly, you're willing to, you know, if you have questions for us, we're really that at this point? I think we have a little bit of time for We have 10 more minutes in the session time, I believe. And, you know, we'll, as Jeff said, we'll also be don't have any place to So thank you for your attention. Hi. My name is, Aytu. I'm from Excusement Networks. Distributor. Vendes. My question is regarding the provide reflectors, Very good. Stuff, borrowing that I have, I think, which you've gathered here is that If you have 2 reflectives, Right? Let's say your package is only available on 1, a Not available in PE. Saint Ryan, Right? You are trying to inject the prefix into the same client"
  },
  {
    "startTime": "00:52:01",
    "text": "sending it for the other reflector Is that something that you guys are working on? So it's the general expectation that the reflectors, just like all IV GT, you should have consistency. So if you have some destination a that is present on 1, but not every rails, you know, it's suggesting either a bug. Or suggesting that, you may have, you know, policy configured in your IVGP, which is not usually what you want to do. It's a problem. You said with IBGB, you can't change. You can't send it again because it's this is BGP. You can throw policy wherever you want to, and it will usually do you wrong. Right. The the the other thing I would point out is BGP just like most of our routing protocols is an eventually consistent protocol. Which means that any given time, you're not probably gonna have a consistent cut across your whole Yeah. So so at any given moment in time, it's likely that you're gonna have a slightly different set of routes that you've learned from first reflector and the second reflector just because of timing issues. So just because right now, I only know route Foo from that router over there doesn't mean that, you know, in a few microseconds later. I'm not gonna also know it from from that reflector over there. Not sure if that speaks to your your question. Yeah. Because it's totally different. Okay. Perfectors on as well. Okay. I'll have to get Right. Yeah. Mark Moshe. Any plans for running BGP over quick. Easy leading question. We'll talk about this. Did Jeff pay you to ask that? We'll Not of be talking about this very briefly on Thursday. lot detail, but, yes, a you know, so solving some of these sins of TCP. You know, we're We're talking about that TLS is sometimes a misfeature We'll talk about that in terms of security. Sometimes bad for you on Thursday. But, you know, the important thing that I think quick is gonna give us and"
  },
  {
    "startTime": "00:54:01",
    "text": "Jeff Tensorr, myself, Alvaro, and Nyingzhitin, are working on, a spec for this. For us, the key things are, you know, not just running TLS. Sometimes security is a good thing rather than a bad thing. Sometimes, you know, you could be faster, but BGP is a pretty slow protocol. You know, trying to apply rocket fuel to make it go faster. Gonna make your CPU eat the routes any faster. Where it's sort of an exciting thing and what's in the main part of the spec that we have is these affix safix that we have for the multi protocol stuff, are no longer one monolithic data stream We now can split them up using the quick streams that they're kept inside and simplifies her error handling. Jim Reid, a BGP version. I just take a previous point about BGP over correction. It should be BGP over HTTP. I that's what everything was being done these days. Anyway, by quick, I I digress. My question is really for naive types like this health is there any guides for implementers, and I've been doing both sciences people activating the court. And also for people configuring BGP in their systems as the avoiding the obvious mistakes and avoiding the stupid things that could cause the obvious problems that you just alluded to. In your talk. Great talk, by the way. Much appreciated Go ahead. Take a step. I can do 2. Yeah. I mean, towards coders, I guess we sort of tried to hit the high level bits in this deck. I don't know. I think it'd be great if this was captured somewhere a more formal mechanism, perhaps even as a a best practice BG RSC or something like that. you. I have a thing for If you talk to Tobias Fibig, who is at the conference, he is, you know, agreed to pick pick up the work for BCP 194, which is a common set of operational things for BGP, where some of the wisdoms trying to be written down, part of what he's, you know, finding is that when you try to boil the ocean, you have to do it a liter at a time."
  },
  {
    "startTime": "00:56:02",
    "text": "So the challenge is how do you actually take all these common pieces of wisdom, which are Operationally applicable to specific scenarios. BGP is this protocol that's simple, lots of extensions, where you deploy it, how you deploy it, what you use it for, all change the different pieces of this equation. The flexibility makes for complexity, the complexities, what kills you most of what we're talking about for network operations in general, and this is great for, like, the, you know, Nadar and Ryprouds, How do you manage complexity in your network? That's the key conversation. The rest of it incredible, you know, versions of some flavor of the feature. K. That's great. Thanks very much. I am Paul Gia from just down the road. You spoke about responsible use of reserved fields. What does that look optical terms. And is it that does it boil down to TLDR always put zeros then. Or is it a bit more nuanced than that. I'm gonna pick 1 very easy one. Yeah. 1, John tried to do as part of work at the 7606 work for know, air handling, we mentioned this, you know, attribute flag field here. There's 4 bits that are defined. They're the top 4 bits. The bottom 4 are technically reserved. Being too theoretically to put stuff in there? And when John was working with all the other, you know, people trying to solve, how do we deploy these extensible things for air handling. There's this idea that we could add a signal bit in there that says that this this update has had something corrected in it. When some of the very first bits of prototype code went in, got deployed across the internet, about 5% of the routers on the internet saw this extra bit getting set on occasion and would throw the session away. You're supposed to ignore it. And it didn't. And it was operationally disruptive. And anybody who's looked at the various BGP experiments across the years."
  },
  {
    "startTime": "00:58:02",
    "text": "Which there are people in this conference that, run and, you know, some of the right people have done it and bore social way than some of the other people that do a BGP experiments. Know, you find that sometimes things will just explode even when you're trying to do something that's within the also So I, I, I think that, in the community, they have the idea that if There's something that, is reserved and must be ignored on a receipt. It's actually a good idea to exercise that and, know, and so, of course, We didn't have that idea. We never exercised it. And, something you don't exercise is something that doesn't work. So Yeah. I think that you know, the TLDRs that you said is probably right is that things that haven't been exercised for decades are probably burned at this point. You know, unless proven otherwise. Yeah. And the thing that we're sort of desperately lacking say, planetary wide conformance suite for BGP. No. No. No. Theoretically, everybody should pass the same safety tests. That's not universally true. Hello, Saket. Yeah, thanks a lot for this. I'm I'm not sure that, that, aspirational deep dive was anywhere close. I would call it a great cheat sheet, right? So this would be a great, Wiki page kind of, what's what's this damn term about BGP. I'm sure I'll find it on the cheat sheet, and that point me to some RFC. Did you ever write some RFC like that? In the way, You take a Skype? Okay. So the the one thing I was missing, so If this is directed to implementers, I think it's mostly the on the wire stuff for the implementers. So one point in time, when I was looking into BGP, there was this magic, what is it, 14, 14 rule set, you know, as path. Selection, there seems to be some standard, and then the reality seems to be not only a varying degree of messing around and changing that. But also a, seemingly not standardized degree of flexibility of being able"
  },
  {
    "startTime": "01:00:01",
    "text": "to mess around and change that. So if you buy one vendor, you are able to do some cool policy and another vendor, you may be able to do another cool policy that change the best cost calculation. So kind of the best IETF state of, you know, messing around with the best path in terms of all the things you should be able to do, to do things you shouldn't do, but, we'll need to look So it sorry? Could I quickly pop in for a second and see if you enjoyed this make sure you come back on Thursday at 5:45 to see 2, which has even more detail related to. Little bit. So to answer your very specific point, One of the dangers of BGP is that we have extensions. There's no requirement for these things to be consistently deployed. So if you have, you know, base 4271 plus extensions a, b, c, and d, m of these impact know the route, route selection that means that you have to decide what the set ends up You're correct. It's not all in one spot. Most of the deep things are in the base, you know, specification several visit specifications add in for their extension. Know, individual things, And, usually, and then this is, again, one of the hidden rules If you're going to deploy that feature, that means that you have to have a assistant deployment within your domain. And that's not written down very well. Right. And and that that's why I was saying, right? Rather than trying to hopelessly try to specify up front all the details. It's maybe, you know, the required flexibility in messing around with the policy so that even if you have different implementations, you can fix them up so that you do get across different vendors. A consistency consistent death path with this specific set of extensions. So that you haven't seen type of policy language. example, policy language to specify For kind of my best path calculation, right? So that that would be, of course, also another way to specify how it should be, but in the first place, it should be a way that you know, you do know you will have the flexibility."
  },
  {
    "startTime": "01:02:01",
    "text": "There, there have been a couple of attempts to, to fix this in a general way. There have been at least 4 attempts to fix in a general way, and and and none of them has, you know, sort of gained universal traction. One thing that makes it somewhat more more pain or less painful, let's say, is that, networks that are hop by hop routededge to edge are a lot less common than they were 4271 was written. And, you know, tunneled forwarding makes a lot of the consistency requirements weaker. And, like, the the final comment, we had this nice formal Formal methods group that, has been spawned for IETF. Maybe this is a piece that they can dig their teeth into of. Can you model this? I'd like to thank, John and Jeff for great help. Think we should have more than this. I know The number 2 is coming. I would like to encourage you to do 3, 4, and 5. Specifically, In ATF, we always talk about the internet. Right? 80% PGP speakers, so they are in data center. Are not on internet. Data center BGP has somewhat different semantics. And, again, Thanks too. Flexibility and scalability of BGP, it is the protocol of choice. I think it would be very, very useful people around to better understand really. BGP in data center semantics. That's a great point. And thank you again. Ericring first. Thanks again for the presentation. Very interesting. Always amazing to see BGP control protocol used to transfer or whatever. Right? So I expecting quick over BGP, not the other way around first. Mostly, usually, and and more and more concerned about the complexity of all the draft updates. I mean, RSC updating on the Is there any Adia appetite. To get a RSE 2470bis And how long would it be if we get everything there? I would like to call. To anybody. Right?"
  },
  {
    "startTime": "01:04:04",
    "text": "I was away My my name is Sue Harris. I've been a long chair Look, I've had four times Like, it sounds funny. I have proposed to this Worked on a bus work with the 4271, which is actually the 3rd variant If you really wanna stop all of the work to do it, you know, I know where all the bones are buried. But every time I've gone to do it, I've gone to the people and said, okay. This is what it takes to do abyss This is how much work it's gonna do, and this is what you're gonna have to give up. And you will have to give up changes that people seem to need. So This is our possible but but do understand the 4171bis is I'm trying to find a good adage. It is a large bag that you will have to carry around, and it won't necessarily seriously give you anything extra. It'll make writing this stuff that you see And, you know, the chairs talk about it sometimes, but let me tell you, I haven't yet seen people wanna stop their forward progress. Yeah. think. We'd we'd we'd love to do it, I But it's, yeah, it's not only do you have to rebuild the jet plane in flight. But you have to take the mechanics that are, you know, building revenue, you know, features and have them rebuild the jet plane instead. So far appetite hasn't been there. Yeah. The the thing that we should be doing, and this is true across IETF in general, it'd be nice to have a road map of the various documents, how they relate to each other. A nice data tracker feature that gives you a graph of things. And when you poke the GP on that, you better have a very large screen. And really our problem here is, you know, again,"
  },
  {
    "startTime": "01:06:04",
    "text": "Nobody has to support everything. This is everybody's favorite thing to extend aside from DNS So our challenge is things and, you know, what we're trying to do example, like, the pet the Astrobee Discape document doing, we're we're taking some time to write down the gotchas, you know, what are the things that problematic about BGP that may not be cleared from the basement. That's for volunteers. There you go. Yeah. Thank you for volunteering. So I I our our queue is empty, and I think 5 minutes over. So thank you all so much for coming. Thank you for your attention. Please, consider coming on Thursday. And I guess once again, I'll remind people about Thursday And also if you have any thoughts of future topics for technology deep dives, please send them to me or something like that. Preferably not now because I just drank 2 coffees and one of these."
  }
]
