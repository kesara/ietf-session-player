[
  {
    "startTime": "00:00:05",
    "text": "stupid window manager never happens on my computer at home all right well this seems good enough good enough and we're exactly on time now oh perfect what happens if i change i don't know stupid okay so it's probably time to start okay so welcome everyone welcome to the meeting of the sixth law working group my name is carlos gomez the other chair is treta bandari and the responsible ad is eric klein there is some sort of audio issues maybe yeah now it's yeah now it's better thank you okay so things as you can see well the chairs and the 80 we are all unfortunately remote this time but then we have michael richardson as our delegate in the room uh thanks a lot michael for helping and also we have mida takers adnan dominique and michael who have kindly volunteered"
  },
  {
    "startTime": "00:02:01",
    "text": "as well and also michael will be our javascribe today so thanks a lot to all for helping and volunteering thank you uh by the way i i think there was some additional part at the lower like at the bottom of the screen which is maybe not shown here yeah yeah okay thank you okay so yeah you can also find on the slide the pointer to the online agenda which contains many links to useful resources and also the link to hedge doc which is the tool that we are going to use today for taking minutes so recall that everyone can join and contribute to the process of taking minutes so feel free to join and contribute to this collaborative process next please so well it's wednesday already so probably most or all of you already are quite aware of this but anyway well this is the first itf meeting that we have since the start of the cockpit pandemic that has some in-person uh component so for in-person participants there are some tips to keep in mind uh please make sure that even if you are in the room physically make sure that you sign into the session using miteco for example by using the lite client that you can find from the data tracker agenda as in fact uh we are going to use meet echo for managing the cube so you need to use neteco to join the queue if you want to do so there is a single unified queue and also blue sheets are automatically generated from miteco so they are not like physical blue sheets and for remote participants mechanism the mechanics are like the the"
  },
  {
    "startTime": "00:04:02",
    "text": "same as in previous fully online meetings just make sure that your audio and video are off unless you are presenting next please so this is the notewell this is a reminder of idf policies on several important topics so please make sure that you have read the note well okay next please and this is the proposed agenda for today so the first slot is the usual chairs introduction which is currently in progress then there will be a presentation on the status update of ipv6 over plc even by paolo then there will be a set of four presentations on the topic of nd given by pascal these comprise the nd multicast address listener registration then the and the unicast lookup also a presentation on a potential use of syslopan nd outside the iot domain and finally a presentation on the idea of prefix registration its applications and relationship with rfc8505 next please then there will be a presentation on the transmission of sheet compressed package of 15.4 given by itself and that will be followed by a set of two presentations on the draft about native short address for lln expansion the first one will be a report on the last updates given by luigi yannoni and that will be followed by a demo given by lee so this leads to a total of 100 minutes of schedule time over the two hours of the session so is there any comment"
  },
  {
    "startTime": "00:06:00",
    "text": "any objection to the agenda okay so if there's no comment let's proceed to the next slide yes so this is the report about the working group documents first of all since the last atf we have a new rfc that's 9159 about ipv6 mesh over blinks so congratulations to the authors and many thanks to everyone who has contributed in the process by giving comments and reviews and so on so then we have two documents that have been evaluated by the isd the first one is the ipv6 over nfc draft which has been like a bit stuck for some time although i understand that we have some news about potential next steps so perhaps eric if you may want to make comments on this which could be like next steps uh yes thank you i think um at this point basically i i need to uh i need to double check with lars uh real quick and then just uh schedule it for uh uh to bring it back to a chill chat um on uh probably not not the first teletub after this meeting but uh late april or uh or may so if lars wants to have some kind of a second last call because it has been such a long time we might need to do that but i'm hoping that won't be the case so i think i just need to update the shepherd right up to i don't know convey whatever people need to know to feel comfortable that everyone who needed to review the document at the l2 l3 layer interaction had access to the definition of the l2 layer so"
  },
  {
    "startTime": "00:08:01",
    "text": "but that's uh unfortunately um yeah it has not uh i've not been able to make it a priority but i'm catching up okay thank you for the update so yeah it sounds like we have a plan for next steps and yeah then uh the next draft that has been also evaluated by the asg is the draft about ipv6 over plc so actually what you can see on the slide with the red and green colors is like not up to date anymore because a few hours ago there were some some updates here so there were two remaining discuss ballots however both have been cleared in the last hours so um actually one of them the one by benjamin still has a set of comments and the authors may need to to see uh whether they still may want to to address them well later we have a presentation slot for this draft and perhaps we can further comment on this not sure if there's any comment at this moment um i i said to you in an email but um i'll say it here i think if they uh if the authors get a dash 11 that incorporates whatever it is they want to incorporate from from men's comments that'd be great and i'd be happy to send it off to the rfc editor from there okay thank you so the next document is the six law use cases draft it was in 80 evaluation also there have been some recent updates in the last hours and basically this is now in last call idea of last call"
  },
  {
    "startTime": "00:10:00",
    "text": "there are a few comments by the 80 but our understanding is they can be addressed in future updates so yeah the document is now in itf last call and the last working group draft is the ipv6 and the multicast address listener registration as you may recall this was adopted right before the last itf and today we have a presentation on the last updates for this draft so other than that is there maybe any question any comment okay so if there's no questions or comments let's proceed to the first presentation by paolo on ipv6 of the plc do you need your slides is this this plc you're doing header compression is that it hello header compression it's the plc plc plc i think it's going to be correct right there you go good so thanks so good morning my name is paolo volpato let's say that as you see i'm not in the list of the authors of this draft i'm presenting on the alpha of the authors represented here um the reason why i'm here to talk about the transmission of ipv6 packets over plc networks is that i had a talk with my at huawei they were not able to attend itf 113 so"
  },
  {
    "startTime": "00:12:02",
    "text": "they asked me to act as a proxy on on their behalf so to update you about the status of the draft and uh explained by the chairs i saw a couple of emails uh yesterday i think which to some extent obsoleted some of the content of this presentation anyway we'll discuss that and we'll see what's the reaction so next slide okay so status you see here basically uh the draft underwent the last call review i think end of 2020 um tail chat and isg evaluation happened in summer 2021 after isg evaluation there were some discuss and the authors were able to say review the draft and provide new versions just to address those discussions by the way the autos wishes to thank all the people who provided their reviews and the result of the asg evaluation i got three uh discusses uh one from eric winker and um i think that was uh let's say addressed by the most recent uh versions of the draft specifically there was a major revision it was a zero nine which addressed that comment and then there were a couple of discusses uh that probably were partially addressed by the list is the versions of the draft one from roman again apparently it was okay after reviewing version zero nine and uh that was completed in version ten"
  },
  {
    "startTime": "00:14:00",
    "text": "and the let's say uh the major point of discussion was the discuss raised by benjamin but i said that happened uh before let's say itf 113 uh there was a email sent yesterday which if i understand correctly um reconsidered the text provided by the authors so the discuss was demoted to comments so something has to be fixed still but let's say probably the discuss is not applicable any longer so that's for the status michael if you can please move to the next slide okay let's jump to the discuss provided by by benjamin so the main point was about the use of the two bits the uh let's say um [Music] universal local and individual group bits in the first byte of the interface ied so basically the issue was that the original draft imposed those two bits to be set to zero but that apparently was creating some issues so that originated let's say they discussed by benjamin um the authors uh reviewed that position so they let they lose the constraint which was described in version 0 6 and basically provided two ways to deal with those two bits so the first mode was to let's say um use those two bits as originally intended so um maintain those bits to zero when forming the interface id or the other mode which was defined in the version 10 of the draft was to"
  },
  {
    "startTime": "00:16:01",
    "text": "leave to the operators basically to use freely those two bits without taking care of let's say how the specification set them originally there are constraints so the operator has to be aware that in doing so it's very hard to move back from the 64 interface id back to the short form of the same interface of the same address as said that was the slide produced by the autos the uh the the last comment by benjamin let's say uh superseded the description provided in that slide so next one michael this then there was a comment uh received during the last call process was about the interface id entropy again uh originally that was not included in the draft but the latest versions let's say expanded a bit how this is let's say um [Music] provided in the draft uh basically the comment from dave was uh it is needed to explain to add let's say some components in the behavior of a of a plc network on how to deal with the uh generation of the addresses or add parameters such as the typical linked time frame or lifetime basically the authors introduced a new section so they expanded section 8 which is about security so they believe this issue is being fixed right now next like this and finally there was also discussed by roman about let's say security at the beginning the"
  },
  {
    "startTime": "00:18:01",
    "text": "draft was not including let's say all the possible mechanisms to deal with the typical security issues in let's say talking with the authors they explained me that actually they tried to expand the base text so again they touched the section eight of the draft and also they pointed out that speaking of security is probably a much broader subject than just the dealing with the typical security aspects in a plc network so just at player two so their idea was to say expand the set of security mechanisms not just dealing with layer 2 for example payload encryption or let's say cross authentication from a device to the pan coordinator but at the other mechanisms at every possible layer of the stack including the application layer so basically they introduced a comment that you see here in the slide additional end-to-end security services that are probably active at every possible layer and they explain me that that is this is also let's say related to the uh user you make of the plc network and of the applications that actually the network is used for so that we can move to the final slide so again when prepared the presentation the authors clearly were not aware of the latest updates so the the main email is sent by benjamin yesterday they wanted to ask further feedback to the chairs whether it's possible to move on uh removing the discus and clearly um having the possibility of developing probably a couple of new"
  },
  {
    "startTime": "00:20:00",
    "text": "versions just to address the remaining comments before entering the publication queue and i will say this is it i hope i've been clear enough uh in any case if there are questions you can ask me or clearly send to the mailing list thank you from the floor go in the queue anyone remotely well perhaps perhaps uh just the point that eric mentioned that the authors may want to consider the comments in the last email from benjamin and then probably the document can proceed further that certainly worked for me oh okay so if there's other comment then we can proceed to the next presentations thank you paulo and next is pascal on the set of four presentations on topics and documents related with labor discovery uh so pre-loaded shares slides for which ones you want her first pascal two-bath unicast look up that's what you would like no okay can you guess me do you want multicast is that what you want first those slides uh multicast is fine yes let's take them in order but i just want to to make sure that we have enough time for the last one so i'll be quick on on most of them just to make sure we have enough time on"
  },
  {
    "startTime": "00:22:00",
    "text": "a prefix advertisement basically because that's where i would like to see discussions so yes marticus please multicast i can pull them myself if you want but just because now you have to give me the right control you should have the slide control now i i'm seeing it yes very nice many thanks michael so so this first line of introduction fits for pretty much the full presentation i'm gonna do so um just giving some history on the work we've done in this group on uh what we call six lopez neighbor discovery but we'll see that has grown a lot beyond six low pound but still we are we are the source of of this work and today i will be talking about um what what what we call unicast lookup which is basically converging a backbone network um for both traditional neighbor discovery and uh the the state for address the configuration from six open nd uh and sharing a six lbr basically to do unicast lookups so that's one draft we'll talk about today and and what i'm talking about now is the multi-gas registration so extending uh basically six lap and nd uh address registration options for any cast and multicast so um since last atf we've pumped a document version twice um one change was minor in terms of edition but it was important in the field is there was no discussion at all about all nodes multicast learning scope multicast group and effectively in ipv6 uh every host is implicitly in that group so just added some text to say well this is true too so if if the cxlr uh sees any uh traffic from a host uh registration from a host so it has the"
  },
  {
    "startTime": "00:24:01",
    "text": "estilio of that also basically implicitly that host is a target if there is an ffo2 column column one packet we have refined how uh this address protection rfc 8928 is leveraged for uh registering address so we have more text on that and that's another draft i'll be talking about today but we are proposing a method to register ipv6 addresses to best so to bgp basically in the evpn environment so using using it 545 as the registration protocol to be redistributed into into a vpn and basically we would like to be able to to register not only unicast but also anycast and multicast so there's some text about that um since atf-112 i'm sorry during atf 112 we've discussed uh any cast and backward compatibility so so that was published right during the atf session and maybe people have not seen it so i just want to insist that that was done and uh there was the the we needed a flag field in theater and we did not have one so we we repurposed the status of the request you know the status only valid in the response and so we we repurposed the status field which was basically reserved on on the uh head message to carry the flags and now we can carry the d-dart is for any caster multicast address so these are the recent changes since so on any question at this stage just interrupt me put your hand up in the queue"
  },
  {
    "startTime": "00:26:01",
    "text": "so basically the question now for this group is um are we missing items is there some more work we want to do here because at some point we need to transfer the token to role i'm not saying we necessarily call or what but role is not yet really observing this document but it's the the main change that we do here is not read the you know the a and m bits in the registration to say any guest or multicast what's really important is how we change the basically the ripple underwear leaf work which is rsc 9010 to expose those anycast and multicast addresses in ripple yield there is the introduction of a new mode of operation mode 5 for non-storing mode multicast so for all those change we need role to take a good attention on this document so basically what i would like to get from this group is a green light say hey we are reasonably happy with with this we can still work on it but we are reasonably happy so we'd like to pass the token to roll so if you guys could comment on the list and and you know basically express comments like uh see it as an only one good place call from this group if you like but it's mostly passing the token on this afternoon we'll be talking about the patrol as well yes so thank you mascara so yeah there was some more discussion initially and it seems like now the document is getting stable perhaps it would be good if anyone would like to volunteer to review the draft at this stage not sure if anyone attending at the moment or maybe we can ask later on the mailing list it would be great yes and also you you if you remember this work was tiered actually by the way son"
  },
  {
    "startTime": "00:28:00",
    "text": "association i mean that's why sun is is a group that standardizes uh technology for the smart grid based on repo and six japan and um i also asked them to publish a review on this list okay and that's that's it for this one uh michael do you want me to pull the next one i think i can sorry there is a question on the chat by kristen has anyone looked at how excuse my ignorance has anyone looked how this works with the multicast registration that is passed of the constraint cast document actually no and that would be a good thing to discuss actually i i i i i remember very well the constraint cast it's just that well that it existed and so but but no i've not i'm not dug into that do you want to we can work offline on that if you're interested yeah we probably should yeah we're welcome so any cast a unicast lookup so so then again same family some introduction um so basically with uh rfc8929 we we've got what we call the background router which is approximately function so you can register on the lln on the 6lowpan network two addresses and the 6br will do nd proxy for you on the backbone and that applies to classical 154 that applies to that 11 that applies to many things but at the moment there was no real work on what happens if we want to to use the registration on the backbone side as well actually i tested it it works fine but um yeah we we probably need to to standardize it and the most important thing or interesting thing is if you want to to to move the registration to the backbone probably"
  },
  {
    "startTime": "00:30:00",
    "text": "you want to move the 6lbr to the backbone now if you have a 6lbr on the backbone that kind of tells you that you can use it not only as a dad database but also for lookup and so what this this so so you avoid the broadcast or the bump as they call it you know broadcast uh unknown and multicast flows on the backbone if you can first ask the six lbr oh by the way do you have a registration for this address in which case i won't do the classical lookup of that so that's basically what this document says it proposes a way to place the 6lbr on the backbone and remember the 6lbr is very very abstract i'll come back to that on the evpn discussion but the the extracts 6lbr is now reachable for the backbone or even far far away on the internet because it's a global ip address and we can effectively pour uh it's it's database information not only for oh is this address duplicate but also what's the address resolution so what we really do in this draft is we we extend the the dardak exchange so we can provide the slave options and so this is still a personal submission it's been very very stable so we are in this situation of adopt or drop so uh do we care about publishing this work which basically says now you can have six lupine devices on the backbone sleeping etc because now you can benefit from the proxy for sleep proxy et cetera or do we want to keep six le pen at the edge on the other side of the backbone and outside of the background personally uh noah you know my side i want basically to converse the registration on the backbone but any feedback basically i would like to go for adoption i mean it won't move far beyond"
  },
  {
    "startTime": "00:32:02",
    "text": "this if we don't adapt that so it's really adaptable like that yes so carsten is in the queue yeah so i was wondering given that we now do do six low pen signaling on the backbone side is that useful on the backbone for other nodes as well yeah i mean if everybody basically the more devices contribute to the registration on the backbone the last bump traffic broadcast uh unknown multicast you will get on the backbone because the draft will be more and more useful because the nodes will be able to to look up through the 6lvr and never again do a multicast so this is essentially a soft entry to efficient nd it is yeah it you can you can see it this way more efficient look at the graphics you know this work is the evolution of efficient nd i mean or it's all intel efficiently was always completely linked to this uh but we did not i don't think we really discussed of uh placing the 6 lbr on the backbone and doing any cast lookup no no we do but it was it was the obvious continuation of efficient individuality yeah so we certainly can do this work in the working group i just wanted to raise the question now it's not against adoption at all yeah and we actually started this document at six man and six man for anything you know related to six lap and nd i mean doesn't really care and so i presented it once or twice uh raised a few eyebrows and and that was it pretty much like efficient nd i mean you've seen the lack of interest to progress this work at six men six man is more maintenance as i see it and so look at the service six right they do the work in spring and sometime they"
  },
  {
    "startTime": "00:34:01",
    "text": "when they they have something then to just get six men to validate that it's okay or changes change a little bit but here same thing we've done this work and six men will basically just say it's okay or not but it's it's it won't advance in six months they are not doing that sort of thing i tried it's been there okay so yes i mean i would like to see a discussion and option on the mailing list so the introduction to the next discussion is uh remember the 6lbr you might see it as say a server but in fact it's really really abstract if you look at 8929 which is the background router the global six lbr is effectively uh the collection of all the and the information on all the six lbr the 6bbrs because all the backbone routers they they have a partial view of the the 6lbr for their own local llm but the real 6lbr is the aggregation of all those views and the way uh this real 6lbr distributed to 6bbr i'm sorry is red is by doing classical ending for the backbone or over the proxy function so it's not a centralized box at all it's really the collection of all the background routers together being read through nd that's what the macbook router does now can we move to the next slide where the evpn one let me show you another way of deploying s6 lbr and in this case uh 6lbr would be literally bgp the all pgp network that serves the vpn okay michael yes i see them so please uh bear with me because this"
  },
  {
    "startTime": "00:36:00",
    "text": "slide where was not done for this audience and just i'm just telling you that i presented it to them um the classical evpn world and the classical cloud world is really really ipv4 they they understand people understand ipv6 but not in the same depth as people doing iot for instance right and and so sometimes and really in enterprise networks they mostly don't let slack at all and they work with the hcp v6 just the same way they work with v4 so it's kind of easy to forget that there is more to ipv6 than dhcp for the best for the better and the worse right so so basically i i was with this slide i was making the point that as long as you you use the hcp you've got this round trip between the client and the server that you can observe on the way so you can snoop the hcp reliably you can expect it one address per host or per interface you know it's going to come actually in our access points find that machine the access point association is up when we have seen the dhcp packet and when we know which ipv4 address this host has and effectively that's completely different from the ipv6 world where you will have multiple ipv6 addresses that will come and go so as long as it it's the hcp i mean you might be tempted to believe that v4 and v6 are the same but not and and for evpn in particular but also for wireless the aso is the sm in slack it's the stateless piece because the way slack is done cannot be deterministically observed it's just based on some broadcast dad and potentially some look up later you don't know for sure when the host forms an address when it stops using it there is absolutely no signal that this host will stop using this address"
  },
  {
    "startTime": "00:38:01",
    "text": "and so you end up with addresses that you don't know exist and addresses that are no more used but you still maintain a state in the network for them slack was not at all defined for maintaining state in the network it was meant for maintaining caches in the network it's very very different because evpn needs a deterministic state that can be injected in bgp so using slack addresses and redistributing them snooping them and redistributing them in evpn needs to broadcast unknown and multicast traffic which is one thing they want to avoid so this next slide basically uh explains the kind of crimes we have with slack when we want to interwork with evpn it summarizes what they just said she wants to maintain this slide but i don't have so much time so so that was that was true with slack until until we made ipv6 and d state four and that's eight five four five uh seven sixty seven seventy five and five four five and nine i mean the whole series that i have shown on the first slide with this protocol we effectively synchronize the state about the address between the host and the network now we have a deterministic state that we can redistribute into routing and effectively 8545 carries address control semantics which help this redistribution in particular we negotiate the lifetime and that's generated from 67.75 and we we have special signaling to say please redistribute my address so the router can inject the address in a proxy that's at nine to nine uh in ripple that's nine zero ten zero ten at ninety ten uh and in this in this case for dvpn and here in the cake we have a quite simple uh address protection"
  },
  {
    "startTime": "00:40:01",
    "text": "which with eight nine two eight uh so we can do savvy and all those games we can bar traffic which is not sourced by the user who effectively registered that address on the first stop switch or first operator so basically it is the the draft that i presented to bess and i'm trying to get it adapted is explain how you will redistribute rfc8505 and 928 in evpn and if you look at it that effectively makes the bgp tables that are synchronized in every every node v6 lbr because if vpn basically advertises uh routes type 2 which really are combination of ip and mac and type 5 which will be the ip and and what we do is we we extend uh the support that was already there for um basically and the uh ip690 there was there was a beginning lpv6nd in there there is no c for that and so we extend that signaling and and we also we we effectively uh have two different uh fields that we update because we need a number of flags and and we need to expose the lifetime we need to expose the rover so how we do that is is explained in this document the bottom line is now we can provide a secured uh address and that's why you have secured the titles because eight nine two eight to nine and eight nine to eight information is effectively injected in bgp and so bgp can can block a host which would like to steal on the trust to impersonate over a vpn so so benefits are really pro address protection and deterministic state and that's illustrated here and i won't spend more time on this slide so i will just there is any question a question well uh eric is in the queue sorry"
  },
  {
    "startTime": "00:42:04",
    "text": "so um so when people do this with ipv4 presumably they can know when addresses are no longer being used the unregistered part right by setting a lease at an hour or 24 hours or whatever yeah i don't know yeah well if something moves and the lease is 24 hours they won't know they've disappeared for 24 hours but but but but do we have in the in the set of things we have with the registration i don't remember do we have enough sort of resolution there in terms of things disappearing being unregistered in terms of timers or we we have a lifetime in the registration and uh what's neat with uh 6 75 is is the host proposes a lifetime and the router confirms that or modifies that like reduces it so we we can effectively uh we register with a lifetime yes we do now the resolution is whatever we can signal i don't remember exactly it's two bytes uh i i don't know about the unit uh it's probably seconds yeah okay so yeah that's good because otherwise people will later discover that hey we need to unregister better but we have what we need so well you have both right you can normally the the draft should uh if you stop using address there is a shirt you know something like uh register it with a lifetime zero which means unregister now if you don't then the lifetime will time out the other thing is there is there is text which says that your registration should map your intention with this address like if you are if you have the intention to use it long term use a long lifetime if you have if you use it like just a very temporary address use a short lifetime now it's under the appreciation of the stack to decide what kind of lifetime it will ask so we have a lot more uh control actually"
  },
  {
    "startTime": "00:44:02",
    "text": "and we have the rover which will allow to ensure that it's the rightful owner because the duid in the http can be impersonated okay and last slide please and that's the one i wanted to insist the most how much time do i have left please cheers in theory uh according to the agenda that would be like 16 minutes although we also have additional time since we have like 20 minutes of flex time for the whole session okay that's neat okay so same first slide you know uh the the big family that this group has developed so so i i you know i've been working on on cloud usage of of what we did in this group don't be too surprised with the vpn uh but the next thing that happens in cloud environment and you will realize it happens in iot environments as well is at some point you want to give this device not just a an address but you want to give it a prefix and and the kind of usage is in the cloud it's you've got a virtual router in your host system in your in your server like something like calico and and basically you want the devops to be able to manage not only addresses but prefixes and so the devops would would configure prefixes on their systems and what you want is the system to advertise that to whatever routine you have in the cloud in a fashion that's completely agnostic to the routing in the cloud so you can do your rift you can do bgp you can do whatever and for addresses h505 is fine for that purpose because it's nd it's completely agnostic to the routing protocol in which you redistribute but we do that only for addresses we don't do that for prefixes now redistributing is not something new at all we we do it with a repo with the ripple of nowhere work"
  },
  {
    "startTime": "00:46:01",
    "text": "um in this case the 6lm uh registers no trust with the arbitrate and the the ripple first stop ripple aware router will effectively react to the air flag and injected ripple the same flag is used in eight nine two two eight two nine i'm sorry uh by the bible router to to decide whether or not to proxy and that flag is is also leveraged in the best work so what we are looking at is uh not something new redistribution but reducing prefixes are supposed to host and this is a quick quick view on how how that happens so this is the traditional ripple uh non-storing mode so each node will have an address in the same prefix and uh basically the nodes send a non-storing model like this red packet the root and and the root can construct the source rod path back which is the ac via a b which is connected now with the ripple and where leaf what you do is you've got this host uh which which for which we'll see an array from c from router c auto conf address a column column l for uh power node and basically it will be the node c that will advertise uh l as a non-storing now on the alpha so what happens between a column column l and a column column c is purely five four five l is completely agnostic and aware that it's repo and the address is injecting the writing and and the note can be served so so the question again is yeah we can do that for addresses but what about prefixes i mean does that make any sense and actually there are a number of use cases where it does make sense and the broad category is a stub network it's a network this is either inside the node"
  },
  {
    "startTime": "00:48:02",
    "text": "recursive networking but there is a node is a network for the next level of recursion or a private network a virtual network that would be bandaged for instance by communities or something you could also have a net function and a private real that's really uh what you would do in communities but you can also uh connect through reaper or any network a smaller network of private uh iot devices without really knowing what kind of routing takes place there what you want is is just be able to signal through the same simple registration we have with h505 hey this device which does something different from ripple um effectively owns this this private room or something so yes as long as it's a stub as long as it's reachable only via these devices or those two devices which work together it makes perfect sense to expose not only a host address but a prefix in ripple and that was there forever i mean exposing a prefix on repo which is exemplified here this is a typical structure that triple could build so each node abcd get a prefix abcd and if c connects to b then it will form a prefix an address of this prefix and then you can expose the the same sequence of uh source route information again and and it's gonna work fine because in repo what what b will expose is b column column flash 64. as opposed to host it will just expose a prefix and repo is built for that so so each node has a prefix each node forms addresses from its parents and you're all set that works for storing mode and storing mode everything now if we wanted to do the exact same thing for a ripple unaware writers now we don't have it we we don't"
  },
  {
    "startTime": "00:50:02",
    "text": "have a way to for not l to effectively say oh everything in the alcohol i'm constantly 64 is mine uh l would have to talk ripple and if it's cvpn l we would have to talk evpn the very cool thing about that 505 is completely diagnostic to what routing protocol l is doing or what environment it does like if it's inside the server versus what goes in the ripple network so what what we're after here is is really a simple way for a stub to say hey i'm a stab please give me the package but i don't know what your routing protocol is and uh i think was yesterday at six man um there was a question a use case that was quite interesting uh where there was a uh a unique local uh prefix which was that which was owned by a router which was somewhere on the home network if that guy had used this registration to talk to the home gateway problem guard packets would reach the home gateway com gateway would find the registration for the una prefix route end of the story but we we we don't have this simple nd extension now remember jen at some point talked uh to the group and say hey uh we are not listening to arrays this ula router would have advertised arrays but then the home gateway does not listen to arrays so we lose the information that's why we have the problem well in this case we use rs effectively to register so it's just like ns for for host that naturally would migrate it to rs i guess but that's the group to decide in this case effectively the home gateway would listen to the rs with the address registration option or something prefix registration option and it will effectively know in a fashion which is completely independent of what routing takes place outside the home network or even within the home network it will know that there is this router which holds that step and which is connected and effectively it still works"
  },
  {
    "startTime": "00:52:01",
    "text": "if the step itself is a different subnet on the same multi-step net link this is very traditional shared link existed since the early times of ipv4 where you have a same wire if you like where multiple subnets are deployed this just happens that the home gateway would pass the packet to the router which did the registration which would then inject on the link whether the link is the same as the home link or different link doesn't matter it works it would work anyway so yes yes yes we we we would register prefixes but hey uh when we register addresses we have this thing which is quite useful which is that right we want to ensure that uh a given prefix is a given address is not a duplicate so we would need to do that right uh yeah yeah we would effectively mostly if we want the devops to configure prefixes on their devices without asking too much just picking something in a larger aggregation here you have the risk of duplicate or is it free duplicate no it's not i mean it could be an exact duplicate for prefix but it could could also be something which deals with an aggregation like i'm i'm stealing a prefix from an aggregation that is already registered by somebody else so basically yes we would need to do that again but we would need to consider not just exact match but also aggregation like some prefixes could be exposed as being prefixes from which you can uh steal a sub prefix and some of those would basically not be proposed that way so if if you register for instance a prefix within the prefix and you have the right to do that then you get it if somebody wants to register the same you won't uh be able to do it because you own it uh unless you say any case something but then if somebody wants to dig into your own prefix if you did not allow for that you will be rejected as well right so so you have to consider aggregation as part"
  },
  {
    "startTime": "00:54:01",
    "text": "of the dot but otherwise yes the very cool thing is you can do auto allocation you can do prefix at a goal for this and then the traditional that method i started to understand aggregation would would do the trick for us so the proposed way i've not written the draft yet i just want to you know i don't want to waste too much time unless people are interested uh but for me the obvious way is to do with rs what we do we did with ns and do a stub registration option now insist on the factory stub right because with that we don't have it's not a routing protocol it's still indeed we are just advertising rich ability but we are not addressing cost etc we are not participating into the writing protocol very important distinction and so we just say hey i have this prefix and i want you to to to is yes that is that to inject it in your own routing and give me the packets back please and since it's a tab it won't be a loop it won't be anything so that's why i suggested this stub registration option name and then in this example i have a cloud fabric and i have this this server down below attached to two leaves l1 and l2 and it would basically send the rs to l1 and l2 saying i'm registering this prefix and then i want l1 and l2 the two leaves could effectively inject it in bgp uh evpn or rift or whatever else you want to run there and the same obviously would work for repo so there is uh and michael waiting in the queue oh i'm sorry i did i had scrolled down and i did not see the queue oh now i scrolled up and i see you both sorry sorry sorry um it's my fault uh it's just the scrolling thing i mean the queue does not show when you scroll down something for me to go guys if you could make sure that the queue shows outside of of the list of participants uh is always at the top that would be"
  },
  {
    "startTime": "00:56:00",
    "text": "very useful i just just made that mistake okay no problem you're first uh hey pascal could you reiterate or summarize on the use case how this fits into the sixth law charter uh i'm not very sure if uh kubernetes carrico all this is understood constrained environment we are so abstract um uh it fits it fits as long as you have uh uh for instance if you have an iot network instead of this server down there it's just a a plain existing iot network which is uh v4 for instance i mean a lot of them are not ip at all but you want to map each device to an ip address just map like a net function that would map a mac to an ip then you can expose effectively every device on that slash p to the ripple network so if you see that's why i picked on my example before on repo um effectively ripple has the model already for uh for lens where each of the routers owns a prefix it's there i mean it's always been there um so this can happen if the router c is effectively the gateway to to an ipv6 network uh which which has the prefix b but it it could also be something else and and that we could not necessarily um how can i say this yeah it could be anything it's there what what does not exist is the capability to connect a gateway which does not speak uh ripple so yeah i'm sorry for that so the use the thing that exists today is this the thing that does not exist today is this where you take this iot gateway which has a number of devices below it and which wants to map the devices in in that group of devices"
  },
  {
    "startTime": "00:58:01",
    "text": "to an ip7 that can be injected in repo and you don't want to have to sort of another routing protocol yeah it's completely abstract now we we basically say what's good with 6lowpan what's good with nd it's completely abstract writing protocols you can you can advertise the prefix to say hey reachable but you cannot give a cost or something like that you're not a routing protocol but at least if you have a stub you you should be able to announce it and like michael said regardless of what frauding takes place over so i take the example of a cloud or i take the example of repo it really doesn't matter we're completely agnostic actually that's the value of doing it in nd but in this case yes if you yeah so this is this is uh this enables 6lrs and lbrs to advertise prefixes that will be in turn delegated or mapped to the uh constraint nodes um yeah there is a gateway which self-transferring nodes and we want to be completely agnostic of what it does maybe it does not even do ip but we want to be able to to talk to every device in there so we want to give them each an ip address and the simple way for that is that the gateway has an ip address all of them whether it's really the uh a prefix um that is distributed to the devices or it's just mapping that that is done at the gateway but at least we want to go through the gateway to talk to every modbus device and for that we want the gateway to own the prefix now either the gateway speaks repo or we extended 545 to say hey the gateway is open nd but gents we can ex you can expose the stub as opposed to just address so what i really want to do is what we did here and made sense for a single device i want to make sure we can also do it here when the device is actually a"
  },
  {
    "startTime": "01:00:01",
    "text": "gateway to more devices thank you yes michael um so i wanted to say that um anima's acp is already injecting um prefixes into ripple into the acp ripple but that this actually would be very interesting because it would mean that in for instance the the knock which might not uh which might run the acp as a native network rather than a overlay that that would actually permit us to have some structure in the knock i think that would be very valuable um and uh um you know uh i think that would be a so i think this is a kind of a useful very useful thing to anima this this extended uh um prefix allocation um and i just wanted to say actually in response to uh schwester's question to you about charter it might very well be that this work does not belong with six low but this is essentially i think that we need to be aware of this because this is essentially an evolution of 8505 which is our document uh in other other working groups right so i think that's a relevance to to this working group is that our uh we wish to have our uh our children uh go forth and be fruitful right yeah i agree with that but then we don't have a working group to push that well well i don't know if if it's not six low i don't know where it is but the point is that it is based on our document so um interesting i completely agree with you michael but i hope i hope more and just interest i really hope that we develop that here because that's where we have the skills right so yes my argument is is effectively uh this l node could be an iot gateway we have many"
  },
  {
    "startTime": "01:02:00",
    "text": "many cases of gateway in industrial and uh where you have all sorts of industrial protocols uh i think they're on the dressing scheme and uh basically what we'd like is to be able to have the gateway map every uh address in its network to ipv6 and then inject that in the routing regardless of what protocol runs in the router so in that case it's pure ll and it's it's pure iot now it's obviously it's not what i'm telling is just not limited to iot i mean it would it would have solved the problem that we saw yesterday ethics man just by a snap of the fingers and it's what came to it will naturally say oh too bad the array is not right by the home gateway well no they already know but yes okay there's also a question on the chat by carsten i think it was little with the last slide that you were presenting before the question yeah i'm i'm like the student who at the end of a talk that explains how to build computers out of transistors asks what is the transistor the prefix b is related in what way to the prefix a uh okay so it's not that picture i'm sorry let me bring back the picture so in this case there is absolutely no relation between a and b it could be two different cars uh served by two different service providers it's just and then you build the money of cars and that still works so no there is no ex no relation there can be other can be not right you don't really care it's just that when the car say hey the car and you have an iot network inside that car all the the the the"
  },
  {
    "startTime": "01:04:00",
    "text": "units that you can find in the car um that is served through wi-fi then the car as basically is exposing alcohol and column a column column 64 right and if if you want to build a network of cars then basically you expose that in arrays in a clear and then car b can join that and effectively if you do that you want some privacy both in a as a prefix you want to kind of take it from a temporary una just for visitors and uh b should use a suffix b in this case uh for a column column b which also would be uh anonymous but the bottom line is you can effectively uh have b connect to a by forming the transmitter based on a uh arrays and recursively you do that and you do report between them and guess what you form a network that reaches the outside of a parking lot or connects mna together actually this is this is how we experimented with ripple like 20 years ago before anything the wrong group was proposed or anything we are doing that with cars we are building exactly what you see here and this drawing is kind of old it was tested by nasa by the way at glen center they were streaming video cross cars to us as they were driving ooh solo too okay so nothing much more just uh this is slightly made for the evpn people but basically you see you would see how it could happen uh in in the vpn case but yeah then again it's completely agnostic to the writing protocol that you would run um if we get a little bit gorier on what we'd like"
  },
  {
    "startTime": "01:06:01",
    "text": "so the main change is to to advertise tabs stop prefixes are supposed to host um you can effectively advertise slash 96 if you want to to expose a private ipv4 a domain like you would do for for communities um you can you can you we could if we work on this draft uh add more information about policies and echoes so if you want to have access countries etc they have the right to do this i claim the right to do that for this prefix then then that could be signaled the other thing that could be signal these metrics to influence not routing then again we don't do routing but to influence load balancing like if you have a ripple network or an evpn network a factory class fabric there is a lot of load balancing taking place um it's not right it's just load balancing and the question is if i have multiple of those gateways serving the same network it might be that you want the weight to be unevenly distributed between those guys and so you could effectively uh advertise information about that uh and then all sorts of things which could be placed for v4 like like donut id vrf etc i i need to say because um this is an itf meeting blah there is some ipr on all these games right so we have found some ipr on explaining all those different things could happen and so basically that's what i'm looking for is is a discussion on this list and i have i had the point by shweta is that's this fit charter i think it does it's certainly not limited to iot uh but before i start going into a draft as you know it's the draft zero is always a lot of work if you want to do it right uh i wanted to expose the dangers to the group and and kind of get a go no go"
  },
  {
    "startTime": "01:08:02",
    "text": "feedback here regime yes i'm here you hear me so actually if you can go back one slide just once like so i i think that the work is interesting i just wanted to make a comment on the third metal main bullet adding metrics to influence load balancing yesterday it was the there was this kind of compute and networking i think it was the acronym anyway they work on a similar problem in a certain way because they use so compute metrics and network related metrics which is like water worker capacities access yes exactly that could be exactly very very good that's exactly what the sort of thing we have in mind yeah if if basically if for instance if if you have kubernetes again right and you can decide how many pods you have on different servers you could basically load balance on the number of pods yeah yeah i think there is some overlap this may be a different solution i don't know maybe you're getting oh i didn't know and there is some connection there otherwise the work is interesting that's it thank you luigi justin yeah i need to continue asking my question because somehow i got disconnected here the i still don't understand the relationship between a and b so is b a sub prefix of a no no no i'm sorry oh you were disconnected yeah so you did not show my response they're completely unrelated they can be related but there is no requirement at all that there is any relation between the job of the abr then the abr suddenly gets additional networks it's responsible for okay"
  },
  {
    "startTime": "01:10:00",
    "text": "so you're talking about the sixth lbr right sabr the 6mbr the registry the registry is is only useful if you do um the the function that is equivalent to that right if you want to auto configure the addresses so basically say those are cars and they have service providers and service providers did give them a slash 64 which is a b or c now those cars end up in the same parking lot and they want to to form a melee of sort with ripple uh basically they would advertise uh an address and they can advertise this qa unique prefix they have or they cannot take off a ula prefix uh if you really want to ensure that the ua prefix that is autocad for anonymity purpose just for forming this network is really unique inside the parking lot then you would have a 6lbr if you're using global addresses you would not need the 6 apr because the very interest is every prefix abc is unique it's being just given by the each service provider and that yes there is no no relationship at all between a b and c okay then i really don't understand why a and b are on the same diagram because they seem to have no relationship at all oh they're just they're just two cars parked next to one another or two devices your picture has things on it that have prefix a and things that have prefix b yeah not b as prefix b owns prefix b as a router and node c auto calls an address from b uh we're using c as an id and it's just so the prefix b is owned by router b yeah so is the router which which has that prefix c is a host attached to b forming address b column column c"
  },
  {
    "startTime": "01:12:00",
    "text": "so what do the hosts that are in a [Music] have to do with b what are the hosts i'm sorry i missed some words the hosts that are in a what do they have to do with bb as a prefix uh the only one that has anything to do is not be itself because he's uh as a host on one antenna if you like is he's a host to a and then as a router is the writer for prefix b so the interconnection between a and b is the fact that there is a router b which acted as a host on one leg to form an address from a and on the other leg as acts as a router for exposing b it creates that link that connection if you like during the time where it's it's reachable from from a and when b goes away from a uh address a column column b will will go away it will have to deprecate the the nodes in a cannot address any nodes in b without triple they can't but once you run ripple and say a becomes the root just because from the diagram it looks like obvious then if if uh a node in a pings an address like b column column c through ripple it will know it's there that's that's when you need the routing right i mean the routing ripple does exactly what i've shown on the slides basically ripple builds this right a is the root blah blah here is routing tables in every node so for instance in node b which is in the middle prefix b appears as connected right and it's actually owned and a prefix a is connected but as a host and then b has a default route via a which is the root and and c and d they basically auto confident trust from from b so they they see b"
  },
  {
    "startTime": "01:14:00",
    "text": "uh us connected they see their own prefix that's connected default via b right that's ripple fire so it's just repo used in some many form if you like okay and that works used to using ripple in sub-networks so this this is not known as transit network so it's not transit if if you don't connect to anything right if for instance a might be connected to nothing it's just the the the election the natural election which will have made him uh being the root yeah it just starts with um well it's not how it's used today right it's just that it works if you go ahead you connect a to the internet it makes a lot of more sense yeah so you connect into the internet becomes the transit network to b so so if you say what you call the abr can be a works fine yeah um okay i i'm looking forward to your draft because to me this makes absolutely nothing this would not be in the draft i mean this this this has been my ripple course for 15 years but it's not it's not in in in the draft because the draft would more well would would probably discuss that flight well which would probably curving the other one yeah if you like i mean to explain this background that we i don't want to overload the document either with ripple consideration when it's really talking about md so yeah i mean i would be happy to discuss about those slides anywhere in any form you want including this mailing list but saying that i will write that in the draft i don't expect to but this is pure deployment it's not so interesting how ripple does this it's more interesting what uh capabilities and responsibilities you"
  },
  {
    "startTime": "01:16:02",
    "text": "just assigned to the various nodes in the network here oh yeah cool cool cool so now we are back to to this case it's basically saying there is there is a rotted network uh where where c is a 6lr if you like and then there is this gateway which needs a prefix and doesn't speak repo so it's a ripple underwear router and we call that an external destination in our c89 i'm sorry 8008 9008 so so use of ripple info we did this is this is a next one destination so how do you get knowledge or fix all destinations that are not host and right now there was nothing um so now we have a protocol okay so sorry to interrupt uh there's uh also one paying uh in the queue so perhaps we may have like time for an extra question by one thing and hopefully you can continue the discussion for for example on the mailing list and now yeah just time for a quick question from one ping okay thank you hi pascal um does this mean um does this and does this mean the root is gathered by the by the root node and then for the communication every packet will uh carry the root message in the encapsulation oh um if you're using in this case it's using non-storing mode and so rca9008 applies and yes it does mean that c will encapsulate the packet to the root oh i think if i remember well you know we had a lot of trouble writing nine zero zero eight but this is this is whether it's it's really a ripple and"
  },
  {
    "startTime": "01:18:01",
    "text": "destination doesn't make a difference and my memory is effectively c will encapsulate to the root and then uh the root will either encapsulate if it's another rural destination or if it's not a real destination then he might no well sorry if it's non-storing mode it will encapsulate so yes okay i understand okay thank you but yes uh always you know go back to nine zero zero eight it was so hard we always miss things when we do it by memory but same as a rule i mean whether it's a mixtal host or external uh prefix doesn't make any difference okay so thanks for the presentation and discussion so it appears that well it may be good to confirm further on the mailing list that there is interest in this work also it was good to clarify relationship with the charter so it appears this whole work area is can apply in iot networks but also it's not limited to that so yeah it was also useful to clarify those aspects as well okay so then thank you and i guess we can proceed to the next presentation actually well i think it's me this time yeah i'm i'm saying get a broken format do you want to just play your own slides then so yeah share preloaded slides i'm still seeing like a broken format you'll have to share your pdf because if you see your screen my screen okay"
  },
  {
    "startTime": "01:20:04",
    "text": "so and now we know that whatever pdf process you you used is results in broken slides so we have a test case okay so i'm starting to share okay can you see the screen sorry the the slide correctly yeah it looks great okay thank you okay so carlos gomez again i'm going to present the last update of the drafting title transmission of chic compressed packets over ieee 2.15.4 networks my co-author is an aminable from aglio and let's first take a look at the motivation for this draft so as the working group knows well rfc6282 has been the basis for header compression in 6v pan and also in six low it was designed for 15.4 as the target technology to support ipv6 on and it has been adapted or reused for several relatively similar iot technologies uh several times such as the ones that we are handling in six load and with this rfc it is possible to compress an ipv6 gdp header typically 48 bytes down to a size of seven bytes in the best case with global addresses but then we also have the recent publication of rfc 8724 also known as chic which is a product of the lp1 working group she defines adaptation layer functionality comprising header"
  },
  {
    "startTime": "01:22:00",
    "text": "compression and fragmentation and it has been designed for technologies which are even more constrained in terms of communication capabilities than those which we deal with in six volt pan or six load such as for example lp1 technologies so here we are interested in using chic header compression in six open environments since it is possible with chic to compress an ipv6 udp header known to a size of for example just one byte again in the best case with global addresses and the technique is that static context is used here which exploits a priori knowledge of the header field values of the packets to be sent or received then if we include also the application layer we may want to compress the whole set of ipv6 udp and co-op headers and well there is no 6lowpan header compression defined focus so then we can consider two cases for a co-op header as an example uh if we assume a header without options then with six load pan the resulting size of ipv6 udp coop header would be 11 bytes in total if we consider the options in a co-op header such as those in table 6 of fc8824 the resulting size would be 23 bytes however by using chic which by the way has also some specification to compress squad headers with ship then it is possible to compress the whole set of ipv6 udp and cob header down to a size of for example just two bytes then with this decrease in the amount of bytes to be transmitted or received it is possible to achieve significant improvements for example in terms of the theoretical battery lifetime"
  },
  {
    "startTime": "01:24:02",
    "text": "transmitting packets for example periodically over 15.4 as you will see later it is possible to achieve a theoretical improvement by a factor which might be even greater than two even if we include a third byte as a sheet dispatch and however the disclaimer here is that actual improvement in practice will be lower depending on various parameters and features such as the device hardware and in particular the sleep current consumption also mac layer settings application layer settings including the payload size network topology and so on so just to give a few more details on this here this figure shows on the vertical axis which is the maximum theoretical battery lifetime improvement factor that can be achieved for the cases considered as a function of the payload size which is the horizontal axis here we assume short mac addresses intrapan communication and again a battery operated device which transmits packets periodically so here you can see there are red curves and blue curves the red ones correspond to a star topology scenario and the blue ones correspond to a multi-hop scenario with mesh under i will refer to route over later in the presentation and as you can see while the improvement decreases with quad payload size of course it is still possible to achieve quite significant improvement at least theoretically with shorter payload sizes so on the status of the draft you may recall that there was initially a related document which was a proposal to define a 6lowpan dispatch type to signal when chic header compression is used which was presented in itf 110 and that led to creating this draft"
  },
  {
    "startTime": "01:26:01",
    "text": "which has a greater scope which is intended to enable like all the details to allow transmission of chic compressed packets over ieee eagle 2.15.4 networks the previous versions zero zero and zero one were presented in the last two itf meetings and here i'm presenting revision02 which aims to incorporate the feedback from the last itf and also from the couple of lp1 interims where related topics have been discussed so let's go through the updates in this last revision the first one relates with the frame format here you can see the format on the slide which starts on the left with the sheet dispatch which signals that what comes next is a packet with a header which has been compressed by using chick and the chic header the compressive header compresses two components a rule id and if any a compression residue so in the previous version we stated a fixed size for the rule id of 8 bits however after comments in the last itf we have modified this and now we say that the recommended size for the rule id is between 1 and 16 bits the idea is to allow the most suitable rule id size to be decided and used for each specific environment and also we would like to avoid like a hard limit on which could be the network size and number of endpoint pairs that can benefit from chic header compression by the way just in case uh i'm seeing my screen like full size so i cannot see if there's anyone in the queue so if there's anyone just let me know um so then the next updates are in section 5.1 which focuses on ipv6 udp header"
  },
  {
    "startTime": "01:28:00",
    "text": "compression so by default what is known here is use section 10 of the base chic specification which is rfc 8724 to compress ipv6 or udp header fields however there's a bit of a problem with ipv6 addresses and udp ports because chic is based on the lp1 architecture and in that case there's special terms and elements such as the ones shown in the figure where at the left you have constrained devices which would adopt the role of deb and on the right we have network site infrastructure which would adopt the the role of app so in the base shake specification the devon up terms are used uh actually the rules for compression and decompression are written for the ipv6 addresses and udp ports in terms of who is dead and who is up and actually there is no uh mention of source or destination so the point is the rule is expressed in terms of develop so in lp1 this is not a problem because a chic entity knows in advance whether it is dead or up and then as we clarify in 0 2 in some 15.4 scenarios this is not a problem either and in fact this is actually an optimization in chic in the lp1 context because this allows a compression decompression rule to be used in both directions so this same optimization can also be used in some 15.4 scenarios as is for example in star topology networks where the constrained devices talk to some network site infrastructure however the problem may arise in other scenarios like two peers two constrained devices that talk"
  },
  {
    "startTime": "01:30:02",
    "text": "to each other within a mesh topology because according to the definition of a depth if both endpoints are constrained devices both could have the role of depth so here we need to address this problem so one possible solution which is the one that is currently in the last update of the draft which has been discussed in lt1 interims is that we might want to tell a node whether it is dead or up in advance so additional functionality is needed for that and here each endpoint might need to know whether it is developed when talking to any other possible potential endpoint so it means that we might need to give additional context to the nodes and then there's a related point which is that the basic specification also defines the terms appling and downlink which are in terms of devena because uplink means from depth to up downlink is the other direction and if we follow this approach it means that uplink and downlink would have a local meaning just specific to each pair of endpoints so in zero two uh currently we have this approach we remove some sort of tentative solution that we attempted in the previous version in zero one which was uh using the terms source and destination in the rules however this would have the issue of duplicating the number of rules because we would need one rule for each direction and well we also attempted to use transmit and receive as possible replayments replacements for applying and downlink however well that is now gone so we are trying to stick to what is already provided in the basic specification in terms of deven up so i don't know if there's any comment"
  },
  {
    "startTime": "01:32:00",
    "text": "on this yeah i just wrote in the chat that since you have to install these rules anyway you have to establish the city context that is being used here can't you establish the roles at the same time so when when you install a research you install them for node area as app and node b as dev yeah so actually that's my current idea and i understand that these corresponds to what has been suggested so far well that there have been like different suggestions in the lp1 interims but this is one approach which reuses the functionality of devon up mostly as it is and yeah so since the rules need to be written beforehand then i understand that the uh context to know whether node will be never up even for different endpoints i think it can also be established beforehand as well so i think that rules and deciding the the roles would like would need to be done at the same time so what what what is the way you envision the [Music] rules to look like so a particular node how many rule sets will that node have and is there any sharing between these rule sets yeah that's a good point and actually it's uh considered in as light i have next as next steps yeah exactly thank you yeah so actually we are trying to be a bit generic uh so far in the specification trying to capture perhaps from small networks to larger networks uh so"
  },
  {
    "startTime": "01:34:01",
    "text": "yeah at the moment we are trying not to limit anything in this regard and yeah one related point is uh the one you just mentioned about whether rules could be shared or something like that and and even reused across different pairs of endpoints yeah okay thank you for the comments so then also another addition in zero two is uh regarding some text in the basic specification which states that the iid cda which means compression decompression action cannot be used on lp1 technologies that only carry the depth identifier in the data frame however in 15.4 now we explained in zero 2 that data frames carry both a source and a destination field therefore the app id can actually be used of course if the id can be reconstructed based on information available at the l2 header so then we've also added a few details on the security considerations so because this specification doesn't define new header compression functionality beyond the one in the basic specification the security considerations of section 2.1 in the basic specification which focus on header compression apply here and we've added also that the security considerations of section 9 of fc 8824 which is chic for co-op header compression also apply because we also want to be able to use co-op a compression here and um also we've added a requirement in 8824 which is that cryptographic integrity protection is required to protect chic headers so here we also copy the same requirement and in fact we"
  },
  {
    "startTime": "01:36:01",
    "text": "explain that in 15.4 networks there's also support for linkedin encryption and authentication so it's possible to support this requirement so as possible next steps well it would be good to try to stabilize on the discussion about devnap and writing the rules accordingly perhaps beforehand as kirsten mentioned then subsequent questions could be okay do all nodes need to store all the rules that need to be used in the network or perhaps is it possible to reuse rule ids across these joint pairs of end points but this is something to be considered and also there might need to be something to clarify about the scope of chic header compression for ipv6 udp in this peer-to-peer 15.4 topologies because it appears that there's not much of a challenge when there is one hope between source and destination and also when there are several hubs between a source and a destination it's quite not very challenging to perform this compression in mesh under however it might become more challenging in the route of a scenario and in fact there is some experience in the working group with a related similar topic so perhaps we might want to approach first the one hop case and the mesh under case and perhaps leave route over at least for ipv6 udp for maybe a later specification so well this is perhaps another point to to discuss and well other than that since most of the content and the main goals and the structure of the document has been stable at the moment or is getting stable then the authors would like to ask the"
  },
  {
    "startTime": "01:38:00",
    "text": "working group whether it could be a moment a good moment for adoption so any comments or questions yeah so i think this this is a really interesting word custom again by the way sorry um i think you as an author you probably want to make one or two more rounds uh completing the architecture before you push this into the working group um because as an author you have more flexibility in doing this so i would probably look at this at ihf 114 but that's just my personal opinion if i were author of this i would not ask for adoption today but try to make sure this is complete so the working group does the small points okay thank you any other comments okay so well i'm not seeing anything else than my slides so i guess if there are no other comments then we can proceed to the next presentations on the native short address draft thank you here we go native address short address [Music] yeah i'll give you uh i'll give you the control let's see if it works i haven't seen it work yet"
  },
  {
    "startTime": "01:40:00",
    "text": "for me yesterday okay so you're participants in the queue but i have to find you i can't click on your name in the queue i have to find you in the rest of the thing luigi there we go past slide control does it work i think so because it changed yeah okay okay so i'll give you an update on the uh lysix slow native short address draft okay uh no there is not the the the right set that's on the right side this is for the next uh okay let's let's do that properly then uh let me see i think you have to exit ah i can't take it away from you yeah quit yeah there you go head request again yeah you didn't need to put your name in it so this is native sort update share and there we go that's great that's the the right deck so uh that's another an update since uh one one two we submitted two revisions one in december one uh uh before the cut-off date in in march so not that long ago so the main changes between zero zero zero one this is the one submitted in in december we did quite a lot of text revision uh we clarified the the scope uh y is in scopo we believe is the scope of the six law working group uh because we don't actually do really routing but it's more on a stateless forwarding solution but the main point is really addressing and how we build"
  },
  {
    "startTime": "01:42:01",
    "text": "addresses okay we clarified the applicability of the solution for this thanks again to pascal that did help a lot in in in to in the text in order to to really be clear and it's obvious that uh the applicability is more in a static deployment because as soon as you have a topology changes you should renumber or do routing okay we don't want to do routing the numbering is is complicated okay and we add the text in order to clarify the allocation function which is basically the function that builds the addresses and some small discussion about simplicity versus optimality and we have a new code or wrong that jumped on board main changes between 0102 which is the last that been submitted uh again revised the text added some stuff we did some further work about the clarification on the applicability scope and we tried to move it um earlier in the document okay so that it's clear right away where these uh solution can apply what is the use case basically we try to clarify the architectural overview the the roles of the of the nodes because we have a root then we have for other sleeves we try to to better define the different roles and what each node is expected to do okay and he for the address assignment procedure we added uh two neighbor discovery options which i will detail in the following slides so the idea is or to leverage on"
  },
  {
    "startTime": "01:44:01",
    "text": "nd are already available in the sixth slope and okay the basically we are two simple options okay to request an address and as i reply to assign an address from the parent node so we call it nsa request address option and nsa assign address option okay this means we updated the yana section with the uh right format to request this to allocate the options so the request is pretty simple it's a type and the type has to be allocated by ayana anyway but in the request what we put basically is the uh expected address lifetime it's like i want an address and i want it for this expected period of time okay and in in the reply what we have is basically here is the address here is the lifetime that i give to you and here is the prefix length okay and then there is the actual address full format and then the node is able actually to uh store retrieve the prefix because all the information plus the nsa address okay because it's because of the peculiar format it's very easy to extract it uh from the from the full address okay details on the in the draft anyway so on the next step um you will see the evaluation in the next presentation okay uh rock the league one thank you we will give a short demo we try to uh evaluate a little bit how much and where is the game with this uh approach we we need to incorporate uh further feedback that we received actually actually after the latest uh submission so we have diane carter and carpenter adnan interesting feedback i have to say"
  },
  {
    "startTime": "01:46:02",
    "text": "so all in all we believe the the core of this document is stable but we need a revision of of that document for the the feedback okay we expect to do it right away after one or three because already we have the feedback and at that point we may consider adoption or a working group adoption because again we the core elements are stable there is not that much to be up that we think and i and that's all if there are any comments or question further feedback everything is welcome okay nothing in the queue okay so yeah maybe just a clarifying question in the draft you state that the applicability would be for rather static environments with wired wire technologies so is that for example plc or do you envision other technologies as well vm vision are other technologies but we are still looking at them i mean we do some bibliographic work and we may add a few more references in o3 but we want to make sure that we we we don't say nothing wrong just to add some references so maybe it's the most honest question uh answer i can give okay thank you yeah it will be good to to clarify a bit more what kind of scenarios would be in place here yeah sure thank you another question uh hello uh to answer this question from class um accepted uh you accepted the bill plc"
  },
  {
    "startTime": "01:48:02",
    "text": "and how there is another fiscal year technology named apl advanced physical layer which is based on the standard standard standardization of ioe 802.3 ct is also suitable for this nsc technology in the network layer i think thanks okay thank you is just curious is that for uh constrained devices is it like maybe more general which are the typical use cases uh yeah uh partly yes there and there are many scenarios for the for the intrinsic safety requirements which will constraint the resources of the gland in the industrial equipment okay thank you thank you more questions yeah thank you uh as a quarter and also from the perspective of the operators so we're working how to use app address in most scenarios so i think it's a really good way to apply the short appeal address without an unnecessary routing function in iot so maybe i hope the wg could consider this work yeah thanks that's all okay so i'll hand back the control okay so"
  },
  {
    "startTime": "01:50:00",
    "text": "next is a presentation still on the same draft however it's a demo okay thanks hello everyone and this and this is for the demonstration of the nsa allocation function um and which which is just which is described in the draft of native shorter address version 2. next page please i gave you the slide control it should be at the bottom okay thank you uh i i can't control scroll down i don't have it i keep trying to pass you slide control i don't have it i don't have side control and you don't let's try again okay thank you okay so i'll just get it next there we go okay and the specifications are described in the draft today's three points our first oo and allocation function of the essay can be different caseback is but all nodes under the sim root must use the sim one see section four in the draft and for the example algorithm for the location function is given in the draft is very simple and today i'll show the demo uh implemented based on this algorithm and so the target address will be allocated by"
  },
  {
    "startTime": "01:52:00",
    "text": "parent parent address uh plus uh plus some some binary one binary ones and uh plus the rule uh bit uh which which indicate uh indicated the node is leaf or for order and the third point is uh about to calculate the maximums of the address and the maximum of the address for a node equals the length of the parent address plus the length of the ones and plus one bit next please thank you and the code is very simple uh we can see in the slide uh only one page for the core code for the core code of implemented uh allocation function and uh most of the parameters uh used by the allocation function uh is a uh is a lo the local uh is a local variables and only the parent only the parent address is uh is a global uh context uh okay next i'll show uh i'll show the um the output of the program next next please again uh no okay okay so there are there are two keys two keys designed uh for the demo uh case one is to generate a topology and uh send addresses for the topology and the parameters is will be set is layers uh or in the topology uh of the tree and uh"
  },
  {
    "startTime": "01:54:00",
    "text": "the second parameter is uh maximum children of of of each code sorry so here we give an example of a four layer uh tree topology and uh for every node uh how have four children because because we choose the random random mode so um not not every node has has a full amount of the children so for the output of the program we can see um there are there are totally uh 23 nodes and the maximum address length is six uh owned by the blue nodes and the average average length of the addresses is only four four bits so as uh so and this will will prove um the the efficiency of the allocation function is very high uh okay next please we'll go to case two focus two uh the program will read a arbitrary graph from a file and uh try to allocate nsa addresses for um for the file and there are uh totally uh 21 21 nodes in in the input file and after the allocation we can see uh the correct uh the correct uh nsa addresses uh had been successfully uh allocated okay next i'll request the request to share my html screen and to show the left then"
  },
  {
    "startTime": "01:56:10",
    "text": "yes okay and the shared screen is okay for you yes we see it okay thank you and we can run on the program and see see the parameters in four and four we can we can feel um we'll we can feel larger numbers but because display display problems so we use four and and four as example and we can use a random and generate generated the topology and evaluate the length of the devices and there are 16 nodes and every address length is only three bits and the maximum length is six and we can draw this so we can see and the max the maximum length uh is six and the in for the balloons after we have after we have this and this tree and the um the nodes can calculate the next hope that there's a destination address and not rely on the separate and separate routing table and for case 2 we can load sorry let me let me delete the output file first and select"
  },
  {
    "startTime": "01:58:03",
    "text": "code code space sorry oh okay cody space and i see product and the example topology okay we can see the addresses are allocated successfully and the output file is generated and okay this is the input file we can see no no addresses is labeled for the nodes but after allocation we can see the address the ac address is labeled for every for every node here okay and that's the whole demonstration here any questions or comments thank you ahead pascal you had a question pascal okay let's stay for information um then i can see where it can be useful in specifically hardware environments like or if you look at the harness where every uid every every device has a very fixed position in a kind of an electrical wiring then i can see that this amplifies the rod inside the harness and avoids having a point to point uh i'm sorry a star typology on the harness which consumes more copper so i really can see how this can be useful on the other hand we have this this concern that the way it's done today implies that you're building a tree and i would like"
  },
  {
    "startTime": "02:00:01",
    "text": "the next generation of this document and they see that fuji is being occupied and that's sad because i'm talking to him but i i would like the next generation of the draft to cover a more meshed apology possibly two non-congruent trees or something so so two addresses per device so that if you have a wiring which allows to to pass to reach the same device it would effectively get addresses and you could send the packet to the two addresses to make sure that one of the packets reaches the destination so basically what i'm what i'm saying is iot environments we like redundancy and you talked about safety networks etc safety network condition one it's redundant and so please consider how you would build not one but two trees and and different addresses and redundancy and that would make it really suitable you see you see the point a tree is not enough one single tree is not enough thank you but in case two we read a topology which is not a tree it's a graph and we can but the routing has to follow because you know the writing the path of the packet along the graph is exactly my point the path of the packets along the graph is limited because of the addressing right because you have to follow the addresses it's my understanding you don't have a routing protocol so if you basically want to use two different non-concurrent paths to the same device you need to give it two addresses on two different topologies make sense no sense we can follow the mailing list sorry i i didn't follow your question um okay you have you have a mesh right you showed the mesh effectively and you can show it back if you like now the path of a packet my understanding is that it is"
  },
  {
    "startTime": "02:02:00",
    "text": "constrained by the address as following the bits basically so the path the effective path in this mesh is a tray and i see that as a limitation because we we want redundancy so what i encourage you to look at is something like giving two addresses to the device to build two trees which would not be congruent so that each address can be reached even if there is a failure otherwise you know you break someone in the tree the whole sub tree is disconnected um why does this connection occur because our dedicated scenario is uh is more is a stable topology if maybe if one of the notes breaks in in the tree that you showed the addressing is a tree right even if you build on a mesh the addressing is a tree if you break a node somewhere in the tree you need to go you can only go through that node to reach the children right because you follow the addresses so if you break this node you lose the subtract yes correct yeah yeah one no one under the break yes we lost yes you lose the subtraction yeah iot and mostly the use case that you gave of safety you require redundancy it's a must you you have to have two paths you have to have non-congruent that's why ripple builds geodex correct so so the next instrument is draft the next version of this draft if you could show how you build two trees and and find the two paths non-concrete so probably you have two addresses uh then then that would give you a real that's my suggestion for you okay so thank you for the"
  },
  {
    "startTime": "02:04:00",
    "text": "discussions uh yeah sorry yeah we are three minutes four minutes already past the time so thanks a lot for all the discussions and let's continue discussing on the mailing list and the well the session ends here and let's hope we'll see each other in person or virtually in the next idf okay thank you chair thank you are we done yeah it seems we're done so thanks a lot michael welcome good thank you mike thank you michael have a nice lunch everyone see you in philadelphia see you i hope thank you bye thanks bye thank you you"
  }
]
