[
  {
    "startTime": "00:00:07",
    "text": "we are at the top of the hour and uh thank you everybody who joined uh this is the first uh virtual MLS interim meeting that we're having after uh ff19 and uh um the agenda today is uh pretty brief we're going to talk about uh the feedback on an m&a uh MLS Network action implementation that we've been working on in the working group and uh for this uh I think uh Fabian and Michael have prepared some material and they will be sharing um um myself TK as well as Tony and uh and Nick will be sharing this uh interim uh we are going to take some minutes uh on the U hedg doog I'll leave a link where we can contribute if you have uh um the bandwidth uh and let me uh before I pass it on to Fabian let me uh ask if Tony and Nick want to add anything else I might have dropped so nothing from my side I'm still fighting a bit with a tool sorry go ahead no comments thank you um I'll just pass the link for the minute scker uh where we where we logging the minutes um in the chat and and Fabian uh is the material"
  },
  {
    "startTime": "00:02:00",
    "text": "uploaded I don't think I saw the material being uploaded uh not yet can I upload that myself or should I send it to someone uh you can share your uh uh you can send a request to share I think your screen itself oh yeah I can do that okay I thought do you need the slides as a PDF file beforehand or should I just share my screen I think you can share your screen but it's also a good idea to upload uh using the um you know the uh the page uh for the virtual inter meeting um session I can pass the link for that if you're missing it uh I guess it's the propose slides button there yeah I can just upload them there yeah okay just a second [Music] okay should be uploaded I hope it was the correct set of slides but I think so uh okay uh can you hear me Fabian yes I can hear you okay I think you can click on the button uh I'm not seeing any slides yet um"
  },
  {
    "startTime": "00:04:13",
    "text": "okay I started the screen share but did you get the uploaded slides too or yeah I can uh yeah I cannot check if the let me double check but for now I can see what you're sharing myself and I believe others as well so we can get started okay I will just turn my video on so that you got a face to the talk okay so my name is Fabian El I'm a PhD student at the University of tubing in Germany and there we implemented the m&a framework in its current state on the int toino in4 so I will talk and discuss today about our implementation experience with that is for today's agenda I will first provide you with some background information on m& and the relevant drafts so that we all on the same page then I will talk about mutable data including PSD I will present our proposed operation modes and finally I will describe the implemented pipeline in a bit more detail and show you an implemented example Network action now before we start here's a lection for this talk so you will find those colored bookmarks and circles on each slide and they indic if the content is from the current IDF drafts in green if it's a proposal by us in blue or a topic for discussion in Red so if you see a red circle we can have a discussion there but of course you can ask at any time or after the presentation so here's a motivation not for the m&a framework but for this work and for m& to be successful it must be efficiently implementable in Hardware because we've seen similar cases with IPv6 extension headers where pack that"
  },
  {
    "startTime": "00:06:00",
    "text": "contain multiple of those headers are often dropped by many routers and Transit and the reason there is that at scale IPv6 extension headers are not that trivial to implement in Hardware so we need to find out if the m& encoding works on hardware and we in tuban use the Intel Tofino as a reference architecture for hardware implementations and there we follow the Paradigm that if it works on the int toino it will most likely also work across other more powerful or when the specific Hardware so now the questions behind this work are if the iatf m& en coding can be implemented efficiently on Hardware what the challenges are and later then if we should use PSD or not now first some background to get started the m& framework is a general mechanism for transmitting processing and executing predefined n actions and for that purpose a new generalized headend coding is introduced that defines to encode Network actions and the data and this encoding is called the network action substack short Nas and it's basically a stack of related lses containing Network actions and their data which is inserted into the MLS stack so now what does that aess look like basically it's a bspl entry followed by Network actions enter data and this bspl is called the NES indicator then for the rest of the NES the traditional encoding is reded defined to encode Network actions so we do not have the traditional um label traffic class TTL encoding but we have rather three different new encodings there we have the mandatory initial up code um which contains an OP code some data and configuration parameters and the length field then we have the optional subsequent op code type and the optional ancillary data entry type here we have some examples for"
  },
  {
    "startTime": "00:08:00",
    "text": "valid Nas according to the ITF draft that's the absolute minimum we can have with only a single initial op code then we can have multiple subsequent op codes and note the length Fields here that's the example we've seen on the slide before and we can have one larger Nas with different numbers of ancillary data inserted into the stack now they all have in common that there's no ancillary data after the initial op code lsse so we cannot have anciliary data here and that's because right now it's not allowed in the encoding and there's also no l field for this purpose and this brings us to our first discussion point because during implementation we ask ourselves if we cannot move the configuration parameters of the initial op code so this part here into the TTL field of the BSL and eliminate that encoding type because that basically simplifies the coding and saves us eight bits and as I said before the initial op code cannot carry ancillary data so let's say if we only have a single action in a packet that requires ancillary data lses then we have to put in an initial op code lsse that is not used because there can be no ancillary data and we have to waste one lsse also if we look at defining those Network actions we always have to keep in mind to have either two different versions or two definitions of each Network action meaning for each lsse type or we have to constrain Network actions in the definition and say that the action is only well it for one type and therefore we think it would be better to eliminate this encoding type the initial up code Type completely and move the flex into the BSL and only work with OP code lses and AD lses but we don't know if there are any other implications with redefining the values in a BS PL because in um I think that"
  },
  {
    "startTime": "00:10:04",
    "text": "those fields the TTL is not really used but maybe somebody can comment on that that would be great at this point yeah so um there's actually some text in the draft uh the TTL field is absolutely necessary in the format a LSP LSC okay is what what's the reason behind that uh so we have a case at the I'm sorry I don't remember the the details at this point um but if you dig up the draft it said it talks about it um and storage jumping in to remind me uh what I was going to say is that there is some Hardware quite ancient Hardware that um May pred decrement and check the TTL so you may not get the TTL value you expected but is a TTL value really necessary for BS SPL entry or is it again some backward compatibility thing then if we want to deploy that and we will have problems with that there is some Hardware I me depends on yeah we we we have to be able to deal with any hardware implementation right and some Hardware pre-processed the TTL before it realized um that it shouldn't I had this problem in pseudo designs a long time ago okay so I draw the conclusion that we cannot do this in this case then all right free to start a discussion on the mailing list you know maybe well first check the draft see the text there and then feel free to start a discussion if you don't agree with the text yes I will read the draft again and search for some more information okay um one uh one follow up on this"
  },
  {
    "startTime": "00:12:01",
    "text": "from my side uh if I remember correctly at the P penultimate hop uh there was a possibility that uh the the special purpose label would show up as the top label um after popping all the transport labels so in that case we don't want to play with the TTL but I'll double check we discussed that in the past um but that was just a something that came up to my mind okay thank you then I will just continue so another concept introduced in another separate draft is post data and post data is located um as the name says below the MLS de so with some offset or directly below the MLS de and in the draft the presence of PSD is indicated by a bit in the initial op code of in stnas and right now in this draft the reserve bit is proposed but there are ongoing discussions whether another bit or op code should be used and at least in my experience with the implementation now a bit is way easier to implement because we can in before easily check it during parsing if we would have an OP code we would have to check every op code in the stack during parsing but the position of the bit could be changed of course if we want to keep the reserved bit in this case you see here's a red circle so we can discuss about this now but maybe it's better to discuss it afterwards or move that to the mailing list as I think there we some discussions about that so um I see a raised hand in the meet Echo tool by Tony Tony yeah I think yeah I'm not sure if Tony had it by mistake ah okay okay so I move the discussion to the and okay there's another hand"
  },
  {
    "startTime": "00:14:04",
    "text": "now yeah actually I think the the current proposal is to have a res bit in the uh not in the initial op code but it's I think it's part of the reserved bids right yes exactly it's this reserved bit if you look at the encoding before it's a single reserved bit yeah and now it's the P bit or right right yeah just for clarification thank you yeah okay so in the draft um we have another encoding introduced it follows basically the same Principle as a Nas but the MLS requirements like the bottom of Stack bit are gone but we have that first nibble and div verion field but the principle is same is the same we have a post stack Network action top header that in indicates the beginning of the PSD and then we have the post stack Network action header where we again can Define op codes data and the length okay there are two hands again I'll just ask if there's any question on that yeah J Jimmy dropped so Greg is at the top of the que go ahead yes thank you I have a clarification um question so uh in the previous slide you referred to the in the draft uh PSD encapsulation but uh the working group draft does not define any PSD encapsulation this is actually in this draft here below not in the header and coding draft but there's a separate draft for post stack encoding yes but this is individual draft so it's not being uh"
  },
  {
    "startTime": "00:16:00",
    "text": "sufficiently discussed and considerate so uh I don't know how much of uh really uh relevance it has to their uh discussion of m&a because it's only one possible way and um so as working group draft can change so this one is even more so yeah yes that's true we just used that draft even though it's not a working group group draft as a reference to read about PSD and to search for possibilities how to implement PSD and we based our implementation for now on this but don't take that as um as a production ready implementation or production ready post stack data and coding okay thank you okay so next point is um different Scopes in the nas en coding and that's an important concept for us because a scope tells where Network action should be processed and right now there are three different Scopes the hop by hop scope the select scope and the Ingress to e scope and there should be only one Nas per scope per hop allowed and a m Nas must not be on top of the stack and if a note exposes one to the top it must therefore also pop the and now in our work we only look at segment routing with MLS as normal label switching is quite easier to do and here we have a potentially larger MLS Deck with multip ness so now in segment routing the note that pushes the MLS STC at the Ingress must ensure that each note on the path can read its Network actions and for that purpose those notes signal the readable label depth the rld to the engress node and the rld is the number of e the note can read without"
  },
  {
    "startTime": "00:18:00",
    "text": "performance impact so then the Ingress nodes takes care that the NES is placed within read label de for each node and therefore may have to place multiple copies of a Nas in the deck and here you see an example of such an MLs Deck with having two hop by hop Nas copies and we refer to this as hop by hop Nas replication in the following so one more aspect that we find is important is mutable data and with mutable data we mean data where the value changes during packet forwarding on a path an example for this is the collection of telemetry data along a path for example collecting node IDs doing some path tracing or time stamps and that information must be capped and updated along the path so for backward compatibility only the last eight bits of an lsse are mutable and that's because Legacy devices might has the MLS label for load balancing and we do not want to change that so only those bits in the lses are mutable now the challenge is how can we use more than those eight bits for mutable data if we need mutable data and how can we carry mutable data in the MLS de with the hop by hop Nas replication we've seen before and there's another Hand by Greg yes thank you um I not sure that I know that uh any use case that uh been acknowledged that requires mutable data support less mutable data being part of their uh label stack so although it might be interesting uh for um research but so far there is not agreement as I understand that we have a use case that does"
  },
  {
    "startTime": "00:20:00",
    "text": "require uh mutable data uh being supported especially in the labels St yes I'm aware of that because for the mentioned um collecting Telemetry data here we can for example just use the direct export function of for example but as you said for research this topic is of interest because it has challenges in it and as you will see later inst data is quite easier to do without mutable data yes if we talk about the Telemetry data collection in a uh data packet itself then uh as I understand it the proposal is to use not inst uh unary data but postte data so then the mutable uh will be postte data not insect data still yes we will that's exactly what follows in the next slides so yeah so stay tuned yeah no no what I'm saying is that then probably the green should go for uh red flag of for discussion because it's um currently working group documents do not require mutable data in stack yes all right um so here's now an example um that illustrates the problem with hop by hop replication and mutable data but with the background that for this we take instc data mutable so if that's not directly in the draft that's just an expl an example of what a problem would be here okay so we have an example network with some Transit nodes an Ingress Noe that pushes the stack and an erress Noe and we have different rlds on the path and the m&a incapable node so now the Ingress node pushes the stack places two hop by hop copies in it and in green you"
  },
  {
    "startTime": "00:22:01",
    "text": "can see the set data bits now note a receives that packet has the hop by hop Nas in readable label dep adds some data and forwards the packet according to label 60 to not B same happens at node B node B adds some data forwards to label um 70 pops the label now has the hop by hop NES at the top and therefore has to pop the hop by hop NES as well and that's where we would have a problem if we're doing mutable data in stack because we don't know what to do with the already um with the mutable data and at the moment it's not quite clear how to find such a conflict and how to resolve it if we're doing that because in theory we would have to copy the data down but the nas copy is not within our Rd so we wanted to find a way that prevents those conflicts Al together yes Greg please so I have to come again to this um so um you um set a use case as a problem that needs to be addressed that doesn't seem to be really grounded on any use case that is listed in uh working group document that documented uh use cases so it's a draft ITF mpos m& use cases so I I I'm really again that might be interesting challenge to uh resolve but uh how practical it is how about we just take this as a point for uh future requirements uh yes future requirements that's fine I agree but uh again uh then"
  },
  {
    "startTime": "00:24:00",
    "text": "the consideration or at least from what I understand the mutable data supposed to be postte data so there is no use case for instake data unless I'm missing something yes you can see that kind of as a motivation for postc data why we should do postc so you can see yourself confirmed in the use case ders with this example I'm I'm not saying that we should do this or that this should be in use case draft yeah guys I think even though we don't have a use case for M mutable data in SD now but that it doesn't mean in the future we can't as a general solution I I think we do need to consider uh this this situation and uh find solution for it because we we we cannot exclude this possibilities right uh again we can agree and I don't argue that if and when we need mutable data then uh potic data seems like a uh appropriate solution but let's first discuss the use case thank you so points been made let's move on yes okay so quick conclusion with the hop by hop label replication we have multiple um copies of the hop by hop nest in the stack that leads on the one hand to larger stacks and on the other hand makes the handling of mutable data difficult in stack and that's why we propose the concept of hop by hop Nas preservation and basically there we only allow a hop by hop Nas to be placed below the top of St stack label so only at this position or at the Active segment and now a note that brings this Nas to the top must then move it one segment de deeper after processing so if we look at this stack the select Nas is processed and popped because it's a select Nas anyway and then we move the below forwarding forwarding label up or"
  },
  {
    "startTime": "00:26:02",
    "text": "move the hop by hop Nas Down it's basically the same and in the end we receive this stack and after that we can or if we get this stack the next note can repeat the same so now this has the advantage that the stack only has to hold one hop by hop NES and that mutable data is reflected in stack anywhere because we only have a single copy and we also do not have to search for hop by hopas buried somewhere in the stack so we know that if you're going from the top we will find our hop by hopas pretty soon but the problem is that m&a incapable nodes cannot deal with this and also this does not follow the traditional MLS Push Pops for Paradigm but we have some kind of an reorder mechanism in this so here you see an example of how this would look like note that this note now speaks m& 2 and basically the H by hopas is updated by each note and moved down by one segment after forwarding and this is yes we have a question from how you ah yeah didn't see that yes yeah actually you may uh uh talking about it but relate to slid 13 uh as another that's another question is the uh now rsrb is a uh capable of I right but if it's um uh it's a incapable of processing so uh the processor of it will be just a pop the pop label then it will expose the n as a uh as the top of Stack but as a as specified in the specification that's not allowed because uh um lsrb is incapable m& will do nothing about that and then um the next step when it reach to lsrc"
  },
  {
    "startTime": "00:28:02",
    "text": "if is indeed ISD capable but it will see the top top of Stack is M Stack substack that will viate the specification how to solve that problem well the the RS or the draft says that that was a question right yeah that's a question yeah okay so the I think the RC or the draft said that if a m&a capable node and that's lsrb here for example exposes a nest to the top which it does by popping the forwarding label after forwarding so this is the packet it before entering the switch then it also must pop the hop by hop nest and that's what happens here and this packet So Below label 80 is forwarded to lsrc which is not capable of m&a just to does the forwarding according to label 80 and then we can proceed with doing the hop by hop Nas at lsrd Okay Go Okay then back to the hop by hop Nas preservation I think I explained this already yes I did and as I said that's what we implemented and we also implemented the hopn replication before but more on this later so now we've seen the problem of mutable data where we can only use the L eight last eight bits of an lsse and that we can use hop Nas preservation to keep the hop by hop data but the last only works with all the nodes no m&a now another approach to solve the mutable data problem is postag data and this works because the postag is not hashed for ecmp so we can use all data bits and also the data is kept in one place namely the post stack so we do not have to do some copy mechanism but here the question is if we can"
  },
  {
    "startTime": "00:30:00",
    "text": "implement it efficiently and for us the challenge is how do we get to the post stack We have basically two or three options we can jump over the MLS deck if our device supports jumping or we can use a look ahead function by just looking at the bottom of Stack bit until we at the end or we have to pass the full MLS stack and the small teaser for our implementation we are not capable of jumping during parsing so therefore we have to pass the full stack and that may sound uh not that promising but for us on the indino it's not a problem to a certain depth yes another question Greg yes um so uh we discussed it u in uh our previous interim meetings so um there um uh postte data becomes uh I would say more interesting because of uh several uh technologies that use their own postte headers uh specifically it's a suda wire um control word it's a de net control word it's a um AC it's a de net Associated Channel header and it's a beer header so effectively in these cases uh if and when there is a so basically there a lot of consideration but uh the fact is that uh these postte headers are expected to follow immediately after uh their label stack element with their uh sbit set so then if uh any PSD applied to them then they must follow their postte headers so again just looking for uh this uh magical bottom of the stack label stack element might not"
  },
  {
    "startTime": "00:32:00",
    "text": "work so basically what you need to do is you need to know your label because only based on a context of label you can determine whether you have um application po uh postc header and what's the size of this post header because uh they are of different size so it's say either one stack element two stack element or uh some arbitrary in case of beer thank you thanks okay then I will proceed to our operation modes so with the previous knowledge we now propose three different operation modes depending on the requirements to the nodes and the network actions we want to implement and note that this does not require big changes in the m&a drafts except for maybe the hop by hop Nas preservation concept but it's rather an application of the current drafts so first of all we have the compatibility mode and we implemented that with the Hop byop Nas replication therefore we can have a mixture of m&a incapable and m&a capable nodes there we have two sub modes one using inst data only Which is less restrictive to the readable label depth in our case but we only have a few mutable data bits available and only in some circumstances so therefore applications or use cases here would be Network actions that do not require mutable data for example the direct export feature of then the second sub mode is compatibility with ISD and PSD or PSD only depends there we have more mutable data available in the postte but we have to get to the postte somehow so that's the challenge and therefore also use cases would be of course Network actions that require mutable data and the third mode we propose is the Green Field mode there we make use"
  },
  {
    "startTime": "00:34:01",
    "text": "of the hop by hop Nas preservation concept and therefore we can for now only have m& capable nodes for this note we say that if we are going to do a Greenfield deployment anyway we just say that we require entropy labels therefore we do not have to Hash the stack and we can have all datab bits mutable in stack so in this case we have no need for PSD for example for the direct EXP sport feature therefore use cases could be all of the above okay now for some details on the implementation before I dive into that short intro to before before is a high level programming language to describe the data plane of switches there we have a compiler that Maps our P4 program onto the pipeline of a Target and that pipeline in P4 consists of a programmable parer some control blocks and a dearer in those control blocks we Define our packet processing operations there we make use of match action units branching constructs logical and simple arithmetic Expressions what we cannot do is um loops and if we have to Loop over something we have to do a recirculation and in a recirculation we Traverse the pipeline once send it back to the Ingress and can process it again so now for the parsing of m& and you might have heard about my previous talk on the m&a head encoding basically there I said that the different encodings are too complex to model them in a finite State machine like the before parer users one and there I propose different encodings and at this point thanks to the people and the discussion last time because that really helped us pushing the implementation in the version we have now and because now I know a little bit better because in the implementation we simply ignore the different encodings during paring so we pass all lses after the initial op code"
  },
  {
    "startTime": "00:36:01",
    "text": "into the encoding of a subsequent op code and then later doing processing we can decide whether we are looking at an OP code or at an ad lsse so an m& or a NES which is in the packet like this looks like this in the internal representation of our implementation yes question please yes um I'd like to reality check if I may is P4 deployed in any production Network at the moment or any production platform and if not is it likely to be because I'm trying to make sure that we're designing this around the majority rather than uh an artifact of a one particular implementation Tony St you're asking two different questions uh you first asked if there was existence proof yes there is uh previous employer shipped a Barefoot based box um you asked then about majority no is very much in the minority yes so we are building in4 to build a proof of concept of course that doesn't mean that the draft has to be designed around P4 or something like that it's just our experience we have in the implementation so in the implementation doing the Ping we push the p lsse on one of those three types of substacks in the internal P4 representation and note that this is very specific or specific to our implementation so that's not something that um has to be addressed in a draft or something it's just background information about our experience and we have to do this to apply the operations later then according to the placement in the stack and to emit the substacks in"
  },
  {
    "startTime": "00:38:01",
    "text": "the correct order there we have the active segment stack which contains everything that's related to the current segment so the forwarding label and the relevant Mass we have the intermediate segment stack that holds labels and Nas of other segments and those are labels we have to parse to get to the bottom of stack or to find the buried H hopas they are pared but not processed and then finally we have the persistence stack that Post St data or hop by hop Nest located below not before we have to fixate the maximum size of all of those stacks and the space for the allocation there is limited so we have to think about optimizing the size of those St substacks to the requirements of our Network for example if we know that we have long paths in the network we should increase the size of the intermediate segment deack or if we know that we have many or large hop by hop actions we should increase the persistence deck size but we have to stay overall within the readable label depth so that's a constraint for us you can see now an overview of the assignment of labels through the corresponding substack according to the implemented mode and here basically the active segment stack is always the same like here and here it contains the forwarding label and the relevant Nas for the inst data only mode the intermediate segments deack holds labels until the first hop by hop Nas is found so this part here but for the PSD mode the intermediate stack holds the full remaining MLS stack until the bottom of Stack so you see here that the intermediate stack has to be a lot bigger if we're doing PSD in our implementation then at the bottom in this case we find our hop by hop Nas because as we have to be within the readable label dep for the whole stack for PSD here anyway we can place a single hop by hop Nas at the bottom and we do not need hop by hop Nas replication here then in contrast for the Green"
  },
  {
    "startTime": "00:40:00",
    "text": "Field mode the intermediates deck only has to hold one label and we do not require a persistence deck so we can stop parsing quite early here and we only have to check this part and this makes in our case the Green Field mode the most efficient one regarding the readable label depth and the allocated header space after we are done done with parsing we get to the processing of the stack in the pipeline and here here one match action table for each lsse in a Nas is required and such a table holds the op codes and the network actions and therefore we need 16 tables for each scope so 16 for the hop by hop scope 16 for the select scope and those tables are then applied sequentially now we ignore the different encodings during parsing and in processing we match on the network action length field for each lsse so on this field here where we have the value one and then X execute an action that accesses the following number sad encoded lses and then those lses are skipped and not processed as op codes and that's how we get from this encoding back or from from the um simplified encoding with only subsequent op codes back to the semantics of the original n now another point is that the pipeline space is limited so we can only fit n of those tables in the pipeline then we have to go into recirc calulation and here is a very high level overview of the pipeline in4 for the Greenfield mode there we have those different stages and in each stage we apply n of these tables for the different Scopes so a packet here enters the pipeline and the first n entries of the first Nas are processed then for the first Nas we apply some trick on the toino to get it processed without a recirculation in the eras but this only works for the first Nas and won't go into details here so after that we have"
  },
  {
    "startTime": "00:42:01",
    "text": "to potentially recirculate at most twice if there's another Nas in our scope or if there's a very large second Nas and then finally we do the hop by hop label preservation mechanism and forward the packet and for the other modes the pipeline looks very similar but for PSD we have another recirculation so the concept is basically the same there are differences in paring the packets now you see here that in the first iteration we can process a maximum or a fully sized NES with 60 Network actions without having to recirculate and maybe compared to IPv6 extension adders because that's that was the motivation at the beginning we can depending on the device do only like three extension headers without recirculation so this is compared to that it it works and also note that the recirculations here are only required in the in the worst case so we can do many Network actions if we place them accordingly so now as a teaser already the postte implementation brings some more requirements for P4 and first of all for us everything must be within the readable label depth so we cannot jump in parsing but that's not a problem for us on the toino so we can just parse the full stack in line rate and as I said before other forwarding engines have their ways to find um to the bottom of Stack another constraint for us is that we have to stay within the distribution of those substacks so for example here we say that there can be 16 lses between the active segment and the bottom of Stack but of course we can move the sizes around as long as we stay within the overall readable Lael dep we just have to keep this in mind a disadvantage here is that PSD processing increases the number recirculations but in the future we"
  },
  {
    "startTime": "00:44:00",
    "text": "maybe can optimize this okay so um one thing we asked ourselves during implementation is if we are doing the compatibility mode with PSD in P4 that means for us that we have to have the whole mstic in readable label Dev so therefore we do not need um copies of the hop by hop Ness in the stack and we can place a single Nest at the bottom of the stack and there we can indicate the postte data so that also means that we can place all the hop by Hop Network actions and the data in the post SEC and that we can shrink the size of the hop by hop Nas to two lses in this case one lsse if we could use the TTL but we already talked about that and for us this would reduce the number of recirculations in the implementation so yes question for discussion can can we use the hop by hop Ness to only indicate PSD or is there a requirement to have insect data actions in parallel with postte actions or can we say that we're moving everything to PSD so as we've discussed the working group has no requirements for PSD at this time yeah one question on uh on this slide um in regards to readable laal depth um if you re recirculate the packet wouldn't the readable lead label depth increase um and if so uh why wouldn't it improve the uh you know the inst stack approach versus the post stack um for the first question um it does increase the Red Label depth because we can pass the full stack at"
  },
  {
    "startTime": "00:46:01",
    "text": "once and on each each recirculation we can pass the full stack again so that doesn't make a difference for us I see of course it could be increased if we do the select Nas in the first iteration and then pop it and then the stack is a bit smaller and we can go deeper but that's a special case that's what I was thinking yeah you advance and then you do another parsing but yeah that's what I was uh I got that uh feedback yeah thanks yes and what what was the second question again yeah if if the readable label depth if it increases then the in it will benefit the inst stack approach but uh based on your implementation the readable label depth does not improve even though you can recirculate the packet yes that's correct so um I think each time of the recirculation will effectively half the throughput so that's really should be avoided which means uh for the single pass processing that might be actually a rld uh limitation for this kind of Hardware so we should try the best to limit um the the size to make it uh to ensure it can be processed in single pass without to to avoid any recirculation that's one point another point is U uh even though um this trinal Hardware is actually really used uh it's never widely used um but the basic parsing logic is also adopted by the Orcs A6 switch A6 so they use a similar approach so they will face a similar problem and of course there's other type of uh um devices based on network processor which is totally software programmable uh but on that I I I don't"
  },
  {
    "startTime": "00:48:02",
    "text": "think is their passer is more efficient than A6 because A6 actually take advantage of all the parallel processing it is can actually pass a header uh in in a single uh State machine uh clock cycle so um but if you do that in pure software way that will obviously it will take more Cycles so I can imagine the performance will be much worse than than that in as6 Hardware so um I really think we uh for any uh encoding uh style actually we should uh consider um how we can Implement that what's their what's how they behave in different kind of hardware and thank you very much for actually uh doing this work to at least provide some experience on this this one uh available Hardware but uh we may also need to see how it behave in other type of Hardware thank you thank you okay so finally for some implemented example Network action um basically we implemented some kind of a simplified version of a path tracing mechanism in the context ofam so it's notam we just wanted to build a proof of concept that we can access all the fields match on the correct fields and do something with it so the goal of our example Network action was to collect the note ID of each ters Noe and evaluate the path at the tail end Noe so basically simplified and yes Greg before I do a de Yes actually um about uh the simplified version um in the context of in C2 o so yes uh path tracing have been proposed for IPv6 only so uh path tracing has not been"
  },
  {
    "startTime": "00:50:03",
    "text": "proposed for NS network uh and um I think that U probably it's better if we are not uh consider it because there was even less in my opinion ground to uh discuss applicability of path tracing in npos network thank you yes I do not mean that we have to implement path tracing or something like that it's just a proof of concept that the pipeline processing works of course you can do anything else with that that was just the simplest thing we could do with those actions and there's another question yes please rakes okay probably not then I will just continue okay so we designed the nwork action okay now maybe H sorry I was talking on mute sorry there is a draft on part tracing for MLS I'll put the link to the the draft in the chat oh thanks okay okay so we designed the network action like this that we have an OP code to indicate simplified IAM then we do matching on the flags and we say that each flag indicates what metric you want to collect for example you want to do note ID collection then we set this bit then we reserve ad lses uh in this case so let's say we reserve five entries that means that Transit nodes do not have to add lses and then we treat the mutable data field here as an index to indicate to Transit nodes where they have to write the data in the ancillary data so if there's a zero the transit node inputs its data in entry zero and increments the index by one and then finally the"
  },
  {
    "startTime": "00:52:02",
    "text": "data is written into here and that's um what we implemented actually on the int toino and there we run without a recirculation at 100 gabit per second and note that this is the inst stack data only version here so therefore the hop by hop scope needs to be at the bottom but of course we can move this to the other modes and what you see here is basically the packet enters node a sees op Code 42 node ID metric collection flag and index zero then therefore it writes its node ID let's say a into the data field forwards the packet and increments the index node B does the same or every node does the same and at the end we have our path okay so that was the inst data version here you see the same with the Greenfield mode and note that here we can make use of a single ad lsse because we have more mutable data and that we can use the index to write or to to specify the offset where to write that and here the overall stack looks a lot more Compact and we make use of the hop by hop um Nas preservation concept where we just move the hop by hop Nas Down and this also Works postte Data Works similar so it's the same concept as this but of course the data is in post stack and not here in the D lsse so now that brings me to my conclusion so we in this work we analyze the requirements for Network actions and therefore we proposed three operational modes for deploying m&a in a network so namely the compatibility mode with ISD ISD and PSD and the Green Field mode and we implemented all three modes in P4 on the Intel toino one running at line rate of 100 gabit per second and by the way some nice side products of this project are that we have a python Library where you can assemble and send m&a packets"
  },
  {
    "startTime": "00:54:00",
    "text": "and we have a wire shark dissector extension for visualizing that m& traffic so now one of the initial questions was if the ITF Mna encoding can be implemented efficiently on hardware and we say yes the encoding works but depending on the size and distribution of the subex we have to go into recirculation but in the best case we can do 60 Network actions without having to recirculate the challenge in an implementation lies in mutable data with instc and the hop by hop Nas replication if we are not doing this then post stack brings some harsh requirements at least in our case namely that we have to get to the bottom of stack and finally here you have an overview which of the modes one can use depending on the requirement so if you have only m&a capable nodes we say that you can go for the Greenfield mode because it's the most efficient one in this case in the P4 case if you can accommodate the entire header stack in readable label depth you can do do Post data potentially need more recirculations and if not you can do inst data only and now for some future work we still want to optimize the implementation meaning we have ideas how to reduce the number of recirculations but we have to test it out and also on the Intel toino 2 we expect better performance and also we have some ideas how we can make the Green Field mode so the hop by hop Nas preservation mode compatible with m&a incapable nodes but we have to think about this first then we want to extend the range of implemented Network actions for example the MLS inband performance measurement draft right now or the direct export i m option and we also have currently a paper about our findings as work in progress so if you want to have maybe a specific Network action implemented and see how it if it works or if you want to"
  },
  {
    "startTime": "00:56:01",
    "text": "join in on writing the paper we are open for collaborations just reach out to me so thanks for your time now I'm open for another round of discussion and maybe to get the discussion started you have an overview of the three different operation modes and the requirements and now my initial question is what do you think about the modes do you think they are feasible especially with the PSD requirement thank you uh can you go back to slid uh 29 this one oh yeah oh let me see uh okay this what what mode is this um is this uh you you mention three different mode compatibility and uh yes this is the compatibility mode using inst data only oh okay so so you also said here is this U uh stack substack must be at the bottom of Stack right if yes if that's the case and it actually doesn't matter if it's a in stack or post deack it can be can be done also in post stack and then without any limitation on the format right because if if it must be at this location and you force it into in stack you you you basically add some artificial limitation on that if if at first place if it's must be at the bottom stack it can can be PSD and for format free so that's my comments right yes that's true and that's also the intention behind the slide because if we are not placing the hop by hop Nas at the bottom it means that we need to have copies in the stack because else the other notes wouldn't get the hop by hopn with the problem I've explained on the slide before this means we have to place it at the bottom and you see that it's not that efficient and that's what brings this mode or the PSD mode which is similar there we can"
  },
  {
    "startTime": "00:58:01",
    "text": "make use of mutable data so I'd say inst data only is as you've already discussed a lot not really suitable for mutable data but it could be implemented if you really want to okay okay then Tony is next in the Que talking on mute um so couple points uh first you mentioned you had some Python and some wire shark stuff that you've done uh if you be willing to share that that would be most appreciative I'm sure the testing folks and development folks would be very interested in playing with that um on your last slide uh you raised Greenfield mode and that's not possible Right the internet cannot be swaped popped out uh there are no flag days so we don't get to do that um and compatibility mode with istd and PSD again we have not accepted that we are going to do PSD so that's not even interesting case right yet uh so then we're really looking only at ISD only yes thanks for your input um actually yes the Greenfield mode only would work if we m&a capable nodes but we have some ideas how we could that move that m&a incapable noes as well but we have to test it around a bit so I will um I will give notice on the mailing list as soon as I know more about that and for the ISD and PSD mode just I I don't want to um say that we should do this or that it should be decided to do this it's just current state it would be possible has some requirements to us"
  },
  {
    "startTime": "01:00:00",
    "text": "yes okay then next one in the Q yeah thank you very much for all this work it's very interesting and uh my first question is uh about uh uh P tracing case can you go back to that page yeah or the slide before this one yes so in this case you put H by Hop N in the end of the stack well but will this cause the IOD issue for some notes they cannot pass or they cannot reach this H hnas because it's deep in the stack yes that's correct and that's also um the motivation why mutable data in stack is a bad idea because the other option would be to have another hop by hop Nas like somewhere above here yeah but if you're doing mutable data then you would pop that hop by hopn somewhere in between so let's say here and then you have the issue from before that you have to copy the mutable data down but the copy is Out Of Reach so I know that this is not feasible for most implementations but as I said before if you want to do inst stack data only with mutable data you would have to do it like this or you find some way to solve the copy problem yeah I agree with this analysis and another case I'd like to mention is uh the size of the data even it is not mutable if uh it need to be H by hop processed uh if you put it in the label stack it will also need to be replicated several times and you can then impact the uh in capsulation efficiency as you cannot you do not have much space for"
  },
  {
    "startTime": "01:02:00",
    "text": "the uh normal forwarding labels in the label stack have you consider that case so that maybe the size of the data can be some thing to be need to be considered when you when decide to whether use ISD or PSD for a specific type of a action that is not just a mutable or not but also the size can be something to be considered in this Choice yes of course it I mean it all relies on the capability of readable label dep on your notes or of your notes yes yes especially if you want to consider some Legacy uh no if they want to do the normal forwarding right and another thing is about the last page you do the comparison between the three modes and U what I I'd like to say that in the green mode actually you are creating something not compatible with existing mprs then do which you need to follow the label stack format or the behavior introduced by mprs it's just a new protocol to my understanding um Yes actually that's why it's called a green field mode um I mean it's it's just an example of how efficient it could be if we are not backward compatibility compatible but the point is that if our idea Works to also get this mode working with m&a incapable nodes then we could have mutable data in stack without that copy problem then of course if you do not have entropy labels you still have eight bits per lsse only mutable but you can have um only one hop by hop nest with mutable"
  },
  {
    "startTime": "01:04:02",
    "text": "data in stack but as I said we have to find out if that works that's just our current state-ofthe-art yeah yeah I think it only makes sense if it can be uh compatible or interoperable with existing mprs uh no otherwise it's uh we can do the protocol extension without this limitations of the exist format right that's a good point yes yeah thank you okay uh we are past uh the mark uh uh for for today's meeting and and I want to reiterate uh my uh um you know uh my thank um I'm glad that you presented this Fabian and this was very great work uh thank you for uh you know sharing your experiences uh the slides I have left a uh a link where you can upload the slides if you can take a look at the chat and um please propose the slides and they will be documented so everybody can have access to it yes I will do that after the meeting now and also um for the python and wi shark libraries I have to clean them up a bit more honestly but I'll just reach out to the mating list and push them to git or somewhere that you can that would work great if you can leave the the URL in the slides itself that would you know people would have access to it uh you know towards the end last slide maybe yes I'll add it but as I said I have to clean it up a bit so might take a day if you want to send the URL to the mailing list separately that's fine too I can do also both so doesn't really matter sure thank you so much again and I'll U"
  },
  {
    "startTime": "01:06:00",
    "text": "you know send um U towards my co-chairs if they want to ask any further questions before we adjourn um directed to my co-chairs so no no question from my side but I think it was really a great job thanks for the input thanks thank you Fabian and your entire team for helping uh invite you to participate actively as part of the working group thank you very much yeah thank you okay have a good day have a good day thank you bye"
  }
]
