[
  {
    "startTime": "00:00:16",
    "text": "Alright. Good morning, everybody. We will get going in in just a minute. In the meantime, I really could use some note takers if anybody is willing to take notes and note taking tool. Yeah. So that would be fine if presenters wanna do some some swapping. So, Thomas, can you take notes while Rafael is Okay. And, you know, multiple people can help the note taking tool is very collaborative. You can type over the top of each other. So It's actually very helpful to have even a couple of people. And really, we need action items and, you know, things like that, not verbatim conversations in the first place. So not not not not not not We don't have chat GPT yet working. No. The transcription system used to it. We have transcription. No. I guess that went away this time. It was an experiment last time. So We should probably go ahead and and get started, You can. Yeah. The the note taking tool makes it a little bit easier to do collaboration so that other people can But whatever works, it will accept notes in any form you can get them to us. So to start off, I'm"
  },
  {
    "startTime": "00:02:03",
    "text": "West Hardaker. Claire is my wonderful co cochair, and She'll be speaking in a minute. And, yeah, Claire, please do feel free to go ahead and broadcaster video as well. I will say that there is one of the most important things that we can do is make sure that you do sign in to the room There is a QR code which will appear when Claire goes away. So the screen over there will have a QR code on it. There's one outside the room, and you are well to scan this one as well. Yeah. The the downside of of our audio visual system is that the QR code only appears when nobody is on video. So so so But everybody do please sign into that because that is our official record of keeping track of things I'm sure most of you have seen the note well at some point in the past, but you make sure that you understand it well by contributing to the and by participating, you agree to follow the IETF processes and policies That includes intellectual property. It includes the fact that You know, you'll be recorded for video and audio and things like that. If you have questions, contact your lawyer because I'm not one. there is a number of things that the note will covers, there is a list practices in the IETF for those that are newer to the IETF. These are all worth reading. They include how the standardization process works, how working groups work, our anti harassment and code of conduct procedures we follow very strictly how our copyright system works and how patents and so participation works and how you must disclose them when you're contributing to the ATF as well as our privacy policy Our IETF code of conduct guidelines, which I have a explicit slide about These are important. We treat colleagues with respect. We speak slowly and limit the use of"
  },
  {
    "startTime": "00:04:03",
    "text": "slang. This is where I fail a lot of the time, so I will try and slow down. We dispute ideas by using reasoned argument and we use our best engineering judgment We find the best solution for the whole Internet, not just a segment, not just my personal view, but we really need to think about, you know, what's the best solution for all the users of the Internet. we contribute to the ongoing work and the and the group of the IETF. I'll remind you that this session recorded both visually and in audio. So make sure, as I said, you sign in to the session. You can use the QR code that I mentioned. There is also link on the IETF agenda regardless of whether you're using a phone or whether you're using in a computer, you can actually log into the session that way as well. We do use that Mead echo tool for doing all microphone queue management. So you need to hit the the raise hand button on on the little tool in order to get into the queue, and we will follow the ordering in that queue pretty strictly. keep your audio and video off unless, you know, if you're using if you're in the room, if you're remote, keep it off until it is actually your turn to speak and present Remote participants, make sure, you know, as I said, keep everything off and know, using a making sure your audio is good by using a headset is, of course, well recommended. this is the information about the the working group in particular, the SAP protocol. We have a data tracker has lots of our information and documents. We have a mailing list, which is actually sat not set p because it predates the name of the working group a little bit. And there are 3 active working group drafts to consider, and they're actually those are actually the name of the drafts. I apologize for not updating this slide. They're all now draft, you know, IETF SAT p with core architecture and use cases."
  },
  {
    "startTime": "00:06:02",
    "text": "Those will will get you there if you search for them, though. Our working group meetings, we hold them at every IETF We have monthly interim meetings that have been very well attended with good discussions. There are 2 more coming up. 1 in August and 1 in October Why don't we have one in September? And then the other question I realized is that, you know, we planned a bunch of these out. We haven't talked about continuing my guess is that we probably want to submit a bunch more. Claire Creek created them all in the past, and Claire, I think you and I probably need to chat about know, creating ones for November beyond. So we'll add that to our to do list because those do seem to be an effective way of communicating for this group. This is the tab damage version of the agenda, It looked much better when I looked at it on my screen. Welcome to PDF creation out of something or other. There's a lot of things on this agenda, and I'll see if I can find a better copy of it at some point. But The important things is the agenda items in the beginning, especially 3 to 6, our our core working group items. The things under any other business really fall to things that we know that we're working group wants to do at some point in the future, but are slightly out of you know, charter now even though they're somewhat related. So we do give priority to items, you know, 3 to 6 in particular. So if they need a little bit of time, we'll actually sacrifice any other business, and we apologize for that being the case, but we have to get through our chartered items first. With that, I'm gonna turn it over to Claire, who is going talk about the scope and the purpose of the set working group in the first place. Absolutely. And to the point on the previous slide, I as I remote, I have the advanced shipping. I go to the stopwatch. So we'll give you sort of a 5 minute warning for the pro for the presenters. if we go over a couple of minutes over 5 minutes, fine, but we do need to be fairly"
  },
  {
    "startTime": "00:08:01",
    "text": "consistent with the times we've put forward. And whereas I've just double checked the meeting agenda, we do have a meeting in for September 12th as well. My apologies. I'm gonna stop taking that on the slide. Hi, everyone. Thank you for coming. Sorry I can't be there in person. The Atlanta is quite a large agent to crush. So without further ado, the scope So we've all had this before. I will just repeat it again for the benefits of framing conversations for today. The focus for our first iteration is to develop a protocol for the secure single one direction, union directional transfer of any digital asset between any two networks. So you will hear a lot of talk about blockchain today, but that's mainly because of our presenters are focusing on that area, but any solution we come up with will be agnostic to any network and any digitalized asset. As to the focus of and the focus of our work, it will be for the transfer itself between two gateways. So there's some assumptions about the the setup of a network, and a gateway. the discussions around a gateway, what a gateway contains, and what a gateway can do should be limited only to the elements of that gateway that will impact the transfer of the asset itself. So only so much in that messaging might be impacted, recovery might be impacted. Beyond that, that's out of scope for this version. Any questions, always bring it up. We're happy to discuss and agree as a group whether or not there is a reason in scope, but we do need to focus on the scope for best, best, best, best, Thank you, Liz. Next slide, please. So as I've just said, unidirection asked to transfer Gateway to Gateway asset transfer, assumptions about the networks, is agnostic to all of them. And future scopes to be confirmed, multidirectional, gateway considerations, digital log like bills of lading,"
  },
  {
    "startTime": "00:10:01",
    "text": "then in networks itself, so pre locking, which I know we've got some agenda items today, but only insofar the impact to the actual transfer itself that we are discussing. Thank you. Where's next slide? And I'm not gonna keep reading the signs out to you. I think we've made the point. In terms of path to adoption, we are here. We have been formally identified as a working group. We've had our 1st official working group meeting. We've agreed to formally adopt all three of our documents as Wes has pointed out. We're now in the design and deliberation phase. So we have the interim meetings, the mailing lists, documents are being edit and revised by the working group. We're in that process now. Once we've agreed the documents are ready to review. They go out to a peer review and feedback and the edit and review cycle will continue until peer review is confirmed. and then that is the documents on the path to implementation. So just to kind of point out where we are in the cycle, Still very much, as always, will be a collaborative assess all ideas of welcome for review and discussion. I think that takes us to our first ten minutes. bang on time. Thank you. It does. Alright. So we'll ask Thomas to come up first and give a presentation on the update to Sat core. I will I will run the slides. Yes. morning, folks. So yours. Okay. Thank you. So so this is a set of updates that has been done to non core core 2. And this some of this was discussed at the last interim meeting, the online meeting, but I thought let's let's go with through it again in more detail. Next slide, please. Thank you, Wes. I was hoping this will work. So so basically 4 bullets and a quick report on the architecture draft."
  },
  {
    "startTime": "00:12:01",
    "text": "So these are the main set of changes, groups of changes, and I'll go through each one of them. And and the there's a red red sort of notch on the right hand corner that's that tells you we're moving to a different topic. Next slide, please. Thank you. So the first thing is removing the redundant act act prepare. So thank you, Alex. I think Alex is is online somewhere from the UK, but thank you for pointing this out. So in the in the classic 3 phase commit for those who remember the database class. There is 1 coordinator and multi subordinate databases. So when you do a change on one database, you wanna propagate to all the other copies. That's the whole point of a distributed database. And so when the coordinator sends Get ready, you know, you know, prepare. prepared to commit, all of these guys are majority of them have to actually explicitly send back an act acknowledging. Yes. We've received the certification. We're ready to to go ahead. But since we are or only dealing with 1 gate, 11 center gate, and 1 receiver gate, but not a one to many. this particular message is redundant. Like, what's the point of know, this one single recipient gateway acknowledging something that both sides already know it's gonna happen. So that's been taken out And so so you'll see in the For those who are interested in the details, the message flow diagram, there's a link before to our GitHub repo and the current gigantic color diagram is version 19. you'll see the act prepared message still there, but grayed out And when we move on to the next rev, that's gonna be taken out completely. That's kinda our habit in the group is keep the messages that are gonna be deleted were chains in gray, and then you see the next rev, it's gone. And all the reps are there up in the repos. If you wanna go through all the way, like, version 7, I think it's up there. So next slide, please."
  },
  {
    "startTime": "00:14:04",
    "text": "So this is what it looks like. So commit prepare is message 3.1. and you could probably see it. But, yeah, you can see it. Right? It's it's gray. For the for those who are not familiar, It's the the gray arrow going from the right tool less, act prepare. And so that's basically gone. it's it's worth noting. We did discuss case as well in the future. What happens we have an asset that's gonna be split into 2 and there's 2 recipient gateways, and you kinda said, no. No. No. Let's just do the basic first. If you can't do one to one, then there's no point arguing about one to many. So so this is this is where it is at that point in the diagram. Next slide. Thank you. Bye bye. I do it? Oh, thank you. and and Okay. So transfer commence. So because of that, we we also also thank you, Alex, about really logically so this 3 stages stage 1 should organize the setup And so the agreement to commence really need to happen in stage 1 and all the other stuff like locking assets in stage 2. So what hap what has happened is two messages have just simply been shifted up to stage 1. It used to be at the top of stage 2. and these are called transfer commands. Let's let's commence. And the other side says, yes, acknowledge that's commenced. And so However, the other thing that's that we did for stage 1 now is that is is So you'll see message 1.3and1.4 used to be in stage 2. Now it's part of stage 1. It's just been shifted up. So it's just a logical delay our mind sort of know, arrange arranges things. But the big thing also that we added is this multiple negotiations of the features of not only the gateways, but also the assets. So we we call that transfer claims. So this is gateway g one saying to gateway, g 2. These are the parameters of the exchange. And g 2 can say, yes. we accept I accepted or g 2 can say,"
  },
  {
    "startTime": "00:16:04",
    "text": "No. I don't I don't I don't like your signature algorithm. I only use signature algorithms. It goes back again. So that that loop that dot dot Aero thing is is trying to say that this is a multi round segment So one point one, in fact, is multi round. is really what we're saying. Right? And so And we've just been calling that transfer proposal claim. right now, if g2 accepts the claim that is just received from g 1 is simply sends a receipt message. So when you when you hear the word claim. It's a digitally signed claim that's independent of the SSL, the TLS connection. So it's stand stands alone. If you see a receipt, it's a signed receipt. Why do we have to explicitly sign stuff? because this you know, legal and you know, financial obligations when things go wrong, when disputes occur. And so both sides need some kind of a standalone evidence and which is why they have to sign busy design stuff. So one point 2 is the explicit receipt. Now if this room round thing keeps on going on and on and on and g 2 finally gives up okay. I give up. This is this is too hard. G Two can simply send a counterproposal, With an empty claim, I give up and terminate connection. So this is one mechanism, and we're looking for ideas for different way different ways to gracefully indicate that none of these claims the majority of these claims is just acceptable and so we wanna terminate. that's that's another future sort of subject that we wanna approach and address here. Any questions before I move on to the next bullet change Please do use the queue button if possible. That's Smith Intel. So I think it's not clear whether a transfer protocol receipt is continuing the exchange, Otherwise,"
  },
  {
    "startTime": "00:18:01",
    "text": "if it's if it's terminating the the exchange, it's not clear what message is being sent in the dotted arrow Okay. should give it a name. Okay. Thank you. That's that's that's exactly what The input we're looking for because trying to show this month in negotiation and you know, final receipt and reject in a diagram. But yeah. So so if folks have suggested names of this, we're quite open to names. kinda struggling with names. Thank you for that. And, Yaron? So I hope that's pronounced right. Hi. I'm I'm Neil here. So this may be a silly question. You're on chef. We in in many networks security protocols, we have avoided multi negotiation forever, basically, why why is it justified here? Why is it needed here? So so thank you, Yaron. nice to see you. A long time. So we have at stage 0 actually, that's out of scope. Dennis is gonna talk a bit about stage 0, which is the setup So we we have the same question has been asked of us. But why not do all this stuff about what is the asset type and all this stuff really need to be staged 0. out of scope for us. So it's quite possible that 1.1and1 basically, 1.1 is this they've already agreed somewhere in stage 0. It's out of scope for us. And one point one just says, this is what we agreed upon. Sign it. Yeah. So originally, the previous version versions ago of this diagram, which is a simple this is what we agreed upon. Yes. Yes. I I agree. Yeah. Thank you. Yeah. So this is you know, if you have some thoughts you wanna help out here, Yaron? I know you're you're capable at a know you're a busy guy, but, yeah, stage 0 is is this sort of complex, because a lot of the stuff out there is beyond the IETF For example, identity of the originate and beneficiary like"
  },
  {
    "startTime": "00:20:03",
    "text": "who who are the you know, how do I identify gateway operators? Right? This is Yeah. These are yeah. Two quick points with respect to the ATFA, this is the exact type of feedback that we want in the ATF. We actually want an interactive discussion with feedback that's the purpose of this. It's not a presentation just to so we we like questions. But but but 2, the set protocol working group had a very restricted charter to get started where we scoped things down to just this interaction and deliberately put out of scope things like the agreements that had to be in place first as well as how gateways might interact with their community. That stuff that we wanna do in the future, but Charter, you know, we didn't we didn't bite the whole problem at once. So thank you very much for that. Yogesh? Oh, there's yeah. Question. Myakrishna. Hi, Yogesh. Yeah. Probably, Anayu question as well. So are we assuming that the 2 gateways are online all the time in terms of connectivity is We hope so. I I'm I'm assuming yes, and that's why we got we got Rafael. So so the model we we are adopting for crash recovery is a primary backup. So each side actually has a shadow gateway. Right? And so if if it dies, one is gonna pick up the session. And so this topic we put under the title session resumption. which is actually turning out to be quite complex. Actually, more complex than I thought, and that's why we've got Rafael here. Yeah. Good. Thank you, Yogesh. k. And then net again. one way to approach the you know, recurring negotiation protocol is to define a state machine. for example, if you've established that you have a set of claims, that you've accepted and a set of claims that are not accepted if you create a state machine for each of those claims. then you can each side can check that you've yeah. That the state machine is progressing. You you is your right hand"
  },
  {
    "startTime": "00:22:03",
    "text": "volunteering? No. Maybe. Oh, maybe. Yeah. Yeah. No. This is great. We we actually did the state machine kinda thing for the state for the asset states. but not for the stage 0. Yeah. Now that's a good idea. That's great. I think I think Dennis kinda is saying the same thing for stage 0. write Dennis. You can Just type yes. Absolutely. Yeah. Thanks, Dennis. Okay. So moving on, Next one. Okay. So this is the set of claims So so in the previous version of the draft, it was disorganized. Let's just put it that way. And I said, okay. Let's just put everything in section 7. So section 7, it, you know, has multiple subsection, but there's one specifically on the claims section. pertaining to the asset and the actors, meaning what is the asset profile? What is the ident identifier for the asset profile? who what is the identify identity of Alice and Bob. Right? So that's that's assets and the actors, and then a second set of claims has to do with the gateway itself. and the network itself. the characteristics because it could be, for example, network 1 might be using a different duration lock It might be using an escrow instead of a lock. Right? So so it's just grouped that way just for us to easily understand you know, on the sections. it could be that as as as Yaron was saying earlier that all of this stuff really needs to be in stage 0. Right? So so know, for example, know, a a gateway this is a good one that I think will come up when we talk about session resumption. should g one indicate to g 2 its primary backup. the identity of the primary gap backup kit so that if if one of them crashes and they wanna do session resumption, not surprised. They're expecting they know who to expect as the primary backup gateway."
  },
  {
    "startTime": "00:24:00",
    "text": "So things like that, But this is this is in section 7.1. It's super drafty drafty. So you know, please take a look at it and, you know, edit it and maybe all of this stuff really could be separate it into, like, a separate draft. Because because much of the item there is out of scope for the idea. In fact, it's it's all the it's it's driven by logic. It's driven by, you know, policy, government policy regulation. is really all the stuff in stage 0. This is just some examples. that we have now, the digital asset ID of the asset, the the profile, ID, identify the profile file, verified originated identity. So the word verified is there to indicate that that this is a big topic, by the way, in the crypto space. that entities who run services like gateways, they're almost obligated to make sure that the identity of Alice that originated an identity of Bob the receiver beneficiary is known ahead of time. This is the famous travel rule, which is came out of the the b s BSA act of 1996 public keys. So so this is just a guys should not be surprised with this. This is a sneak compiling everything into one section and more is needed is is really what I'm asking you guys about. So You know? So this is definitely this particular topic section needs a lot of work for for the core draft. Next slide. Session assumptions. So so we're gonna hear more about this from Rafael. But the idea, the general ideas, we would like to have appear a message flow it basically says, you know, that from one sender, from g 1 to g 2 or vice versa, request request session resumption, And then there's another line flow going back saying, you know, yes, no, here are the parameters. but but but"
  },
  {
    "startTime": "00:26:00",
    "text": "what is interesting is there's a lot of machinery that's happening behind the scene, behind the gateways, and that that determines well, there's a there's a recovery, sort of architecture that's gonna drive the selection of the parameters, it's gonna drive the the you know, the primary backup gateways. So I've just put it this as one slide, basically, saying, hey. Look at look at the draft. Recovery is 00, and I think this is gonna be the topic. We're gonna spend, like, half an hour with Rafael later on. So this this is you know, I think I just posted this on Sunday as that the the upload website was available. So the architecture document matches the flows in the Sat core. previously, SAPcor, like, there's, like, 2 versions ahead of the architecture a draft. And there's a you know in thank thank you, Rama, for putting a lot of text on the ISO 122 for those who are not familiar, that's a gigantic set of messaging, standards for the banking community, and we we think like, you know, we we should be using that for stage 0. because it's there, you know, it was some people might might not like XML, but I don't mind XML. It works. So yeah. So stage we're looking at, well, what what messages could we pick out of the set, that we could apply Just to interrupt very briefly, 5 minutes remaining. Thank you. Thank you. Is that last one? So next step, I think this is my last slide. So we're gonna continue working on Rafael on on the error. error messages section. and definitely work on what to do with this set of claims. And then, you know, any other topics fixes corrections that you know, you guys wanna make or introduce into the draft. I think I think that's it. Yeah. Okay."
  },
  {
    "startTime": "00:28:01",
    "text": "So with that, are there any questions to the room either remote or in person for Thomas before we switch context to a different to the next agenda item. Alright. Seeing none, I think we'll move on to Rama. Thank you. Give me one sec before it works. k. Good morning, everyone. A little closer to the mic. Good everyone. morning, So this actually is when about 3 things, this is an update to the use cases draft. Compatibility standards, this actually refers to what Thomas just mentioned. which was question raised in IETF 116 about the how satly related to the ISO 20,022 standard. And, finally, Originally, we were thinking we'll maybe add some text in the use case of trial, but finally we decided to add it to the architecture draft. So I'm gonna talk about that briefly here. And finally, I'll close with the mention about an ongoing implementation in a a popular interoperability blockchain and DLT interoperability system that will hopefully provide a reference template implementation as well as a software toolkit for anybody who wishes to use SATP for their purposes. So the use cases draft update this is we made some updates around CBTC. So there was some discussion on the mailing list around CBTC and what movie see about it. And the text on decentralized Finance and central my initial currency and a particular center advantage to currency There are a bunch of different scenarios, which involve interoperability"
  },
  {
    "startTime": "00:30:02",
    "text": "across different networks involving asset movements, and therefore, And and it's actually one of the most compelling and near term application of SatP and gateways because lots of governments now are experimenting with CBTC, and They're going to need some kind of a standard secured protocol that enables interlinking of different networks, enables the moment of assets in a safe manner, which at this point bunch of different adult solutions being worked out. So I'll I'll mention that briefly. So decentralized finance or DeFi is just a new financial paradigm that leverages distributed ledgers and blockchains to offer different kind of financial services like lending, investing, etcetera. Primarily, folks in the crypto area, but, really, you can think of decentralized finances, anything involving financial transaction that are occurring in a decentralized way without involving a or without relying on a traditional centralized intermediary. And there is a link here. There's also bunch of other references in the draft. If you see the use case draft, So scope for the world of finance, Defy Offers, architecture and protocols that are built on smart contracts on vaccine, etcetera. and and digital distributed ledger technology. CBD Central Bank Digital Currency is a particular application. does not have to be decentralized, but as it turns out, it mostly will be. I'll I'll have a slide coming up that that shows the landscape. So what is CVTC? It's a form of tokenized cryptocurrency that various central banks or in this country, the the federal bank or the federal reserve are experimenting with as the digital equivalent of traditional Central Bank issued money. And this is money that the only the central bank or the federal reserve or there's a sole authority to mint an issue, and it can be used by other banks and other financial institutions. for interbank settlements as well as for retail purposes. So there are"
  },
  {
    "startTime": "00:32:00",
    "text": "two categories. I'll I'll mention that in just a minute. So why CVDC compelling application if you see the map of the world is actually one year old, but you can see lots of governments around the world, including cross national organization like the EU, which have been experimenting with CBDCs. And out of as it says here at the bottom, 23 out of 93 CVs have decided on blockchain based infrastructure. So most of these or many of the most experiments here are going on on top of distributed ledger technologies. And this CPTC is not just about building 1 big distributed ledger network, it actually involves multiple networks as I'll I'll show you, and as is written in the draft, and that will actually require the moment of assets, where Sappi is called Payt role. Let's just an example at the right. which involves CBD experiment that I was involved in helping build which involves interoperability between 2 different networks the networks are built on permission DLTs like Hyperledger Fabric and CUDA. and it involved use cases around moving moving assets sharing data between different ledgers and exchanging assets. So why do we need multiple networks for Central Bank currency is because CBDC cannot be managed by just one single system or or ledger if it has to satisfy yeah, that those performance and scalability metrics that be be going to need for for a system of of of that importance, which involves both settlements as well as enabling people to conduct retail transactions. So there, we encountered 2 different categories of CBD broadly speaking, there's a whole CCVDC, which facilitates interbank and settlements and cross border settlements, and that kind of CBTC is available only to banks and other major financial institutions. But as retail CBDC is something that refers to currency that"
  },
  {
    "startTime": "00:34:01",
    "text": "is fundable with Jose Cbdc. but it's available to the public and can be used as a digital form of cash. And it's can be used as also a substitute for legacy payment mechanisms. So what this these different categories entail are they will necessary the deployment and use of different kind of networks some networks that manage whole CCBC, others that manage retail CBC, some are going to be public, going to private build up built on permission blockchains or DAD Technologies. Different architectures can be proposed for this. and and The one that's talked about mainly in the use cases draft is the one that is most popular, which is 2 tier or indirect, but they're also direct and and avid models. this is I showed the slide in the previous IETF meeting as well. This is the 2 tier architecture. You have a whole series cbdcine network. which involve the central or the reserve bank and various commercial banks maintaining accounts, and you can have smart contracts or business workflows built on top of that. But then the lower tier, you have different retail CBC networks. Each of which have a 1 or more commercial banks, and as well as end users and they they can they can manage currencies for transfers and and retail payments. And typically, they'll also have the central or reserve banks as auditors on those different networks. The use case of a SATP involve CBDC transfer between wholesale and CBD and retail networks, or between 2 different retail networks. And what we added what we added recently is a use case on multi CBC. So thanks to Thomas for proposing the this use case. CBD is a national financial instrument, but it they must also take Cross border payments and interbank settlements that are that that are global. So 2 possible solutions. 1, you can have a multi CPTC ledger"
  },
  {
    "startTime": "00:36:00",
    "text": "a shared CBC ledger containing multiple CBTCs or facilitating exchange of CBTCs, and that will had the potential benefit to improve cross border payments and also protect multi sovereignty. Without forcing the different countries to become part of monetary union. So you can have a come multi CBC ledger And but order to be able to transfer the BDCs between different countries. You will need to transfer from a Jose CBD Center to a multi CBTC ledger, or or back. So that requires a protocol like SATP. And or in a different kind of solution, you can have a direct exchange between 2 different hosts, the CBDs networks as well. So something that under suggested in the on the mailing list. So SATP across the Yeah. So we've we've got a a person with a hand up. if we could last year before we move on. Sure. Hi. My name is Trinchelieu. I'm from Huawei, and I kinda have a one simple question. So In the use case, you said there will be, like, a in interoperability between the cbdcnn and d 5 application So but until I hear until now, it's more like the a simple exchange of CBC between different countries and different jurisdictions. So when it comes to d5, it's actually come like it's a it's a different problem. Right? It's actually something more, like, financial business related, something like liquidity Mining, and you actually kind of giving out loans and getting interest back. So I'm not sure. Like, I just I just wanna clarify. So I I don't know. could you, like, clarify how do you actually use this SATP to like, use use STTP, sorry, to to enable, like, Defy using, like, cbdc Right. And the pharmacist Thomas wants to say something. But if you heard the westwest mention, mention"
  },
  {
    "startTime": "00:38:01",
    "text": "a few minutes ago that the charter for this particular the scope of the charter for SATP currently is very, very narrow. there's a lot of things we want to do in the space. SATP is defined narrowly for the purpose of moving an asset from one network to another. If you look at the architecture draft, we actually have a broader spectrum of use cases that are or interpretive modes that are defined there, but most of them are at this point not in the scope of the charter. And many of those those other modes will actually solve different problems related to DPI. Right. Thomas, did you wanna help answer that question? Okay. specific example. So let's say you have a closed private network. And I I have my assets there. Let's say, call it some kind of a currency. So I have liquidity. I have a 100,000,000 there. and I go out of the network, and I I wanna go to bank and borrow money. I wanna by the Picasso in your basement. Okay. Okay. Okay? And and so you're gonna save Mulev show me that you're liquid. Like, what's the point of talking to you? If you if you say you have 100,000,000 show me. And so I will say, well, talk to my gateway you're gonna hit my API. and at one of the gateways. And the gateway is gonna extract the evidence, the liquidity liquidity sort of and it's gonna issue a claim, a signed claim saying, we attest that this guy with this identifier has a 100,000,000 in tokenized cash or tokenized government money. So you need a Gape, and that's one of the modes that drama is talking about. But right now, we have a draft explaining all of that, but it's not a working group item. that. So but that that's the the the the point is that all the DFi stuff will face an additional hurdle when the network is closed. private completely. not everything is gonna be permissionless and 1 for, like, Ethereum. So we need to prepare for the you know, that kind of sort of situation where when and we're good at using gateway as sort of a paradigm to to explain that. Okay. Yeah. So"
  },
  {
    "startTime": "00:40:01",
    "text": "Just from my perspective, like, DeFi is a little bit more complex. Yes. That's just simply change things. That's right. So atomic stops is not gonna work. It's gonna get very Because clicks. if you do wanna do atomic swaps, 1 network is private, 1 is permissionless. Right. That's Alright. So let's let John that's we're toast. John comment, and please do make remember to use the microphones. We do have people remote that can't hear you if you're Yeah. I've tried a little bit This may be a dumb question. but -- But -- -- but -- But -- -- but -- But -- -- but -- -- but -- But -- If you have CBDCs in different countries, they're gonna be different currencies, and they're not gonna be worth the You know? And the way it works now is, like, you know, the fed basically has account offers accounts to it's lit. This was this was Central Bank. And you know, and at no point, do the do the do the do the 2 different currencies actually touch, you know, except sort of in the in the walls So I don't understand how the way that works relates to what you're talking about. ear. I mean, it's like, you can't yeah. in the absence of gold in the absence of a gold standard, you can't yeah. That's a good question, actually. I was hoping I was hoping Martin would be on closer closer to the Mike Thomas. So so so So the quick answer to that is is the quant guys now speak loosely on behalf of the quant guys Claire, please beat me up if I say something wrong. but they've shown an actual working demo where there is a network that connects up to a cbdcnetwork to do the payments and settlement. but the actual asset exchange is on a different token network. Right. So so the c the CBC is used only for settlement. to to answer your specific question, that's why they're talking about multicubDC networks But I understand. So this is this is the whole question about is the US dollar gonna be Right? you know yeah. if if I may. Yes. So there's there's a different conversation between how FX would work, which screen CBDC to CBDC settlement, and the SAT"
  },
  {
    "startTime": "00:42:02",
    "text": "protocol providing the rails in which that can happen. So absolutely, you are right. In a normal sense, 2 CBDCs don't touch, but you do still need to manage liquidity when you are trading CBDC from one currency to another. So, you know, you need to manage the liquidity, you need to sure that there's no double spending. And that's all out of scope, unfortunately, for the first version. But those are the of rules and the sorts of conditions that would be handled at that stage. between those messaging, between the FX, between the liquidity providers. But what the SOTP and Ram is I use case is to highlight the kinds of things that would benefit from having a secure asset transfer pro form based to security be open to interact and transfer digital assets between one network, to another. Yeah. No. one sentence that I'm done, which is I I told I totally get that guess, this would be more plausible if you at least gave us some hints about, like, where the FX plugs in around the edges. So putting my chair hat on I I think what we are hearing is that this is actually a difficult use case with the envisioning of the current charter because The current charter is really I have a fixed solid first from one network to another. And this use case is you know, or the use case of multiple currencies, it's very much outside the scope because we are sort of prohibited from working on. Well, we she want to mutate this asset as it gets transferred. Right? So we should put a note. So so within So there's 2 options, I think, and it's up to the group, not me. we could remove, you know, said use case, or we could put a note in in said use case saying, you know, with this is this is currently out of scope, and these are the missing requirements that the SAT working group is not currently working on, but know, we'll be in the future. So read this in the context of"
  },
  {
    "startTime": "00:44:00",
    "text": "it won't work today. That makes sense? Just just to quickly add to that, a quick add to that, Just there are experiments that different banks and companies are doing. The one that I example, I mentioned a couple of slides ago on the Bank of Bank of France and HSBC that they did with us at IBM. It involved trying to move currency or exchange currency between 2 different platform. Actually, it was an exchange scenario in order move. But that involved 2 different currency exchange anatomic currency exchange. both in different denominations. So these are things that companies experimenting with and they're trying to make it more decentralized when the current layer of the line is not decentralized. So just testing the water after after. Okay. Yeah. Thank you. just to pull out this. got 5 minutes remaining. We have already gone over the allotted 15, but Yes, Thomas, finished early. Just just in terms of being able to cover off everything you wanted to cover off today. I'll be quick. Thanks, dear. So this this actually we've already mentioned this. question raised by John back in in the previous ITS about how SAT differs from the ISO 2020 standard and why should we not instead just use that standard for the use cases that have been described in the in the draft. So we we are aware of these different kind of standards, but the what the clarification you add in the architecture draft is that the scope of SATP is defined quite narrowly precisely. and it also is defined such a way that it presents unique challenges that these different standards do not even attempt to Right? They they serve a different kind of purpose. And the intent of this working group is for the stat protocol to be compatible with other standards and specifically to not preclude the user any other standards for aspects of asset management that are not in the scope. like like in stage 0. So stage 0"
  },
  {
    "startTime": "00:46:01",
    "text": "this because it's not in the scope and where we still need different systems or different networks to agree on some things. we have scope for bringing in existing standards for to allow those 2 different networks. to to talk and and negotiate. So ISO 20,000 22 standard is I'm not gonna go into this in detail. It's Global comprehensive unified standard for financial messaging. And what it does is that it allows 2 different systems to communicate requests or or or intents to each other, and It also specifies the syntax for message construction using XML JSONasonone. it this standard provides communication probability, the ability to communicate information in an an ambiguous manner across system boundaries, but What SAP is doing is something more or something different, interoperability among networks that are managing digital as involve more than just communicating desire or intent about something. we what we want, and this is describing the architecture draft is that we need asset properties to be enforced across network level. And what that means is that if you have a standard for communication probability, which talks about syntax and semantics. That's by itself insufficient. Sati requires 2 different systems to carry out, share updates, in concert to achieve the required outcome. is an asset has to disappear from our network. and we create in a different one. So ISO 20,000 going to does not actually solve that particular problem. And by the same token, Sati is not trying to create yet another standard financial message. So we we have clearly mutually explore the scopes. They can play complementary roles in the asset management ecosystem, and we can leverage the ISO standard for asset triples and context negotiation is stage 0. And the various functions that are listed here, they are described in the in the architecture drafts with if you can't eat Any quick questions on that before I just touch upon this, Yaron?"
  },
  {
    "startTime": "00:48:04",
    "text": "Yeah. So so this is all good, but I don't understand the interoperability goals So do you have in mind an ISO 222 profile of SATP And those gateways will be interoperable or Anything else? Not at the not at this point, I think what we how we can leverage I sold 20,000 rand to in a CTP is the the stage before the stage 1 that Tom was talking about, stage 0, that 2 different systems are just coming to contact, and they decide, okay. Somebody in my network needs to send an asset to somebody in a different network. So how do you even start the process? How do you even discover how do you describe the asset that somebody wants to send. How do you describe what what context that that asset belongs to, what business process that asset belongs to. So there, we can use ISO 20,022 messages to Get them to communicate, And that's particulars of the asset profile particulars of the business process that the asset is be governed by and then move on to the actual SAP protocol. So that's So so my question is is very concrete. You're having a hackathon and you want to to prove that the protocol is complete enough that you can get into ability between t 1andc2 Those will need to speak both SATP and ISO 222. I suppose, otherwise, there was no interoperability. So if I may, in the IETF, we often divide things into different pieces. So there One of the the discussions is that this actually came up, I think, in one of the last ETFs to I personally view The SAP protocol is the negotiation process"
  },
  {
    "startTime": "00:50:00",
    "text": "how you encode the messages and you know, might be doable with the ISO framework. Right? So we haven't talked about There are many protocols in the IETF. There there might be multiple encodes. Right? Some things accept JSON. Some things accept XML. Some things might accept you know, ISO format at XML, we haven't gotten down into the negotiation of you know, are we gonna support multiple different types of messaging protocols? So that's an excellent question. I I think that that nobody in this working group has gotten there yet is what it comes down to. But but we will have to go there. That's the important takeaway. Probably, sir. Yes. So Alright. Is that your last slide too? Or -- This is my last slide. Hold on. Talk really quick. I will. So We have an ongoing project on implementing the API protocol based on the specifications that we call. and both Rafael and and I are commentors of a of a developer who's sort of temporarily hired by hyperledger. Hyperledger, if you don't know is a foundation that governs various blockchain and distributed ledger open source projects, and they an annual sort of in mentorship or internship program. So this is the the system described on the right or institute on the right is hyperlogic cacti, which is a flagship interoperability, project, under hyperledger. And it consists of these modules for the relays which we are trying to fashion as SATP gateways. So they will be confirming to the standards that are describing the in SAP code. So Alright. Thanks very much. One one other with my long term senior IETF hat on. One of the things that we do in the IETF is when we have multiple options. So multiple encodings, multiple things. We almost always mandate 1 as the one that you must support That's the way we get interoperability. Every gateway must support"
  },
  {
    "startTime": "00:52:03",
    "text": "this flavor of Jason or whatever it might be, The rest of these are optional and you can negotiate that, but we always have the ability to fall to one that everybody must support. Just future thought for for this working group. Ned, Ned Smith Intel. So I didn't see any in any of the use cases where you gave some attention to privacy. So I'm a little concerned that as a gateway, that's a exchanging a set of claims and attributes that there aren't some claims that in one network might be defined as being privacy sensitive, but in the network, it's not privacy sensitive. and you may be if you're not tagging that information in some way, the other gateway might not treat it appropriately. k. Thank you. Yeah. Alright. Thank you very much, Roma. We will go on to Raphael on the crash recovery which should be another good discussion Actually, if I may answer to that concern on on privacy, we are currently exploring what are the privacy implications of interoperating a private ledger against non private ledger, so a public ledger. And there are some factors that we can wait here so such as the indistinguishableity of identities, the confidentiality of the transfer itself And effectively, there are a few methods to Promote privacy across sliders, but it depends a bit on the use case. but we're we're looking on through a map. Thank you. Hi. Hi, folks. I'm Rafael. I've been working with Thomas and the rest of the group for the well now, and I've"
  },
  {
    "startTime": "00:54:01",
    "text": "put my focus on crash fault tolerance and session resumption, which we believe it's fundamental part of the protocol. So we can guarantee that the protocol is life and safe. Right. So gateways are software systems and being so systems, they can enter faulty states, for a variety of reasons, the point here is that sooner or later, a gate will enter for this state. and it can have repercussions on the right operation of of said b. Some of the So when a gateway in terms of 40 states, it can produce alerts and errors, so there are faults that can be recoverable by sending the input or the the output to the user, the user can the the user being the the counterparty gateway. counterpartic gate with connect upon those faults and protocol might be resolved by itself. Right? Other errors are more catastrophic causing gateways to crash. So depending on the phase of the protocol where the gateway crashes, this might have important repercussions on the safety of the protocol. So for example, if a gateway crashes in the middle of an asset transfer, which is a process that involves transactions against distributed lagers. then we might have a sort of double spend, across leggers, which is something that the protocol states clearly that should not happen. So to address the possible crashes and the possible failures we need a strong logging mechanism and the recovery procedure that allows gateways to recover its state and continue the rightful execution of the protocol. We for this, we have"
  },
  {
    "startTime": "00:56:00",
    "text": "to databases, the first one is a state database where every gateway persists every step of the protocol, locally, And we also have a distributed public database that is used for non repudiation and decentralization of the process. So we encompass these two different databases on 1 log storage API, so that the gateway can issue log what write requests onto its database or in a in the decentralized database. And these login procedures and recovery procedures are depicted on on our gateway recovery draft. So this is a schematics of how the login procedure work all the logs are written ahead meaning that before the gateway executes an operation, it will write the log entry that that operation will be executed. So these login 3 essentially has the stage of SATP, the specific step within that stage and the process. a process or an operation is what specifically the great way is is doing. So the gateway might be about to execute a specific step of the protocol, it might be executing the that specific step at that time. it might have concluded the execution or it might have caught an error. or a file. This is the example for the transfer command phase. So let's say it's stage 1, step 1, although we moved it to stage 0. when gateway to communicates together with the gateway 1 communicates to gateway 2 that the transfer commands should be initiated, the gateway to writes the intention of executing that step"
  },
  {
    "startTime": "00:58:00",
    "text": "within its log storage API. Right? So in step 3, the intention of executing that step is showcased in LogStar at API, and then the the the phase itself it's executed on step 4. Upon execution, that way to writes that it has successfully executed that step, and then it communicates the result to gateway 1. So here we are implicitly implicitly assuming that we are good to go for the next phase because we received an answer from gateway to And this login procedure allows us allow us to be sure of each step of the protocol at any time. such that if one of the gateway crashes, we can retain or recover the states that we were currently in. So how do we handle crash faults? Well, we have 2 scenarios. faults that are noncritical and faults that we consider to be critical. The noncritical Faults happen when gateways are communicating, but they do not interact with the external c So, for example, the negotiating the negotiation phase. If one of the gateways crash? Crash? Well, it's not much of a bummer. Right? It will recover and keep the negotiation going on. It it's okay. However, when a gateway crashes in the middle of a transaction with decentralized ledger, then we can have a bigger problem because those transactions are not easily reversible. If we have a centralized database, an operator can come in and revert the transaction. But if we're dealing with decentralized ledger's, then the procedure is not as simple. By the way, feel free to put any questions during the presentation. Now, great ways are assumed we consider to recovery"
  },
  {
    "startTime": "01:00:04",
    "text": "process or models, the the self healing where the gate recovers by itself magically. or primary backup, we choose to standardized or to explore the primary backup because it's more sensitive, more aligned with the real world implementations. And in in this model, when a primary gateway crashes, it will be replaced by 1 or more gateways that will act as backups. So there needs to be a mechanism for gateways to agree on Who can replace them in the eventuality of a crash. Right? So depending on if we have crashes on that are noncritical or critical, we might just resume the protocol, abort the protocol, or roll back the protocol. Rollbacks are essentially the implementations for recovering faults that have issued transactions against distributed ledger. So we need to do define what is the state of our gateway, the state that the gateway has to have order to be able to recover. essentially, we save the session ID the gateway is involved in the transfer, of course, the transfer contacts the stage of the step in the operation. And, also, the trick the trick is here, the rollback logic. So the rollback logic is depending dependent on the specific step of the protocol. and it contains the guidelines or the the instructions, for recovering a crash that happens in that phase. So for example, If gateway crashes, After walking an asset, on a source chain, the rollback logic will tell that we should issue a transaction with the opposite effect."
  },
  {
    "startTime": "01:02:02",
    "text": "we now give an example of a noncritical crash, which would be, for example, in stage 1 with the transfer proposal claims. let's say that gateway 1 Sands. message 1.1 to gateway 2 and then crashes right away. gateway tool process this message and execute its part of the protocol, And then when he returns the message, it will face a 500 or a 503, or it will simply not have an answer because gateway 1 has crashed. So so we implement 2 time outs. the first time out. is when the gateway 2 tries to communicate with gateway 1 and is the time what the time out expires, it will retry the message, a number of times, or against the time out, when that second timeout is expired, then we issue the crash recovery procedure. In in more detail, we have the transfer proposal claim that it's sent to gateway 1, and then great for you. to gateway 2. Sorry. And then gateway 1 crashes. So what gateway 2 does is it writes the logs that going to execute that phase according to what we've explained. it executes the transfer of proposal claims. and then it sends it back to to the first gateway. But it gets nowhere, so it or it gets an internal error So the first time out, the gateway tool try to send back the response to gateway 1, on a hope that gateway 1 has self healed, and we'll be able to to answer accordingly. If if this timeout expires, then gateway 2 assumes that kt1 has crashed. and it will wait. according to our protocol."
  },
  {
    "startTime": "01:04:00",
    "text": "This has license implications, but we We are assuming that the primary backup model is in place. So, eventually, a backup Gateway will take the k31's place. So when the backup gateway comes online, it initiates the recovery phase. it sends a recover message to gateway 2. gateway 2. tries to compute the state that gateway 1 has missed because it even received the the original message. and sends a recover update message with that updated state. Gateway 1 can then parse this decentralized log phone extra as an extra safety measure. and expedite its local state according to what gateway to has, has from has stated. Right. And after that, we cover 6 message, then gateway 2 might or or can send the original message to gateway 1. and resume the process. So all in all, these has a few steps. The gateway 1 gateway 1 recovers from the crash, Gateway 2 helps computing the latest state gateway 1 has missed. to one updates. That state? and then they continue the protocol. These avoids starting the protocol from scratch. Of course, that if Guiton 1 does not respond upon the second buy mode. then then great way to might decide that Keto1 has crashed indefinitely, and it can abort the protocol. So this is a safety measure against gateway to waiting forever. in practice, we assume the primary backup model to hold."
  },
  {
    "startTime": "01:06:04",
    "text": "in theory, I mean, but in practice, we should have this time out otherwise. we'll have liveness implications. In case of an abort, then the session is crashed and it needs to start over. That was an example for a noncritical crash. for the critical crash will take the stage 2 phase where we have a log assertion, And that's the outcome of locking an asset on the source blockchain. So gateway 1 sends the the log assertion and crashes right away. Getaway 2. will compute, will actually do the local search in broadcast and compute the receipt. And it will send the receipt to gateway 1, but gateway 1 again does not answer because it scratched. So the procedure here is quite similar, we have the crash, we have the computation of the result and the respective right log entries that are omitted for space purposes. he sends the the answer back, but there's no answer because gateway 1 has crashed. And now we have the same procedure. So we have the first time out that does retries. and then we have the phase work gateway 1 recovers and does exactly the same thing. So for critical and noncritical crashes, the procedure is the same. except that if the gateway if the gateway 1 does not answer in time, then we initiate a rollback instead of an abort. if the recovery is successful, then it gate 1 just competes the current state it should be in. and executes the protocol. Otherwise, a rollback decision. So if I may really quick, I assume in that failure case that also is not just from a time out, it also occurs"
  },
  {
    "startTime": "01:08:00",
    "text": "and say gateway 1 says, I can't recover because my log is dead too. It was on a spinning disk that is no longer spinning or something. Exactly. that that that might be the case. So if k31 has imagined corrupted logs or it's not on the condition to recover then that recover message will actually be an abort message. to get to it so. and the protocol would be and this guy is not aborted, but rolled back. This rollback might might be executed by gateway 2, if possible, but might be cases that gateway 1 needs to do the rollback by self when it recovers. So this might be these might enter the states that's sort of a realistic state where we need manual intervention to solve this problem. namely in the state where gateway 1 needs to conduct the rollback and gateway gate 1, cannot conduct the rollback because it's crashed. Okay. It looks like we have one question from Hi. Trinci here. Sorry. Just one question about the recovery of the gateway. 1. So consider, like, after the gateway 1 has made several, like, attempts or some claims. and then he wants this gateway 1 failed and some backup gateway indicate with one side wants to take over. So the thing is the context of something that our exact action that the gateway one has actually done must be kind of retreat out of the crushed Gateway 1. So if this gateway is completely crushed, it's not just network staying. It's just like a completely breakdown, then this kind of what have Gateway 1 has done That thing is kind of tracking this broken computer is how how do you take it out, take it out,"
  },
  {
    "startTime": "01:10:01",
    "text": "That's an excellent question. And and that's true. So if your question assumes that the state database is lost against is lost with the gateway. Right? Yes. So the gateway crashes in the state database. crashes as well, and we cannot retrieve But the assumption we make here is that the these state database is replicated in the primary backup model. Okay. So the way it works is for every transaction that the primary backup does, the the primary gateway does. Mhmm. We update the state database. Okay. And this state database is replicated to the backup gateway. So the backup gateway is not offline. It's online along with the primary. Great way. you kind of assume a very strong synchrony. Yes. Yes. Okay. Cool. Thank you for your question. Yeah. John Lavigne, I sort of met a question. Okay. Which is what you have here is an extremely complicated set of interactive state machines. And As far as I can tell, they look okay. You know? But I look at blogs and see where tiny bugs in defi state machines cause horrible problem. So I'm wondering if you tried to do, like, formal methods to make sure you don't have arcs to nowhere. Yes. That's future work for sure. That would be the next step. Yeah. Okay. We'll define the -- We'll define the messages. the specific schema, get right what we need to do, and then definitely we need to employ some formal methods because this has very subtle bugs that we should get -- I mean, like, I You read Molly. I'm sure we all read Molly White's blog. You know? Like, I don't wanna see this on Molly White's block. Okay. Well, well, we could even consider the bug if what what happens if gate to 1 since a message crashes, gateway and then gateway 2 crashes. Right? how how would the rollback work there. Yeah. Those set of bugs we need to sync about them. people like that one. Yeah. So I inserted myself in the queue with for 2 purposes. 1,"
  },
  {
    "startTime": "01:12:00",
    "text": "I'll start with a statement, which is there's a IRTF group called univer usable formal methods research group. They are just spinning up. They're they're they literally had their second meeting, I think, yesterday. they are looking for test cases to you know, to apply their methodology. And not only that at IETF, 1 18 is next. Right? They will probably have a editorial and using some of the tools. So it might be a 3 hour tour it's usable formal methods research group, uf MRG, and it's part of the IRTF is a research group. So they're looking, you know, longer term out. But but they're considering all sorts of protocols to evaluate But my question that I was going to ask, which is the second part, is How much of this aligns, you know, the the the technology for doing transactions, you know, have been well associated with database and the whole, you know, asset compliance comes long before this working group. how much of this aligns with what other people have done that is, you know, proven to be a secure mechanism for doing, you know, reboots and things like that. So we're we're using Right? pretty common techniques, crash fault, tolerance techniques from the database literature. we know that we need to align these techniques from distributed systems with formal methods to create a more robust protocol, crush recovery protocol. The working group that you suggest, I think it's a great first step to start start seeing what people are doing in real world protocols and venues such as the IETF. Great. So I will say that the reason that the research group exists is that formal method been around for a long time, but they're not usable. They're very hard, you know, to do these proof So the the goal of this research group is to make it so that you know, people like us that may not have much background in"
  },
  {
    "startTime": "01:14:01",
    "text": "informal methods, I don't might actually be able to use these tools in order to actually help us we we actually considered briefly to use DLS, or something more in the cryptography It is research area, like universal composability to model these protocols, but Sunu realize that it would take a lot of work for a protocol that's likely to be changed considerably in the next few months. So as the as of now, we will do this as future work. Alright. Right. So example rollback logic for the lock assumption step, In in the locker session, we basically have a lock or a burn on a source chain, and we need to unlock it or meet it on the on the target change. So there's a typo there. so the rollback logic to undo the lock is essentially a transaction against a distributed ledger that and thus, or undo that lock. quite soon. the input would be the assets to be unlocked. and the output would be a beat successful fail. So this is quite simplified version of the rollback logic. We've actually implemented this on the first seat the first open source is ATP implementation that's available in hyperledger cacti. So you can check the code and see how is this implemented. doesn't discussion items that we can have around session resumption. So should session resumption be explicit or implicit. right now, we're considered to be implicit. So the gateway 2 assumes expects a recover message from a crash gateway right away. we might"
  },
  {
    "startTime": "01:16:00",
    "text": "want to have a short negotiation phase on how the recovery will be done, we can also embed this on the on the profiles. So having crash recovery profile on h0. defines the gateways that can be backups, the specific parameters of the recovery and so on. Right? And the second item, I think, aligns very well with John's concern, which is what happens if we have subtle bugs that will invariably happen Right? That is a there's a few solutions a few ad hoc solutions we can create and incorporate within the protocol, but to really grasp the very subtle bugs that will appear we probably need to use some formal methods. Wes, how much time do we have, please? So you started a little bit late because we're are letting the primary presentations run long a little bit, and is is there an important seems important. So I I think you probably have another 9 minutes or so ideally. Right. Very good. Another discussion which is more related to the use case would be should we consider a burn means protocol or a lock and lock protocol And this is a discussion that's ongoing on interoperability community specifically in the blockchain world. we might consider to enforce a lock and lock, order button means in the protocol or probably that probably if that will happen. would be allowing application developers to choose 1 of the 2 models. Dimitri,"
  },
  {
    "startTime": "01:18:03",
    "text": "Hi, Dimitry, Apple. It's, like, interesting. couple of questions to clarify my understanding first that As a transfer, is it a complete transfer from one system to another, there is no copying Okay. Okay. Got it. So and the lock is universal lock which means retry delete. So just lock it. no one can do anything to that resource. So the question, what is the size of the asset being transferred can then be large, And if it's like gigabytes, a 100 gigabytes can be the case. Okay. So There are no real asset transfers across watchings. Hit Watchions literally do not talk with each other. Notably, at least most blockchains, and blockchains have a modular construct, where you can create instances of that blockchain engine, and they communicate with built in interoperability protocol. Right? Mhmm. But for the majority of botchines, the transferring an asset is really not transferring an asset. It is locking an asset, locking an asset, on a source chain or making it unusable And unlocking a representation on the target chain. So that representation is Mhmm. just a string. It can be can occupy as little as 32 bytes. It it depends on the asset. profile definition. Okay. and the implementation on chain. But, typically, it would it would be an entry on a table. So not very stowage consuming. Okay. Makes sense. Thank you. You're welcome. Right. Let's we we're almost done. error messages. So for situations where we do not have crashes, we might have error messages that are communicated to other gateways, so other gateways the counterparty gateway can"
  },
  {
    "startTime": "01:20:04",
    "text": "try to resolve the error and keep the protocol going. and And we can have errors across all the steps. of all the stages of set p, some of the errors before actually go to the arrows, we have schema for the arrow, so the arrow type, the arrow codes, the description, proprietary attribute where the gateway operator defines the custom message for the error, and we we essentially define the different errors across the different stages. this will this is ongoing work. Of course, there are many, many, many errors that we still haven't discovered or thought about, but few examples are budily formatted message, an act mismatch, assets already locked, then we have errors that are specific to the distributed budgets we're transacting against and so on. we've got a question or hand up from Dimitri Is that an old hand? It might be an old hand. I thought I'd sort of go down and come back up again. Must be home. Now oh, we've got another one just come up now. So if we could just take a moment. Yeah. I'm sorry if I -- -- too much questions. Just I wanna The question I'm having is, like, intuitively, like, burn and mint are actually reactions. compared to lock and unlock. So I understand, unlock and unlock. It actually could be you consider from a highly part attack. Right? So that's kind of individual level. scam or some kind of attack. But if you would like Making it like a standard and make mint and and burn. That kind of is like a normal procedure that actually could jeopardize or, like, harm the whole system."
  },
  {
    "startTime": "01:22:00",
    "text": "So it's like you compare, like, the the the the the the pros and cons to actually So I want to, like, know your clarification more clear. Like, we why burn and mint is more secure, more preferable than the unlocking column. That's a great question. We're not stating that burn and meant is more secure inherently than block and lock. they have their own security models and depend they depend a lot of on the different implementations. So the trick here is that some bookings, namely, sidechains like Volleygon, they tag their state onto another chain, for example, Ethereum, the way you send tokens to Polygon is doing these lock and lock mechanism. When in the Ethereum you lock, And, actually, on Polygon, you mint. mint. mint. mint. So it's a a hybrid between burn burn mean tan lock and lock. You can burn and mint the tokens in Polygon@will, it will, well, dependent on the rules of the lock and lock. meaning that if you if you exidentally means a lock an asset on Polygon, you can just burn it because it's those rules are embedded in the protocol. Now for blockchains that do not have those rules embedded like Ethereum, You cannot meet a CDM Natively on a bridge. Right? on a bridge use case. But you could meet net you could mean cryptocurrency natively, if it's an ERC 20. So you could have a smart contracts that has these interoperability capabilities, and you can burn and means tokens from within this from the smart contract instead of from the chain. You couldn't do that with if unless there is a hard fork that add support for it, but you could do that with specific assets, you would have to change you would probably have to create a new standard for assets that"
  },
  {
    "startTime": "01:24:02",
    "text": "have those capabilities like Circle. Circle is working on providing that capability for one of their stablecoins. So so this is one of We've been talking about this for 2 years because the problem is there's so many types of networks, blockchains, and we don't know ahead of time what type of mechanism they're gonna use So in in the earlier versions of the draft, we just say disabled. The asset has been disabled, like, because we don't know. Is it gonna be loft is gonna be escrowed permanently like what happens. And and it's this is one of the things that's out of scope for us. We just say, Burning Mid. Disable enabled. Yeah. whatever language is. we we consider it as an implementation detail, let's say. how the asset is disabled. It could be burned or could be locked. the specific the specific mechanism to do that and the logic behind it. is handled by the application that uses the gateway and not by the gateway. So So, yeah, just give me a a comment. So I'm just kinda concerning because Minan burn could affect the circulation of a currency in an ecosystem. So That's right. That's right. Note that one of the preconditions of this group was that there is likely a legal agreement between the two networks for of for how they agree you know, to handle things. And that maybe they fall back to a court system. I don't know. But Claire, Oh, Claire was gonna say the same thing that I did. Okay. say exactly the same thing that is for the participants in for the individual network to deal with. The term we use is is designed separately to the implication on the on the network. And, also, we are actually at the last 5 minutes now just to kind of qualify time slots. Right. Thank you. So that's a very interesting question, and it's I think it gives grounds for lots of discussion. holy. how we handle this?"
  },
  {
    "startTime": "01:26:03",
    "text": "Right. We're finishing. So a quick update on open source implementations, we have relatively stable SATP implementation on hyperledger detect they, It's a bit outdated. meaning that it falling a previous draft. but we were working on updating it. And in parallel, we are implementing Also, I wanna in hyperledger cacti, Rama presented it an alternative implementation in a different programming language that has more decentralized component powered by the previous by the project previously called Weavernow Integrating hyperlogic cacti. All in all, we'll have 2 implementations, 1 in typescript, 1 in Rust, Gret, Greg, Yeah. And these will allow allow the to further test interoperability against gateways. So having multiple implementations is a good idea for robustness. Next steps, to keep working on the error message definition, to find various and defining the various errors across all stages. update the open source implementations, and now I think we have another item, which would be explore the applicability of formal methods 4. not only the crash recovery protocol, but I would say for SATP. as a whole, which we could probably start looking onto it. you. That's it. Do you have any questions? Any final questions? before you go on to the next presentation, Yaron. I looked quickly at the draft, and I think the there needs to be more clarity about the trust the guarantees. for example, the security considerations says that both gateways are trusted."
  },
  {
    "startTime": "01:28:04",
    "text": "and that's sort of meaningless. I think you want to say that both gateways trust one another. And then you use hashes And but you mentioned time stamps. Mhmm. So time stamps should also be secure which I have no idea how to do. But if if one of the gateway plays with the time stamps, I'm sure that there would be a text. So Thank you for that feedback. We we like Actually, that's one of the purposes of the decentralized log storage. So when a gateway creates a log entry, it will sign that log entry and put it onto decentralized log storage. For example, host it in a blockchain so you couldn't easily tamper with this. So you'll have the time stamp recorded on the blockchain, meaning that the gateway might not disclose a different timestamp that the one had that that's on the blockchain. Right? So we try to enforce some non repudiation properties using these decentralized log storage. But I I'm sure we can look onto it in more detail and discover other types of attacks. Thanks for the question. Alright. Thank you. Thanks. Dmitry, did you have one final question? Hey. It's no. No. Not a question. It's basically command based on the previous of one in addition to the trust between 2 gateways it might be helpful to create end to end tunnel, tunnel, Not just rely on TLS or use maybe hybrid encryption HPT to encrypt the whole conversation. it would make it more secure. Yes. I I I believe we have that on the security considerations, but I'm not so sure now if it's on the crash recovery draft or the SATP core."
  },
  {
    "startTime": "01:30:04",
    "text": "Alright. So we are beyond time, so we're gonna move on. And I'm I apologize. I think I was mispronouncing your name. The font on the screen makes your v look like a y on my screen. So Anyway, So Dennis is up next? So hello? Do you hear me okay? No. He's is here. easier. We're good. Yep. Go ahead. So and then this is Aureliones from Compelio, and I'm very excited now that we are a working group I mean, I'm working with the the group before even the formal acceptance as working group. So it's super all the the input that we're getting today. So looking forward to more sessions like that. So the transition this this presentation is also quite well linked with the the previous comment about legal jurisdictions and things like that. So I will start presenting it's a it's a bit of vocabulary here. about assets. So down at the bottom, you might have seen the thing that Claire presented in the beginning. which is the scope of Sat B. So we have the 2 gateways with the 2 networks Okay? There is a okay. We use here a system because it might also have legacy systems behind the gateway. But the idea is that the the asset, the instance is of the assets reside inside the network. So there is an asset issuer, which is a party, that actually creates instances of assets inside the networks. And these instances, they have a ontological link as class instance with what we call an asset profile. So the asset profile is typically the the definition of the class. of a NASA instance. And because we have the this problem of trust, And in general, I mean, the the computation might be dependent on the type of assets. that we are moved. And eventually, we have also"
  },
  {
    "startTime": "01:32:01",
    "text": "legal restrictions and requirements in the different networks. So there should be a party, which is what we call the asset definition authority, that actually gives the the definition of what is a valid asset profile. from which we can derive instances we are an asset issuer that we can if eventually mint on the network. so we can have the gateways transfer these asset instances using a SAP. So if you have any questions, please please mean, I can stop me at any moment. So we can move to the next slide So here, it's an attempt. to somehow put some semantics on what is the the assets be moved between the the different gateways in sub p. As we said before, there is ISO 20 o, 22. okay. There are definitions of the semantics of financial instruments there. However, the purpose of sub p is to move assets from one network to the other. So there are some minimal requirements that we have to define on what could be part of an asset. So in the profile, we have identified some categories as I show here. 1st of all, most important thing is we've done find the asset. So there should be IDs. both on chain and eventually off chain because of maybe having assets that actually leave outside the network typically, if we tokenize, for example, assets, we might be having legacy systems. that actually holds the the real asset. and the assets that we see in the network might be proxies of that asset. So there should be a non chain and off chain eventually identical IDs. And there is definitely also the possibility if we have typically in the financial sector,"
  },
  {
    "startTime": "01:34:02",
    "text": "instruments with ease in codes, and descriptions like the key information document on prospectus that might be things that actually belong to the asset. So we know exactly about what is the asset that we are going to to transfer. Now in terms of computation, we touch upon many things. when we negotiate the claims. potentially. Before Sati, there should be some capabilities that we could define at the level of every asset that has had to do with the constraints and transferability typically burn mint, for example, we should destroy the asset on one network and recreate it on the other. The way that we can trade the asset if the asset could be extinguished or not, if it is taxed or not, for example, other things that we also related to the CBDC use case if there should be collateralized or not on the getting at work. And, of course, there is also law enforcement, so the fact that we can come case, the asset is also an important thing. Now in terms of ownership of the asset, if we take the broad set of roads that actually are part of the business process of creating and and trading assets. We might be having the creator, which is the party that creates the asset, Talking about also getting the requirements from GDPR, for example, there might be processor entities that are different from the creator, So they should be somehow defined as part of the profile. as well as if there is distribution of asset by another party. or custodian of the asset and eventually the definitely the owner of the asset at any point in time. Now in terms of compliance and validity, there is also the fact that assets could be audited So the identity of the auditing the auditing party And eventually, if there is a Time. in the validity of the assets."
  },
  {
    "startTime": "01:36:01",
    "text": "the conditions and the expiration and any sort of evidence about the fact that the audit has been carried out is also important. And, finally, there is also the reference of the jurisdiction either of the owner and the processor or the the creator of the asset. So these are all the kind of information that we we believe should be the minimum to define when we define the profile of the assets. and this is part of the negotiation phase when we start discussing about the transferability of assets in stage 0, as the the other presenters know, mentioned before. So next slide. Just to interject, we've got 4 minutes left. Sorry. Thank you. Yes. Yes. And it's a very short presentation. So Now in terms of the the instance, so we say that the asset profile is class and there is a class instance, ontological connection with the asset that lives inside the instance that lives inside the network. So In terms of what we need to process assets, It's, first of all, they have to have IDs so we can refer to them universally even across networks, They have to have a type. the mustn't be typed. So there has to be a there has to be a explicit reference from the asset instance to the asset profile ID, They have to be trackable. So if us instances move from one network to the other, we should be able to follow the trading. of the asset. So we know that has been typically burned in one network and minted in another network. And there are also some computation restrictions. typically, we have to have a serial serializable stable property the asset. So if we take the definition of the asset instance, let's suppose that this is adjacent. So if we serialize deserialize"
  },
  {
    "startTime": "01:38:02",
    "text": "the the asset, this computation should be stable. So we should not have, you know, typically between the languages floating points that actually make it So the asset instance string example, JSON string can differ. if we serialize or disagreealize. Same thing about persistence. the fact that we persist and we fetch from a persistent storage the the definition of the asset instance, should also be something stable. So we may we we can be sure that if we And as the last property, if we hash, for example, the the asset instance, Also, the caching should be transparent in terms are stable, in terms of any computing language or stack that we might be using. So although we don't impose, of course, any specific format for that. are some interesting RFCs. So the JSON cannibalization schema and as well as the the the signature, the AWS, that could be things that we can using in in for implementing a first version of what is the the asset instance. that reside inside the networks. And, of course, also, Rama mentioned that, is not, we should be able to have a discovery service at some point. Of course, this is out of scope of SATP. But the fact that we can register assets and we can go to a global the discovery service. It might be a very interesting service to have. in the negotiation phase. among gateways. So that's it. terms of my Thank you very much, Dennis. Are there any questions from Dennis? I I will highlight one a chair perspective, The asset profile list has a long set of stuff. One thing that the working group needs to consider in the long runs or which ones of these are helpful versus required? As you know, the IETF has"
  },
  {
    "startTime": "01:40:01",
    "text": "sort of 3 levels may should and must. Must means it absolutely will fail if it's not included, where it should is things could easily go wrong in May is is just help So you should consider, you know, in this list of that. Yogesh. and then we'll quit and shift. Hi. This is Yogesh. My question is about quality of service. Is there any consideration of that at all? For example, say, party a is trying to transfer 100 assets versus party b is transferring 1 how do we prioritize whose transaction goes through Yeah. Actually, it's it's a very good question. This is orthogonal to the definition the assets. So here, it is more touching, you know, going the direction of having some sort of semantics. inside the assets. I believe that such type of considerations should be part of the the the stage 1 in the negotiation between gateways. maybe we could prioritize things. I mean, if we have, you know, bulk transfers or like that. also things like, for instance, long log periods. that's also some part of the quality of service. if you actually keep a look and the transfer remains there. allow for something which is for example, like an optimistic locking. So the first who transfers actually wins and and stuff like that. So all this quality of service is part of the stage 0, stage 1. parts of the protocol. Thank you. Alright. Thank you. So the chairs have silently decided behind the scenes We have 19 minutes left and 35 minutes of presentation material, but the we're into any other business section, So we do wanna dive into actually, that is the wrong 1, isn't it, Thomas. We do wanna dive into the remaining items and our proposal is that we do stick with the ordering that was in the any other business because it seemed to us"
  },
  {
    "startTime": "01:42:05",
    "text": "that the gateway transfer initialization claims in the straight 0 transfer context came up a lot in today's discussions, and that would be good to helpful. but we may not to get to Ramas. But It's the working group's decision. So if you guys have complaints on the chairs decisions in order, we'd like ear that now. Okay. So we'll let Dennis go with stage 0 then according to Thomas's in the room, comment. Thank you very much. -- Thomas Interverteity Actually, the sequence. Right? Yes. So you're on this set of slides of gifts. Perfect. Perfect. So Yeah. Here it's the the famous stage before. I mean okay. So so I have the the freedom of discussing out of scope things here. the the idea of stage 0 is how we establish the link between the eight ways. So this is an example flow of what could potentially happen before set p. So as you see in the diagram, Downly, the bottom will have SAT. So this is what happens before. And when I'm say in the gray, I'm talking about stage 1, 2, 3 as Thomas presented. So here, this one possible flow of how things can happen. The idea is that from the application because we have 3 actually, level. We have the level we have the application, the gateway, and the network. So us in, you know, borrowing the the flows from the older transaction processing theory here. we have the application to application communication. So we initiate atstage0, the whole thing, some p before starting some p sequence. when we have an a client application that goes to Alice once we transfer to Bob."
  },
  {
    "startTime": "01:44:01",
    "text": "So here, I have the client application, Alice. that goes with gateway and say, I would like to have to initiate a transfer. and I would like to send that specific asset to both, for example. So the application goes through the gateway, and gets what we call a transfer context. which is the set of claims basically that we have to negotiating between gateways. And when this transfer context comes from the gateway, so typically signed from the gateway or the gateway knows that it is its own transfer context. The client application goes to the network, the system and says here is binding that you have to do between the context of the transfer for this specific set of assets. for that specific session, transfer session. So The client application then propagates to the remote client, Bob, application, application, this transfer context. And similarly, the Bob application goes to the the network and say, Here is a transfer context. So be prepared to receive assets coming from Network 1 inside network 2. And, also, I mean, in 6 now as as a step number 7, The bob application goes to gateway too and say, This is a specific transfer context that require you to bind yourself as gateway to to the gateway 1. that's where the gateway 2 comes back to gateway 1. So and says, this is me. you are going to go and do the transfer with me now. So that's actually puts together a gateway 1 with gateway too. And because the transfer context was originated by the gateway 1, then we have the we're closing the loop. some sort here. So next slide."
  },
  {
    "startTime": "01:46:00",
    "text": "So if we sit as a set of conditions before winter, Satvee. on the outgoing, the eager side, the gateway one side, the application, the Alice level application, knows that there is a transfer context, where we can put all sets of claims between the the gateway, the assets of Network 1 and we know that this is a well defined set that is going to go to Bob. on the other side to the to the remote application. And in terms of the network, we have a well established link between the They asked the set of assets and the gateway that is going to transfer them. and we know that the 2 gate was our bound, g 1, g 2. Now on the receiver side on the ingress side, The beneficial application knows about Alice, the network knows that it's going to receive. assets from Network 1, and the 2 actually, gateway 2 is bound to gateway 1. So next slide. And this could be an example of what a transfer context is So first of all, we can have a an idea of the transfer context We can have a state the of the transfer. So whether it is active or committed or aborted, for example, And typically making a reference back to the cross recovery from Rafael is that we can have a session ID But eventually, we can have a history of sessions in case that we have recoveries. from other sessions. So we discontinue the session. We create another one, but it's part of the same transfer context. then there are information claims about And the outgoing ingress part and the incoming the ingress part. So we have the idea of the gateway, the idea of the network, the idea of the assets, eventually some expiration,"
  },
  {
    "startTime": "01:48:00",
    "text": "and many other things that might be added as part of the context, and this is still work in progress. And similar thing on the the reception side, on the ingress side. network gateway ID, network 2 ID network 2 IDs, plus eventually assets that should exist also on the other side on network too. And this transfer context concept is the thing that actually puts all the claims together so the the gateways can negotiate before survey starts. So that's it. Thank you, Dennis. Thomas, do you wanna add anything from your perspective and similar agenda item, or you're good? No? Okay. He's good. Perfect. Perfect. then we can give the last 10 minutes to Rama. thank you very much, Dennis, for your presentation, and then we will We might actually almost get done in time. There you go. Those are right. Right? Yep. 20. Oh, yeah. Okay. So I presented a couple of slides. Sorry. A couple of slides here I presented back in the previous IETF as well. So this is just food for thought, and Because the question of using the gateways to query rather than to move assets came up recently. So I just thought would remind the community and, you know, maybe think about it. see few if if this is useful and what parts of this maybe we want to standardize, and we can decide how to expand the scope then whenever the next re chartering comes up. Let's see. I I I Yeah. So you can see the Back up on the left. the first use case there is as a transfer, and that's what the current SATP charter is focusing on But if you look at the architecture draft, we also disrupt 2 other"
  },
  {
    "startTime": "01:50:03",
    "text": "Broad classes of scenarios involving assets in 2 different systems, often, but not just distributed ledger systems. these are asset exchanges, which means which also have have to satisfy the asset property of 2 assets being exchanged are swapped into different networks in the In the bot in blockchain policy, you you may know of it as atomic swaps. that's really what we want to solve here. And but there's also another use case which involves just the ability to query to to locate and query the state of an asset or find out about the state of a business process that's operating on on one laser. from the outside. Thomas, Actually, great. I no. Go ahead. I was just gonna comment on the on the third one, the the data sharing Okay. So just to connect this to what you see on the right, the the classification. There's another way to think about this if you if it's coming from the database world, it's, like, if you have 2 different systems, if you sort of abstract them as databases, asset transfers and asset exchanges involve state updates, simultaneous state updates in 2 different systems so that you need to execute an atomic transaction. So there's a bidirectional dependency between what's happening in the 2 different systems. Data sharing or data transfer is You read something from one one system, and that triggers sort of state update in a in a different system. Okay. Yeah. So so a good example of this just a comment on the third one. So in the in the finance sector, I believe it's called the a counterparty completion risk or something like so so this idea that So Alice is gonna sell her car Ferrari and -- Count about your wrist. Yeah. Yeah. And so the the problem is that both sides are not sure if if one has liquidity, has enough cash, and the other one actually owns a Ferrari."
  },
  {
    "startTime": "01:52:03",
    "text": "So so this is where you have these sort of centralized and market making sort of systems to do the the matching. Right? but in a DeFi world, and I'm looking at well, oh, that go over there. this this may not you know, be be entirely possible. And if it's a DeFi world with, like, private closed networks, then you need this 3rd feature, which is give me evidence of your liquidity. Give me evidence that the owner Ferrari independent of the transaction. This is just in initial dialogue. This is just you know, talking. This is no commitment. And so, in fact, it it might be the the case that that third one that is sharing, is a core part of the the what Dennis is just explain. Right? The the applications are set sending to each other evidences of liquidity and evidences of owning a Ferrari. And in the case that the liquidity network or the Ferrari network you know, is closed. This is this is exactly the model we want is is one side is gonna ask the gateway, say, hey. sign me a give me a signed claim that so and so owns a Ferrari. the other side will say, give me a signed claim that, you know, Alice owns, you know, a $1,000,000. So so the but that's just a comment. Yeah. No. Thanks. Thanks, Larry. And, yeah, I kind of omitted the the main part that Thomas is talking about, which is that data sharing or data transfer is extremely useful or necessary when you have these closed networks. it's not so important in open networks like, you know, anybody can go and query what state of a contact is in Ethereum. But if you have a network that's that requires permission to view it then you need have to have some a pro a protocol like this. So this is just an overview of cross network workflows. So you can have different kind of networks which are running business workflows"
  },
  {
    "startTime": "01:54:03",
    "text": "again, the blockchain problems call the smart contracts. They manage digital assets, and 2 different processes or 2 different smart contracts 2 different networks, maybe interdependent, and therefore, they'll require interlinking in some way. I don't have the slide here now, but in the previous IT, if you had that example of 2 different trade networks that whose processes are intertwined. and therefore, they they would benefit from protocol that allowed the networks to query each other. So any sort of a workflow that spans multiple networks requires some sort of cost network operations, One of them is asset transfer. Clearly, once you decide that an asset must be moved from if we manage our own process in the network, but it now moves needs to move to the domain of a different network and a different business process, At that point, you need asset transfer. But even before that, the business workflow may have other operations to do. It it may need to discover that an asset actually exist in one network. Therefore, it needs to be fashioned to another network, and it also the process and one network needs to query the state of the asset in in one network so it decides whether or not to request for that asset to be moved. There are different things one would like to do. So a core primitive One of the core parameters clearly, that's a transfer. Another we believe is can be very important is the ability query the state of an asset, to query state of the process, managing an asset, from outside the network. And Key thing here is that that network is is pick or it's a it is hidden from view to to external parties. Therefore, the the gateway is only way by which you can actually reach into their network. So just highlighting 1 point here, in addition to having a protocol or data sharing protocol to complement and asset"
  },
  {
    "startTime": "01:56:04",
    "text": "protocol. We need what we need here is proof of evidence a proof for evidence of authenticity of the state because These networks typically are not sync governed by single parties. They are decentralizing networks. visit themselves if you're running a blockchain or a decentralized or distributed ledger, they're running some kind of condensed protocol among themselves. So you cannot actually have some party try to proxy or try to be the spokesperson for any information that that network needs to consume from from the outside. So Some kind of proof is necessary so that it can also be validated by the by the peers running the network. So that is something that we need to take into account. And as Thomas mentioned, the one of the requirements when he's related to the CVTC use cases is the ability to request and find evidence of liquidity in the form of CBTC tokens. So Yeah. 4, 4, 4, to this. Yeah. So this is actually something that we have an implementation of the in fact, the early implementation of this was, like, 3 to 4 years ago. And there are a couple of peer review publications that we we have on this. that talk about how to what it why we need to query a different network for for data? And how do we do it in a way that does not require any trusted intermediary in between the networks. there's an open source implementation of the libraries within happily jack type. So the concept that we are talking about here About 2 minutes. 2 minutes. Okay. it's we call them views. This is a term border from databases. just like in databases, you can define views that allow a client to query for a particular subset of a database and get"
  },
  {
    "startTime": "01:58:01",
    "text": "get something that and get a response which does not which only reveals what the implement or the view allows them to to view. So we sort of borrowed the same borrowed that terminology from the database world. except here, it's about one network or some party external to a network, trying to view something within a network. And and that network is permission. So we need some standardized way of querying that particular network and particular resource that you want to view and then getting a response. So the something that the requestion needs to supply is some sort of descriptor. So the term we use for that is we've used for that is view address And this is outlined in a draft that you'll find listed as a rated draft on the SatP page. As you can see, there is a it has a hierarchical structure. There's a location part, there's a ledger part, and there's a view part. So this is something that we believe if you can standardize this, then we can provide a well defined way for parties to identify resource or a piece of data they want. within a permission ledger and get that back. Modulo, any kind of policy enforcement that the ledgers want to do. This is just some samples from Hippology Act. You can see that few, If you browse the hyper logic act, I get a repository. I won't go into the details here. just last couple of slides. The the highlighted part, the yellow part is what we would like to standardize here. So so the part which involves operations going on within the network, that's outside that'd be outside scope. But the part that the gateway can handle, which is gateway receives a request for a view, and then responds with a view that's something I think we can is a a a meaningful standardization. And in the view request,"
  },
  {
    "startTime": "02:00:02",
    "text": "it must contain a view address, which is also in standardized format. And this is an extrapolation of the previous slide where you have 2 networks. In previous slide, you had Just one network being queried by a an external client, Here you have two networks and So you have a gateway to gateway communication, one gateway queries another gateway with the view address and gets back a you in response. Okay. Fantastic. Thank you, Rima. We are at time. I think today was a fantastic set of of discussions. I think the authors got a lot out of the feedback presented, so thank you everybody. For the identifier thing, we we do need to make sure that we stick with sort of existing standardized ways of labeling bids or URIs or something like that. we can we can work through that as a working group. And thank you to Claire who fixed a bunch of my mistakes silently behind the scenes. It was wonderful to have her remote with multiple screens and handling things in in the background, including timing and everything. else. And thank you everybody for participating. If you haven't signed in yet. Please make sure that you do that before you leave if there's, like, QR code outside the door. and we will see you all in Prague, which is a wonderful city, one of my favorites, and I hope to see you all there. Ship them to player 9. We'll take care of it."
  }
]
