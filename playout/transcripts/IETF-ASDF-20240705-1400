[
  {
    "startTime": "00:00:54",
    "text": "so um we are waiting for Michael at least to join as well my co-chair um uh so welcome everybody who's joined uh we are waiting for uh Michael to join up as well hopefully um I haven't heard from him since yesterday um okay maybe let's get going and then let um uh Michael join um Can somebody take notes if Michael is not here"
  },
  {
    "startTime": "00:02:03",
    "text": "sort of I'm a single threaded person so I can only either talk or take notes um okay let's get going and see what happens if somebody if we get into more technical discussions it would be great if somebody could take some notes okay Ari are you anyone can anyone hear me now yeah I I can try and take some notes for the but I I'm also presenting for a bit so I will be a yeah it would be great if somebody who's not presenting who could take some notes I we can we can sort them out afterwards and complete them but um oh well let's get going so welcome to the second interim of the ASDF working group um uh and uh we are ah okay so s can't take notes carsten can you take notes it would be lovely if you could well I can try to but um I'm going to be discussing things so it's really hard to yeah okay let's see how we work at to I will try to take some paper notes and I'll update the hedg talk afterwards anyway yeah I'm going to do it in the the Shar notes so if other people want to chime in yeah the problem is I can I only have a small screen here so I can't really see Meco plus the other window um right so unfortunately that's not the really good idea but anyway we'll we'll"
  },
  {
    "startTime": "00:04:01",
    "text": "we'll we'll make two um so uh first of all uh this is an ITF meeting here is the not well you are being recorded please be nice and professional and the usual IPR guidelines of the ITF is are applying um here is a longer note well with more detail you have seen it before if you've attended ITF so no news there uh these are the code of conduct guidelines that was added a few years back you know and I think we will live up to them you know be nice to each other basically and be Engineers right um so uh this is where we are when we get to the actual agenda for today and uh we uh first the not well Logistics of the meetings we've just seen uh we have a very short uh working group status update uh we have a short update on the status of SDF uh we'll spend most of the time I think talking about nipy and then we'll spend some time at the end talking about digital Twins and then there are some any other business if there is any other business uh and you sort of need to bash this agenda okay um and and be aware that the kind of the the time I've put to these agenda items was um uh you know they are not set in stone uh they are rough guidelines based on on what we think we would discuss today but um we can be a bit flexible um anyway uh moving on then um with the the working group status"
  },
  {
    "startTime": "00:06:00",
    "text": "update uh we were charted in uh the first Charter in October 20 uh 2020 um with Michael and myself as chairs um we've had uh our first RSC is currently or our first work is is currently um submitted to the isg for publication that's a great progress um we have also since last time have a new Charter and you've seen the chart we don't need to go into details there but it basically covers the work we intend to do now we've also had uh the nipy draft adopted uh and there is a call for adoption out for the digital twin location draft and uh if you haven't already please review that draft and and uh offer uh sort of um review support on the list so we can get that vted as well uh meeting wise we are not meeting in Vancouver in a few weeks time due to people unavailability unfortunately but uh we have uh two interms planned already for September and October and there's also you know we don't need to discuss it right now but we need to um you know we could potentially meet in Dublin uh where hopefully we have more of the core people attending okay um uh with that we move on to to uh the uh next uh step which is an update on SDF Carson I will try to take some notes here right so um as the previous slid said this is submitted to the isg and uh we got an ad review with uh quite a few quite a few useful editorial"
  },
  {
    "startTime": "00:08:00",
    "text": "comments uh we got uh a review uh a genard review from meler Nole uh which also has editorial comments and then we got this absolutely massive set of editorial editorial comments from Susan Harris so there are some 40 comments in this stack and and each of them really makes you think uh because uh there is room for editorial Improvement we probably knew that um all the time but uh up to now this document mostly has been used by people who already had a rough idea what's in there and uh the editorial comments indicate that uh it may be less useful for people who do not already know what's in there um so um I have started working on those uh comments um I think we don't have a chance to to actually um submit MIT a new version uh by internet draft deadline uh but maybe that's also not uh really deadline we have to make because um Franchesca is is uh on a summer vacation I don't know the exact dates and maybe we don't have to have them in the meeting the recorded meeting um but I think we we will most likely um only be able to get uh responses from the reviewers after uh the uh Vancouver meeting uh so I expect to to have the a new draft in time for when the um uh repository reopens on the first day on the Sunday exactly um of the ITF uh meeting but then I don't expect people to actually read that for another week um so uh we will get some some feedback"
  },
  {
    "startTime": "00:10:01",
    "text": "for those addressed comments um by by the first week of August earliest so this this will take its time uh but um I think the comments uh really show that there is uh very little uh discussion about the the actual technical content uh by the reviewers but about the way we are stating it and uh uh again I have worked for on 20 of those 40 comments from Susan and uh the document has really improved uh already so I'm I'm looking forward to doing the other 20 and then uh checking whether all the ones from Franchesca were covered in the requests you already had and checking that malleries were which are kind of parallel to Susan's uh comments are also addressed or need some some additional uh work so that's I think a summary of of the status of the SDF document perfect thanks a lot and and thanks for sort of heading and and addressing the comments right away it's it's great and um yeah okay good to hear that we are moving in the wrong direction even if a bit of extra work was happening at the end here um but it hopefully improves the quality of the document uh yeah and it also might reduce the the amount of interaction we need with the RFC editor at the end if the text is already clear than the RFC Ed will not guess what it might mean which which always takes some additional time uh to to fix so doing this before we we uh publish this to the RFC editor probably is a good idea yeah yeah I guess text clarification is always is always painful on one hand but also good in the"
  },
  {
    "startTime": "00:12:02",
    "text": "when you've done it so okay um but but that's good um any other sort of SDF we don't need to bring it up but there's no other progress on the other SDF drafts right um right right now the the focus is on getting the first document out but there there are several documents that we will need to work on so for instance for nipy we probably want to have an idea of how we do these mapping uh files and uh for the the digital twin work for the SDF location work uh we probably need to have an idea of how we uh do uh both classes and instances um in in this context so uh I think we need to work on some of these documents in the process of working on the documents that um are on this the agenda today okay perfect um thanks any questions before we before we move on so just mentioning you can look at the first PR uh if you want so uh if if you're interested in the editorial uh improvements you can look at the GitHub repository now m okay yeah good I will not try to do it now because then we mess up the sharing but okay good thanks um yeah before we move on if anybody has some other channel to reach out to Michael Richardson other than telegram um you know it would be good if you could ping him um I've done so already on on telegram but"
  },
  {
    "startTime": "00:14:00",
    "text": "yeah right uh then the next part of the agenda is the um uh the nipy discussion and um there's been quite a bit of of enthusiasm or sort of Engagement around the nipy spec and um support and so on so it's great to be able to bring it up here um so I'm now let me share the uh uh the slides um so I think we'll SP spend yeah around 40 minutes or so on on the on this uh primarily to you know where we are right now and where given that we have now adopted the document what sort of what things we need to do to it from a both from a nip of course but also from a kind of ASDF perspective but but uh I uh hand it over to BART to present these slides please go ahead uh thank you Nicholas and um thank you all for the adoption um can I do I have the ability no I I will I will switch the slides I don't dare to hand it over so uh okay so so this is kind of what what we thought we wanted to um talk about today um what hey first of all what do we want to do uh to nipy it or what do we would like to change in nipy itself or update in Ni nipy itself and then um what you know start thinking about what nipy looks like in SDF it's still early days uh you know since the adoption you know most of us have been on vacation so uh but we we do have some ideas already um and then also what we you know we're we're all newbies right is like how do we how do we uh how do we you know one of the questions we have is how do we"
  },
  {
    "startTime": "00:16:00",
    "text": "organize uh is the best way to use you know kind of the mail mailing lists to collaborate or do we organize meetings with you know a smaller group that is you know interested in in in in contributing so so that's kind of those are a questions from that perspective so so from um uh and nipy itself um you know we we have some ideas around improving the draft for readability so um uh this is kind of something that oh uh we we want to do oh maybe we can go can you still go to the previous sorry Nicholas yeah which one want do you want yeah I'll tell you when to move yeah um so so then there's some uh oh yeah this page two sorry yeah so so I I think these are things that we could do you know that the authors can do by themselves um then some discussions and feedback from uh the ASDF working group the mailing list and and some other things that we want to ask the team um we we think we should do some adaptations to um the nomenclature that we use and the API structure so it's closer to what you know uh closer to SDF then obviously we want to you know talk about what nip looks like inside SDF and as I said very much early days this okay now we can go to the next slide Nicholas thank you okay improve the draft readability so so what we as as I said this was kind of our first time and as we built it in retrospect we kind of realized oh you know we could probably improve the readability a little bit so now we have kind of a schema definition with kind of tables in each API call uh and we reference uh API calls that use the same schema we will reference a previously"
  },
  {
    "startTime": "00:18:02",
    "text": "defined API call we think we want to include a schema section up front and then reference that section um and and we were thinking instead of using kind of tables with attributes uh just using Json examples would make it more readable as well um but we we can of see the tables everywhere in in um iatf draft so we're not sure if that's okay but you know we kind of thought okay we'll move the schema out and reference it and then use Json examples everywhere so that that's kind of a um relatively big change from an organizational perspective you want to make and then our draft is about 35 pages but with the open API model it's more it's like 100 pages so we were wondering if it's okay to reference or to to put in a link to a model um I I see like in in SDF for example there's also um uh the model or the SDF model itself is also included so so I'm not sure if that's okay or or if it or if it's okay to to keep the model included in an appendix or or if it should just be referenced I don't I don't know if there's any uh feedback on that um I mean I don't think we have to uh if we don't have to take it away for the I there is no special point in making short short specifications right if it if it as useful we should be there and and I guess that it could be useful to an implementor to have it there right uh I haven't looked into it very deeply but but as I understand links are not okay in in no I mean there is how otherwise"
  },
  {
    "startTime": "00:20:00",
    "text": "we would have to now make another document with the model in it so it may be better to put it here so okay just leave it and because of if you want to make this a specification you want to have everything you know it's implementable right in place okay then we leave it in so so I think if if the group is okay with this then I I suggest that over the next few weeks the uh we will make those changes to make the the the draft more readable and you know if there's any other if if people are reading through it and saying oh you know this is not well organized or I would change this please let us know so I think that's section one yeah any other comments to this carsten Michael well open API is not exactly known to to generate compact um specifications correct model um open API is designed to be used by tools you never actually look at an open eye uh specification and um there's extreme amounts of redundancy um in that thing um so uh usually when I try to read something like this I I write a small tool that that compresses that redundancy um so um maybe we can think about a way to to do this yl has some some built-in mechanisms to deal with redundancy maybe these are uh good enough so we uh get a a bit better uh view on on the the the actual content that is hidden in those uh incredible numbers of pages um the the other observation just for people who want to use this uh uh document uh when you look at the the plain text version then then of course"
  },
  {
    "startTime": "00:22:00",
    "text": "you have all these these page headings uh in the way um but if you look at the XML you can extract um the the open API with a very simple command um so uh you can get the the actual file that that is hidden here in in the document uh using that command and and can work on that so I would recommend that we put some some a few words on how to do this in in the document like we have done in other uh documents that have had models in them okay do you have an example of such a document that has a model in it like yeah RSC 1952 uh would be one example but maybe I can dig out a few more examples so you can choose for how to exactly do this okay thank you K right any any other comments all right next slide then Nicholas yes um then some of the discussion and we'll start with h what wter and and Kon brought up was basically the pubsub API format um which is currently protuff and I think there was a proposal to use Json plus CBO now I'll start with why um we selected protu right and I think we have two two I mean there were two reasons I think I think One Good Reason one reason from a standards perspective and another reason more from a practicality perspective um I think we picked protuff a because you know the the data is binary protuff is binary and and also as I think Carston pointed out like"
  },
  {
    "startTime": "00:24:00",
    "text": "protobuf is used um quite a bit between um systems that are affiliated right so hence we you know when when we implemented um this we used protobuf internally and obviously if you're dealing with a very large amount of data then you know if you have to do re-encoding it it obviously is performance impacting Uh I that the latter is not a good reason kind of from a standards perspective so I I kind of I see I definitely see your point from a Json plus CBO perspective that that's more internet friendly so um you know I'm not I'm not uh opposed to uh to adopting that um I think from a uh an implementation P it may it may be interesting to have both um you know the because obviously protoo may be um better from a performance perspective well the the real issue about protuff is that you need to do the Version Control on both sides uh and that's inherently problematic you don't have the problem with Json and or cabore MH yeah so the the Practical problem is that you you need to ship new software to both sides of the communication each time this uh Portu file changes uh and that has been a problem in Internet style applications it's not a problem if you control both sides of the uh communication and in particular control when a new version is being installed but um if they develop"
  },
  {
    "startTime": "00:26:00",
    "text": "independently from each other then uh you get the problem that vter was referring to um the reason I I raised my hand here uh actually was that uh we don't have to nail this down exactly now um so I think we can do a little bit more work on the architecture uh and understand how we want to to handle uh the the various uh communication relationships uh before we return to the question how we we actually um represent the information on the wire I think the discussion it's useful to to keep in mind that we will have a discussion on this uh but I'm not sure that we actually have to decide today all right [Music] um so what's the what do you think are the next steps here I think uh I mean we can we can certainly prototype this but as you said if we change the API structure quite a bit it may be U interesting to focus on that first well is this uh pep shop data API is that completely different than the open API or is it more or less modeled the same uh honestly I like mqdt to use for these kind of things going Upstream because it's basically all major uh uh standards that I know have adopted in some way or form so it would be nice that we can use our or reuse something that already"
  },
  {
    "startTime": "00:28:03",
    "text": "bit uh or that we Define something that somebody else can latch into uh it has both things but I don't know if it's designed in the same way yeah right now it's it's designed to be protu uh over mqtt right so um obviously you're using the same data uh formats for open API as well uh no yeah the op open open API is all Json based so yeah it's not prot okay why would that be so much different um the because because the the is basically streamed over protuff right versus Jason versus the the uh the um the restful interface you know I mean the the the schema for that is typically Json right plus we for on boarding we use Kim which is also already Json based so um we continue but mt5 Al has a client server approach so you could use exactly the same I'm sorry uh water I didn't get M mq5 has also a client server approach like open API so you could ex use exactly the same ah you you mean a request response interface yeah yeah yeah yeah um no I mean because we we started from skim which was basically uh um a restful interface so we also uh um"
  },
  {
    "startTime": "00:30:04",
    "text": "built nipy in the same way and then as we um needed a streaming interface we leveraged mqtt for that it maybe we're not getting to a conclusion here right I I uh I mean obviously there are pros and cons with using protuff uh and Jason and seore here but if we can maybe as carsten suggested wait with that decision PT it a bit into the Future [Music] Okay and maybe have sort of I don't know what we would we be depending on but is maybe not we don't have to decide it right right away now um yeah I think it it would be useful to actually write a little bit of code that demon rates the various approaches so we we can compare how they they fit together and but of course you have written code so so it's it's not your doing that it's it's the turn of the other people to look at this and and see what what kind of code we would be coming up with yeah we we do have some open source code already available on this um I'll I have the link in another slide but um yeah we can we can uh we can try we can write some code on the Json plus cboard approach as well great yeah great perfect um then then there is some binary data in so so so I was kind of asking you know if we do Json on Cort on the pub sub do we on our restful interface also look at Cabo then for binary data but I"
  },
  {
    "startTime": "00:32:02",
    "text": "guess I don't think we have to have that discussion now there's a in the in our uh read in our read write apis there is some some binary data that we ch um well you can easily convert Json and C bar both ways yes uh so it's it's it's it's almost trivial yeah that's what I that's what I would think as well um then from uh so so there's some we we Define some protocoling extensions here for uh non IP um Wireless St standards we've currently defined BL and zigby but there are others right so the question is uh how do we deal with that um you know do we Define some others we Define B and zigby because those are the ones that you know we were primarily interested in but obviously um there's others as well and and um do we make that extendable is that something that goes into an Ayana registry that's kind of one of the the questions we have as well and and if there's anybody interested in in helping with other extensions obviously that's also uh interesting to us so as an architectural principle of course I would prefer the the various ecosystems to be plugable um I also think that in the end Anna registry gives you a very good way to have different organizations doing this plugging uh so we we don't have to do all all the work uh in in this working group so some Industry Group could uh come in and say how to do this with Conex or some some other"
  },
  {
    "startTime": "00:34:02",
    "text": "mechanism um so I think the the architecture issue here really is um are the those various pluga bles completely independent of each other or do we do we actually see some commonality that that we would like to reflect in how the protocol works yeah we we um I think what we tried TR to Define in in nipy is all the all the commonalities we've we've put in in the API in the schema itself and then and then we've defined Json objects for you know uh pluggable uh Wireless Technologies so so I think that's already there so so I think I think it's already extendable yeah goal is to talk to those devices directly right correct yeah so how much of the protocol itself is in the API or is that abstracted somehow so how much do you need to know for BL to use this from IP versus uh using the same thing from zigby yeah so so this is you basically do operations on attributes right so we Define an attribute in the API and then the attribute is linked to a protocol extension which defines the attribute in that protocol right so so all the operations happens happens on happen on attributes and the attribute is either something you can read write or something that you can stream for example but then there's an extension that kind of defines that what that attribute looks like in BL so"
  },
  {
    "startTime": "00:36:02",
    "text": "so you do all the operations on an attribute and then um you know as defined in the API and then the extension um is the actual thing that you operate on uh so you have a common set of attributes between BL and zigby or are they all dis disjunct yeah no it's it's a you name the attribute right so so so it's an attribute and then you can do you can do operations on those attributes that are common right and then um but the and the attribute um uh is defined by an extension so the attributes are not common across uh Technologies so to speak no there is a there is a definition of an in the schema there's an attribute yeah and then you register an attribute to be you know this BL extension so for so so actually so so you'll say for example attribute temperature is blle service characteristic uh sorry service and characteristic this right or zigby you know this zigby attribute right so and then you do your operations on temp temperature okay so you do have a set of common there is an attribute common attribute temperature that then maps to both and okay but using different underlying extensions okay yeah yeah so the the proxy on BL and ZB should really know their own network in what's there and represent that on attribute level which basically is uh well could be an SDF object"
  },
  {
    "startTime": "00:38:04",
    "text": "right yeah yeah and when we get to that section I think I think the attribute Maps very well to an SDF property right and and uh so then we just need an extension to to define or we need to be able to get the b or the zigby extension in there to say this attribute is this right so that um you can actually do a nipy operation on it so yeah but I have some slides on that um yeah I I I realized we're actually talking a bit too much and not getting as far as I I missed sorry yeah no no problem but but um let let's walk through this and and um uh see where it takes us okay so then then we've got some API extensions as well I think we could cover that later probably also but I think we probably will need um maybe so this allows you to um to uh kind of take some or or take some a combine some apis like to to to execute some bulk apis we've we've defined a bulk API but you know uh you can make your own um Extensions by combining multiple multiple API calls into a single API call as well um and then I think the last one we could we we can just do um we can simplify we we in in draft uh one we have uh a binding and a and a connection API and I think we can subsume that into a single API so these are these are changes that we could just make if the group is okay with it okay Nicholas next slide yes there you go so um you know kind of"
  },
  {
    "startTime": "00:40:01",
    "text": "from a a an like a how we would use this perspective um this is this is what we have skim plus nipy so we've got the the schim on boarding API and we have the nipy operations from an application against the nipy gateway then the nipy Gateway talks to the thing right over a either a b or a zigby network um we we already have a library it's in Python and Java it's available um for for those so that you can in embed that in your application and and use the library instead of the apis um directly so all of this kind of stays at the connectivity level so if we think at of next slide maybe Nicholas how we would kind of integrate SDF we're kind of thinking okay there's another library that sits on top of that that understands SDF and that you know kind of maps into the skim plus nipy library and can basically take an FD SDF model right and then um uh based on the SDF definition the extensions that we put put in that SDF definition it can call uh uh skim and nipy uh apis so the the the delineation there is that skim and nipy are all about connectivity so they don't understand the application context so they they don't understand that uh uh what is what the function of the of the thing is they just understand you know the the the connectivity it has and then and then SDF has the application context and we have to make the obviously the goal is now how do we make the link the link between the"
  },
  {
    "startTime": "00:42:02",
    "text": "two um next next Slide the Nicholas so so this is kind of what we have so SDF has a model with an SDF thing object properties events actions and then in nipy we have a a skim device object that device object is nowhere near what an SDF um object or an SDF thing is because it really just includes a device uh information about how you on board the device so it's a device ID and um some you know keying material you may need uh it does have um BL zigby Wi-Fi you know other radio extensions with with potential keying material you need to onboard the device but you don't it doesn't have much more information in there and then there's NY operations there's Reg registrations attributes pop sub topics and files if you want to send the file to a device file is basically you know a different version of an attribute these registrations are obviously very similar to uh you know you you you register an a property of a device so it's very similar to an SDF property and the operations are obviously very similar to or or our you know SDF um SDF um actions and then and you know obviously the pub sub uh uh topics are are very similar to SDF events so next slide if we next slide Nicholas if we look kind of look at how we would map this then um you know our SDF properties um could be um attributes subscriptions broadcasts or files or connections so a device can have a connection it can have several you know"
  },
  {
    "startTime": "00:44:01",
    "text": "attributes you know or properties like like temperature for example um uh so so that all all these attributes subcriptions broadcast files connections they map very well into SDF properties on the skim side um you know the the the attributes that the device had have also map into U properties um the actions are mainly are pretty much from a nipy perspective a get put a post to delete on a property right and then and then from an event perspective currently we've defined the the the um pubs up interface has currently defined three events uh connection br broadcast U and subscription so it kind of fits under the if you look at layer number three here the properties the event and the actions I think the the all the nipy operations kind of um fit well under those so um next slide so so the thought is kind of I don't know if this is a kind of a good approach but if there's a uh I see that the the quality the data quality uh in the SDF spec are extendable there's also an ay registry there and I'm wondering if it's if if what we do is um we we put the extension so if we Define a nipy pro or an attribute like temperature as a um as a uh a BL service and characteristic right is is a is there"
  },
  {
    "startTime": "00:46:00",
    "text": "some uh is there a new quality for example nipy property right we can add uh uh which is of which is a Json object that includes that extension because once we have if we if we Define temperature like this right we can uh obviously do we we we basically know that it that we're talking to a BL device if we want to read temperature we have to read this service ID and this characteristic idid um we have to read um or we can or or or write it and so forth um properties being readable and writable and and so forth we can we can all discover so so I'm thinking maybe something something like this uh could could be the integration just for my understanding the Char St jistic ID that denotes the temperature and the service ID is then something on the Gateway that denotes which device it is or which yeah this is this is how on the device it is yeah yeah um um like service ID is basically a grouping of characteristics so um but but zigg will have a different way of of getting to a property right so so it it'll be so that's why it it's inside the BL extension because it is BL specific so but you can have multiple BL devices exposing a temperature uh do you describe this then just for a temperature or do you describe it for a temperature and where it can be reached yeah this this is so so this describes temperature and and in in the"
  },
  {
    "startTime": "00:48:03",
    "text": "definition of this thing right where you can find the temperature on on on on BL yeah okay but how would that work with your first diagram in how you want to marry SDF with uh the scheme because the scheme is basically the addressing and the SDF is done just the temperature so skim skim doesn't um expose any Char any Properties or skim doesn't include any properties of the device other than the device identity itself so um you know SDF is much more descriptive from that perspective and and and skim SK doesn't describe a a a Dev a thing right it describe it it basically gives information uh about a specific device yes so just looking at the architecture would it be possible to add something to skim to uh carry an SDF quality of SDF uh device description because then you solve the problem and then you solve it actually at the the the proxy level because the proxy uh if you if you are doing the BL side you know which device is the well which which device is where and also which device does what and uh I think you should marry that in the proxy and not within the"
  },
  {
    "startTime": "00:50:02",
    "text": "client so we we have several dimensions in in which we need to discuss this we we have the dimension where we add ecosystem specific information and this is the red stuff on on this slide and we we have a draft called the the SDF mapping draft that is meant uh to provide one way of doing this and I would expect we come up with a nipy more nipy native way of doing this so this is about uh managing a herd of devices that belong to a number of classes and then the the other thing is that there are actual devices that the the instances and we need things like addresses and so on and and skim is currently set up to uh manage some of that information and I think we need to find a way how to to merge the the skim managed information with any other instance information that we may uh need uh to manage yeah yes like SDF doesn't carry information about a specific device it just is carries information about a type of like a a type of device and skim carries information about a specific device right I think that's well that's well maybe something has changed but SDF was always meant to if you have an instantiation that it carries the data of a specific device C maybe that has changed over the time I don't know I'm not sure I thought what you said is still right um but I think we need to"
  },
  {
    "startTime": "00:52:01",
    "text": "to uh map this into the actual architectural concepts of how we are using npy yeah yeah I I I would really like to explore a little bit about the schem in how we can uh use that to uh because uh can you go back three slides or so yeah this one so the nip nipy Gateway that has the on the on the non IP network side has all the information about what that thing is because it needs to know that otherwise it can't talk to that network uh uh and can't talk to that device so from my point of view the nipy Gateway should have some information about what it is representing that through SDF and maybe uh where you can find it to skim so so what that can be a problem because like there's for example use cases in healthcare where you're dealing with you know patient data you know being sent over these interfaces and you know you want to keep the that context of what that is like for example the the this characteristic is a heart rate right you you don't really want that in the network you only want that in the application but then that thing doesn't know that it's an heart rate either right that yeah the thing doesn't know that it's a the only the only but yeah the the the the the only um entity that should know that it's a heart rate is the application yeah but so uh I would say"
  },
  {
    "startTime": "00:54:03",
    "text": "then that's just a stream of data and it's being classified correct as a stream of data and uh I'm not even sure if SDF in application would help there because at that moment in time you should start marrying what well you could specify an SDF thing as an heart rate but it it comes later in play so most of the things that I see now uh and I'm coming from a completely different angle than uh uh Healthcare um I would put as much as we can in that nipy Gateway because then you don't have to carry that and marry that later so I think marrying it up to some scheme identifier of what it is uh basically that means that there is an additional relationship in what a thing exposes through nipy uh what that scheme identifier means that you can marate up so what is uh well probably there should be some information in going into the thing that you can marry it up later with an SDF Library [Music] um guys we are unfortunately we only have five minutes left of this meeting and uh this is a I think we're it's a very inter interesting discussion but we won't be able to finish it um I would suggest that we actually take we have interims planned but I don't know if you could plan for a design team meeting uh you asked B before how to sort of how to organize this work at the sign team meeting discussing about these things like you just discussed about nipy and and and skim and so"
  },
  {
    "startTime": "00:56:02",
    "text": "on um would that make sense that would be great lter Carston are you fine with that sure um I would say after Vancouver meeting but not that long after Vancouver meeting we'll try to find a date okay and then you organize that Nicholas or or I we will we will try to set yeah we will figure out the day yes okay I will put it together okay good uh thanks a lot and thanks for discussion I've taken some notes uh please review me afterwards if I got something wrong um let me then so sorry we have only a few minutes left but since y Yong actually did some stuff I would like like to give her uh five minutes to present this okay thank you hello everyone I me my name is H and the pr can't pronounce my name H jangi and I'll have a very short talk for the document titled SF for dig in this version We describe the SF location in SF model in figure one next slide please we have eight the SDF location in SDF model the SDF location is described using GPS coordinates or poster address for physical locations which enable extensive reuse and interoperability and also described by strings or integers for relative locations next slide please yes we have added the s SF location SF model as shown in figure one with the boat model where"
  },
  {
    "startTime": "00:58:01",
    "text": "there is a heater in the boat as shown in the figure one we proposed to add stdf location to stf model at the level of stdf property stf action and stf event then stf location can describe the location of stf thing and stf object next slide please uh this slide can be skipped because it was already presented last meeting and the next yes conclusions in this verion we propos to add SF location to SF model at the level of SF property action and event more information to represent an object as a digital twin the requirements of the SF model for the digital twin and the detailed figure one as the figure two in s main document will be described uh I think the time step can be added to AEP location to indicate the duration also I hope that the document will be adopted as a working gr document that's all thank you okay thank you for that very quick presentation and again sorry for for for for squeezing your time any um any comments or questions though um we still need people we still need to adopt this documents P review and have have you know have a think um about it but uh any comments or or questions to Y okay so if you have any sort of additional thoughts about this let let's take it to the list and we will decide how to to move forward with this if we need some uh yeah how it's best integrated into"
  },
  {
    "startTime": "01:00:00",
    "text": "the sort of the overall um SDF framework um with that um that was actually quicker than I thought we are actually out of time I will um uh call for a meeting to um uh I will call for a design team meeting which is not an a formal interim uh try to find some date after Vancouver um if if if if we can't find another date then may might be that we'll have to um wait until the next interim but then we take it to next interim in in September given that we now have vacations and summer and so on in various areas okay uh any final comments questions by anybody if not uh thanks a lot and thank you to presenters for doing quick presentations and so on and thanks for a good discussion so uh and let's talk to you again in a few weeks time take care cheers thank you bless byebye bye"
  }
]
