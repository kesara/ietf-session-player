[
  {
    "startTime": "00:00:08",
    "text": "From Yeah. Okay. Let's keep going. Welcome everyone. To the second session of a or artwork group. So, first thanks to, Hannes and George for taking notes for us this time. Yeah. Thank you guys. Appreciate that. This is an oil. Again, this governs everything that we do at the ETFs. So Please make sure and and to familiarize yourself with this. If you're not familiar with this, really important to to know what this means. Please use the meet echo to sign in here to allow us to know how many people are in the room. This allows us to kind of plan for future meetings and make sure we have room big enough to to host us. So and also it allows you to"
  },
  {
    "startTime": "00:02:00",
    "text": "that allows you to get in the queue and and have comments and questions. Okay. So here's our schedule for today. We have a packed agenda. So let's keep going very quickly. So Mike and Aaron will talking about protected resources metadata. And Oliver and Daniel will be talking about SDJOT VC. Paul will be talking about attestation based client authentication. And with the given us an update about browser based apps. Peter will be talking about cross device flows and Paul will, wrap it up with OAuth's status list. Any questions about the agenda, any bashing here? If not, Let's get going. Okay. Hello. I'm Mike Jones, and my partner in crime in this venture is Aaron Precki. Next. I don't think I don't know if it works. Okay. So quick recap on what this specific is for this is the now called resource server metadata, previously combined with authorization server discovery. The point of this though is for clients, like, for example, mail apps or calendar apps, specifically, those are good examples because they don't have their own relationship with an oauth or authorization server"
  },
  {
    "startTime": "00:04:02",
    "text": "the whole point of those apps is that you can use whatever account you want with them, that application. So usually the way these work is first thing you do when you set up the application, is you actually tell it what server you want it to go and talk to. And, currently, the user experience of that varies pretty differently depending on the application being used. In the case of this screenshot from the apple I believe that's in the settings app in Apple you enter the server address of your mail server, and then it does things. Sometimes it asks you for a password, sometimes it asks you for go off log in or whatever. The point of this is to have a standard way to do an OAuth flow for these applications because currently, most of the time, they are asking for a password for this, which is not good for a number of reasons and not possible in some servers that have decided to turn that off and force you into an actual LOS flow. It is not advanced. It's not Okay. So what's happened since we last met our heroes in San Francisco? We got working group feedback and reviews on the document. We incorporated that. And after that, Let's see. We addressed many comments when we published the 01 draft. And if you're interested in the issues that we addressed, you can view the set of closed issues in GitHub. Next. Okay. There's only 2 open questions we know of. About about about the draft."
  },
  {
    "startTime": "00:06:01",
    "text": "I'll take the first one. Should the WWW Kate, Kate response, return the resource identifier or possibly a resource metadata URL that might clip that well known path built into it. Currently, it returns the resource identifier, which is the was the original design. I'll note that, a fairly recent OAuthRFC, resource indicators draft that has the resource equals identifier, does use the resource identifier as the resource value. So unless people really wanna make a case that we should do something different, I think we'll do the same thing. The I was hoping we had an example of this in the slide type. It looks like we don't. Unfortunately. So also just use your imagination to picture what that looks like. The the main difference between those 2 being the resource identifier is just like the URL that identifies the resource server the resource metadata URL is built on top of that. So using that dotwellknown construct that we use for a lot of other parts of, like, authorization server metadata is a handful of other things that we use if we're we would the the client would have to construct the URL for the metadata based on just that base URL. Which is related, but a slightly different question from the second question. I guess, George, you wanna say something about that first point. Yeah. K. K. So if I remember correctly, when we were going through the resource fire, resource indicators draft, the resource indicator itself can be logical."
  },
  {
    "startTime": "00:08:04",
    "text": "So it doesn't have to be a your array to something. It could be a And in that context, would that make it more difficult for someone to find the stuff they're looking for. So is there value in basically specifying that this thing and the wwwdash authenticate should be a pointer to actual metadata, like the full your URL to it rather than a potential logical indicator, which is what's allowed in the RC I should look at resource indicators again. I thought that that was a URL to the resource. URI. Partly because I was hard Okay. Justin Richard. All of the problems that George just listed, plus the fact that you're actually not supposed to do a dot well known on anything that has a path already No. There is a defined way to do it, and the AS metadata says it. That do That's fair. That's also a little odd. How it's done. And I realized that 3, you know, we don't wanna make Mark nodding him mad. But, For both of these reasons, sort of the the weird quirks in composition, which are quite possible to get wrong plus the, the logical identifier that is not vegetable URL. I would returning both under separate keys. But with the caveat that if we allow that, then we have to be very clear about what the relationship between those has to be. Which is actually related to the second point on the slide here in in in it's pretty much the same underlying issue. So with that in mind,"
  },
  {
    "startTime": "00:10:01",
    "text": "I say we allow both. I don't know what the requirement would be for 1 requiring one versus the other for interop sake, I lean towards URL because I would know that that's fetchable, but That's not gonna be universal. The other, the argument I can see for returning the oral is that, like you said, with, possibility of a URN or the possibility of getting the path construction wrong, returning the dub up of authenticate header is kind of the way to skirt all those issues if the value of it is the URL of metadata. And you kinda avoid all the issues in the first place. And that would be the reason to use it as opposed to not use it and assume the client can just find the metadata. Because if we're talking about, like, you punch in a URL to this client, and the client has 2 options. 1, it can just try to find the metadata if it knows the dot well known act, which might work or it could fetch that URL and get a dub to them authenticate header header back, which would then have the actual path. To the metadata, which could then could be whatever. So that that act that feels like it gives the w l authenticate header a reason to exist. Instead of just it being like, a nice thing. I I think there's actually a cogent argument for both because the logical identifier if the resource indicator is the logical identifier, then that may have meaning to the client beyond just the metadata location. And if the other is this is the metadata location regardless what the logical identifier is then you know, we're we're very clear as to what each of the means and what you're supposed to do with What's unclear is the relationship between them, which is exactly the state that got us into the, AS mix up attack space with AS discovery documents in the first place. So we have to be careful there, but I think that there is a coach in I meant for both."
  },
  {
    "startTime": "00:12:02",
    "text": "Felix Kogan Octa here, we do like the fact that the resource indicators allow allows a or, sorry, a URI. But I don't think that's applicable here because of the nature of the use case that you explained where you enter a random not another random arguably, a URL to explore the server you wanna talk to, and I think that when you hit a when you hit a resource, if The w w authenticate gave you or URI, there's no way to resolve that to the well known, by the way, we already made Mark unhappy in open ID foundation because the discovery, 1.0 in open ID behaves not conform while the 1 This is RC, 8414. For all does this correctly when you have path included. So we should definitely be very explicit about you know, what we reference in, in this way. I was actually thinking that is it should just return the URL, to its well known document. And you may discover the the resource value to use in that document. So either you return both of them at the same time or you discover it. And I think that leads to the second question as well. However, because of the dynamic nature of this, I don't think that returning a UR I should be allowed altogether. Because I would assume the URI something that you would have to pre register. With an issuer. Whereas the URL allows for the dynamic, the the dynamic nature of this. Good argument. Thank you. Brian, It just sort of following up on both. So the resource indicators does allow URI, but it doesn't necessarily mean it needs to be a lot more here. Certainly, could be constrained via URL. It probably would be"
  },
  {
    "startTime": "00:14:01",
    "text": "the deployment models, the URI was kinda more for, like you said, pre pre configured kind of ways to identify a resource or group services and so forth. So I don't know if that's it. The the idea of returning the full Tom, Yeah. URI telemeditated itself is, I think, compelling, but clients aren't the only one. The idea with well known is clients aren't the only one that are maybe looking to discover this as we 30s cases for and he has to figure it out. So not quite sure how to reconcile that. N just lastly on the well known path construction, this the way it's done in here, I think makes a lot of sense for how it's works and what people's expectations would be, but it does run counter to what the naughty hands, etcetera, would would wanna see. And I'm I'm concerned that we're sort of setting ourselves up for another you know, deployment where this where the sort of what makes sense and works that we have now it gets used and deployed, and then we hit feedback and IST review that forces a change that's really nasty. And and causes you know, variance and incompatibility issues. I don't know what to do because I like what it does now, but I'm I'm worried about the the future state of progressing a draft. So, Brian, you obliquely pointed out that Other parties, then the client might also use this metadata. One of the things we explicitly did for this latest published draft was address your comment Yeah. Saying that the server might also use the metadata to the Mark Nottingham point for better or for worse, it already uses the language like AS metadata where it puts the path at the end of the well known"
  },
  {
    "startTime": "00:16:00",
    "text": "so that the well known is already in the root. I don't like that either. I've yeah. That's what the draft does. I was rather than we we can both read it again, but having fought that fought and lost for AS metadata, I'd didn't try to win it. Again, especially given I've had side conversations with Mark on this topic in the last 6 months and Mark, nottingham's point of view is The web security model is based on what's what's the use case? Not there's a web origin. It's when web origins. Now I I do note that cookies can include paths, so that's not strictly true, but for the most part, he's right. Perman? Hi, Roman didn't use AD. If we're trying to reduce ISG prize. One of the things we could do is hit. I was just checking the review records that we could It sounds like we could ask the HTTP director it for an earlier review on this specific mechanism. And so if you had a clean review from that director when it comes to the ISG. I think that they might find it difficult to suggest something contrary to the director or review or perhaps they're gonna That's okay. You can ask now. Yeah. But we could definitely do that. That that's fine. It's it's Brian, you're still in the queue, or are you done? Okay, Neil. This is Neil Jenkins Fastmail. Just a few thoughts on this. Firstly, the URL, I think, will be a lot easier from our perspective than trying to back up slightly."
  },
  {
    "startTime": "00:18:00",
    "text": "This kind of thing is really interesting to us. And last week, we got a group of lot of the big email providers and various other clients together to try and work on a profile, if you like, a flow that uses just the existing or drafts to actually make dynamic client restoration work so you can do this sort of thing connecting to your contacts or kind of stuff. Because at the moment, no one does this. It's not there. So this kind of thing is obviously very relevant to that. I think, yes, firstly being able to return the URL directly to the resource metadata is gonna be a lot easier for people to used and on stand than the other alternative. Secondly, I've looked through that this draft and I can't anything about how you find what scope you need. To get these because that's obviously really important. We have some thoughts on on that. We're looking up, but one of those meant to be anything related to this. And then I have something on the next question, but I think you haven't got to that yet. So I'll maybe wait. So to the scope, question, which is a good one. OAuth Corps 6749. Does say that WWW authenticate can return the scope that you need to do an operation, and you can have multiple things in WW with Medicaid. So it's a building block. We're not touching that part of it. Okay. Great. Do we really not mention scope at all in the draft? Cause I thought we had a sentence about it somewhere. I only skimmed it, but I couldn't see anything about saying that. I would be useful. The devil authenticate header can return scopes. We should at least mention that part in the draft. Along with And an example. The developer authenticate header that's in this draft or at least put it in the example the The scope problem is a hard problem because you almost need scopes to be interoperable for the use case you're talking about, which is a different problem. As well. There is in the draft about scopes is there's a scope supported meditative value."
  },
  {
    "startTime": "00:20:02",
    "text": "Which, by the way, we changed the name as a result of feedback to match the name in the AS metadata. So when you fetch the metadata, you can see that at least a subset publicly published scope values that are supported. And if those are meaningful to you, you use them. K. Just one second here. We have 4 minutes and you still have few slides and you have few people in that in the queue. So let's let's I think this is actually the last slide we care about. Okay. So so let's let's get Brian Okay. Brian, Brian? Oh, he's okay. Some Thanks. So as as a data point, solid project does use something very similar mechanism. So returns a dub dub, authenticate response header, except it instead of the level of interaction, of pointing to the resource and then constructing the AS metadata it links to the AS server directly. So I was just wondering what, apologize if this was already discussed, but what's the reason against doing that? That is how this started. With the other draft that I had written, which was authenticate header points is at AS. I believe there were arguments around I can't remember the exact arguments, but it should be captured somewhere either in previous meetings or in issues. And it made more sense to do the to point to the metadata, which can then point to the AS. The RS metadata can point to the AS in that document. In particular, it's a set of a s's in general that your your resource might say I can work with a, b, or c."
  },
  {
    "startTime": "00:22:01",
    "text": "And then it's up to the client. Would you consider an optional mechanism for a preferred AS just to skip on the extra HTTP call. It's an interesting question. Let's discuss that. Yeah, so just in the last yeah, on on the list. Just click on bullet tiers and certainly have 2 minutes left. The the main question here. Nope. Is Let's assume that we've now decided that the full URL is returned in that authentication header. What happens if you make request to example.com, for the resource, and that returns the authenticate header with a meditate a document that's at a completely different hosting, example.org. Is it okay? Does it is it bad? Does it let you do interesting things that are good? Does it enable interesting things that are bad? At the very least, I think the that you would need a kind of, like, backlink, like, the metadata document should say this is a metadata document for example.com, so that you can do that, that bidirectional confirmation. So this is an open question, We don't have any time here to discuss it, but this is if you have any thoughts about this, be another good one to chime in on. Both of these are open issues on the GitHub repository. So feel free to go there to, to find those links or just on the mailing list is Lawson. I think that's it. Okay. So at least as we saw it a couple days ago when we made the slides, the next steps for this draft or to resolve open issues. And if it looks like we're in a good place with working group consensus, asked for working group last call, but it sounds like to me, you can double check me that we take a pass at returning the metadata path directly"
  },
  {
    "startTime": "00:24:00",
    "text": "see what that looks out. Try to write security considerations. A normative text for the latter point. And take it from there. Does that Sound right to people in the room. Yeah. That that sounds reasonable for sure. Okay? Great. Clear client question is the intent to do that in lieu of source identifier or in addition to. What what is your intent for this next next stab. I would put the resource identifier in the metadata at that point, Go ahead. You're you're straight to convince us otherwise. I'm I was just wondering what the editor's intent was for this thing. That's what I would do because more is sometimes more. Mike, thank you. And Thank you. Aaron, thank you. Okay. Oliver, Daniel. Yeah. Hello, everybody. Alibaba and, going to talk about STHR is very focused today, together with Tania Fets, Next one. Yeah. 1st of all, a quick recap on SD chat based there of our credentials. So it defines a profile of SD chart, for very follow credentials. Similar to an AD token that defines a profile, of charts, in And, the spec itself also defines data formats video types, for variable credentials based on SD charts. Using JSON payloads. So it's not RDF based. It doesn't use JSON ID. And on top of that, it defines, validation rules and processing for verifiers. And totals of, verify credentials based on SD charts."
  },
  {
    "startTime": "00:26:02",
    "text": "And it's also possible to use this with, non disclosable, nonselective disclosable, shots, 2. Thanks. And this is useful in the, so card issue a whole a verifier model. The issue a whole a verifier model, verify credentials, which are issue assigned at the stations that contain claims about the subject, which are optionally bound to a key. That can be, you know, like, sent amongst these, participants. So that the issue of, for example, issues like credential for a driver's license, to the holder, and the holder can then present the driver's license So verify us. And the whole I can optionally approve this key planning I was talking about. And there's also a status provider, where you can optionally check the the status of a credential. Next month, please. The spec was adopted at the last some IETF meeting in San Francisco, And, then you published, version 0 and, recently published version 1. I wanna talk about the, the updates, next one, please. So what's new? What's new in version 1? So we have a renamed so based on so everything was basically this cast on on GitHub. So if you wanna see why we decide certain things, please go to, GitHub and check that out and also encourage to also participate in a discussion. First of all, the type identifier, so it's a, we we define new rules for a type identifier. For position resistant names. We renamed the type claim, through VCT, verifiable credential type. We had a lot of bike sharing discussion. And, Then we, removed some duplicated and inconsistent requirements, on cheap cheap cheap keep binding shots. Are inconsistent with the SD charts back, which also know, advanced,"
  },
  {
    "startTime": "00:28:03",
    "text": "since last time we, updated this spec. And, then we also defined, rules, for obtaining the, issuer verification team. Which is important for verifiers. And then there was obviously also some editorial changes and the fixed the fixed also references. Next one. So this is a summary. So this is the latest thinking of verifier should obtain, the verification key of an issue assigned shot. So, basically, how does the verifier verify the signature also verify the credentials. Different mechanisms, based on what we saw but the community has this requirement. So the first one was, using, the X Five Star headers, in a w t's there is like, you know, X Five C X Five T X Five tea, s 256 and so on. So there's a few of them. And there are corresponds to X5 for 9 certificates and more specifically to a leave certificate at the end of the chain. So if the verifier encounters, one of those headers, expectation is that they had, that verifiable try to match the ISS video, against the DNS name or uniform resource identifier value in a in the sun sun extensions or the subject of a native name extension of the, least certificate of the X Five for 9 certificate then get the verification key from there and verify the issue assigned short. If, the ISS value is a HTTPS, you are then the verification key should you obtain from the well known short issue metadata? Which, contains a JWKS or JWKS UI. Yeah, to your case, set set off TWKs. Barbecues. And if if the ISS batteries are dead, then you should do,"
  },
  {
    "startTime": "00:30:03",
    "text": "Data resolution and, also optionally use the KID to further locate the, publish key in the big documents. Katie can be an absolute or relative that you are And then ecosystems can also at the additional rules, as long as I don't contradict with the was that we just discussed. Next slide, please. Yeah. So, and, now, Dania? Thank you. Yeah, we got a couple of points open for discussion, and we have 40 minutes left, so that's great. So first things first. Oliver, already mentioned that there's this that used to be a type claim, which is now called verifiable credential type VCT, And, a type claim is of just calling something type is always great because everybody has an idea what to put into the type, but it's not necessarily the same idea for everybody. And it's very easy in the specter kind of reason out of this and to say, this is the time. Of the extension. But the question is, what does it actually mean? So instead of wizzling out, we thought that maybe it would be a good idea to actually define what it means. So define the concept offer credential type. For SD. So this is all scope to SD drop VC. We're not going to define, anything for other credential formats. Right? So, Sorry. There are some questions in the chat there. Brian, Richard, I think a very fine question, some k. You wanna wait Go ahead, Brian. Oliver's head is right in front of the camera. By the"
  },
  {
    "startTime": "00:32:03",
    "text": "not what that wasn't the question. Right? That's That wasn't the question, but it was a comment from us, yours at home, my actual question was, do we really, really to bring this into this in a normative way. The credential type, No. That was on on the prior slide. This one. I think that should be removed and deferred Right. We need to define it somewhere, I guess. No. We don't. Richard. Okay. Okay. No. Nobody really needs deeds. Right? I I also have some next 5 or 9 comments here, but I'm happy to save that until later if you wanna we're gonna 7. So the thing is I think for a credential format we should define this. We're not doing this NSD drug. We're doing it in SD drug VC. And errors a property of a credential that you can verify it. And I think in SC drop, we see we should talk about the mechanisms that, switch over to do that. If we agree that we like, this should be put into a separate spec and, pulled out and make make make more generic. I I think that's fine. But right now, for example, when you use charts for for ID tokens, we have a defined way to find the issue a key but we don't have for the SD WOCs. Yeah. We have we have one way there, and I think it's appropriate to specify some ways here. I'm I'm pushing back on specifically on using DIDS as a normative piece, and that could be deferred get rid of that point and just roll it up under ecosystems can define their own roles."
  },
  {
    "startTime": "00:34:00",
    "text": "saying use did. It's like saying use a protocol. Yep. Yeah. It's Well, that's really, like, 200 of them. Bye with with with as We can take this offline. Or Yeah. Yeah. Let's take this offline then. Okay. K. On your top, opinion list or get. Yeah. Okay. So coming back to the credential time. But certainly, a set of metadata that is usually associated with credentials. And we've seen some of that metadata pop up in other places. For example, in the Open ID for verified residential insurance protocol. Where it shows up in the issue of metadata, but it's not really issue data. It's really about the credential So I think this should be associated with the credential type. And this can be, and this is this is really really early. So these are just the initial thoughts that we had on this topic. Right? Something like display information about the credential. That's something that but credential formats are already defined. Starts with the background color, to display it in your wallet can also be other information as well. Information about the claims for example, also how the claims are displayed. Right? So if it's if a claim is called give name, what does that translate to in French? Type information, in the sense of what can wallets expect in, as the value. Of a claim, of course, again, to display it in the wallet. And set us information about the claim. So as Safa tested? Is it, has it been verified? Maybe the other options as well. So where does that claim come from? Samsung. And also the whole thing with refinding the credential."
  },
  {
    "startTime": "00:36:00",
    "text": "We already have to find an acetylox key binding also claims based binding is a, big topics are using claims in the credential, to, maybe with another credential to check that they match and then, we can just those belong together or something like that. Maybe it would be useful to encode some of that information. And this is really added. This has just some ideas, but there there's a set of metadata And, this having this information would help especially wallets to handle the credentials because they usually don't know a lot about the credential. They get the credentials. I sent them somewhere else, but Yeah. Verifies as well. Verifies, especially verify, developers be interested in learning what the type looks like. So what data fields can be there and so on. Yep. So, having credentials up, I think, is a very useful thing if we associate some metadata with it. Next slide, please. We are, at the very beginning of this, So I think what we should do is we should agree on initial initial set of data came in very small, then think about how we can distribute that data. Your options could be to have a registry for the data. If, people prefer IANA registries. They can they could put the data in there and then get a nice short name for the credential time. Credential types could also be URL. So that we can make the metadata discoverable wire that well known URL think that would be nice as well. And, specifically for, SD. So and we want to do this, as I said, specifically for us to drop VC. We're not going to define prevention types for or credentials. Right."
  },
  {
    "startTime": "00:38:00",
    "text": "So this would be, Yep. Very specific. And, And, of course, also try to, stuff out of out of specs where I think doesn't really belong. So the VC aspect and a high assurance profile. For open ID for VC to So there are some duplications there, so to remove as much as we can from there, the belongs into their credential 5 metadata. Next sentence. This is a completely made up example of what this could look like. So, just just to give you a very rough impression, So for example, the VCT, which, of course, would be the identifier for the credential type. Could be in this document, then the display information which starts with some information about the credential itself. Including the logo background. Cut up and so on. There could be information about the various claims For example, that could be adjacent point or pointing to the claims in the credential and then providing some display information like a translation for the name of the claim and the status of the claim, whatever that that exactly would be. Right? Just to give you an idea something to think about. I'd like to invite you to participate in that discussion, Right now it's on GitHub, but we certainly want to bring this to the list, to have a, like, have more people participate in this and, Yeah. Probably the the right time to bring it to the list is once we have, a better pure idea of what data we want to put into this and then to discuss it there. Next slide, please. Different topic. I have already mentioned that we have the draft issue of metadata. So the the metadata, the drought issue metadata,"
  },
  {
    "startTime": "00:40:03",
    "text": "is where you can find essentially the key to verify if you use a URL to verify, a credential. And right now, it's called jaw it's it's called isuramite. You show me the title chart. You show me the ticket. Yeah. And that's very generic. But we're defining it in the, in our spec as CJ BC spec. So I'm not sure if that's appropriate to define a, like, this very generic sounding name in the very specific spec So I think we should think about and other people seem to think so as well. Coming up with a better name, more precise name that scopes this to SD drop credentials or SD drop PC credentials specifically. That's an issue on that on GitHub. If you have a great idea if you have a strong opinion on it. Let us know. What else? We need to, improve the examples that we have we also have some, we have a more request on that. We need to work on that, provide better examples, especially for the guide us, to, ARF examples of the the stuff that where where as the drug we see is actually going to be used as far as I know. And and to provide useful examples to encode personal data them. And, yeah, some other topics that we need to us as well, confidence on insurance levels and also, how to bind the credentials or then claim space binding. Yeah. That stuff that we want to add to the spec as well. Thank you very much. And we now can take questions. Thank you. Anybody has any question, comment,"
  },
  {
    "startTime": "00:42:01",
    "text": "which are rewinding all the way back to the issuer he discovery stuff. Don't wanna be the X Five Zero Nine mirrored in the room. But, I think the wrong you you you went past and, yeah, there you go. So I I am totally sympathetic to wanting to have a non live HTTP way of distributing issuer keys, that is really salient of use cases that care about. You may run into some problems if, the only, authorized key usages in the, X509 certificates are, TLS server authentication as is very common when PKS certificates which are the ones you'd probably be, which are, like, the obvious ones that that folks use. Yeah. If we're already adoring that, Great. But, you know, the you you may have some PKI nerds, complain about that mismatch. Thanks for the input. Now it's definitely not the intention. I think it's definitely valuable to have Yeah. also support for even gap, root certificates, for example, in a high assurance environment. Oh, one one other thing that occurred to me here, here you seem to have kind of a it makes a difference in the format of the credential whether you use X509 or HTTP based discovery. It seems like you could maybe split the difference here and have credential, be in variance. Just always have an issue URL there. If you have some other objects that basically captured the JW case up from the issuer metadata. And signed that. Under, under an X509 certificate that they incurred in some other PKI. So, you, you would keep the, the j the job format the same."
  },
  {
    "startTime": "00:44:03",
    "text": "But you'd, you'd authenticate, the, the key set. And that, that was the design. I'd, gravitated a little bit more choice. I can send you some links to some stuff I wrote up about it in another context. But that would be not an alternative worth considering. Thank you. Okay. Christina, you wanna say something quickly? Yeah. Please do that quickly. Yeah. Super quickly on devs. So, yeah, I don't Should I don't think we should allow all 200 methods, but If we're talking about, like, Monday, the HPS URL, for example, and I see what you're laughing. I saw you. So There are bunch of people who implemented the web right now who want to implement this specification. If it completely take all the dates from here, in Monday only GPS version, if you're losing you know, it quite some share of the market, some just didn't want to, you know, let it sound like we completely against it. So, like, just saying that having did that, for example, would be, like, a really, really nice start and I see what shaking has and, like, we should talk talk about it, but, like, yeah. Thank you, Christina. Thank you. Dial. That second. So k. K. Okay. Yeah. Think you're you're after that. Good. Hey. Hey. I'm Paul. I'm talking about, a new draft that's hard to pronounce. At the station based client authentication. It's a bit hard. And, this is not prague. As you can see, I hope this is the most current slide deck, but we'll see. Okay. Go to the next one. And,"
  },
  {
    "startTime": "00:46:00",
    "text": "Tobias was on there. So I'm doing this together with, tobias Looker. I'm not sure if he's on online participating as well. Okay. So let's get started. The motivation of this, is mostly Coming from Idas, we want to, To buy is online by the secure government credential issues So we need high insurances there. And we wanna do this with the VC ecosystem, open ID for VCI is probably the protocol, how we're gonna do that. And we looked into the ecosystem and we saw that not a lot of people care about the security of the wallet, So we want to to make sure that the issuer can be sure that he's talking to the genuine legitimate wallet and that he combined his issued credentials to hardware bound keys because there's lots of regulations that you can mostly only apply if you have very high assurances and mostly at some point, you need some kind of hopper binding to this. And, yeah, and the question was, how can we integrate this and, yeah, things like open ID and also, like, generalize them the concept, to our auth. Next slide. So this is Basically, the solution, it's, it fits into the into the framework for a client authentication. Right. And there is some debate going on. If this should be a client authentication or not, maybe can keep this to the end. And the idea is that the client instance, it's very hard to say whether this from original OAuth terms is a public client or not? That's Also, discussion, but it's gonna be like a web wallet or like a native app wallet. In the cases that we have in mind, Just one one comment."
  },
  {
    "startTime": "00:48:01",
    "text": "Don't point there because people are re remote and that you you talk to. Okay. What you're trying to say. Yeah. Great. And so we think that there's like, a client instance. So a client instance one particularly device, probably, that, the issue or the authorization server and authors when to issue something to And, So the idea behind this is the client instance and step 1 here generates a key that he has under control, And in in some way that is not part of the standard in step 2, it requests an attestation, a client attestation from its back end And, it can you it can make use of any platform specific attestations. We don't wanna specify this because this is probably very volatile and not keep the same over over the years, And then the client back end can validate all these platforms specific attestation and generate, a client attestation. Which is bound to the key that we generated in step 1. It will send back the client attestation. And then the client instance can use this generate, approve of possession with the key that it has. Specifically for this authorization server and then can use it in a token request or at the par end point. And, send this client attestation and the proof of possession and then the author can make sure of us really belongs to this to this client, and this is bound to this client instance. And they can continue from there. Probably, also using a depop, Yeah. So that's, the basic idea, next slight please, Yeah. I think we covered all of this. Let's jump to the next one."
  },
  {
    "startTime": "00:50:01",
    "text": "This is something that, like, how it could Look in, a mobile wallet set up. So the key that is being used s supposed to come from a secure element, TPM secure enclave, what ever you call all of these things. And, should be opaque to the authorization server or the issuer. Which kind of key thingy decline is using So the idea is that this client instance that the client attestation it gets back at step 4 Looks the same no matter what. Hardware underlying which platform this client instance is using because the authorization server doesn't really care. Probably about this. He just wants to make sure, and we wanna keep this, like, in, like, a very, yeah, thin layer of interoperability in that way. Next slide, please. Step 3 twice here. This is a slide from Tobias. Okay. So this is how that would look like if the token request We have this client assertion type, which is called Jeff client attestation here. Then the client insertion is, basically to, Jason Web Tokens the first JSON Webtoken is the client attestation. That we received from our client back end And and this is something of the authorization server, can verify and then look up against a trust list or and a federation and and see, well, this is a world that I or this is a client that I trust then we have the tilde, that's very, on vogue. And we have the client attestation, proof of possession jot, behind that, and that is a proof of possession similar to how a key binding JWT works in, in SEJOT. Where we"
  },
  {
    "startTime": "00:52:04",
    "text": "Yeah. Use the key that is signed in the client attestation, and we use it for specific audience and non from the authorization server. Next slide. Com. Yeah. Okay. Yeah. Yeah. There's a new assertion type, and then the next slide probably, yes, these are the 2, jots that are concatenated by the tilde. Next slide. This is, again, another thing how, like, the whole thing looks like. So it's 2 dots combined with the tilde. And this is how a client attestation could look like. It is a jot. The important parts I just asked the issuer that's our client back end And then the sub, equals to the client ID that's gonna be used in the workflow the, yeah, time validity informations can be used by the client back end. Also to signal. Some form of, like, how long should you trust the thing This is belong then later to the discussions of assurance levels, and in the end, we have the confirmation claim that's the key, the client instance key that's being used for the proof of possession. Next slide. So, yeah, the use case, I think I mostly talked about, we can use it for any, well, flow with client authentication in particular, we use it for open ID for Verpal credentials. Issuance, especially in the IDAS context. Next slide. Yep. You have sheep people in the queue. Do you wanna take questions now, or do you wanna wait? Has has anyone urgent questions? No? Keep going. Okay. Then then the next slide"
  },
  {
    "startTime": "00:54:02",
    "text": "That's just yeah. So, what happened so this draft was presented in San Francisco at last last ATF and it was adopted, very shortly afterwards on the mailing list thanks for that for all the support. And since then, there has been a little progress, which is summarized here. The introduction was a little bit confusing, and we kind of simplify that, making less assumptions, about the the, you know, circumstances around this, making it more oauth generalized There is a big discussion, around replay attack detection. So how can we make sure that this client attestation, proof of possession jot, is not being replayed. There's 3 main major things that we could use here, or like 2, other we use, like, Jot IDs and the authorization server has to keep track of those, or we use nonces that are either implicit or explicit we added some guidance around this, and there is, like, endless issues in various repos on how we want to do that because there's a lot of people that actually want to use this drafted. And we have them particularly decided is the best way? We think that Jolt ID is What kind of our fallback mechanisms, but almost all people agreed that we should use non sis. And the question is how do we get the non the authorization server, to the client, particular important, like, particular troublesome, how do we do it at the par end point? Because atpar client makes the first requests, to the authorization server so we don't have any chance there, to do that and, like, question there is, do we have a non endpoint that we want to create or"
  },
  {
    "startTime": "00:56:00",
    "text": "do we have an additional round trip, or what do we do? We have, yeah, we have generalized, saying that this is not only applicable token endpoint, but also, like, power endpoint, we did some clarifications on how to use this rest refresh tokens but there's also ongoing discussions how to do this with refresh tokens. And we fixed some, like, typos and things that were, like, obviously wrong in the text but meant otherwise, and we have some examples how this matches to IDES, how we expect this to to do. And last slide is, yeah, what are we working on? As this should be used for wallet at a station, we kind of or, like, I envision something that we have an authenticate or assurance level so that the client back end sees all these this attestation that we get, and he Can, analyze this and say, well, to a certain degree, you can achieve this level of assurance in a particular trust framework. Because the authorization server doesn't really care which key type is used and what user authentication mechanism with how many pin digits. He just wants to know, is this applicable to my use case or not? So in the end, we want the client back end or we might call it attestation service, summarizes or analyzes all the things that he has seen on the client authentications as well. You can do. Substantial or high. We're renaming the client back end to client attester or client attestation service because might be different entities we wanna register, media types and, so therefore, just types, And, I've already covered the discussion on the non mechanism, a this is a big ongoing thing. And then, some people want to use this mechanism, Also, in the verification of"
  },
  {
    "startTime": "00:58:05",
    "text": "and the presentation of credentials. So in open 94ep, that's a big discussion if we actually want this. It wouldn't work right now because it's a client authentication method and an open ID for VP. It's the other way around. And then, the ongoing discussion on refresh Okay. So we have 6 minutes and survey people in the you. So please very briefly. Hi, Justin Richard. I have a lot of concerns. But I'm not gonna go through all of them right now because we're short on time. One of the first things though that that I noticed is that looking into this, you're going and talking to the authorization server getting something that is, you know, attested to be part of a key. Handing that back to the client for the client to just use going forward. This smells a lot like dynamic client registration, is there a reason that it's not is that a deliberate choice. Because for me, specifically, the use of client station, is directly applicable to other dynamic registration type of use cases. Outside of a client authentication to the token endpoint and whatnot. Yeah. First of all, I would wanna say that, like, I'm not an off expert. I'm like, pretty new to off, and I know that there's I think there's some overlap to dynamic client rates and I think that's probably also what Aaron wants to say. So, yeah, I don't have perfect answer to bias probably once say something to this. Yeah, feel free to join up to bias. Yeah. Yeah. So I I I just wanted to say the the the party that the client is obtaining the attestation from Justin isn't authorization server. It's a, we call it the client back right now, but we're just gonna change it to the the client. Oh, no. I I I understand that, but the client attester needs to have some sort of relationship with the AS in order for the KEP Trust upon attestation. And that part when you look at it from a distance feels more like that's part of the registration step. That's what I was saying."
  },
  {
    "startTime": "01:00:01",
    "text": "So I'm saying that this there might be a larger There might be a trust list behind that where the authorization server might look up the client ID and what that actually means. Or there might be a federation behind it. That's for now, not in scope, but Right. I and I'm saying that there might be a larger mechanism. Thanks. Right. Yeah. So to to be clear, though, it's we're not trying to the way that the client would identify itself to the authorization server is is not for consideration in this draft per se it's more a client authentication mechanism. But, understand that there is either left there. Okay. Philip, please keep it short, guys. Absolutely. So I do think this should be or could be explored to VODC mechanism as well, maybe BTDCR mechanism, but that's not why I came to the mic. There was a use cases slide, which started with something like this could potentially be used for other of two endpoints or mechanisms that use client, authentication. And I think I wanna definitely strike the potentially this has to work as a general mechanism if it's gonna be if if it's gonna be, brought further on. And on your very early slides, exact me the point that, that Justin was making the relationship between the key that is used by the, AS to verify the attestation that is something that needs to be explicitly at least for whatever default and the generic way of operation of this mechanism needs to be 5 with metadata or, the client's, pre registration, which could be done with PCR as it's the JOK URI or something so that the authorization server knows where to go and get the key Thanks, Philip. Turn. Hi, Aaron Paraki. Octa. I'll try to keep this quick. 1, thank you for doing this, so I don't have to. Too."
  },
  {
    "startTime": "01:02:00",
    "text": "Client attestation is a different problem than authentication, client authentication, and they are both important. And I would like to be able to do both. All of the time. What I mean by that is anytime that the client talks to the AS, we currently have a slot for client authentication. We now also have a slot for token binding using depop. And there is another input to that, which will be client attestation. And I would, in fact, like, be able to send all three of those at a time. So as was previously said, using at a station at all of the existing endpoints in OAuth would be very useful, including dynamic client registration, the token endpoint for all kinds of to happen at the token endpoint, the par endpoint, etcetera, etcetera, etcetera. So this is great. But it shouldn't take up the client authentication slot that we already should be in addition to that. Aaron. Christina. Not sure I agree with that, but somewhat related. I agree. We we want to use it regardless. And if you look at date, short profile for quantification and authorization grants, or see already existing in this working group. Like, I would like to be able to use I look at this draft as more like, cinder constrained drug profile for client dislocation and no sterilization grants potentially. Where I'm going is We have a use case where, we would like to use this If you look at this cinder constrain joy as a grant, use it as a grants type, to be able to get, access token. You only have to think I have time to explain more, but, yeah, I would like this to be discussed. Thanks, Christina. George. And I'll I'll just say ditto to it. Aaron said there's many, many places we could use this in attestation as different from authentication. I saw Ben join. Do you have that quick comments, Go ahead. Very quick comment, just not for discussion, but just to consider,"
  },
  {
    "startTime": "01:04:00",
    "text": "I'm Ben Bush, I'm work on Thunderbird, and we connect to mail servers and, casing, company. I I want to use Thunderbird My company uses Microsoft Exchange of 365. I have to go through OAuth. N what's how can this be How can this not be app used to block Thunderbird from connecting to Office 365. And Microsoft saying, no, we only support our apps and everybody else go away. In that point, we lost access to mail. Okay. Thank you, guys. Appreciate it. Thanks. K. Erin. Can you give me slide visual? 52. Let me see. How can I do that? Where is that? This is a new s. There we go. Yes. It's great. And timer. Thank you. Okay. Hi. I'm Aaron Paraki from Okta. Watching for browser based apps. This has been in the works for a while now. And I wanted to give update on the status of it after, the last time we talked about it in San Francisco. The short version of what this is is a recommendations for people who are building OAuth, applications, clients, that it run-in a browser environment. Typically, that means a single page app interface app, JavaScript app, whatever you wanna call it. However, it may It does include the case of a JavaScript app that has its own back end component. That's in scope. First, I wanna give a huge shout out to Felipe for stepping up a co author of the draft. Libbey has put in a ton of work to do a a big overhaul of how this draft has been presented. He is remote. So, he's here today."
  },
  {
    "startTime": "01:06:03",
    "text": "If I say anything wrong, I hope you will speak up. Because I wanted to give a summary of what, of what those changes are. So the fundamentally nothing has changed in terms of, like, the recommendations and the the document itself. However, it is now much much more readable and much easier to find things within the document, The big restructuring, was starting with the threat model of what we're talking about, rather than jumping into the recommendations. And then once we have that threat model laid out, the the most of the document talks about kinda 3 main architectures of applications. Playing pure JS apps, apps that get tokens from a back end, but then use them directly or apps that, go route everything through a back end component. So now each of those sections as I talk about the, the the properties of each of those architectures now are able to reference the threat model and say, this one solves this. This does not solve this. Things like that. I have a couple of examples we'll actually look at in For example, this is the, from the table of contents. This is the the main new section in the draft. Talks very explicitly about the types of attacks that we are worried about and considering and, trying to protect against. Previously, these some of these were in here. I think, actually, oh, they were all in the draft, but they were kind of hard to find they weren't able to leave point to that. Point to that. So this is now a great list that goes into detail about the actual attacks that we are, caring about. And then when we get into for example, the BFF pattern where, this is the the pattern where the JavaScript app doesn't ever see the tokens because everything the JavaScript app does, it talks its own back end, then rules the token along make an API request. We're able to now say,"
  },
  {
    "startTime": "01:08:01",
    "text": "these are the attack vectors that are still possible with this architecture and these ones are solved. So Do you mind also there are, There is one in here, which is Turns out. Good as we can do in JavaScript whereas some of the other back end, the other, patterns like the pattern where the JavaScript client goes first to its own back end to grab tokens but then goes and uses them, but it still has to store them. Now we care about things like token theft because the tokens in the browser, I'm persistent token type, which is a variation on that, and that results in, you know, these these consequences. And then of course, the the the worst one here had, which is vulnerable to, you know, 4 of these different kinds of attacks is when it's a pure JS client. Like this does a much better job of really explaining the situation of how how these different architectures actually affect the security outcomes of building these clients. So That's the big update. Again, like, there's nothing there's not a lot of, like, new all no changes to the functionality of recommendations because, again, this was meant to capture the security considerations of these kinds of clients. Please do still review the changes. And I'm hoping that this is like the home stretch here because I think this was a huge, huge, very, very good rewrite of how this information was presented. That's it. That's that's it. So Okay. First, thank you, Aaron and Felipe. Yeah. And, you know, we put lots of effort into this and and it's great work. We appreciate all the hard work that you've put into this. So Do you, like, do you feel that we are ready for recouplast call or What's I, I do feel like we're ready. However, I realized that"
  },
  {
    "startTime": "01:10:04",
    "text": "Probably not everybody has actually read this yet. Right. But I do feel like it's ready. So K. I don't know how to Okay. So I I would like to hear Justin is in in the queue and and and people if what do you think? Have you reviewed the document, the changes, Go ahead. Hi, Justin Richard. I have not yet read the new version of the document. And it's it's actually been a minute. So my my only real question is you know, this has been progressing for a while and I agree. It's it's great and it's important work. My only real question is, does this have considerations for things like a storage of, credentials that are bound to tokens, Deep off keys, and the like, and storage of those, or is it, just storage of access token or is that looped under secrets. There no. There's it does talk of I I I'm pretty sure there's a section that talks about Mhmm. The web crypto API JavaScript and how it does not guarantee that that private key is actually hardware bound. Right. That can still be extracted from the file system, but cannot be extracted from the JavaScript. Attacker. I remember correctly, there's a whole section about depop in the draft. Got Okay. Like I said, I I haven't read the new version of it. The last version I read was creepy pop. So it's it's been a minute. Okay. Thank you. K. Nail, nail, Hi, it's Neil. Again, I'm mine was pretty similar. I'm I was just trying to find the Deepot in here, and it wasn't clear to me from this. I have only scanned it a bit for the default references, how you were meant to bind it to the browser so that, you know, you definitely can extract it. I think it'd be good to actually talk a bit more about that in here if you want people to use that. K. Any other questions, comments?"
  },
  {
    "startTime": "01:12:02",
    "text": "And Felipe, feel free to join and and if you wanna see any anything here. And Yeah. I I have the document open here. So there's a section that briefly explains how you can use Deepak to not combined with the web crypto API to use a non extractable key, to create your default proofs. However, there's the second paragraph in this section is the site note assist like, yeah, but even with Deep Up enabled, it doesn't really solve the problem. Because the attacker is very likely to be able to, abuse tokens anyway. Because they can use their own secrets to set up Deep Up So it's To be honest, it's fairly limited what's in there. It it gives the necessary information and pointers on do it. And then I it kinda defers the the the actual details to to what follows from Deepak itself. Okay. So Can we go ahead. Yeah. I was just gonna add to that. I just pulled it up the the header in the document is called sender constrained tokens. Not called depop. However, it talks about Deepom. But, again, like Olivia just said, the the problem is that it that. Maybe this is maybe this is like, a sign that this should get moved up into a higher because it does solve some of the attacks, and it does not solve other ones. Just like the other architectures like, like, like, has some of these properties where these things are solved and these things are not, and it is still worth knowing that. So that I can, I can, I can understand the argument for for wanting to bubble that higher than the security consideration section where it's in k? Can can I Oh, go ahead, Justin. I would second that, because, this storage of keys and stuff like that is effectively another type of deployment pattern more so than a security consideration. I would argue But I I think that's a good idea to do."
  },
  {
    "startTime": "01:14:05",
    "text": "Can you get a few volunteers to review the latest version of the document. Select Justin. Anybody else? One more, please. Okay. You have to So two people to review it. And, let's let's see what what happens after that. Maybe we can schizophrenium. Comfortable after that. We can make, recoup classroom. Okay. It's okay. Philip. Yeah. Justin, if you if you review the documents, let me know if if you still think deep up is is like a separate pattern because, it it kinda fits nicely into the different as we have. And I'm not sure it should be listed as completely separate section, but, let me know once you've read threat to draft in the patterns and and mentions of depopliter in there, and we'll we'll take it from there. Yeah. To be clear, it's not the default is a separate pattern. It's that the, sort of the nature and storage of, associated secrets would be the separation of the pattern. So it's so it's it's tough because, like, you can crop with all three Exactly. So it's not like a separate thing, but the using depop does give you some properties that you don't get by not using obviously. But it's not the silver bullet that solves everything. So, like, it absolutely knows exactly where to slot it. In there because it's more than a sec it's more than a security consideration but it's not a full separate pattern. So instead of a pattern, it might just be a different sender constrained tokens might just be a its own section. Maybe we just move it before security considerations in its own section, and then just give it its own sub headers. Yeah. Something like that. That no. That to me feels feels like that. I I will I will read through the doc and you know, if that still makes sense after doing that, then,"
  },
  {
    "startTime": "01:16:00",
    "text": "then that'll be in the review. Awesome. Alright. Thank you, guys. Thanks. Thanks, Justin. Okay. Perfect. Thank you guys. Thanks, Thanks again. Great job guys on this document. Appreciate it. K. Period. Trying to find you, device K. Here we go. K. You do have control? Yeah. I can. Control, Let me find the forest. Come on. You you get going and I'll I'll give you that control Okay. Yep. Peter Kussman, and talk about the latest on the cross device flow, be that we've been working on. And today, I'm happy to have both Philip and, and Daniel in the room with us. Still waiting on control. There you go. Alright. So, as this customary picture of Prague as imagined by an AI. It's not bad, actually. I do now have real pictures of it as well. But, Yep. For those reasons, there's there's been some reaction about the incorrectness and, of the, the picture."
  },
  {
    "startTime": "01:18:04",
    "text": "Okay. So why are we here? Not quite in the cosmic sense, but what is it that brought us to this? I'll also talk a little bit about where are right now and and where we need to go next. Okay. So why are we here? Wind back, 12, 18 months. One of the things that we started seeing a considerable number of attacks. That's really focused on stracting, tokens token theft. And there's sort of several entry points for that. And one of the things that became apparent is that one of the big entry points is social engineering type attacks against cross device flows as an example, and this is a way for people to get unsolicited unauthorized access. And these attacks, really how they work is they end up exploiting this idea that, you know, you're gonna initiate a flow on one device you're gonna wanna transfer that to another device. Usually by scanning a QR code. And, essentially, what happens is there's this unauthenticated channel that gets exploited by the attacker. And so what attackers do is they would initiate a flow And then they would take this QR code and change the context in which they present it to the user, And, a user would scan that and be fully convinced that they're doing something completely normal, the jet let and grant authorization. And so simple example, you might get a message that says, oh, you know, your SharePoint site is about to be deleted. Please scan this QR code and authenticate. Of course, you don't want your SharePoint site to be deleted. So you're going to scan this and you grant access and authorization to the person who actually initiated the, this flow to start with. And so this is particularly insidious because it it's actually sort of really even bypassing multi factor authentication. Doesn't matter how many layers of authentication you add"
  },
  {
    "startTime": "01:20:04",
    "text": "you've tricked the user or you've convinced the user to say, yes. And all of this because have this unauthenticated channel between the initiating a device and the, authorization device. Or the consumption devices we now use So we started looking at this. I think one of the things that were trying to do is putting some pragmatic mitigations, in place also looking at alternatives and really encouraging people to adopt, protocols that have better protection if you need to have a cross device authentication or authorization flow please use something like Fido or Pawski with authorization code grant, please don't use things like device authorization prompt if you can avoid it. We've also started looking, doing some of the, what we call, underpinings. So, Daniel, and, also researchers from, University of Stuttgart and other places have started looking at doing some research about you know, it's those things that we can discover about these attacks or that some of these mitigations that particularly, effective and, see if we can just improve the situation that we're facing So that's the sort of the problem, the approach that taking, so where are we in park? But More specifically, this is kind of the the sort of winding road that we've been on. Since the last time we spoke in San Francisco, we did also present this work at the at OSW, the OL security workshop. And we've got some really fantastic feedback from a couple of, folks that I think, and I'll talk more about the impact of that. That's caused us to really sort of go back, rethink a little bit about how the the document is structured. And actually, we ended up adding another attack pattern as a result of that. And so we'll talk a little bit more about that, today. And I also noticed that I"
  },
  {
    "startTime": "01:22:03",
    "text": "mistake on that slide. Slide slide bug. Okay. So the BCP, there's a QR code. Anybody would like to scan the QR code? Nope. Not today. But you kinda perfectly safe from us. I'm slowly conditioning people to trust QR codes that I show them. By by the time we're done, you'll all scan it and there will be a catch. Anyway, no, moving on. Okay. So what's new? So one of the things that was pointed out at OSW from, Marco and and Gita was that Although we described, an attack, there's 2 attacks that we described that didn't fit the patterns, or the abstraction that we were sort of reasoning over and presenting back to at to readers. And so as a result of that, we sort of came to the conclusion that In fact, it's really, you know, sort of thinking about, and Michael always says, right, he the standard, you know, it should, it should contain everything that's needed, but no more. And so I think in the attempt to sort of have to do the no more, we realize that we actually do need more. And, so we we've added this new cross device session transfer pattern. And so this, what makes this pattern interesting is that it's sort of almost the inverse It's a, It's a flow that you start on the authorization device or on the device where you are already authorized. And then you transfer to that session to a consumption device. So a typical example of that is you want to join your mobile phone to a network So you go to your PC, you log in, you authenticate, you obtain a QR code, you scan the QR code and your phone, joins the network. Application bootstrapping is another one You're logged into your email account. You want to transfer that session to your mobile phone, or you wanna bootstrap that session on your mobile phone,"
  },
  {
    "startTime": "01:24:02",
    "text": "generate a QR code, you scan it, and it shows up on your phone. And so, these examples are in the doc document, but the the flows was not properly described. And so we we actually broke that out as as a new, pattern. And also describe the attacks, which is really a cross device session phishing attack. That the types of dates, attacks are very, again, sort of insidious type things that attackers would do. They would call somebody up, claim to be from an IT support. Organization and, ask them to send them to initiate this flow basically authorize the transfer of the session and then send them the QR code. And then once this then the attacker can scan this QR code, because the channel is unauthenticated, there's no controls. The attacker can take over the session. And I really spoke a helping and contributing text to make this clearer in the in the document. So that that is new. A few other things that we added. So as we also describe these new attacks, there was also a new mitigation that goes with that. So good news, we described the attack better and it also we also got the opportunity to add a, a mitigation, the request binding without a out of band data. We also broke out user education as its own segment there's some research, that, some researchers at Hollywood pointed out to us, And that was, particularly helpful in, sort of, you know, showing the value of user education as a mitigation on its own. So we we wanted to draw attention to that. And then the final thing I think that was a long sort of outstanding issue that Aaron raised around. We had one mitigation called the"
  },
  {
    "startTime": "01:26:00",
    "text": "indicated flow. And really the idea was that the for either transferring a session or initiating a session you would actually authentic or authorizing a session. You would log in on the consumption device and then initiate the flow. And so, we we, we found a new name for that, called authenticate and initiate. We also added 2 new exploits. I'll talk about free, the first one, the fake help desk, And so in this flow, the attack that we've observed, somebody phones up a customer and says, we spotted some, illegal account activity. Somebody is trying to by things that they shouldn't, we don't we're gonna send you a list of transactions, and you have to just decline them in your application. And so the attacker will then start off and buy an airline ticket and Of course, you'd get a notification and you just say no decline and then they'll buy a TV set. Again, no decline. And you sort of keep the the attacker would keep doing and bold trust with the, with the the person being targeted. And then at the end of it, would say, well, now that we have declined all these transactions, what I need to do is move your account or move your money. I'm gonna please approve this. And at that point, the person has, you know, it's sort of built up trust trust. And now they end up in approving these these attacks. So so that's one that we added. And again, know, the mitigations that we describe your rural health co location, proximity and so on. The the second one, consent request overload. So this is another one that we've observed, essentially really sort of focusing on, launching attacks at very inconvenient times at high volume. So 2 o'clock in the morning suddenly you know, as a"
  },
  {
    "startTime": "01:28:02",
    "text": "at ITadmin, you're you start getting requests to authorize access to a system, and you're getting them once every 30 milliseconds, your phone keeps ringing or your your phone keeps buzzing. And eventually, just to make it go away or by accident, somebody says yes. Right, and therein. And again, things like rate limits, proximity detection and so on, will help with these as well. So we've added those as other forms in which these cross device flows do get attacked. We did discuss in IITF117, the various should recommend and may the the normative text. So that was added in, after the after we discussed that, in San Francisco, And then a couple of editor or in addition to sort of restructuring and adding this new session transfer, flow we did a fairly big editorial scrub we also decided to adopt the open ID foundation terminology used in CBA. In part, well, first of all, you just I think it gives us greater consistency, but it also made it a lot easier to actually describe the attack. So thanks to folks who for conciva for having come up with that terminology so we could reuse it. And then just acknowledging, Mark, Gita, and Miriam for their contributions in reviewing the spec as well. Okay. So that's kind of the set of things that's changed. The question now for folks, where do we go next? What's outstanding? So I think at this point, there's a couple of open issue some of them perhaps more pressing than others or or more critical than others. I think one of the things that we're trying to figure out is whether we can do a better graph representation of the diagrams, I think, Daniel, you if we're sort of we're fighting the formatting monster to see if we can can get something slightly better, but that's more"
  },
  {
    "startTime": "01:30:03",
    "text": "in trying to convey, how these flows into tax work. I I think that's also a question about for ISO MDL? Is there a way to reference? Is there something that we should do there? And then finally, I think the sort of biggest piece of work that I think that's outstanding for us is updating the formal analysis section and so, I think right now, we're really just waiting on some of the research that's been done over the last 18 months to be published so that we can reference that And, hopefully, that'll get done in December, Daniel. That's Yep. Daniel says December. So I think that's the outstanding work that we see And, So next steps, big things, right, update the formal analysis section, And then I think the other question that we have here is at what point would it be appropriate for us to go to either get review or working group last call on the updated document. Seems you you still have few things to close. So let's let's see. It. So, yeah, look. So so let's let's close those and maybe next year, early next year, we can k? That would be Makes sense? Yeah. It'd be great if yep. I'm perfectly happy with that. Thank you. Yeah. Having a few reviewers after you spin the next version with those new edits that sounds like, would be appropriate, and then we can see what a It's it's ready for working group plus call. Okay. Excellent. So do we do that just on the mailing list when we have the next version ready and we can we request for reviewers before we issue with We have some reviewers right now, you said, like, early next year, January, February, you you have some some time available to go through these documents. It's not sure but, could be interesting. Tony. Yes. Just wondering if I Handy. Down, Go ahead there. Yeah. Just wondering why you would add a reference to the ISO document. The MDL. There's no"
  },
  {
    "startTime": "01:32:02",
    "text": "cross flows here in MDL today. Daniel, do you want to take that one? Microphone. I'm, not not quite sure what the exact wedding around that aspect. The, think there's cross device. Presentation at some point. Isn't there? No. Depends on and which document are you talking about? 20 to to Jesus as if I would 30. know all this. I just would, some clarification. Like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like like So need some clarification on that. I mean, obviously, Yep. We need to get that right. Yeah. K. Go ahead, Christina. Go ahead. So officially right now, presentation of Iceland DL using Anything is prohibited to the same device. You know, take it as a grain of salt because you can't really prohibit anything really. Having said that, When they originally saw the that, hey. Can we this cross device document also talk about this credentials and street party model. I remember resistance in this group, partially it was Victoria, saying that Look. Like, this cross device CCP talks about cross device grant of OS. So, like, why are you bringing in these credentialing? So I'm fine maybe talking about those students and not exactly against, but If we do that, we need to talk about this whole credentialing space in general. We can just have this entire document focusing mainly on, you know, cross device grants, and then just add this throw in NGL. That just feels a bit the place if you're just throwing only that part. I think the idea is In this cluster of IceBCP, we should not talk about"
  },
  {
    "startTime": "01:34:02",
    "text": "really credentials, That's not the point here. But the what we should point at is other places where cross device flows are used that can be credential based flows. And they use the exact same patterns. So it's nothing new to this document. It's just a different context where it's used, and we should point that out so that people are aware of it. Think that's the whole point here. Token ID for AP. Closed to coronavirus grant for the loan. Yes. Think we do that. Yeah. I think we I think we referenced VP already. Okay. Tony, did you want in here to review did I hear that correctly? Like, for the minutes, just Okay. Awesome people. Thanks, Tony. And thanks, Andy. Thank you. Thank you, Peter. K. To give you control, or do you want me to drive from here? I don't mind control. Okay. Have a new app. Okay. I'll do it. If you want to control him. I was wondering how you do a thing. Okay. So Yes. So I'm Paul again, talking about Oh, all status list, or let's say the title is not very clear. That's not one of you an issues. It's a revocation or a status mechanism, and I'm doing this together, again with Tobias and, Christian, who is not affiliated to Carson Borman. So what are we doing? We This is mostly adaptable to SD Job VC again. We want, a revocation mechanism to"
  },
  {
    "startTime": "01:36:04",
    "text": "later say, well, we issued some tokens like JOTS or caught and we, the the issue might have an update to this saying, well, this is not legit anymore. Or have some other kind of status that he wants to communicate about this token after that he issued it. So that's kind of the idea that we wanna do Next slide, please. How should this, status our revocation mechanism like like like, work? What's, like, the circumstance that there's requirements that should, be achieved to, scale very much again, as this is, particular applicable to IDS. Oh, that's one of the use cases that we have in mind. We want a decent level of privacy Yeah. Let's say like that. And, we wanna support like, the formats, like, Jose, Jose, based tokens or credentials specifically we want it to be, like, integrate very nicely into ISO and MD and sd.vcsser. The candidates for Eitis pits and, would also be nice to have some caching support, enabling, yeah, either offline verifications and also giving relying parties, some information, how long these are, yeah, how long this should be cashed, these status lists. Okay. Next slide. So what, like, what we do and, to be to be like, clear, this is not something that, like, we invented. This is"
  },
  {
    "startTime": "01:38:01",
    "text": "leaning against the W3C status list 2021. But for a number of reasons, we thought it makes sense to, bring this to an IETF drafts that has several different properties, we're seeing this as, well, the foundation is like a byte array a status list. And each bit or, like, multiple bits within this byte array, correspond to a status of a specific token our credential, and the the issuer and quotes the statuses of, like, lots of lots of credentials into this slide. And the particular status of a token then can be referenced by an indent x. So with the index, you can look up the correct bits that correspond to this particular token, and then you know what the status is. And this status list is then hosted by the issuer somewhere on an infrastructure And, so it can be read by relying parties, and the trick here is that this status list then Yeah. Depending on this the statuses that you have in there, but but but Well, mostly think about revocation, we expect kind of low revocation rates, So this, byte array that we have has just a lot of zeros. Probably. And, so it makes a lot of sense to compress this. For example, with gzip and then we, encode this in the JSON and the JSON Webtoken case, with base 64. And then the issuer signs that and, can put that up on wherever he wants to do."
  },
  {
    "startTime": "01:40:02",
    "text": "Life, do you wanna go now or at the end with a question? So I actually wanted to make a comment about the scalability stuff but we I can Let's give it to the Emerald. Yeah. Okay. Next slide. So this is an example how this works. We have 2 terms here. This is a reference token. So this is like the original token that we want to convey a status about. So This is, like, a regular JSON Webtoken, and we defining you a claim here that's called status. It has 2 members 2 properties. One is called URI at the moment and that points to, a a URL or your eye were this status list token can be, received from and then IDX for the index where within this status list, you will have to look up. Next slide. This is how the status list looks like. It is, JSON Webtoken, in this case, The issue is supposed to be, the same here. And then this has a status list. Claim, and this has, 2 properties. The first one is bits that signals like how many bits one status has. So and the easiest case, that's one. And we just have, like, a bit error in, like, one bid applies to one reference token. But that could also be, multiple bits depending on how many different statuses, the issue wants to communicate And then we have the list. This is the base 64 encoded gzip status list find array. And also it contains, a subject which is the URL URI under which it could have been"
  },
  {
    "startTime": "01:42:02",
    "text": "or where it was hosted on for, like, offline use cases. And then on the left, we see adjacent Wabturk again. Well, you know, chasing what targets look like. Next slide, please. So this is how it fits together the status. So the URI points to the place where the status list is hosted, we gonna deflate this with g zigzib, then we have this byte array and the reference token has the index 5. So we look up the index 5. And then we see, oh, it's a one and the the draft then create the registry where we have the values for, these different statuses, and 0 means valid and 1 means invalid. So they know that this is, probably revoked a reference token. Next slide. We edit. So, yeah, maybe to after we discussed this, the what was the like, history of this draft, to rewind a little this was also have presented at IETF, in San Francisco, there was a bit more discussion if this, fits into our auth or not Also, accompanying to this, like, general discussion if SDJPC and all these things belong to OAuth or maybe to spice. In the end, we settled down that for now, we see that this is applicable to OAuth and there was, request for adoption on the mailing list, which was successful, but that just ended, like, very shortly before This IETF. So there wasn't a lot, done since then. And Some features that this also has, and one of these is is nuisance, the last one is that, we kind of define this like very basic fashion protocol of HTTP Get, like,"
  },
  {
    "startTime": "01:44:02",
    "text": "how, a relying party would patch this, status list token. From, yeah, from the issuer or the status list provider, and we advise to use, HTTP mechanisms, cache control, and also, the accept header and to, to differentiate between the sales list and also give information like when there is an update to be expected? Next slide. Yeah. This is I think this is, a relevant slide with with probably what a lot of people are wondering. Like, what's, what's the size of this thing? Because, like, why are we doing this in the end? Because, the CRLs just scale very badly. And, surprisingly, these statuses scale pretty well. You can see for the number of financials that the issuer contains in a status list and the percentage of things that are revoked. Like, how big these numbers get. Yeah, and we expect, like, I think the average revocation rates on the internet are around 1%. Also depends on lifetime of your tokens. And Yeah. These these numbers, well, can give an indicator of what you can expect in terms of size. Next slide. What has happened since last time? We got adopted. We changed the title that, got a lot of confusion on a lot of discussion. Before this, it was called joint caught status list. Then there was a discussion to rename this because maybe we don't want to be particular on these these formats. And we renamed it now to Oh, awesome. The status list, but we Mike wants to get rid of this OAuth and people say, we want tokens to us this. I think it's on we defined this HTTP protocol how to retrieve a status list were you were just at some, Hi, Anna."
  },
  {
    "startTime": "01:46:04",
    "text": "Media types, we add a lot of a lot to the privacy considerations because this is always a big topic of discussion here, And then, we renamed very far as true line parties And, yeah, gather it some feedback from early implementations. And what's, on the next slide, last night work in progress. So, there, what we wanna do is provide an option for an unsigned status list. So right now, the status list is always adjacent web token or a single web token, There might be use cases where is nice to have a repudiation. And, if we provide a status list, over an HTTP endpoint, you can achieve this. And, also, it might just make things easier if that issue doesn't have to sign that all the time if he updates this. We're switching from Gzip to Zillow that that makes life, easier. We have the discussion, the draft title, if you have, opinions on that, please, say so. Were drafting some design considerations for the and because we get a lot of feedback why doing things in that particular way and, to, like, Get rid of all these questions. We just want to put in the introduction why we made certain assumptions and certain design choices. We're still missing the CBAR web token representations. And, security and the population considerations. We're continuing to test this, and and do some implementations. And, there's a lot of discussion if privacy can be Made better, Yeah. There's there's no good solution in in site. It seems And, also, like, yeah, we're comparing to the mechanisms of revocation that we have in the X509 world and trying to learn, from these"
  },
  {
    "startTime": "01:48:00",
    "text": "Thanks. Okay. Ready for questions here? Go ahead, Alright. I have a couple of comments. One of them is on the scalability requirements. I I mean, some of the business cases we've seen in in a couple of the LSPs or actually think your numbers are a bit conservative and at least one of the use cases we're looking at possibly up to 20% relocation and least two orders of magnitude more, credentials in there. We have to kinda I have no idea how we're gonna deal with that quite frankly. Right? The But just to note that I think we it is a bit conservative, right, the the numbers you you're using. What I would want on concretely, I would say that does the integration into the token in the in into the credential itself should really have some algorithmagility. Right now, it's sort of you you directly be referencing the the the thing, and it has one way of dealing with statuses right now. Some, as you know, some people that were playing around with accumulators and at Well, one of these days, somebody might come up with a better way to represent data, even though you're pretty close to the, like, the Shamir. I don't know. The the theoretical minimum, right, but still you might actually improve the way you represent data, and we should be have a way to say it. Right? This is the status bag. Here's the status mechanism. And, you know, with that with that mech within that mechanism, in the context of that mechanism, you the rest of the parameters so you can go and do whatever you need to do. And that would also might give us a way to represent stapling approaches. In the same way, which I think we're gonna want to use, for instance, I could like, ship along a verifiable credential together with a bag of privacy policy tokens,"
  },
  {
    "startTime": "01:50:00",
    "text": "based on the status of of that verifiable credential. And I would the the verifier would know essentially that somebody who's actually verifying The issue would know that somebody was verifying the the VC without knowing who who who did so. Right? So it's a significant improvement over over, classical OCSP stapling. Right? So I I I think there's stuff that that we're gonna develop here. And we're just wanna make sure that we have space in the protocol to do so. Right? Yeah. And I think I had one more, but I'll I forgot about it. So Yeah. Thanks. There you go. I I agree to, most things I had said. And particularly, we had have a lot of discussions, for example, with Giuseppe already on like, a similar approach for VCs or JSON Web Tokens in general with a non OCSP stapling like approach, and it should somehow there should be, like, match to this so that we can use, like, the same the same data formats that I used in the reference token, but I think like like, the OCSP light stapling approach doesn't should not be in that. Specification. It can be like a sibling RFC that that that that takes like these forms of yeah. What I what I was thinking more of is if someday, Peter Oldman comes back with this magical accumulator based approach, right, then, yeah, we can stick it in the same Right? Yeah. Well, well, yeah, well, that's on the on our path. Thanks. Justin. To contradict what Lafe just said. So I would actually with, with using something like this for the reference that is inside the the token. I would actually rather prefer that be a a single scalar value. As in a URL that tells me everything that I need to know in order to get this. Now we can if it is just a status token list and then index into that. We can do that very easily with a URI fragment, because that is"
  },
  {
    "startTime": "01:52:02",
    "text": "Yes. This this this question came up twice already and deliberately not did that because what people will do is just take this whole URL and then fetch this. But that destroys all the privacy features because then the status list provider learns that you are interested in Nindex5. Yep. Right. I get that, but you're not supposed to send the brag It is a recipe for failure, in my opinion. Plus you didn't count didn't actually counter by It counters the argument because it would get rid of the No. spaces for the additional parameters for other types of ways to look things up. That's That that was the counter. So we think, yeah, we think that URI should not contain the index because you should take the URI is is, take the status list, and then apply the index yourself. If the index is somehow in this in the URI, and probably implementations will send the index to the status list provider and destroying the privacy. Yeah. Totally get that. That said, multi field composed identifiers have a way of getting composed weirdly and stored wrongly in implementations. When we actually have to go on roll and do this. Case in point c issue or in subject and open connect. Thanks, Justin. We have, six people the queue, we have 7 minutes. So We're on the roll with this. Hi, Aaron Precky, Octa. I'm I repeat the annoying OAuth guy again and say, There's a lot of applications of this in OAuth that does not involve any kind of VC or anything regarding wallets and that kind of stuff. Like, I would love being able to use this for John Access Tokens which is an OAuth spec. And say, have a way to revoke jot access tokens because we don't really have a good way to do that right and this solves a lot of that stuff. And we don't really have the privacy concerns"
  },
  {
    "startTime": "01:54:02",
    "text": "that, that come with us because of the relationship between the AS and the RS in that. But the the other thing that Justin mentioned about the, like, Creaming all to one URL. Things relevant to the jaw access token argument is the cachability of this. Like, the whole point of this is that the RS could cash this whatever lifetime is determined at that URL, and not be fetching it every time so that you get the performance boost of actually using this kind of list, which is great. So, I did a quick scan of the document. There is 0 mention of the term access token I feel like that should go into the drop somewhere and maybe reference the Jot access token spec. And, as a as an application of it. Thanks, Aaron. Harnes. Good. Sorry. Can I just respond to that really quickly? Sure. Yeah. So, Aaron, I think the the the the current, language to be clear, we're we're trying to leave it abstractly as tokens, right, reference tokens in general So they can be identity assertions. They can be access tokens, but I agree with you. We could we could to better in communicating that, there's certainly not any opinion around what that token is and the purpose. I think there's also no mention of very public credentials on the No. That that that's fair. I just, because we have a John access token spec in OAuth, and this is in OAuth. There should at least be a mention of it somewhere in the notes. Yeah. And I think I think to your point, we could also consider pro somewhere filing on top of the JWT access token profile, how you would actually put this status information into a chatbot. Right? Okay. Thank you. Next, Hannes. Yeah. Yeah. Off. I think you should reference the work in the average receipt And funny enough, the WSE work itself doesn't mention the original work, which you should also reference in in all fairness, which is the electoral quirk. So this is, I think from like, style point of view. The other thing is, like, you define 2 formats for this for a, for a status list."
  },
  {
    "startTime": "01:56:04",
    "text": "And if you use a a JSON based format, you have this ugly, basics, default encoding. If you truly care about size, you would as you also specify, just use the Cboe based question, and you wouldn't have to worry about this. Unpinned with it. Yeah. Let's Good question. Like, we we we know that, like, the Jason part isn't as Yeah. Optimal for, like, the binary of the status list. We just think for, like, some use cases, maybe, like, your whole tech stack is just Jason. Do you want to, like, implement then a keyboard part, like, only for one particular thing that you have. So I think we want to keep both options open. Iran. Yes. Thank you, Hannah, for saying exactly what I was going to say about size and Sebo. I'm not a fan of Sebo, but this seems to be the one place where Cybo is clearly Oh, the bet the better way, and then to go on record token status lists. Please. And Get? Are we how to put it nicely. Are we actually competing with the w three see on a solution for the same problem. Have we sorted through Well, there's a number of reasons why we don't like statusless 2021, and we thought that it makes sense to to start this endeavor a thing yeah, if we wanna go into the reasons, I think it's mostly about JSON the RDF And then the question is, if this is for Like, nobody in all of knows Verified credentials. Do you want to parse Verified credentials for your revocation mechanism, I think Jason Webbtoken is just the mechanism that is mostly available to all implementations. So I think that's an easier approach 5."
  },
  {
    "startTime": "01:58:01",
    "text": "For, like, a better data container. For a status list. K. We have 2 minutes and still three people. Thanks. Thanks, Yaron. George So I guess for me, I was trying to skin this back real quick. I think we need to describe in what context this is useful for what kinds of tokens, because there's many other ways to do Right? You've got shared signals. You've got other things that can make a lot of sense. And so and even the access tokens, if it's a short lived access token, is status list really a super valuable way to address verification? So I think some context didn't hear about this solution as app well, under these conditions would be really helpful. Yeah. Thanks, George. David. A couple points. So back to the, the revocation and the, the percentages, I think, 1% could be very low the one of the reasons for verification isn't that the a person loses access, but for verifiable credentials, the attributes have changed. So I've seen, especially internal use cases we start to see people sign a lot more attributes. Even as high as 50% verification because it's like HR change their family name because they got married or changed their, reporting structure because they got promoted. All of those led to revocation and reissuance. And, you know, we could also see like 86,000,000, citizens represented in a single, from a single issuer. And it doesn't mean just like, things like accumulators, other approaches of immunity to follow phones, but I'd really like to see guidance on where and where this, shouldn't be used in terms of"
  },
  {
    "startTime": "02:00:00",
    "text": "performance, in terms of the W3C, the the issues that I saw with that spec is is 1, it's, you know, defined in terms of RDF using JSON LD but it's also verifiable credential, w3c verifiable credential. So as we start to see more use cases such that such as access tokens for this, bringing in something like W through C verifiable credentials, Dids, and all of those other dependencies in order to be able to basically process whether or not an access token was still valid. It's just untenable. Thanks, David. Oliver. Yeah. To to life's point earlier, I think if you really wanna support additional status methods specifically for credentials in the future. And this could be also done in the SD chart this e spec. So currently, we have a Pointer to status list as a value for a status claim, which, you know, basically means go to status list. But in the future, if you really wanna do something like geographic accumulators and so on. You could justify a new claim and, and point to an different specs. We don't need to solve it in the statutory stack. That's what I'm trying to say. Okay. Thanks, Paul. Thank you, everyone, for great discussions. And, We're done. See you on Friday. Phones."
  }
]
