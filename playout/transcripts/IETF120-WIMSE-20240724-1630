[
  {
    "startTime": "00:00:02",
    "text": "great All right. All right. Let's get started All right, good morning everybody and welcome to the third day of IETF 120. This is Wimsy. So if you're not here to talk about workloads and related things, or you sit down down down Anyway, I am Justin, one of your co-chairs, joined by I'm Peter your other co-chair and we are looking forward to our session today Yes, it's the second only ever session of Wimsy, and we have a very full schedule ahead of us. First off, third day of the meeting please note the note well well roughly boils down to be nice to each other, focus on the technical work and there's a lot of really important detail about how all of that works right there Okay, Wimsy and Casey you missed it, is workload identity and multi-system environments with our beautifully guard AI-generated logo there, although this is the one with the corrected text. And I kind of like to AI generated logo there, although this is the one with the corrected text. And I kind of liked the work glop version, but yeah In any event, we are here to talk about work version but yeah in any event we are here to talk about workloads we're not going to dive into detail about what that means here. We're hoping you've got the background of what the work is and does Today we're going to be, we've got a lot on the schedule We've got two drafts in flight. We're going to be getting an update on each of those. And then we have the output from our two design teams. And then finally we've got the authentication levels for workloads presentation from"
  },
  {
    "startTime": "00:02:00",
    "text": "Ryan Hurst. And finally, we'll left a small amount of time for any other business before going to the end So don't want to take up too much time with this overhead If you haven't, please join the mailing list. We also now have an official GitHub repository. We've done a lot of setup between IETF 119 and now So we've got a GitHub organization This is where all of the drafts that are in the working group are going to be living And so yes go check both of those out. We have two working group documents. We'll hear more details about those in a minute working group architecture and OAuth client authentication BCP. I think I've seen about seven different permutations of this document title. We'll get it consistent at some point um but as i understand that is also one of the questions that the that the have to the group is the title and scope of the documents So we'll get there. And finally, I want to give an absolutely massive thing to both of our design teams We spun these up very quickly after IETF 119 to give these two very important topics a kind of a running start. These are folks that went out and did a bunch of research and collected a lot of sort of starting ideas on this area on these areas, and they have created three different drafts for the working groups consideration There are also some individual drafts that that got submitted at the same time and none of these are working group documents yet. And I'll leave it to the design teams to, just, uh, to say think all of this goes during their presentations But seriously though, big round of applause too the design teams. Thank you all very much And that's all I had for intro, Peter, do you have anything? to add? No, I think that's everything"
  },
  {
    "startTime": "00:04:00",
    "text": "Let's get going. All right so first up, we have Lindsay Architecture. How do I? How do I say yes to Joe? request? Can you put it in again? Oh, there it is. It was a pop-up my bet You should have oh, yeah, sorry, let me, I think I need to unshare And you got to All right. Perfect. Thank you All right. Hello everyone I'm Joe Salloway and I'm going to talk about the work we've done on the Wimsy Architecture spec since last meeting. Also, working with my co-authors Honus and Yoroslav were also here. But I got the privilege of talking to you all So we'll talk again give a brief status update then some of the most significant discussion we've had has been on Wimsy Identify We'll talk a little bit about some use cases in deployment models. But kind of the first thing is we identified we'll talk a little bit about some use cases in deployment models but kind of the first thing is we've published zero zero which was kind of the just bringing the document into the working group and then a brief short rev to a zero one since the last IETF perhaps we haven't made it quite as much progress on this as we might have liked due to participating on the design teams and also waiting for some of the design team work to kind of coalesce so we can get an idea of kind of how things are shaping up for the architecture But one area which we focus"
  },
  {
    "startTime": "00:06:00",
    "text": "on, because, you know, having participated, with the service-to-service authentication team, saw that there is going to be some thing we're going to have to discuss about workload identities so we'll cover that a little bit today. And thank you for a everybody who's been participating in that discussion We also, based on some feedback, started to set separate out some of the use cases that were combined together like authentication and authorization, we've separated those out into two different sections, which makes perfect sense but just not how we started started All right, so the way, uh, way kind of the text started in the document was having a very sort of general discussion of identity and numerous people have pointed out what a trap this is to fall into and so taking some feedback from that I've tried to scope it down and working on scoping it down even more to let's focus initially on an identifier. There'll be other aspects of identity that no doubt we will be talking about within this group and in the architecture document, but it's probably not better it's probably better not to try to start from that point but work to those different areas as we get to them because, or else, yeah, became pretty clear that we could very easily try to boil the ocean here So we'll be right now from what the working group is has kind of pointed us towards we'll be focused on defining identifier now what is the identifier? This is, you know, a string to identify a workload. What is a workload? Well, we have kind of a definition for that. All of these things we're going to have to refine as we go Because there's, I know from talking"
  },
  {
    "startTime": "00:08:00",
    "text": "to people both here and on the list, that there's different you know views on how all these things go. But what we're starting with right now and this is, is an identity is in the format of a URI And this is convenient for a number of reasons one we have some well-understood deployed mechanisms that you this identifier namely Spiffy has formatted their identifier as a URI URIs are nice, they have good definition We can write a very good definition for what are you has formatted their identifier as a URI. URIs are nice, they have good definitions. We can write a very good definition for what our URI contains possibly And there are also easy, well-defined ways to include these things in different types of credentials such as JWTs and XP are also easy, well-defined ways to include these things in different types of credentials such as JWTs and X509 certificates, right? So this kind of already ways of doing that Now we've had some discussion of whether, you know, what is this you are? had some discussion of whether, you know, what is this URI going to be? I mean, we could just say it's a URI and not provide any format. I think where we like to go is that there is a basic format to it that defines a scheme a trust domain, and then a path. You'll notice if you're familiar with Spiffy that this is very similar to what Spiffy does. Because it may some sense. You know, a trust domain is kind of an important concept to us because this helps us understand what the scope of that credential is and it points as to how we would verify the issuer of that token or verify that that token was issued by the correct entity So schemes, you know,"
  },
  {
    "startTime": "00:10:00",
    "text": "should we, there's some options we have here. We can allow the scheme to be defined have a registration of different schemes and provides some basic formatting for that or basic requirements on those We could go with the pre-existing scheme and say, hey, we're just going to tie on this 50. This might be a little bit too restricted for us, but maybe something we should consider. Or we can fix it go with the pre-existing scheme and say, hey, we're just gonna tie on this 50. This might be a little bit too restrictive for us, but maybe something we should consider. Or we can fix the scheme as whimsy and then maybe define other schemes later if we need to. Fleming Yeah, Fleming trace, if you can just go back to the previous slide when you were talking about identity i just want to make sure understand correctly. So you... Fleming, yes thank you. When you're talking about identity, I wanna make sure understand correctly. Are you saying that you're going to change what's in the draft right? now to talk less about some of the attributes etc and just focus on the identifier aspect, or you think that that's reflected in the current draft? No, I think we're going to update the draft to reflect to be more focused on identity, on identify Okay. Okay. That doesn't mean we're going to ignore the other aspects of identity, but I think those will follow on in in topics of their own okay that makes sense because because there this way we can be very concise about this action in topics of their own okay that makes sense because because you know this this way we can be very concise about this aspect of it and then like when we come up to say like okay how do we compose you know and maybe we have a complex workload or a complex object How do those things get represented? That I think is a broader topic or a different topic that we can tackle in a different way. Agreed. Okay thank you Richard. Yeah, sorry, just trying to follow on here. Sorry if I've missed something. We have identifier syntax or talking about identifiers here. Do we have a clear idea of what the thing is that we are identifying? with these identifiers? Yes, we do We have a definition of a workload"
  },
  {
    "startTime": "00:12:00",
    "text": "Okay. And that's what we're identifying here. Now, is how concise is that there may be so different views of what that is in this room but it it defined in this respect but the idea is this is identifying the workloads that we were talking yes Not like issuers or some other related things No, I mean, so there are related things like we will need to deal with issuers in some way And that somehow related to trust domain that will have to define problems but this is not specifically dealing with issue. I mean, perhaps an issuer is also a workload and has a workload identity I don't know at this point, that would be a good discussion That's great, thanks All right, I think I covered here So, you know, there's this, I think one of the decision points is how closely do we want to be tied to Spiffy? Do we want to talk? closely to Spiffy? Do we want to? provide flexibility from the outset? of like well we can define one scheme here and then you know, if we happen to have a different requirement, because one, of the aspects of one of the aspects of uh, the, is this path element which is fairly unstructured in Spiffy and right now, for us, it's unstructured, but different we could define more structure for that which would give us maybe ways of doing authoriz you know, okay, I think maybe I talked about that We talk about trust domain, just to go to the path, you know, you, you know, there are different ways, deployments, to do this today. You can specify roles, namespace just an opaque identifier Maybe we define different schemes for different types of things, or we just leave that definition of what the actual composes"
  },
  {
    "startTime": "00:14:00",
    "text": "the identity up to the deployment itself and we don't have to, you know, define that here. But going back you know, the trust domain is an important aspect of this because it's kind of defining the namespace for these identities and how things will be issued you know, in there'll be things to discuss about, you know, configuration or how does this trust domain get mapped to an issuer, right? This is could be static configuration or we can define discovery mechanisms for this all of that is, will be an important to discuss um Some of the discussion we've had in both the service to service team and and the architecture team is when we talk about a trust domain what is that right now, most of the time, it's a host name How strict do we want it to be about being a host name? Is this like a domain name that's actually registered? so that we can ensure some sort of uniqueness? We've had kind of different discussions there that, you know, we don't registering seems like maybe it's a high bar but on the other hand, it does help us get to this unique aspect of the trust domain, which is some know registering seems like maybe it's a high bar, but on the other hand, it does help us get to this unique aspect of the trust domain, which is something that we really would kind of need We have net on the Q. Yeah this unique aspect of the trust domain, which is something that we really would kind of need. We have net on the queue. Yeah, in the draft, it mentions that a domain could also be tied to an X 509 certificate. It wasn't clear to make if you were referring to one of the attributes in the certificate field like the subject alt name or if you were referring to the key itself So it would be the identity we go in the subject alt name field, is that what you were asked? Well, you could say that the domain is defined by some name structure inside of"
  },
  {
    "startTime": "00:16:00",
    "text": "a certificate, or you could say it's defined in terms of a key Yeah, so I think right now, that's sort of an open issue. I think we could go different ways on, but the way I think we've been going is that the trust domain is part of the identified right? So if we go back to this format trust domain is in the ID identifier now in the x509 world that trust domain probably maps to issuers that are CAs right? We haven't defined what that looks like so I this is, you know, work in progress So if you have thoughts or opinions on this, it would be good to work through them Just trying to get the concepts. Yeah Hey, Joe, you meant, you meant trust domain defines the path Can you explain that a little bit more? Because to me, those are different parts of the of the identifier, and I'm not sure how they're related to defining each other. Maybe you can explain a little more. Yeah, maybe the define isn't quite the right word, but the trust domain is going to define who are the set of issuers and the issue need to be coordinated in how they're going to issue the identities or what is what is the namespace for that identities and and how those identities are formatted so it may not be exactly correct to say that it's the trust domain but the trust domain ultimately it's going to have to coordinate some way that it will, you know, that those identifiers have meaning within that"
  },
  {
    "startTime": "00:18:00",
    "text": "trust domain within that domain within that domain within that you know reusing that same word but And I thought I heard you before mention that, um, path is probably defined in a format based on the scheme so those two things seem like they may be in conflict I don't know if we need to kind of work that out in the next revision Yeah, definitely we do. They are sort of in conflict. The scheme, you know depends on how we want to do it. If we want to be very strong of work that out in an extra vision. Yeah, definitely we do. They are sort of in conflict. The scheme, you know, it depends on how we want to do it. If we want to be very structured about what these things are and say yes like, we want the scheme to always have something that we call a role and something we call an instinct and that means something when we talk about authorization then we could do that with the scheme and say, yeah, you can have different trust domains, but they're always going to issue identifiers that look like this Perfect. Or we go and say, well, okay, we're always going to use a scheme of women and then, you know, trust domains get to do what they want and we may give them some options so they can de-conflict, you know, make sure they're not issuing things are conflicting, but it's really not up to us to make those decisions at this point. Okay sounds good. Thank you. All right, Darren on the queue. If you'd like to ask a question, please join the queue. And also just a reminder to every in the room, please sign in using the on-site meeting tool Hey, just a couple properties that I'd love to see hold true from the perspective of folks who will be using these IDs for authorization purposes One is a question about will they be recyclable? like can a workload ID be issued to a completely different work? at a different point in time, in which case those holding persistent authorization rules could have issues there The other is just the more information we might pack into a path that needs to be parsed out, like roles and so on Just historically, we've seen a lot of security incidents come down to just incorrect parsing and normalization of paths"
  },
  {
    "startTime": "00:20:00",
    "text": "And so it's just kind of a risk there in terms of like maybe setting people up to fail if we mandate a lot of parsing of paths to extract properties So with respect to that, do you think that having that well defined would be helpful or is it? just something that we would want to avoid avoid? I'm less opinion on exactly what's in there, but the property, you know, like, if it was a UU, though, maybe a UU and just a little bit of information about a UID, it tends to be pretty safe, it's not recyclable, you have to go somewhere else to understand the properties about that, whether it's test or production I understand there were tradeoffs about that. Sure But I think those properties would be helpful that authorize parties may be interested in would be helpful to kind of nail down and keep in mind. Okay, thanks Yeah, that sounds like good, good topics Daniel. Just have a question, if we move to the XIVE and I world, do we expect to have the full identity? as an URI into the sand? or is it something else that we expect? The full URI would go into a URI sand field Yeah. Evan? gilman Spiral. I just wanted to kind of tag on to the earlier comment about authorization we've historically seen a lot of people in Smithy community trying to overload these IDs with all kinds of stuff for the purposes of authorizations specifically usually like ABAC. And it is super dangerous, and we've seen lots of problems there When I talk to folks, I generally try to steer them away from this. Okay. And we give guidelines around like, hey, you know, you want it just enough in the path that is like human readable and meaningful to you, but like you don't want like if you need all of these other attributes to process your authorization policy, you need to kind of ship them separately. So similar to the Guit comment earlier where you do like a look aside or if you're like bundling this stuff up and shipping it"
  },
  {
    "startTime": "00:22:00",
    "text": "out of band and then, you know, an authorizer is looking at the caller and this kind of locally cashed up. There's a lot of different patterns there, but I would generally give a strong plus one to you know at least guidance or spec around hey please, please don't put query parameters on this thing and all kinds of other stuff. Got it, got it yeah okay thank you um or spec around, hey, please don't put query parameters on this thing and all kinds of other stuff. Got it, got it. Yeah, okay, thank you. I'm gonna speed on here since we're running. I don't want to go too far over time here or at all so another thing that we've been discussing amongst the authors here is, you know, we're defining a, we have a bunch of use cases some of these use cases are fleshed out Some of them aren't. There's been a we've also had some discussions on the list in a amongst groups of people about attestation. That's not something that we've included in here it's even questionable whether these types of topics should be called use cases, but that that's list and amongst groups of people about attestation. That's not something that we've included in here. It's even questionable whether these types of topics should be called use cases, but that's what we're calling them right now. What we're wanna do is get more feedback on what should we be including in use cases What are we missing? What should we be? fleshing out more if you have thought? that that would be great let me we missing? What should we be fleshing out more if you have thoughts? That would be great. Fleming. Fleming and Reyes and Cisco. Yeah, on the use case so we talked a little bit about it, right? But I definitely think that the delegation and impersonation, for example, is an important use case which goes back to a more fundamental question my opinion, which is, again, the definition of a word right? But I definitely think that the delegation and impersonation, for example, is an important use case, which goes back to a more fundamental question, my opinion, which is, again, the definition of a workload, right? It can be many different things that could be a single process, they could be multiple processes, They could be a bunch of processes, a whole application, etc And each of those have sometimes separate use cases and do you want to be able to combine those? And what does that then mean? Do we need to have multiple identifiers? in a single scenario for that as, you know, an example, consider maybe I want to do segment able to combine those? And what does that then mean? Do we need to have multiple identifiers in a single scenario for that? As an example, consider maybe I want to use segmentation and access control between two different workloads That would probably have what I would call the native workload identifiers that you would want to leverage, but I might"
  },
  {
    "startTime": "00:24:00",
    "text": "want to do delegation and impersonation as part of that flow as well at the same time, which is a separate identity that I would need to do that. So how do these use cases then in a link with one another and what does that mean for the kinds of things we have to convey? So I think that those are some important considerations that we have to address fairly early on Okay, yeah, I mean, I think those those will be important as well yeah I agree The other thing, you know, we also want to look at how these things will be deployed Because, you know, it's great to go talk about all these identifiers and what they look like, but until, you know, we kind of have some idea of how people are going to use these things, So we thought it might be good to cover some deployment models and there are things like, well, you know, this could be deployed in a service mesh or their API gateway type of models you know application libraries are these things going to be important for us, or is it really boiled down? to the same thing? I'm not sure. It seems like there's an awful lot of common between these things, but maybe there are substantial different between the way people want to deploy this type of solution I mean, I think. You are about out of time here. So I think so I think... Okay, not too much, though uh so next steps uh align with the other uh with what the design team output has you know, how that shapes up. We want to make sure we stay in alignment with that. Continue to work on Luce use cases and I just talked about deployment models so that's kind of where we're at so thanks for the discussion and we'll look forward to seeing you on the list All right. Thanks, Joe Honest, do you want me to run the slides? Yeah, my presentation is"
  },
  {
    "startTime": "00:26:00",
    "text": "brief Oh, type of it The link to the draft is now correct. Who noticed that? Who is still wondering what I'm talking about? Okay, this is not HBKE Although we could imagine one solution. We are not true chartered to discuss HPKE So I talked about the PCP document which in those who have been following the work may notice that we actually adjusted the title to get it in line with what's actually in the document And I get back to that a little later when we talk about the scope and how we want to advance the document. You may also notice that a few people joined us, Eduardo Jaroslav and Aunt. Thanks for the help and also we have a couple of site meetings to flash out the D details so we have updated the document quite a bit. Next slide. So lots of changes if you look at the div two versions submitted uh zero zero was as usual kind of a call of the individual submission as it is pretty done. In version one, we then shortened the document improved the editorial parts, added the co-authors, changed the title in accordance to what the draft act actually contained. It was much broader before that from a title point of view. Next slide. Just as a short summary of what we had in there, I spoke about this already. I think two times in the meanwhile, but the version is, so there's different ways to get an initial token So this is focused on a parallel token usage. So you get an initial token somehow"
  },
  {
    "startTime": "00:28:00",
    "text": "in this diagram and in the document, we talk about this initial token, the service account token. And this is comes through, for example, some here referred as control plane some other protocol, presumably also using some platform at the attestation uh choh just talked about this and that's more or less outside this scope. It just starts when the workload actually gets that information. We also don't mandate the specific way for the workload to obtain that information, three different techniques have more or less emerged Environmental variables should reading from a file or using local sockets and sort of communication between the underlying infrastructure and the workloads. So in some sense it doesn't matter how the workload gets it but the important point here with the document is that one pattern emerged and it seems to be quite useful, is if you use a JWT, which is what the document focuses on, it used or in this description, uses RFC 7523 which is the OAS client authentication with the JWD. And that is then presented to an authorization server to get consequently an access token And that access token is then like the final goal in this exchange to then talk to other workloads that offer the services and act like resource servers So it's a kind of, in some sense and that's a good, that's a feature it's a simple mechanism. We talk about the different security considerations of that solution in the document so I think that's pretty well flashed out And as I said, like this is a baritoken approach it doesn't have like other solutions like for example x509 certificates it doesn't have a key associated with it. So there's no proof of possession here in any shape or form"
  },
  {
    "startTime": "00:30:00",
    "text": "but yeah so that's what we have today and it gets me to the important point where i want your feedback on is and we believe we have two possible directions we could go to the next slide The first direction is which my errors got replaced with boxes so we can stay narrow as the document type currently says and the content says as well, and just do work on this document like we initially we call it the PCB and also from the type of document because that seems to be what many people are doing today in terms of solution and so if that's your preference, if that's the group's preference, we should probably ask the working group for a working group last call soon. There may be some issues with getting the terminology aligned with the architecture and all the other stuff that Joe talked about previously So Delta, those type of changes, we would be more or less done with this It's kind of weird. I don't think I've ever been in the in a working group which started and created something very quickly rather than sort of discussing it for years um so i feel somewhat uncomfortable with that approach Do you want to finish this slide or take the question now? No, no, go forward Thank you. flemming andreasen Just a clarifying question because it's not obvious to me when I read the document. Is the purpose of documenting what is happening in the region? world today? Or is the purpose to say these are the recommendations from the working group as to what you should be doing? Because based on my what the answer that question is, I think that that affects what we want to do here yes No, just kidding. Yeah, the term PCP has been interpreted very loosely uh best current practice. So it could be an desirable practice, but interpreted very loosely uh best current practice so it could be an a desirable practice uh but uh my understanding of the work of this specific work"
  },
  {
    "startTime": "00:32:00",
    "text": "was more like out of all what people are doing today this is the best version of the current practice rather than this is what we could do at some point in time, and then it would probably be the best version right so sorry go ahead yeah because obviously right so I mean you have to pull it up there already, right, about, you know, proof of possession, the next five one then it would probably be the best version. Right, so sorry, go ahead. Yeah, because obviously, right, so I mean, you have the bullet up there already, right, about, you know, proof of possession in the next 519. There are other documents in the working group that are addressing that, so it seems kind of strange that best current practices doesn't talk about that. But I guess that's part of the discussion we're going to have here. Yeah. Okay Thank you. So just very quick the chairs have been pinged by the ades about the terminology of calling this document a BCP or not and sort of where it fits within the ID ADs about the terminology of calling this document a BCP or not, and sort of where it fits within the IETF document stream. A lot of that boils down to exactly how the working group wants to answer this question. Is this going to be an opinionated document? about these are things that exist and this is the right way, recommended way to do this, or is this going to be more of a an informational document of the are the options, go choose what you want? kind of thing? This is exactly the kind of scope that this slide is asking that the working group needs to answer for us to figure out what kind of document we want this to be. To be clear we have the flexibility to make this the type of document that it needs to be, but we have to, we should decide soon what that, what that is evan gilman, Spiral Forgive me, I'm not super familiar with the bear RFC mentioned earlier. I'm wondering if either in that RFC or your doc if you're, I noticed in the diagram and that did that, or lack thereof, talking about how that bear took"
  },
  {
    "startTime": "00:34:00",
    "text": "wondering if either in that RFC or the doc or your doc, if you're, I noticed in the diagram and that, or lack thereof, talking about how that bearer token is validated and where those validation keys, how they're obtained and like this kind of validation part of the story, when the workload presents that bearer token, too. So, repeat that you're not quite sure where the keys are. When when validation part of the story, when the workload presents that bear token too. So repeat that, you're not quite sure where the keys are. When, very there, thank you, when the workload contacts the authorization server, using its platform token or whatever as a bearer the authorization server presumably needs to validate that bearer token and the mechanics around that validation. Yeah. Wait sure we could do a better chop, but I just actually, before the meeting, I read through the text again, and we have some pointers in there But like your question indicates that we should improve that. Yeah, I see a lot, I think this applies. I can think of several platforms that this pattern applies to um my question would be hey can we close the gap on the validation side you know how does the authorization server get back to you know the keys that it needs to validate that bearer token? And if that's looking good across all these various platforms, then, you know, maybe BCP is kind of a good choice because we can say, like, hey, look, here's the recommended for bootstrapping workloads into OI wealth system, like here is recommended best practice using platform tokens here's how you validate it, this is the bear token exchange or whatever mechanism you call it, seems pretty clear to me but we but i think to do that we would need to fill in that validation yeah at the moment it it points to some forgot the number RFC from the OS working group on metadata um but and so for example if that RFC uh uh, forgot the number of RFC from the OS working group of metadata. Um, but. And so for, for example, if that RFC, um, requires you to register the client with it with a public key or something like this that it is using to validate then I think we would need to describe yeah how that happens from, you know, Kubernetes or GitHub or whatever Yeah, I think that would be a good addition, irrespective on how we answer the next, the questions on the next slide It sounds like very good feedback thanks thank you honest"
  },
  {
    "startTime": "00:36:00",
    "text": "Yeah, I personally don't have a stronger opinion on which direction we should go out of those that were just mentioned also I'm not religious about it should go out of those that were just mentioned. Also, I'm not religious about the type of the document. Actually, I don't care. I couldn't care less so I'm really sort of up for feedback on what you guys consider to be most valuable for whatever you do in your companies. Brian Somebody said yesterday words matter and I know there's been a lot of talk about what this isn't, but I'm, I'm and have gone back even into the boffs around some of this stuff I'm really personally uncomfortable with the word best in our description of current practice in this. And I think it, I know there's different interpretations, but outside of this weird world of the IETF that we're in, it conveyed something that I don't think we want this document to be trying to convey This is a description of a current practice that some people are using the word best really regardless of which way we go here, I would very, very much like to see that not connect Yeah. Well, of course, you know where the best comes from, like in terms of types of documents, PCP documents but I, as said, like, I have no problems, like, just omitting the best current practice and just call it an informational document or whatever It's like I don't think it, reduces the quality of anything that is in there right it's uh definitely concur with that and you say I don't actually know where the best one I've been doing an IETF for 12 or 15 years or something, and even I don't really understand what that means and I think it's important to realize when we look outside of this world that most people don't understand a lot"
  },
  {
    "startTime": "00:38:00",
    "text": "of our weirdness is an intricacy and and vice versa Fair, that's fair And compared to like the TLSBC intricacies and compared to that's fair and compared to like the TLS BCP that is really used as a it's conveyed as an authoritative, this is what you should be doing The word best just, yeah. Right so informational would be i guess my all right no thanks Brian that's great and that's exactly the type of discussion, the working group needs to come down on with an opinion about what the purpose of this document is in our messaging to the world But Brian, since you're on a microphone, so how would you answer the other question, like if you say, okay, because among the authors, we've been struggling exactly with the best current problems, I'm actually going to, if you're asking Brian, to specifically answer this question, the chairs would like to actually get a feel for the group as a whole Okay, that's even better. Thank you. Grill Brian thank you. Grill Brian? Uh, Mark oh hi so um when we talk about um you know this working group is, you know, I'll make kind of a shameous plug and perhaps it's a little aspirational, but by the time this working group completes what it's doing i expect that we're going to have a pretty broad adoption of confidential computing. So as far as price, i would actually uh step away from bearer tokens and move towards bound credentials. And I would prioritize figuring out the role of remote attestation in this So, you know, there is a whole host of questions about how these things would integrate but be impact in the industry can be absolutely tremendous if we get this right. So again probably not a good forum to go to deep"
  },
  {
    "startTime": "00:40:00",
    "text": "into this, but when I hear, okay, we'll illustrate this and it's going to be bare a token, that says, why are we effectively going backwards? Yep. Hi, Mark good to see um the that's a that's a very good comment uh actually in preparation for this meeting, the architecture also got together and talked about specifically confidential computing and confidential containers and how they actually match to the architecture And they are it's true that you need more functionality, but it's not just the proof possession functionality. You need remote attestation and a couple of other pieces as well to get this sort of like solid. And that's where the part of best current practices kind of would be getting our way because I don't think it's fair to say that confidential containers is really the current practice by any stretch of imagination So it's more than that future containers. It's more about more than containers right? Before you talk about, like you have a token server on your control plane, well, that could be your attestation service And then when you say we're going to have a dance with our authorization server to go reach a relying party, there is no reason for that to be a better token based exchange so that, and it's not just about containers, pretty much anywhere workload that you confidential DM is likewise in scope for this. So when you say about like actual customers seeking to adopt this, you know, we would like representing a lot likewise in scope for this. So when you say about actual customers seeking to adopt this, we would like representing a large financial institution, you know, do the most forward like representing a large financial institution, you know, do the most forward-looking thing actually at this point and skip the intermediate step that carries over some of the, you know, problems we're actually trying to step away from otherwise by water Okay. Yeah, here you um here you say that we should really sort of like as we change this the title of the document again"
  },
  {
    "startTime": "00:42:00",
    "text": "we should also add that functionality in there. That's what I heard. It was a little, the audio was a lot should really sort of, like as we change the title of the document again, we should also add that functionality in there. That's what I heard. It was a little, the audio was a little bit. Yeah, and this is so I think this is going to be a really important discussion to take to the list to determine, but I'd like to drain the queue and the chairs would like to get the feel of the room on a couple of topics here flemming andreasen. Yeah, I agree with Brian. I mean, I think this is definitely informational I'm also uncomfortable with the use of the term best, etc cetera. I think the focus is too narrow, right? now. I mean, we know that there are people doing other things out there right? X-509 is used. I think there's value in document what people are using, and there are definitely multiple different scenarios, and I think we should try to expand the scope to cover them of those Arndt Arndt. And thank you, Mr. Microsoft I'm favoring number one to keep it narrow. For two reasons, like one reason mainly is that this is already happening all major container orchestrators, AWS, TCP, and Microsoft as well are doing this and we really see value in describing it whether it's best current practices, informative. I really see value describing it. Also, like, to give security recommendation on what needs to happen and what are the pIETFalls and so on um and second I think wen lin general need to have a conversation whether we see Kubernetes as a whimsy environment because it's broadly adopted And for example, before in show's presentation we said every WIMA, workload entity has a UI, right? But Kubernetes describes them as Uran. So we can of lose Kubernetes adoption. And I think this is something also valuable, valuable to consider now"
  },
  {
    "startTime": "00:44:00",
    "text": "because in here we focus on Kubernetes and describe what's happening but then further on we're going to say like, hey, we want to have key binding and all these things but we all my opinion, should always have a look on what Kubernetes is doing and how we can get maybe them adopted as well Thanks, Hart. Jeff Yeah, Jeff. So very quick, just reenfezing that this is effectively like two narrow we need like more best practices around all of that. And I think that by doing the work, you will also highlight what might be missing as we speak and refuel the whimsy workgroup with maybe additional questions that will allow the whimsy work group to be able to tackle to tackle new features, new patterns on how to move forward. And then he will refuel your own BCP document to be shown that you are like exposing those new best projects thanks to the new standard that you try to establish For O2, it's the BCP are a good document, but they came very late A lot of adoption already started before that, and a lot of customers from my perspective went the wrong way, and we had to correct that after what if you started from day one then you will allow maybe more people to start on the good fit from the beginning thank you jay Jeff All right, so just a quick show of hands in the room and feel free to pipe up on chat Who here has read the current version of this draft? That's actually quite a lot of people no you want to do a polls No. It's more than the authors as best as I can tell. So that's great for our second working group meeting. I am thrilled with"
  },
  {
    "startTime": "00:46:00",
    "text": "this result. All right so the second bit is you know, is the scoping question, which we will of course course hang on, sorry, the scope is yes, no all right. I would say yes So hang on, let me try that again Why didn't the scope? Because I don't know how to edit the options here real quick Do, I would just want to get a feel of people, do we want to widen the scope of the document from where? it currently is or a no answer is, no, keep it the way that it, that it is current defined and intended? Just not pretty I'm honestly saying is that that's pretty it's yeah Okay, yeah that that's pretty It's yeah, okay, I was going to say it was pretty inconclusive, but then a bunch a bunch more started rolling in um we will we will put out an official call to the list and solicit feedback on what people think the expanded scope should include. I do want to, and we will do this in the email to the list I do want to caution everybody to stay within the bounds of our charter and something that is actually delus deliverable when we're discussing what the scope is for this document. And this will be the scope for this specific document, not for the group. Right. Thank you And so we could always have other documents that address other related topics. It could even be very closely related in a separate document But we will take the chairs will take this to the list Thank you, Honest. I think that we've got a good direction"
  },
  {
    "startTime": "00:48:02",
    "text": "All right, next up, we have Yaron and I think you're going to be joined by a few people on this one, if I recall Yarin and the ban. Do you want us to share? Yes, please No, please Yeah, sure All right. So I'll be talking about the results of the service to service design team. We published shortly before the cut-of-date version zero zero of the draft um i'm i was a come I am accompanied by Brian and joe here as well as the aunt and dan am accompanied by Brian and Joe here as well as the aunt and Daniel who participated in the design team. Next please So the focus of service to service is on one atomic component of the architecture workload A or service A depends on how you want to call it. Workload A is making a call to workload B We will be focusing on that We are assuming an identity site that used that's used by both workloads to obtain the a credential and we'll be saying a few words about this credential And we also want to remember that does that does in authorization decision taking place so we have a policy and"
  },
  {
    "startTime": "00:50:00",
    "text": "enforcement point and potentially a policy decision point, basically authorization as to where workload be is willing to accept a service call from workload A Next In the context of what we are, which Geron just spoke about, I wanted to sort of briefly mention and clarify a number of things that we are not trying to do here because I feel like there's a lot of expectations and varying expectations around what is being defined where and where sort of the lines of our charter and work gets drawn so one thing we are not doing is conveying the call chain or call stack or the full context of the invocation via some kind of direct-lib acyclic graph or any anything like that. It's one service to another service. We're not accounting for any kind of cross-domain anything. There are already quite a few pieces of work in this area that I don't know if it's worthwhile for this group to try to point to or discuss or try to raise awareness of or even profile additional work if they are somehow insufficient but already there exists the RFC that Hanes mentioned earlier using for client authentication also defines a authorization grant profile that was very much and very explicitly designed to facilitate federated or cross-domain sort of authorization from obtaining an access token from one domain through the federal sign token from another domain There is currently work in the Oath working group going on right now to sort of further profile, describe the use of that"
  },
  {
    "startTime": "00:52:00",
    "text": "as well as a token exchange mechanism for a obtaining a proper cross- jot That's called, I'll read the long definition there Oath identity and authorization chaining across domains that works in progress right now. It's not really defining anything new, but describing how token exchange, the cross domain profile could be used together as well as a pointer to the OAuth authorization server discovery and metadata document about how to obtain and understand key although I think that's kind of backwards actually not thinking about some of the things Evan was asking for probably still aren't described anywhere particularly well We're also not doing whatever some huge providers out there insist on calling Open ID Connect, which is sort of a variant nonsense pattern of the two things I described above, but they call it Open ID Connect. It's not in any way Open ID Connect but there seems to be sort of a branding or naming confusion out there that is well being the scope of what I have to kind of rein into the world but it's a very similar pattern to those things that's described above with slightly different formatting I think using some of the maybe it's called Open ID Connect because it uses some of the Open ID Connect metadata to express keys probably around some of the same reasons that Evan was referring to earlier. I'd love to have some of that name sort of clarified or better understood but it kind of falls out of scope of this document And we're also not covering whatever whimsy might be doing with respect to token exchange, probably trying to describe and readdress some of these same problems in different ways that I apologize. I haven't read the draft yet We are also not conveying anything here about the external authentication or authorization context of the call"
  },
  {
    "startTime": "00:54:00",
    "text": "that kicked off whatever it is we're doing that would cause these two services to try to authenticate with one another um context of the call that kicked off whatever it is we're doing that would cause these two services to try to authenticate with one another, but we do try to allow for or mention that that might be conveyed through the call chain And there's other work and practice that try to allow for these things, one of them is the transactions token work that's also happening with Oath that I guess I was already talked about this week but it is a draft that tries to describe a token format suitable to convey and express the context of a particular transaction not the workloads involved, but the large transaction context And we, wen lin this work, try to allow for that and mention that it might be there, but it is not specifically part of this or some sort of o-off bear token, oftentimes what we saw in the last thing, are being used to express something about the authentication authorizes context of the whole thing. Sometimes this is an external token Anyway, we're not trying to convey anything about it We have some callouts to allow for the service to service authentication to provide for integrity of or binding to that stuff, but not do anything with it specifically. And it's been said in a couple of different places, we're not describing anything about the distributing or provision or obtainment of any of these credentials to the workflows themselves. That's happening somehow but it's sort of out of scope of this pretty good document. So we're not doing a lot Next slide, please that was really a bummer all right so this slide is it looks like a bunch of blocks, but it's really an old overview of what we have in the document So our opinion is that we need to"
  },
  {
    "startTime": "00:56:00",
    "text": "provide two alternatives to users of Wimsy One is transport level with mutual TLS, and one is authorization, authentication in the application level For that one, for the application, level option, we present two alternatives in the document And it's our belief that once the document is adopted, the working group will need to choose whether we prefer option one which is inspired by the Deepop solution in Oath or option two, which is based on HDC message signatures it probably doesn't make sense to give providers both of these options But long term, again, we believe we need both a transport level solution and an application level solution and that there will be maybe not very common but there will be deployments that use both for different types or different subsystems within the deployments. Next I think you want two slides two sides oh okay slide back one forward one Okay, that's an easy one, identity. So, Joe started by writing section on identity inside of the service to service draft, but this work is happening and was a eloquently described by Joe in the architecture document. Next"
  },
  {
    "startTime": "00:58:03",
    "text": "Okay, among the application level authentication mechanisms, there's one commonality which is the whimsy identity token, tentative being referred to by the acronym WIT This is in many cases, I don't know it is sort of similar to a certificate. This is the token the credential which describes or is the credential for the individual workload itself and would be conveyed as in conjunction with either of the two applications level authentication mechanisms within this token it's a jot it is a sign jot specifically so is the WS signed with some asymmetric signature algorithm. It's explicitly typed just to say, hey, this is a specific kind of jot that is this thing It has a few requirements claims or attributes, the issuer, which is the identity of the we're calling it identity server or whatever the system it is that governs the trust for this whole thing and issued the token It has a subject, which is a both of these are URIs, back to the identity conversation that's kind of all that we were able to get to um token it has a subject which is a both of these are URIs back to the identity conversation that's kind of all that we were able to get to and maybe is the appropriate level of abstract here, but these are both URIs identifying the system In the example itself, I used sort of hypothetical whimsy scheme, but it's just a example of a URI that might be in here. There's an expiration on this. There's a unique identifier for the token And very importantly, there is a bind to a key. So the CNF claim is from the jot world, and it is basically saying that in order to use this token, which is the workload identity, you must also present proof of possession of the"
  },
  {
    "startTime": "01:00:00",
    "text": "private key corresponding to the public key embedded in this claim. Here we're showing just a example of that But importantly, it is not a bearer token. It is a jot that identifies the workload identity just by URI right now and binds that identity to a key The key must in turn be shown proof of possession on presentation using one of the two options that you're on described Next slide will describe one of those The depop-inspired option is a proof of possession mechanism that is similar to but distinct from depops who are using inspired there. It is not deep out of itself, but it uses a lot of the same concept Basically, that is you see the the identity token in a header previously. I think I skipped over the name of it. And you also send a proof token, which is the proof of possession of the key bound in that identity token in the context of this HGB request. So this, this is also a jot, but it's sent with every request meant it anew, and it has a few attributes in it that attempt to sort of sufficiently show proof of possession of the key in the context of this particular HP request It has normal stuff. It's explicitly type 2 just to say what it is It has an issuer here, which actually may or may not be necessary That would be the identity of the workload whom is making the call. So it's kind of implied, but I don't know I put it in there. I can't. There is importantly, an audience. So this is the URI of the target service and vocation and this is what says sort of the scope of the call or the scope of the transaction"
  },
  {
    "startTime": "01:02:00",
    "text": "being made the receiving side needs to make sure that it is in fact an intended recipient of this that would disallow this proof from being used somewhere that it was not intended to be used used um there's an expiration time just to sort of put an end on its validity There's a JTI, which is a unique identifier for the token which can be used for auditing, could potentially be used for replay checking if in fact your service wanted to do that and maintain the cost overhead of data holding that data for the period of time that it was available. And then we have a couple of claims that are meant to allow for and sort of show correlation to some sort of other context token might be an access token. That's the ATH claim here It's a hash over the OAuth access token if in fact one is present and you wanted to sort of bind it into this proof for transaction. I also had the TTIH was just the transaction token hash same kind of but it's just a hash over a transaction token referring back to that Oath draft if that wasn't here And then there's a really poorly constructed other token hash that the concept is just maybe you're conveying this in some other way, and here's a hash over it, but the construct and things are a little bit weird, there's probably better ways to do it But I think some conception of that is probably necessary as this stuff if this stuff proceeds I see somebody on the queue and the other just main point is this is sent as an H to be head not as an authorization header because you can only get one of those and we didn't want to over the it or use up that space Hi, yes. Brian, I was wondering, like you said, all these different hashes are all optional"
  },
  {
    "startTime": "01:04:00",
    "text": "So developers obviously like that idea because then that's also always causing a lot of hassle But then on the downside, there's nothing really in the and the token that binds it to anything and uh doesn't have any replay protection is that sort of like there's a fine line between the two, like imposing too much? and then imposing too little to developers and let them all figure this out and as we know like passing on these security decision to developers works really really well So I want to know what uh what you're taking that a couple couple of thought you're right um but there are a few things the audience very much is the in a manner that prevents replay out of the context of the specific target URI are at? And of course, that specificity, specific that has different meaning to the downstream system but generally speaking, different URIs are for different things in the restful world and whatever. So it is a pretty good proxy for the context of the intended use of this. On the other side, these things are all optional in that they might not be present at all but the text is written with the intent that if there is an access token in the request, then the hash over it has to be present so it's um So it's more like conditional, conditionally optional Yeah. Yeah There's not good wording for that, but we tried to make it conditionally okay yeah it's mandatory if this other thing is present. Okay. Rather than being completely optional. Okay, that makes sense. The other token one is a little funky because there's no way to say that, but again, that construct, like I said, needs to be re-looked at anyways so but yeah does that that yeah"
  },
  {
    "startTime": "01:06:00",
    "text": "that's better and maybe a current since most of these devices will have a clock so in absolute time so maybe even a time stand Oh, good. Actually, yeah, there's an next, sorry, I missed that as well. That's mandatory Yes, it's mandatory. Okay, that's good Evan From Spiral. I like the audience piece I find interesting and actually a honest comment about expiry was that was kind of what I wanted to throw out for some extra consideration that there's lots of use of like async APIs and things like this. So if I'm using, for example, you know, I'm posting an HTTP message that is being processed by an async queue in the back system outages other things may cause Q backups. Expiry is kind of, as it becomes difficult to manage sometimes. And so there's also a flip coin of like an issued ad where local policy may make it a decision on what is tolerable So, you know, the behaviors of these things can be quite a bit different. So we might consider like other avenues. Yeah, those are actually two really good points that there was some considering given to that maybe didn't make it through and what I talked about we had I had issued that um originally with some sort of vague wording around okay, this is when it was issued now It's up to the receiver to apply some policy about a reasonable time frame of acceptability acceptability um and um some of my co-authors pushed back a little bit on that with a preference for an explicit and time which is easy to kind of reason about and think about while also one of the, sorry, I'm jumping around a lot, one of the intensive audience, this is all very much HCP bound in terms of its context, but using audience as sort of a general"
  },
  {
    "startTime": "01:08:00",
    "text": "mechanism made sense that it could be reasonably dropped into a queue and reason about independent of HGP without a lot of um work or that's not the right work. I thought about the same thing you know. And so even with XPRI, I think you could, you could still make reasonable accommodations for like, okay, in this context maybe you understand that and you will give some allowances for processing it after the expiry although we don't speak to that and issue out is similar and maybe not yet. Brian, just in the interest of time I just want to do a quick time check and maybe if there's more detailed discussion to take that to the list or offline yeah I don't have strong opinion other way just want to make sure we're having that conversation. Thanks, Evan Ken, do you want to, you have a question? for us yes so the document mentioned workload identity tokens must be signed by a private key held by a central identity provider I was wondering, are there ways we could relax that? constraint to allow workloads to sign their own tokens? a self-signed jot that could maybe convey the path to a known trust anchor using something like the X5C claim, which would convey a certificate chain to a possibly a already distributed set of trust anchors for a trust tumor And that would also potentially combine the proof of possession concept requiring the whimsy proof token with the workload identity token itself and could also include an audience constraint. So the workload could just sign its"
  },
  {
    "startTime": "01:10:00",
    "text": "own token and say, here's the my belief is based on my private key and here's the path to a trust anchor In a sense, that's Thank you different way to reason about, think about it exactly what it's already doing, but we tried to be sort of opinionated in building a certain structure around hopefully having something that would interoperate but absolutely there's other ways to do it. I'm not sure how else to address Maybe we're out of time. Another topic to take the list and get more people to weigh in on that one. Yeah right, we've got five minutes Brian, you're done. Next slide. Next slide Okay, so this was option one, inspired by the POP by the pop. Option two is to basically use a HTTP message signatures out of the box. So the document defines exactly which of the headers, which of the message components should be signed, must be signed We get all the flexibility of message signat but it's on us to decide how to use this flexibility, so we can use it in inside the document, where the document says, what needs to do signed, or we can leave it to developer to deployers or developers to say what they want to sign right now the document is more on the prescriptive sign of that divide and the working group will need to decide Good"
  },
  {
    "startTime": "01:12:00",
    "text": "thing with message signatures is that out of the box you get both signatures of the message body in case of a post request as well as the response and some tie-in between the request and the response Yes, Annes. Please keep it short. We are short on time. For the service to service, communication at the beginning, there was once a discussion about sort of like, not just hop-by-hop, but multiple over And then the question arises of what happens to the HTTP requests and if you protect some of the methods, will they actually between the different hops, stay the same? Did you talk about that? Not at all. Our assumption was this is a single HTTP hop Okay. And what happens with the rest is like that sort of idea gone? It's a cold chain and each one is a separate when the identity a separate audience. Chain of trust type of thing No, no. Call chain Yeah. Next call is a new call Okay the thing that does go across the call chain is probably the transaction token Okay, next So here I get to play TLS enthusiasts so the, uh, I get to play TLS enthusiast. So the kind of transport option that your own described at the beginning, I mean, it's pretty straightforward here is to use mutual TLS and then use whimsy credentials that are X509 certificate right now this is reasonably straightforward, however, there are still some difficult"
  },
  {
    "startTime": "01:14:00",
    "text": "in particular like how to you know traditionally tLS connections when we make them, you know, we're doing host name validation based on DNS names. Is this something that we want to continue in this space and require DNS names in? here as well? Or do we need to define? the mechanism for, you know, okay, we have expecting to connect to a particular whimsy identity? We know what that is and we can validate the host name there So there's a little bit of thought that needs to go through here There's some discussion of this in the current draft This is an area where we need to have more discussion and look at what people are doing today here. I know a lot of deployments are just doing things like validating trust domain and not actually validating individual entities I think it would be nice to have the option to validate the individual entities, you know, do that host validation So that's one area. The other area is looking at trust domain mapping How do we map the what's trust domain in a identity? We talked about this a little bit. How does that map to? the into the X509 world? Probably static configuration, but maybe we have other things But we'll move on to the next slide, because we're short on time so discussion we've had some discussion already. So next steps you know we this document it's a zero-zero document, but we feel like we've made some reasonable uh done some reasonable things here uh question is is this ready for working group adoption there are some big things to still be decided but something I think we should consider Fleming very brief, yeah. Very brief. Yeah, no, I just want to say, I think you guys made some really solid progress here consider. Fleming, very brief, yeah. Very brief, yeah, no, I just want to say, I think you guys made some really solid progress in a short period of time, well done"
  },
  {
    "startTime": "01:16:00",
    "text": "okay you guys have more slides. Did you want to go through those at all or no? You know, it's just discussion of issues that I think we will need to have on the list yeah we okay we do not have time for that okay so the question to the room first, who has read the draft from the design team? All right, excellent number of hands The question posed to the room and those online is should the chairs start a call? for adoption on the list? This is not saying whether you're in favor of adoption or not. This is saying whether you think we should start the call for adoption now or if the answer is no that is you think that generally you're saying you think that there should be more discussion before that happens happens Sure, I typed it fast There's only one document All right, just a very quick temperature check seems like the group is ready to start that. I'm not seeing any explicit dissent So I'm just going to cancel that. This was just, like I said, a quick time temperature check. Thank you, everybody. The chairs will start the call for adoption on the list in the next couple of weeks. And we will take it from there. Thank you all very much All right, next up, Dean and Yaroslav, who's starting? You'll start. Do you want me to run the slides or do you want to? So the clicker is going to be your phone Okay, then please do. All right, let me all right um oh it's just one deck right yeah okay right. And Dean's online too. Cool All right, we'll get it. Hello, everybody"
  },
  {
    "startTime": "01:18:00",
    "text": "I'm today representing in person that token exchange design team So there were five of us in the design team and we had regular meetings and did loads of brain brainstorming around this problem, our fearlessly leader, Dean, unfortunately, couldn't make it in person but he is with us in spirit as well as on Mid Echo And he will be presenting second part of this deck So the first thing that we very quickly realized and the design team is that there is actually there is actually an absolute sea of applications of token exchange especially in context of workload identity And the token exchange term is already coined by OAW, so there was a lot of confusion Does token exchange means that we're limiting? ourselves to OAS or does it mean something else? So the first thing that we would like to propose is to, in context of WIMC, report, term of token exchange with token translation. So for the rest of the deck and in the document, we refer to this process as token translation and token exchange is a subset of orthcentric subset of what we can do with token translation in general So it is a wider and it's a super set Next slide, please There is, as of today, there is no singular WIMC identity token. Very likely seeing will stay that way. There are so many different tokens in certain areas there are all already translation mechanisms defined. There are certain protocols how you, for example, can request X509 certificate or certain ways how you can exchange oath token for trans token"
  },
  {
    "startTime": "01:20:00",
    "text": "for them uh for the transaction token um instead of creating attempting to create one size fits all standard we decided to split the work into two separate sections one requirement section that outlines requirements for token translation service and one sample implementation of those requirements with an expectation that they're will be other implementations of those token translation requirements that might be speaking to certain token types or a whimsy app application scenarios so translation mechanism may potentially translate one token type into another token type it can translate from one token type in the same token type Next slide, please. And after debating nearly to infinitum there, all that all cases, all the applications of token translation we boiled it down to eight specific technical requirements. So what happens actually when you translate? a token? It doesn't mean that every token translation mechanism needs to implement all of the but token translation mechanism needs to consider all of them and discard those that are for whatever valid reasons are not applicable So first thing that can happen when you translate a format of token matrix change. So you're translating, for example, you have X X509 certificate and you want to get some kind of beer or token, which everyone hates, or something something better. That's first requirement. Second requirement is content and coding change within the same format there are options for different encoding types so you could keep the same format, but if you have two separate"
  },
  {
    "startTime": "01:22:00",
    "text": "speakers that speak different encodings, prefer different encodes you might want need to exchange one token for another with different encoding Yadislav, there's somebody in the queue do you want to take a question? Oh, sure, of course. John? Yeah, sure John Camp. I wanted to ask about the difference between translating and exchange, because to me, exchange is usually, for example, for you hand in one type of token because it won't work at the potential endpoint you want to use it at so you hand it in and you get back another one and to my mind at that point in an exchange for example you could cancel the original token and give back another one with new timeframes, for example And to my mind, that's quite a different thing than a translation way back another one with new timeframes, for example. And to my mind, that's quite a different thing than a translation where you're basically saying, let's take the information that in this token and encode it in a different format and hand it back to you. So I just wanted to sort of say that I sort of feel that these are two disjoint concepts. They could be used together or independently of one another I see. Yeah, perhaps we need to do a little bit more warding, more word massaging, but in jing general, I personally think that translation may translate with a translation service one, token to another and not necessarily discard the original token or in translation process original token might be become invalid or expire after the translation So I believe that in translation, translation again is a super set of exchange, which might which might result in invalidation of a original token or not Dioraslov, if I may, I think that's a good description I do understand your concern, John. It does make make"
  },
  {
    "startTime": "01:24:00",
    "text": "sense. However, when we look at the token exchange mechanisms that exist today, and we're really talking about the ones defined by an RFC number, which I can't come up with at the moment, but that RFC defined token exchange in a very specific manner for a specific set of tokens And those tokens today have no mechanism for expiring them dynamic that I'm aware of at least And so I'm not sure that that really maps but I'd like to have this conversation and figure this out either on the mailing list or through some GitHub issues so happy to engage with you on that and make sure we capture that correctly correctly Thanks, Ciaroslav and Dean. Thank you, Dean Let's go to the next one So third option is third requirement to consider for token translation service is crypto change. Certain tokens have cryptographic properties that are embedded in them, digital signatures, cryptographic hash encryption and you could have different different that prefer different crypto You could have different domains that have different requirements of what cryptography strength is applicable to them And now also in migraine to post-quantum crypto hybrid crypto world those challenges when you're moving from one domain into another and you need to reconcile communication between those domains so exchange of crypto information could be an important translation use case. Brian I'm sorry, come in late because I couldn't figure out the client it crashed on me to raise my hand. But going back to some I'm sorry, coming late because I couldn't figure out the client it crashed on me to raise my hand. But going back to something Dean said, I, uh,"
  },
  {
    "startTime": "01:26:00",
    "text": "OLF token exchange is admittedly quite hard to read and understand, and I apologize for that because I was responsible for a lot of it but it most definitely does not constrain to specific token types And part of the reason it's so hard to read, I think, is the intent was it's a general mechanism to take any token in and spit out any token on the other side So I'm not sure what the consequences of that are, but I'm maybe a little concerned that there's something lost in transit an entirely intended in terms of what's what and how we're trying to reconcile it here uh so that's not actionable but um it's definitely not it's it's meant to be very wide open and be an art arbitrary, arbitrary exchange mechanism thanks Brian that that's helpful You know, one of the things that we discussed is we were in the design team was, and I have to thank Peter yang justin for their help on this, is token when we convert token formats, we may lose information. There's information loss in translation. That was how we got to this concept of token translation Because, and you'll hear this when I talk a little bit later about the second draft that we've written one of the major concerns is how do we define what is lost in translation? How do we know that that is acceptable? And so we're going to talk about profiling the different token translations so that each of them are defined concretely, and we know exactly which context is lost when going from an essay jot to an access token or whatever the bearing may be. And so I think that's in my mind the distinction but if you think that's supported by the existing token exchange RFC,"
  },
  {
    "startTime": "01:28:00",
    "text": "I would love to have that conversation. Maybe we should have a conversation but what you just described sounds more meaning and useful. Like, describing the properties of what is and isn't lost in a specific exchange from one or the other rather than what I thought I heard you say before is like you can't do things other than these tokens and there's not those sort of restrictions so maybe we should have a conversation but that is that's helpful thank you no problem thank you dean moving to the next one um talking embedding so when we have one uh token that we want to keep around and embed it into external token, something that again can be consumable, it's especially important for things like service chaining or supply chain situations when you want to keep, when you want to keep can be consumable. It's especially important for things like service chaining or supply chain situations when you want to keep a history of previous tokens I'm going to the next one then we have context change when we have claims or other parts of associated with the token that needs to be added or replaced as part of the communication then change validity constraints. So we could have token expiration changes we might want to replace long-lived token with a short-leaf token when we communicate to that outside world or changes in the audience So we could ask, we could take an original token that is intended for just token translation services or for Gateway and that would exchange it or translate it into a token that would be applicable for a different trust domain changing or adding sub subjects. So that is also designed to cover to cover"
  },
  {
    "startTime": "01:30:00",
    "text": "embedding of domain local identities so when you're going from one domain into another domain, your subject might change, you might want to do generalize your subject instead of how having subject specific to some work within trust domain when you're going to a different domain you may want to offer identity that would be generic to whole domain for privacy consideration for hiding intimate details of your internal topology that you don't necessarily want to disclose to outside world. And then the last one is adding a center constraint So we could have a regional token that is not a center constraint for certain communications we may need to add an attestation or center constraint so we would be embedding that into the token resulting in a new token And then the first draft that outlines those requirements it's at the moment quite barebone draft just listing those requirements and giving few sentences explaining them. We also have security considerations section that defines how token translation mechanism needs to needs to what what security considerations talk translation mechanism need to have replay attack protection everyone's favorite access control. So when you're translating a token, how do you make sure that it is within? certain access parameters a privilege as collection So if you are replacing one token for another, one, you don't need, you don't want to escalate your privileges unnecessarily. Prevent a abuse of token translation service if you have a not-so-trusted endpoint that can call token translation service you don't want it to dose cause denial of service of your token translation service or"
  },
  {
    "startTime": "01:32:00",
    "text": "use it without certain authority Privacy considerations so generalization of identities for cross-domain use cases, encrypting of sensitive identity information when it's happening to be traveling over untrusted or not-so-trusted environments auditability, and one that is missing in the current version of the draft is multi-tenancy that we've discussed but was not yet added to the document So that requirement document is submitted as an individual draft and with that let me pass over to dean to walk us through the second draft. Thank you, Erasm I'm sorry I can't be there today, folks Global travel disruption disrupted some plans for my wife so I'm stuck in Seattle just a few hours south of you but I wanted to talk about the token translation bit and I know we've we've spoken about it a bit already We specifically defined this because we wanted to do differentiate from token exchange and the fact that these conversions may be lossy. And so this is how we've defined it in the draft One of the key things that I would like to get out of the working group today and all the folks sitting in the room and online is, is this correct? Have we correctly identified? what we're doing here as token translation or as we've heard today is token exchange? really the definition that we should be? using? Brian, I will certainly speak to you after the meeting so that we can get some time together and figure out is this appropriate? What do we miss? in the token exchange RFC? and is there some context there that we need to bring across? to the next doc or to the talk, I should say. Next slide, please"
  },
  {
    "startTime": "01:34:00",
    "text": "so with this concept of lossy translation, we propose that token translations really take three different forms. You've got the token exchanges are defined by RFC 8693. This is well defined It's well accepted by the community. There's an RFC, etc And so we really wanted to kind of leave this alone for the most part and operate as it operates today as defined by this RFC. The second is the idea of lossless token translation So perhaps we're maintaining the same token type while executing one of the defined use cases to change either the crypto or change context or change validity but there's actually no loss of information here because the token types are fully compatible with one another. Either they're the same token type or they're different token types that have represent the same body of information. And then the third, is this concept of lossy token translation So this might be a change of our token types where we can't communicate all of the information from token type A to token type B because of different formats, different kinds of information that are contained in those tokens. Now, I'm speaking about this in very arbitrary terms because what we're talking about is translate arbitrary token type A to arbitrary token type B. And we have to profile this We're not, at least in this individual draft as it's written today, going to specify how we go from a s-vid jot to an access token or an S-vid jot to an X-509 certificate because we think this needs to be defined through profiles in order to, as I said earlier define what those losses might be because that has specific security context associated with it, and it may change the security context or this understanding of that security context when you"
  },
  {
    "startTime": "01:36:00",
    "text": "convert from, translate from token type A to token type B. But this, if you get to the next slide please, is really where we need your feedback. These IDs, are really early drafts and we need the working group feedback on the following items Did we miss any use cases? Yaroslav covered eight of them. I think we've captured everything that we should need at this point, but if we're missing, something, that feedback would be super useful Is our definition of token translation appropriate? Is it correct? And this gets back to the questions that Brian was asking earlier. And is the need to profile these lossy token translations really appropriate? Is this the way that the community thinks we need? to go forward with this or are there better mechanisms that we're missing and we need to pull into the individual drafts? And then if we do pro thinks we need to go forward with this, or are there better mechanisms that we're missing and we need to pull into the individual drafts? And then if we do profile the lossy token translations, how do we document them? are they rFCs which could take a inordinate long time to produce? or are there other mechanisms that we could use to define what? these profiles are? And again, looking for community feedback here with that let me let me take the few folks that are in the queue i think evan you're up first Evan from Spiral. Thanks, Dean Also, thank you for a design team on this It's kind of a big problem to put your arms around I really appreciate, you know, the kind of required the set of eight requirements and some of the other kinds of points here around translation and the terminology there Each one of these requirements, you know, makes a lot of sense to me kind of an isolation on its own. But also you know, when you have kind of arbitrary token issuance system on one side that maybe you control and then arbitrary token issuance system on the other side, maybe you do, maybe you don't, I think there's a huge number of possibilities there, which I think is part of why it can be done difficult to say, like, what are those set of requirements?"
  },
  {
    "startTime": "01:38:00",
    "text": "For me, when I think about each one of those individually, some of them I can see clear use cases to admit applicable environments that I'm familiar with some of them I struggle to see that. And so I think it would be really helpful, at least for me personally, to have some kind of concrete guidance of existing token types from going from one existing token type to another existing token type which of these requirements, you know, slot in for those things and I feel this will help kind of either I validate or invalidate that set of requirements, maybe narrow it down and make those stuff a eliot lear For example, in my head is like, you know, you mentioned going from a spiffy jot to maybe an AWS credential or going from, you know, a Kubernetes or a CICD token to some other kind of credential to an X-5-09, Ethan So maybe capturing some of that, I feel it would help me understand, like, okay, you know, which of these requirements apply web and what might these profiles start looking like, right? So, Evan, would you suggest then that we we write some appendices on one or on apply when and what might these profiles start looking like, right? So, Evan, would you suggest then that we write some appendices on one or both of these docs that define what that looks? like for certain token type pairs or as exempt? of certain token type pairings going? from A to B and maybe not going back from B to A because that may not be a possible translation Is that what you're looking for? Yeah, yeah, whether that's, you know, appendices in the doc or whether it's a conversation on the list or some supporting doc, I think what it will do is it'll help validate some of these requirements and also kind of light on which ones are like to be more frequently used than others Great. Okay, we can do that. Thank you I'm more or less plus one in Evan at I'd like to refer you back to the Wednesday chart where we talk about specific profiles for specific translations that we have in mind"
  },
  {
    "startTime": "01:40:00",
    "text": "between X technology and women and whimsy and Y technology And of course, as we make progress, with service-to-service draft, things will stabilize and we will have a better sense of what tokens we have in reality Thank you, Your Honor on Microsoft from what I understand, there will be some sort of token translation service that will be used to kind of exchange the format Would this be something that is within the trust domain and then reissue? credential from the trust domain or would it more than delegate and, for example, then go off to it? and exchange the format and return? that to the workload? It's a fantastic question. I think in my mind it is probably within the trust domain itself So a trust domain accepts an inbound token and it can then translate it to some other token type based on whatever profile is defined or if it fits within the realm of the 80s token exchange, then that could happen So I would look at this in a similar way as we see other token exchange services that operate today, but we haven't fully defined this yet. We're still in very early days of the individual draft and so this is still an open question and we can begin to answer these questions, but it's a good one to nail down pretty quickly, I think Yeah, I think the current assumption is that token transfer service happens within the same trust domain, but the reason for that could be to have a different token for the same trust domain or a different token for a different trust domain If you have use cases where these assumptions"
  },
  {
    "startTime": "01:42:00",
    "text": "does not stand, I'd be very interested to hear details Okay. And just one more question. What would be the difference between a translation and the issuance in the first place? Because if it's the same, service they potentially have the same keys, why not? perform at the station to get a format in the first place and not get like first a shot to exchange it to an empty less? like x509 third and then again to increase the validity. Why not just? perform attestation in the first place? Or increase the validity. Why not just perform attestation in the first place? I'm not sure how to answer the question aren't. I'm not sure how how attestation uh plugs in here but if it is within this within the same trust domain and you're issuing all of the tokens then there's probably not a need to do any sort of token translation there it's probably about issuing the right kind of token to begin with. But it's an interesting question that we should we should think about because there may be places where certain workloads can only accept certain kinds of tokens and so as you descend down, as you go through the call, stack, you now need that token translation or to make a call to another, even though it's in the same trust domain it may not operate off of the same token types. But I think that's a good use case that we should explore further yourself i don't know if you have any feedback No, no, I think that's, that is a great use case. I don't think every single inception of initial token is aligning with token translation but yeah, many of the ways how workloads request initial token and get a additional attestation, additional context falls well within token translation method"
  },
  {
    "startTime": "01:44:00",
    "text": "methodology Jeff, from AWS, so one of the things that I sort of was like opaque to parsable or like viral reference versus by value can of translation sometimes we might have to cross some bunderies as that might require some privacy preservation mechanism opaque can be one of those mechanisms, so maybe that's the characteristics that might need to be looked out because it will involve element of resolutions and if the workload be needs to get more insight from the opaque version which has been translated to back to some more insight from the Opaq version which has been translated to back to something which is passable, then you might require additional endpoint at the translation service to support that Yeah, I think that's, if I understand correctly, you're suggesting that token from translation can be used not by so-called originator to translate token to send more appropriate token to somebody, but by a receiver to translate whatever the receiver received in more something that has claims or decrypted or whatever that context happens to be. Did I catch that correctly? So sometime communicating to workload B may be onto a not privacy preserving channel and therefore we might want to translate to an opaque token so that the workload B receive by reference element that they can then like exchange back for like the real information the real stuff on the contrary we are coming from a non-privacy preserving channel, receiving a NOPAC token, and for the internal stuff, we need to translate to something which is possible. I don't want to go too much into GWT and OO2 focused type because you try to expand out of that. But"
  },
  {
    "startTime": "01:46:00",
    "text": "that's really something that happened at least a lot into OOS world. Yeah, I think that's an excellent suggestion Thank you. We certainly should add it to our work yeah thank you jeff that's a good one and from Spiral, I'm aware of the time. I'll be quick I was interested to hear your comment, Yeroslav, about you know, your expectations that this kind of exchange generally happens within, you know, a trust domain. I actually had the opposite model in my head And, you know, one example there is, hey, you know, I have a platform credential from my CICD system. I want to obtain a Google service account token. And in this case, I'm calling Google authenticating with, you know, some OADC style thing and obtaining back the local token, the Google service account token so in this case the exchange is happening kind of on the remote side rather than the local domain. One could argue that he you're extending your trust domain to include Google for that, but I see what you mean. And Evan, I actually captured that example after you and I spoke a few weeks ago in the individual draft that I wrote So, so I think it's worth further discussion to figure out how we, how we don't you and I spoke a few weeks ago in the individual draft that I wrote. So I think it's worth further discussion to figure out how we define that. How do we talk about this? in concrete terms so that we're all used so there were all on the same page? Yeah, my worry is if we say like same trust domain, then what you get into is like, well, yeah have this vault over here that I cut my token from Google and I put it there and on the quote exchange happening this way and I feel it's kind of the patterns we try to get away from in this world. Yep. Okay. Got it A time check. Notice you guys have one more slide Yep, let's go on to the next slide and then we'll end it. Oh, perfect so uh all right so um sorry if i may um you guys have one more slide. Do you? Yep. Let's go on to the next slide and then we'll end it. Oh, perfect. So, sorry if I may, we would like to ask whether or not we think this is ready for working group adoption for both of these drafts. It does seem a little bit"
  },
  {
    "startTime": "01:48:00",
    "text": "early to me, but I did have to ask the question So I'd like to offer that to the chairs Just getting the poll ready yeah so first as is tradition please raise your hand if you've read either of the two documents from the design team All right, a handful That's great. So the question is, should the chairs ask for adoption for these documents? One or both, and they're going to be separate questions and especially because one of them is a requirements document. There's going to be some discussion around that one about what the nature of that document would be for the working group group seeing a pretty strong ambivalence A lot of people don't care To me, so what I'm reading from this is that just gauging the temperature, we will of course bring a note up on the list about these outcomes but what I'm reading from this result is chair is that there's not a strong feeling that these are ready, let's let's get this started so let's continue the conversation on the list. The chairs will start a thread to sort of frame the discussion of what the next steps for these documents are I do want people to keep in mind that documented option is to is the starting point for the work group and not the finishing point for the working group But that said, like I said, I'm not seeing a strong call to bring these up All right. Thank you very much, chairs, and thank you to my co-authors as well and again thank you to the design team for all"
  },
  {
    "startTime": "01:50:00",
    "text": "the work. Appreciate that immensely. Yes, absolutely Okay Ryan, for the last presentation of the day Do you want to run the slides? No okay. Okay So I'm Ryan Hurst, I'm with Spiral I wanted to talk to a little bit about the idea of authentication level for workloads. Next slide So, yeah one of the things that I really like about the Wimsy Charter is that it's taking a picture at the current practices and trying to map at least a subset of them into stuff that can work cohesively together. Ryan, can you eat that microphone a little bit? I will eat the microphone a little bit. Thank you And one of the challenges though is that implementers as well as deployers when they come and look at the specs in the eye IETF, they're trying to figure out what are they supposed to do and how does this map to the way their environments work And the challenge that we run into is that well, service authentication, is a thing. There's a lot of spectrum of what that means and what properties you get out of each system. And then other identity systems, for example, in the user space, we have sort of a maturity level model So next slide that we can rely on. So 860 is a good example that is helped both implementers understand what they need to do to meet their customers' requirements, as well as customers to understand what they want for the security level in their particular environment I think there's an opportunity to do something kind of similar as an informational RFC inside of the Wimsy group to help people start thinking about what all of these options sort of may mean not necessarily classifying any particular technology, but setting out a taxonomy, a framework for us to use to describe to people and sort of on"
  },
  {
    "startTime": "01:52:00",
    "text": "common ground the security properties that you get at each level so you could view where you are in sort of a security arc. You know, maybe at the next slide, actually, you're already there. Thank you Dean has a question Then you're muted Sorry, too many, too many of you buttons here You mentioned an informational RFC Is informational really the direction that we want to go? or should we define something more concretely? to specify what? those authenticator or authentication levels are? And I'm not gonna say how we define it exactly, but is it informational or is it prescriptive? I think it could be both I felt that informational is the least It's as you as you leave it informational, the question becomes, how specific do you get in regard to it kind of gets back to that best practice conversation that was had earlier today. And so that line that you have around specificity, I think it should be as specific as possible, but not so specific that it's prescriptive in which of the solutions that you choose or anything. So help people, my mental model has been at least that it's a way to navigate the domain space rather than you know I would like to see everybody do strong workload identity backed with that to state navigate the domain space rather than, you know, I would like to see everybody do strong workload identity backed with at the stations tied to the environment that it's in, but there's going to be a spectrum for as long as I'm a professional for sure yeah i think i agree there's a there's a there. I think what it was there's going to be a spectrum for as long as I'm a professional for sure. Yeah, I think I agree. There's a spectrum there. I think what I would advocate for and have mentioned this in a the list is doing something where we can be very concrete about the properties of the authority credentials that are being used so that we don't have to do bucket them into AAL-1, AAL-2-A-A-A-H style mechanisms And there are some other threads on this and other standards body"
  },
  {
    "startTime": "01:54:00",
    "text": "that are happening as well. So I want to make sure that we try and align directly around that so that we don't do something that is just buckets, but it actually talks about the properties of the credentials themselves or of the authentication event that happened. Yeah, to be clear, I think the properties are the important part because I don't think the labels themselves are enough. So whether it ends up as a informational or something else, I don't think it's all that important but i do think it's important on a criteria basis that you should be able to objectively assess what each technology kind of would map to as configured and deployed. Perfect Yeah. Awesome. Thank you. Just a quick time check. There's three minutes on the clock, so then a few people in the queue. Yes. Very quick Jeff. So here you're assuming that you are focusing on HAL is it not not also a part of fall file so if a iL inside what you should look at for that? In here, this is really just intended as an example What I'm really looking for is, like, is there any interest in this work? And if there is, you know the conversation we just had the theme, well, how would it progress? inside of the working group? So actually, not to the point of saying it should look one way or the other yet as much as does this seem like this is something that is meaningful for the working group, seems like it totally fits in the charter to me. And is it something that is worth our time, feels like it would be valuable to help both implementers and customers So my assumption is yes, but that's the conversation i'm hoping to have today but though i'm happy to discuss anything to be clear. John? I just wanted to mention I'm a big fan of the word context as opposed to level, because level sort of implies to me that one level is high or better than another level"
  },
  {
    "startTime": "01:56:00",
    "text": "and I would be, I would prefer to be basically just provide the context of the authentication and let the recipient decide for themselves at what level they require it I agree, I don't think this is a document where you would say best coming to the earlier conversation as much as it would be a document where you define to Dean's point, the properties and then you can decide what's right for your threat model, for your environment Okay Do you want the next slide? Yeah, next slide please I put this together with a Peter just really as an example of like the way we could think about what a spectrum might look like, but I have no attachment to this at all. It's really just to say here's a basis. Each one of these conceptually might be maps to a set of properties maybe they're totally different ones instead of you know set of there being five, there might be three, there might be 10, I'm not sure, but the idea is that when I talk to customers, I hear people who are across this entire spectrum. Some are trying to just get away from what I have as level zero here to get to level one And, you know, maybe if there was a clear story arc of the journey that people might take and the properties they get when they take that journey they might be able to skip a couple steps and not recreate the mistakes that I'm sure all of us have made along our careers Next slide So to the earlier question, and given my time, is this something we think is needed? Is really the question? I have for the group, and if so, what's the best? way for us to work towards this? I'm happy to contribute my time to help make this happen And I'm hoping there are also others that would find this to be a worthwhile effort to spend time on on"
  },
  {
    "startTime": "01:58:00",
    "text": "Thanks, Brian. Anybody in the queue? Yep. All right, so I just want to point out from process perspective. This is not any type of call for adoption. There's in fact not a draft even to be considered And also, if there were a draft, this would be something that is not a it's not already seen as a work item for the working group to fulfill. So this would be, depending on how it's framed potentially an expansion of work, which is hard to I will say hard to justify for a new working group that hasn't delivered a document yet. But all of that said, whimsy has been intended from the victim beginning to be an ongoing venue for exactly this type of discussion So I encourage you to bring this discussion to the list, see if there is interest, if there is need, and if any of that is true, we will find the right thing to do with this work Thanks, Justin. And then I think one of the thing just as maybe a reminder for everyone, we have, the design teams have done excellent work, but of course, anybody is free to, if you see gaps, Robert opportunities, please feel free to create an individual draft, bring it to the list The design teams have concluded their work at this point and so really looking for anybody to if you see a gap, please participate create a draft. All right and a parting shot from our ad you see a gap, please participate, create a draft. All right, and a parting shot from our AD. All right, we're a steel responsible ID. I just want to thank you all for a one wonderful session. I'd love to see, I've loved to see the progress on the list, the design team, especially a thank you to our chairs for running this session. All right Thank you very much and thank you all And we'll see you on the list and see you guys in Dublin. Yay!"
  },
  {
    "startTime": "02:00:00",
    "text": "Peter won't have to go far for that one one Okay. Thank you. Great job Yeah, I think that one really well. I really appreciate it running the polls to get the people Yeah, yeah, I agree and it was i've seen them overused i think we we hit the right right right We need to grab some day or tomorrow or at some point to just go through the nights like we did last time Yeah, yeah. So what's your schedule like? Oh, gosh"
  }
]
