[
  {
    "startTime": "00:00:04",
    "text": "foreign good morning we're trying to sort out one slide issue um trying to get those but they're not the first presentation so I think we'll just go ahead and get started and try and work that in the background um let me bring up the slides okay so uh today we're gonna have a a short one-hour um virtual interim beating remind everyone that this is taking place under the note well please pay attention to your UH responsibilities under the note well and please don't participate if you have not checked that out so this morning we uh have two presentations that were uh associated with uh itf-114 after that this slide is is changes discussions on the list Friday we're going to talk about the hashland sign issue with post Quantum signatures and then if there's time left we're going to talk about the um and a status update on CMP the two rfcs that are being updated there um so because of the slide issue we're going to start with the pthcs12"
  },
  {
    "startTime": "00:02:01",
    "text": "presentation while we try and sort out the slides for the CMS presentation before we go any further though of course we need a note taker as anyone willing to do that can someone take notes in the in the chat you can get to I'm sorry The Ether pad that you can get to but the button at the top of the um the upper right little pencil in a pad yeah yeah I can do it Russ it's John Gray genre thank you so much I appreciate it John all right let's uh then uh move to the uh first presentation uh Dimitri are you gonna be the presenter I think I think Hubert will be the presenter the author of the draft okay Hoover is going to be it okay yeah that was the plan can you hear me yes let me pass you uh the ability to do the slide control yourself [Music] okay did you get that um do you see at the bottom of the slides uh there's just the numbers and then an arrow to move them forward uh-huh perfect okay yes okay good all right good all mute okay so hello everybody um um I will be talking about the use of PV Mark 1 in pkcs12 file format uh my name is Hubert cardio and I'll be presenting together with uh Dimitra Dimitri we both"
  },
  {
    "startTime": "00:04:03",
    "text": "work at red hat in the crypto team so quickly about pkcs12 the purpose of the file format is to transfer private key certificates secrets and extensions the specification is in RFC 7 to 92. there are a lot of implementations the primary ones that we are interested in are in open SSL and accessible to TLs but there are also a lot of of implementations in Windows in by a lot of Hardware implementations in Network appliances and so on and so forth more or less interoperable basically the only interoperable file format that works for both our windows and Linux environments the file format itself has a very extensive structure but on the top level there is technically just three Fields the version the outsafe which is the list of items which are inside the the file for the the file itself and then there is the Mac data which is working as the Integrity protection for the whole file what's important is that Mac data specifies just the digest that is used for the Mac protection the the salt used for that hmac derivation and the iteration count that's used for the for the key derivation while some implementations allow omission of the mark as this as the a71 specifications here shown does most of them actually are quite iffy on that"
  },
  {
    "startTime": "00:06:01",
    "text": "um Mark generation itself is specified in appendix B of the RFC and there already is a specification that this this like when you choose with uh with password uh the key derivation is not recommended and it should be duplicated for a new usage one so well while we already had [Music] I used was uh duplicated the problem for us is that this this kdf is not fixed compliant so it's not possible to create a mark protected ptcs12 files that are fips approved um so our intentions we want to have an up-to-date standard that allows use of new and current derivation functions we want fips compliance uh we also want as far as possible backwards compatibility so that those files would be readable at least partially by old implementations and also we want that implementations to be easy to to do since we need to implement it in multiple libraries and uh and so so the the ease of implementation is important so the proposal we want to do is uh to prep to preserve the existing high level pkcs12 structure um and additionally permit the use of the ID PB Mark 1 object identifier as a valid type for the digest algorithm so instead of specifying as a hash algorithm it would specify just the PB Mac one as the as the hash itself then"
  },
  {
    "startTime": "00:08:02",
    "text": "uh we would we could use the parameter field to store the PB Mach 1 params and then those would include the information about like how to how to calculate the the hmac and the hmac itself would still be would be calculated according to the PB Mach 1 [Music] um standard which is specified in RFC 80 18 uh while for the pkcs12 structure itself the max out and iteration values would be completely ignored since those are while they make sense for for use with pbk df2 they don't make sense for a script or for argon2 like those those use much more advanced and more complex parameters to to work so we would need to completely ignore them to make for interoperability the upside for this proposal is that pvmark is quite easy to implement uses exactly the same key derivation functions as already deployed bulk encryption ciphers so like if you support AES in pkcs12 you already have all the plumbing necessary to also support BP Mach 1. the hmac calculation itself is exactly the same as in ptcs12 just the key derivation for that age Market changes we also already have a very widely deployed implementations that will be able to extract the private keys and certificates from files that use ppmac 1 just by telling them to skip the Mac verification so you can use openssl probably like even 098 or and definitely 101 that that's the one all this one I've actually tested that will allow you to read the file by specifying"
  },
  {
    "startTime": "00:10:01",
    "text": "just uh to open SSL ignore Mac verification and then you'll be able to uh verify like extracted their private keys and certificates uh finally uh it does provide a very clean upgrade path for modern kdfs you can as we specify with the specification already um we proposed you can use a script and are going to just needs the asl1 oid specification and parameter specification to be usable uh there too now the alternative that was proposed on the mailing list was to use aesccm now the problems are that I'm not aware of any implementation of that inside pkcs12 none of the widely deployed libraries that we actually use uh supported so none of the open SSL green tls's Java Windows as as [Music] Windows implementation I'm not aware of them supporting them that would also be the very first aad Cipher in pkcs12 so that would require a very new and potentially complex code this is also not a wildly used Cipher so anyone that would need would want to use it in kcs12 would need to implement it verify and in some cases also certify since we wanted to flip certification that would um that for some implementations that would require another Cipher to certify finally there is no clean way to handle as CCM together with hmac if we live and live in the Legacy Mark in the file then the straight flip compliance will be"
  },
  {
    "startTime": "00:12:00",
    "text": "problematic since then you cannot derive the keys necessary for hmac well if you omit a Mac then you will lose the whole file consistency Integrity protection and for some implementations that is problematic like they don't provide the apis necessary for telling the implement it to tell the library to to skip the Mac verification so the specification is on uh data records the draft carrier pkcs12 PB Mach 1 there is GitHub also with the source code for that would have a quick and delete implementation of open SSR in openssl and if the draft is actually adopted by the work group we will provide a full implementation for openssl nucleus and NSS that's the absolute minimum we also will be pushing for open jdk support if you would like to look at the file itself you can download it for also from GitHub and the password is one two three four okay so questions so first question is from Tim Hall big uh sorry if I'm mispronouncing the fifth compliance problem is the use of absolute algorithms uh correct the problem is that the key derivation function is not approved for fips use and we want to use pbktf 2 for the key derivation function so that it's effect compliant foreign so my misunderstanding is a little bit because I mean a higher level things like KDs are usually not in fips fips is usually about just the crypto"
  },
  {
    "startTime": "00:14:01",
    "text": "the individual crypto if we are talking about 140-2 and current requirements a key derivation functions are very much in uh scope for fips oh you're right sorry I just see so many people implementing them on top of it um yeah and they won't be flips compliance with us yeah so so my gut reaction this is Russ is that um the your first proposal makes more sense than the alternate uh and I'd like to know whether other people feel the same do you mean the first proposal is using of course so sorry for um clarity [Music] uh I'm you know in the slide you had a uh our preferred Way Forward and then you talked about other ways forward and I'm saying I think your preferred Way Forward makes sense okay and I wanted to know if others thought differently yeah yeah I was just gonna say uh yeah I agree with that uh the first proposal because the aad decipher obviously there would be a change in the structure of pkcs 12 which I think part of the purpose of it is backwards compatibility and stuff plus you know the fips compliance is a good Plus on this um because obviously lots of people need to use fips so I think the recommendation of the first one makes sense to have PB Mac one plus we have another like we put it in CMP as well and other um of our protocols that we work on so I think it makes perfect sense to do this in pkcs 12. okay Sean"
  },
  {
    "startTime": "00:16:00",
    "text": "one two three waiting for it to work yeah um I agree uh definitely option one okay Mike foreign we hear you I think I'm gonna say the same thing that my colleague John just did which is PB Mac one uh keeps disaligned with the changes we're doing in CMP so PB Mac one would be good for both CMP and p12 that's aligned all right I'm not hearing anyone speak uh against that approach um my quick skim of the internet draft was that's the only one that's in it is that correct only what that's the only alternative you wrote down in the internet draft yeah in the internet after is just BB mark one good okay so uh would anyone at this point speak against working group adoption of the this draft no one is coming to the mic so um I didn't see anything over in chat so we'll have a call for adoption I have to say we're itf114 put a long list of uh documents to be uh called for adoption We'll add this one to the end of that list and so it'll probably be a couple weeks till until we actually do the call but we"
  },
  {
    "startTime": "00:18:05",
    "text": "thank you any further questions on this this one all right then we will move to the uh PQ sigs draft in CMS foreign I can hear you and I'm passing okay thank you uh so yes the so this light set is just a an update of the previous presentation that was done maybe uh well six months ago or something like that so um uh yes we can just go through the slides so it's uh basically the idea I will remind the the idea of the the main idea of the of the RSC so the purpose is to propose a solution to communicate a key uh individually encrypted to several entities so the actually if you can just go further in the slides please I think you have control okay okay sorry okay it's perfect so"
  },
  {
    "startTime": "00:20:00",
    "text": "um yeah so that was the the purpose of the of the RFC just to define a new mechanism to uh send a key to several entities and to encrypt the key individually so basically the idea is to uh to propose a combination of free algorithm that will be used for encryption uh the first is a chem okay encryption encapsulation mechanism then a kdf and finally a wrapping algorithm so basically the algorithm is defined in this slide so we will first generate a ciphertext and the shared secret thanks to the cam algorithm then derive the shared secret thanks to the kdf and finally use the key encryption key obtained from the kdf as the encryption key for a symmetric algorithm uh the wrapping algorithm that will bring then confidentiality and integrity and so the decoration mechanism is described here so it's the opposite so it works uh obviously and uh so uh they're in CMS we will use uh we propose to use the the the recipient for type and to set it to a key trends recipient recipient info and um to set the following values in the key trans recipient info I mean we will set the the algorithm to uh oid IDK Trends which will be the cam trans mechanism"
  },
  {
    "startTime": "00:22:00",
    "text": "and then set the uh algorithm parameters of type generic hybrid parameters uh well let's let's hit basically and uh so I just made a few updates according to the comments made during uh last meeting so especially there was a discussion about the kdf uh which can be useless if the cam for instance outputs a key of the correct size to feed the the symmetric algorithm so in the racer really clarified that this kdf can be the identity algorithm if we want to skip it and the other date was to make sure that this RFC proposal is aligned with the RSC 9000 180 which describes the hybrid the encryption mechanisms so basically it's the same principle which is proposed in this RFC meaning that it's a combination of the free algorithm chem kgf and and the symmetric algorithm so basically the RC is correctly aligned and um finally in the sea there are still some open question that have to be answered well and with where I'm really open to discussion so it's about the way to communicate the info so for in this RFC we suggest to use the key trans recipient info uh but well we could imagine different solutions just to avoid the updates of"
  },
  {
    "startTime": "00:24:02",
    "text": "of rfcs then uh some open parts are still left dealing with the certificates especially because it depends on the work uh that will be done on the pqc IX and finally uh maybe some algorithmic limitation should be put in the RLC especially dealing with the choice of chem for instance do we only specify the caliber algorithm or shall we extend this use to any cam maybe that's up to discussions and as well for the choice of kdf of the web algorithm should we limit them or should we be I mean quite open on the choice of the kdf should we use well she uh sha free or kdf base or maybe that's still open so if you have any suggestions I will be glad to get them and incorporate them into the into a diversity so that's it for this update so please if you have any questions suggestion [Music] please so um I think we talked in about uh keeping alignment the RSA chem was advisable um but to do something different if there were property that uh kyber we didn't know that which"
  },
  {
    "startTime": "00:26:02",
    "text": "one would be picked um supported but I wonder if if we would be better served by defining oids for triples that had kyber which kdf and witchcraft as opposed to splitting those out uh have you have you thought about that uh yes but we think that um the combination can make the the number of IDs really huge so that's the reason why we propose to clearly split the combination into free algorithm okay Sean go ahead I'm just gonna say that based on your uh request for input I would probably just do Kuiper and all three whatever strengths whatever they're called two four and five or whatever it is I can't remember the numbers um and limited to that and not try to um make your competent Torx problem more difficult than it really is but again I'm not a cryptographer so I'm just throwing it out there from like let's not make this too complicated we're gonna have enough of these um less options is maybe better yeah that's I agree but the only point is you know that uh in the nice competition uh there is another new round that has been opened for uh key encapsulation mechanism so maybe for the time being Skybar but maybe uh in a few years it could be changed or at least a update or enhanced so maybe that's quite yeah I think I definitely don't want to"
  },
  {
    "startTime": "00:28:00",
    "text": "get out ahead of our um ahead of our skis as some people would say to be specifying things in advance of what Nest is picked so I would just go with the ones that have been actually selected um and then when they come around if they pick another version with two or four or just one other one then we can update the specification do that there's you know there's not supposed to be that much um to do to spin out a new internet draft and update an RFC so I I think that's probably the better approach at least in my mind at least I I would also observe that if we take the approach where we're using key trans um then you really all you're doing is specifying the conventions for using kyber at the three levels and so when another one comes along we can write a similar one that specialized specifies the conventions for using that one with key trans uh go ahead Yuri first first I think uh it's there is some a confusion because uh Nest doesn't open fourth round for the key encapsulation mechanisms maybe unless there is a breakthrough and something with many times smaller key size and adequate performance comes up which is rather unexpected so we can probably assume that key encapsulation mechanism remains what's selected specifically kyber we can also expect I think that if in the unlikely case there is a new a cam it will satisfy the same constraints strength wise and of course it is"
  },
  {
    "startTime": "00:30:02",
    "text": "necessary to document those requirements to come regardless of whether we decide to stay with the nist selection which makes sense or go outside thus the open question is what to do with the kdf on the chat the argument is that one of the reasons to use kdf is to deal with the key size mismatch with symmetric key size mismatch that's a valid argument I do not think we need kdf for strength I would not argue for using it for size matching though again I find it a rather expensive older any response to that okay Mike Mike this is Mike go ahead yeah kill myself the response to Yuri in chat um so yeah the kdf was there I think you know super conservatively in case you know people end up wanting to put non-nist chems here that don't have that that property that you can just use their shared secret directly as a symmetric key you know there have in the past been chems that didn't have that property um I suppose if we're going to be sticking to the nest cams then maybe we do get to just assume that that property and maybe that design problem becomes simpler and then yes Yuri said the the size"
  },
  {
    "startTime": "00:32:00",
    "text": "mismatch you know we don't we didn't want implementers to have to worry about getting the choosing a cam that lines up with the key size of the wrap um so the kdf sort of makes that go away but I guess if Russ is suggesting that we we pick triples um chem kdf rap maybe we could actually reduce that down to doubles and just specify chem wrap if we choose ones that happen to have the same size and maybe that just makes everything clean over or even uh Cam and at least key wrap key size right um just a thought uh I mean I need to think it through some more but the slides made me ask that question uh go ahead Yuri um I I wanted to say that a of the old case camps that did not have the necessary properties probably shouldn't be considered here hopefully we'll learn something since and second making the requirements explicit would easily deal with this issue you would just look at the hash for example and say wait a bit we require hash that does not have obvious collisions this hash has therefore it is not acceptable it should be simple enough likewise with Cam with document requirements if a new cam comes for consideration and we see that it does not satisfy some of the documented requirements that's just not an acceptable Cam and why should it be over"
  },
  {
    "startTime": "00:34:00",
    "text": "there [Applause] Mike your hand is up is it a new one or no ah thank you Quinn Quinn we're not hearing you so um I don't I don't know what's going on can you maybe ask your question in chat ah there you go go ahead Quinn oh oh I'm sorry I I I didn't know that I got to click on on the thing um I have a few comments or questions um the first one is regarding to the the secret K in kyber chem um so the first option is to make the k 256 bits for all two or three uh cam options or uh on this could uh or we or we could um could you know make the the length of K depending on the strengths that we're targeting for example if level one we're thinking about AES 128 so we could make the cam only 128 bits or you know we yeah as you said so there"
  },
  {
    "startTime": "00:36:00",
    "text": "are two options there and um that's a second comment is that they got into the choice of the PDF um as uh Mike pointed out you know in the future if we wanted to use um a different cam which you know which does not have a PDF in the cam itself then of course we would need a a kdf to improve security of of the cam outputs um so that's there's a reason for the camp there um but if like the second choice I I just mentioned where we output the cam size it is you know exactly the size that um the algorithm needs like one two 120 bits of uh AES 128. um so there are two choices there um I don't know which way is uh the right way to go um and the third one is you're going to the choice of rap um I'm not sure if I get all the the understanding the the need for the wrap here because with the camera long basically you can uh you know both sides and can get and get the secret key without needing a wrap yes and the thing is the the recipients uh must do um a decryptions the bka decryption and then a bka encryption to check to make sure um you know the um the legitimate um ciphertext were received there is a chance of failure but that failure probability is extremely low like like"
  },
  {
    "startTime": "00:38:01",
    "text": "two to the two to the minus one uh uh 50 or something like that that's it's like it's practically zero so um so I'm not sure if we still one type of wrap in there or not okay just yes if I can answer yes to me the rapper algorithm is absolutely needed because the cam outputs a random key but in our case we want to send a fixed key because we want to send the same key to several endpoints that's why we need to master actually the the kit to be sent thank you okay um I would propose that we do a call for adoption of this work is there anyone who would like to speak against doing that okay thank you uh we will add this to the list of documents we're doing call for adoptions for thank you next up Mike is going to be your uh presentation on a hash then sign to be dip the slides up [Music] sound check okay and you should have slide control now"
  },
  {
    "startTime": "00:40:05",
    "text": "okay um I'll try and keep this brief so that Hendrick has time to speak about the team here it's more urgent um briefly this is a land mine that we discovered in the pqc the Sphinx the lithium Falcon we sort of stumbled with this laminate a couple weeks ago I know we're not the first people to stumble and do it but you know we decided to make noise about it so this is just a PSA talk to get it on our Collective awarenesses so we can start thinking about this uh so hash then sign this is a pattern it's used a lot and RFA required you to pre-hash um this pattern is pretty well baked into a lot of stuff where what you're sending to your crypto module to sign is a short is a short message you're not sending the entire plain text there's lots of good engineering reasons to do that um like for example if you're signing an email you could have a 25 Meg email with attachments and if you're signing out with a smart card you don't really want to stream the entire 25 Megs to your smart card um and I put a few examples every Network which are some similar example uh latency symptoms processing variable size messages blah blah blah and I put golang here as an example just to show how certainly ubiquitous this is the ecdsa interface in the crypto layer expects a digest that digest is currently performed at the x509 or TLS or what have you layers like this is a just sort of making a point this is a very well established pattern uh this pattern does not work with the three signature schemes that we're looking at Sphinx style lithium falcon it does not work because each of these algorithms internally begins with a message digest step that is prefixed Within nonce and in the case of randomized sphinx and Falcon that knots prefix is is a rat is"
  },
  {
    "startTime": "00:42:02",
    "text": "a completely random number chosen at signing time in the case of non-randomized sphinx and dilithium that prefix is derived from the public key of the signer so tldr here you don't want to pre-hash because you're sort of stamping on this hashing that's done as the first internal step of the algorithm um I started a thread on lamps and cfrg with a really bad email title last week and then yesterday Sunday I started a threat on the nist mailing list with a better title I think we've been getting some good responses and so it seemed like the answer is yes you really don't want to just prehash with shot 256 because you will clobber the security properties here so my fourth slide here I think we sort of already have an answer to this given the Miss nist manualist discussion this morning the answer seems to be question one yes we do care um question two can we safely externalize the hash step of sphinx die lithium Falcon outside the crypto module the answer seems to be no don't do that and then we're left I think then making this mailing list discussions sort of lining up with our question three here Chris said if you want to be sending a short message across the network to your crypto module then you need to Define an envelope layer at the protocol level which is sort of I guess what we were needling at here with number three so I just want to put this out for General awareness that if we want to support a prehashed mode in pkicks where you're what the the actual message you're signing is short and compressed and digested then we're going to need to Define that envelope format at the pkx layer and we'll need to worry about its security properties Collision resistance contains a nods blah blah blah we'll need to worry about all that at the pkx layer um that's it thought for General awareness I'll end here I would uh observe that this is just not"
  },
  {
    "startTime": "00:44:00",
    "text": "a prefix problem it's a CMS problem as well uh but uh go ahead Panos he kicks in the Church comment um so Mike thank thanks for doing that you know thanks for trying to collect the data and I'm not I'm not entirely convinced to be honest uh that we you know that the prehash fails uh for all of these cases I think we should read it on a per algorithm basis and in my opinion I think we should collect all the arguments against it because I'm not sure that what we're hearing so far are practical concerns you know there are cryptographic theoretical concerns and there are practical concerns so you know maybe for Falcon there are but I'm not sure there are for Sphinx and die lithium so in my opinion we should really understand the counter arguments before we embark on a trip and thank you for doing that you know my goal is to have to try to understand it a little better foreign okay anyone else want to comment on this um I realize it was a call to action not a specification to adopt okay Mike thanks for raising the issue um we'll move to Henry all the action here probably is for like Massimo Jake and Panos and Sean your draft that's doing dilithium like that's the place this would need to get addressed indeed I want to stick up the lithium and the CMS Sphinx draft as well and the CMS Sphinx draft and the eventual eventual Falcon equivalency I don't know if you want to stick placeholders in now because this we're going to need to sort this out one way or another"
  },
  {
    "startTime": "00:46:03",
    "text": "uh go ahead Yuri [Music] uh I just want to re-emphasize my previous argument uh dependence on collision and resistance property of hash of course we expect Collision resistance property of the modern hash and if you insist on using md4 grow up there over go ahead Sean um I was just gonna say uh thanks for that Mike I expect that you'll keep us honest so appreciate it okay then we're gonna go to Henrik status yeah so thanks can you hear me I hear you okay um thanks um for getting the chance to give a brief update um just one slide um early August [Music] um the authors of CMP updates including Mike prepared the zero zero version of the 40 to 10 bits and 67 12 bits which is mainly the original RFC text and then the zero one version where the we merged the changes specified in CMP updates into the documents and then we um did it did a review and"
  },
  {
    "startTime": "00:48:00",
    "text": "um provided some additional editorial changes um sorting out some things we came across while reading and added an action item for appendix C to be reviewed more closely fixed some nits and we came across the topic whether this is now a good point in time to also add support for cam keys in 4210 bits and yeah but this is just um that we wanted to to raise this issue and see whether there is any uh feedback or support for this activity finally it needs to be added to proof of possession as well as message protection um and if um cam algorithms will be supported in CMS envelope data in key trends then we have the support already covered with the change we did in CMP updates switching to envelope Depot data for transferring centrally generated keys so thank you for raising this topic we we had a short discussion um when we were talking about chems at ietf 114 and it was observed that we needed a proof of possession mechanism to go with that and I believe that Sean and Panos had agreed to put together a draft on that uh am I remembering that right go ahead John did agree I did agree to do that I haven't done it yet okay so uh assuming that comes to happen quickly"
  },
  {
    "startTime": "00:50:02",
    "text": "then I think aligning this work and that work makes a lot of sense otherwise we're soon going to be doing an update on uh 42-10 bits which uh seems kind of silly so let's just make sure those go together as long as they go quickly yeah um one one question Sean are you planning to um support chem key proof of possession for pkcs10 and crmf good question but I suspect it will depend on what we need yeah because pkcs10 sticks to self-signed at least as of as of today crmf has more flexibility here basically I think that was the reason crmf was invented was to be held in Keys yeah right so uh I don't know if we want to open up P10 no I don't that seems painful um more well more pain than I really want to endure oh um yeah we'll we'll get to that I mean my my I know that um uh we've already had some internal discussions amongst the authors about the motivations in which way we would do it and I think there were some other people that sent me a message off list that said hey if you guys are going to do this you also going to do this pop thing um and um we noted that we had this discussion and they provided their input so I'm sure it'll be a lively discussion as we figure out which one of the ways to to uh go but um yeah definitely on the thing and I'm also hearing put this higher up on the priority list and uh can do so okay great I appreciate that because I think that uh moving these together makes a whole lot more sense than doing"
  },
  {
    "startTime": "00:52:01",
    "text": "a second second update the 42-10 bits no completely agreed I've I'm I've been in your I've been in your shoes before and I don't want to add any undue pain that's that's not required awesome all right any other comments about this okay is there any other business then uh if not we're going to wrap up six or seven minutes early go ahead Quinn you have to push the the microphone at the top again there you go ahead Quinn maybe you're locally muted because we're not hearing you are you hitting me now yes now we hear you oh thank you I'm sorry about that um put that the rap and one of them was used to send um different Semitic keys to different um recipients right no it's in order to get the same key to all of the recipients so the cam gives a pairwise and then you wrap on that pairwise okay all right all right so basically we do different instances for for everyone okay all right I got that okay yeah thank you yep all right if that's it we're going to"
  },
  {
    "startTime": "00:54:01",
    "text": "wrap it up here thank you I think this was a very productive hour and uh we have action items for a couple uh document call for adoptions and we'll be having that uh shortly and uh I look forward to further list discussion on the topics that uh were raised by Mike all right have a great day thank you thank you bye thanks bye"
  }
]
