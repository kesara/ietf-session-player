[
  {
    "startTime": "00:00:05",
    "text": "um so if you subscribe to the Json path mailing list you should receive notifications now now this is a new uh group I just found Ali sorry draft in the professional good morning everybody thank you hello Glenn morning Stefan good morning good morning well we seem to have all of our editors and chairs here that's good should we wait or should we just start Greg's also here always all right great of course I don't see Greg oh there he is welcome Greg"
  },
  {
    "startTime": "00:02:01",
    "text": "James why don't we just get going yep we can do that uh I'll do the the usual starting point for the YouTube later um so for the recording later this is the Json path February 2023 interim uh as this isn't ietf meeting uh please know well uh and then the rules of the ITF apply to this meeting as it does to other meetings uh ministravio note takers I think Carson's put the notes Link in thank you uh blue sheets are automatic uh I guess we'll keep an eye out for the chat there's not that many of us um is there any agenda batching is there anything specifically we want to bring up today right there was some comments there was some conversation on the email and then we do have four or five issues there um I I think it might be most productive to ask our editors to lead here um on on selecting the the issues that need to be talked through Glenn and I have brought up a couple issues in the past hour or so that have sparked some heated conversation okay well I would welcome a suggestion for a starting point Glenn your mic's not working thank you um yeah why don't we go through the issues there aren't very many of them sure where would you like to begin well can we start with the agenda as you just showed it because what Glenn is saying is the third item on the agenda yeah but I don't we've never stuck to a particular order"
  },
  {
    "startTime": "00:04:01",
    "text": "we can always we can do this and whatever you'd like folks actually Kirsten Kirsten is right um sorry I should have I'm in the middle of the night for me I'm having a little trouble getting swiped in here um so yeah look I would like to uh informally see if we can set some goals I think that we are very near the Finish Line If you find the Finish Line as getting the sent off to the isg and starting the Fairly lenses uh set of steps from there to the uh to the real Finish Line so it would make me very very happy if we could at in the course of this meeting um nail anything down that needs it and send it off to the isg ideally sometime like tomorrow um for both of our drafts I think we're within the reach on both of those um who no no we haven't had a working plus call on the bass draft yet yeah oh yes you're right so so we can ship but we cannot ship the best route yeah right okay so so I so first of all um you know I have reviewed uh Carson's uh most recent update to to the reggae um thank you for catching those Corner cases on on the ecma expressions and so on um I think it's ready to go does anybody want to uh uh do we have consensus that we could send that one off foreign James you have your your Shepherd document it looked like in reasonably good order last time I looked at it yeah um I think they need to update the document Shepherd right up for that so that's something I can take care of uh offline and then yeah I think we can just ship it excellent I'm not hearing any objections"
  },
  {
    "startTime": "00:06:01",
    "text": "to updating the document Shepard Doc and then just shipping it yeah great great okay so then our objective should be uh that to take to uh get ourselves in a position to do the working group Last Call on the base draft what what is the base draft as as opposed to like the the iteration 10 that recently was published the same thing it means base as opposed to regas okay yeah okay so that's I think where we stand I don't anybody want to uh disagree with that snapshot of the progress fair enough now let's now that I'm kind of swapped in let's go back to where we were and and start looking at Karsten do you want to get in and uh comment on the agenda first or should we go to the issues now I think we can all go through the issues right Glenn where do you think we should start um well I'm hesitant to start at the top because I haven't even read the first one um we could go from the bottom get the historical ones out of the way first so obviously one five one is irrelevant wait I mean it's it's relevant but not for the first of this meeting okay so let's yeah so that's not relevant for this meeting the supplies yeah so in this one if you look at table 13 um it appears to me reading this that we're"
  },
  {
    "startTime": "00:08:00",
    "text": "using the word value and type the type column you just had it it was just there up it was uh and then trying to is this the table that's the table yeah there you go so if you go to uh the type column right in the middle it says value and that's the type in our type system and then also in abstract instance instances you have value with parentheses and some kind of parameter there and I think that's meant to stand in for the Json value of some sort and uh the using the word value both in our type system and for the abstraction of of what that means I think is confusing uh Glenn pointed out in the issue I think Glenn pointed out in the issue that we do use value for Json value throughout the document and so I think that's what it should should be uh but that means I think that we need to rename the type of value uh because I think it's I I think it's a little bit confusing well I departed when I was when I was trying to make sense of the table it is the Json video that is meant by by vague parenthesis we parenthesis right but we're talking about the one in the left column right yeah so I'm fine with the abstract instrument instance I'm fine with that okay my my issue is with the word value in the type column I think it conflates with the type the word value in the abstract instances column"
  },
  {
    "startTime": "00:10:02",
    "text": "I don't think that they're quite the same thing especially given you have the value true and value Falls just below and that's a that's another issue that's that I just created so that's at the top of the list we'll come back to that I mean they're not the same thing at all because um value in the left column is a time and value in the middle column is an abstract instance so there's but you're right they they do Collide as it were the terms collide yeah so what would be a good name for the type so here's one here's one straw man suggestion when I have an enumerated type I tend to put type on the ends of all the enumerated values you know string type number type option type so we could consider doing that saying value type I think I'm happy with that it does provide a distinction between the two now then for consistency you would want to add that to all of them and that would make some of them look kind of clumsy the optional note or value type but I mean it's just clear it's you know long variable names aren't terrible but I don't really care that much so I'm going to shut up now and we did talk in the issue about um renaming one of them to Jason value so that I guess that would be the type but then we'd probably have to rename optional node or value to optional node.o.json value the consistency yeah I think you're pending type to everything is well it really hurts but it seems to be the easiest way to to get out of this"
  },
  {
    "startTime": "00:12:01",
    "text": "I mean we could be obscure and put t on the end instead of type if I wanted to keep it short but we've been underscore teeth underscore T just like C programmers no underscore no underscore yeah I mean we're using Pascal case here we are not using snake case so yeah we could just add an uh uppercase t at the end foreign let's do that I mean that makes sense he means if you don't know what the g means it provides yeah I agree with Greg's and I would say the uh if you're going to do that then you need a note about the table saying the trailing T stands for type yeah I don't mind going for type it's it seems heavy-handed but it's clear I'm happy with that okay Carson would you be okay with type yes okay just recreate some headache in in formatting the other tables but uh yeah I can go ahead and create a PR for that uh it'll probably be tomorrow great okay okay so let us call that issue resolved okay that would take us to issue three eight three six eight yeah and that was three six six this was"
  },
  {
    "startTime": "00:14:00",
    "text": "three six six that we just talked about yeah yeah no it was 366 we just talked about yes it may be useful to look at the notes because I I'm trying to capture what we said yeah let's look at the notes here yeah I'm I'm leaving a note in the issue foreign except for uh oh yeah okay okay 368. you should say a lot of discussion here where did we get to yeah so oh I I remember this one so it's to uh potentially tighten it up to allow greater syntactic um uh compile time checking and now we're talking about options yeah so what would what would the spec would there be a change to the spec then no what we ended up uh at least with these last few comments um what we ended on was leaving at the white leaving the spec the way it is and then in my Implement my implementation I'll have like a a strict parsing option that if they turn it on then it'll check for things like this where uh input values aren't the right type or stuff like that it won't be spec behavior"
  },
  {
    "startTime": "00:16:02",
    "text": "um but I think that's understood from enabling an option um generally we have a spec implementation and you enable an option that's understood that you might not be spec compliant anymore um but I'm fine with that just being an option uh if we want to be tolerant by default I think the important observation is that we we have well-defined semantics with the type system we have and uh anything we we add to that is probably going to be very specific to the the specific extensions uh that are being defined so it's hard to come up with a general type system uh in the the base document that then will be useful for any further function extension that people will be coming up with uh so I think Greg's approach to to say this this is something that an implementation can do as a quality of implementation uh feature is useful and my comment was just to to remind people that this is not changing the normative semantics um so that that will stay in place but it's just a useful service station implementation uh you can offer so I don't think we actually need to change any texts here I agree yep in fact you know you can imagine you can imagine implementations that do all sorts of uh linting somebody somebody wrote the word linta and and be super smart uh and in fact you can even imagine things that are that are you know in systems that are known they know the shape of the of the of the Json instances that they're that are going to be processed and can be even even smarter on that so I don't think"
  },
  {
    "startTime": "00:18:00",
    "text": "there's anything in the specs that constrains implementations from being super aggressive in type checking so what shall we do with this issue are we okay to close it uh yeah I left it open because uh it's attached to the test Suite changes um I wanted to close it once we've merged that so that that those uh those new tests will act once we merge that VR um then probably several issues can be closed okay excellent okay everybody happy with that any objection to closing this no pleasure well I was thinking leave it open until the the test PR is merged with a test PR can reference a closed comment so that's yeah it's fine for the test okay like behind the spec because that's the usual way you think shall I close it yes please yeah sorry okay that takes us to 385 is that not a oh no that's not the same as three 66. this is just an editorial correction actually at the starting point we got a little bit uh sidetracked in the discussion about sub attacks by coercion it's up to custom whether we uh want to discuss that now yeah I think I don't understand I read this three times and I didn't get it because somebody explained what you mean by speculation we allow a node to be cursed into a value so if if a function requires a value as an argument and gets a note then the the value will"
  },
  {
    "startTime": "00:20:02",
    "text": "be extracted from the node and that only works for optional because everything um but so this is something that that I have been called calling coercion and um the same thing happens if function returns a node and that is used in a comparison environment so like we we handle singular paths by by essentially taking out uh the the node to to affect the comparison the value of the node to affect the comparison we would take out the the value of the node returned by the function so we have um some coercions that are essentially already implied by the grammar we have the the coercion in the function argument uh position and I think we we only differ in the use of the term subtype uh where I consider this to be distinct from coercion why Glenn considers a coercion to be a part of the subtype hierarchy and my problem with that is that that essentially the the hierarchy gets uh trivial uh pretty quickly once you do that when you say trivial do you mean um uh Turtle you know complete every every type is a subtype of every other yeah not not totally complete but yes so so essentially it will be um there will be an edge almost everywhere yeah um I noticed in 2.6.1 just above that table we start using the term coercion and I don't see where it is defined it's defined below table 14 isn't it"
  },
  {
    "startTime": "00:22:04",
    "text": "we never actually defined the term so that's uh foreign the term but we the substantive thing is below table 14 isn't it where there's two bullets are the two cases where we do coerce to get subtype so could we agree go ahead my brother said can be used in place of as opposed to is a subtype of so we can keep the subtype hierarchy clear and clean and uh don't have to mix the two up but the prop the problem there is that elsewhere in the spec we say things like um this is valid providing uh the function returns X or a subtract of x and if we have to then say or a value which can be converted to a subtype of X it gets a bit wordy I have no problem with that I have no problem with but uh value conversion I think I prefer that rather than um rather than claiming that it's a snub pipe uh I would like to have a question for understanding uh what what happens if I want to urge an empty note list what what what will the result be it depends on what you're going to in some cases it could be nothing it's an empty note list for my in my understanding what exactly is nothing else then an empty note list well we only Define two coercions actually and I don't think empty node list uh fits in either of them"
  },
  {
    "startTime": "00:24:09",
    "text": "okay let's think about that may be a problem so in in the grammar we have a separation between singular paths and and general paths which we call Future paths um and uh the the functional argument position can be filled in by either um so what does this I mean essentially you need to direct the parser to one of those cases well yeah there's two we talk about um a uh well-formness and validity don't we in terms of yes what makes it correct Json path and the parser I think will be doing the well-formness check checking that the Json path conforms to the a b and F and then on top of that there is a set of validity checks to do with um uh I Json values and uh and function types so I think it from from my perspective that's kind of post parsing but it still gives an issue an error before the um you know before the path is run well the the functional argument production says a functional argument is a filter path or a comparable a comparable is a singular path or a function expression so you are happy with that being"
  },
  {
    "startTime": "00:26:00",
    "text": "ambiguous can we look at this text because I can't hold it in my head which section are you uh just search for the the word function argument oh okay yeah so I've seen 2.6 so you see that function argument is a filter path or a comparable okay when you go to comparable which is in 255 . search for comparable equals uh scroll down a bit there you go that there you go right in the middle you see that it's adjacent value a path or a function expression that's a literal Json video or a singular path or a functioning expression while future pulse is uh um road path of Json path or a function expression um so this is all ambiguous which is not fundamentally a problem I mean we can't have uh ambiguous derivations in in a BNF um it's just that uh we we do uh provide some some guidance here that the function expression that uh goes into comparable is supposed to be an optional node of AU and the function expression that goes into a filter path is an optional nodes or subtype so it does make a difference"
  },
  {
    "startTime": "00:28:02",
    "text": "which of these two derivations we are actually using yeah I'm not quite clear it's early in the morning from here I'm not quite clear what the problem is though the the problem is that we may be relying on this comment meaning something when it actually turns out it doesn't mean anything oh okay yeah I mean I think that comment is um it's pointing out it's the um validity checks to do with subtyping isn't it do with typing that's that's where the normative text is I would say down in the function extensions section yeah so that that will say a function expression is only valid as a comparable if it returns an optional node or value on one of his subtypes so if you look at for example for example if you look at 262 then the second bullet in 262 says the function expression which occurs is a comparable is correctly tough if it occurs as a comparable in a comparison and the function is defined to have result type option loader value of one of its subtypes so that's that's amplifying the the comment in the ABN F if you like yeah but it cannot be decided whether it occurs as a comparable because the the grammar has multiple derivations here so this if doesn't make sense no I say"
  },
  {
    "startTime": "00:30:05",
    "text": "okay I think we've got an issue here I think it's different from the issue we're actually discussing but we should probably capture it I think that I think the issue well the the next ish the next GitHub issue actually relates to all of this as well subtly okay I wonder if we can capture this particular discussion as an issue well we've got it in our minds because it'd be fantastic to note it down I'll maybe take that as an action after the call I guess too too much to ask I I haven't quite managed to understand it I'd love to see you know some jotted text that that explains what the problem is here maybe I think is sorry go ahead I would like to to go back to the uh to compare comparable where functioning expression is used where we have been before 255 255 yes yeah you're there yes you're there no no no yeah fine yeah uh comparable is number string literal true false null singular paths or function expression for my understanding uh the result of a function expression should be one of the values above"
  },
  {
    "startTime": "00:32:04",
    "text": "but if function expression is an empty uh note list it doesn't fit because a singular path in my understanding cannot be an empty note list am I right yes yes a singular path can be an mg cannot be or can be can be oh okay so uh so it should be no problem because function expression uh will be or can be coerced to one of the above now it's this this gets into the next the next GitHub issue function expression can also return a Boolean an expression Boolean that is not equal to is not the equivalent of the Json Boolean which is the true false there an expression Boolean is like the exists operator and a function expression that is not one of those values listed there okay I slowly understand and that's the Crux of the next GitHub issue which we can come to later can we yeah let's check them one at a time because it's getting a bit confusing yeah I don't have a solution off the top of my head uh I I would prefer the the uh parsing to enable um prioritize choice so this can be implemented using a positive expression hi Grandma so I I have a greater aversion against the"
  },
  {
    "startTime": "00:34:00",
    "text": "grammar and ambiguity than than most of you but I also need to to understand whether we are making some some uh semantic Assumption of uh lack of ambiguity uh where we don't have it can I just check my understanding if we if we take something like a a numeric literal that's outside the ijson range sorry uh say a step and a step value in a um an index expression uh that's outside the adjacent range then that's valid in the abnf uh you know the the Json path is well formed but it's not valid in the spec because it's outside the adjacent range okay now where does that sit relative to your passing expression grammar concern would you want the peg to be able to detect something outside the adjacent range okay well I I mostly want things to be passed in such a way that the the subtype relationship will be will enable the the use of the result um so um with with your ijson concern uh there really is no pausing ambiguity so the the step number is uh passed and and handed uh to interpretation and turns out to be outside the ijson range so that makes it invalid but not uh not well font okay so can we come up with a particular example where the um the current abnf doesn't decide the syntax yeah at"
  },
  {
    "startTime": "00:36:03",
    "text": "is my example so it's going to be a little bit more uh verbose at what at the the the single enzyme that is both a filter path and a singular path so when you use Edge as a function argument then you can go both through the filter path case and through the comparable case which then goes to singular path I haven't quite got there yet um yeah I see what you're saying but I don't see what the problem is the the problem really is just that uh when we when we pass this we have two different derivations and I'm not sure that we um actually account for this possibility in all of our thinking okay so if you look at the comment behind function expert right at the top of the screen uh this essentially is telling you that the filter path uh accommodates functional Expressions that result in optional nodes or subtype or some type of that um and uh down at the definition of comparable it says it accommodates a functioning expression that is an optional node of a U or subtype of that and first of all depending on how we Define subtype that actually is maybe overlapping uh but uh it's definitely not something that that can be used to resolve this"
  },
  {
    "startTime": "00:38:01",
    "text": "housing ambiguity um so uh we we cannot really in other cases we're using the syntax to to clean the distinguish uh between uh filter paths and and their their uh derived Boolean semantics and comparables which have an explicit uh Boolean semantics and to hear this this kind of breaks down uh so I'm just trying to make sure that we can live with this uh breakdown um so we we can uh make sure that that we don't rely on the puzzle making a decision for us here which which really is one that is based on the return type of the function okay one question do we use the term filter pass anywhere in the spec yes if you look at the very top it's it's also in the definition uh section I don't know is it also in the uh definition section no um scroll up just a little bit in the in the text okay so that top ABN F block defines filter path well too far too far nope yeah okay yes okay okay okay and it's used about half a dozen times in the text yeah okay that's okay but what I'm struggling with is um the difference between a uh an existence test and a test expression parable"
  },
  {
    "startTime": "00:40:03",
    "text": "can be determined by context in the by the parser can't it so if it's if it looks ahead and sees a comparison operation and he knows the um the term is meant to be a comparison that's right is that is that a problem for a peg well the the Peg puzzle will just choose one of those deterministically while an A B and F General BNF parser will choose one of them non-deterministically um so it's life is a little bit easier in in the peg world than in the BNF world except that you have to make sure that the one that has chosen deterministically is the one that you actually want Robert is there no is there no concept of backtracking if you make the wrong choice and the thing doesn't pause then you can try the other the other choice um well in Peg if you make a choice and the choice actually works uh you are stuck with that okay so at some point I will probably uh make a PR that reorders some of these in such such a way that that working parsers always uh can can be stuck with uh but that's not my problem right now my problem is is that um the the grammar itself of course is a grammar but there is a comment in there that seems to uh explain uh that uh we are um expecting certain types to occur here and uh it's a bit weird to have different derivations that differ in the"
  },
  {
    "startTime": "00:42:00",
    "text": "expectations okay so playing that back in different words um if we stripped out these comments from the a b and F then we'd allow function expression in multiple places intestinal expression and filter path Etc and um that would get through the uh the parsing regardless of the type of the um function expression yes yeah and then we get onto validity checks and that might then cause a failure foreign okay so Glenn just for my sanity here are you it seems like you're making the distinction between the parsing and a compiling um so I can C sharp I can say uh true equals one and that would probably parse correctly you'd get you get symbols for true and equals and one but then when the compiler comes through and checks those checks that syntax tree it would see uh that true is a Boolean one is an integer and it would say you're not allowed to do that yeah I mean is that the distinction that you're making but basically yes but into the way it's frozen in the spec we talk about well-formness and validity and I think they're both syntactic issues but wealth formless is determined by the abnf and validity is determined by determined by some extra rules that we layer on top of your compilation phase in your terms right so um in the compiler Community whether what you just described is actually called semantics or is another form of syntax so uh yeah yeah those problems don't help that but so the the reason I bring this up is because if we're talking about well-formedness um I think above uh way earlier in the spec and I can look at this later"
  },
  {
    "startTime": "00:44:01",
    "text": "um I do believe that we say that well-formed paths need to need to execute um but not necessarily semantically valid or well-formedness well-formed paths need to be able to execute even and and if they're no now it has to be well formed and valid to be okay thank you otherwise it gives must give an error and there's a there's a capital must in there oh wait a minute if if we don't make that distinction we probably should now we make it right at the start yeah okay okay yeah yeah it's in section two one it needs to be well formed and valid okay okay so if we determined that it's invalid then we still raise an error yeah the crucial sentence is just after the two bullets in 2-1 adjacent path implementation must raise an error for any query which is not well formed and valid yeah so the the true validity requires that we have is that the integer uh numbers uh that we are using well I don't know what are relevant to the Json processing actually means but we can discuss this but the integer numbers must must be uh same and the the function extensions must be correctly typed and that that is then delegated to section 2.6 and 261 actually has the the text that uh explains that can we get rid of these unnamed sections these are actually"
  },
  {
    "startTime": "00:46:01",
    "text": "driving me crazy um so 2.6.1 has the uh type system and um it doesn't really say what a filter path or a singular path evaluates too does it no I mean 262 is where we actually Define the um validity requirements yes yeah and and there there are two if it occurs that are actually looking at the tree and not not just at a single occurrence a filter path in a test expression is different from a filter path that goes into a function argument what does a test expression exactly mean here yeah the grammar rule test Dash Expo yeah okay yeah test expert is very interesting isn't it because it's got two branches which take function expressions and which have different effects so the filter path Branch can take a"
  },
  {
    "startTime": "00:48:01",
    "text": "function expression which returns optional nodes yeah yeah but the the other one takes a function expression which can only return optional Boolean or a subtype so we can do the match without an equals comparison I kind of feel as if we need to um go away wrap a cold towel around our heads and write down some of these issues uh it's going to be hard to come up with it on the Fly in the precise text I think there's something there is a problem here it might clarify that if we had some example paths that illustrate the problem I think we need to make up examples but don't be honest I don't get it players might be speaking might as well be speaking Sumerian yeah can can you scroll through test Dash expert uh sorry which way am I going test Dash Expo maybe do a fine for it it's in 255. there we go yeah oh yeah so we see that a test expert is either a filter pass or a function expression and the filter path is either a path or a function expression yeah test expression doesn't need function expression in it that's redundant well it's not reduction in terms of the comment commentary yeah I mean the big question is does the parser decide which branch to go down in order to complete its the housing step"
  },
  {
    "startTime": "00:50:01",
    "text": "before we go into the validity check um yeah that would be a disaster I think some of this might be resolved if we move on to the next next issue to be honest okay let's let's give it a try why don't we push this on the stack and and see what uh what Greg suggests do what Greg suggests here which is uh 387 Greg yep okay so I've got some issues linked um we have previously decided that the match function uh is not a comparable it is not allowed to be um compared with compared using the equals or greater than or whatever uh functions it is it returns a Boolean and that was decided in 360 and I codified that in a PR in 365. um however sorry can I just yeah um I know that we decided that you could use a match uh on its own without a comparison where did we say that you couldn't use it in a comparison n360. can we can we see that please sure right it's linked right there or you can do that So currently those two examples were in there and we ended up removing in 365 that second example that equals true and we did this the"
  },
  {
    "startTime": "00:52:00",
    "text": "argument for this was that match returns a Boolean which is distinct from the Json value true or false I don't agree with it yeah why I we've already determined that comparables return to Boolean that is distinct from true and distinct from Jason true and false issue one equals two does not have a type so we cannot discuss this okay so if I were to say 1 equals 2 equals one equals one and put parentheses you would be okay with that no that that's the grammar doesn't allow you to do that why not well because that's the way we have been doing things of course we can change that but I don't see a big use case for that it's very comparable yeah I'm not saying that there's a use case for it I'm saying it's invalid because 1 equals 2 produces a Boolean an expression Boolean that can only be used with and an or or not yeah but you you are now trying to transfer some of the things that we're doing with syntax into the type system and that is neither needed nor does it work because one equals two really doesn't have a type a comparison can only occur in in certain places and in those places it doesn't have a function extension I agree with that statement 100 percent what I'm saying is match does not return a value a Json value of true or false it returns whatever it is that one"
  },
  {
    "startTime": "00:54:00",
    "text": "equals 2 is no one equals two is syntactically a comparison and function expressions and comparisons don't mix functional Expressions can be comparables but the comparison is the case if that's the case please uh James please go back to 360. so Kirsten are you saying that I could write an expression which I have the match on one side and equals the literal true on the other I don't have a problem with that expression being well formed or Village okay so here's my thing if the second if the second one is valid then the first one cannot be valid because the second one says that matches returning true as a Json as a Json comparable value and then the first one says that it's a test expression but a test expression cannot have a comparable value in it according to the and b f well we just looked at abnf that allows that yeah no no we yeah that's the other thing we're saying it has a function Express okay so we're saying it has a function expression that that I get but what if it returns a string then it's not valid in a test expression correct it has to return a Boolean in order for it to be returned in order for it to be valid in a function expression and the A and bf does not Express that no the definition of the the function expresses that so that's why I said"
  },
  {
    "startTime": "00:56:02",
    "text": "these comments are so incredibly important because the the comments a and bf isn't going to respect comments no but we have to make sure that that what what we think is happening here is is not just covered by a comment but it's covered by actual text somewhere yeah so it is weird to have the functional expression in the position that that it has in in the test expression okay so my thing is we we have one or the other on on my on my issue that I posted we cannot aren't on 360. you can have either of those two cases you cannot have both because of decisions that we've already made you could you pay for the decisions because I I don't know that yeah you see it my recollection is that we we want we we allow the equality option the second option but we didn't like the verbosity of it so we added a special some special cases so that you could write the match without the equality exactly the quality is incredible correct means it's not needed but that contradicts the decision we made earlier to not allow just random values as an extent as an existence test yeah but that's a validity constraint yeah exactly it's I'm saying one of those two cases has to be not valid no oh"
  },
  {
    "startTime": "00:58:01",
    "text": "then you just throw away hold on hold on two people are talking at once Carson's did you go to table 15 me so table 15 supports Greg oh interesting okay I actually removed that in 365. so what happened 365 was merged and note that I'm looking at the GitHub version yeah that's where that's where I put that yeah and the yes I added that it was agreed upon and yeah I added this I I changed this saying it's invalid typing as a result of 360. okay yeah so you essentially are saying that that the Boolean value that match returns is not a Json uh true or false but is is a different category of things like nothing nothing is already one value that we allow that is not among the set of Json values and we would have a function true and the function Falls or gesture test walls whatever that make up the the test Boolean type yes I'm calling that an expression Boolean just because that's what I've been calling it so I see an expression made up of comparisons which in essence compiled to a an expression Boolean which then can be combined with"
  },
  {
    "startTime": "01:00:00",
    "text": "the Boolean logic operators the Boolean logic operators have to operate on something yeah we record these tests somewhere else would be a test true and a test for it but that's fine with me I didn't put a label on it let's call it a test true and a test false or a test Boolean that's fine I'd like to Crow on the sentiment of people looking at the screen right now um that last one that currently is declared to be invalid uh are people what do people think about that it looks gross to me like the the literal truth just feels like a different flavor of thing than what comes out of a test test expression but what do other people think this comes like a consequence of this would be uh to substitute the nothing Thing by uh expression tool or expression false which which I uh do like a bit more The Proposal that is not a necessary consequence uh there's another weird consequence that comes out of this uh if we if we take that last example there the invalid one and replace true with an at dot a then hang on where'd you go sorry okay thank you uh if you do an at dot a it gets really weird because now you're saying I don't know maybe that's a valid use case for this yes I mean it's only weird if you already have decided that the test booleans are different from Json volumes uh but if you accept test"
  },
  {
    "startTime": "01:02:01",
    "text": "booleans as as equivalent to Json booleans then it becomes possible to say equals uh add dot a okay so then you would have to say that um test booleans are yeah that tests being a comparable with being a comparison or a function expression or an ex ists expression and one of those tests would produce a Boolean adjacent Boolean value which is the the true or false and then that would make the the expression true and false a valid Json expression which we decided not to do because we didn't want the Jason liberals to be valid in uh valid operands for the the logic operators right we wouldn't change that because that's prevented by the syntax um but uh when we've been trying to get in for a while can we have here from Glenn can we I was just going to say I'm just going to respond to Tim's question about the invalid typing example in table 15. um I I kind of uh yeah I kind of can see where that's going but the more General cases if you have an optional value such as return by length and you wanted to compare it against a uh a literal like one of ten uh and I'd want that to be valid so I don't really see a distinction between an optional um production of value which returns an integer and an optional Boolean returning true or false"
  },
  {
    "startTime": "01:04:04",
    "text": "but the integer you're returning from length is sort of not in the same category as in digital literal in a certain an integer value in a Json document I mean it strikes me that the the the namespace if you will the the space of function results is not the same space that of field values but the question is can we compare them or not right now function results are allowed as comparables I would say that a function that returns a value should be allowed as a comparable but a function that returns a test Boolean should not be allowed as a comparable okay but how about function that returns an optional value so optional value right now you've defined as a value or the optional Boolean and I'm saying that optional Boolean needs to be its own thing like optional node is what you just said is not true no optional value is either a value or nothing okay uh optional note or value so we already have to to allow that for singular optional value is optional okay so it says optional Boolean is a subtype of optional value I think that's wrong yeah because you're making that distinction now we're trying to tell you that you don't have to make that distinction so"
  },
  {
    "startTime": "01:06:00",
    "text": "in implementing all of this which I have gone in through and done implemented all of this in order to support the test cases that I'm writing I had to make this distinction in order to check syntax I had to come up with because I'm an object oriented I had to come up with classes and everything that represent the the test Boolean and a value I had to come up with all these things in order to get this to work properly but it only works properly if it only works properly with all those syntax checks if we make a distinction between uh Boolean and value so are you saying that if we if we made that last item in table 15 valid and it you couldn't implement it um I could not implement it with the syntax checking no I had it implemented without syntax checking and when I went to go put in some text checking those two last uh those those two last examples conflicted with each other I could not have both of them two possibilities either it's uh the spec is inconsistent or the implementation has a problem so to to pull the type system into the syntax check uh you have to know all the types of function extensions there are two types of functions a function that can return a Boolean or a function that can return a value well there are a few more types could return an optional node list"
  },
  {
    "startTime": "01:08:01",
    "text": "okay now in terms of where it can appear in the the expression those are the only two options for syntax checking you only occur you only care where it appear where it can appear in the options or in the expression you don't care if it can return uh nothing or if it can return a node list is it valid in a comparable or is it valid being uh being operated on by the and by one of the logical operators I maintain that it cannot be both we have to choose one the the syntax that is defined by the a b and F right now allows function expressions in three places and uh one of them is the the one where you only get valid by returning an optional Boolean right so thank you you're right Greg this issue is deeply connected to the previous one that we haven't yet written uh is there a chance to get to a result during this discussion or should there be raise an issue I already put in issue 388 to capture the the ambiguity sub issue and we don't have an issue yet that uh discusses with the test booleans and Json booleans are the same thing or different things I'm saying that we've already decided"
  },
  {
    "startTime": "01:10:00",
    "text": "that though we decided that long ago because you can't put true and in false we decided that and then we put it in to your point we put it in the A and bf that you can't have those literals in there because those literals are comparables not tests yeah I mean I think I think what you're saying Greg is that the philosophy was that that direction for literals and we've chosen a different Philosophy for the function expressions correct yeah and I agree and I did point that out when we went when we put in that shorthand and said this will cause issues to come out of the woodwork because it's a different philosophy I didn't use those words but you know see this was coming but nevertheless it's what we've got is consistent even though it's uh you know sorry it's not consistent it's uh it works it can be implemented even though it's kind of slightly inconsistent the way it's um phrased I think that we need I think the solution to this is how is to have different a and b f types for functions that can act as a test and functions that can act as a comparable yeah the problem is that these Powers executively the same way so that creates this uh ambiguity issue it's not I think if we're going to require the function types be declared then there's no problem right because then the parser has to know the function type yeah and that's exactly what I ended up doing in my implementation if you were to create a custom function you would have to say you'd have to decide which type of function it is and implement it"
  },
  {
    "startTime": "01:12:01",
    "text": "that way and I had to do that for for the four functions that we have yeah I mean that's interesting if you if you flip things around a bit and you say um that we essentially writing a an a BNF template and depending on what function extensions are available the that fleshes out the ABN F concretely in different ways you know so the actual match for example would be part of the ABN F and it would occur in some legs and not in others but that's that's a bit mind-blowing personally yeah they're also almost no tools that can do that so yeah um generally you you fix the the syntax at the BNF level and then then do all the the consistency processing at this first semantics level that is sometimes also called syntax um and that's what tools do um so I I don't think we can have the a b and F changed dynamically uh with new function extensions I think I'm going to have a crack at it sounds like a challenge and I I seem to be up to that challenge yeah but it would be nobody could Implement that so why why would we want to do that I have already implemented it I don't think so okay you're welcome to look at my PR and and my implementation on that brand yeah I have already implemented this but I can tell you already that I'm going to be violently opposed so what do you violently opposed to specifically having the the type"
  },
  {
    "startTime": "01:14:00",
    "text": "of the function create different ABN F rules for different function registrations well okay but you could imagine having an ABN F where you have different tokens for a a a test Boolean function and a comparable function yes that's what I want to avoid I can imagine that and that's exactly what I want to avoid why do you want to avoid that because it means that you cannot pass something until you know what the the function extensions actually have as a type and why is that bad pardon me I'm I'm not being or having a registry of functions so functions should be well known by the time you know before you enter parse I mean if you don't know a function you can't you can't even begin to process the the Json path right well that's actually depends on what what your definition of processes you can't do anything useful with it well I can put it into a processing chain so for instance I could convert the the Json paths syntax to some Json structure that I then hand over to to an AST interpreter um so I'm I'm not sure that that we would be significantly restricting the the freedom of of different styles of implementing this uh by by making the type decisions for functions uh during parsing time foreign that's something that I cannot really agree with"
  },
  {
    "startTime": "01:16:03",
    "text": "so if we had scissors or something like that that would clearly separate uh functions that can be used as test expressions from functions that can be used um as as variable expressions and from functions that can be used as node expressions then we we could pull this off but I'm not a big fan of of doing that kind of marking yeah you're getting into Pearl territory there yes um um having said that these things feel these these these different types of functions these different classes of functions feel very different in the way you would use them and so it bothers me that you can't reflect that fact in the specification of correctness foreign the validity to take into account um the the function uh types both the return type and the argument types um so we my concern here is that my concern is the return type how does it function with how does what is the role of the function within the expression basically and there are two possibilities here it can there's at least two anyway it can be a comparable or it can be a test it can be one or the other what's the third one a puff which can be both a comparable and to"
  },
  {
    "startTime": "01:18:01",
    "text": "test functions I'm just talking about functions yeah functions can return can return nodes on nodeless I'm not that's a comparable oh no it isn't you can use the angular path as a comparable you can use any path as a test expression okay so you can use any path as a test expression yes so in if a function were to return a node list it would act as a test but if a function returns my point is a function can only act as a test or act as a comparable it cannot act as as either well actually if it returns something that that has the properties of a singular path uh then it connect this either yeah a chance to flash this out a bit in the function extension uh section the type system and talk about the representation uh yeah there in the notes there I'll talk about optional node is an abstraction of a singular path and optional node of value is an abstraction of a comparable so the philosophy was to try and make functions returning those types optional load of value fit anywhere in the syntax where comparables fit and same for singular path and that was what was behind us comments in the ABN f I don't think it makes sense to have a function potentially act as both I think a function needs to be defined"
  },
  {
    "startTime": "01:20:00",
    "text": "to act as either comparable or a test any function that acts like a singular path can actually do both yeah and we also in the current text we also have functions that return optional booleans that have that property but uh even if you take that away we still have singular posh style functions function returns that can access both and I act as a Boolean if if the thing they identify exists or not if it is used in a test expression then it's it acts as a test if it is used in a comparable then the node is taken its value is extracted and this is fed into the comparison like with any other path already okay that seems undeniable um do we need to take this to a written form of communication so that we can okay so what's our what's our action that I'm coming out of this then is for uh to to do we have a sufficient repertoire of issues do we need to raise a new issue to right now okay we have sufficient dishes test bullion versus Jason bullion and the the pausing ambiguity and these obviously interact strongly but we need to resolve both okay I don't think they interact at all okay Kirsten can you take an action to"
  },
  {
    "startTime": "01:22:01",
    "text": "uh add the description to both those issues please hmm yes thank you my day-to-day is a bit full but I hope I can get to it by the end of the day it doesn't have to be today but um I feel that we have to capture that uh your your understanding of the the parsing ambiguity stuff because I haven't quite grasped that yet and uh I'm not sure anybody else has oh yeah there's a fuzzy spot here okay okay so we're going to take this to written form and we have the existing issues that we need so encourage everybody to dive in there and explore the space yeah I think all all those five issues are deeply related foreign okay you're right you're right yeah so all these fall issues from 385 to 389 um are deeply interrelated okay well let's all give it a best effort to get this thing sorted out and issue discussion my only contribution is can we please have examples in all the arguments foreign forces people to be more concrete and that's a good thing yeah"
  },
  {
    "startTime": "01:24:00",
    "text": "I would also like to have a an example of a function returning a note list I'm I'm I'm thinking about possible example but but I have no idea could somebody have such an idea because I I Echo what Stefan said I can't imagine one oh yeah remove duplicates so that takes a node list with duplicates and gives you one back with the duplicates removed and charging and I think there are a lot of other applications would this be useful in a filter expression yes this would be also my question maybe remove duplicates could be if you're saying if you're doing like a account remove duplicates is greater than you know one yeah County the unique currencies of or something or other yeah that seems it seems Edge Casey but useful Okay I uh don't want to forget uh maybe it's a trivial question for you uh do we have versioning with with trace and path uh is do we have what there was a noise there versioning I there are some comments were where uh there was talked about Json path version 2. 2.0 or something like that do we have versioning with Json path or not in the traditional sense of version um we can look to in the future re redo"
  },
  {
    "startTime": "01:26:01",
    "text": "the specification but we have to accept that rfcs are immutable yeah we could put a version number into the Json pass expression but that that sounds really ridiculous to me yeah so I you know you can imagine doing things like having you know in Jason's path version two uh the Expressions begin with two dollar signs right yeah so this would strictly be versioning in the sense of preventing false intermability uh which is so always something that that's worth uh doing but okay mostly when people think about versioning they think about uh something that has some levels of both backwards and forwards compatibility and I have I'm having a hard time imagining how that would work okay just to be clear I don't want to have versioning so I think we all agree here about this effect okay uh another question is about that index function there was an issue I'm not sure uh what was the reason to uh to close this issue I think uh that would be a very useful uh function I would say more useful than the count function what do you think so what one issue is that when people bring up examples for that they suddenly notice that they didn't want the filter or something that you can put into a filter expression but they want the"
  },
  {
    "startTime": "01:28:01",
    "text": "selector no no I don't want to selector I just uh yeah but I'll I'll reasonable examples that people have come up with actually you want to selector but we have arguments against the letter yeah so we we I think we we do have agreement even even though we didn't state that uh explicitly that we do not want to make this step at this point in time yes we agree so this this would be significant Innovation although there are other people who have something like the tilde operator and all that uh uh putting that in a way that it fits into our current framework would be a significant step so back to the filter expression case I think that there aren't that many uh convincing use cases um because generally you can just restructure your your expression in such a way that that you uh use selectors to go there um again the problem is that you only can filter on the things so in in the end you will have a Boolean value and and the question whether a path with some selectors in it returns a value is usually as good as going through an index function in a function extension um so you would need to to construct a pretty elaborate example that that has that doesn't have that property so I also defined how we could add something like indexing to um index access to the functional extension uh framework because essentially the the index function gives you the last segment"
  },
  {
    "startTime": "01:30:03",
    "text": "of the normalized path representation of the node that you are looking at yes exactly it's very easily to implement yeah if if you if you agree to the fact that a function uh should have access to the normalized path uh well it already has access to to the node itself but right now we essentially don't have in our model that the function can get at the normalized path of of this no that node and that would be a new thing uh we currently are completely mute about that so so I we would have to forgive implementers who think they can do that um but I think we we need to make up our mind whether that's a good thing or not no I don't think that we formally allow a function to access a normalized parts it can be simply implemented like that under the hood getting a value you will the implementation will build successfully the uh normalized Parts internally because it's Unique to get to that value and the last step before getting the value will be uh to get the key the index the name because that's the key to get the value so you you you have it without uh formally being allowed to access or build the normalized path you you you did it already so the the use case in that last comment there I think is very compelling where the person who wants to be able to write"
  },
  {
    "startTime": "01:32:01",
    "text": "a path that does this doesn't actually have access to the processing lot to the logic that's processing the Json path they own they are interacting with an API that says all right give me a Json path that's supposed to return a value and I'm going to use that value this way and they want to be able to get the key as that value um currently because Jason path doesn't have that capability in the syntax they can't do what they want to do through this API uh just to be clear I don't want to to use this index access outside of filters I just can imagine to to to think about this very useful index function whatever it's called right but if we agree with the majority of us agree to not add it to the function we already have where I think index would be more useful than the count function so okay it I I see that ex that that filter functions or function Expressions can be added uh also later to Jason part so it's okay yeah I don't think that adding a an index function that's only usable within filter Expressions uh addresses any of the issues that we've seen from users I don't know that it's worth doing that work right now I uh"
  },
  {
    "startTime": "01:34:02",
    "text": "see the point in doing it right now when it doesn't address what users want I explicitly ask for an example a use case I I didn't see till today a use case so I I don't see the value of an a tilde operator till the expression but inside so so I think that I think that as Glenn said uh you know adding that kind of new syntax is outside of our scope at the moment yes we could meet these use cases through the existing function mechanism that would be great um but we're not going to go further than that I don't think I agree okay folks what are we then done or um so I think we know what we're going to do with these we're going to take them to a deeper discussion um what else do we have to I think we can usefully put our time to at this point uh if and or when we plan any uh interim mating um why don't we push that on the stack for the moment and see if we can insert this mess on the screen out um because if we can then our our our an interim meeting would be as a consequence of lost call feedback wider last call feedback and that you know we'd have to wait and see when and if that comes yeah I'm that's fine but uh no I'm not I'm not advocating we we"
  },
  {
    "startTime": "01:36:01",
    "text": "do it but I'm just sort of wanting to get a sense of where to go now because um if we think that this is these are the last outstanding issues uh the ones that were these these issues that we'll talk through today then actually we probably don't need an uh a Cadence Spectrum meetings provided that we can get these addressed in a timely manner I agree yes okay in that case I think we are done for this time the floor is open for additional business if there is any so just to just to be clear um suppose we do get these uh issues resolved to our satisfaction and we've got clear consensus um we don't need an interim meeting to trigger a last call is that correct no that's correct okay thank you all right the last call is triggered via the via email on the data tracker okay it'll be a two-week period And then after that closes we'll go through the rest of the formalities of submission okay so in what I'm getting it is it we can agree to initiate a last call via email yes yes okay thank you okay sounds like we're done here okay thank you everybody for your time and I look forward to wrestling this thing to the ground yeah an email exam examples examples thank you thank you thank you"
  }
]
