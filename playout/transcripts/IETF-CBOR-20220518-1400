[
  {
    "startTime": "00:00:21",
    "text": "we are at the top of the arrow so far i only see carsten and marco let's wait a few more minutes for people to show up i know ira is not coming today he has a conflict but i have not heard from michael"
  },
  {
    "startTime": "00:02:45",
    "text": "so it looks like brendan moran will be coming specifically for the pact discussion that's good to hear hello rickard hello hello hello ah hello brandon okay maybe we have critical math now yeah i think so do you want to go through the agenda of july oh go ahead why not okay um we have two large um okay it's changed uh we have uh three and a half fields of discussion plan for today uh one being the tag 38 the extension to problem details that does the language direction and the half discussion attached to that is that we might want to talk a bit about how we evolve types"
  },
  {
    "startTime": "00:04:01",
    "text": "in general and on the topic of file of working group documents there's a question of the status of file magic and carson has a few updates on seaboard packed originally would have arranged these things according to the slides that carson prepared um but brandon if you are only here for pact if you want we can re um shuffle back so that we start with zebra pact and um i don't know if you're interested in the other topics brandon said i can call him when we do pact so okay great um any any additions to that any changes that people want to make any things that we should consider um before we head right into type 38 hearing he would be happy with us starting with bach now okay yeah then then let's shuffle around and do it that way and in this case either way uh floor jewels um i think you'll be sharing slides yep thank you okay so these slides talk about tag 38 first but let me just move forward um package um so we we just finished the programming last call we got a few responses we got a lot of offline thingies coming up here and there so i'm not even sure that the list that is on on that slide is is even uh complete so um i think um the the overall outcome is um"
  },
  {
    "startTime": "00:06:01",
    "text": "this can be done as it is but there are still lots of ideas of of maybe improving or changing it in one way or the other so i would like to bring up some of these items and some of them were really coming coming out of the blue um for instance uh i think christian was you who asked about deterministic encoding impact and i must admit i haven't really thought about that at all um and it's not even clear whether we are talking about deterministic forms of packing or packing of deterministic encoding um both of which are interesting um the the first one deterministic packing would be interesting because at the moment we um don't um specify the packer we only specify the unpacker so the the having the pekka produce something that is useful as a signing input um would be a whole new thing to think about but of course that's something that that any uh document that uses the the packed uh scheme as a normative reference uh might might be uh doing oh marco was it thank you and the the other thing packing deterministic uh would be making sure that our unpacking algorithm actually leaves something behind that can again be used as a deterministic"
  },
  {
    "startTime": "00:08:02",
    "text": "uh encoding and i think we we haven't really thought about that that issue either so i think some some thinking and experimenting will be required to um uh discuss this and um yeah i would like to hear a little bit about what people are thinking we should be doing with this go open so my take on this is that um we should treat them separately one of the points of of packed seabor is that it can be used in place so unpacking it and expecting to have deterministic encoding doesn't make sense to me i'd say that if you've signed something then what you've signed is what you get uh trying to pack something post signature makes no sense to me well you use deterministic encoding for many things not just for signing things but when you use it for signing then typically you don't have the actual signing input as as the transferred representation you're building the signing input from some data that you have so your database says this this particular playbook entry was produced by john and then you have a signature that that verifies that and um to to be able to create designing input"
  },
  {
    "startTime": "00:10:02",
    "text": "some form of deterministic mapping right right and i i appreciate this but what what i'm trying to say is that these are these that use case doesn't seem compatible with pact to me there are use cases that are compatible with pact um this isn't one of them so i think if you're if you're trying to construct things in that way uh packed seabor is probably not for you um that or there's got to be a fallback deterministic packing algorithm one of the two yeah so far we we have discussed packing with respect to generic pekkas which are really hard to get deterministic but if we have an application specific format such as for instance suit uh we might have very defined points where the packing mechanism comes in so i i even think it would be easier for these these application specific packed formats uh to be useful in a deterministic manner as well okay i think that that's going to be really difficult to to accomplish though it depends on how much packing you actually want if this is just a high level thing that avoids your format having to um define uh ways of avoiding uh growth redundancy uh then it might be possible but maybe yeah we actually don't have to solve it now so that that would be one uh outcome of the discussion to say um yeah this can be thought about but uh"
  },
  {
    "startTime": "00:12:00",
    "text": "please think about when you need it because your application will uh shape what what this is actually going to be and it's hard to discuss this in a lecture yeah that makes sense to me good but really this really was an example for why you need working with blast codes because it triggers some brain cells that are addictive and it's good to know that yeah this is at least now something that we understand the application developer may want to do at some point next question do how do we handle sequences now obviously you can pack each element of the sequence but that doesn't really allow you to to use the full redundancy between the elements so what we really would like to be able to do is pack a sequence and how do you do that well of course you stash this sequence into an array pack and then unwrap so that's easy um except that we don't know how to do this unwrapped thing and of course if if you come from the lisp world then of course you you immediately invent something that would be called unwrapped splicing which is a way to unwrap an array and put the elements of the array in this into the sequence where the unwrapped slicing data item was before so if you look at this example here with element one uh the the tag thing uh take n n n and element four so this this starts life as a three element um sequence"
  },
  {
    "startTime": "00:14:01",
    "text": "and what the unwrapped splicing essentially does is uh when you process it uh it expands into two more uh elements of the sequence so it's not just an array but the array that is in the square brackets but it says when you're done creating this array take it apart and put all the top level items in in that array as separate elements of the sequence uh into the sequence um so this is certainly something that that can be done it's probably something that implementations that that operate on sequences really need to expect because it's not at all um something that current would expect um so this this requires some uh processing uh and maybe the the first thing that that is going to be an implementation issue is that the overall sequence uh once you start reading it has the wrong number of elements so if you use this for instance in in a place where you would um distinguish different arrays by by different sequences by their size um you would look at the sequence before unpacking it and it would have the wrong size so for instance in in the example i made here you would look at it and say oh it has three zebra data items and only when you actually look at the zebra data item number two you'll see that it's it's unwrapped uh splicing uh so again the the application would have to be very warned about that um but i think it can be done in cases"
  },
  {
    "startTime": "00:16:02",
    "text": "where where you still would want to use a sequence because it's uh usually the the more efficient way of doing things but if you actually want to um put some packing in there packing across elements of the sequence this unwrap splicing thing would do it so that's something we could define in this document that's something we could define later so it's not really necessary to define this now but i think we should think about whether we have use cases that would want to use redundancy across items in a sequence or elements in a sequence and whether this particular solution already solves that problem so ricard when you think about adjoc for instance is that something that you could imagine using sorry did you can you repeat that you're referring to me or yeah i just wanna you are i think you your specifications uh um at least you you are involved with specifications that that use sequences and uh i was trying to to pick your brain here i think on the end doc point i believe marco is a better reference there because he's more actively working on that implementation we have uh so if he has any feedback on that point yeah that depends on the exact sequence you build maybe and yeah the amount and type of ead items probably yeah if you go for plain adult with no particular additions probably you don't reach a critical mass to get"
  },
  {
    "startTime": "00:18:00",
    "text": "benefit of this it really depends but not to be excluded in general either yeah so this sounds a little bit like like a lukewarm maybe um so the question really is should we try to define this thing now or should we define packing first and then go ahead and maybe define this unreplacing thing uh separately from that well my my my impression here is that this is would really work well independently of of packing and that will need a lot of use cases that we don't have yet and also maybe an impression of why are those users that use um c board sequences why are they are using sequences and can they just switch over to areas in that for applications like this good so um it seems we have approximately the same resolution again if somebody needs this we we know which slide to look at and can start working on this so next item so this is an example of of a case that maps really well to what the package does at the moment so assuming that you want to do some some string processing here and you have uh three um"
  },
  {
    "startTime": "00:20:00",
    "text": "uis that that use hd oh typo https packed example um the s didn't vanish for a reason it just vanished as a mistake um then you can extract the common prefix https pick the example put it into the prefix table and we even have a common suffix here dot html which is only common to two of the three but but still may uh worth extracting and then you can apply the prefix to the result of applying the suffix tofu and to bar and then just the prefix to n dot cbo so that works well um what we cannot do is is kind of the the inverse situation where the things on the outside change and the inside is is uh uh constant so i i've called this midfix uh here um which is different from circumfix which is again different um so we we um have the domain impact.example in all three entries of of the uh array or three elements of the array and we we extract the pack.example into the prefix table and now we can do something with that prefix table use prefix 0 to build the pack.example.html and again uh use that for uh bardot sibo uh and so on um and uh yeah the example works well for the"
  },
  {
    "startTime": "00:22:00",
    "text": "case where we only have a single concatenation but if we need two concatenations then uh we're kind of missing a construct so we don't have a tag that would allow us to outright concatenate uh two uh strings or other things that can be concatenated the concatenation is always combined in the current document with accessing the prefix table or the suffix table so in this particular case that there is a cup out of course you if you would know that you want to do this you can simply throw the the strings that you you need to concatenate into the prefix table um https and and co-op s and still build what what you need uh but that's not very useful for static dictionaries so the the use case where where the mid fix stuff is really missing is a use case where you would use static dictionaries um yeah so the the the status quo is we we cannot do anything for this uh use case except by by cheating like in this case which works fine for uh purpose built uh dictionaries is this something that we we want to look at okay it seems nobody really cares about that specific example too much"
  },
  {
    "startTime": "00:24:01",
    "text": "i i care about the case the the general case behind this not this particular style of composition so if we i think i've mentioned this in in my mail today too i like to have some extensibility on how things can be packed this would be a good example but i don't care too much about the particular case yeah in this case simply having a tag that takes two two strings and concatenates them would be all that's needed so if you look at this from an extensibility angle then it's easy to define a tag that solves this problem um which which will also kind of in in attack that concatenates might also help with the last case about the um expanding in the inside the sequence so maybe that's a topic we can extract from this brendan i think i was probably going to say something similar but from from a perspective of how this kind of thing could get used in suit i would expect that some of the the arrays that suit uses would have common patterns in them and being able to inject those common patterns into the middle of an array would be very important so that winds up being effectively a mid-fix compression i think that suit might conceivably make use of this it's really hard to know without uh without trying it out a bit more but um yeah i think mid fix certainly it's not like top priority for um for pack c ore but i could see it being useful"
  },
  {
    "startTime": "00:26:00",
    "text": "and especially when combined with with sequence unwrapping okay i will have another slide about extensibility and our strategy for doing extensibility here but it seems to me this is again something that is best discussed in the context of a specific application and if we have the extensibility in place to make use of this um then we can do it when we come to that application okay i have one more comment about the the fx packing so fx packing is currently defined for string plus string where the rom determines whether it's the result will be a text versus a white string so we already have a rule there that combines different types we have array plus array and we have map plus map but we do not have array plus map and we do not have a string plus map or array plus number um these are all invalid uh which is fine because we have defined error handling um but maybe there are some cases where it actually makes sense um to for instance automatically widen a single data item to an array or things like um that um so i think this this would be a good time to think about that in this case we wouldn't be defining a new tag"
  },
  {
    "startTime": "00:28:00",
    "text": "to enable this but we would be extending the behavior of the existing uh prefix and suffix referencing tag so that that's a very different um type the very different kind of extension we would make so i think we we cannot really completely cop out of that question we we have to decide we are going to do it now or we are not going to do it now but it's hard to edit later do you have examples of what an array plus map or map plus area might even do or what says so when you look at chris zipp's record type then you immediately have about 10 ideas of how you could use splicing together arrays and maps i haven't actually defined any one of these but it would be possible and when you're thinking about combining arrays and strings um you immediately think about python join um so i think that there are a number of combinations that are possible here that actually makes sense again it would be nice to have the applications that that uh really need that um but yeah when we look at the cri problem there we have a again a situation where we actually would like to combine things that are structurally not quite the same uh but we haven't even started to understand what we want to do there um so i think it's very much conceivable that you want to do that um but"
  },
  {
    "startTime": "00:30:02",
    "text": "natural way for combining these things that's but that sounds a bit like it would be either implementation or at least type specific what happens there and that sounds complicated to consider now yeah yeah so the question really would be can we do something now that would make it less of an issue if an application needs this um there i think you'll come back to this later um there is this point about possibly merging pre and postfix um styles and if we if we in some way generalize the pre and postfix maybe that joining operation will not so much be a property of referencing into a prefix or postfix item and then that this addition here would be described in in in pre and postfix terms but if if that composition becomes a property of the of the item inside the ethics list then that composition could be more flexible and we and we would have a way for placing elements in that table that brings with it some some composition rules and then we get all that flexibility there and don't have to define it for prefixes and for past fixes as a binary operation maybe that helps"
  },
  {
    "startTime": "00:32:01",
    "text": "yeah so the special behavior could be attached to the referencing tag which is relatively expensive because you you need to have a number of those referencing tags and you have to have compact encoding for them to actually benefit uh from from the packing or it could be attached to the table entries which we have avoided so far because it means that the table entries need some additional uh data attached to them or what we have done is we have actually attached some of the semantics to the table so these are approximately the three cases three places where we can do something um yeah let's come to that in a minute because before we do that uh maybe we should discuss extension points in general so it's pretty clear that we have an extension point where we define new table setup tags and in particular we expect to define a new table setup tag for every single static dictionary so that would be the normal way to do a static dictionary just define a tag for it um of course you could also do a static dictionary by by referencing some data using ui or hash uh and so on but if it's actually static and and standardized like like uh what was it three four eight five uh was then you would just give it a tag and then it's there so that that's an obvious extension point and we can define new reference"
  },
  {
    "startTime": "00:34:01",
    "text": "tags so we could define reference tags for midfix circumfix template expansion um and and so on but of course if we have new reference tags these either need to use the existing table so they would in the current situation use one of the three tables sharing prefix and suffix or they would define the the new table type the new table types and then we would have to explain how the table setup works so that that's pretty much the extension points that we have at the moment and i think you said that you wanted to bring up the ability to put something into the tables beyond just putting the the data item itself there yeah um yeah so i think whether it's in the table or in the data item in model-wise doesn't matter so much i would view it more in being inside the table entry but it's um how it's set up doesn't need to occur needs to match one by one to to how it's in the table so for example it there could be a table setup that still says we have a list of prefix things and list of suffix things but that populates a single uh a single sequence of somehow typed entries in the table that for example then contains three the first three items that are prefixes and thus use string concatenation if there are strings and every concatenation if they're areas and some post-fix entries and then if there's different um different table setup or an additional"
  },
  {
    "startTime": "00:36:00",
    "text": "entry to the an additional type of yeah if the if the table is set up differently then that could allow inserting elements to the into the table that have yet again different rules that would then be any kind of the circle made or other fixed entries so the the uh how do we do this now i mean we we the the question is how how do you do we define the extension point in such a way that we can add this later um in a way that that doesn't sacrifice backwards compatibility so for instance we could say that that one of these tables actually is not a data item but a functional and so you apply the functional to the argument of the the the content of the reference uh tag so that that would uh solve most of the problems and we could even hijack one of the existing tables by by saying the default situation unless you do this and this um the the functional is is essentially created by by doing the prefix or uh suffix operation um so that would be one way of doing it so right now we cannot merge um we cannot prefix the suffix tags uh so when you find a tag in one of the the prefix or suffix tables that that could have a different meaning than um other things"
  },
  {
    "startTime": "00:38:00",
    "text": "but that's maybe related to the next item so so um one question was do we really need to have a separate prefix table from a suffix table and clearly having one less table means that you save a byte because in in the table setup tag you no longer have to reserve an array for the prefix ones and the reserve an array for the suffix ones and it also makes it easier to actually use the same piece of of text or the same piece of array in both the prefix and the suffix position right now you essentially have to use one of the entries to refer to the other entry uh concatenating it to the empty string which does work but that's kind of ugly um of course the the next question is why do we separate the sharing table from the ethics uh table and i think that there are stronger arguments why one one would want to do that because the sharing table is just pointer chasing while the other one is is processing of uh strings arrays and and maps so it's a very different kind of operation but at least the the question comes up so uh given that that we have two positives here saves the bytes and makes it easier the question is wasn't there a downside and of course there was a downside because when you actually write down a reference tag and have exceeded the the range of of a particular length or size of reference tag then you get into the next one"
  },
  {
    "startTime": "00:40:03",
    "text": "these things for prefix tags we have this this first group of oneplus 31 or 32 references which are significantly more efficient and for suffix tanks we actually only have eight of them so as soon as you uh get out of that area you you lose a bite and that that can make a difference um with respect to to packing if efficiency i understand that right that merging the tables here when you say merging the tables here you still mean using the one different i'm telling which whether it's a prefix or postfix would still be done by the tag around the ramp item and not by the table entry right the the reason is that it's just very expensive to put that information into the table entry um of course we could invent less expensive ways of doing that but yeah these also require some processing then and and so on um yeah of course it would be much nicer to have a single range of referencing tags that says do whatever the table says and the table sent then says i'm a prefix i'm a suffix i am a functional um and then we have uh we don't need to spend another space of reference tags for the suffixes"
  },
  {
    "startTime": "00:42:02",
    "text": "but of course the point was to to use this for actually saving bytes in building that table the current document already makes a statement that prefix is expected to be the more common case so maybe prefix could be the default and then there would be kind of one but one byte marking for for post fixes for example um so the the the com the most common case would still be cheaper how do you do that one bite marking it's a two bite marking probably because we don't want to spend a one a a low tank for that yeah and there go your dodge htmls [Music] uh is that um it probably makes more sense to save a bit of space for simple cases and and most of the time i think this will save a lot of uh space and effort in simple cases it also means that you can i mean i think you've made the argument here already that it's easy to share affixes but i i don't know i it would be really nice if we could get a quantification for actual applications on the impact this has but um i don't think we have enough uh actual samples that for for real"
  },
  {
    "startTime": "00:44:00",
    "text": "applications that we can make a properly informed decision so this is going to end up being finger in the air regardless of what we do unless we do that i guess what i'm saying is i'm making an argument that we should get more test cases so that we can actually have some data and do some real measurements on how this impacts the results if we merge the prefix and suffix tables we could still get by without adding a couple of bytes to each suffix by actually keeping the suffix reference tags i mean this would be a little wart in in the um grand scheme of things but uh it would it easy to share the same string as a prefix and suffix and it would still keep the idea of open that if you put a tag in there then that tag tells you what the the actual functional is that is applied uh to the argument of the tag of the referencing tag i mean that makes a lot of sense to me um i think honestly you know it costs a bite or so you save a bite and sometimes it costs a bite for the size but overall i think it's a win to put them together because any time you share affixes you you gain any lost space right back and in the case of a functional that functional would basically get a boolean argument for free whether it's in prefix or in postfix mode oh nice yep"
  },
  {
    "startTime": "00:46:01",
    "text": "yeah i could sounds good to me okay i think i'm getting a direction here uh so uh i think this this has to be written up um but um i think uh i will be able to generate a good request from that and of course i also want to to change my implementation to implement that as well that makes a lot of sense i think okay as always tags are the one thing that make things possible in sibo that are not possible in other environments great so we have 14 minutes left let me quickly run through the the last three slides here um there were some editorial uh comments so i think we need terms like current table uh we probably need to describe the overflow implementation scheme because it's it's so much easier to think in terms of overflow than in terms of adjusting uh index numbers when when building augmented uh tables and uh somebody has to go ahead and write the pseudo code for for an unpacker so of course i could do that but then it would be in ruby again and i don't know if people are happy with that so maybe you can threaten to do it in ruby and then if nobody volunteers that's what you get okay um next item um interoperability um so"
  },
  {
    "startTime": "00:48:00",
    "text": "um i think we we have two natural profiles right now some people will want to implement this for sharing only because thank you brendan so um there are cases where the sharing really brings the the large benefits um and sharing has the advantage that implementation can do this with simple pointer chasing so you you don't have to do any string processing and so on so the sharing only profile of pac will be perfect for very constrained devices and the the sharing plus fx situation is probably the other profile where that that's everything but you could possibly split this into a strings only case and a full implementation that does arrays and and maps too because i think quite a bit fewer cases will really benefit uh from doing arrays and maps uh but they are really useful for some cases so i would like to keep them in um yeah so do we suggest these as profiles that was the main question i had on this slide and the other question was um do we maybe do specific tags just as we have take 51 by the way i give that thing a new number in in the next version uh because 51 is actually uh the number three so that's not something we want to spend here anyway um so should we have separate tags for these profiles um now that we are about to merge prefix and suffix maybe the expense"
  },
  {
    "startTime": "00:50:00",
    "text": "of having a single tag for both is no longer as big um yeah i think we need to take that to the list because the the time is running out but if you have a quick reaction to that that would be nice and while you still think about that the last thing is the draft currently still says informational and i think we have agreed to to make it a standards track and data tracker already says that and is that actually true sorry some email said it says that i didn't actually click that i changed the data tracker to say standards track so you should change the header to yeah okay so we don't have to run this uh um discussion again anything else on page so just uh the quick thing of uh uh chris zip's thing of um uh the record tags for records that's if if that's done that's going to a separate document so there's nothing in here for that right right that would be a standard specification that you put in for specification required even if he actually doesn't use any specification required tags anymore okay and of course we could think about how the the new idea of putting functionals into the tables uh relate to to what he's doing so there's a little bit of new thinking that may be coming out of of this meeting um but no change no change to pact as a result right okay so let's use the the last eight minutes to quickly talk about tank 38 which is being defined in the core"
  },
  {
    "startTime": "00:52:02",
    "text": "problem details document so we are not concerned with the whole problem statement thing but we are concerned with um the the change to the tag 38. uh just as a reminder this slide so if you want to say something like shalom then you have to change the writing direction and there is a common view in the internationalization community that this is best done by a separate argument separate from the language tag itself because a language tag doesn't really say you tell you which writing system you are actually using um and you can read the the references down here and we have a proposal in in the call draft that defines this uh um the the one thing that came up in the last minute was whether we maybe need a third value for the direction which is called auto in the w3c document so left to right and right to left are the ones that are really going to be used in the end but there is also an auto uh case and of course you could say you get this if you don't uh put in this optional element but if if this is used to override something that is inherited from the context you may want to [Music] reset the context back to the default so that's why it may be a good idea to have a third alternative uh there and more generally that that opens the question do we want to have some extensibility there so if we nail this down to those two or three values what do we do next week when we"
  },
  {
    "startTime": "00:54:01",
    "text": "find out that the direction this needs more cases and that maybe leads into the the agenda item that we may not have time for anymore which is how do we even evolve tags so this is the first time we we actually are changing um the the domain of a tag um so the meaning of text changes all the time because the the data that go in there are subject to various registries and so on but here we are actually changing the structure of of the content of that tag and so far we have avoided that um yeah christian um one tends to think that until one goes into a room where internationalization experts sit and you get out of the room with a really big headache and uh understanding why you want to provide these actions explicit i think i think i read one of the documents about this and i think they said that there are there's an explicit list of languages where it's recommended not to spa stated even that when it's right to left but there are languages where it should be explicitly stated because it's necessary but that that's all in the in the details of the languages so the the problem is that the unicode characters that are in that string do not necessarily all have strong directionality and as soon as you have characters with weak directionality in there uh you need uh the the context how to start setting up the bi-directionality uh engine and i invite you to go into the that"
  },
  {
    "startTime": "00:56:00",
    "text": "iat and uh thread where where people are pulling out old documents they have written 15 years ago that that show you really have to put this there and they lament that they are not that bcp-47 did not uh make this explicit but this is kind of uh oral tradition at the moment and and they have to fix that yeah either way that's the that's the domain discussion that we don't have to have here yeah and um so i i just wanted to to use uh three minutes here to bring up uh completely different approaches so the the we could do this as as it's defined in the current draft we could wait for bcp-47 to grow something that can indicate the direction in the language tag now that is unfortunately recommended against by w3c and also given the the pace in which internationalization discussions are resolved uh we are probably not going to get the outcome of that this decade yes in that okay so people don't like it at least some people don't like it and uh even if we like it it would take too long um so another way to solve this would be to separate out separate tags for direction only leaving tag 38 unchanged and wrapping the tag 38 by by another tag that does this base direction setting that of course would be a clean um solution um except that the the internationalization people tell me these really should be coming together it should not be uh separated um out um so yeah but that would be an alternative that would uh"
  },
  {
    "startTime": "00:58:01",
    "text": "make it unnecessary to change tag 38 but it would keep attack 38 there that is essentially um much less usable without the explicit uh direction information attached to it and then of course we could just define uh as many take 38 analogs um as we have directions uh so the the thing we are doing in many other places as well that we encode some of the information in into the tag number uh that that is certainly uh an alternative that that we should uh think about but looking at all this i'm still happy with what we have in the document but but i wanted to hear whether people have a strong preference a point i'd like to make for you for the one we have in the document now is that it's easy for implementations that don't that basically discard language and or directionality information because they can't process it because these will just see it's tag 38 i take element number one in the array and use that and discard everything else and if we get two or three or an extensible number of tags that's just a list of tags that i text to basically to ignore and pick this or that element from the tag for for those implementations yeah it's the second element yes this starts at zero good i'm done with my slides"
  },
  {
    "startTime": "01:00:00",
    "text": "and we are quite approaching the end of the time that was allocated um i we didn't really get to the point of file magic um i'll just take this as a point as take this as being poked as the shepherd to see where this is stuck um any further feedback on the on the tags this guy on the packed and 38 and if evolution evolvability would be much appreciated on list um otherwise we can still pick these topics up next week as well in two weeks as well so with that thanks everybody thank you marco for having me barry no just uh just agreeing that and thanks marco as always for taking notes appreciate that okay thanks everyone see you around thank you"
  }
]
