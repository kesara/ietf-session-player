[
  {
    "startTime": "00:00:13",
    "text": "all right it is 6 30 a.m pacific so let's begin oh hi everyone welcome to the first official working group meeting of the newly formed oblivious http application intermediation working group we are your chairs welcome and we have multiple notetakers thank you all for uh for volunteering um and for job describing uh richard and i figured that we can we can just keep an eye on the chat and relay any questions this is the note well please read carefully especially if you're uh this is this is your first ietf meeting but even if not please always be sure to be mindful of the node well and also the ietf code of conduct as laid out in rfc 7154 folks are expected to be courteous not engaged in personal remarks mindful of diversity and contributory and this is our agenda and we have a one hour slot uh reminder that the session is recorded and the blue sheet attendance is auto generated please keep video and audio off in case you are not if you are not presenting or not recognized in the queue and to enter the queue there should be a button over here which raised hand icon to join the queue so please press that in case you want to join the queue i'll pause here for a second to see if anyone has any comments on the agenda or wants to change it in any way please join the queue going once going all right so if not chris you're up"
  },
  {
    "startTime": "00:02:00",
    "text": "you can stop my slideshare okay um uh just to confirm you can see the slides great okay all right so thank you on um this is uh just an overview of oblivious http um i'm still going to refer to the protocols of http even though the word group has probably one of the best names we've seen in the itf for some time now um this is uh primarily led by uh martin but i've helped him know a little bit along the way um okay so the the problem statement for oblivious hp is quite simple um there are many many cases where you have clients interacting with servers doing simple very simple tasks like performing you know a dns query or executing a safe a safe browsing query in which in interacting with the server they're revealing a bit of sensitive information the actual data itself is sensitive and by virtue of connecting directly to the server they're also reviewing their identity that is the ip address of the client directly to the server as well for reasons it should be obvious this sort of uh exposure is not great from a privacy perspective because it allows the server upon interacting with the client to link both data that the client sends and potentially also receives uh with the identity of the client so if you consider the case of the dns queries this allows uh say for example a dns recursive resolver to collect effectively the the browsing history of clients and they may have you know uh policies around how those uh how that data is managed but um essentially it's it's it it's not great for the data to be uh collected uh or available in the first place"
  },
  {
    "startTime": "00:04:00",
    "text": "there are a number of other applications as well it's been discussed on the list for example uploading telemetry data from a browser or any other application to a server where the telemetry data might have sensitive information about that particular client's experience using the web page or doing some other activity where you don't want to link that particular data with a specific client and in general there's there's a lot there's plenty of applications um and scenarios where we have uh these sort of transactional you know single request response uh protocols um or exchanges taking place um in which the exchange itself does reveal sensitive information so bluey's http is all about trying to address this particular linkability problem of course there are a number of ways you could address this without any new protocol for example you could use a general connection oriented proxy like connect as it's already standardized or the hask or tor um but as of it's often the case that these uh these connection oriented proxies have much stronger requirements um uh extra privacy and on anonymity requirements uh in practice tor for example has multiple hops that clients go through in order to further off you skate and and make sure that um linking a specific client to a specific uh target eventually connecting to is is hard in the presence of some um some you know a very pervasive active attacker um and as a result of you know stretching things out or adding more layers or hops there's more overhead added to the protocol which is problematic because uh typically these transactional exchanges that take place for dns queries for you know telemetry uploads typically are just a single round trip and sometimes especially in the case of dns they're very performance sensitive especially if you're going to do a single request before you know trying to connect to a"
  },
  {
    "startTime": "00:06:00",
    "text": "particular server so if you wanted privacy using these existing technologies like mask or connect what have you you'd have to trade off um you know effectively performance um or you'd have to make a trade-off between sort of performance of using this particular proxy protocol and privacy you could for example get great performance with connect or mask if you kept the connection open for a long amount of time and then just sent you know these these single request response queries over that over that long lived connection but then you'd be allowing the server to potentially link you know these multiple queries of these multiple requests over the single connection even though the server might not know who you are um which is less good from a privacy perspective um alternatively if you wanted to break that link ability you'd have to stand up a fresh connection a fresh tunnel every single time which does incur a performance penalty um so in general um you know this trade-off is not great especially for performance-sensitive applications like dns and other things um and it's unnecessary it turns out um as is exemplified by obvious http um you can also go down the route of using a specific application specific protocol for you know breaking this link ability so in the case of telemetry where you are you know trying to it collects some information about you know what the browser's user's experience is like you you could collect this data in a privacy preserving way using something like prio or privacy preserving measurement there's a bluff happening later this week i encourage folks to check out um but these inherently are more complicated protocols involving more parties um and it requires infrastructure non-trivial infrastructure that is not currently there it's also true that oblivious http requires new infrastructure as well it's it's significantly simpler um and retrospect um [Music]"
  },
  {
    "startTime": "00:08:01",
    "text": "in the case of prio specifically as well um this these application specific verticals add delay um you can't just like collect the data instantaneously um and then look at it um whereas with uh you know the protocols that we're talking about here and oblivious http dns state browsing what have you um it's available immediately um necessarily must be especially for dns because again we want but that's a very performance sensitive protocol we need the response immediately in order to connect to a server so all that is to say there are existing techniques to address this particular problem but they don't seem particularly well suited to the applications that we have that we're considering here and this is where oblivious hdb comes into play it's a very very simple message-oriented proxy between client and server that combines two well-known things for achieving privacy uh and you know breaking this linkability between client and identity the first of which is a network proxy between the client and the target we'll call it um that exists to obfuscate or hide the client ip address or it's identity from the target server and the second of which is public key encryption um using hpke to hide data from the proxy itself so the proxy is effectively sending messages back and forth between the client and the target but it can't see the contents of any of these messages because they're encrypted that's the gist and here's uh just a sort of quick overview of how it works just to uh in case you're not familiar with it so the typical arrangement is you have this client proxy and a target and then typically you know resource for servers beyond a particular target i'm like sort of separating them here because the target has a particular role in terms of the actual encryption and decryption that takes place and the resource server is the one that actually has the content of the clients actually fundamentally after"
  },
  {
    "startTime": "00:10:02",
    "text": "so before anything happens it's assumed that the client sort of discovers some way you know mechanism out of band uh or are not not specified in this particular document um the the target hpke configuration that is to say the public key that the client will use to encrypt information to the target server then opens up an https connection to the proxy fairly straightforward and then over that https connection sends a public key encrypted http request which is then forwarded along to the target server who decapsulates it because it has the corresponding private key revealing the http request and then it goes off and you know get gets the resource corresponding to that particular request um generates a response in return or gets a response in return and then simply encapsulates it and sends it back to the client through the proxy so fundamentally what we have here are um well fundamentally we have here is a simple request response encrypted in each way and if the client was to send multiple of these each of them would be sort of unlinkable from from each other from the perspective of the target because all the target sees is a single tls connection to the proxy and then multiple encrypted requests or queries coming over it it doesn't know whether or not they're coming from the same client or not hey chris uh quick clarifying question um i noticed you've drawn this dotted box on the target server and the resource server um it does that indicate that you know in principle those two could be uh operated by the same menstru or could be instantiated on the same device without um undermining the security guarantees we're after here that's correct um uh especially in the case of dns or oblivious doe which is like the predecessor to this work it's advantageous for the target server and the resource server which is the recursive resolver in this case to be"
  },
  {
    "startTime": "00:12:00",
    "text": "operated by the same entity to minimize performance penalties involved um there's there's no i again as as i was saying earlier they've only separated them for the purposes of you know uh separating the roles that they play the target is responsible for the cryptography and the resources responsible for the application data bits um but they can totally be the same box the same logical entity thanks yep uh thank you for the question um so if we if we revisit the the if you think back to the the initial uh the initial slide wherein the server previously saw both the data and identity quickly convince you that that this is no longer the case in in this particular protocol assuming non-collusion requirements i'll get to in just a little bit so it should be obvious that the client knows both the data that wants to send and the data it receives as well as its own identity proxy however though because it's just sending encrypted requests and response between the client the target all it sees in clear text are the identities of either end so it knows the client that it's engaging with and it knows the target that's uh it's sending data to on behalf of the client but it doesn't know anything about the data beyond that um you know module like length of the encrypted data and whatnot but touch on that a little bit as well and then the target uh equally sees uh just the identity of the targets or the proxy server that's engaged with um as well as any of the client data um the that is the encrypted or rather the decrypted request and the response that's produced in result as a result and eventually sent back to the client um so importantly no single entity beyond the client has both the identity and the data um which is effectively what we're after here for the the various applications that we're considering um so the threat model is uh fairly simple um"
  },
  {
    "startTime": "00:14:00",
    "text": "it assumes some trust uh between parties that are engaged in the protocol so for example the the client in uh in its configuration and selection of a particular proxy it trusts that the proxy's not obviously just revealing sensitive information to the target like not just sending along you know the client h ip address and an http header along the request um and the target uh also assumes that the proxy is you know taking measures to ensure that it's not overloading uh it's not overloading the target um the the proxy as a participant in this protocol um making sure that you know the that the ip address is hidden from the target has a role to play um in the exchange and completion of a single transaction and as a result also has a role to play in ensuring that the system is uh available and not abused um the from a i guess collusion perspective the the core requirement is that the uh target does not uh you know glue with the share data with whatever with the proxy itself um because if you did have you know both of these entities controlled by the same by the same actor they could just you know put the pieces together figure out who sent what um which is obviously not great but in the sort of the configuration deployment models that are under consideration um that this this property sort of falls out uh and i was mentioning earlier that the proxy uh does not see anything about the application data um with one caveat and that is you know i guess you know properties at the ciphertext including the size of the ciphertext when the ciphertext was sent in response which means that things like traffic analysis uh you know how how plaintext should be padded before and encrypted uh whether or not timing is of concern um in these exchanges"
  },
  {
    "startTime": "00:16:00",
    "text": "um is not discussed in the draft and out of scope simply because i don't think we have a good answer uh for any of these things that is you know sufficiently generic and useful to all application protocols um there are some existing drafts uh and standards rather that that discuss how to use you know appropriate padding for the purposes of minimizing information leakage and encrypted dns i believe based on some work by dkg and others and so for specific application protocols that want to use oblivious http they can just follow that that specific application guidance as a a practical matter in you know using oblivious http there's a number of number of things to consider uh from an operational perspective i think the very first thing to to make abundantly clear um is that this is an application specific proxy protocol um so i mentioned dns i've mentioned telemetry data uploading i mentioned safe browsing queries as well it is not meant to be a general purpose proxy protocol for which we already have solutions if that was something you desired like connect like mask like tor and so on um importantly also that the discovery and configuration of you know what clients are sorry which proxies a client will use as well as which targets clients will engage with across these proxies um is out of scope of this particular document um the the the main idea is uh very similar to doe in that we're simply specifying the protocol mechanics and leaving the the deployment considerations to subsequent work um and subsequent uh i guess yeah effort either in this in this in this working group or elsewhere i forget exactly what the charter says about this um but anyways it's not in the stock"
  },
  {
    "startTime": "00:18:00",
    "text": "as mentioned earlier because the uh there is some relationship between proxies and targets with respect to um keeping this sort of service available and running proxies do need to engage in some sort of load balance management to make sure that they're not just abusing and overloading the target and taking it offline um and i guess finally as a practical matter because all of the public key material is uh sort of static it's it's distributed out of band discovered out of band and configured clients um it's possible for um uh proxies to take encrypted messages under these these static keys and replay them um and so targets need to make care targets need to ensure um you know that they are injecting pressure randomness uh into every single response that's it that's produced in response to an encrypted request and the protocol does dictate that this happens um but you know care needs to be taken nevertheless um to ensure that randomness is fresh there are uh a number of remember there are at least two implementations that we're aware of uh that are interoperable uh one of which was written by martin another one was written by me um and there is a test server up um that you can interact with a test target server that you can interact with that will simply spit out whatever bytes you happen to send it and then in an encapsulated http request um so uh if you're interested in you know bringing standing up an implementation of a client uh or a proxy um you want to make sure that you're interoperable i guess let me know or send a message to the mailing list we can share details in terms of like what the how to use this thing um but it's there ready to ready to be hit um and with that i think i'll pause for any like technical clarifying questions um and uh assuming we get through all those i'll turn it over to the uh the chairs to"
  },
  {
    "startTime": "00:20:01",
    "text": "to deal with this question tell me go ahead all right hello um thank you for the presentation um so one comment i just wanted to volunteer that um i did recently implement the protocol from the drafts both this and binary http messages and i think that the specs are good and definitely usable and ready for adoption based on that um i did have a couple clarifying questions based on that um that i'll just quickly ask um one of the things that wasn't obvious uh initially reading through the doc that became obvious implementation is the fact that the proxy has to have like uh a pretty static mapping to like when you give it a request where is it supposed to go on the back end and there's a fair amount of state that's not mentioned there so it'd be nice to see a bit more because that's a piece of the architecture that wasn't really clear but then the other question i haven't maybe this is the one we can address now the part about binary http being the body of this seems to be you know as there are different documents pretty disconnected um and like in odo you know we didn't actually have the interior of the oblivious message be http it's fine for it to be http but in this in the current document we are specifying like this payload always is a binary hp message um it seems that both the client and the target could decide to put something else in there is there any reason we need to restrict it to that um or can this really just be a mechanism where we have oblivious bodies that we send over http and we don't really care what's in them i i think the latter and the document is"
  },
  {
    "startTime": "00:22:01",
    "text": "at least the oblivious hdb document is sort of written in that particular way and as you point out as you observe um that is uh it it deals strictly with the the encapsulation and decapsulation mechanism doesn't make any sort of uh that i'm that i can recall stronger requirements um in terms of what is actually in the the encrypted uh payload so yeah it seems perfectly reasonable to me from a technical perspective that you know this just be a generic encapsulation mechanism encapsulation layer for things that the client target agree upon um oblivious or a binary http being you know the the the one that you you would most likely use um and on your i guess your your first question uh regarding sort of proxy configuration um uh yeah i agree certainly more information could be uh i guess included with respect to what state proxies need to keep in order to keep in order to route requests from clients to particular targets as you know in obviously erin oblivious doe rather um we sort of put the state on the wire um so clients would specify effectively the route via the request that came into the proxy um but oblivious http um the the spec doesn't require that to be the case although the the two are somewhat functionally isomorphic um uh and we can we can just add some rationale uh to the current design of the draft um if i could ask that you file an issue to that effect against the trap that would be that would be great that's good thank you richard hi yeah i just wanted to thank you for a brief chair note from the chairs um that on on the scope of what we're talking about there's been a bunch of discussion about collusion and proxy selection in the chat and this is just a reminder from the buff and the charter that uh the initial protocol we are to develop does not have those things in"
  },
  {
    "startTime": "00:24:00",
    "text": "scope so the protocol starts from an assumption that the client has selected a proxy server and a target server that it assumes are non-colluding how the client makes that choice is out of scope you can imagine a variety of ones ranging from fully automated discovery to highly manual configuration that is not the business of this working group um so um any discussion of you know how we um you know so it's up the protocol's job is to make sure those entities are identifiable to the client and um probably authenticatable by the client but not uh to talk about how they are chosen by the client thank you richard andrew so i was gonna exit the cube and i'll ask the question anyway which was what can we do to try and avoid the problem of colluding proxies um but uh noting richard's comment you might want to ignore that for now but i think it is a problem that at some point we have to address um otherwise we're giving the illusion of privacy but with absolutely no guarantees of anything whatsoever being provided to the end user so from an end user point of view i think that's hugely problematic um yeah i mean it's uh it's a good question um and i'm gonna punt uh because for now it's out of scope but um when we start talking about you know dynamic configuration of these things uh and actual discovery protocols i think we'll obviously need to address that but for the time being with the assumption that you know the configuration falls from the air and uh the the participants just run with it i think we can safely ignore it steven yeah so i don't know richard mike called this elesco but i don't actually believe it is i mean i'm not asking for discovery i'm asking for detection of collusion i i do think we ought to look at if is there any way that we could make it possible for some kind of transparency about collusion that might be post factor detected and only if you actively probe or something"
  },
  {
    "startTime": "00:26:02",
    "text": "but i think if we if this protocol provides no mechanism at all where collusion could be at some level detected even if it's post facto even if it's statistical then i think uh again the overall benefit kind of is is going to be kind of hard to see given who's likely to put up these proxies so i i would it's not about the ready for adoption call but i think the given the discussion in the chat it's worth recording that if we could have some kind of transparency at some level that might help people understand whether collusion is happening in the real world or not um sorry i'm not closely following the chat uh but the situation to me seems very indistinguishable from or trying to detect whether or not you know parties are colluding seems very similar to trying to detect whether or not say a tls terminating server is just like posting its you know keys to twitter or or you know sure my counter argument would be that we would have said the same but the web pki before certificate transparency probably um but given certificate transparency that's no longer true and again but not in an individual transactional kind of level but at some kind of if somebody clever goes looking level it's some kind of technical auditor type thing um yeah i i i uh maybe sure something is chair here it's like stephen if you have concrete proposals here um by all means feel free to propose into the list but um yeah i don't think this is something that's clear in the charter as a requirement and needs to be blocked needs to block the main protocol document all right so i think we've we've i think we've drained the queue there we closed the queue to try and manage uh the scope managed time here um so i think martin it is"
  },
  {
    "startTime": "00:28:17",
    "text": "this is the point that i wait and it's working okay so um tommy made made a point about the content of these encapsulated messages and i just wanted to go through some of the uh the stuff that we've done thus far um for carrying http messages so that you're able to use generic http in order to get the messages through we i've opened an issue in response to tommy's query and that is something that we can talk about later if we get past these things the initial more important issues but um for the moment the protocol is fixed to the use of this binary http messaging coding and how do i get to the next one all right there it is so um the idea is to cover entire http messages to the target resource everything is included including all of the the routing and encapsulation the method the uh url and it uses a binary encoding which is unambiguous and easy to process and uses a lot of the lessons that we've taken from http 2 and http 3 and in making http messages so it's not those protocol formats because well they're really complicated and things like hpac would rightly scare"
  },
  {
    "startTime": "00:30:01",
    "text": "people away from implementing them also some uncertainty about whether the compression in something like hbac is safe to be using under under the sort of adversarial conditions that we're using so forget that just put the control data in the header field straight in the message uncompressed and then make a few allowances for things that we do know that we need which is things like padding and the ability to stream requests and responses there's two mechanisms in here there's a fixed length one for those people who know how long every piece of the message is going to be before they put it on the wire and for those who don't which allows for uh construction messages that come in off another medium and also sending them on to another medium that little bit of flexibility is of course negotiable i have an implementation of this i heard that tommy has implemented some of this as well it's relatively straightforward i think it was about 300 lines of code in rust not that difficult most of the hard part of writing this code was parsing http11 messages which is what you see at the top of the slide there or rather in the middle because those are terrible in various ways so i'm here to really just say this is probably not something that this working group wants to take on we should take on the encapsulation part and all of the difficult questions that people have raised about how this all fits together but instead we asked the http working group to take this sort of work on i've gotten some feedback there this is in the right direction but that's all i have so martin just to clarify um and i guess for chris as well um it seems like oh hi"
  },
  {
    "startTime": "00:32:03",
    "text": "is not really useful if we don't have this format right because it needs something of this general character to get its job done yeah so it depends on the extent to which we allow for tommy's idea of generic uh things to to be facilitated in the framework so it doesn't it doesn't really carry http at that point but you can carry other things over http and so uh if we make allowances for that we could we could get this to work i think this is probably the right thing to do in terms of having carrying http and so i prefer that we we do this then you can make a generic http request more or less um and and then it works into it so then the for the work split would be that this working group would develop a general intermediation deliver this data through an extra hop protocol and then the http working group would make the here's how you generically encapsulate an http request and then if you put the two together you end up with oblivious https that sound about right yeah that's that's right and we can talk about what it takes to to do generic stuff for other protocols over the top of http but we will do the over http encapsulation ebits yeah it seems like we would at least need the semantic that um given the way the tunneling protocol looks you'd at least need a request response semantic for whatever you were telling right i mean that's a that's a limitation inherent in this and and to some extent that's a limitation that we need to discuss for http as well one of the the issues that i'd like to discuss later is whether we have some sort of streaming capability in here that would allow us to do more generic http messages than than what this"
  },
  {
    "startTime": "00:34:00",
    "text": "currently allows all right sorry and since i've uh injected my own questions using my chair privilege bit uh we have a couple minutes i think uh before we uh hit our sl our time to make the adoption call in um on the agenda if folks have further thoughts to bring to the mic on on before we take an adoption call i believe we'll be taking adoption call on the draft that chris introduced any thoughts my client is open eric howdy yeah um uh these three drops seem like appropriate learning points for adoption um uh i have no i do do not care at all whether like the binary one goes here here and i trust that someone can work that out i mean they say it'd be exactly the same people in their location so um certainly it doesn't matter um uh um uh richard thank you for for for trying to scope this as narrowly as possible um you know the issues are being raised here frankly are relevant adoption calls so i think the adoption call answers them i think we don't need to re-debate them watson i think adopt the first draft and punch the binary message strap to hdp more people who know about http are in that group that this group yeah that was that was the thought uh there are some fiddly bits in here it's not particularly complicated but uh it's worth getting those people to to do the work i think"
  },
  {
    "startTime": "00:36:02",
    "text": "yeah i'll want to check the charter to see if you know we it makes sense to extend this beyond http but i think even if we keep this working group http indirection specific um you know we can still take the dependency on http working group for the encapsulation all right last call for further comments on discussion here okay i think we chairs are working on getting this call set up siobhan do you have um have you figured this out yet um the uh the actual column yeah so i'm gonna i'm gonna try and do a show of hands here for adopting um the draft name do a show of hands on adopting the oblivious http draft as a working group item okay i'm going to start the show of hands now please raise your hand if you think that the working group should adopt the drafts that chris presented um as uh the starting point for fulfilling uh our charter milestones um and click the do not raise hand button if you have concerns about uh adopting this isn't working as a starting point for our working your deliverables okay so clicking the button now"
  },
  {
    "startTime": "00:38:13",
    "text": "all right things seem to be equilibrating closing the session now so that seems like pretty strong um agreements that um we're going to go forward with this does anyone from the not raise hand camp want to come speak about what their what your reservations are okay um so we will take this out and confirm it on the mailing list um feel free to contribute to any discussion there um if you've already raised your hand here there's no need to reconfirm it there we'll just cover any additional issues there but it looks like uh we have pretty good consensus to adopt this oblivious http draft and get to work on it as a working group item thanks all so with that our remainder of our agenda is set aside for looking at issues related to that draft i think martin you were going to share a screen to walk through issues there i have approved your screenshot i think"
  },
  {
    "startTime": "00:40:00",
    "text": "well that that's working really well for me i can't see anything working right now can you try again i'll go try again it's getting sort of a jasper john's vibe from that could be solo it wow there you go all right if at first you don't succeed so i i sent an email to the mailing list i didn't get any responses on this one but i put five of the issues that i thought we might discuss here briefly we only have 20 minutes so um feedback would be useful in any form the first question is really to what extent we're able to make requests and responses more generic so um probably the most obvious thing we could do to make request and response more generic and be able to support a larger subset of http capabilities is to make them streamable one of the things that that would allow is you could have things go via the proxy that include things like one xx status codes or long message bodies that could be processed incrementally and those sorts of things this comes with a cost uh primarily some sort of framing and a little bit of complexity although i think we can manage the complexity reasonably well by tweaking things like aads in the um the aead application or hpke so i'd like people's thoughts on this one and i'm apologizing"
  },
  {
    "startTime": "00:42:02",
    "text": "but i can't see the cue now uh so i guess this is uh sort of a base question in in how you're presuming this if if i currently have a setup where i have three of these proxies configured one of the things i can do is i can send information uh to to one and my next query to two and my next query to three essentially round-robining the queries uh even if they're to the same service by a different um proxies and that would work fine with the current set of mechanisms because they're four things like do was where the responses coming back are not meant to be uh linked to any state on on on the server um i'm assuming that if you made these requests and responses more generic um then you would have to then not use a single you know get or post as as the um as the unit here but you'd have to have some more generic way of of thinking about what the the the interaction set would be and i don't think i know what that would be and i wondered if you could describe that so i don't think we're looking to change the basic interaction model here so you would retain the same capabilities as before the only difference would be that when you construct a request or a response you would be able to construct it in such a way as that pieces of it would be available for processing as opposed to the entire thing i i don't know if there's any desire to go for anything"
  },
  {
    "startTime": "00:44:00",
    "text": "far more generic than that along the lines of what you described does that help um so it's gonna be a request response and and all of that so you would get correlation of request with response okay but um you would still say that if if i wanted to switch uh to the next proxy in my list of three for the next request in response i would be able to do that it would just be that the first response might have continuation in it like with a 100 is that is that correct that's right yeah that's right uh thanks for the clarification tommy next all right thank you um yeah on this i guess i'd like to understand what specific applications would need to have this more generic format um you know a lot of what i've been thinking about is we have these oblivious requests for pretty stateless simple request responses for more complicated things we can just do you know multi-hop mask proxies because we have to have stuff for that anyway from being more stateful can we get away without having this complexity and just say yeah there's a limited set of things and all the applications we know of will need this smaller set i think this is a reasonable approach to take it's the one that i took originally uh that that wasn't by accident but um i i thought it was important to ask the question because others others have"
  },
  {
    "startTime": "00:46:11",
    "text": "we're not hearing you mark but i see that you have the audio privilege still not doing anything and you're offline now new online modern technology i think maybe we can move on and uh we can i see mark back in cuba maybe i'll uh i'll vamp for a second while he uh gets audio going um so just to try and throw the uh decision into higher relief here um martin is the choice here between having more flexibility and capturing the entire range of interactions that http allows on the one hand and on the other hand having a simpler interaction model say a simple a single request single response and declaring certain http patterns cannot be done over this channel yeah i think that's right i i don't think anything here forecloses on the possibility of defining a new format to do more complicated things so we could even decide to do both but um it really is keep it simple keep the overhead low or try to get more of the streaming capabilities of http which are used in some contexts but as tommy says um because of the narrow application domain we could reasonably say that that those"
  },
  {
    "startTime": "00:48:00",
    "text": "are out of scope yeah i think personally like speaking as an individual contributor you're not a chair i think my preference would be to follow that ladder path and keep things simple in this iteration um even if that entails um basically disabling or turning off some some http features and putting chair hat back on i'll pass to jonathan so maybe this is just uh a stupid question but does this create a vector whereby you can make a you can more easily make a server store a lot of state like send lots of part one of six i messages that was true already although it shifts where you maintain that state so in the current design you can send up one of six but the server would would not be able to decrypt it so it would be holding the ciphertext and this one potentially changes that to shift to the application domain so if that's important that's important i don't know thanks mark you want to try again can you hear me now yes you can okay all right it's like this webrtc thing isn't done or anything um yeah i was one of the folks who was asking these questions and i don't have direct strong feelings about it or or concrete use cases this was just one of the things where it felt like we often put these artificial barriers in place you know because of design constraints and then applications immediately trip across them so we"
  },
  {
    "startTime": "00:50:00",
    "text": "should do so really consciously if we're going to do it um and and also to me it really spoke to the naming issue if we're going to you know not allow full hdp to come through this protocol we probably shouldn't call it oblivious or anything dash http uh which we'll probably get to that later because that's a big freaking bike shed but um that that's where i was thinking with with these questions was if you know somebody comes along and wants to do an application that requires you know larger responses for example or one xx you know uh uh you know non-non-final responses um you're gonna want this pretty quickly and it's gonna be pretty constraining for them yeah so i don't know if you missed this while you were struggling but um i made the observation that we can add new new i guess media types in order to support different uh different use cases so so i guess that's the question as well um as i understand it this is really a question for the generic proxy layer or or or how you how you uh uh bundle up the crypto i guess it's it's and it's also a question for things like one xx about the the http format so how do you see this being reflected in the two different drafts that's a good question uh i don't i'd be looking for text on that um um it's too early late for me to be cogent i feel that on the specifics there yeah uh yeah i i mean i i'm fine if we decide that you know no let's keep it really limited um i just think that should be conscious and then if we do we should probably think about the naming"
  },
  {
    "startTime": "00:52:06",
    "text": "thanks mark mark we still have i think a few minutes in case you want to talk about any other issues yeah i'm i'm going to just talk to these ones i think rather than subject everyone to 4k screen shares um if it helps i have uh just a summary of each issue at the end of my slides we could just pull that up um oh yeah but why don't you ask to i will do that maybe i can i'll do it okay all right so um the next one talks about um what additional data we need and this gets it into uh interesting questions about well two things really so chris open the issue and i think i split it two ways the first one i i think we're going to want to talk about the question of what information does the client or the server need to provide to the the intermediary in terms of what's going on under the encapsulation in order for it to more effectively do its job and my initial take on this and what's in the drafts is absolutely nothing but chris wanted to ask the question and i think it's a reasonable one to ask is is there anything that we might deliberately expose to an intermediary in order for it to more effectively do its job and that's really not something that i think we need to discuss here unless someone has a stunning idea but um if it's something that people might want to think about the other aspect of that that i think we might want to discuss at some point is"
  },
  {
    "startTime": "00:54:01",
    "text": "anti-replay capabilities so one of the more unfortunate properties of this is that the proxy becomes a potential source of replay attacks against the server and providing some capabilities or some sort of facilities for doing that is not something that the draft currently does but we might want to do things like put timestamps in messages in order to provide the servers with some tools that they can sort of hang their anti-replay protections off do people have opinions on i just wanted to if i may add some uh color to the the origin of the issue um just for people to have some additional context uh over in the uh ppm priv group or boss that that body of work um we're effectively reusing hbp for public key encrypting um data that could be easily fit inside of an http request from clients to these uh servers and it's been discussed a number of times that you might also want to compose uh or use ohio or ohttp for the purposes of sending these messages and in in that particular protocol right now there are some additional authenticated data that's exposed in the clear so the the idea was could you potentially reuse ohtp for this particular purpose including some additional authenticated data allowing one to deploy a proxy between client and server if you wanted one later on without any other sort of wire format change but i agree with the the pushback that has been discussed on the on the issue um that you don't necessarily want to be adding or exposing more things to proxies but that was the origin"
  },
  {
    "startTime": "00:56:01",
    "text": "thanks chris and sorry just jump in um so we are at five minutes four minutes now until the end of the session i just wanted to take a couple seconds here at the end uh by the way of wrap-up and next steps um you know we've had a good meeting here i think getting people in sync getting a good adoption call clear adoption call which we'll confirm on the list now as we work on burning down these issues and making progress on our new working group document um just wanted to see if folks would think it useful to have some virtual interims scheduled so we could do something like have monthly or bi-weekly calls to go through some of these issues and try and keep up the uh keep up the pace here um do folks have thoughts on whether that would be a good kind of face or what would be a good case here or whether we should just keep things on the mailing list for now martin cress's editors i have a preference for doing things in github been there enough times that i know that the mailing list is fine okay so we can focus on async for now um should um should we should real-time uh face-to-face be useful we are always two weeks away we uh the itf requires two weeks notice before we have a working group uh virtual interim so uh feel free to propose such and we can get something scheduled all right i think we are that is the last uh i had on my agenda so i think we are uh we are done here three minutes early so enjoy the rest of your ietf day thanks all yeah thanks all and thanks again to our notetakers and presenters"
  },
  {
    "startTime": "00:58:02",
    "text": "have a good ietf week you"
  }
]
