[
  {
    "startTime": "00:00:15",
    "text": "um foreign okay welcome everyone let's get going if you can take your seat please we are ready to go Danielle okay welcome everyone welcome everyone second session they're not well applies here so hopefully you're familiar with this already if not make sure you get familiar with this um tips for joining so please if you are"
  },
  {
    "startTime": "00:02:00",
    "text": "local use the meteco light client and make sure to log in because we don't have blue sheets anymore so that's the power blue sheets that helps you also get into the queue and please wear masks unless you are speaking um for remotes people make sure your audio and video is off and unless you want to speak up and please use a headset um this is the second official session um and we still have one more side meeting tomorrow at two o'clock I've done those updates this is Monday's agenda and this is uh today's agenda I'll be talking about jot embedded tokens um a tool we'll be talking about fine-grained transactional authorization hey Peter will be talking about cross device flows and Christina will finish it up with the client ID for anonymous clients and um on the side meeting tomorrow we'll dig deep into fine grain transactional authorization um we talk about um a security vcp and there's one more topic that I forget in right now but uh make sure to attend that to remember that yeah thank you okay okay let's get going then hopefully can drive there slides for me honest foreign"
  },
  {
    "startTime": "00:04:07",
    "text": "hello yeah okay um so I want to talk to you about a jot embedded tokens or formerly formerly known as multiple subject chart so um dick Giuseppe and I have been kind of digging deeper into this and we we want to give you a quick update on uh our current thinking and unfortunately we didn't have a chance to update the document yet but we'll give you some update on um what we are thinking right now and hopefully we can get some feedback either now or or later on so next slide please so just say some background um when we started working on this one um we had a number of use cases and those use cases fell into two different categories a use cases that require issuing multiple tokens from multiple issuers and use and use cases that require issuing multiple tokens from one issuer and we've tried to kind of um address both those cases in one document which made it really cumbersome awkward and not clear confusing so what we've decided to do is um focus on one use case or one category of use cases which is multiple tokens from multiple issuers and we'll look into the other one in the future maybe in a completely different document can you hear me clearly guys next slide please so the goal is to be able to bind one or more tokens that are issued from a multiple issuers"
  },
  {
    "startTime": "00:06:00",
    "text": "um into a new token and show the relationship between those tokens next slide please so why do you need this there are a number of reasons the other Trail is is an obvious one um in some cases also it's useful to use the information in those tokens to display information um to the end user and this is a I'll talk about an example of a telephone example that that is useful in that case and the third one is obviously evaluation authorization next slide please so um in in those use cases the multiple issuers use cases um the the tokens that that could be issued it could be an access token or an ID token so the the prime example for an access token that needs um embedded tokens is a stir divertic call so and and this is a telephone use case so equals B and the call from B is directed to C sorry somebody sing some no okay so a calls B and the chord from B is directed to C so when the call is redirected from B to C B will create a new token embed the original token that was talking about a column B and um and send that the new token embedded into the new issue token into C so c will when C receives that we'll be able to see that the original call was between a and b and now the call from a to c was redirected so that that's that's the use case right the other use case for the ID token is that hello use use case that um a dick is working on and um in the idea"
  },
  {
    "startTime": "00:08:01",
    "text": "there is you want to be able to link multiple claims from from multiple or different issuers for example you could you can get the date of birth from one issuer and um Education certification for for example from a completely different issue next slide please so the current thinking is that what we want to utilize the token exchange mechanism which it has all the the tools that we need with with just a little bit of a tweak so in this case um we want to send a request to to the as with that original token and ask for a new token but indicate to um the as to embed the token that we sent you in the new issue token next slide please so the responses will be a typical token exchange response with with a requested token um including the embedded token next slide please so to to do that we wanted also to define the new tokens claim in this case um we defined a token's claim that is um a list of objects and each object will have a information about the new token in this case we're talking about a type to indicate the type of token and the token itself so this is kind of a generic um means or genetic structure that will allow us to address multiple or different use cases next slide please so that's that's all all we have a again we haven't had a chance to update the draft with all those details that are still more details technical details that we're gonna dig deeper into and and"
  },
  {
    "startTime": "00:10:00",
    "text": "Define and make it clear but um just wanted to give you a quick update on our current thinking and if anybody has any comments question they happen to hear it right now got your own I think over time there will be multiple different semantics for embedded tokens and it makes sense to embed so to to include the the semantics so something signifying whether it's something trusting something else or just a combination of two things and probably many other things I'm not saying we should standardize semantics I'm saying we should have it explicit in the token because you're signing it and you want to minimize um a confusion attacks can you say more a little bit more like can can you give an example for example just just help me understand exactly what you mean by this it's really a question of use cases I'm not sure I understand enough that different use cases you're looking at but you probably don't want to to have an embedded token that's used for one be used for a different use case got it got it yeah that makes sense thank you any other comments questions there Brian go ahead I haven't read the draft well it's it's not up to date so that's why actually I may have read the last one I'm just having worked a lot on token exchange that jumped out at me and it looked like you had a like an extra parameter to indicate the interest in the semantics"
  },
  {
    "startTime": "00:12:01",
    "text": "yeah this is just a a straw man proposal right now we haven't dug deep into that yeah if you have any comments just some thoughts about it because it jumped out of me the the intended sort of point of extensibility with token exchange I know it's kind of a mess but the idea behind it was to use the token type as the indicator for that got it kind of-ish stuff and it's not perfectly clean I I know that but I would I would look at that rather than adding additional parameters to to maybe indicate both what you're asking for and what you get back got it just got it thank you that's very useful feedback I appreciate that okay that's all this oh who's who's before Robin open Robin go ahead the audio working can you hear me okay yep great uh yeah Robin Wilton uh speaking in a personal capacity just coming back to the the comment from the floor just now about um maybe not wanting a claim that was intended for one use to be repurposed for another one I I mean I think experience in this whole area over the last 10 or 15 years tells us that you can't you can't tell relying parties what to rely on so I mean my instinctive reaction is to that is don't worry about even trying to define the semantics because relying party's going to rely uh and I mean you know the canonical example is U.S Social Security numbers strict rules about what they may or may not be used for have no effect on who insists on having them and what they rely on them for so don't sweat it is my advice okay thanks thanks Robin is it yeah I didn't put myself in but okay go ahead um so because you're embedding the"
  },
  {
    "startTime": "00:14:01",
    "text": "original token you know inside the new one that you're minting essentially you're giving full control over that token to the recipient of that uh you know new token right right um so I mean the semantics essentially becomes like you've completely delegated that token to whoever is receiving the new token with the embedded tokens right um because if there is any other way like if there is any other restriction then you cannot actually embed the token inside that right you know yeah so that's correct yeah okay Kelly yeah my question is about whether this is intended to be within a single trust boundary as as the the term we're using in the the fine-grained authorization or across trust boundaries yeah that's a good question so so we're talking about different um issuers so potentially we're talking about cross boundaries here in this case right so if you embed a token generated by say one authorization server how would it be parsed by a resource in a different uh trust boundary is is that something you've thought about yet yeah so so like the whole idea is is exactly that like one Identity or one issue would issued one token that will embed it in your a new token that was issued as a completely different issuer and then sent to that I trust the outside token to uh but then still you have to parse it I guess right you have to understand you have to validate both right all right thank you yeah okay any other comments questions okay thank you very much that was very valuable feedback appreciate that"
  },
  {
    "startTime": "00:16:02",
    "text": "okay okay back here and I think at all foreign to drive the slides from here uh yeah you can drive it there's not a lot of sites uh hi everyone uh my name is Atul tulsibaba uh I have been working with a bunch of folks in this room uh on uh this fine green transactional authorization um idea or requirement and while we are not get at the stage where we can talk about specific specification proposals uh today I would just like to cover the work that that group has done and the charter that we have come up with and since I didn't take my own pictures I used a stock photo so um yeah I should have asked you um so yeah um the the motivation is we want to secure communication between microservices both with inside a single trust domain or a single a single VPC if you will and across trust domains right so this is so that if there is a software supply chain attack or other way in which a sort of VPC is compromised you cannot have a elevation of privileges or you cannot have a impersonation of users within those uh"
  },
  {
    "startTime": "00:18:02",
    "text": "you know within that trust domain and um this essentially has to be based on standards because organizations are going to have um you know vpcs in different Cloud platforms between on-premise and Cloud platforms and stuff like that so unless we solve this in a standards uh you know Open Standards kind of way we are going to be stuck with you know crummy solutions that cannot easily cross boundaries of these uh Cloud platforms next please um there's a lot of work uh prior work that has been done and I will just touch upon each one of these uh so the Netflix blog just talked about how they can emit tokens which I think they call passports uh that can pass through the system without the ability for anyone to alter them and so that way you cannot have impersonation or you cannot have uh privileged escalation within within a call chain but this of course Works within just one trust domain and it also as far as I know does not protect the call chain itself so you can actually take that token and use it somewhere else and uh it'll it'll just work uh Athens is a sort of a Yahoo you know Verizon uh open source project and that it has these uh centralized and decentralized authorization uh capabilities it is meant for the same application but from the website it wasn't very clear exactly how these things worked uh so I'm gonna just make a mention of it and you know uh you can read up about it uh you know later um George I don't know I I don't I didn't see George as a attendee remotely but uh George has been active in in this working group and oh he's there awesome um so um he presented an identity identity Wars 2020 a short-lived"
  },
  {
    "startTime": "00:20:02",
    "text": "transaction tokens idea which is jwt-based tokens that last a very short period of time and you know that can embed the uh identity and authorization information so that any service using that within that period of time can can rely on that to identify the user and the authorization scope it does not again bind the call chain to those tokens um so that's a potential limitation if we are interested in fixing that uh rifat just talked about multi-subject tokens or I guess now it's called multi-assure tokens uh so um and then Kelly has uh just put in a proposal I I saw a draft being submitted just today I think but we talked at I Kelly talked at ietf one in film Philadelphia about token chaining basically the idea is how do you cross boundaries uh between let's say trust boundaries like between two different organizations or uh two different you know Cloud platform instances of the same organization so you have an authorization server on one end and an authorization server on the other end and you mint a token from the second authorization server for the outbound call to use so that it can actually cross the boundary and be accepted in the next uh you know trust domain and then you know I just uh presented uh in uh ietf114 as well about the generic problem architecture and I can we can go into that a little bit uh um so this is in general what we were thinking about as the problem architecture and um the idea here is that there are multiple uh vpcs as you can see and it could be the the vpcs belong to the same organization like in this case the vpc1 and vpc2 belong to the same organization"
  },
  {
    "startTime": "00:22:01",
    "text": "or it could be that you're calling a third party API and you know that belongs to a different organization but it could be that the data in there is of your own organization so you want to make sure that um none of these call chains essentially can result in a privileged escalation or a user impersonation uh within that sequence of events and um the different colored services like the uh you know the Blues Blue bubbles uh represent external externally facing rest apis that can be called by um you know uh publicly sort of documented clients and the yellow bubbles represent my what I'm calling pass through microservices what that means is um they need not necessarily need to know the identity of the user but they they can just pass that token through to a resource uh microservice which actually needs the identity of the user right so if let's say I'm writing a microservice that just Aggregates information from different other microservices I don't need to know who the user is right I can just pass that information to the resource microservice and then get back the data and then aggregate that and send my response back and um yeah so that's sort of the general architecture that we've been working with and so now let's come to the Charter that we have defined um next slide please yeah um so we we had a couple of workshops or actually one workshop and a one one call after that we had all these companies attend um and we've now got certain proposals to the um uh existing Charter you can download the charter I just put it up on our website and you know you can download it from there um but uh you know other uh attendees May later add themselves uh so next"
  },
  {
    "startTime": "00:24:04",
    "text": "slide please so let's let's go into the you know what what is in sorry somebody say for an ITF group or chapter four or Charter for the work it's Charter for the work we haven't I mean we expect the work to happen in O Arts you know it's one possibility right but you know uh we haven't quite defined that yet so um so we would like to cover in this uh work both you know interactive and batch invocations so uh interactive is where the user is actually uh present and a batch invocation as well something's acting on behalf of the user um and then there are invocations which could be synchronous which means that the the expectation is that the call will return in a short period of time or it could be asynchronous where it could take much longer and um there are trust boundaries so these are like things like you know an on-prem uh on-premise uh installation that is then talking to a cloud uh service or uh you know services within one Cloud platform um maybe it's the same organization's tenant and just as an example AWS uh talking to a tenant in Azure uh belonging to the same organization so it's um you know those are the trust boundaries that we are talking about and we're just defining our PCS as something that uh is the actual call made between microservices and the call chain is the sequence of events that uh result from an invocation at the top level which could be a user like an interactive invocation or a batch invocation right next slide please right so I'm not going to read this a lot but this is the purpose of the group right we want to make sure that it provides"
  },
  {
    "startTime": "00:26:01",
    "text": "um it can convey authentication uh without modification it can provide least privilege fine-grained authorization so the Scopes that are defined uh for the call chain can be very fine grained and it can provide the context information uh required to um you know in an immutable sort of way so that you cannot do things like let's say I want to put in a buy order for a certain stock something in the middle can't change that order value or the you know the sort of the security that I'm buying um yeah so we want to limit the scope to basically just you know providing the framework to communicate identities uh that's one part of it which is uh you know how do you identify the same user when you're crossing a trust boundary right when you're uh let's say in uh you're in a VPC that is an AWS and now you want to go to a VPC that is in in azure how do you talk about that same user on both sides right so that is just a framework for communicating the identity not trying to define a new identity format or something like that but just arriving at a Convention of how we will identify the user and there's some existing work out there like in the ietf SEC events working group that we could use potentially for for this purpose um and then we want to also uh provide a mechanism for security securely communicating that identity and authorization information and the context information between services foreign and so what what information are we talking about right so this is these are all the things that we want to make sure that the identity of the principal you know uh invoking the call is preserved uh we also want to make sure that the identity of the services that are in the"
  },
  {
    "startTime": "00:28:00",
    "text": "call chain is preserved and um the authorization scope you know as defined at the top level but also if it was uh downscoped or modified along the call chain you know that information should always also be present and uh you know the context of the uh invocation should also be preserved right so that you cannot mutate um you know what it is the call is about so these are the pieces of information that we need to preserve along uh in the call chain uh as we go I think we well okay about 15 minutes do you want to kind of maybe a little bit wrap it up in in a few minutes and get see if there is some feedback yeah so um we're going to have a little more discussion tomorrow um so uh I think there's just one more slide that I want to okay um let's let's skip this one um let's skip this one as well uh let's skip this one as well um yeah so these are the things that we would like to discuss right so we want to uh we want to discuss things like you know uh the short-lived tokens or the efficiency considerations because this is something that that is going to have to go with every RPC between microservices so it needs to be super efficient um you know how do we verify the call chain and I think we've had some good discussions uh in the last few days over here and so we there is some clarity on some of this but uh I think it'll be good to get opinions from everyone about you know how whether this is important or not important and so on so um that's kind of uh we'll be discussing some of those tomorrow uh would love to encourage people to participate anybody has any thoughts at this stage I don't see anybody in the queue"
  },
  {
    "startTime": "00:30:02",
    "text": "all right so yeah yeah we're gonna discuss this in a bit more details tomorrow so encourage people to join us tomorrow okay great thank you thank you okay Peter may I follow you here no I I am to give you control yes again no you should see it just kidding me try someone again did you give someone his control no I'm okay yeah Big Slice control impact take it back and redo it or Bachelor yeah okay let me take it back just simple all right uh thanks everybody for coming this afternoon"
  },
  {
    "startTime": "00:32:02",
    "text": "bit more about some of the Cross device flows first I just want to do a sound check and everybody hear me okay is the sound okay good so you might want to adjust that yeah there we go even better all right um okay so um I'm going to talk about cross device flows I think this is a topic that we've discussed at a number of venues and I'm going to give a little bit of an update on the progress that we've made and also just a recap for folks who may be new to the topic as well okay okay here all right yeah oh I didn't need to look back thank you she's unblind all right um so uh there was a challenge right you have to take a picture locally and this is mine mind the gap and it's actually kind of topical for this presentation uh because it turns out there's a couple of gaps that we need to pay attention to and um and maybe we just need to put a label up or maybe we we also need to do a little bit more so uh first of all right I'm gonna talk very quickly just about the problem as a recap a little bit about our journey so far you know how we're thinking about managing this risk some proposals um I'll I'm going to talk a little bit about the draft proposal that was circulated maybe two two and a half weeks ago um and then I think a question for this room and for this audience is what do we do next right where do we go next with this uh with this work if anywhere okay uh so uh one of the things I want to maybe just start with is just this idea of an attack and and where are these attacks on the identity systems come from and so uh if you look at this graph it's kind of interesting right there's sort of an entry point uh right at the the start which often involves social engineering Etc and then there is a a couple of other entry points brute forcing and also exploiting the"
  },
  {
    "startTime": "00:34:01",
    "text": "protocols itself and one of the things I think that we often do uh or one of the places where we put a lot of focus is really the space here right we think and we spend a lot of time thinking about how an attacker could exploit the protocol from a technical perspective however I think one of the things that we've been learning over the last two years or so is that attackers are because of the really good work that people in this room and elsewhere have done attackers are actually sort of not going for the difficult problem of attacking the protocol as such um oh come on uh they're focusing here right they're focusing on the social engineering side and this is kind of you know part of that mind the gap right all our retention is going into making sure the technology and the protocols are secure and I think that's great but it's it's leaving some of these uh social engineering gaps and and some of them are you know implementation issues but it's also sometimes I think we've observed some of these as sort of unintended or unexpected right um it continues to be surprising uh that people are surprised that this is a problem and so an area or a gap that we we're we might want to focus on a little bit more so very specifically I think one of the flows that we've been looking at is the device authorization Grant or device code flow and so typically how that works is on the one end right you have an attacker who controls a device or is able to connect to the authorization server and they can initiate a session they can then get hold of a user code or a QR code or something like that and they change the context before they present it to the user and so really what they're doing here is that they're exploiting an unauthenticated Channel between two devices right the place"
  },
  {
    "startTime": "00:36:00",
    "text": "where the the session gets initiated and the place where a user is consuming it um and they're incredibly creative right it is things like click to win or um you know sign in or we're going to delete your SharePoint site or um you know any other number of things that creates anxiety a sense of urgency um and get the user to say yes there's other variations of this where it actually gets coupled with timing uh or just spamming people right just giving people uh you know you get you get notifications at two o'clock in the morning every five minutes to authenticate or authorize a transaction and eventually somebody says yes right so the sort of a user user experience issue there so of course once the user has done this they end up they they get this they you know they're going to click to win because today's the day right and they scan and they enter that code um they perform their authentication authorization and this can be strong auth right or it can be multi-factor or Fido doesn't matter because with this attack it's the attacker I don't I'm not after your credentials right it's not a traditional phishing attack I just want you to say yes because what I really want is for you to say yes that I can access your tokens your access token your refresh token and then I can leverage those sometimes to do a lateral attack to a different uh uh you know I can sort of move across or even just if I have access to your your mailbox right that's already plenty because now I can start sending mail on behalf of you I can request additional access right I think we're seeing attackers being really really clever uh and not really attacking the technical aspects of the protocol but but using this sort of soft entry point with users so really to to uh to to recap um you know start off by initiating the session some social engineering"
  },
  {
    "startTime": "00:38:00",
    "text": "technique to rephrase what's happening for the user um and you end up bypassing strong authentication multi-factor authentication um and um and you're in um you know I think one of the things that we do do and I've I'm sort of laying a challenge down to people on this one especially uh folks working on formal analysis Etc we we model the user right when we design these protocols we sort of expect Perfection from the end user they're going to make good judgments they're going to be smart about when they say yes or no do things um but the reality is uh it doesn't work right and I think some of the recent attacks where I believe you know a large company suffered uh an attack and and the attack ended up being I think against uh part of their security organization right so even people who are Security Professionals end up being caught out by these attacks and so um the reality is right I think we need to find a way and we need to accept that this is happening that there is a person a human on the other end that's going to make bad decisions visions and we should just be thinking more about how we design for that as well and so this this work is really sort of been teasing out about what could we do in that space um as well so you know just in summary um really these are attacks in the cross-device sense that we're seeing that's about exploiting this unauthenticated channel um this idea that the user is going to make good decisions right we sort of not abdicate but we give responsibility to the user and they malfunction right they they make errors they make mistakes in their decisions um I think the other thing that's come out as I started looking at this is that this is not just device authorization ground or device code flow was the first"
  },
  {
    "startTime": "00:40:00",
    "text": "place we started seeing these attacks but as we sort of dug in right there's plenty of other cross-device flows and so the question is also how do we take some of this learning and apply it and and how do we think about those other protocols and how how would that how can we apply the learnings but then also are some of these other protocols actually better replacements so so far um it's about a just over maybe uh 12 months ago that we've sort of started digging into these attacks um last December at osw we sort of brought this to the community for the first time we described the issues we were seeing and sort of tried to get a sense of other people are seeing it um in Vienna we had a similar presentation really just getting a gauge is their interest at the time there was quite a bit of interest from people and a few folks came up and said yes they want to sort of help uh explore this problem um at osw 2022 an identiverse we really spent uh in fact osw in particular was an extremely productive uh set of discussions around the problem and it really helped me and everybody else understand more around the challenges the potential mitigations and the breadth of the problem uh so I really want to thank everybody for their contributions there uh and then I think the previous IDF I gave an update and I think one of the questions was well okay so where's the write-up um and so uh actually we went off and did that so with Daniel and Philip uh we ended up creating um uh this framework so sort of thinking about our approach in terms of practical mitigations looking at Alternatives and okay what do we need to do in terms of some of the foundational underpinnings um and we ended up writing this proposal so um so what's in the draft proposal right I think to start with we we actually took"
  },
  {
    "startTime": "00:42:02",
    "text": "some time to describe some of the concepts behind the cross device flows as well as the scenarios where are they getting used there's quite a few of them we we sort of picked six um you know I think one of the things that I wanted to be thoughtful about and from providing examples we don't want to provide too many but also not too few because one of the things I've discovered working with Engineers is they often only read the examples right they read the example to figure out does this apply to them and so there's sort of a number of these in there to try and sort of give an idea of the breadth right so if somebody reads this they can see yes I have the scenario no I don't or I have something like that right so that's kind of the intent we've actually since publishing uh there's been two additional use cases that folks have brought to us after reading the documents so I think one of them's already been added in the next iterative duration and there's another one that we we need to discuss a little bit more um so so that's kind of the the T up in the document um we've also ended up sort of coming up with a list of mitigation so I think we're at what uh trying to quickly I forget now I accounted them last night I think 12 10. we've got a quite a good number of mitigations that are all described in terms of whether they're preventative uh you know do they disrupt the attack do they help you recover right because I think that was the other thing that we looked at um if we only try and prevent the attack uh it sort of ignores the fact that the user is ultimately going to make a bad decision so how can we disrupt it once it's in in flight and even when it's completed right what can we do in terms of recovery so we got these what's a 2 4 6 8 10 mitigations that's described and since publishing this I've been approached by uh by two individuals who had two additional mitigations that they recommended and so I folded those into a"
  },
  {
    "startTime": "00:44:00",
    "text": "future draft and we will be making that available as well so that's the mitigations the other piece is just looking at alternative in terms of protocols and so giving guidance so the the guidance that we're trying to give is uh you know there are alternatives out there right uh to the device authorization Grant and there are different sort of trade-offs right some of these are more susceptible than others um some of the mitigations are more relevant than others and some of them are putting some requirements on the devices involved right so if we look at the 502 web or then which in my view is one of the you know that's just one of the the best mitigations that you can have for across device flow because of how it's it's pretty it comes across pretty secure um but for that you need fairly high-spec devices that support the protocol you need Bluetooth Etc right and so that may not always be available but we sort of try and and give some recommendation based on the problem space that you're in based on the risks that you're facing uh and based on the capabilities that you have in your solution which of these would be would be applicable um then I think also just a nod to the foundational pillars I think one of the things that we're sort of um there isn't really a great uh there's been some work around how to model poor user decision making and security protocols but it hasn't really been applied in this space and um you know I think that's sort of a challenge that I that we all want to put out there is what can we do to make that actually um uh more um you know how can we have more robust uh formal analysis to know if the mitigations we're deploying is actually going to make uh make a difference um so I think that's everything I the"
  },
  {
    "startTime": "00:46:00",
    "text": "purpose of this document and I I should have said that earlier on the purpose of the document is really to provide guidance to implementers uh to system Architects even to Security Professionals so that when they're faced with a scenario they have a little bit more information and they can make better decisions about how to how to how to think about the protocols how to think about the problem space and how to think about managing their risk even though we cannot fully retire it and then the other part is uh just maybe offering Alternatives right sometimes these cross-device flows are better served by a different product protocol than the device authorization Grant or in some cases I think one of the the the the notes or feedback that we got when we when I first sent this out was you know maybe we should also call out that if you're if you're on you shouldn't do cross-device protocols on the same device right that's also not a great practice right there you should avoid those kind of things so it's kind of obvious stuff sometimes but um it's calling calling that all out um yeah and so I think the the question that I have for this group um and for for folks uh online um like what next right so we've we've we've written this document up uh we can continue to evolve it um I also want to get a sense of whether this is actually useful to people right is this a a part of the problem space that is worth paying attention to do you find that valuable um or not right and so basically getting feedback on on the work the problem space and ideas about how we progress this work going forward yeah thanks Peter anybody has any thoughts about this come on there must be some thoughts here um there you go well actually one one uh thanks Justin"
  },
  {
    "startTime": "00:48:03",
    "text": "go ahead you were about to say something no no I was well I was you know I was going to start asking the audience questions but I I'll let you answer first and then I'll ask the audience a question gotcha yeah sorry I couldn't find the button that's fine keep going uh Justin Richard I just wanted to say first off I think this is really important work um I think that this is a space in the uh security of these protocols that often gets overlooked because we just kind of say the user needs to make good decisions and if they don't we're kind of stuck um but a lot of what we deploy is about helping the user make the right decisions or removing those decisions in cases when the user shouldn't have those decisions I mean that's that's practically that's that's a lot of what we uh what we're building out um in that experience in that space do you think uh that part of this work from the BCP we might start getting close to um I hesitate to say it but standardizing the ux for uh user involved decisions this would be important for both cross device and same device uh type of situations so in a same device situation I'm being asked to you know I'm being fished to click on a link and it just goes back to my browser and then like it it still works for the attacker in some cases um I would uh the word standardized might be it's too strong I think we want a very consistent user experiences around this okay I I think about and I you know John your John Bradley can probably comment about this but I I think some of the things that's really attractive about the Web author and 502 uh you know cross device flow is it's a pretty consistent user experience right almost independent of device Etc"
  },
  {
    "startTime": "00:50:01",
    "text": "right there is a good bit of of consistency across platforms um and I I think what I would say strong guidance but also then turning that guidance into requirements right so I would also turn around to the um to people who are deploying the systems right you know turning that guidance into and I I at least have this expectation in terms of the user experience rather than trying to say well the pixels need to be rendered in a certain way in a certain color and the buttons need to be in a certain place uh maybe we I don't know if we can I didn't right I have low expectation of success going that far no I mean so that's that would be more legislating the UI as opposed to the ux that's a great point of course yeah and uh so I think we might actually be able to do some things on the experience side um there is an entire community of uh user experience research out there that we might honestly want to tap into for this because we are specifically talking about things that are um that are that are touching users which Community is that by the way uh so uh I'm thinking of uh the lab at Carnegie Mellon cups I think is the lab is the first one that comes to mind um I know Bentley's got a big um ux Department as well um that they've done a lot of a lot of work in the past I am ah whatever the internet 2 group that was doing it that like there was a whole multi-year thing about uh about uh specifically about authorization uh ux in that case I mean so that there's a lot it's in the academic space it's like you know very Ivory Tower at the moment but maybe we should start throwing some ladders against the tower and uh see if they'll help us good idea yeah I had to pay for that and you know I think there's plenty of us here who work with teams that have user experience uh"
  },
  {
    "startTime": "00:52:00",
    "text": "capability as well and I think um having a proposal that they can react to and interact with would be fantastic I would really welcome that so Justin if we can talk about how we do that but I'd love to bring that and maybe use this document to Anchor that and maybe that you know it turns into additions to this document or another document but let's start doing that that that's a really great point to have something concrete to say this is what we were thinking of yeah instead of just make it better so yeah and maybe that's a place to start right we can share that document and say this is the problem we're facing ux researchers how would you solve right yeah all right thank you awesome Joseph uh Joseph Heinen author late um I don't think I have anything terribly insightful to say but I've read this document it's a good document provided a bit of feedback um I've referred people to the document and I believe they've read it and found it helpful I've seen other people refer people to this document so I think there's interest um I would say we should probably kind of take it forward to adoption and try and get more eyes on it and more input thanks Joseph thanks Joseph George yeah I I think it's probably already been said but design patterns I think make a ton of sense in the sense of making clear what the critical factors are and I think that information into the design teams will be super helpful um you know I think they're often they might not have the understanding you know they're looking at it purely from a user experience right and to have some guidance we can give that says here's the implications of of making these kinds of choices um would be super helpful to those teams and I think they would really appreciate it thanks George awesome jump"
  },
  {
    "startTime": "00:54:00",
    "text": "um so I think this is good work a couple of observations um the thing that the web authen thing that you describe is the cross device flow currently called hybrid formerly called cable is not a thing like the others um it it really is a different beast in that what you're doing is it's analogous to you wouldn't say that plugging a security key into a Windows computer and using web often to do oauth from the Windows computer was across the vice flow and cable hybrid really is just a transport piece that replaces the USB so it may confuse people to describe it as cross device I think we have to be a little bit careful about that I I yes I take the point John maybe you can uh system Capelli actually authored that that part of the document um I think I I kind of took a step back I know as a technologist we understand that what's really happening is we we actually establish proximity uh through and um through that hybrid protocol and so then it's a transfer right to you more than just proximity though and so I'd love your feedback on the text that that Tim contributed um the reason it's in there is uh it is a way in which I can use this device with a device like a PC it is a way there are two devices involved and sometimes that's really what the what the system designer is trying to right but you're not doing the oauth glow from your so yeah so it looks the same from the user it is a better user experience but from a protocol level it's completely different I I appreciate and understand and and I think if there's a I think here's my other motivation here"
  },
  {
    "startTime": "00:56:00",
    "text": "John is one I really want to steer people towards if you have a scenario that can be met by the by Fido and with uh the web of then flow please use that rather than one of these other flows right and I think that's kind of my motivation for including it there to support cable and Microsoft has no excuse for doing weird funky cross-device things you might well you have it has lots of excuses it doesn't it doesn't necessarily they're not good ones but devices supporting Fido either through directly a USB connection or hybrid would be a better solution to this weird cross device oauth thing and and if we go back to um siba God help me when I started off doing that with the telephone companies it was cross device because it was to a call center so when phone companies distribute a app to the SIM card so that they can remotely authenticate the user over over the phone they wanted a way to oh now and and do oauth or do open ID connect to relying parties based on a push notification the regular sort of flow um they also said okay well now when people call into a call center we want to use the same mechanism but clearly you can't do oh off easily over the telephone uh in a voice call so that's kind of the origin of it it was never really intended to be used with a QR code with both legs of the of the protocol on the network but once you open the can of worms people use them for lots of things I mean yeah so a couple of so uh I couldn't possibly comment on Xbox"
  },
  {
    "startTime": "00:58:00",
    "text": "um and your other point that you're making I think these protocols get designed and we have very specific use cases in mind for them and but once you open Pandora's box right I've been reflecting on this a lot right it is um it's like telling people not to covet their neighbor right it's like invariably something happens and people make a choice that they you know they they shouldn't have used the protocol in that way right sort of almost like you're dealing with human nature in that way um but yeah and again I'd appreciate any feedback on how how we I do want to use this opportunity with this work to advance the good work that's happening in fighter and we're both in I appreciate that it is not a traditional cross device like Siva or device authorization Grant but there is sort of a commonality in that experience that that might be a hook for people to to transition to something more secure that's the intent right we just have to figure out a way of describing it so that they understand that it's quality I I would love that feedback uh so jump before we leave so do you still think that this is a useful work that we should continue yes I think it's a useful word but there are some subtleties in how we explain this okay so so we people ought not to think ah yes because hybrid or because cable hybrid is secure that that immediately can be transitioned over to that's a different doing web authen over that kind of Transport is a different thing than trying to do Multi-Device oauth okay and and and again please if you have suggestions about how we do that if it is if the right answer is we shouldn't have that in the document that's fine too but I I do want to make this opportunity to at least leave it with the implementers that there are better options that they could use being in there but"
  },
  {
    "startTime": "01:00:01",
    "text": "separating that from Multi-Device oauth say you can you do in the case where you're using Multi-Device oauth why don't you do just to oauth with the normal redirect flows but do Multi-Device through the authenticator that's so okay so yeah I think you just said about my intent is if that I'm not expressing that help me okay thank you yeah exactly so thanks John I appreciate that Aaron I'll just be really quick since we're like out of time um I just want to say I also think this is important work this is great a good start on the document and I also agree that the user experience side of it is uh worth pursuing and um documenting I think that's something that is been very much missing from a lot of the work that we've published and interestingly it has come out mostly the same when people do implement it both the device flow and just traditional oauth consent screens if you look at what's out there there are a lot of commonalities and that tends to be a good opportunity to actually document them as a standard so I don't know exactly what the right way to do that is but I don't know if it's a standard it's a PCP but it's a it is a a BCP is a standard it's a it's a type of standard I don't know but I do think there's something there too because it is also a question that is very commonly asked of someone who's starting to build these is what do I put on the screen how should it work and then it's kind of they kind of just have to figure it out or go read someone's book so thanks Sam and Aaron would you be open to sort of adopting this you should we be adopting this as formal work in the working group yeah yeah Christina hi Christina I'm just plus one great work I'm going to react to what you said Peter when you said don't use cross-device protocols and same device flows turns out it's not as simple as that"
  },
  {
    "startTime": "01:02:02",
    "text": "it's just only thing I wanted to quickly say and maybe the comment is not exactly relevant if the protocols you're picking up in the document are you know can only be usable with cross device flows but the protocols I'm working on for example the cross device mechanism can also be applied in a same device environment and we are observing people doing that like for example as a request encoded in the QR code is also in a deep link so user has an option to actually click it on the same device for example right so I don't know exactly how relevant it is and I've read the document I haven't seen anything around that so probably adding a text or clarifications or having a discussion is would be useful because for again like initially in at least in our protocols the guidance was absolutely not used cross device for the same device people are doing it and people are doing it also for some legitimate reasons some deployment models do not allowed to have token endpoint whatnot some you know like divide the response is too big and like you know they want to benefit from cross-device HTTP post requests what not so yeah just bring it up all right now thanks for that Christina I think that comment was actually added Joseph based on feedback that you gave and so it's in the next draft I'll actually if you want to review that but I want to know about those use cases and you're right right we can say don't do it people it's not going to prevent them so we need to have mitigations or we need to give people options or at least highlight the risks thank you thank you foreign are you aware of any like there are specific Solutions in the western so are you aware of any uh iprs on those because uh a check that document it didn't say anything but that would be important to file if you are uh it's like these are the types of documents I would normally have assumed everything uh could be impacted I'm not aware of"
  },
  {
    "startTime": "01:04:03",
    "text": "any IPR uh harness um and and I yeah I'm not aware of any IPR okay awesome so I as chairs we think um we see lots of interest and support for this work I didn't see anybody objecting to for the work group to do that so what we think we're gonna call for adoption on the mailing list okay thanks uh reporting should I just do an update of the doc before you do that yeah that'll be great yeah okay I'll do an update and then we do that awesome thank you thank you Peter Christina is this the right document this is the right document okay um do you want me to pass the control to you foreign first um see if that works oh wow yeah it works this is great all right hi everyone um so the point of the presentation is to draw the working group's attention on how the client ID is being used and what can we you know note some emerging data points of emerging patterns and hopefully to start a conversation um what can we do about it so"
  },
  {
    "startTime": "01:06:00",
    "text": "if you look at section 2.2 in RC 6749 it clearly says authorization server it is authorization server who issues the client ID and also if you go back to section two it says the client has to register with authorization server before initiating the protocol so they're clearly two requirements that we have that are probably not always exactly followed in some of the deployments we are seeing so just a couple of limitations use cases I'm familiar of and I've heard from the rooms that they're actually other use cases that are not exactly follow these two requirements so one is open ID for fiber credential issues protocol we've been working on and I should say um I'm here presenting it but this is kind of a result of a long discussions with Torsten and Tobias who are not in the room but yeah against a huge kudos to both of them to contributing um so in the protocol it is based on OS 2.0 if it has open ID in the title we just keep calling it up in id4 because we're talking about you know user claims but it is OS based essentially we defined a new resource server just for those in the room who are not familiar with the protocol um so this is a use case where the large number of ruling parties they close on wallets a large number of these credential issuers who have built this additional resource server that want to interact with each other and we've received a lot of feedback that it's unrealistic and also impractical for the easterling party slash wallets to sample and register with every single credential issuer and manage client IDs for each of those issuers so and that's kind of one extreme is this completely open ecosystem where you know people want to allow anyone to talk to any credential issue but of course people would say how about high Assurance use cases right that's where"
  },
  {
    "startTime": "01:08:02",
    "text": "it's kind of close to the second point with open Banking and education Federation and whatnot where it's a relatively closed ecosystem meaning there is some kind of third party managing you know the requirements either it's a trust list or you know like you have to have the certification but in the end of the day the point that there's a group of relying parties who are wanting to interact with another group of authorization servers is the same and again the same feedback coming in like we don't want to manage client ID for each issuer separately from each authorization server in this case so this is partially what we started calling Anonymous clients maybe not the best term but you know that's what we mean um when the client the rank party is coming in previously on known toasterization server so it's it's bringing in the client ID which authorization service has not issued itself and maybe it's not pre-issued per section two um so yeah I think I covered both kinds completely open ecosystem a bit you know more close ecosystem but still two groups of um parties interacting so the two questions I really want to you know challenge people to think about is who should be determining the client ID and who should be managing the client metadata and we'll come back to it and just to give you know Fit For Thought I want to give some data points or I want to call it prior art because kind of current art so one thing is what I took a liberty to call client ID as a URI or bring your own client ID model in existing open ID Federation um um spec so essentially a trusting device and I think that this mechanism defined in openly Federation is much more powerful than the authors themselves have intended or wanted to be and it's"
  },
  {
    "startTime": "01:10:03",
    "text": "interesting because first the specification absolutely breaks section two and section 2.2 of RC 47 6749 and this is where a third party so there's no pre-registration as per section two so the client does not have to pre-register and it is a client who is determining its own client ID it's literally the client saying here's my client ID it's a URI a panda dot well known slash openly Federation config you find a Json file use it as a client metadata or you can go up the trust chain if it's you know the closed environment I talked about verify the trust chain and make sure you can trust the metadata ceramics summarizing at 100 pages in one sec one sentence so purchase for that but um so that's what it does right and I just put example of that you know like example of client metadata managed by the client and the same model actually have been pretty independently um developed in this therapy too and openly for VP so again open it for VP is OS 2.0 based um we still call it open ID because again it's about client identifier and it's really close to the issuance um extension so this is where we actually allowed three different options to counters the limitations we faced so honest with that it's okay for client ID to Eco redirect URI if you don't know what client they need to use but not many people it's the simplest but not many people do it because of you know where do you get the metadata from and the answer to that question is we Define the new parameter called client metadata where you can so in openly Federation example the client metadata was hosted somewhere externally um but it also enabled an option to actually pass the actual client metadata"
  },
  {
    "startTime": "01:12:02",
    "text": "long as that request is signed or you have some additional mechanisms to trust that request or Origins coming from it's okay to take out the metadata from the actual authorization request right so those are the three options we have right now and I think Tobias sent a note to an email but there is a draft on individual draft on to kind of bringing that client metadata idea into the OS working group um but we I'm kind of running ahead of myself but I think if we can find a mechanism to combine this client metadata in those authorization request idea with a powerful mechanism up in the refrigeration spec is giving us we're actually creating something really powerful um but obviously I just just to comment on the asterisk obviously we are enabling pre-registration to just you know so people are not having heart attacks um so and recently what happened was so I'm going back to the credential issuance draft so that's where we actually have to find a new Grant type where which is really similar to job Fairground type but there's no civilization endpoint and you can take you know the token directly to the Token endpoint um and that's where I talked to Brian Campbell so we're not doing something completely crazy we said it's okay not to um pass client ID in the token request so the client is pretty much Anonymous so obviously it was the association server wants to identify the client it can return an error say hey up so they need to bring the client ID but spec wise we're saying the client can be completely Anonymous um you don't have to send the client ID to the Token request if you're not even doing authorization request right and I can't put it on the slide but my actual motivation to bringing it up because there's some really interesting"
  },
  {
    "startTime": "01:14:00",
    "text": "but might be dangerous workarounds happening and what I mean is um all those data points I've given are great but the limitation is that existing authorization service existing ones right probably can't do it because they've implemented RFC 6749 they have to spit out their own client ID and they right now do not allow bring your own client ID model and hopefully in the future as I will but that's a status quo and before we go to Future State what this authorization service are starting to do because they have to spit out the client ID so they do and they publish it somewhere or communicate out of band and they're telling the clients who want to support that specific flow or whatever just use a client ID so authorization servers are encouraging the clients to impersonate each other or what's happening it's a pretty bad way to put it but that's what's happening because there is this limitations that I described this relation servers are have to spit out the client they right now what they do they spit out and allow multiple vendors to use it so that's my actual you know motivation to bring it here because you know I'm a bit you know I understand why it's happening but I'm a bit scared that it's happening so right so kind of going back to two questions I posted in the beginning you might disagree or maybe am I missing something but probably four ways the main reasons why client ID is actually needed why I was in you know 47 67 49 I don't know I keep saying 47 today um so time client ID to the list of allowed redirect Uris to prevent open redirects so you know knowing which client metadata to use knowing what metadata displayed how to customize user experience if it's in a per client and as can also apply specific specific permissions I guess based on you know identifying which client you're talking to um so next steps"
  },
  {
    "startTime": "01:16:02",
    "text": "um again just a suggestion I want to you know hear people's thoughts um can be you know I as I already I guess you know went ahead of myself I really want the working group to kind of you know encourage working on this you know mechanism where we can combine this client metadata idea which is this individual draft device submit it and maybe mechanism of any Federation um and that was actually important point we wanted to highlight is OAS 2.1 actually already relaxes the requirements um I pointed out in the beginning of this presentation was typing already relaxes that as has to be the one spitting out but I think that has happened without you know a big working group um discussion I think tourism acknowledged that um it was kind of you know the editor's um decision so again the bringing up this walking group is actually aware and you know that is being a conscious decision by the working group that we are relaxing that um well hopefully five people should I be scared or happy yeah go ahead Darren uh yeah I got a lot of notes here okay uh let me start with the oau 2.1 thing since that was the last thing you mentioned um yeah you I you are correct that the language got already changed in 2.1 and it says you may also serve clients whose client identifier was issued by a trusted third party that's the new text and I actually uh now have been caught this through a little more I think we should go one step further and remove the word trusted from that since it could be issued by other parties for various reasons that are all legitimate in different scenarios um so I think we should I think we should go even go even farther with that um which also brings up an interesting"
  },
  {
    "startTime": "01:18:01",
    "text": "point that the security BCP also says that clients should not influence their own client ID and that's for a particular reason that has nothing to do with this but that was for the case where a resource server might be confusing this subclaim uh for a client authentication issued token versus a delegated token um so that's an interesting sort of wrench to throw in there because I think that is still about concern but I think the recommendation that clients shouldn't influence their own client ID is not the right recommendation based on what we're seeing now um okay the other I also wanted it back to the beginning of your presentation the um another example use case of a scenario that uh leverages this is the whole world of completely open web where there is um no trust chain available or desired and that would be things like random random person spins up their own WordPress website it's open source software they install it themselves the developer of Wordpress has no idea that it's happened obviously another random developer makes an iPhone app that they publish in the store to edit your WordPress site obviously the developer of the iPhone app has no prior knowledge of every place WordPress is installed nor is that desirable and vice versa so in that case you actually want the WordPress iPhone app to be able to present itself to an individual's own WordPress website and say please I need a token I need to log in and I think this is again it's the same scenario where you want information about the client you want some level of redirect URI registration somehow uh but you can't even do the trust chain thing because there is no trusted root in that ecosystem so uh and along those lines there is"
  },
  {
    "startTime": "01:20:00",
    "text": "also a community that I am involved in that has been doing exactly that since about 2014. so it's not even new so it's like eight years of client IDs as URLs and it has been working and it's actually kind of widely deployed there's a lot of systems that use it so can you say more about this yeah the uh the spec was um published as a w3c note in 2018 it's called indiath and it is essentially a way of using oauth in that sort of open web ecosystem I have a blog post that talks about it as well kind of in terms of looking at it from the oauth side um I can link that into the jabber chat or whatever um but it's it's decently widely implemented and it does exactly that client IDs are URLs client metadata is found from that URL it also happens that the user IDs are URLs too but that's a different discussion so I think there's a lot of precedent for that can you post that to you the meeting minutes I'll put uh are you taking notes in the ITF tool yeah I'll put links in there um cool that's all right thank you so much yeah Brian would you go back just one slide yep I think I lost control so if you don't well it it's maybe not important actually I I regained it well just for context I think it was what is what is client ID used for needed for I think one one piece that was missing from that list is it's often used for part of the record of the of the granted authorization at the authorization server that's how it keeps track of you know what an individual user granted certain access to a particular client and so right um but it's it's a"
  },
  {
    "startTime": "01:22:01",
    "text": "consideration I think needs to be considered what's life yeah why is client ID needed yeah um that that that's sort of client ID associated with the the record of the authorization what's often called the underlying Grant or the authorization Grant is something that that I think pretty much every real authorization server does so should be included in this so it's not not missed okay I see someone disagreeing but I I think I think I think I think yeah thanks Brian I think the point of the slide and sorry I couldn't didn't talk through is yeah if we can identify why client ID is needed and kind of use the list to analyze you know to say that even if they allow this client ID as a URI or bring your own client ID model you can still use cliently for these reasons so it's okay like that was kind of why I actually wanted this checklist to be here because if we can check all that like why not right um so yeah thanks like I think yeah no this list definitely has to be revised yeah Daryl Miller um forgive apologies to the rest of the room as one team at Microsoft talks to another team that Microsoft uh I think this would be absolutely wonderful we have so many issues in developer experience around that initial app registration um and this would allow us to significantly simplify onboarding of people using apis it also has an interesting effect we get we have a lot of concerns around garbage collection around app IDs that have been created and then never deleted and around the consent issue um maybe it's not such a bad thing if an app ID that hasn't been used in three months that has a consent assigned to it goes away and the user has to reconsend afterwards but it is something that we should include and discuss but yeah I'm I'm very supportive of heading in this"
  },
  {
    "startTime": "01:24:01",
    "text": "direction I'm so happy to hear that could you explain um for the minister like what is the when you say consent issue what what do you mean by that I I think the word user was Grant so we store uh when somebody attempts to go get a token to be able to access a certain piece of data uh there are scopes that are in the scope claims in the token that the user says yes I would like this app to be able to access my email yes I would like this app to be able to access my contacts and so we have to store that information along with what we call service principle but it's It's associated to the app ID indirectly so client ID sorry Microsoft General thank you this is great just a second okay okay Justin hi Justin Richards so uh a lot of what's on this slide is actually I would pause it not about client ID but about the underlying client registration record as known per the I per the As and that is what is being referenced by the client ID that actually further goes to what uh Brian was just saying and why I was shaking my head about it is that you don't need a client ID in order to tie to auto records you need to link to some database row number somewhere and that is not a value that needs to be exposed externally to the protocol generally speaking however in the uh oauth world uh the entire oauth protocol is basically you start with the authorization code flow right everything else is just kind of bolted on in strange angles from there and in the authorization code flow as it was classically defined you had to start with a redirect as you were do going through the fun Channel when you're going through the fun Channel you cannot make an authenticated call to the authorization endpoint but least he couldn't at the time I know there's like you can do it sideways with sign jots and things like that these days but we needed a way to identify what client we were talking about without authenticating the client software"
  },
  {
    "startTime": "01:26:01",
    "text": "itself so that's where the client ID really came into play we ended up looming on the client ID so hard that we had to invent a whole other set of specifications to get a client ID when you didn't have one that's the dynamic registration side of things right and as you've pointed out very very uh rightfully here there's a whole bunch of use cases where you start collecting all of these client IDs that maybe you'll never see them again because are you going to really dynamically register every time your spa reloads or you drop the cookie jar I know people have tried to do that back in the day because that was the only way they could get around things it makes absolutely no sense there are other ways that we should be able to bootstrap this trust environment into the registration record ephemeral or otherwise at the As and client ID is not the way that we should have done it all of that said that is the mechanism that oauth 2 has because everything else assumes the client ID will be there and if it's not there a lot of stuff actually breaks so yeah I think that a lot of this is interesting I will also add though that if you add pushed authorization requests into the mix of possible things a lot of those ones go away too because you now can uh start talking about an external identifier to that ongoing request that is not necessarily tied to a specific client external client identifier um within the scope of the protocol itself you are simply saying I am doing the next bit of this part of the protocol here so if you're doing par if you are doing you know um you know key based authentication and stuff like that you don't actually technically need client ID at all in oauth except that oauth requires it that's not a requirement we're going to get away from in uh in oauth 2 anytime soon I think that the new language in 2.1 is a good step in that direction um but anyway this is a very long way to say this is I think good and interesting work I do think however we need to"
  },
  {
    "startTime": "01:28:00",
    "text": "really think about this in terms of the client record as opposed to or the client registration or the client something as opposed to the client ID because we're using client ID as the stand-in for all of those different things can I quickly react yeah yeah so great points um just to react so that's why the question I had both client they didn't client metadata universe but just declarified the reason why I didn't put the term registration per set is because I don't think when the client is bringing in its own metadata it's actually registration it's more of it it just it didn't feel like the right terminology like so yeah the only thing so maybe if you can find if it's a record or what not a good term like I would be happy um yeah so yeah I I just to respond I I would agree with that actually registration is sort of very narrowly defined in the oauth world to mean this I give you a bunch of metadata you give me a client ID that's that's the transaction um so yeah I agree it's that's not what's happening here okay and on part that's exactly true um but the there is a deployment models where you can't do part so like if we can yeah like account for that but also so parse gray but there are some cases when it can be used about the video in those cases is if you can discuss that would be great we have one minute so I want to give people a chance to talk to Tobias great Tobias I can't see you sorry can you are you able to hear me yes we can hear you so yeah I just wanted to um throw um some strong support and for for this work um obviously have have done some work my um South in this area that was published in mailing list um yesterday um on client Discovery I think um"
  },
  {
    "startTime": "01:30:00",
    "text": "much of the language um around original old term what we have seen in deployment subsequently kind of reflect that you know the traditional pre-registered model and assignment of client IDs by their um as is limiting and the ability for the client um to effectively have a an identifier that I would posit in reference to the oauth 2.1 language that might not even be assigned by a third party but might in fact be self-attisted so I would even consider going further in the context of something like oh to a point one and and considering not just third-party assignment but also self-assignment like if if a client can do such a thing um and uh I also agree that I don't think when a client is having a client ID where the metadata can be discoverable itself is in fact best described as registration it's really an attempt for the client to say this is me this is how you can get my metadata and you can enforce whatever policy you would like to on top of that um whether that be you know limiting me based on the policy you have as an as or proceeding with the transaction based on what you know me as the client um so I I would um would like to get further feedback on at least the draft that we have um started today which is all with client discovery that um was published to the list that uh is conceptually similar to things like open ID Federation and all it really does Define is um a URI a additional request parameter and oauth 2 to signal that that client ID is not an as assigned one that should link to a client record uh how to get that metadata document um and some basic validation rules there because I also believe with common there"
  },
  {
    "startTime": "01:32:00",
    "text": "Aaron made which is um the lowest level here shouldn't be focused on third-party attestations about the client should be probably just about how the client has a metadata document how it can be resolved how those kind of rules working all too then further client authentication requirements will trust signals and establishing who the client is can be layered in on top of that mechanism thank you thanks Tobias John Let's wrap it up okay I'll be short um so Christina you're you're lobbying has been noted by the open ID Federation editors um I I will point out that um I think there may be a misperception that open ID Federation requires some monolithic Global routes there's nothing that stops uh a a client from being its own route I mean that's a policy decision so you could have an infinite number of roots and everybody could just be their own route if that was the kind of federation you wanted so nothing actually stops you from doing that right but that's when I would Lobby to rename this back because Federation consisting of one entity is not intuitively Federation nothing says I mean yes I know you don't like the name but many people understand what federation is and trying to convince universities and governments that that it's called something else that's probably not a discussion for here but um there doesn't need there could be an infinite number of routes supported by Federation okay thank you John and we passed the time thank you Christina appreciate that the great discussion let's continue that discussion on the mailing list thank you all and see you tomorrow on the side"
  },
  {
    "startTime": "01:34:00",
    "text": "meeting thanks two and have a look at the meeting minutes some of you spoke so fast that it's really difficult to to capture everything yes uh Justin you are one of them oh yeah thank you"
  }
]
