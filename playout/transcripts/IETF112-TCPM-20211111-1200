[
  {
    "startTime": "00:00:24",
    "text": "so we start us we wait a minute or so i guess you can start okay then let's start um this is tcpm tcp maintenance um my name is michael dixon i'm one of three coaches the other ones are yoshi and michael um and this is the note well you should have seen it if you attended another meeting so please read it and do what it says um we already have a note taker thanks to gary who um volunteered again um and michael is a java scribe so um if you want anything reflected at the mic i'll put in a prefix mic and i think yoshi will do the job in case michael is presenting if you are submitting a draft to the ietf and you want that the tcpm working group is aware of it um put tcpm in the name of the id that makes it much easier for us to find it and to be aware of it this is the agenda"
  },
  {
    "startTime": "00:02:02",
    "text": "a working up status then we have a couple of presentations for working good documents one is on proportional rate reduction which is uh from yuchang which is proxy or who's proxy by me today um cubic an update an update on yang two presentations on tcp ao um one about the draft and one about an interrupt test and uh finally on the working group documents on tcp edo and eos um where we have a slide from joe and um we are also proxying it after that we have um two three more presentations um two about upcoming biz documents and one about an implementation [Music] um feature provided the talk is provided by neil anyone wants to bash the agenda if that's not the case then um this is the are the status of the documents we have um rfc is 793 bis and um that is uh after isj last call um a revised id is needed and wes is i think there and can give us an update yes uh the isg did a really good job reviewing it and there are a lot of comments i've worked through some of them but i've looked at all of them i've actually"
  },
  {
    "startTime": "00:04:00",
    "text": "made edits for a good number of them but there are a few that i had put off because they involved more research or homework a good example is there was a question about how we treat uh source route options and uh whether what this document says is is uh totally consistent with what other rfc is not about tcp but about ip options say and so uh i wanted to make sure that we did the right thing there and also do something consistent with what uh real stacks do so i've been sort of dragging my feet and taking more time to get around to doing the right thing and looking up a lot more information on that one and there are a couple of other issues like that but for the most part uh the isg comments are pretty clear and uh i think it just needs my attention to get through them okay do you have a rough timeline uh no so uh i would i would uh hope to get around to it uh really soon like within the next week or two but uh i've hoped that for a few weeks already okay so uh but in case you need help um from others um reach out to the mailing list i was going to do that on some of these questions uh i think that will be much quicker and lead to better results so i will do that okay any questions regarding 793 abyss if that's not the case we can go through the list of documents"
  },
  {
    "startTime": "00:06:00",
    "text": "um they are in the order of the milestones which are um often in tcpm not taken that precisely so we have prr um i have a status update on that in the first presentation um we have eight three twelve bis um uh where we where we have also a presentation um said that he wants to do so he has implemented what is in the current document and um microsoft is wants to do some more measurements and um present that the next ietf and based on the outcome of the measurements the document should be in a in a pretty good shape or not but that depends on the um on the outcome of the measurements so that's why we um don't see any new information or and we don't see a presentation here accurate ecn and generalized ecm um are both in the same state as last time because the frs work going on in tsv is not finished yet we have a presentation on the tcp yang document in this meeting we have actually two presentations regarding the tcpao regarding tcpao one is about the document describing tests and one is about an interrupt test and finally we have a slide from joe regarding tcp edo"
  },
  {
    "startTime": "00:08:04",
    "text": "any questions regarding the documents if that's not the case um any additional statement from any of the coaches here this is michael speaking can you hear me this may be a good opportunity for a personal announcement that this meeting is most likely my last meeting at the chair desk so i've decided to offer to step down to open room for um the next generation of tcp researchers so that they can get management experience the transit that transition will not immediately take place because uh since i still want to wrap up some work uh the most important one is the top one on this list here but once 793 bis has passed isg evaluation um and maybe some other things are done then i'll step down and as i said i'll open room for somebody else to gain management experience i will stay still stay around so i will just go to quinoa to work in tcpm but not on the chair desk so this might also be an opportunity for best to speed up to work on seven i3 this because this is actually a showstopper so thanks yeah thank you and thank you for all the work you did for tcpm and um i hope we um will still um have you in the working group as a contributor and reviewer and"
  },
  {
    "startTime": "00:10:00",
    "text": "a person that can share his knowledgeable tcp thank you okay um [Music] the first presentation should be um let me see so this is uh um regarding um propulsion rate reduction um the draft is i think um not active anymore we contacted the the authors and basically they are um pretty busy with other things but they um they stated that they will um provide a new version on in the time scale of the next ietf and this is the list of changes they currently have in mind which need to be addressed before the next version which is two bug fixes and [Music] some clarifications especially on interactions between prr and reg because at the point of time where prr was written rec didn't exist so there are some some adoptions also based on newer developments on the documents um uh are there any comments are there any additional things the author should"
  },
  {
    "startTime": "00:12:00",
    "text": "address so um they said they will read the notes and any feedback will be addressed yoshi ah hello i just curious about implementation status of this one it is already main running in the corner why not because now i see you know the beast version is slightly different from original version so there are some logic updates so i just would like to know the status of this implementation i'm not sure if any of the um draft authors are on the uh call but um i'm in close communication with them and the um i believe the this is going to basically um reflect the latest linux tcp uh prr there have been a number of um minor changes and fixes uh i guess changes really not fixes over the years and we wanted to update the documents or reflect the experience in the linux tcp stack so it will cover logic that's implemented in linux tcp richard so i just wanted to add on this that i've provided some of the feedback based on my experience of prr in the freebsd stack so this has not yet been fully committed especially the one that is running without a selective acknowledgement but it happens where or will be addressed in an upcoming revision hopefully"
  },
  {
    "startTime": "00:14:06",
    "text": "but uh you provided the comments to the authors already that is correct yes okay so the authors are aware of it any other comments okay if that's not the case then i would say um the next focus is cubic and um videos up um you can run the slides on your own they have been uploaded yeah am i am i audible yes you are audible thank you um so i actually forgot how to do the slice thing on the on the below your name you have uh to to next to your next to the hand icon there is a document icon and if you click on that yep you should see a list of documents and you can select your so do you see the slides or not yet i think you have to select it and then i selected it but it just opens on another tab well done so yeah i just i am not sure how to share this with you guys okay and then i can do that it's okay if it's okay if you want to um take over i i will let you know yeah thank you very much i'm sorry i couldn't no problem okay uh thank you um hi everyone"
  },
  {
    "startTime": "00:16:02",
    "text": "uh so you know in in the past year we have been making some updates to cubic and we are trying to adapt it to the recent based on the recent deployment experience in in tcp and quick stacks and a lot of folks have contributed to this effort and we're really grateful for that um next slide please so um i think around two months ago when you know the chairs were concluding the work group last call we received a final final review from marco and this was quite an extensive review and i'm really glad that it raised some profound issues that we probably missed so big thanks to marco and everyone who has helped with you know writing peers or providing solution solutions and all the discussion that is happening on github so i can cover these issues briefly just that everyone's aware was changing in cubic base the first one is because cubic is more aggressive than reno so we have um mentioned that in the changes we have added that cubic uh basically updates rfc 5681 and this is because of this the the beta factor which is 0.7 instead of 0.5 uh next point is about um when we have a slow start overshoot cubic only reduces condition window to 70 percent instead of 50 in case of reno and this means that cubic's window is 40 higher than reno so this could cause high packet loss during recovery but could"
  },
  {
    "startTime": "00:18:02",
    "text": "take multiple rounds and so we have recommended uh the implementations or implementers to implement high start plus plus with their cubic implementations and and that's the experience that we have from the deployment as most of the implementations are ready to that and um as i was saying it could take a bit more than one you know recovery cycle to compensate for the two times overshoot in the slow start we are advising the implementers to you know evaluate their choice of the first multiplicative decrease after you know whether they receive a packet loss or they receive an ec yak so this is something they should be evaluating and we have mentioned that specifically in the draft um the next bullet is about using prr to reduce the sending rate slowly um you know during loss recovery and uh as marco pointed out the the draft uh you know when he reviewed it it incorrectly mentioned um employing a fast recovery for all congestion events so this should only be done for packet loss and not for easy and related condition events and now we have updated that um last point on the slide similar to reno the performance of cubic you know as a loss-based congestion control it does suffer in wireless networks because the packet loss is not necessarily you know giving us a good signaling of the bottleneck capacity so we have added some text around that um next slide please um so these are also some important design changes so cubic has um [Music]"
  },
  {
    "startTime": "00:20:00",
    "text": "you know lower window reduction and it also reaches w max faster than reno so it really it effectively means that it has a shallower salty than reno and uh we have added some guidance regarding you know buffer bloat and queue management where the new aqms the new implementations of eqm's probably could mitigate some buffer blood by for example setting lower thresholds for the queue size um next point is uh very important and it is about how the draft uh the sorry how the base strap originally had a lower limit of 2 for congestion window and there is a crucial distinction between a congestion event due to a packet loss versus due to ec ack i mean we do need a window of two packets in case of packet loss to perform loss recovery but for ece markings we need to keep reducing even beyond a congestion window of one by using a retransmit timer type backs off exponentially so i think this is some something that implementations need to be doing i don't think linux does this or um other implementations take care of this behavior this is clearly mentioned in the roc 3168 and i think we should implement this um so another important point that has been discussed in in detail on github is better to use flight size or congestion window in the reduction equation um the rfc series you know the standards rfcs they all have they all use flight size and not save"
  },
  {
    "startTime": "00:22:01",
    "text": "wind but there could be an issue of there could be an issue that the flight size sometimes is very low especially for the rate limited apps when the loss occurs so uh the best way to mitigate this issue uh is to implement rxc7661 so we have recommended that and and some implementations you know for example the next currently used event we have left that as an option as well next slide please these are some of the editorial changes um there was a bug in the average cubic window equation that neil had found uh thanks neil so we have fixed that the next point is about rearranging the algorithms for spurious events detection um we now recommend the standard star track forward rto recovery rfc first and then we provide some examples or references for experimental rfcs um then we have added cubic's response to certain events like sudden increase or decrease in capacity and cubic is more aggressive than reno in both the cases last three are some simple editorial changes [Music] next slide please uh this one is kind of a duplicate of the next one so we can skip to the next one thank you so this is an open issue that um i would and we would like some feedback from the working group we have some feedback already on the github issue but if you have not had a chance to look um i can describe this issue so marco has raised"
  },
  {
    "startTime": "00:24:01",
    "text": "some objections about the spurious detection and the conditions response to those events and to provide some context so there are two types of spurious events um at least for tcp uh there's rtos which is for applicable for tcp and there are spurious retransmits detected by acknowledgments and that's applicable for both tcp and quick so the first issue is that cubic is modifying a standards track rfc 4015 which um you know defines our response to spurious rtos um the rfc port event 4015 it sets the condition window to you know flight size plus minimum of bisect plus initial window and this but in cubic we are recommending to restore the condition window to its previous state before the reduction was applied so this is the issue um i will come back to the solution in the next slide second uh issue is cubic is currently specifying a response to both types of spurious events and uh marco said in smoke in certain networks for example in mobile networks a path change could increase reordering and thus it can result in spurious fast retransmit and at the same time the bottleneck capacity might get reduced so if that happens then um you know restoring to the previous condition window might not be such a good idea and that's why he said there is no previous rfc that talks about restoring state due to spurious fast retransmit events the third one is currently we don't exclude the cases when the ack detecting spurs event has ece set on it so this is"
  },
  {
    "startTime": "00:26:01",
    "text": "a simple one i think we can fix this one and the last one is we don't specify or cubic doesn't specify any mechanism to adjust rtos acknowledgement thresholds you know time thresholds etc to avoid any future spurious events next slide please so um as i was saying the first point about violating the standards track rc is a bit tricky as um the response defined in rfc 4015 is uh is a bit conservative uh because the condition window is set to uh not to the previous value but to flight size plus a minimum of bite sac plus initial window most likely it will end up to be flight size plus initial window um in my opinion so this is too low um and i think some pro folks won't be happy with it so if you have an opinion about this and how do we proceed or deal with this problem um we really like to hear back from you second one uh spurious factory transmits so these are much more common for tcp and these are the only events more quick so i think um if there is no previous rfc that provides any guidance um perhaps we can record cubic's response to these events um and again this is the another topic that um you know any input would be very any any input on this would be appreciated um the third one we can fix uh in the draft that's not that's an easy fix and for the last point um i think a lot of us agreed that we would need a separate draft to cover this as we want to keep the loss recovery changes separate from the congestion control um"
  },
  {
    "startTime": "00:28:00",
    "text": "next slide please so we will continue to fix any open issues these are um you know as next steps and once uh whatever issues are open right now are resolved we will again request the chairs to conclude the work group last call so if you haven't read the draft please read it if you plan to read it um we would like to take care of the issues as soon as possible thank you thank you for the presentation and update comments questions hi vinnie good job presenting i just had a very quick comment about something you said verbally i don't think it was actually on the slides um you talked about the problems with wireless networks losing packets i think actually the big problem is not packet loss because wi-fi link player acknowledgement and retransmission is pretty good the bigger problem is the huge variability because wi-fi can vary from a gigabit or more to a megabit per second and that happens if you just walk around the house with your phone or if someone else walks around and gets between your computer and the access point so i think the bigger problem uh and i don't know whether the draft talks about this uh but since you mentioned it i just wanted to bring it up the bigger problem is that if your wi-fi rate instantly drops from 500 megabits to 50 megabits when cubic is only reducing 30 percent each time it takes multiple round trips to bring c winds down by a factor of 10"
  },
  {
    "startTime": "00:30:00",
    "text": "and of course during that time it's sending too fast the queue is building up so the round trip time is going up so the time for the round trip time is going up so it is true you see lots of loss on wireless but it's not random packet loss it is q overflow because the center is sending 10 times faster than the link can now carry right so it's more like a transient congestion loss yep thank you yeah thank you praveen so i have a question um so as we make these changes right some of these changes are coming in from review feedback i'm wondering if the some combination of all the uh diffs from the previous rfc would be representative of a implementation that has implemented all of these changes or would it be sort of a mix and match so my worry is that as we make these changes we might not have had implementation experience of the entire uh new rfc so that that's just one concern i had so any comments on that it's a great point and um the changes that have been made you know before this review were mainly to reflect what the implementations are doing today with this new review um it it's it's a it's being a little more careful i would say a little bit conservative in the sense um and we but we have left the options open uh with respect to the um things that implementations are doing today so it's not like we are completely closed those gates for example you know using sieven instead of light size that's one of sorry using flight size instead of seaweed that's one of the things but we have still um left options for implementations which is"
  },
  {
    "startTime": "00:32:00",
    "text": "like using rfc 7661 and if you're not using that some implementations are still using cvent and not flight size so it's not like we have completely changed what implementations are doing the only change that i can remember which implementations are not doing is the ecn change and i think that's a good change because ecnc markings are representative of congestion directly and we should keep backing off so so yeah so i would say um we're not too going too far away or too too way off from what implementations are doing so it should be okay a quick follow-up so so this is no longer representative of the say the linux pcp implementation as such right it's more of a representation of all the different implementations is that is that the current stance sure yeah we can say that okay thank you i just had a couple quick comments oh one um i wanted to encourage uh the draft authors to to keep the discussion of the undo logic in the draft i know there was some discussion about whether to keep it or not but i wanted to emphasize that undoing loss recovery events is really important for performance in practice in the real world and the cubic algorithm has enough state variables that it's non-trivial to know exactly what variables are need to be reverted or to be at least reminded that there are many different state variables and not just see when then access thresh uh to undo so i think that's important to keep in um there was also in some of the github threads some question of whether it's okay to to undo lost recovery if there's been reordering due to a path change and um i tried to"
  },
  {
    "startTime": "00:34:00",
    "text": "respond in the thread but wanted to emphasize again that um i i would argue strongly that it's okay to go ahead and undo um if you detect that there was reordering um and this various retransmit because if there was actual packet loss in that round then the loss detection machinery will detect that there was also loss and will then um you know invoke the congestion control response and slow down appropriately so i think that's fine to undo in that kind of scenario that was raised um and uh yeah and then also just to echo stewart on the question of loss in wireless networks i definitely agree from all the packet traces i've seen from from youtube and google.com that cellular and wi-fi links these days do a really great job of link layer re-transmissions um and so any losses that are are there are usually because of the kind of scenario that's stuart mentioned or there's a rate reduction and it takes a couple of uh rounds for for cubic or whatever to slow down to match the new delivery rate uh so thank you for all your nice work on this this draft thank you virus yeah some of the things that really talked about um especially towards the end right sort of and then also the ravine mentioned so if there's this document started out i mean the the pre-biz version started out with willing to document what linux is doing specifically because that was the you know canonical implementation and the best version started out by wanting to you know update that because the links have changed and also to roll in some of the things that other implementations of cubic had in the meantime done so that is where we started out all the way pretty much until we got marco's review um which uh as we said right raised some"
  },
  {
    "startTime": "00:36:00",
    "text": "very conservative points that basically said you know you can't move this to the standard strike saying this um because it's in conflict with for example five six eighteen or um or sk1 or 4015 and while that's you know technically true right we shouldn't publish your proposed standard that's goes against the must in the draft standard in reality right all the stacks have been doing it for over a decade and the internet is fine and so at some point i think we should sort of give up this um you know very dogmatic view on on congestion control and try to accept that things have moved on since we published some of those rfcs um so so some of those changes we made was because we you know couldn't come to consensus on the issues on it but i would sort of really hope that we could be pragmatic and actually you know document what is working in practice rather than uh you know find ourselves in a situation where unable to move forward because of a must that was written 15 years ago thank you yeah i think i want to echo kind of wireless point but like kind of go in a slightly different direction with it which is um i i think we should really be conscientious i mean i think all the changes like have been discussed sound like mostly sensible um although the flight side of steven change is a little concerning to me because in practice i think yeah i don't know i think that's hard to make right um but but maybe it is okay with enough caveats um but but i think we should be really conscientious of not trying to put things in a document that no one has implemented um and so if we're in a position where you know we get to work in group last call and like there's some recommendations or even must particularly but even some recommendations uh in there that like zero cubic implementations actually do like i think we need to like remove them like i think we need to be like really"
  },
  {
    "startTime": "00:38:00",
    "text": "conscious of like not putting things in the document that no one implements like in production like i don't mean like a toy implementation but i mean like a major deployed operating system or other environment um i don't know i mean maybe i'm too like harsh on this but like if no one implements it there's probably a reason and like putting this back is very silly in my opinion but that's it um yeah one point regarding that so um regarding the implementation point so if i would make a difference but i would make a difference between um what major implementations explicitly say that they don't want to do compared to they might want to do it or they will do it but just haven't done it because it now comes up and it might make sense and they just haven't implemented it yet so that might be a difference um well that that point i'll take it but you know the flight side and c went uh issue it really boiled down to oh there's no roc that uses that and we are moving to standard tracks so we have to i don't know follow the trend and i was a bit disappointed with that um and and uh like really there is no point of using flight size if at all rfc 7661 is probably the way to go and with that could be a must um so um i am not very familiar with all the rfc procedures but that point was really like no standard strike rfc has recommended it by our advice cubic doing it um so yeah yeah sorry i didn't mean to latch onto that one in particular just i only said it because i'm most familiar with kind of the ways that i can not work but um i think i'm receptive to the idea that like if they intend to implement it that might be okay um but i'm also apprehensive because"
  },
  {
    "startTime": "00:40:02",
    "text": "like the ietf has standardized a bunch of stuff that like no one implements and like it my experience is it usually works out pretty poorly if you have no experimental data because it sometimes it turns out like these mechanisms have like gotchas that just don't like cause them not to work for like detail oriented reasons that like we just don't anticipate um you know and this is just the nature of the beast like if you've never written code for it no one's ever deployed it in production i mean it probably works but like you just don't know and simulations don't really cut it so um i don't i mean maybe i'm fine to drop this issue but i just kind of want to put my two cents in on that at that point lars yeah so as a little preview to the talk later on updating uh 5681 so one of the questions i'm actually raising is we if we should try and roll in some of those changes specifically the flight size versus sealant uh discussion we've had because of cubic at the moment the cubic draft updates 5681 because it it wants to make it okay for cubic to do this which raises the slightly sort of uh interesting question whether a proposed standard can update a draft standard um but we might be able to sidestep that issue um if we decide to update 5681 any other comments i have a final question um to for the author so you are using uh hearthstone plus plus as a normative reference um i i think it's uh lars could you answer that bro yeah it is a normative reference because we wanted to use um 2119 language to say should so we are basically we're basically tying ourselves to high style plus"
  },
  {
    "startTime": "00:42:00",
    "text": "so this means as a message to praveen the document uh needs to progress uh yes well it doesn't need a problem milestone the milestones are okay but uh and i'm fine with him saying they want to do measurements um but so he should be aware that there are dependencies yeah i mean this is yet another one of those things right where so high start plus plus is the only standard strike document we have in this space and since we can't or or the the there's also one of the points that marco raised right um we here is that we shouldn't recommend something that isn't standard strike in a standard strike document um and high strike plus it's the only thing that we intend to publish on standard strike right so so either we say you know you know do whatever or do something very conservative um we might wanna uh you know do that but it's again one of these things where in in reality people do do things but we can't say that in the document because of stupid silence reasons i just wanted i mean i just wanted to so i'm happy if uh high start plus plus matches around the next ietf and i don't think it's a problem but it shouldn't move over and over again yeah if it does we have to deal with it in cubic gary michael can we just be clear for the notes whether the reference to high start is a should or a must do the authors just want to say so we can put it in the notes it's a should"
  },
  {
    "startTime": "00:44:07",
    "text": "praveen do you want to say something you just you wearing the queue and just left the queue can you hear me yes we can hi i was just responding to a question so i did mention in the chat as well so we were just waiting for uh other implementers to also implement the changes in the latest draft because the latest rap did have a significant change right so that's the only reason that's one of the main reasons we wanted to wait a bit before we go into working group last fall um but uh yeah i think like uh pretty soon we should be able to get there and then aim to have uh publish this sometime around next eight years perfect thank you uh neil and i'm closing the queue after neil it sounds good uh praveen could you clarify which other uh stacks are are implementing i start plus plus and and you're waiting for feedback on uh yeah so uh the cloudflare quickstack uh implements it uh i think uh apple was experimenting with it and uh freebsd as well i think netflix was experimenting with it so there's multiple implementations out there i'm just waiting for more feedback to move forward okay so martin uh states that he's a bit concerned about the post-working group last call changes uh don't actually have consensus so we will once once we see the final document i think we will we will ask the working group if it's if the working group is fine with these changes anything else"
  },
  {
    "startTime": "00:46:07",
    "text": "then i think we move on to uh the next presentation um tcp yang model i think it's michael yeah this is michael speaking from the floor uh i guess you can hear me right okay so this is a short update uh um on the tcpa module other that is trying to work with mahesh and michelle um and there have been some recent updates to this document uh mostly to ensure that we get closer to a working group last call to finish the small piece of work so there have been two updates recently the first one was basically some open issues that were left in there so we have emphasized now in a much better way and more prominently that the document explicitly has a very narrow scope so this is the consensus in tcpm the document has a very narrow scope we have also [Music] expanded on the specific game semantics on the tcp connection table which is writable so this has caused some discussions in the past so we added text on that and there were some open issues in the security considerations which got fixed so the o3 document was probably first complete version of the document and on that version we then got uh two um extensive uh sets of video comments both from tom catch"
  },
  {
    "startTime": "00:48:00",
    "text": "um the first email uh the relatively small minor um edits which have been fixed in o4 um so we've changed the reference for tcp to 793 bis under the assumption that this document moves forward soonish and then the result actually bugs in the yang module which we have fixed um so this is basically the current version of four and then we basically received the second set of extensive review comments actually which are summarized on slide number four so these are a lot of good and valid comments um most of them are relatively straightforward so i don't think there's much discussion needed on it we just have to implement the changes so i've listed here that there are probably missing references and some of the references need to be more prominently referenced in the yang module and a couple of other things so as i said the references need to improve um there are also some small changes in the in the yang module that need to improve some is just yang semantics a more editorial aspect is that the suggestion is to add more warning signs regarding md5 so so that is this is a legacy technology and tcpo is much better than that so we have such warning signs already in the document but we could do so more prominently and that's something that's easy to change and uh the examples are also not perfect so these are all relatively minor things that will be fixed in the next version of five hopefully within the next few weeks there are only two um the things that are uh are the bigger questions actually and the first issue is that there is an ongoing evaluation"
  },
  {
    "startTime": "00:50:02",
    "text": "couple of documents actually that work on service models and one of these models specifically the three network model also includes yank statements on tcp ao parameters simply because the layers vpn site may need to implement tcpo to protect the control plane signaling of the pgp specifically and that creates an overlap between these two young modules that is nothing specific to this yang module the same overlap happens between the l3 and model and a lot of other itf models simply because it uses other a lot of other technologies but the overlap with the tcp mdn module was not well mentioned in the in our draft so far and this is why we have to do something about that there is also a technical difference in the modeling assumption the l3 and m model assumes that some of the tcpao parameters are modeled in the kitchen k gene key chain sorry um the only issue is that the corresponding rc which is 8177 doesn't foresee that as of today so that is why we actually don't have that solution as of today and in the tcpm yang what will be there therefore i have explicitly added configuration parameters for the send id and the receive id we will see later why these parameters are so relevant for tcpo so this is a difference at the moment my suggestion is to clearly explain that a difference and of the reason why the this model models those two parameters explicitly and of course this also implies that we have to add a reference to the 3m document which is still missing"
  },
  {
    "startTime": "00:52:00",
    "text": "in o4 so this is the first uh possibly a little bit bigger change and that requires additional text at least the last uh bigger request for change was uh comprehensive comparison with the tcp mip so we got past feedback in tcpm that the tcp emip is not so interesting for this young module but now we have a request to make a comparison so this is something that's not super hard because we still model a lot what is in the tcp mip already with some slight differences to be future proof so we could add such a comparison of for example in a new appendix so it's something that's doable um but we haven't done so in the past so and this is something where uh i would also look for feedback from the community um if this is something considered useful as i said there have been past statements on the mic on the tcp map so as i said as a most of these things are straightforward we will come up with a new version of soonish for the last two ones any comments from the group would be particularly appreciated and um that's the current status so as i said there's a new version uh a new version coming up that should address or hopefully all known issues and we would really look for further comments from the group as we have addressed all known issues the authors believe that the document would be ready for working group last call but of course that requires feedback from the community and that's my summary for today comments questions"
  },
  {
    "startTime": "00:54:07",
    "text": "michael um so what is the what is the um reasoning behind wanting to like why did the commenter want to do the bib comparison i mean it was just i mean the i guess the underlying assumption is that there are quite a bit of implementations out there of the t3 mip so we know that there are implementations of the mip and if somebody who implements the mip wants to transition to this yang module of course maybe a translation table could help in most cases to be honest it's relatively easy to see the mapping the statistics are very similar we have removed uh i think one or two aspects from the mip um um we could reason why we've removed that although there was a in the middle there is a setting for the tcp retransmission calculation timeout so we've removed that one i thought that this one is widely implemented actually so as i said it would maybe help implementers but the big question is if somebody who works on young in a state shop is really needs a summary in the in the document okay well i mean i if you think it's not a lot of work i i certainly wouldn't object to like an appendix but um i just i'm a little skeptical that yang's gonna become a dominant configuration mode for like tcpn points uh barring the special case which you correctly targeted which is like these bgp um hosts uh so i i don't think it's him i don't think it's important but if if you don't think it's a lot of effort i think that's fine thanks yeah i mean maybe i mean that that comment is not the first time so we all know that the angle not the um the most important"
  },
  {
    "startTime": "00:56:00",
    "text": "configuration method for a lot of tcp stacks but it matters on vouchers you also see that in the 3nm model which also targets routers so in that specific target area the model mattress and that's also probably one of the key areas where the tcp map actually is implemented so at the end of the day we all know that on host operating systems this model will most likely not be widely used thank you any more comments so guys we are looking forward to to see the updated document will progress then from there okay thank you um the next is a presentation on about test vector um the status of the draft um so um from my hattie or i don't know how that thing plants this up see there yeah hello can you hear hello yep you can run your slides by your own yeah sure"
  },
  {
    "startTime": "00:58:00",
    "text": "okay can you see the slides i guess you can see the slice right okay great excellent sorry uh i had some technical difficulties my laptop just crashed so i had to change to the spare one but there we go uh my name is johan kulsari so i'm presenting the tcpa test vectors draft and the updates to it we have been doing that with show touch so let's see the next slide so the reasoning here is that uh implementing tcpa is is quite complex so the test vector should help to implement it correctly and of course for interoperability it needs to be correct otherwise it won't work at all so here we have provided test vectors for the mandatory options for ipv4 6 for the mandatory algorithms and for both ignoring and including tcp options and it also discusses some of the implementation issues that may be tricky or the implementer uh this was presented last time iitf 110 uh not many changes uh shortly after itf 110 we were able to test it in our lab with ipv6 so no changes there everything was working fine"
  },
  {
    "startTime": "01:00:01",
    "text": "then we got good comments from michael scharf thanks thanks for those and the version o2 draft was updated based on them so there's some clarifications uh uh the nut travels or was changed middle pro middle box traversal and also clarified some parameters that which one where decimal or hexadecimal or even binary for the dcs fields so these are the changes so thanks for the feedback uh so far of course the feedback is always welcome we as authors think that i it's ready for the working group class call we have been waiting for week feedback sometime uh i guess i hope it it is looking good so not more feedback but of course if if something is noticed thank you thank you for the presentation are there any comments she has thinking that this is in good shape and it's getting close so if you have any concern or want to comment no just speak up here or send a message to on the mailing list very soon otherwise we are thinking about proceeding the draft yeah this is michael speaking also just"
  },
  {
    "startTime": "01:02:02",
    "text": "as a heads-up this is an informational document so um of the powerful information documents is maybe a little bit lower than standard strap so for an informational document i think that the working group last call is easier to achieve and we might not be far away from that any comments if that's not the case then we move on to um greg who is presenting on a tcpao interrupt greg you can run your slides herself oh um wait a minute yep now it should be possible okay hey how's the audio yeah pretty good okay hi my name is greg hankins i'm presenting on behalf of me and also melchior ailments who participated and helped facilitate this interrupt test i should mention it's not clear from these slides uh the main use case that we're looking at in the operator community is for bgp so uh this tests focus around pcpao with bgp and all the work that we're doing to evangelize the technology and promote it in the operator community is around use for bgp as a replacement for md5 we conducted an interop test last summer it was in the middle of the covid pandemic and the shutdowns so we figured let's use the time"
  },
  {
    "startTime": "01:04:00",
    "text": "to do some interrupt testing over the internet it was uh done remotely using virtual machines and it turns out it doesn't really matter where they're located as long as there's a tcp connection so we used multi-hop bgp and established v4 and v6 sessions over the internet this saved us some time in getting together in person and lugging routers around and things like that so it's really easy just to spin up a vm and do testing over the internet we tested with two algorithms there sha 96 and asc mac 96 the interrupt was pretty easy but we did learn a couple significant lessons that um are here in the slides uh lesson number one and this is maybe was not obvious to me as a newcomer to tcp ao i think for someone that's configuring it for the first time it could be a little bit of a learning curve so the first lesson that we learned is that send and receive are configured from the router's perspective so my initial configuration was to match the send and receive ids it turns out you actually have to have them so that they're opposite so that the send is configured to the receive and the corresponding receive is configured to descend that was one important thing that we've learned we provided this feedback to the yang model to hopefully clarify that in the yang model and we also updated our respective documentation to make sure that people understand that's how you configure it and the other thing is that since tcpao supports multiple authentication algorithms then or cryptographic algorithms i mean then you have to make sure that you also configure the same algorithm or else that's not going to work the other lesson that we learned is that we had a firewall in the path which we initially did not know about so the nokia router was connected to the"
  },
  {
    "startTime": "01:06:01",
    "text": "internet and was was open the juniper router was behind a firewall and it turns out that the firewall was actually modifying the mss option for some reason so this caused the calculation to fail on the receiver and the bgp session did not come up so this is actually great because this actually means that tcpa was working since the packet was modified the session did not come up so once we figured out that there was indeed a firewall we had to do some package races on each end and then we figured out what was going on relatively quickly the firewall issue was resolved and um interop test was successful there wasn't really much else to say really once the the tcp sessions came up we exchanged routes and just as an extended test and everything worked great so in terms of implementations there are currently several commercial implementations that we're aware of if anyone knows of other implementations please let us know and we'll add them to the list there are no open source implementations this is a problem because the community can't really adopt the technology until there's a number one open source implementations and then number two a tool ecosystem to support the implementation so currently there's no open source implementations and as far as we know only wireshark supports tcpao other tools like tcp dump don't have support for ao yet so here's uh the exciting news is that just last week several members of the community finalized a development project that's funded by the ripe ncc we have funding to develop a reference implementation it's done by philip peps who's been a longtime freebsd committer we're going to provide"
  },
  {
    "startTime": "01:08:00",
    "text": "support by offering router vm's for interrupt testing juniper and nokia will support the testing with vms and the set of deliverables is first of all a reference implementation of tcpao for the bsd kernel and also nc netcat utility and then a port of that reference implementation to the linux kernel we're currently working on more sponsors to also add extensions to some popular routing implementations like open bgp bird possibly fr and this work is targeted it's going to like i said we just finalized this last week so the work should be starting relatively soon and release targeted for early next year hopefully january 21 at 22 though that should be january 22 sorry about that in terms of resources we have a github page that has the configuration examples that were used for the juniper nokia test we added some cisco examples as well we're also developing a much more comprehensive website tcpao.net that is intended to be a one-stop resource for evangelism resources why you should use this technology central location for links to implementations configuration all that kind of thing everyone everything that an operator would need in order to figure out if their routing implementation support tcpao how to configure it and as well as some of the benefits as i mentioned and that's about it any questions or if you have any comments or any other tools and resources or if you'd like to be involved in some of the ongoing projects then get in touch with us any questions you mentioned are the um is the is your team aware of the the well it looks like a tcp ao"
  },
  {
    "startTime": "01:10:01",
    "text": "implementation underway by leonard crestaz for linux no we did not know about that yeah it does seem like over the past uh i guess over the past couple months i do see patches from leonard prestas for what looks like tcpao i think it's underway it looks like he's revised it a couple times but i just wanted to mention that okay i did not know about that um could you would you mind sending us a note with uh the name i don't recognize the name i'm not i'm not a linux developer familiar with all of them yeah i'll send you the email and then pointers to the patches yeah great thanks a lot micah yeah i have one question regarding actually the previous um configure the previous talk have you looked at the test vector document during that interrupt no we didn't um primarily just because we we each had implementations and we didn't feel like we needed to and uh our actually the nokia implementation was released many years ago even in the cisco as well even before the test vector's draft was even written so that wasn't useful for us at the time but i expect it will be useful for the ongoing work in the freebsd reference implementation yeah if as if there's any um if such as uh an observation already can be posted somewhere for example a list that this would be excellent so if yeah somebody confirms that the test vector document uh first this correct and segment has been useful so this would be a very um strong um help for tcpm to finish the document actually yep"
  },
  {
    "startTime": "01:12:03",
    "text": "was there someone in the queue before me um i just wanted to i mean i pretty much like the idea of supporting open source implementations um regarding the previous d1 do you know if philip is going to implement this for the base tcp stack or also for alternative tcp stacks like for rec or so i'm not sure that's a good question i can i can ask ask philip and we can note that in the project proposal okay because i think the base deck supports uh the md5 stuff and the extensions don't right now okay any other comments if that's not the case then thank you very much for the thank you for the interesting information um and [Music] the next is neither wes nor joe um but wes is in his west still there no idea what's in these charts yeah so um my point is um there are two documents uh so so maybe you can jump in uh there are two documents one is describing how to extend the option space for packets"
  },
  {
    "startTime": "01:14:01",
    "text": "after the initial exchange with soon segments and another one which is an individual submission about exchange extending the option space for packets with this option set and [Music] so he has made no progress on the implementation and things so things that the document is becoming more stable so the tcp edo document he thinks is ready for working group last call and the the other one which is an individual document there are some dvds but he thinks it's near ready for working with glass call so that's the status update um are there any comments any messages for wes or joe a little bit i that is indeed quite stable and has been for uh a while uh it's just been uh a case of uh there's a lack of uh eagerness or urgency in implementing it anywhere and so that's what has been paused on however it's not really been changing at all and there are no known issues that i'm aware of either other than not really being implemented yoshi okay so yeah i think i have a couple of comment video but i will send a you know on the list later because i need to think about a little bit more but other than that i think i'm really curious"
  },
  {
    "startTime": "01:16:02",
    "text": "about uh some uh middle box interaction or a hardware optimization interaction of the edo and then especially if it's in if someone you know implementing you know renaissance others you know always stuck you know then i've tried to get some feedback if this is feasible like this there is no concerns about it so i just know my concise now this is very best feedback on this document so but uh this is kind of important document because you know option space extension is very important so i just would like to see more feedback and then and also scene extension i i have some you know one collection this this is not uh indeed is this is not adapted working group item so there is no working with brasco and so it's not ready for working with rascal i think and then um and then i basically opposed the idea that's submitting this draft as an individual submission um individual streams so if these documents you know going to publish it should be adapted back in group item and then star directly that's one thing i want to mention that but this is as my individual comment again i also have a want to see a more feedback on this one as well yeah the milestones are um a bit in the future martin as an individual or as an id i don't know oh as an individual um thanks for the presentation wes uh can you talk a little more about implementation so are there literally no implementations or just a matter that hasn't been deployed anymore"
  },
  {
    "startTime": "01:18:03",
    "text": "actually i believe there was some work but it was uh several years ago i think joe was working with a grad student who did some implementation work on edo i don't think the other one uh was implemented yet but um yeah i think there was some work and that experience was plowed back into the draft however it's not uh the case that that work resulted in like patches to the linux kernel that uh are deployed or anything like that so um i think uh an interesting way to deal with this might be to attempt to last call and see who responds uh i i think i think that might force people to look at it because there's really no driving uh need for this at the moment although there had been many times in the past when people wanted more options space and didn't have it and because of that that's why these drafts exist it's only a matter of time before someone comes up again and wants more option space yeah i mean i think i think last call as a technique to like shake out stuff is good as long as you only accept knows an answer um i i guess my other my other thing would be uh i'm a little uncomfortable the idea of edo being standards track um it seems to me like the whole game here is is deployment experience with the the whole question here is the middle box reactions and without any deployment experience i don't know how we could possibly recommend this to people um experimental would be fine but standards track seemed really"
  },
  {
    "startTime": "01:20:01",
    "text": "aggressive to me personally as an individual thanks michael and i closed the queue after my yeah just like to echo what wes said um 10 years ago this was really an urgent problem that showed up every once per year and this was the basically when we started that work um of course things got more silent on options recently but as i said there was a strong need for that document a couple of years ago of course situation has changed a bit but we don't know the future so i think there is it is valid to document some of these things in one way or another that's an individual country okay but uh yoshi said he had comments so i suggest that he sends the comments and that can get incorporated in the document okay so we have uh 40 minutes left and we have we need 40 minutes for the for the next three presentations so i'm i'm running the timer to keep um the time budgets reflected so lars you're up next yeah thanks uh can you share should i share uh i would say you share you should be able to do that okay are you requested to share [Music] i just yep now you should be able to do that"
  },
  {
    "startTime": "01:22:04",
    "text": "i think it's these ones can you see yes and sorry for being so super late with them i actually didn't have them until earlier today because i thought i would speak without slides and then i decided maybe uh giving people something to look at other than myself is a nice thing to do right so you used a way to submit them which i don't know how to do that maybe it's just so you can you can now upload slides directly to the data tracker as a participant ah okay which is what i did because i wanted to try it out but it's a new functionality that can be advertised a bit more but um it means that your shares don't have to like do all the slight handling uh yourself anymore which is nice um anyway so it was i guess it's good i made slides just just for that reason um right so so um this is a sort of initial presentation on wanting to raise the question whether we should revise rfc 5681 which is tcp congestion control which is a pretty core um rfc and i already talked earlier when we had the cubic presentation on some of the reasons why i think wouldn't mean we might want to do that but let's go ahead um as a brief history right so 5681 is the current draft standard um it obsoleted 2581 which was a proposed standard which in turn obsoleted 2001 which was also proposed standard and just based on the rfc number alone you can see it's been a while since this was last touched um so the the main goal here would be to move this to an internet standard uh since it isn't already and it kind of feels like tcp congestion control is sort of ready for that um there's one existing errata which has also been verified um on 5681 so the minimum goal would be to roll that into the revision um which is i think pretty uncontroversial given that it's already verified um i reached out to the original authors"
  },
  {
    "startTime": "01:24:00",
    "text": "and uh ron paxton has said that he has moved on and has no time to spend on this but wishes of luck uh mike allman and ethan blanton said they would contribute and i've also sort of reached out to ridicule neil cargill and jana yengar for help and um that is already five so if if those five want to do it uh you know full speed ahead to them otherwise i can sort of volunteer to act as editor but i felt like i wanted to have some people on board that know this stuff uh better than me um there's a repository um on github which basically has a markdown version of the text that was 5681 um and there's sort of just formatting changes and and some very minor things are related to that like updating to reference and so on um so the the one question i want to raise is should tcpm even do this right uh basically open 5681 uh with those goals on the slide and and there's a another goal on the next slide that might make that discussion a little bit more interesting right and that is um there's things that have accumulated um since we uh published 5681 specifically they're widely deployed for for a decade or longer that are in conflict with what 5681 says and one specific example came up when we did cubic uh the quickbiz right 5681 says you set ss thresh based on flight size and cubic as far as i know cubic basically since its inception and also all major cubic implementations don't do that and they update ss3 based on seawind and not flight test because it has benefits in app limited scenarios um which is technically not allowed by 5681 right which is why it was raised for cubic when we wanted to move it to the standard stack um gory pointed out there's rfc 7661 which is experimental that already sort of allows um"
  },
  {
    "startTime": "01:26:00",
    "text": "ss thresh to be set to something between flight size and c wind so so cubic would be sort of in line with 7661 but 7661 didn't update 5681 and it couldn't because it's experimental right um also a quick uh i think this was uh brought by yusun uh the quick congestion control document actually defines updating as a thresh based on seaweed and so is also not in line with 5681 um and we have sort of this is one example of something where you know we are sort of diverging from the uh the the original uh specification in 5681 but there's probably others like that um and others might have other examples so the question is if we did update 5681 did we want to move some of these things in specifically um for this one the cubic uh bis document that we're doing is already updating or proposing to update 5681 specifically to make cubic's behavior okay basically saying you know whatever cubic does is fine too um and and there might be other things here that we might want to sort of make okay based on 5681 um this does raise the question sort of in terms of um sort of the the standards process you know if we move things into 5681 that aren't uh baked enough um you know would that mean we need to go back to propose standard with it or or stay at draft center and not go to full internet center but i think uh that question of how we're going to do this we can answer once we know what we want to do uh to the to the specification um and i see i have people in the queue which is good because that's all i had thank you yeah hello everybody um thanks for bringing this up so i think actually these changes on this slide are more important than moving to internet"
  },
  {
    "startTime": "01:28:01",
    "text": "standards so i think we should do this for having these changes if we go for internet standard afterwards or not it's a different question for me we might still be able to do it because it's based on what's actually implemented out there um but that's the last important point for me and i also want to mention another thing i think gauri started some document to try to define something like tcp fairness or whatever maybe that belongs into the same bucket not sure watching so as an individual i i support this work um i i am someone inclined to just roll in the abc abyss into 3465 as well but i know that's the next talk so i'll just leave it at that um but the um regarding like the standards level i don't have a really strong opinion about it but i i do think we need to think hard about like maybe reframing the language to be a little more permissive in terms of experiments and so on um if the internet standard like it's gonna be very very hard for documents to modify it and so um like i would love to reposition it to say you know to talk about congestion control experiments to explicitly acknowledge the existence of of things that we know about like cubic um which i think you're doing here um and and you know just i i just i just don't want to have like further tinkering blocked by you can't modify you have a proposed standard and you can't modify this internet standard um and just have that be a line of objection to further experimentation thanks mia please be brief uh largely support this work i think"
  },
  {
    "startTime": "01:30:02",
    "text": "this makes sense to me same sentiment as others are not yet sure whether we internet standard congestion control is still evolving uh we're still finding uh new ways of doing things so you know not baking in would be a better thing to do but this makes sense to me i had one question so apart from this particular ss thresh issue what are the other changes that we're thinking about are there like other uh issues or updates that we want to do here i i don't know frankly so i haven't had a chance to sort of get together with the the people i i sort of i got to the point where i asked them whether they're interested but i haven't actually sent an email so what do we want to do um i think i i basically um when i contacted them the the goal i pitched was to move this to another standard and so by definition we thought this was going to be a pretty minor update if um we think we want to make more changes then um you know we sort of need to reconfirm and restate this but i don't know so i'm i'm guessing we want to sort of maybe start a list of some sort i'm hoping it will be still a short list but this is the one thing that i have fresh in my mind because of cubic gary you are still muted can't hear you boy can you hear me now yes excellent so it's true i started something in tsvwg to try and catalog all the things said in rfcs about what was thought good practice for congestion control"
  },
  {
    "startTime": "01:32:03",
    "text": "it's a long list and not all of them we probably now believe in so where does this really lead us to i think we can document what new reno is i'm a bit frightened that we don't really know the answers to changing it significantly in other words rewriting the spec and i particularly wonder about what happened in quick because i thought quick was reno based and that was what the charter said no congestion control work and yet we put cubic's reaction into 9002 which clearly isn't what the rfc series said if we make things like this happen how are we going to write a new 5681 that covers everything i think this is hard and we should think carefully about what we want to achieve bob you're very okay um the the the changes on this slide is fine moving to internet standard i think would be wrong you know yep and then um and the the reason is that i think there's reducing use of reality sorry but that wasn't really cool"
  },
  {
    "startTime": "01:34:03",
    "text": "[Applause] since we are running out of time i would say michael what do you want to say yeah just have a quick comment from the chair that's there's also something that might have editorial changes um 793 bliss has a congestion con control consideration section and that changes the framing for this 5681 a bit so because the basic construction control requirements in 793 bis and as of today this was basically 56.81 so um as i said they changes in 793 bits actually could result in editorial changes in this one as well okay so i would say we get this um discussion to the list since we have to move on um so the next one is about abc um vidi should i run the slides again i can try uh oh you can try okay ask to share slides or well you can do it if you want okay here we go okay and um you have 15 minutes but if you can do it in less time i can i'll do this better can you see this one yes oh nice um so this uh this is a discussion on the mailing list about you know how abc is currently right now and youtube neil and i you know we talked about it and probably we want to um bring our proposal to the to this"
  },
  {
    "startTime": "01:36:01",
    "text": "meeting and to the mailing list um so let's see so the recap of rc 3465 appropriate by counting there is a you know in earlier in i don't know i wasn't really working on congestion control in 1999 but there was a paper um in 1999 and it was about how you know the receivers could manipulate senders and can manipulate the senders to increase the condition window uh by sending acknowledgements for one bite instead of for the whole packet and this means that you would increase the condition window by a thousand packets but the receiver could basically is it could basically be just acting thousand bytes and so the rfc 3465 fixes this by making the increase based on the bytes acknowledged not per ack and the issue that is discussed in rc 3465 is about a stretch stack which could uh sharply increase congestion window and cause very bursty behavior and for that it has a limit a cap called l to limit the bursting behavior so this is the recap of 34.65 uh on the next uh slide we are talking about the problem statement so the the with with you know um so much involvement and advancements uh the cap of two uh packets is not cutting it so we think that um the these days the stretch acts acknowledge a lot more significantly more packets than two packets and this means that the condition window increase is going to be limited by two packets and it's going to be very slow the increase is going to be very small"
  },
  {
    "startTime": "01:38:01",
    "text": "uh and other stacks don't implement this limit um because of you know the uh low throughput and the low receiving increase issue and uh linux has been implementing abc without l since 2013 and it it basically the the the way to control bursting it encourages to use spacing uh to reduce the bursts um the solution uh we're tr we're trying to propose a solution where you know we remove this limit l and we say that the increase in the conduction window is a separate problem from from bursting so we use the ack information the total amount of bytes acknowledged to increase the condition window and basically that's based on what we are learning about the network and what we are probing and we will separate out the bursting issue by using some sort of pacing um the rc the pr rfc 6937 um it defines a new state called delivered data which is basically you know the amount of data that has left the network so we're proposing to use that uh to increase the condition window and in the next slide i can describe what delivered data uh what's the definition of delivered data so it's it's it's um in uh you know in in in just plain english it is the amount of data that has left the network and uh let's say if zach is supported in in that case um when we don't have any sac uh blocks then delver data is basically changing the uh the old una and the new una"
  },
  {
    "startTime": "01:40:00",
    "text": "and when sac is supported i'm sorry when the sorry when when there are sac ranges which means there are some reordering or there's some packets are getting acknowledged before the send una is increasing then the delivered data is changing at the una and whatever is the delta in the sac blocks um when sac is not supported um then um first case is when there are no duplicate x it's just same as the previous case where it will be change in the same q a and uh when there is some recovery going on and we have duplicate acts um then delivered data will be uh equal to one packet on every single dupac because one packet is leaving the network and on subsequent partial or full ack it will be updated to whatever is the change in the send una and we will subtract uh one sms for one uh packet for each preceding dupac so you know so that we don't double count the packets that are cumulatively acknowledged in the full act so this this is a simple definition of delivered data and it reflects exactly what is leaving the network um at any with with any act we know how much data has left on our work and this is the last slide this is about this is a simple change um probably and can we fold these changes into 56 81 bits instead of doing a 3465 base and that way we can obsolete probably the 3465 roc um that's all i have um open four questions uh so as i said a minute ago yeah i think the answer to the last question is"
  },
  {
    "startTime": "01:42:00",
    "text": "yes um 5681 already has abc but with l equals one uh if i characterize it that way um so i think just like having fewer documents would be good uh the other the other caution i would have is to email mark allman um as many of you know i've had like an extended discussion with him about this and he is um some real concerns about just ramping up l in the way that you're talking about here granted it is happening in the internet and this is but this is this is an argument we should probably actually have rather than just kind of rubber stamp thanks ready uh i just wanted to point it out that um the windows tcp stack does use l and it caps it to eight right now um so that change was done particularly as stretch checking became more common uh and windows tcp stack doesn't do uh facing either right now by default and i believe linux doesn't do pacing either by default so my concern with just removing the l limit is that then we should say that facing is mandatory right so that's what the quick rfc ended up doing right so quick connection control rc says i think pacing is a must if i recall correctly and then uh it doesn't have the l limit in the specification right so yeah if you want to remove l then you have to make facing mandatory that may not work for all implementations on iot devices etc where you know facing might have overhead so i think this is a far more nuanced discussion than just saying let's remove l in my opinion right you're absolutely right without facing uh there needs to i mean i'm not in a favor of l but i think the quick draft um does uh recommend i don't think it says must my memory is probably uh not accurate but uh it does uh provide an alternative which is kind of"
  },
  {
    "startTime": "01:44:01",
    "text": "pacing in the transport stack by distributing how much you're sending uh in one send during the whole rtt uh maybe someone can correct me but you're right um without pacing um there can be a l but we couldn't reach a consensus on what this l would be like you said windows is using eight um i think we are using ten and uh the draft says two uh and mark is going to based on my uh you know whatever he has replied on the mailing list he's not gonna like because then that's just you know we're just guessing numbers so perhaps we can also take this to the mailing list yoshi um i have one clarification question so in my understanding abc is used for slow start phase and then congestion avoidance space but abc is now used recovery phase my understanding so in the slide you mentioned about deepak i it is for the other case not a recovery case you know the same package does happen i just like no no you know if you want to apply this during recovery phase [Music] i think if you read the abc draft um you know for example if there's a rto then there's a slow start recovery and and in that case it says it recommends l equals to two in certain scenarios and other scenarios it recommends l equals two one but uh for the fast re-transmit scenario you're right um because that would be incongestion i don't think we use abc in conjunction avoidance at all because that's straightforward increased by one mss"
  },
  {
    "startTime": "01:46:02",
    "text": "um and and that would apply to the loss recovery as well during the fast retransmit but not during the rto recovery yeah i just wanted to confirm that uh the quick rfc 9002 um says either you must piece or uh you must limit l to with n basically um and the choice of 10 to go back to the question of whether it's a magic number or not is it's not i mean it is short of a magic number um but that magic number comes from the iw10 draft which kind of implicitly allows you to burst 10 packets into the network uh at once uh as a direct result of that draft um and so you know if you're going to pick a magic number you might as well pick one based on an existing rfc um it also matches and it coincidentally the initial painting the fq basin quantum the initial fq base and quantum of linux and so there's also experimental evidence for it um that's not to say i actually think 10 is the right number um but it's it's it's something we have so um yeah just because thank you for clarifying yeah i wasn't sure about it praveen um i think like uh in uh so we should recommend pacing i guess and then uh fallback should be an l value and i'm perfectly fine with 10 although you're using eight uh and seems reasonable to me based on the initial window but all the stacks are using right the issue raised by mark was it's not really that you're bursting 10 packets you're reversing x plus 10 right and x is whatever window you have right now um so the point is really not there is 10 or 2 or whatever it's it's uh i think the point is it goes beyond what abc recommends is um"
  },
  {
    "startTime": "01:48:00",
    "text": "can you burst the whole congestion window in one cent um and i think the pacing is answered the answer to that is pacing we cannot i think we shouldn't be bursting a whole congestion window uh wherever we are in the slow start phase so okay so i closed the line and let's say we continue the discussion on the mating list um in principle i think less documents are better than more so the rest of the time uh is neil can be spent by neil on um silent clothes all right so i'm gonna try to uh share my share well you can you can share your presentation the the sites have been uploaded so if you click on the upper left document i clicked on it and it thinks i've got it there it goes yeah we have to approve it you can request be approved you do uh here we go all right can everybody see that yep okay great so um we wanted to talk today about a um a an issue that we have seen in production and a particular solution that we've been using and wanted to discuss it with the community um and this is about an uh this feature is called or we call it tcp silent close um so the motivating scenario here is uh if you imagine a large-scale internet service where it has tcp connections to millions perhaps hundreds of millions of cell"
  },
  {
    "startTime": "01:50:00",
    "text": "phones and then um the server machines kernel pcp stack closes all of those tcp connections quickly due to one of two kinds of situations either one the server application exits or restarts cleanly for updating the executable or updating the configuration or there is a server application crash so the process uh set faults and dies and the kernel closes all of those millions of tcp connections so in either of these cases the clean exit or a crash what you have here is you have tcp in the kernel bursting millions of fins to millions of cell phones uh often in the local region or country so obviously that has a problematic impact um in particular there's heavy network and energy resource usage basically to find in contact and wake up those millions of dormant cell phone radios and then there's also a significant impact because the cell phone network then has to cue those fins and repeatedly retry them for the phones where the radio is powered off or the phone itself is powered off so it might be retrying those fins all night in some cases depending on the the cell phone system implementation and uh that has the potential to cause um cellular networks to become overloaded um and in some cases fail uh and so the concern here is that this kind of scenario is a potential scalability or reliability vulnerability for some cell phone uh networks out there so um is this specific to tcp well in tcp this problem happens in particular because the responsibilities are typically split between the application and the kernel and here we have a case where the application crashes or exits and then"
  },
  {
    "startTime": "01:52:02",
    "text": "the kernel still has the state for that socket and it tries to finish the finac finac handshake at the end but can do this in a very bursty manner for millions of connections uh interestingly you know in in a protocol like quick that's typically implemented in user space you probably don't have this problem uh because the kernel has no transport state so if the application exits cleanly or crashes the kernel has no state so we can't actually do this you know burst of a million fins or the equivalent and so there's no extra network load and so you don't run into this problem but in general presumably this problem could happen for any kernel transport so the goal of the tcp silent close effort uh was to say that upon application exit or crash instead of sending those big bursts of millions of fins we want to basically manifest the traditional behavior that the internet has seen for either a kernel crash or a machine crashing or powering off so basically in that situation we have uh all of the connections from the server that just crashed or died they go silent and then any later incoming traffic for those connections uh that's sent by the client and then arrives at the restored or rebooted or powered online server then triggers a reset because obviously that server's kernel has no state for that connection so we still want it to be the case though that upon the normal or healthy close of a tcp of an individual server tcp connection we want to go ahead and use the traditional fin act fanatic handshake at the end and one key design feature of this approach is that there's no new network behaviors introduced in this kind of silent close approach because basically applications and tcp stacks already have to be prepared for this kind of silence and then a reset if"
  },
  {
    "startTime": "01:54:01",
    "text": "they try to later contact a remote endpoint you know obviously before this could happen with a kernel crash a machine that's powered off a cellular or wi-fi link that is no longer usable because the user is too far away from an access point um but after if we have a silent close feature in place then obviously the same symptoms can be manifested with an application crash or an application exit so just to clarify what we're talking about here um if we compare a sort of server process exit or crash you know before with the traditional tcp implementation you know the behavior you get would be millions of fans going out to the network uh in a burst to all these handsets being retransmitted many times or retried many times um and after if you have a sort of silent close feature um and there's a server process extra crash you don't get that storm of fins and so what is the precise mechanism that we're proposing here so the idea is a boolean uh tcp silent close per socket option set via set suck ups get via get succot and when this feature is enabled and a tcp connection is closed or shut down for any reason then the kernel sends no fan since no reset and the kernel frees the socket state immediately and effectively as said before the goal is that upon application extra crash the connection manifests the traditional behavior for a kernel crash or machine power off the connection goes silent any later incoming traffic just gets a reset and in particular we've used this option for years at our team for a limited set of very large scale services and we plan to send this code upstream to linux when netx opens i believe next week"
  },
  {
    "startTime": "01:56:00",
    "text": "uh and so we wanted to discuss this in this community um since we wanted to to start getting this in the open source world um so the usage model is pretty simple uh you the idea is you enable silent close on a on a listener or immediately after a connection is established after except and thus if the process crashes or exits at any time during the normal operation of that connection you don't get this large scale burst of fins however when the process wants to go ahead and close a single tcp connection because the work is done or the client went away the idea is you sort of disable this silent close feature and then you do your clothes or your shut down so that you get a normal fin act handshake uh when everything is going that smoothly and cleanly uh you know the api is very simple set sock opt pcb sign on close to value one to enable you know zero to disable etc uh you know the api details um we would suggest that this is at least for now guarded by a system so that the system administrator has to explicitly enable this since it's a new feature we propose that the child server sockets inherit from the parent so that you don't need a new system call to enable this on every new connection to reduce overhead uh we would propose that that it overrides the eso linger setting and returns immediately we looked at some other alternative semantics um or considered those so for example we could say that perhaps if the application does a close or shutdown system call perhaps that always attempts the finac finic handshake and perhaps you only would have a silent close feature upon process exit either cleanly or due to crash um but we decided that that would might prevent applications from programmatically deciding to silent close millions of connections if they realize they need to"
  },
  {
    "startTime": "01:58:02",
    "text": "to manage memory or handle denial of service attacks etc um usage considerations we do encourage people before deploying this to really consider the negative possible negative impacts obviously if the server is closing the connection without the fins that could leave extra memory usage either in the client side or in the middle box so we do want people to consider that so we do want this to be a feature that's used carefully and only to prevent outage prevention only to prevent outages not just to save a few packets uh here and there um and there has been some related work in this area that i think helps motivate this and show that the community does feel like there has been a long-standing need for this kind of thing so there was a paper from connex a couple years ago called asylum tcp connection closure and their their motivating use case was cellular networks as well although their angle was reducing energy consumption and signal load um that we thought was kind of a heavyweight implementation because it required a new option on the wire it required you so you have to upgrade client in the server os and then you have to upgrade the client in the server application to agree on this enabling this so we didn't think that was a good model there's also so linger which has been around for a long time with a similar motivation like practical motivation of scalability avoiding time weight state on servers for millions of connections um we thought this was similar in spirit but we didn't want to change this sort of long-standing api or add a new magic number to that existing api and risk compatibility issues there's also an interesting silent close implication of the linux tcp repair mode which is for connection migration but the semantics don't really line up with what you want because if you use tcp repair mode you basically"
  },
  {
    "startTime": "02:00:00",
    "text": "are serializing your connection state and disabling the operation of that connection in the kernel which is not exactly what we want to do here here we want to basically be able to continue to use this connection and just say if that application exits later on then we want to have that asylum close for that connection um so yeah so the effort status we've used it in years for years and we wanted to open source this so we wanted to come discuss with the community um and uh yeah we wanted to invite a discussion although i see we're probably out of time but maybe on the list uh people can connect with us or now as well thank you thank you for the presentation um we are basically out of time but maybe three quick questions maya and then a question i will be brief so as you said on this where you talk about user usage considerations you basically have a trade-off here right you try to reduce network load but you increase load um at the other side and maybe middle boxes by not sending something so i'm i'm not sure what i think about this idea because i don't know how to rate the straight up right i don't understand what the implications are for for all the involved parties okay thank you yeah so it's our estimation and experience that the the extra amount the extra load that it's imposing keep in mind is just memory in the middle box and then the client and those pieces of the system already have to have logic in place to do garbage collection and bound that state um so it's our sense that it's a net safety improvement to deploy something like this to avoid accidental you know massively excessive load on the cell phone network um since the other since the players that have to do with the extra state already have to deal with this"
  },
  {
    "startTime": "02:02:00",
    "text": "issue of value in that state okay so the question i had was i understand that you do this if you close the socket or the close of the socket because the process died but if you shut down the reader right side i'm not sure if uh if you do if when you do that the tcp connection should go away um so i don't think this changes the shutdown of the read side um on the right side i believe my recollection of how we've implemented it is that if you enable silent close and then you do a shutdown of the right side i believe it omits the fin and um i think that's a detail we could if people think if people see problems with that we could obviously discuss that we can discuss this yeah stuart last comment thank you i'll try to make this quick because we're over time uh i see the arguments for this and i'm not saying it's a bad idea i am saying it needs to be done very carefully i think there's a real risk of unintended consequences here uh it's very easy like in the research paper you cited they don't send the finn to save packets and as you say this puts a bigger memory burden on nats and firewalls for that state and that also has a consequence because uh i'm sure you're aware right now tcp net mappings tend to have a much longer lifetime than udp mappings and the reason that gateways could do that and firewalls and other metal boxes is because they can assume they'll see a tcp pin or recess that tells them when a tcp connection is done so merely the lack of traffic does not mean a connection uh as has been abandoned"
  },
  {
    "startTime": "02:04:02",
    "text": "if this socket option is widely available on linux that makes it very easy to just abandon connections then that will force gnats to be much more aggressive without scavenging apparently idle tcp mappings just like they do for udp today and then you might end up having to send 10 times as much keep live traffic in this future world so this apparently well motivated move to save one fin packet has the consequence that we're now sending 10 times as much keeper live traffic 24 hours a day to stop these connections yeah i agree it's something we have to carefully consider it's i guess my sense is that hopefully these um these not boxes are using some sort of lru [Music] map you know lre policy for eviction anyway so hopefully it would work out in practice given that the given the intended usage model but yeah there's at this point we have the reality today that one of the reasons quick is not suitable for long-lived mostly idle connections like push notification connections is because udp mappings have to be aggressively recycled because there's no explicit fin or reset and and if we effectively move tcp in the direction that it also has no explicit connection termination we should expect to see the same lifetime for tcp mappings as we currently have the udp mappings okay thank you for for the discussion thank you for attending um i suggest to move the discussion on the mailing list um i would say thank you for attending the meeting and um michael yoshi you want to say"
  },
  {
    "startTime": "02:06:00",
    "text": "a final word or if that's not the case then i would say goodbye and see you next time and wherever it is bye yeah thanks a lot for learning tcpm5 you"
  }
]
