[
  {
    "startTime": "00:00:05",
    "text": "foreign just approved and uploaded your slides so they're ready for you to share and uh I guess so and Christian is here any question so I'm going to be on for the beginning of this um and then Christian will be on his owner for that so you want me to share this right now well um let's do my item first because I wanna I need to get off after that so it's just the time tag thing um I guess it's time to start it so it's top of the hour so welcome to the second interim of the year for C1 first item on the on the menu here is uh time tag finishing finishing up working group last call looks like there's no issues really on that there was some discussion first in any updates on the bit of discussion that went along Karsten takes a long time to unmute sorry I I used the left unmute the left mute I should never use the left mute sorry um so um update from the discussion you mean what what happened at the mailing list or"
  },
  {
    "startTime": "00:02:00",
    "text": "yes yes okay um so this this is really a long-standing um discussion we have had a couple of times already where we started out defining a tag with an information and a document uh and um then it turned out people actually wanted to have normative references to the specification of that uh tag and I think we we need to get a bit better in in having having a standard rule for for um handing this uh kind of case and in this specific situation um I think I think is not here um but there seem to be some security applications that actually would benefit from the time Tech being um normative document now this is of course always an interesting question when you have a document that itself is extensible uh to a certain extent then part of that may be Rock Solid stable and part of that maybe um things that people put in because they think they will need them and the transition from an information document to to a standard strike document of course raises the question how we handle the second category so things like clock quality um are needed to a certain extent for the security applications um but that's certainly something that that can be discussed so going from informational to standard strike does raise"
  },
  {
    "startTime": "00:04:00",
    "text": "additional questions during the working last call which makes me say this is not entirely a slam dunk but um I think that um in total we we do have good Arguments for moving this to standard strike does anyone see a reason not to move it to standards track and certainly no one mentioned it on the mailing list so well there have been some GitHub discussions about the clock quality and in particular about the fact that the clock quality is defined in terms of an RFC um that actually doesn't Define anything at all but then just references IEEE 1588 which is behind a paywall so many algebrae standards are available through the gets IEEE program but this one isn't so that that ruffled some feathers yes and that is mentioned in the shepherd write-up that I did so um we'll see what the iesg thinks about that my inclination would be to say I'm just as a participant my my inclination is to to go to standards track on it um but I'm you know I'm open to counter arguments so what how about if we say that um first of all do you have any updates to make to it otherwise uh yes there have been quite a few comments over in in the GitHub um there will be a next version and I probably would have worked on that uh this week but I prioritized CDL too"
  },
  {
    "startTime": "00:06:00",
    "text": "um so I think this will happen next week sure okay so then why don't we say that on the next version you make it standards track and I will change the data tracker to go to standards track and we will uh when you post that to the mailing list we'll make a another quick call of whether there are any objections to that change does that sound reasonable that's good for you okay uh anybody else have anything to say about uh time tag foreign nothing uh Carson go ahead and go to your slides for the next item cddl the the user interface is always great when you select the slide said the layout changes in such a way that you have to press dismiss at this point in time because that's just the thing under the cursor right anyway um so I I made two slides about what's going on with the cddf 2.0 support and I think the the most important thing that people ask you about is the the include feature and in iotf 115 I had this example on this slide with a semicolon hash which which will be our pragma prefix and unless somebody comes up with a better one um and then the keyword include and um then we"
  },
  {
    "startTime": "00:08:00",
    "text": "um I have various information uh including where that thing is coming from and uh how it will be uh namespaced within the document that does the include so the next line event start equals time tag dot e time is is my proposal for this uh when when we give something a name uh like time tag here or if we know don't do that uh when we uh just use the the file name for that purpose then we can reference this uh as uh prefix dot uh whatever it's called in the reference file so that seems to work pretty well and I I just did the version of the uccs.cda that has an include for RFC 1952 and and that all works um nicely yes Michael the the semicolon makes this comment in acidity L1 implementation so you can still run your your city di-1 tools on this without hiccups um and uh well I I chose the the hash mark because that's something that people know from from C uh for for this pragmaster a comment um and then of course the stylistic question is whether there should be a space be behind the hash or not uh we can discuss that so probably I'm going to do a little mailing list poll um for that but otherwise the syntax is probably going to steal python syntax a little bit more than than C language syntax and I think it's also important to uh make sure that we don't allow"
  },
  {
    "startTime": "00:10:02",
    "text": "arbitrary file system references uh here so right now this is very limited in what you can have after the world um include so what's after the word include essentially is uh um is limited to to cddl identifiers um so um the the problem with the wholesale include is that you get all these additional rules that you actually don't need um so right now I'm uh thinking about reducing this uh to just the rules that are actually imported plus the the transitive closure of of the reference uh so everything that that is needed to to make this usage time tag.etime is also imported uh from the include but not the whole document uh because there may be other things in there for instance we often have a start um element to to make Studio One tools happy um so that that will not actually be imported and it will not lead to unused rule warnings which could be pretty jarring so um for the existing rfcs it's pretty obvious how to handle this except that there is one one uh question how do we handle the Prelude I'm actually in the current implementation I just have the word prelude for that because it's really very special but we could also identify this as appendix D of RFC 8610 I'm not sure we need this so at the time when I actually import all the the rfcs I will try to"
  },
  {
    "startTime": "00:12:04",
    "text": "check what we actually need there so how does it work in practice um the the tool you use to actually uh work with cddl2 is the cdlc uh tool and that essentially is able to do serial 2 processing on an input City and generate a processed CDA which is compatible with CDA 1.0 so um in in your pipeline uh you would uh include a command like this maybe with some additional Flags um such as uh warning um about undefined and things like that and the the question really is where do we find the the reference document so where do we actually find uh for instance uh RFC in 1952 or um the the internet draft that is in a reference in the example here and um what what we actually need is the CDL for them and um I I plan to put in some processing that allows you to get CDL out of most documents XML text or whatever but of course that won't work reliably in in all cases so my current plan is to put all rfcs into the implementation because rfcs don't change it should be easy to extract cddf from rocs that have cddl include them in the gym and then of course the only problem is if a new RFC comes out uh the the gem has to be"
  },
  {
    "startTime": "00:14:02",
    "text": "updated and what's the latency for that the other place where the implementation currently looks for documents is the current directory um so um there could be other places so it could try to get things from the web or anything but I'm I'm not so sure about how that that works with actual workflows because you don't want all the surprises that come from referencing something on the web so right now this is the the set of things that that is supported so this is the status like we're not hearing you sorry I was we didn't want to interrupt um so I think that uh uh yeah you should have another place uh cddl path so I gather you're basically proposing that you're going to do the file extract from RFC to make a database of cddl files um and I guess I'm gonna suggest mechanically maybe you want to make that a separate gym um and I I would appreciate being able to point at my own directory particularly when uh when working on you know some set of linked documents yeah that's probably not needed so much for rfcs because these are actually pretty stable so yeah you're talking about the yeah the problem of course always is while"
  },
  {
    "startTime": "00:16:01",
    "text": "you are working on documents they are nowhere in the web or or anywhere so that's why the current directory is in this list and you want to have a way to to point to a different place than the country yeah the the you know it's stable but it's in the RFC editor's queue um and but it's not yet an RFC and yet we're building in the next set of stuff based on them right yeah Russ comments that the extraction sounds a lot like young catalog.org for young modules so maybe at some point we we need that right now we are talking about maybe 30 or 50 documents so I think it it's still somewhat manageable and also a little bit of of uh hand processing may be needed for the the oldest RCS that do something with uh CD edit so maybe that's an appropriate thing to include in the gym but of course the the real problem is the documents that that are being uh edited right now uh and and there needs to be accessed to them Christian um what I'd like to understand is uh if if we already need this Con this down conversion from cddl2 to cddl1 uh why does the why does the pragma need to go through something that used to be a comment um to me this this style of hiding something in what used to be a common smells a lot like HTML comments that say if Internet Explorer version equals um and I'd like to forget about those so a document that imports from somewhere will not be usable Standalone anyway so why go through comments and not find a character that used to be invalid"
  },
  {
    "startTime": "00:18:01",
    "text": "and and built from that yeah I don't don't have a really strong opinion on that I think it is useful to be able to use City A1 tools on on those files uh just because there is such a diversity of uh towards um but yeah you may be right that the usefulness um of of that will uh decline over time but on the other hand why don't we just say semicolon hash is a really nice a combination that we all like um and and then we don't really need to have this discussion I don't know so on on the chat Russ comments when other seos are starting making cddl we will need a cross STL repository yeah that's exactly the kind of complexity where I think it would be good um if we had a very pragmatic 80 percent uh solution and and for me personally it always has been fine to actually find those reference documents and and have a make file rule that that does the right kind of extraction for that document uh right into the directory that is used for for processing the cddl um but yes I understand that that other people may have other styles of working"
  },
  {
    "startTime": "00:20:03",
    "text": "okay so Michael uh suggests doing a CDL path with usually Unix colon separated list of directories that are searched and that that could include Dot so maybe the default CDL path would simply be Dot and you can set one but eventually that is all implementation details right this is all implementation details but I think these are important um details because um if we cannot offload these things to the implementation we may have to address them in the language so if if we need something in the language to actually uh access the web and and get something from there and do extractions from there that's yeah different from from just saying this is an implementation better and and we are pretty sure that the implementation can handle that for us okay so uh maybe I'll have the next version of the tool in a couple of hours or so uh so has anybody actually played with the release I met this morning not yet sorry yeah the the problem is that that I finally broke down and said this will require a modern Ruby version because uh working with with uh Json structured data is just so incredibly ugly if you have to do it manually so the the support in the uh recent uh Ruby versions of this uh decade"
  },
  {
    "startTime": "00:22:02",
    "text": "um is really useful for that so if you don't have at least Ruby 3.0 then you may want to look for for installing that but of course other people are welcome to do tools like that it's it's not a giant piece of work to do these things okay one one question that also came um that is I don't have on the slide um now if if I'm including something that in turn itself includes something um then something like cddl pass or or even the the simple approach that is on this slide uh will become interesting so do people have any opinion how to do nested includes how to find the files for that yeah I think there's this problem will be Christian um other other than going forward your eyes and making sure that it's distinguished between it's an identifier and please go fast from there none okay so maybe there will be something like a head to path directive um or something like that but I think we"
  },
  {
    "startTime": "00:24:01",
    "text": "we can see that when we actually start using it and and see that Things become unwieldy and that's of course very important uh for for me to actually get this feedback when people start using it okay that was all I had okay and any more comments on on the cdtr2 from participants general questions customers here now is the time um hearing none we are approaching the end of the agenda we do have the usual placeholder items but essentially it's um is there any news other news about the Seaboard that you would like to share any other business anything you would like to put on the agenda for for itf16 right now um well I'd say then that would give each of us about half an hour of time that we don't have any other appointments in uh to run a gem install dash dash user CD DLC and play around with it yes please thanks everyone with that I think we should adjourn thank you thank you bye-bye well thanks for thanks for taking notes of course yeah bye bye"
  }
]
