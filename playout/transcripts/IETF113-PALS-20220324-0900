[
  {
    "startTime": "00:00:35",
    "text": "i think we start we'll get through the boilerplate um stuff first so i can't see the chat at the moment so if anyone which needs to draw something to my attention please do so i've asked nick to be made a chair as well which will help but hasn't happened yet right so welcome to this meeting of the joint meeting of the pals mpls.net working working groups here is the note well i am sure that everyone is familiar with with that so we won't dwell on that any longer so the purpose of this meeting is a joint meeting of the three working groups and it's being called to discuss the basic architectural issues and solution proposals arising from drafts that proposed new application uses at the bottom of the mpls label stack the general structure of the meetings as follows we're going to start with a status report on the open design team work to date and then we're going to go through use cases requirements and framework then we're going to look at a number of related technical proposals and then we have a 30 minutes at the end if we all run to plan to for an open"
  },
  {
    "startTime": "00:02:01",
    "text": "on the design team work so here is the agenda i propose that we do a small batch that i come to um so we're in session what section one here lower is going to present and talk about the um design team work in his report then tarek is going to talk about the use cases then we'll move to matthew talking about requirements so slots three and four would swap lower will then talk about uh the framework jags will talk about uh a solution draft on extension header um bruno on entropy label id two slots by kiriti uh it's up to you how you spend your 15 minutes kariti but after 15 minutes we will then go to a a an open discussion on the odt activities i'll just leave this for a couple of moments so all these this material is available by the data tracker anyway but uh these are the resource links um for the um where you find the agenda where you find the docs where the jabber room is where the odt wiki is which is where we've been keeping all of the minutes meeting information etc if there's any general issues with um we techo please talk to support ietf.org and there should be a meet echo team monitoring us so uh we're up to 40. um"
  },
  {
    "startTime": "00:04:01",
    "text": "i am now going to share a different set of slides and hand us over to how do i do this to lower um odt report share and okay okay oh yeah you tell me when you want me to move across one okay i have a comment on the wiki on your presentation the week is not very well organized it's possible to go through it and actually clean out the information but you need to take your time if you're new to it okay open this sign team report next slide please so the open design team is actually said to be an mpls open design team but it's actually joint activity between three word working groups that mpls and pals and from time to time the shares are having coordination meetings and to coordinate again and possible decisions the design team meet every thursday and it's very early in california and very late in asia actually just now since i'm in asia i end the meeting welding tooth friday the participation is about 20 part participants each week it might be peaks depending on what topic is discussed and there are about 20 documents that the design team are discussing"
  },
  {
    "startTime": "00:06:00",
    "text": "next and are using the term documents a little bit freely there because some of the discussions are on things that are in the wiki next slide please uh miad we started something something that is kind of very close to what the design team is we call it the miata and that's an mpls indicator and ancillary data project and what we set out to do is actually to define an architecture that allows you to use a data plane to send instructions between layers and lsrs and requesting actions related to an lsp we talked about and here i had a comment that is not very clear what i mean the square brackets are actually uh are alternatives so we talked about forwarding actions and that's in um create this document we talked about network action and then it's and john drake's uh text in the the uh the wiki and we talked about mid miat actions as a alternative name and then there are suggestions that we just talked about actions and don't design them more than that um and we would actually like to prefer we would prefer to pick one of those before progressing documents too far [Music] prefer before or just after making the working of documents we also talked about ancillary data and ancillary data is data that is"
  },
  {
    "startTime": "00:08:02",
    "text": "used to perform the actions requested and it's also sent in the packet next slide please we have uh at least two types of documents one one type of document or what i call guiding and that's this is not an itf term this is my term and to in that group i count requirements framework in use cases and then they have document that that says specifying and that is mostly the solutions document next slide please the next steps we have wanted to start progressing documents for some time uh firstly by adopting them as working group documents what stopped us so far is that some of the documents at least in my mind are not compatible so we can't know both of them we would actually like to we would prefer to uh lead with the guiding documents uh but uh we'd also like to move the solutions documented so sooner soon as soon after as we can the procedures are the standard itf mpls procedures they may be called on there will be consensus call on all three working groups but actually discussion will take place on the mpls list bio is still discussing the process a little bit whether we can start progressing for example a solutions document before all things are sorted out"
  },
  {
    "startTime": "00:10:03",
    "text": "we the next bullet is possibly uh being overwritten uh the uh end-to-end discussion is we don't have the consensus among the shares to actually do the poll so it's on hold the indicator name will probably be solved uh in the framework and requirement stress and then if we want to use a new or a special purpose label or if we want to have a new one that is if we want to use an other one an old one that's still under discussion next slide please so one thing that wasn't clear from me when we started the project was that the the miyag is a little bit different normally the traditional mpls uses a control pane and signaling between the nodes to tell the lsr what to do but in myad we actually use the data stream uh to send information between with the packet between the nodes and that actually brings a strong dependency on hardware and the design team has had [Music] quite a number of discussions on hardware optimizing coding [Music] in my mind there is no strong consensus yet i think we are getting nearer was that the last slide next one that's the last one isn't it lower yeah okay yeah okay i thought so"
  },
  {
    "startTime": "00:12:03",
    "text": "um so i say again uh i would i would prefer that you removed yourself so do we have any questions okay i guess i guess not i mute myself now and then you can go on thank you lower so it's taric next i'll stop these and uh [Music] requirements use cases hello okay over to you tarik okay um can you hear me just a confirmation that you can hear me hello hello yes i can hear you okay okay great thank you uh so hello everyone my name is tarek saad um and i'm going to talk about the use cases for mpls indicators and ancillary data um indeed as lower mentioned there are variants in on my slide i call them function indicators in other cases they are action indicators and so on so i'm yet introducing another uh term uh to the to describe these indicators so we need to uh the action take that action to align and pick up one uh one term for for uh the indicators description um i am presenting a bit on behalf of the co-authors um we are part of the open design team um the objective of this document to compile uh the use cases for"
  },
  {
    "startTime": "00:14:00",
    "text": "um mia that that the design team has been discussing uh in the weekly uh calls um so we we have attempted to cover um what has been discussed so far and what's documented on our wiki we're welcome to to add more to the document or even update what we have next slide please a bit of overview uh although uh law had given a bit of introduction again sorry uh go back please one slide okay um so the npls function indicators and ancillary data miad attends to address requirements from uh new application mpls applications uh these uh require inclusion of uh an indicator inside the mpls packet to allow specific functions to be invoked on the packet as the packet traverses the uh the lsb path uh ancillary data may be included to supplement the invocation of such specific functions and actions uh these ancillary data are added by the ingress ler and they're they're added along with the user traffic uh they may be updated by transit lsrs and ldr as the packet traverses the lsp and they're disposed of and removed by the egress ldr next slide please so in terms of use cases that we have compiled the first one talks about no further reroute we have a reference for the the document that introduced this use case"
  },
  {
    "startTime": "00:16:00",
    "text": "there are cases where uh we have uh fast readout protection and after the failure we read out traffic on the on the backup path but then on the back while the packets are traversing the backup path there could be another uh secondary event a failure event and still a another fr can happen on the backup path itself uh and rerouting the packets uh towards the original pplr in that case uh there could be a loop that could happen between the two plrs the first plr and the second event plr there is an example in the document uh described where we have multi-homing and um uh uh edge protection uh um and cep links fail uh the the the pair of pes are protecting each other so the first event uh the pe would send to the other pe and then the second event other pe will send back to the first pe and we have that loop so basically no further reroute is a an indicator inside the packet that tells any node that when once carried inside the packet tells any node acting as a plr not to read out again or reroute is not allowed again if a failure is is detected this is to disallow that loop potential loop from happening so this is the first use case that we compiled the second use case is about in c to oam this is one flavor of oem where we carry additional data inside the user uh plain"
  },
  {
    "startTime": "00:18:01",
    "text": "traffic so such data like uh telemetry or um uh operational data like time stamps and so on um is carried along with the user traffic um and uh and these these ancillary data can be updated a lot by lsrs as the packet traverse the path so there is a flavor of ion that touches the packet content hop by hop and there is another flavor that's only edge to edge so the requirement is to have such an iuem function indicator carried inside the packet so that we can alert the nodes that need to process or update the ancillary the iom ancillary data next slide please so the third use case that we touched upon is related to network slicing and more specifically to a network resource partition which is the underlay which is a partitioning of the underlay network um in that case um if we are partitioning the underlay network uh and assigning resources to different partitions there is a need to identify the packets belonging to one network resource partition and then apply the perhap behavior or the specific profile treatment on that packet so there is a requirement to carry a resource selector function indicator i called it or a flow aggregate selector and other documents so that the lsrs are able to invoke the perhap behavior so this is the third use case the the fourth use case is related to time"
  },
  {
    "startTime": "00:20:02",
    "text": "sensitive networking we have compiled this use case and we admit that we haven't given it much investigation yet we need to engage that net working group on their interest in in covering this use case in more detail but here it is uh the packet the mplus packet can carry a timestamp or a time budget uh that enable rockers to make queuing decisions um when the packet is traversing a an lsp so for example they could uh prioritize sending out the packet if the time budget budget is is shorter um and as as packet are forwarded along the path we have a times timestamp or budget associated with every hub for example um so the requirement is for the packet to be marked with a and a a time function indicator and as well carry additional ancillary data which is the time stamp that allow lsrs to use to use such a timestamp to prioritize and schedule the packet um this is related to the fourth use case we compile i believe this is the last one but let me double check is there a next slide uh ah there is okay sorry um the fifth use case that we have compiled was related to network programming uh we know about rfc 8986 which is uh network programming in srv6 data plane um the uh this rfc uh with with that uh functionality we get we it allows an operator on an application to specify"
  },
  {
    "startTime": "00:22:00",
    "text": "a packet processing program that to be encoded inside the packet and as well a sequence of instructions inside the packet header so once we carry this inside the packet we can allow such a program to be run by the network on specific nodes the mpls packets may carry such uh such a program uh instruction as a function indicator so that's one thing we discussed uh during the design team as a potential uh functionality that can could come out from miad is that carrying such a program inside the packet as well as some arguments that we can pass along so that we can run that function or our program and those arguments can be the ancillary data carried with the with the packet and the last use case that we compiled in this report was related to service function chaining um there is an rfc in mpls that modeled surface service function chain in header um by emulating the nsh network service header inside the label stack so there was no need for an extension header to to carry the network service the nsh but using miad we're able to carry the ancillary data and we need to do some further investigation if if um in carrying the nsh as ancillary data is superior to emulating the nsh inside the legal stack these were the use cases that we have"
  },
  {
    "startTime": "00:24:00",
    "text": "compiled in terms of next steps some of the documented use cases were driven by application requirements that we know about there are there's interest from the field in in solving these use cases um other require further investigation and validation as i pointed so we would welcome operators and other experts to engage and sound their opinion on this we as usual we welcome further input from the working groups and addition and update to the document is welcome thank you and uh sorry if i took more time than a lot did you we're absolutely bang on time are there any questions yes yes all right so um it's actually being done jointly in the three working groups and the reason that pals has an interest is that powell's uh it was the first um and then.net was the second um system that carried um data below the bottom of stack in order to process the packets so in part this is to make sure that um we um we don't trip over any of the historic work in the those systems continue to work properly as to why this is tagged a pals meeting it is it is entirely sort of procedural and administrative because we couldn't"
  },
  {
    "startTime": "00:26:01",
    "text": "do it all in one slot and so the we requested a second slot to deal with this particular thing mpls will follow in doing its normal work i think you're next maybe can people mute if we speak it better now hello can you hear this one yeah i think it's better but i think the other people have to mute if we speak properly my uh my question was the following tariq i think it's a first of all very good overview my point was a bit on the number five of the use cases if you do five would you not cover all the others because five is the so five is network programming in my view it's a bit of the overarching uh thing that you can do so if you do five you probably if you do five let's say well then you probably have covered the other other ones as well so good point let me let me try to answer that so indeed um as i mentioned some of the application requirements um some of the requirements were driven by um by use cases brought forward um from the field um and um the number five was an aspiration um you know as you say if we model number five we can model any function or any program to be invoked in the packet the question is it's under investigation this is what i put in in between brackets and it's an aspiration the question to the working"
  },
  {
    "startTime": "00:28:00",
    "text": "group is this of interest to the working group and to the operators is this solving specific problems to them that we want to bring about this type of use case but it's a valid uh point that you're raising and my point is if you look at five i mean it's maybe a good reflection on the other use case because if you do let's say have a general i in my view five is a bit of a general uh structure to be able to do multiple things right i at least that's the theory uh and if you could see that you can model the other use cases by doing five that would then i then we have a general generic mechanism to do multiple use cases potentially i don't know whether it's possible or not but i that's why i how i personally see it so me ad is indeed generic miat is not we're not designing specific solutions for specific application the the design team has um you know put itself to design a genetic way to solve this problem um so indeed if we create this generic solution for number or five and to be more more comprehensive um so um we um we got we got some time at the end i'd like to continue this discussion which seems to be of an over overarching sort of type um at the end please uh so we just go we can move on with the the base information we need to start the discussion so next is matthew thank you"
  },
  {
    "startTime": "00:30:02",
    "text": "where's the requirements gone there we go thank you so this um this presentation is about the ad requirements draft that stuart and i have been editing but it's very much an output of the open design team we had a lot of review and discussion of the points in the requirements draft during the open dt meetings next slide please so so this document captures the key requirements for both the ancillary data and the indicators in the mpls label stack that support i've written network actions there but as uh as was indicated as lower indicated early on there's some discussion around the exact terminology here um the user ancillary data as mentioned it's a product of the mpls open design team um so the the requirements we've got in there were largely derived from uh looking at the proposals for additions to the mpls label stack so look at some of the solutions that propose looking at the use cases um to allow decisions about those actions uh based on uh application data um and that application data so that's that's the ancillary data can exist within or below the label stack and the actions can be performed by intermediate or transit lsrs or terminating lsrs of for the lsp i should make clear that the requirements are on the protocol design work not on what implementations have to support as i think is generally the case for the requirements documents and these projects in the itf next slide is so the draft is is structured into"
  },
  {
    "startTime": "00:32:02",
    "text": "kind of four sections um we tried to define some of the base terminology and the terminology work that we did here was done generally before the framework draft although some of the terminology may end up being standardized really in in the framework drafts and so we may need to update this part um some general requirements are kind of a set of design principles that underpin the work uh requirements on the ancillary data indicators so there's the indicators in the label stack for the presence of ancillary data and what to do with it and requirements on the ancillary data itself next slide so i just wanted to highlight some of the the key new terminology that we we started by defining in in this draft and these may change depending on on the framework draft or the details of this terminology may change depending on on the work on going work in the framework draft so the first one is the ancillary data so this is defined in this requirements draft as data relating to the mpls packet that may be used to affect the forwarding or other processing of that packet either an ler or an lsr and this data may be encoded within the label stack so it's termed in stack data or and or after the bottom of the label stack and that's termed post stack data the second major term new term is the ancillary data indicator or adi so this is an indicator in the mpls label stack that ancillary data exists in the packet it can also indicate the specific type of the ancillary data so it gives some indications on how to process the the ancillary data in that case uh we also tried to define end to end and hot by hot but really these need to"
  },
  {
    "startTime": "00:34:00",
    "text": "be defined in these really architectural concepts and they they need to be defined ready in the framework draft so i won't dwell on those here next general requirements so this is uh the first of the main requirement sections um and and these are mainly about ensuring consistency of the design with mpls and the efficiency of the protocol and i've just copied a few of the main ones here from from the requirements draft so so mpls today combines extensibility flexibility and efficiency by using a control plane context combined with some very simple data plane uh mechanisms to allow the network to make forwarding decisions about a packet and we're not trying to change or break or be inconsistent with any of these properties so any solution must maintain these kind of properties of mpls in general any solutions to these requirements must not restrict the generality of the mpls architecture so what we meant by that i think was the ability of the mpls architecture to evolve and be extended in future for new solutions so we're not kind of nailing down a particular version of the npls architecture here it's it's proven to be extremely flexible in the past and by mpls architecture we mean what's defined in rfc's 3031 and 3032 if extensions to the mpls data plane are required they must not be inconsistent with the mpls architecture so we are going to try and use the as much as possible the existing mechanisms provided by mpls the design of any mechanism should be such that an lsr is able to efficiently pass the label stack um and mechanisms so that's basically don't detract from the existing very efficient data plane design of mpls um and mechanisms must not add more"
  },
  {
    "startTime": "00:36:00",
    "text": "labels to the label stack than is necessary so try and constrain the size of the packets because there's still a lot of hardware out there in deployed networks that would have issues parsing very large packets next slide so then we have some requirements on the ancillary data indicators themselves um i won't go through all these there's quite a few quite a few in the draft so i won't go through them all in this presentation i just wanted to give you an overview of the intention of this section so this is a specific these are specific requirements on the design of ancillary data indicators and then really address the following themes so firstly the need for an adi at all um coexistence of the adi which is in the label stack with existing mpls mechanisms the need for mechanisms to enable a head-end ler to know whether and where in a label stack to insert an adi on the lsp and adi support for end-to-end and hot-by-hop processing of the ancillary data now require the next section is on requirements on the ancillary data itself now these are these are quite high obviously quite high level um we're not necessarily designing the details of the ancillary data but we need to at least have sufficient uh protocol design work to identify what the ancillary data is and roughly what to do with it so the high level these are high level requirements and then just address a set of themes the first is coexistence of the ancillary data which could be in the label stack with existing mpls mechanisms and also coexistence with post-stack mechanisms such as control words or generic aches um the next one's around price call efficiency so ensuring ancillary data is not too deep in the packet so we don't have to parse through a whole bunch of other layer four"
  },
  {
    "startTime": "00:38:00",
    "text": "headers for example although three headers in the packet before we hit the ancillary data whether processing impacts the immediate forwarding operation or is or if mis-ordering is allowed so we had a lot of discussion on in the design team on fast path versus slow path processing what this really means um and i know that there's other working groups in in the itf that kind of grappling with this at the moment i've been in a few meetings this week so um we were trying to come up with a some sort of text here that that described this in a without going into the detail of the internals of the implementation and what we were really trying to achieve here the scope of the ancillary data so it could be maybe control or maintenance related or it may be related to the user traffic itself if that's relevant to the action on the packet in the network there's also a couple of requirements related to security and we kind of recognize that we're going to need to at some point do some security work in this area uh to get us through the security area that's one one thing um so and we identified a couple at this stage and again this is requirements on the kind of protocol design work that we need to do this is not saying that everybody has to implement this so the solution is intended it is needed a solution is needed to verify the authenticity of ancillary data so if i get some ancillary considerate data do i know it's where it came from is it authentic do i trust it um and the design shouldn't expose or must not expose confidential information in to the underlying network so it's basically maintaining the confidentiality of users traffic to the underlying network next slide so we've we've reviewed several versions of this draft uh really line by line in the own pillow second design team"
  },
  {
    "startTime": "00:40:01",
    "text": "um we know it needs a bit more editorial cleanup there's i when going through i suppose a couple of duplicate requirements um there's also an additional set of comments received on version two um which we need to address so we think they're fairly straightforward and once we've done this i think the authors believe the draft is quite mature now it's been around for several months and through um three it would have been through four reversions by that point um it's mature and ready for the mpls working group adoption okay i think so you're first i think katan you have a question a question about the in-stack data do the requirements have is there something in the requirement about uh limiting it to a single label uh to to kind of uh you know put a stick bound on how much can be carried in stack and probably more carried at the bottom of the stack in the open design team we've tried to make the you see the the question is how much is too much in the label stack so the requirements draft as it stands is very much around saying well it mustn't be too big and it must be efficient to process we don't have a requirement says specifically how big that is like i i i understand your point and i've you know we have discussed to discuss this um to you know an extensive degree hi um i'm going to see oh fix the echo great so um"
  },
  {
    "startTime": "00:42:00",
    "text": "in the fai document we do have a couple of comments along these lines so one is typically we want four octets per flag there's one flag that has two bits and so that can go go up to eight octets the other thing that we've said about insect data is it um there needs to be um and i don't know how you finally implement this maybe by having an expert team or expert commentary in you know when you do the allocation in ayana there has to be some sense of why this is so urgent that it needs to be in stack versus post stack so i think that's kind of so those two things are what has been guiding us so far in terms of what we put in stack and how much we put in stack there is this whole other thing about if you want to go post stack can you actually reach it and can you do something useful with it and matthew mentioned a little bit but i think we could say more more about that so for example if you can't yeah if your hardware either can't process it or it's a lot of overhead to process post stack data i think there needs to be something said about you know is that okay or are the cases where you should drop the packet if you can't actually get there but in terms of in stack that's in the fai document you could generalize this and not had a requirement that around or along the lines of what you were you were mentioning kriti in that sense that we could say um we could provide basically some"
  },
  {
    "startTime": "00:44:00",
    "text": "justification has to be made in us in a solution for putting in stack versus post stack but why do you need it in stack because that has potential you know if it's especially if it's large could have a significant impact on the processing hello so same concern um for a label a stack deep because there are uh some chipset like broadcom widely used by some vendors only three a label stack are supported and i just wonder is it possible to reuse some kind of uh like label bits or ttl or something else for miats or it should be added somewhere as you sit at the bottom or in a stack so kariti last comment i think if matthew wants to pick that up matthew do you want me to answer this or are you going to do it i i mean there are solutions that have that have been proposed that reuse bits within um for example a special purpose label and their solutions are being proposed that have an extra additional flags field which follows a special purpose label so there's both solutions kind of on the table at the moment in the in in the uh open design team but i think that some of this is is kind of been some"
  },
  {
    "startTime": "00:46:01",
    "text": "exactly how we structure this in in the label stack agreed but i think if you pop up a level we're also looking at solutions that say if i'm going past a node that can't process this then um you know how can we avoid going there as opposed to seeing what we can do with a broadcam chip that can only process three labels so i think there's multiple ways of scanning okay indeed there are requirements in the in the like in the requirements draft about being able to whether or not you be able to know that a downstream node can process at that depth yeah and the compressor adi and could process that ancillary data uh jeff and sure a couple of points here to try to make successful number one this functionality should be clearly explained to consumers this technology all of us who built routers we know we would receive rfq from a customer saying i want you to support five labels i need two labels for basic functionality for our scare over carrier right so same type of explanation needs to be provided to people who are going to use this technology otherwise it's absolutely unclear what you need instead out of stack how do you signal it number two uh thanks to segment routine we've built some machinery in igps and bgpls provides information there are different types of msd to provide what support in terms of label imposition there are other extensions to igp that provides what's important things of depth of lookup please define this or ask as an agp to do this work already so it can be signaled to either centralized entity or hadn't to be clear not to impose data that cannot be read"
  },
  {
    "startTime": "00:48:01",
    "text": "or to impose data that cannot be read somewhere in the past and misread the packet queuing you up you're on next uh lower your shoulders i can't hear you i pushed the wrong one i pushed the hand instead of the mic so he can hear me now can you hear me now yes we hear you oh wow okay and please do and youth otherwise i have an echo uh so i would like to start saying that i produce both martial index very close to the deadline that andy and david set up i got the first one in in reasonable time at least a couple of hours before the deadline this one was not before the deadline and i got a new deadline from david but it actually means that it's my report it's no one else actually saw the slice before they were posted so if there are objections or want to make changes you can chime in so next slide please"
  },
  {
    "startTime": "00:50:04",
    "text": "so uh [Music] a little bit talk about framework and architecture documents in my mind and i know that there are different opinions a framework is documented pretty much focus on how an entity interworks with this environment and architecture is a documented focus on how the entity works internally sometimes we put all this in the same document and then we talked about architectural frameworks um you can say that that is the best of two words in the same document and next slide please so we uh matches two and i put this document uh together uh and uh when we posted uh version one we got mostly positive comments and i was a little bit surprised it should be noted that all three of us are very busy and we had very little time to actually work on the framework we managed to make it but when we sat down after actually posting it we knew that there were a lot of work to be done and what i say is that in that situation we actually got the christmas present uh next slide we had other people that actually had been working along the same lines especially john tony and adrian had been thinking around the same issues or issues that has a rather big overlap so they sent us"
  },
  {
    "startTime": "00:52:02",
    "text": "a lot of useful texts that could be incorporated in the in the document on a very high level we are mostly in agreement there are differences in how we want to name things and how uh [Music] actually what we call things we haven't had an example of actually what do we call the indicators i think i have four different proposals here today and we need to kind of converge on that next like this so when we post the doc next version or the next next version of the document i think that we will have a couple of more um courses uh tony has already started to prepare ace version co2 and circulated it to to the other people in on this list where the john and alien want to be caught i don't know today but they have to tell me next like this uh so next steps are that tony will take over holding the pen at least for some time we will post a new version after this site here and that version should be a rather carefully reviewed and both by the open design team as such and in the working groups and we need to converge on most of the terminology"
  },
  {
    "startTime": "00:54:00",
    "text": "issues or if you can it should be clearly documented in the in the framework uh often updates of the next version uh that version he produced at that time would probably be ready for going to working adoption paul next slide or is that the last yeah okay so that's what i have it's not with much yes no but it's i think we are having a good start and we clearly welcome tony adrian and john participate as part of the the auto team questions nope okay thank you your jags your next stop thank you stewart hello everyone i'm going to present the impeller substation header encoding that are defined in our draft on behalf of all our co-authors and next slide please so we have described the abbreviation which which we have used in the presentation as well as in the draft uh in this slide uh next step please so this is i'm just going to talk today um perspective or draft um let's say please so there are many new applications are coming up with the new requirements to carry an additional information in the"
  },
  {
    "startTime": "00:56:00",
    "text": "mpls packet to influence the m plus packet forwarding or for the oem purposes this requires nps packet to carry more uh spl or espl per application and this will increase the mpls stack that size drastically to solve this problem we need a generic framework to build the mpls extension header encoding format that would carry multiple forwarding instructions in the mpls label stack or after the bottom of mpls label stack our draft uh mainly complies with the mean requirements which has been described before so the main objective of this draft is mpls packet should be able to carry two type of forwarding instructions one is the flag based instruction that does not need any anchor data another one is the forwarding instruction that needs science for the data the second one is mpls packet to carry additional data after the bottom of stack and third one is any combination of uh in-stack and mpls mpls bottom of stack forwarding instructions could coexist in the same impedance packet the fourth one is the new solution which we are going to propose is a backward compatibility uh next slide please before diving into the solution i want to let you know that we have done our extensive hardware analysis to come up with a implementable asset friendly and futuristic solution the appearance extension header mainly consists of two parts uh one is the uh mps extension header indicator so this indicates the presence of mpls extension in the packet next one is the mpls extension header format the format in which the mpls extension could be carried in the mpls packet next slide please let us see the different options of mps extension header indicator so option one"
  },
  {
    "startTime": "00:58:01",
    "text": "is to extend the existing uh eli el by repurposing the els tc and ttl feed to indicate the presence of the empire section header option two is to assign a new special purpose label to indicate the presence of the empire succession header and option three is to use user configured label to indicate the presence of the empire's extension header each option has its own advantages and disadvantages we could choose the options based based on our discussion on the ietf working group so here in this uh in this data structure so if you see there are important fees there um the first field is the in stack uh data length field so this is actually a three bit length field um so uh this indicates the in stack uh mpls extension in the order of uh four bytes some of the parser would require the length of the instax mpl extension for the easy parsing the next one is the instax mpls extension header presence indicator this is the bit field that indicates the presence of the stack extension header and next one is the bottom of the stack empire's extension header presence indicating a bit field indicates the presence of the uh boss mpls extension header that the fourth one is the hop by hop boss and pls extension header indicator a bit field indicates the presence of uh boss empire section hunter that needs to be processed by how uh so this is the instax extension header and its data encoding format so here we see the main part is the the stack mpls extension header so this contains the bit flag which the ipa flag which i which we have described before to indicate the uh presence of uh in stack"
  },
  {
    "startTime": "01:00:02",
    "text": "empire section generator and apart from that we have the instant data data length this indicates the instax mpls extension length in the order of four bytes the next one is the uh instax mpls extension format this contains the opcode so instead in stack forwarding instruction or code this is of 8 bit value that defines the forwarding instruction that need to be executed when it receives the packet and next one is in instax data so this is the ancillary data which is required to execute the forwarding instruction so we use the uh uh two bits to uh control this uh stack uh data processing so one is the d bit which is shown in the diagram so that is uh this is the data stacking bit in the case of in-stack forwarding uh instruction uh requires more than 20 bits of answer data then this bit is used to extend extend and carry more more bits of fractional data if this is built to set then this will be the end of the anchor data for the specific uh forwarding instruction the next bit we can use it here is the e-bit which is shown in the diagram is the end-to-end bit so this indicates whether this forwarding instruction has to be processed or by up or end to end if it is hot by hop then this will be set to zero so the r is a reserved one which is which we are not currently using so we're coming to the uh in stack forwarding instruction op code assignment the value one we have reserved it to carry the flag based forwarding instruction in some cases the application does not need any forwarding forward it does not need any uh accelerated data so in those cases they could uh assign a bit um by the uh iona and they could use the subcode and then carry those kind of informations"
  },
  {
    "startTime": "01:02:00",
    "text": "and then value two is uh optionally used to identify the byte offset of the boss data location so this makes it more flexible to encode the bottom of the stack ampere section data anywhere after the bottom of the stack and value 3 to 254 must be assigned by ayana upon the application request so value 255 is used to extend the upgrade range beyond the beyond the upward value 255 this is for extending our design in the future our next link please this is the bottom of the stack mpls extension header encoding format so this contains uh the boss mpls extension indicator so uh this contains the uh this has the boss extension header presence indicator field this must be set to indicate the presence of the boss employer section header after the bottom of the stack and next bit which is used for this purpose is the hop by hop boss extension header indicator this field is to indicate the presence of a boss extension header that requires hobby help processing so this makes it easier for the person to uh to dig into to move to the uh more examine the data which is present after the bottom of the stack on all the hops next one is the boss data format here we are defining a generic framework so that carry so that we could carry multiple forwarding instruction with respect to the boss forwarding instruction so the first enable is a fixed zero zero one zero enable this is used to avoid aliasing with any existing ipv4 v6 etc packets and next level is reserved and next update"
  },
  {
    "startTime": "01:04:00",
    "text": "is the boss forwarding instruction of code so this value will be assigned by inr based on the application request the next update indicates the length of the boss accident data in the order of 4 bytes this boss accelerator could have its own tlv and sub tlps next update is used for boss mpls extension header flags currently two flags has been assigned the one one the one flag is the next next header person's flag this indicates the presence of another boss mpls forwarding extension header and next flag is the hubba hub bit flat so we can encode multiple uh boss state um multiple boss extension forwarding uh so we can by by this flag we can indicate that this pause for the instruction requires a hobbyhop processing next slide please so this is an example of the instax mpls extension header carrying the flag based instructions as we described before opcode1 is resolved to carry this kind of forwarding instruction which does not need any angular data to process the forwarding instruction in the first in the first word the the ipi is set to one indicates the presence of the stack ambiguous certain presence and the instruct length is set to one indicates that stack extraction header length is of one word in the second word the instruct forwarding instruction of code is set to value one uh it indicates a in this it indicates that it carries the f5 flag and in the case of uh ds bit it is set to one that is that means that this is the end of the f5 flags it is carrying"
  },
  {
    "startTime": "01:06:00",
    "text": "um this the e to e bit is set to one so this means that it requires and how buy a processor um can you please move the next line so this is an example in which in stack mpls extension carries more than 20 bits of data in in some cases the application needs to carry more than 20 bits so this is how the the data format looks like so the important thing here is that the third word if you see here so the first bit of the msb should be set to one to prevent the angular data value from aliasing with the existing spls on the legacy routers uh next place please yeah so this is an example of uh mpls packet carrying the boss implies extension header in this example mpls packet is carrying uh two boss forwarding instructions and its corresponding angular data and the uh the values are set as para we described before uh next slide please this shows a sample com packet comparison between the option one uh that is extending the eli yellow as a mpls extension indicator voices option two that is using a new spl as a mpls extension indicator so in this case option one will consume uh maximum uh uh mp stack sorry the ampere stack depth of five while option two will consume uh mpls stack depth of uh seven this is just to show the difference uh next one so as a next step we would uh welcome review comments and feedbacks especially feedback on the"
  },
  {
    "startTime": "01:08:00",
    "text": "mpls extension indicators options um also we would request a mpls working group adoption um before i uh complete uh also uh i want to mention that we have done uh the hardware analysis study on the npr's extension headers and those informations are provided in the appendix for this of this presentation uh people can take a look whenever they want there are some other slides beyond this that i'm seeing on my screen okay all right so if you don't want to talk to that then we'll go to the questions is that how you want to proceed okay so um carrick is first dark side with juniper my question is on flights please if you don't mind going back to slide seven one of the required thank you one of the requirements of the miad is to be able to carry multiple function indicators or multiple indicators in the same packet um if in such a case we have multiple um instructions or indicators um some of them are end to end or so and some of them are hop by half what would the end to end bit indicate is it per i mean i see you have a bit but is it a bit per per header or is it a bit for for each instruction okay so uh it is for each instruction the bit will be set uh for the op let's take an example i have a two up codes up code eight and upload nine right so 8 is assigned to"
  },
  {
    "startTime": "01:10:01",
    "text": "application one uh the if that opcode 8 needs to be processed by hub then the e bit will be set to zero and if the up code 9 needs to be processed end to end then actually ebit will be set to one so the the full header will be repeated for every instruction right uh not the full header full header instance like the the op code and instead data will be repeated for multiple okay the ipr equal to one and the il will not be repeated only the opcode and the instruct data the the in this case right you see that as the second word will be repeated too much lagging system greg can you go to the next slide yes okay uh so um in case uh when um your entropy label indicator is the top of the stack and the node does not support this uh new interpretation of entropy label indicator so their node will pop up the entropy label indicator and the next label element exposing their data so i guess that will really uh cause the packet to be dropped uh yes uh so uh greg actually in our draft section number 10 we said that uh we need uh signaling"
  },
  {
    "startTime": "01:12:00",
    "text": "uh for the compatibility uh for the earlier routers to support this impedance extension header so that will take care of you know like uh make sure that uh the router which is going to pop uh is aware of this uh okay so so basically you require that all nodes in your domain support a new entropy label uh indicator interpretation so you're saying that uh it simplifies their deployment because you reuse the entropy label indicator for miat but then you say that all nodes needs to be updated what's what's the difference comparing this approach with assigning a new uh special purpose label to indicate miad yeah first of all you know like we give it uh three options right and then um we are we will see the advantages of all the three options one of the options uh whatever you are seeing here the entropy uh using entropy label other option is the using the new spl label so the advantage of entropy label is that it is going to carry the entropy uh which is needed for most of the cases and also like the label stack the comparison which i showed you is going to be uh less and so these are the things i know like uh we think it will be helpful if you if you carry uh entropy if you reuse the entropy label so this is one of the option that is it so and other options is the spl and another third option is the user defined label so these are the these are these are the options we are keeping on table and then our ietf server group we can just discuss and choose which one to go with"
  },
  {
    "startTime": "01:14:02",
    "text": "well it's confusing a little bit because because you are listing many options and asking uh the community to choose rather than proposing one specific solution uh can you decide which option you're proposing so i'm saying each and each option has its own advantage and disadvantage right so uh i want the community to know about these options and then they can we can come up with which ones we need to choose pick up needs to decide but okay thank you thank you can we pick up the pace a bit please uh it's how you next uh yeah uh why appreciate also uh put this together but i'd like to raise awareness uh to oscars that we have a published document talking about the different options for the extension header indicator which includes the option of reusing the um entropy label to to do that and also we have several other options also cover this using a special label and the particular your a proposal we prefer to use a single special label and this also we have another uh document to talking about the uh format of the post uh stack data how to encode the extension headers i think this uh um you know this also uh published uh three years ago and we have continued to update it until now it's a version six so i i think uh uh the author uh here is a proposed some kind of new encoding uh method and should uh to at least to mention that document and maybe make some comparisons why"
  },
  {
    "startTime": "01:16:00",
    "text": "i also want to propose a different format and was a difference and was a benefit the pros and cons like something like that she uh from my understanding of this presentation if we want to carry both instant data and the postdoc data do we need to have two uh special purpose label or the two entropy labeled indicators in labor's map no no it's only one that's the reason no like uh we have the bits right so the bpi bits hpi and ipi so these are the bits uh we'll be using it so only one one indicator is an app but in that case the instax data will be put after the entropy label and it is at the bottom of the stack that's right yeah so we have given an example in our draft both in stack and all the stack data okay so that's in case like the msd issue you need to have another stack data block which is not at the bottom stack right are you understanding your question yeah to solve the limitation of the label stack steps on some transient nodes you need to carry another special special purpose label or the entropy label indicator which can be read by the transient nodes in that case we will need two special purpose labels in the label stack entry one for the instant data another one for"
  },
  {
    "startTime": "01:18:00",
    "text": "the post tech data uh no need actually like i said right so the bits are going to explain now like uh whether it has it's just indicated so the bit indicator is saying that i have some data after the one staggers it but the bottom of the stack label does not have to be the uh it can be any label before the bottom stack block yeah it could be any level there okay maybe i'm not sure this can maybe misread by some luxe note the first of only using the first four nibble first enable to pass the existence of the bottom stack uh okay so uh yeah i as i told you right so we are actually we have an option where uh we can say that uh top code uh two we said threads optionally uh we can have uh the offset of the bottom of the stack bottom of the stack and plus a header location too so if you're going to encode more information can we either can we either can we either discuss in the open discussion at the end or take it to the listener okay okay thank you yeah sure so it's uh now bruno i believe yes thank you from orange speaking hopefully you can hear me so the proposal is a proposal to carry a indicator in the existing entropy level next slide please so a recap on the existing entropy label it is defined in rc 6790 it is used for load balancing and into this stack of two levels first is the entropy level indicator"
  },
  {
    "startTime": "01:20:00",
    "text": "aka eli it is a special purpose level s7 and it is followed by the entropy label which is a per flow entropy value what is of interest for for us is that the ttl field of the entropy label is essentially reserved for future use it is defined as being must be zero when sent on ignored when received the next slide please so the proposal is to extend the detail field of the entropy label and to redefine it as the entropy level control field that would give us a three eight sorry eight flags or eight indicators and we propose that the semantic of those of those of bits uh be user defined so not uh iron iron standardized in order to maximize uh the reusability of these of this resource of the number of slack so essentially uh that's all it's very straightforward next one in terms of benefits compared to using a new special purpose label first one in my opinion is that we have a faster deployment with incremental benefit this is because most if not all egress existing grass ldr already support yellow so they won't drop the packet they already are signal and they support it and therefore any new ingress ldr may use the feature so may use indicators so if we assume that 25 of ldr support the feature we would be able to use it for 25 percent of the flows mostly the ldr"
  },
  {
    "startTime": "01:22:02",
    "text": "compared to if we use a new if we define a new spl we would only be able to use it for 60 for six percent of the flows because we will need both the ingress and the ingress to support the newer the uspl so this is the main benefit for for deployment second benefit is to minimize the label stack when load balancing is required because you you can add indicators with no additional levels in the stack that's true that you could define a new spl and define for that uspl the ability to advertise a an entropy level or whatever the minor but for a large number of years we would need to send both the eli on the new spl in order to be compatible with both new on old lsr and finally we have a special purpose level on the associated signaling in protocols next slide please so the draft give examples of use case to use indicators so one is a end-to-end absolute loss measurement using alternate marking so you can signal that you want to record encode the slice slice id in the entropy level obviously it's not the limiting number of use cases on tariq as i prefer another one some other ones next one next high speed so next step it's an even individual draft since december 2020 [Music] we have presented it three times there are some discussions in the mps working group and also in the open design team we would welcome more review and"
  },
  {
    "startTime": "01:24:00",
    "text": "comments and we believe that draft is a mature enough to request a call for adoption in cmps working group because it's an extension to an mps document that's all for me greg your turn hi bruno thank you for presentation i just wonder um in your opinion how this uh proposal is uh related to the previous presentation it can use it can be used independently the main goal is to advertise indicators in the packet in the stack now you're free to use indicators to indicate whatever you want in so if you want to to indicate an extension you do so i i mean sure to to get you also it's mostly independence in the way that you can use indicators as a general capability to indicate whatever you want and anyone is free to use indicator to to signal something so not sure if this answer your question because um in my understanding that um so what uh your proposal is uh arguing is that uh only 11 indicators can be used with no ancillary data following uh in stack correct and that seems to be too little and does not really conform well does not conform to the requirements so the proposal"
  },
  {
    "startTime": "01:26:02",
    "text": "can use a set of indicators while fully compatible with entropy level we propose the integrals to be a user definer to maximize reusability if you need more than 8 or 11 indicators it's possible to extend the proposal by putting new levels but if you do that so if specific autonomous systems do that clearly you lose compatibility with existing egress supporting only the entropy level so i i think it's it's fair to to ask the autonomous system a lot of indicators to support the cost of it and allow autonomous systems to to be happy with eight indicators to benefit from the compatibility with the existing uh entropy level but it's a problem it's a personal opinion rakesh you'll go hi so uh thanks bruno uh for the presentation uh i think i just had one uh comment is that um i think bruno draft is um is independent um and it can progress um as a working group document while the jack strap is more about um the asic or hardware friendly encoding and it can have a you know resort that uh different encore the indicators um and eli bit can be one of the indicator options so um it's the the this draft the bruno draft is is independent and it can progress i think one another advantage that should be listed is the backwards compatibility on the existing"
  },
  {
    "startTime": "01:28:01",
    "text": "legacy nodes for the bruno drop so that's also a very strong um advantage for this to uh proceed thanks thank you a very short question greg mentioned some requirements do we really first see that we need more than eight values here i mean outside of boiling the ocean it's a question for me or i i i can't answer for the working group um either for your foreground so i mean eight seems like a reasonable number given the preserved buffers compatibility do we really see breaking point where we need to look forward saying eight is not enough so we need to do something else i agree with you jeff i think eight is enough at least to start with indicators if really if we really need more than eight for a given autonomous system we can extend but i agree with you that we could start with eight thank you so can the other questions go after kariti kariti um you've got i'd like to finish you in ten minutes if we could total and could you please focus on new work rather than work that you've discussed at a previous meeting thank you sorry to cut you off a bit i'm sure um so next slide please so the first thing i want to say is that the draft is functionally stable we're still wrangling bits we're doing a few things like that but we're not actually adding new functionality there was one piece of functionality"
  },
  {
    "startTime": "01:30:01",
    "text": "that we hadn't gone into in any detail which we might come back to which is this whole uh thing about user defined you want me to stand there i can see from here from there um yeah so so um but the reason why we're bringing the draft here um to stuart to your point there are some decisions that we do have to make and ideally that the work group will make that decision so uh that's what i'll get to in this deck um and once we have those decisions or in parallel um adopt the document as a working group document so we've been working on this for over a year now and we've presented a few times we've made some changes and so i think we're fairly mature at this point um there are things we still have to do and i don't think that precludes it becoming a working group document uh we want to write down more about how this works in the presence of um you know in a in a brownfield network um how you deal with backward compatibility and so on um what kind of extensibility we want and how much the exact bit formats as i said you know we're playing with that still ayana allocation details and deployment strategies next slide please so the three key contributions here are that we can use a single spl for multiple purposes and that addresses the problem of running out of spls which is something that we constantly worry about in the mpls working group we use the full label entry which includes the tc and ttl fields and we encode forwarding actions very succinctly and both two and three are for efficiency next"
  },
  {
    "startTime": "01:32:00",
    "text": "so we're going to pose a number of questions for the working group or maybe working groups because there are multiple working groups involved we'll pose it here hopefully we get some sort of direction but of course we will repeat it to the mailing list and and then you know act on it from there our opinions will be noted for each of these questions uh our being the authors oh i should have mentioned we have a new author tony lee has joined the the group and he has contributed already so thank you for that tony so if you know if we do an initial poll here i think that will help in terms of um knowing what the direction this is uh that you know we're taking but of course in the end we have to do it by email and have the larger majority in the group speak next so um this should be an obvious one but is there a value in in-stack data and the only reason i want to bring it up here is that there's a constant undertone um that all miad data should be post stack um we already have an existence proof of you know stuff that is in stack um i just want this to be ratified by the working group so that we can put that particular question to bed um so i give a couple of reasons here why in stack is valuable in stack data reaching the bottom of stack can be expensive or even impossible for some chips and even if it's possible it's more efficient to use in-stack data for stuff that's critical for forwarding so the entropy label is an example a slice indicator whether or not to perform fast readout so we think that it's really important"
  },
  {
    "startTime": "01:34:00",
    "text": "to put things in in the stack as opposed to putting everything after the end of stack so the question for the working group is what do you think about this and can we arrive at some kind of consensus on the guidelines we went into this a little bit during matthew's presentation what do you put in stack when do you put it how big can it be and our opinion is yes we need in-stack data and we have some guidelines in the draft we can expand on those but we'd like the working group to you know give us the go ahead next should we repeat the in stack data in the post-stack data this was thrown out in one of the design team meetings i don't think this is worth it i don't like repeating stuff there's always the chance that you don't you know get it right you don't encode it correctly and then if there's a conflict which one do you take but again i think it would be nice to get feedback from the working group and then you know settle this next um we think that this approach is very efficient and very extensible an action is essentially encoded in a single bit and the position of the bit the bit number says what the action is and the value can be zero or one zero means don't do it there is no associated data ever and one means do it to whatever the action is and whether there's associated data or not and how big it is is something that needs to be put in the iana registry so typically um it's either zero or four octets of associate data the number of flag bits is extensible so there's an extension header that says use another label stack entry for more"
  },
  {
    "startTime": "01:36:00",
    "text": "flags so again there's been questions about how do we encode these things i think we need the working group to step in and say yeah what you guys are doing is wonderful because of course it is um and we do have people who are looking at this from a hardware implementation point of view and you know we have a co-author israel from from broadcom and we have internal um people who write asics and microworld and stuff and they're pretty happy with it but again we'd like the working group or working groups to say yes go ahead with this approach next um the one exception to this flags being one bit is there's a two bit flag for the combination of entropy label and yes um and there's a summary of how this works in the top right uh question i guess is i mean what this gives you is a much much more flexibility in how many bits you have for entropy and how many you have for slice id but is this too clever and this is i think a question for people who want to implement this so um the question to the working group is is it useful to have this flexibility and if it is um we then it is beholding on us to investigate the complexity of the hardware that goes that supports this but there is a value that you know in many cases you only use one lse instead of two if you did one bit per action then you'd always have two llc's and you'd always have very big entropy and very big gifts and maybe that's not the best way of doing things next"
  },
  {
    "startTime": "01:38:02",
    "text": "and i guess this is the last one um can the special purpose label reach the top of stack until now we've been saying because we're reusing the tc and ttl bits we don't want it to reach the top of stack but if we have the right signaling that says i can deal with it if the faa spl or whatever you want to call it reaches the proper stack then i think we we have more flexibility the three sort of choices here here are never let this happen which is kind of what the current document says the second is to allow this to happen and you know if you pop the the the top label which is the forwarding label and send the fai label to the next lsr it has to be able to deal with it or the third is if you don't like that happening push a neutral label on top of stack so for example label zero this is not something we have to decide right away there is some flexibility involved there's also some you know potential for bad things to happen so that's something i think the working group should think through next so um as i said we're doing some you know arm wrestling around some of these bits um you know continuation bits is what we currently have um we have a request to put an explicit length it makes it much easier to know exactly how much to pop the bid positions we might want to play with in terms of put all the things that have no associated data first or put all the things that are really important first or stuff like that again semantically it won't change anything that might make it easy for the hardware um we don't have a detailed iona section"
  },
  {
    "startTime": "01:40:02",
    "text": "we need that especially in the inner section you have to do things like say um what's this length of the data associated with this and does the data come in stack or post stack and then there's a bunch of procedures we have to write down and i think that would be good um so that this is deployable and you know we we look through some of the scenarios that uh could happen if you start using this so uh again we'd like to get the working group feedback on the questions which were in slides five through nine and yeah work group at option um i don't think the working group adoption is contingent on any of this happening and this document as i said is pretty stable but yeah whatever the working groups decide questions appreciate i don't think there's time to do mass replies to these today and i suppose with foresight we would have set up a an electronic survey maybe we should ask the chairs to set up an electronic survey to get some consolidated information for your questions yeah i mean the other thing is we could just send email to the list one per question and so either way a million answers to of text answers so rakesh your first then darren and then we're going to go to crete's second slot uh yeah thanks so um i think you asked for working of adoption for this draft and i just wanted to point out that uh there are also two other solution drops as well and they are also asking for working new production as well so um i i think just to highlight there are multiple drafts requesting the same so probably need some more discussion on that uh and that's all thanks"
  },
  {
    "startTime": "01:42:01",
    "text": "it's not a question for me next that's hopefully my profile yeah it is work it is working um um yeah so i've i just had a comment and maybe this will go to the email list well you can tell me but anyway the item number three you had a set of bits indicating the functionality and that seems good until there's some ancillary data associated with those bits and i understand that it would be implementable in in hardware but what the hardware has to do then is is go from a bit presence to some data that may appear later to another bit being present some data that may appear after that and it needs to bounce around in order to accomplish that um i have a concern with that encoding maybe i don't know if we have time today to discuss it or if we'll go to the list but that's my main comment so as i said we have people who are looking at this from an implementation point of view um and there's an algorithm in in the document about how to process this it is sequential because the presence of an earlier bit being one makes you know moves the data around so if an earlier bit has associated data um let's say there's an entropy label that means the first label stack entry following this would have the entropy label if that bit happens to be zero the first label stack entry would be some other thing so we are well aware of that as i said so far the implementation seems to be straightforward um but yes we we are taking that into account can you now fly can you fly through the next one and then we'll take all of the other questions that people have got for this together with all of the questions uh that people got outstanding for other things as part of the final wrap-up"
  },
  {
    "startTime": "01:44:00",
    "text": "okay yeah so um we a bunch of us got together you can see the authors here to write essentially an iana registry for the first nibble which is the first four bits that follow the label stack which is look for the last label the one with the bottom of stack bit set and then the first nibble after that next slide so um the reason we want to do this is a lot of people were thinking that the first nibble would be similar to ip version number and we can use zero or one but we can't use anything else um what this um document basically says is we've got 16 values we're going to use all 16 except we are not going to use four and six um this is not an ipv version number registry and the reason why four and six are special is because people came up with this uh really bad hack that if it is four or six uh it might be an ip address it turns out to be a really bad hack so this also says here's a requirement and here's a recommendation next slide please so the requirement is if you're not putting an ip packet directly after the label stack so it could be either four or six um then you must use a post stack header this is sort of what rfc 4928 says but we're trying to make it stronger and so it's not just for ethernet just anything that you do whether it's beer whether it's what else you want to do um you should if it is not ipv4 or ipv6 just put a post stack header and we are including you know the control word as a post stack header next slide"
  },
  {
    "startTime": "01:46:01",
    "text": "um the recommendation is if you want to do load balancing do not use this hack that you know if the first nibble is four or six it might be an ipv4 packet it's really broken now if the previous uh recommendation or requirement is used this shouldn't be needed but there's lots of uh implementations out there that do this so if you want good entropy if you want good load balancing use an entropy label use a faster oil label don't use that hack that's pretty much it um i think that's the last slide so um if people have got questions on this we'll take those first and then we'll take general questions and comments on the rest of on the work program as a whole or other presentations so all right again my question is there is some talk about application aware routing and routers would have to peek deep into the packet figure out what application it belongs to maybe i'm not sure if that is possible putting this recommendation the one that you had on the slide uh you should not decode or make any assumption what is the header type uh will not would make it hard for the routers to tell uh what is the application would it what well it would make it hard but but it's the right thing to do um we know that we already have the problem that if it's a an ethernet packet and if if it's an ethernet packet without a control word the first nibble could be four or six or could be other things because there is no that's the part of the oui field in an ethernet address in the mac address so"
  },
  {
    "startTime": "01:48:01",
    "text": "trying to guess that the packet is ip by looking at that first nibble is just not a good idea whether it's doing whether you're doing uh load balancing or or application aware routing so so do i publish a draft on this because we got into terrible trouble where people were doing this uh because um there are some ethernet frames starting to appear that um were sent raw as you can do over pseudowire and they were mimicking ip yep yep i think that's 49.28 let's see um so i would say that um the right way to do that would be to put a postdoc data that says and i'm going to say this please don't shoot me this is a protocol type for the packet or something if you really want to get into application aware routing but just trying to guess randomly whether the packet is ip or not based on one nibble is not a good idea okay okay so we have some pending questions i believe if anyone wants to raise them now lower did you have any particular you wanted to cover in this section [Music] what i wanted to discuss has actually been uh on the in the meeting so yeah i don't know i don't have anything in particular us now and we don't have that much time everyone i cut off earlier i was asked to preserve this time greg you go"
  },
  {
    "startTime": "01:50:03",
    "text": "i read all the proposals and i support uh the working group adoption paul for their proposal that he really presented thank you and then whim or are you then when i think it's important to look at this backward compatibility thing uh i i was trying to chime in when jeff asked a question do we foresee a need that we need eight of these things at the same time when forwarding a packet i also believe that that's not realistic to do when you want to have a very high performance routing right so that's why i i personally supported bruno's draft as a star because it gives us a starting point to get going without probably have the full-blown extensibility that we want but maybe it's enough to actually do the things that are really needed in a network because i was looking back when we did entropy label with kiriti which basically is 10 years ago and even today there is many networks which cannot even deploy it because they have routers that don't support it right so we have to basically balance the solutions against how easy is it to deploy versus the amount of extensibility it gives and i think this is a very important aspect we have to consider because we if you look to what what happened with ipv6 and ipv4 it's incompatible right and we actually still struggle daily with this problem and i think it's a very important aspect we have to take into account when considering the solution"
  },
  {
    "startTime": "01:52:01",
    "text": "that we are going to adopt thanks your your last chance otherwise i'll take you out the queue uh hello um let's go uh why there might be some uh reasons to support instep data here i want us to read some disclaimers about the usb data first i think we are lack of a clear criteria uh to uh to decide what data should be proteins back and what data should be for post banking and also there's evidence that um as darren just mentioned that if we use uh bitmap to indicate the use that they inspect data and also uh use uh including stacked data in some labels that will complicate the password a lot so um um and also um we we can we you know we understand there are already some labels other than indicating forwarding exists lexa entrophy label but that's a history before we have any other means to support those functions um but now uh if we uh start to consider uniform mechanics to do that uh shall we continue to tamper the um label stack uh to make the you know the the stack look um it might be used to look messy and also makes a pasta really complex and also um i think uh um uh okay so so first let's just say this um"
  },
  {
    "startTime": "01:54:02",
    "text": "um uh these issues i said i think uh we should have a clear understanding of that and the detailed analysis to decide whether or not we want to go this path yes karite i think yes thank you i just want to respond to vim and i think there have been some other comments along these lines before that eight is plenty and that's what we said about the special purpose label so 16 is plenty we defined i think at the time 3031 came out we defined three or four of them right now we have in flight five or six requests for special purpose labels before we started this work on the fai um forwarding actions indicator so anytime you put a limit on things you don't want to go overboard you don't want so much processing in the packet that you can't actually forward things anymore at the same time i think we have to plan for extensibility so the fai proposal has in the first lse potentially up to 11 bits that you can use for um a function or action indicators but we might take away some of those it has a second lse that can have up to 30 bits i think we need that we've already we defined extended special purpose labels and we have a few that you know have been allocated um anytime we think that we're you know we we get comfortable um we're gonna find that we've done ourselves an injustice thank you greet you running out of time sorry uh is she next can i quickly respond i said eight as a start i'm not saying this is"
  },
  {
    "startTime": "01:56:01",
    "text": "the end i said eight as a start yeah i think in a requirement it is important to maintain the backward compatibility and the efficiency of the mpr's architecture and now we also want to introduce some flexibility to the mprs forwarding so i think based on some analysis and discussion in the design team we have shown that it is maybe very challenging if we want to make further changes to the label format and to the processing of the label uh pop on label swap so this is really something we need to consider we need to be very careful about any changes to the label stack and i think how you mentioned that there are some analysis about the forwarding efficiency and the performance i think this is also useful if uh for every proposal we can have some hardware analysis analysis provided so that way we can provide it it can be introduced with a backward compatibility and efficiency okay sucks very close to beams right i'm looking from deployability perspective looking at my network i'm running depending where you look three to four generation of different hardware software is practical it takes years to deploy forget about hardware so i really need to start somewhere where i can deploy on today's hardware or actually yesterday's hardware plus software to"
  },
  {
    "startTime": "01:58:00",
    "text": "propagate basic stuff like again how deep can i go what's readable with all the staff had been implemented last year or two right even in open source software if you look at open source routing stuff they all implemented extensions to a gps and bgpls last year so in order to make it deployable we need to start with something that is possibly already at least partially supported otherwise we are talking seven eight years from now the whole upgrade cycle i mean we are atf we are doing running code and we are trying to do something that's implementable right so this is where we should start brief is possible comment please um darren because we're running into overtime yep the really brief comment and i'll bring it up on the list as well is i think with the kirti with your draft i think we have a problem when we go to bottom of stack data and additional control words exist after the bottom of stack i'm interested to see how we solve that problem so i'll bring it up online thanks that far same please be brief uh so i agree with what vim mentioned so i'd like to explore her comment i think uh bruno's draft provides a very good start for the working group uh working we should start it uh for this world eight bit support is it provides uh good enough uh for for uh the initial use cases um and then uh the draft also does not require any extensions meaning extension is that backward compatible so it's uh is in my opinion very good start the other point is that before working group adopt any solution um there has to be more discussion on the framework stuff that lua and team started"
  },
  {
    "startTime": "02:00:00",
    "text": "some other consideration within the working group and this is something for a long run and we should not rush into a one particular solution um at the moment we need a little bit more better to start the work uh in the right direction for the long term please uh jeffrey from training pro um so to add a follow-up on how it's coming down about the in-stack data um so allowing instructed does not mean that we would casually put anything into the stack so i think architecturally we should allow it now and in the future when any proposal comes up to add uh uh specific uh data into the instax for some functionality at that time the working group will decide whether that's a good idea or not for that particular future do i agree with him on jeff um i don't think i said eight is plenty i said i'm saying eight now is better than twenty tomorrow i'm like tomorrow plus all proposals are extensible so we can we can have eight now on 20 tomorrow many networks unless you have lots of money are using uh multiple generations of hardware next time to replace reservoirs across a country or continent or world and so we take credit times to have a new feature supported on many many platforms that example with entropia incredible number of times europe required i think it's fair to say that"
  },
  {
    "startTime": "02:02:00",
    "text": "the atf expands also with ipv6 which was not broadly available before we ran out of ability for address so i think deployability is important in config network have showed the concerns i showed the section from the solution point of view there's no consensus i do not think the working group should adopt several solutions with the same feature and from the implementation point of view there are several analyses on the hardware in the dt you can not convince most of people and cannot show any advantage and benefit i don't think this is a good idea a brief comment i believe that mpls working group should consider adopting draft bruno for a solution that for things that can be tackled with it you know today or sooner and in the in parallel the design team can continue working on the more elaborate framework and the analysis but i think it would not be good to get that proposal adoption on for the draft bruno adoption possible comment kariti and then it really is the end yeah this is really really quick before you take any decisions on draft bruno or the other draft that says reuse the entropy label please attend uh the talk in mpls on you know by steward and tony"
  },
  {
    "startTime": "02:04:01",
    "text": "uh and someone else um on the dangers of reusing or repurposing an existing spl thank you all right well thank you everyone i'm sorry i've cut a few people off um i'll see you in the mpls or i'll see you on the odt meetings so thank you all that's the uh we're close for today [Music] go close this for me or do i need to do something you"
  }
]
