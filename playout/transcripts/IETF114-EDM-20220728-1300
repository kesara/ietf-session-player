[
  {
    "startTime": "00:02:09",
    "text": "all right good morning all right i think we uh we'll get started here now um the the chat already has the edm music going uh so thank you brian for providing that um yeah so welcome to the first in-person meeting of the edm program uh so uh today we're going to talk about mainly one draft but i also wanted to give a quick intro just to what the program is for the people who haven't been on the calls that we've had virtually those have usually been relatively small and focused but it's easier to have these things when we have an actual crowd to meet uh david and i are leading this from the ib side but it is open to participation and input from the whole community um which is how kind of the the current generation of iab technical programs are working in general um so thank you for being here and uh contributing just so um for some background on what the program is as mellow is saying it's very easy to forget what edm stands for since it has such a strong connotation in our minds for other things but it is evolvability deployability and maintainability um so it's been running for like about two years now it is a technical program that we have so our goal is to have good technical discussions work on documents when that's appropriate but also just kind of figure out what are the right things that we should be doing as a community technically on things and the topics here um yeah i also cannot believe this has been two years yeah weird"
  },
  {
    "startTime": "00:04:01",
    "text": "evolvability deployability and maintainability so evolvability um i think is mainly around taking up some of the work that had been done previously in iab around preventing ossification figuring out how do we maintain extensibility that's related to one of the documents we've previously published deployability is looking at the aspect of how we make sure that we continue to encourage running code and interoperability and other things we can do in the ietf to make that process easier and better and then maintainability is understanding what are the best practices for protocol maintenance and how protocols are going to live on after we finish their rfcs and the working groups so we're trying to understand like what's the life cycle to make sure that our things are actually working so as far as you know what have we done we did publish rc 9170 which was the use it or lose it draft formally titled the long-term viability of protocol extension mechanisms we've talked more recently about how to associate implementations and try to help people who are working on code get things a bit more involved charles had written a draft of finding code and recently we added some data tracker tags to explicitly call out related implementations i know that was discussed i think at one of the recent working group chairs meetings this week oh sure so i think we need to do more publicity around it i we have talked about it on the working group chairs let's essentially say people try it out i mean the tags in data tracker have essentially related material for a document or a working group those are pretty flexible as it is but we formally defined like a related implementations"
  },
  {
    "startTime": "00:06:00",
    "text": "tag because we've done a survey of the chairs in general and just tried to see you know how are people tracking these things there's a big diversity but having easy ways to if you are coming to the ietf as someone who's just i'm implementing this draft or this i'm working in this group who else is working on this where do i find the hackathon projects if we can start formalizing and saying like hey if you're having great hackathon projects let people know where they are such that if they're reading your document we can tie those together and so that's just like a first step and we want to see with that it's not really an experiment but like what can we do to use that and see how it goes in working group so i encourage people to use it and i think it's a call that we should uh make that more widely known sorry another quick question is that just on drafts or also on rfcs um i think it would work yeah it should be both yeah and you could also have it on a working group main page too to say like you know tls could just say here are here's my page where i list all the current tls main libraries that you can play with yeah and just uh in case you go to try to use this one of the things i i didn't realize was uh as much of an issue perhaps limitation on it or no restriction um if it's an individual draft the the person submitting the draft can go on if it's already a working group draft or an rfc uh the working group chair of the group that that is in or came out it has to do it right yeah which is i'm just kind of the nature of how data tracker stuff works like i know i have requested some chairs to say like hey can you please add this tag for something i'm working on so that people can know how to find it um so maybe that's something that we can also improve the process on yes uh started using it in two working groups since charles talked about it the working group chairs lunch one of the groups that i sent it to they"
  },
  {
    "startTime": "00:08:00",
    "text": "actually had problems figuring out the fact that you could actually have multiple entries there which is documented on there so i help them with that but the part about how to add the label tag in parentheses is not documented or whatever so we just need to advertise that part more because i had problems with that but i'm now using it it works great great yeah and i think like when i had emailed out i was like here's the different ways you could do it but maybe that's a feedback we can take to the tools team of like it should be easier to like have a form of just like add this type of tag with this label add that tag with that label um yeah um paul hawking again so i propose this is not just something for working group chairs i mean this sounds great i haven't been wearing a blue dot in the last few years so i didn't know about it um if y'all once once you've done like once you feel like the documentation's writing stuff if you could send a message to you know ietf at saying this exists and such like that i think a bunch more people will bug their work and group chairs yes to do it yup thank you so yeah i mean thank you for doing that so like i think as we get some feedback from the chairs initially then we can say all right here's how here's some examples of how people are using it if you want to use it in your working group bug your chairs yeah great all right and then for the remainder of the session discussion today one of the other things we've been working on now on the maintenance side of the edm uh trifecta is a draft that had been adopted by the iab previously quite a while ago draft ib protocol maintenance and this is something that has evolved uh martin was the original author david uh took up co-editing it um as a current iab member and we've had uh quite a bit of discussion on architecture discuss about some of the details here so"
  },
  {
    "startTime": "00:10:01",
    "text": "in general when we've discussed this on the ib you know it's something that you know we would like to move forward um you know we acknowledge that is not ever going to be something that is perfect and everyone's going to have complete consensus on but we would like to get progress on it and this is a good group i think to give some feedback on what are some of the refinements we can make before publishing so with that david do you yeah github or anything uh that's a good point i didn't make any slides we'll see if we maybe present bits of the draft um so thanks tommy for the summary that was good we we got some pretty spirited discussion on the uh architecture discuss list uh fun times and we decided oh well let's let's chat in person things always work out better when we're face to face uh even if virtually so what i was thinking is um maybe starting with like the definition of the robustness principle that we chose to use in this document because it became clear that those words didn't mean the exact same thing for everyone and we had to pick one uh we picked the one that was like the oldest star of c we could find um a sensible option i i can totally see that there are other interpretations but just to set the stage um when the so the the overall message of the document is um we had the robustness principle which said uh you know follow the spec but you're you're gonna find something a condition that's like not clear in the spec uh because it's not possible to make a perfect spec otherwise we wouldn't have job security um and when you do how do you react to that"
  },
  {
    "startTime": "00:12:02",
    "text": "and the leading idea in the 90s was you are liberal in what you get meaning you take this erroneous input and [Music] you make do you do not error and that's that's like in rc 1958 the message there um no not 58 right oh yes 58 okay thanks and and specifically i think the text we quote is like you know allow what you accept unless the spec tells you otherwise but the default is don't error just exactly this is for cases when you don't have the spec yeah yeah let me finish my quick intro and then dave it's your your first step and then so the message in in this document is uh the world has changed quite a bit since the 90s and what worked really well then and what actually got the internet up and running isn't neces necessarily the best advice that we can give today and the document goes into some detail of what problems can arise if you follow this to the pretty to its logical conclusion and proposes alternatives specifically protocol maintenance when you have the ability to evolve specs over time and evolve implementations and their deployment of such implementations over time so the document has come a long way in terms of overly focusing on the negative at first we still have a ways to go we have a pr that wants to improve this but it's kind of the idea is the robustness principle is no longer the best thing we have we have something else that is protocol maintenance so now i'm opening the floor dave okay so first let me prefix my comments by saying uh i think that's a a bunch of good stuff in there that i actually agree with okay and so the core technical the core point that you're trying to make in the draft right i'm in agreement with okay i do have to admit"
  },
  {
    "startTime": "00:14:02",
    "text": "that when i read the draft i had a fairly strong negative reaction to the tone and i'll explain why even though i agreed with the technical points and it gets to that same point about the robustness principle meaning different things okay uh that there's at least four different things that you can think of or that i can think of anyway when you say be conservative on what you say and liberal what you accept or whatever three of which are good things and one of which is a bad thing okay and right now it comes across as saying the robustness principle itself is bad and therefore all four are bad and hence the strong negative reactions about the other three that are good things okay and the things you're pointing about are bad things i agree with right uh but the title and the tone come across as throwing the baby out with bath water which if you're not an english idiom person that means you find one bad thing and you assume that the whole thing is bad and so my list of four things um it comes down to uh depending on how you interpret it the quote from 760 which i agree is bad right that's the one that talks about uh the the bad aspect of the four that says when bugs come in you should be liberal in accepting those bugs or whatever which is the whole point of the spec right got that one okay that rfc is obsolete so some people would argue that that interpretation of the robustness principle is also obsolete 1958 on the other hand which is quoted says at least in my reading the exact opposite okay it says if you see something that doesn't look right you silently drop it it does not say to accept it okay it says to drop it okay that's one of the good things okay so the good things are um if there are errors like a bug or whatever that you don't crash okay that's one definition of robustness is that you stay up and running in the presence of errors right you don't crash okay so one definition of robustus principle is don't crash when you see unexpected input okay third one is robustness to attacks okay someone's actually trying to attack you and intentionally sending you things that violate the spec you should be robust to that too okay so that's also both of the number two and number three i claim are purely"
  },
  {
    "startTime": "00:16:01",
    "text": "uh valid in the interpretation of what 1958 says in other words in 1958 and 760 i see as being almost opposite definitions of the roughness principle in terms of if you accept and try to treat as valid errors versus if you treat as invalid errors and then continue on operation without uh detrimental effects right both of those are interpretations of robustness principle okay i claim that the invalid one is the obsoleted one in 760 and the correct one is the 1958 not obsoleted one okay that's why my negative reaction even though i agree with the points about 760s interpretation the last definition of the robustus prince would be robustness to variations in maize and shoulds right just because you do a particular variation of amazing shows you still have to be robust to the other guy according to the spec right the spec a well-written spec actually is written that way to allow you to interoperate with people that make a different set of choices you can argue that that's also liberal and what you accept in the sense of a different variation within this spec all four of those are ways of interpreting be conservative what you send in liberty and what you accept only the first one is the harmful one okay so that's why i have a problem with the title and the tone even though i agree with the content about that first interpretation being bad and all the good things that are in there are great stuff to have in there so i personally would rather frame the document about you know the correct application the resonance principle define it so there's these four different interpretations three of them are good and here's how to apply them and this one is bad and here's how to do stuff instead so that's what i would like to see the document become and then i would very much support it so thanks dave um yeah i'm seeing a lot of reactions coming to the queue uh or people who just want to make comments that's great so i think everyone in this room can agree that if you get input that you consider as faulty you shouldn't crash i think everyone's on that same page right also it doesn't say that right now it says the robustness principle is harmful a lot of you saying you can take that with this that's true i personally don't see that as necessarily"
  },
  {
    "startTime": "00:18:01",
    "text": "the robust principle it feels like common sense but it's also that like it's been done for so long that you know i i assumed it as a you know one of the laws of physics but maybe yeah calling it the part of the robustness principle makes sense and then same for reacting to attacks everyone's in agreement don't let attackers beat you on the other uh on the the point and i think that's the one where maybe we we disagree on this one is if you get faulty input and it's not clear what the spec tells you to do um your options are to you know accept it and like process it fully i think we can all agree that's a bad idea because that was the original one that got obsoleted another option is to discard it silently and the third option is to error and the idea and that's what it's what's very clearly written in 1958 and that's what this document says is harmful and because if you discard it silently you allow the other party to keep going and and to never notice their bug so you end up in a situation where i think this was a point that stewart made and i liked how he phrased it was unlike other sdos the itf doesn't have conformance tests and so kind of the first implementation out there becomes the conformance test and if that implementation errors when you send something bad you're immediately going to fix your code you're not good and so and then we go into detail in the document about this specific thing but silently dropping instead of airing leads to an accumulation of these problems that leads to then people building workarounds and you end up with"
  },
  {
    "startTime": "00:20:03",
    "text": "the the world converging to one of two states if you silently discard you end up with everyone kind of having workarounds for people not doing it for sending them the wrong thing whereas if you have a state of the world where everyone errors you end up in a point where all the implementations are pretty strict and the state of the world matches the specification more closely and that's a point that i i don't think everyone agrees on but that's what we're trying to get across in the document all right and maria i wanted to say the same thing but in just less words than david just said um so about crashing i think crashing is not part of the rashma's principle nobody wants to crash that implementation it's always an implantation bug right so i don't think that's ever on purpose and the difference is really what we're talking about is like silent drop or not silent drop right and i think silent drop and that if that's the only reaction is actually always wrong the minimum you should do is lock the error and you might even decide to like stop the connection and enforce the right behavior and i think that's like always true for any protocol thanks tommy all right uh thanks dave for the the kind of taxonomy of the different types yeah we aren't actually the same person um you have to identify your davids yeah exactly i i think that is definitely helpful um so yeah i agree that you have the the number one of just be liberal and when you accept that one you know obsoleted and not great i definitely agree with like the number three and four of you have to be robust to attacks um and you have to be robust to the maze and shoulds the things that let you have variation um then i think the part i want to dig in on is similar"
  },
  {
    "startTime": "00:22:02",
    "text": "to what david was bringing up about it's like the silent part so like yeah obviously don't crash um but i think you know the silent dropping is probably not the ideal state we're in it can point to a problem in specifications that you know specification really should have you send an explicit error if the other side's doing something wrong of course specifications will have issues and problems and they will miss things that they will have places where they don't tell you to do it um then one of the other things at least when we look at what we did in use it or lose it and talk about extensibility we also talk about how you want to be very clear for what are your variation points and your sensibility points um so in those cases you know i think we could also we we could have an approach where you say the implementations implementations if they see something that they have no idea how to parse should kind of just go to an error state because a specification if it intended to have an extensibility point that you're going to have variation on this in it's on the specification to be very clear about what is my extension point and so then you have to allow that through and so hey i see a new uh packet type come in that i don't recognize okay i'm not going to error on that now part of this also i think matters on how uh reliable or authenticated the channel is here um because if we're trying to make this work with the attackers like if i if this is about high process incoming ip packets that anyone can inject to me you know obviously if there's something bad on that like i shouldn't just like reset i i shouldn't do really abortive things if someone just injected one kind of packet of death to try to make me do bad things to appear um if that for some reason like i can't authenticate it you inject a uv packet"
  },
  {
    "startTime": "00:24:01",
    "text": "to me and now i close down all my quick connections like that would be a bad state to be in but if i do have an authenticated channel to someone so i essentially know i'm i am talking to someone on the other side who i believe you know is compliant with this protocol if they start sending me garbage on something that is not an extension point and like i cannot parse it probably is best for me to close that connection or have some sort of error and ideally the specification tells me to do that but if there's some weird edge case that it did not explicitly say oh if these bits aren't correct and you can't parse this and the you're gonna have a buffer overflow if you try to go beyond this when you're parsing the stream you should probably close the stream rather than just like silently dropping packets forever so that's i think maybe where some of this document is trying to get at and i don't know how we name that aspect of it such that we say hey this one little bit in here is the part that we think uh needs more thought when you're developing the protocol as well as writing your implementation and trying to have like a default state for handling garbage input thanks tommy i see brian in the virtual cue good to see you brian i'll see if you can see me hello um good morning everyone um so i i was a little bit struck by uh dave thaler's sort of uh thank you very much for you know starting off with the uh sort of the taxonomy of different things we can do in the history of this we're we're talking about um some changes that were made to the interpretation the robustness principle in a three-digit rfc that were made in a 40-rfc whose first digit is one right so we're talking about sort of like discussions that happened still 25-30 years ago what struck me about why this document exists and something that i want to talk a little bit more about in this discussion"
  },
  {
    "startTime": "00:26:00",
    "text": "is that the way that the protocol development and deployment life cycle works in the world has changed since that point in time and pointedly things that might make sense in one phase of the point of the of a protocol's development deployment life cycle don't make sense sorry brian you you cut out just uh you said point at things that might and then it paused maybe turn off your video okay um is this better it is two three four five six uh crap i don't remember what i said in had i haven't talked about protocol life cycles yet yes protocol life cycles have changed for deployment protocol life cycles have changed and pointedly one of the big things that has changed is that sort of the development you know early development and deployment and maturity life cycles and a lot of cases in many deployments are going to overlap as opposed to being distinct phases of the protocol life cycle so when we say you know when i originally put myself in the queue because it's like i think we can all agree someone said i think we can all agree that you shouldn't crash well maybe at early in the protocol life cycle if you're basically doing early interrupt may be the right thing to do if you get into a an error state because the other side has sent you garbage is drop the connection right like that might actually in that point in the deployment or if you're in an environment where you actually can do can do quick restart that might be the right thing to do so so it might make sense to approach the differences in what we think the appropriate behavior are in terms of where we are in the protocol life cycle and acknowledge that the reason that this document exists now and if published will have a first digit of nine as opposed to a first digit of one is because that has changed um in a lot of deployments in the world thank you very much"
  },
  {
    "startTime": "00:28:00",
    "text": "okay thank you brian and next is stuart thank you uh stuart cheshire from apple um i agree 100 with what dave thaler said um dave is always great at seeing a broader perspective and spotting our unconscious assumptions and i think this is a great example of that that i mean i love the taxonomy and i think they should be spelled out in the document because one of the first lessons i learned on my first job was if your code crashes it's your fault you don't point at the packet trace and say well they sent the wrong packet um i've internalized this but other people reading the document might not have learned that lesson so yes i think it would be great to spell out um you said something else that's probably obvious to everybody in this room when we're talking about being less liberal with what you accept if the protocol specifies a documented extension mechanism like there's a tlv that goes here you shouldn't drop the connection because there's a tlv there that's not the kind of conservatism we mean we're talking about being stricter about pro about specification violations we're not talking about being strict in the sense that i don't support the optional stuff and i'll throw a tantrum if somebody else tries to use it um all this is kind of obvious but but that's what you're great at dave is spotting the things that the people in this room uh are taking for granted and a document like this is supposed to be educational for the whole industry so thank you for pointing that out i'll give one example from one of the things i worked on recently dns stateful operations we had a debate there and i tried to be really strict everywhere in the document where it has a must it says uh this field must not be zero if this flag is set"
  },
  {
    "startTime": "00:30:00",
    "text": "well anytime you have a must what goes the other side of that coin is yeah but what if that's violated so you're telling the sender you must do this we also have to tell the receiver and if the sender doesn't what do you do and in almost all cases we stated specifically um sender must not do this and if it does the receiver must abort the tcp connection immediately now we could have said silently ignore that one message and continue processing the subsequent messages on the connection that would be also been a valid answer and i didn't particularly care which we did but i did care that we specified clearly in the document what you're supposed to do rather than leaving it ambiguous thank you stuart back to dave sorry i was typing because i completely agree with you and would love that point to be made in the in the in the in the document um and i saw um i think antoine or whatever made a comment in chat that gets to someone like why i put myself back in the queue i think one of the good parts of the draft meaning that the main point of the draft or whatever is to is uh david's point about uh sending errors rather than silently accepting things i think one of the reasons so if you get strong negative reactions on things then it's then i've found that in my experience often that as somebody believes that it's being over applied to a particular case that they can think of okay so it makes me question whether it needs an often or a conditional mosque or something like that so if i see strong negative reactions on stuff i say okay am i over applying this somehow and i do i need to constrain is there some other case you need to call out and i think it's the job of a good ieb spec to actually call out those considerations when those tussles are those things that occur that says well it's there most of the time but this other case maybe it's not you have to admit that whatever so i found usually when i've seen stronger reactions it's because somebody they think that the statement is being over applied i think that might be the case here um because i agree with the point that"
  },
  {
    "startTime": "00:32:01",
    "text": "david made right that says if i've got a channel with somebody and they're sending a malformed packet at me then i should abort the connection center or whatever rather than silently accept it okay i said this stuff the main point of the document i actually agree with right so don't get me wrong um but there's some misapplication of that that says if i don't already have a channel with somebody okay and i have a denial of denial of service attack for example then in that case it's often better to drop stuff rather than try to send an error which can lead itself to a denial of zero's attack right if i send error messages especially if it's an amplification with error messages larger than the original one so think of it as a tiny sin and a large thing or whatever so there are cases where silently dropping is actually better than sending an error and it has to do with this do i already have a channel with them okay if so it's better to send an error message clearly right at least i can't think of a counter example meaning and that was the example you used which i said yeah plus 1 plus 100 right but there's also cases that you can misapply it to say okay you should send an error case in all cases and therefore open yourselves or the world to distribute denial of service attacks that would be the over application and that's where i think you get some negative reactions right and so whenever you see negative reactions look for okay what's the corner case that somebody has in mind and how do i change the statement to actually admit that there's a consideration it's not a 100 case whether it's an often or in the following cases or whatever and so i actually agree with antoine and i agree with the way that you phrased it david and just making sure the document covers both of those that's what i think is a job of a good iev document is to talk about both sides and when different things are applicable because otherwise the community gets into these fights in every single working group and so the iab's job is to write them down once in a way that we think we can agree with to kind of preempt these debates inside working groups or at least give them by the way here's the way to navigate that if you're a working group chair for the people that haven't heard the documents so that's why i think that there's actually a really good thing that the iep document could do here if it covers these various considerations while retaining the main point of the document here i just think there's other things that should be put in there and the title should be changed to actually broaden the applicability of the principles that are in here so thanks"
  },
  {
    "startTime": "00:34:02",
    "text": "thanks dave for like so clearly laying out all these things no this is super helpful uh wes is next uh thank you tommy for giving up your seat so i don't disagree that better guidance is needed for implementers right i think everybody in the room probably thinks it's time for a document like this and um and to specification authors in particular too right avoid holes that's that's also i think fairly clear right try and cover all the cases but this document's for when that doesn't happen i think the goal of any modern document though should be to inform the readers of their complete set of choices and and this document's not written that way as i said on the mailing list right it should be twice as long because right now it's written to attack one viewpoint and it's written by sort of one corner of the market too right as brian said a second ago protocol life titles had life cycles have changed i'm not sure that's true right if you look at cpe vendors and router vendors and switch vendors and stuff they have struggled to get any deployed equipment to be updated right especially in-home stuff it just doesn't happen so the market space there has a completely different viewpoint from http you know implementers that are changing their code every nine months or every three months excuse me and the other big thing is that closing a connection on garbage may result in some devices as taking the entire network down if you you know if you in your process of using say netcom for something to configure a router take down an interface get garbage and then shut the connection down you've just taken down a network behind it right so you need those rollback and other sorts of mechanisms the other you know important quickly jump in on that one you made a really great point there and when when you made it we we did uh and martin wrote a section specifically because we realized again like dave was saying that there was an enormous yes and the new section is great but the new section just"
  },
  {
    "startTime": "00:36:00",
    "text": "specifies this document only applies under these circumstances as opposed to helping all sides and writing the other half of the document that helps you know so i totally agree with the clarifying the uh i'm sorry i'm jumping in it's one of the costs that's all right uh the the caveats and the assumptions that we've made that were perhaps implicit um i do agree with you that for the other side of like in those cases this doesn't what do they do i think writing a document there could be useful i'm not volunteering to write all that text and i don't think we should block writing something on this half until the other half is written because that's probably a lot of text and i don't think we need to put them both in the same document that'll be putting quite a burden on us editors and so going back to my original statement the right thing to do for implementers is to have the completely documented set of choices no matter how hard it is i agree as i mentioned in mail right it should be twice as long in order to inc to incorporate all these because there are times you really want to accept data and be flexible and there are times you need to abort the connection there are times you need to log the error as myria said right but then accept more after that it's hard to write that generically in the first place i mean even the corner cases we're talking sort of about two extremes what about the middle grounds where in the end you know you actually need to give guidance to the user on what the different situations are because even in one protocol you may want to do one extreme thing in one case and another more flexible thing and another depending on what the ramifications of that decision are right so writing the document in such a way that it started off with in the original version this is bad it's just going to set a negative tone right as mallory pointed out that title still you know has remnants of that original discussion even though the rest of the document i agree you know has"
  },
  {
    "startTime": "00:38:00",
    "text": "gotten better but you know for me if if i was going to want to approve this i'd want to make sure that the document had the best advice like iab normally gives to the entire community not just a section and not just against one particular past implementation thanks uh empty no we tended together that's hilarious thank you for that philosophical insight so um i'm going to partly disagree with dave but also agree with him i think this is this this is important because you um you identified four things i think there's only really three that we're talking about here the the maze insurance and whatnot uh the bounds of the protocol that that uh entities interacting with that protocol uh are confined by and the the robustness principle does i think apply in those cases where someone steps outside those bounds that's really what we're talking about i don't think that that there is a and anytime there's a may in a protocol specification that's a must for everyone else so um i don't think that's that's really a distinct piece in this taxonomy so i want to just sort of exclude that to start with um you're frowning feel free to so so when i say if i may send you must be prepared to receive type thing but it's not always true not every bay in a document is about may send you said every may is a must for somebody else and that's where you lost them oh okay so um"
  },
  {
    "startTime": "00:40:00",
    "text": "yeah there's a lot more to it than that i just want to sort of set that aside but i think the the point about not crashing uh not exposing yourself to security issues is something that we've sort of allied to the detriment of the document uh and and it's that's something that we need to need to address full-on um the the whole thing about silent drop and whatever else is i think a little bit of a distraction here to to some extent i think the um that the goal of the document is to say when you end up when when you end up in these situations don't do the one thing that is specified in 1958 or worse the its predecessors it's find some way to have the entire protocol ecosystem agree on what the outcome is and then write that down and it says that a number of times um it probably needs to be sharpened something about sharp implements for sharp people um but um i i think that's that's probably the part that i continue to struggle with when i hear comments like where's i just can't i need i i need help in identifying where where's is getting these misconceptions because it's not what i'm trying to write down and i i didn't think that it ever said anything about um the the bgp case that's that's been talked about right so you receive garbage that's been forwarded on to you from someone else and somewhere else in the network and you have to deal with the consequences of that and you don't want to bring the entire network down it's only one misbehaving entity somewhere"
  },
  {
    "startTime": "00:42:02",
    "text": "remote that that's causing this problem um thing is that has been documented by that community and it's well specified now and the behavior is fairly consistent amongst well at least amongst updated implementations so um i think there was um one other point about update life cycles this may be a point of philosophical contention but it is my assertion that if you're on the internet and you don't have some means to react to changes in your environment or it is a hostile environment if you don't have some sort of immune system and ability to evolve then eventually bad things will happen probably to you sometimes to to bystanders and whether we like it or not in those situations where where people are unable to to update their devices they're causing harm to themselves and and and others uh it's not a desirable situation to be in even though i recognize that i i've got a router that hasn't been getting security updates myself something have to deal with max martin rob and just as a time check we want to give room for people to get to the 10 o'clock so if i close the queue we'll just try to go a little bit choppy we have brian the cue to have the audio choppy that's good so just a few constant things so broadly i think this document's a good document i think it's a good idea it's heading in the right direction i think it's useful for us to be publishing something in this area um i do i do feel though trying to spin it a bit more in a positive way and make it less confrontational i think that would help the community so i think that's worth taking the feedback that's come in and trying to twist it slightly"
  },
  {
    "startTime": "00:44:00",
    "text": "and it's also clear to me i think that some folks in the community are worried that this is going to be used as a tool to bash them on and say your protocol is wrong blah blah blah and so we need to make sure that that's not the case and that's where i have a lot of simply with his argument of trying to make this very balanced on the two sides and maybe we have you know javascript for good parts maybe the robustness principle the good parts would be helpful of having that sort of thing and certainly where there's confusion about our different interpretations of the robustness principle and i think some people think of it as an extensibility extensibility mechanism and i don't think that's what it's about at all then i think actually why don't we write down what we mean rather than just re-quoting the historical robustness principle why don't we actually restate and say these are the things that we think are good and worth using these are the things that we think don't work so well um i agree on the on sort of defining extension points in protocols rather than just assuming oh let's let's just sort of constrain what you're allowed to do and anything outside that's just accepted and allowed so so i think this is i think we want i would like to see something published in this area from iob and i think having a bit more balanced view would be good and a little bit less confrontational thanks thanks and and to be clear we we are as editors we agree when we're working on that um the the documents started off as confrontational to start to get people excited and to start a discussion and it worked um and it might take we want there to be a little bit of a kind of a catchy start to get people to read it because you know most day like ebby documents don't get read but we need to soften it even more because absolutely our goal isn't to piss anyone off our goal is to get people to go oh there are many better approaches uh so totally agree yeah just one quick comment when this gets published this will get read and quoted a lot well that that would be great all right paul um so i want to reset here because"
  },
  {
    "startTime": "00:46:02",
    "text": "i'm really concerned with where the beginning of the conversation went which was we should be emphasizing sending error responses more um well but people have been saying that's what we should be you know emphasizing the not dropping but sending back error error responses and i i have a concern because somebody who sent you a message thought it was reasonable a reasonable message to send so they aren't really expecting an error response even though it's in the protocol they probably could accept it that doesn't mean they're going to understand it one thing we've certainly seen in some of the older protocols like dns is that once people start to under you know like like the error messages we're supposed to tell you this and this but more and more creative errors get the same error response and therefore the error responses over time become less and less useful um and so pretty much and even quite frankly in hdp the error responses are limited and therefore the people who are receiving them aren't necessarily able to act on them in the way that we want in this document namely to have people not sending things that cause errors um so i think that a thing that could be brought up in the send back errors or thing in in the section in the document is that errors themselves should be extensible that is um as new in the same way we have extensibility points usually for adding things to the protocol errors should be extensible as well as a way of making it you know and quite frankly i think private use error messages are a great thing i know this is like i get beaten"
  },
  {
    "startTime": "00:48:00",
    "text": "up on this a bunch but it allows greater flexibility for the receiver to say i got an error and it doesn't fit into exactly what the protocol authors thought thanks and honestly i agree with everything you just said uh deborah deborah are you there okay we hear you there is a delay um as i've said on the list the tone of the document by making a blatant statement that the postal right is harmful i think it's just overboard and you're and that is why you're not able to get your message across there's there's no you know buddy against having advice on how to do better protocol development but you're to put that interpretation into postal it's totally incorrect it's not what postal has been saying and as you've already like been saying here every protocol is different and you may not want to put 100 pages in your document but then you have to tone it down that this is not applicable for for every protocol and what you really want is that people are rigorous"
  },
  {
    "startTime": "00:50:00",
    "text": "in the specification writing so but i i there's been a huge mixture and the audio is bad and i think there's a huge um lack of understanding that everybody uses terms differently for example protocol deployment is that demo code is it in a production network for maintenance are you talking about bug fixes are you talking about upgrades major there's a huge difference in operational reality so that's but it would really help if the tone of the document was not this negativity on po on postal and that that i would really is concerned about thank you debra um so just to clarify one thing uh pastel's name does not appear in the document apart from in the references section as one as the author on rfc 760. uh so we're we're not saying anything about i know though a very early version of this draft said postal was wrong but we've toned it down we've got for and it's the document is much better now it got that flashy thing that got people to the table but yeah um and so i i see what you're saying yeah go ahead you still have that it's the robustness principle and that we all know it's postal you can go to the internet society's website the description of the postal award cites the robustness principle i would love to see if you publish this"
  },
  {
    "startTime": "00:52:00",
    "text": "document that his principle is harmful go to the internet society and have them change their web page okay all right thank you okay just for time for time we we do have a couple more people in queue and so i think we should just take like a minute on each person and then wrap up so let's try to get through this all right thanks debra uh dkg grab a mic please for the remote folks switch and press the button big button okay this is daniel kahn gilmore um so this document does two things right it provides guidance to protocol designers and it provides guidance to implementers and the robustness principle is sometimes thought to apply to one and sometimes thought to apply to the other or to both and i actually think it's subtly different and it's important that it's different for the protocol designers and the implementers and we are making a mistake when we apply the the robustness principle to the protocol design because it does have all the deleterious effects for interoperability that the document rightly calls out so what the document actually says to protocol designers is don't leave wiggle room in your protocol be clear about where things should be uh rejected or whatever i'm not going to go into too much detail on the like sending errors back there are a lot of cases where we can't afford to send errors back but i think the document could do a better job of calling out what the robustness principle means for each of these two categories the protocol designers and the implementers right and it should actually say that implementers if you find yourself having to apply the this robustness principle because the spec is ambiguous please help us improve the spec thanks that's great uh miriam yeah that makes my comment very short because i wanted to say the same thing i think like we should this is very clear for protocol um specification we should do exactly what stuart also said earlier"
  },
  {
    "startTime": "00:54:01",
    "text": "and there should be no wiggle room and that's the most important message of this document um and about deployment parts um you know if it's not well specified then there's a question what you do and i disagree with wes that's where i joined the queue um because i don't think i want to want a document that's very long and talks about all the different options i think the message here is also that like silently drop is not always the best option so that's a big message and i actually think iab documents are best when they are short and give like a very clear short statement so i'm i don't think we should like cover the whole space here thanks totally agree tommy go ahead and i'd like to take a minute after you did that that's fine to conclude um i i i got in the queue partly just to provide a comment as i was listening to these things as a suggestion maybe to you know particularly the title and how we phrase the whole thing um i kind of see two possibilities like one is it's too long but like you could call like interpreting the robustness principle in a world of protocol maintenance like essentially saying like when you have protocol maintenance or like maintained protocol deployments here's how to think about the robustness principle and here's how it applies and another way to do it would be because there have been many statements of the robustness principle another thing you could just do is try to restate it to add a bit more nuance to some of these cases or to just make it more clear that i think if you go that direction it gets into the more like now you need to talk about all the different edge cases and so potentially scoping it down would just be about saying here is how you should use the robustness principle in this type of deployment and understand like no it's not as simple as just being liberal thanks all right so first off i want to thank everyone who came over and who participated"
  },
  {
    "startTime": "00:56:00",
    "text": "i am like impressed at how much more productive this was than the on this discussion uh the phrase i heard the most today was i agree with you yes and um and that was great because seriously we got really useful feedback that like sometimes on the list i was like having a hard time understanding what people wanted us to change and now this is like very actionable changes that we can make to this document and so in a way because everyone has been saying like this is useful let's tweak it to publish it not like no no go away so we're gonna take that back we're gonna make those edits and i think we're gonna improve it quite a bit based on this feedback so thank you so much everyone this was a really great conversation thank you have a good thursday you"
  }
]
