[
  {
    "startTime": "00:00:07",
    "text": "good day folks let's see here hi everyone hello getting used to the new interface yeah I wasn't sure I was in the the right place actually definely confused me can you guys hear me y we can hear you Steve okay great we're in the um the customary limonal minutes we'll come through them soon so exciting that Hannis is still listed as a chair can still press buttons and things for us so that to change soon"
  },
  {
    "startTime": "00:02:01",
    "text": "that is convenient all right so what is the new UI here okay so join Q I'm just oh and Hest is here oh I see they have a different ux now for the que yeah it it looks it's it's the same now as um the conference present ation view so you get the little ordered string of the queue in the top Corner rather than in the chat pane nice okay so we're coming up on on time um I'll make my usual appeal for somebody to help with the minutes uh I can jump in if I could find the place where the the minutes are taken hold on who moved the cheese I'll find them notepad for taking notes there we go oh there's a button to press okay yeah you have to press both buttons it's um oh the publish the publish Buton here in the ACT thing yeah exactly"
  },
  {
    "startTime": "00:04:00",
    "text": "I got you they have to be officially put into Data tracker and we didn't we didn't do that so they're they're in hedg do they can be they can be pushed they will be pushed but we have to ask for special permission from um power user that mecho oh is there a time limit if we don't push it in a certain time exactly okay okay so published agenda for for today uh I think I remember but we might as well just find it here so status of working group last call for use cases uh was the first one so and working group last call has passed um we had some some input and some some PRS um I Steve ory you're probably in the best position I don't know anybody else um don't know if AJ's on the call I can't see now um where are we at with the um uh use cases document do you think we clearly didn't think it was in fit state three weeks ago we extended the call Are we more confident now should we assign Shepherds and things you look like you're in que uh yep always in the queue go ahead uh no um at a minimum the working group last call review should be dismissed or approved and merged that's it got"
  },
  {
    "startTime": "00:06:00",
    "text": "I'll Echo the same thing we I think we last debated whether we wanted to take it with the idea was frozen but the the we discussed that it can be updated in the future so that kind of unblocked conversations on deferring it so I think it's ready yeah absolutely makes sense those are open so yeah let's let's go with that let's say we're Frozen for substantive stuff that is not currently in the uh in the review queue we'll accept dismiss and tidy up the reviews and then see where it see where it lands that's good it's kind of as expected so more onto the meat of things um there has been quite a bunch of of activity which good um on the um the the regular docs um so be good appreciate again um going to be leaning on the same people a lot especially as Hank's out but um do the editors want to give a an update on on where we've got two most important open issues and PRS sorry trying to multitask multiple monitors here or multiple STS um so we've been merging a bunch uh as of recent we've been cleaning up uh remnants from the uh 118 meeting so that includes the reg info um cleaning that up consolidating on the claims header um there's a couple of more clear around"
  },
  {
    "startTime": "00:08:01",
    "text": "web we need to complete um I saw Hanks had a reshuffling I was going to validate through that this morning yeah that one looked I think there was some markdown format breaking or something like the tool breaking with the one piece so I was just going to fix that up today uh generally speaking I think we're in pretty good shape we we need to triage the list of issues because there's we've gotten them down to 18 from like 40 or so um so we've been triaging those through and working through um the any elements that are open and left for cleanup with the goal to be in a good state for adoption in 119 yeah yeah and I think that is um as far as I'm understanding you there's um again people can and should uh look at the GitHub if they want to see what's going on but um we've got good participation on the reviews from people like yoges and AJ as well um who are on this call so I'll just reflect their their participation here so there is decent movement with a broad set of eyes and I think what we're aiming to do is to um improve through simplification so so that consolidation on one header and and things like that is all um is all great great work from my point of view and as long as it's giving people what they need in functionality terms I think we're uh we're actually making good progress"
  },
  {
    "startTime": "00:10:05",
    "text": "um is it worth uh this is not an invitation to do so if not necessary but is it worth um discussing any of the issues or changes that might be more or less surprising and I think for people who are paying attention at8 nothing will be surprising but things like the claims header um non-mandatory reg info and stuff um is it worth the chat here or should we just do all the in issues on GitHub looking at the list of attendees okay well or in the queue while you while you look at that so ask or so I think um in general we should Reserve like uh interim call time for addressing uh something that's a challenge or problematic um if if there are topics that we want to just sort of elaborate on to create issues or because we feel document is weak then I think that's a good thing to come to the mic to sort of attack that part of the document um since you've sort of kicked that off already I'll say in the poll 139 on the architecture I removed a lot of uh of text from the architecture that I think would would block it from moving forward um and I I did that in preparation for some of that text to move to Scrappy uh where Scrappy could kind of come in like later you know uh and the architecture document could perhaps like be done sooner so that was the intention um there and I'm happy to to argue uh for why that's a good idea if anyone wants to have have that discussion now"
  },
  {
    "startTime": "00:12:00",
    "text": "yeah no certainly not my intention to create issues um yeah much more what you said if there are things that um could do with input to help the next interim bit of work then that that's kind of what I meant like yeah not not looking to excite people who aren't already excited um Steve yeah I mean there's I think so that's two items uh one I think it's a good question of whether we want to remove the scrappy what if let's just call it Scrappy the scrappy from the architecture Doc before the architecture sorry before the scrappy API is updated or because then we're maintaining two documents to be in sync or do we get the architecture doc which has the high level API calls in it and do that on more of a lighter weight editing and then when we're feel solid to then update Scrappy before it get and then submit for adoption so keep it in architecture until it's updated and in sync and you relatively stable then uh transition it over Scrappy where there's more details that was I the direction I thought we were going um no objection to either way just worry about a little bit more work so that's item one item two was the uh other it's completely different topic so I can reserve that for a separate conversation on the where is it now sorry I'm trying to find the doc all right no let's let me find the other one because or I'm not sure where the other one is where you're arguing for um the registration the person that's doing the registration to also be validated so let me save that one since"
  },
  {
    "startTime": "00:14:00",
    "text": "I'm not seeing in the architecture docum I forgot where it is let's just stay focused on Scrappy for a second what how do we want to handle it do we want to just remove it all together and do all the edits in Scrappy before adoption or keep it in the architecture document I'm in the queue but since it's quiet I'll just start talking um the key mining registration PR is in the scrappy uh API it's poll 9 um I don't really understand what you were saying uh before I think um it's good to remove I think it's good to merge 139 immediately I think we've had a lot of discussion on the list and GitHub keeps history forever and I think the working group is not going to be surprised or hurt if the architecture becomes simpler I think actually that will help get additional reviews on the architecture uh so my recommendation would be to merge poll requests um in general if I don't think a PLL request is ready I will mark it as draft or I won't raise it that's it I'm just given room for others to comment whether we want to pull the apis out Al together from ITF before we complete Scrappy"
  },
  {
    "startTime": "00:16:03",
    "text": "um so before we created the scrappy separation we had agreed to move the apis out of the architecture so that's maybe like the historic context for why did we even create Scrappy was specifically to separate it from the architecture so I think anything we do to remove it from the architecture and improve it in its new location is in in keeping with the original intention okay so fastly iterate in the scrappy repo is what you're recommending okay with no other feedback it seems fine great and what was the second thing I'm trying to find this I guess the second one was on Scrappy is what R said looking the strawman yes it is on Scrappy API okay so or we can save that for a separate we can discuss it here or do you want to start bringing Scrappy into this meeting since we're going to shift the conversation there well Scrappy's the next agenda item so um we could we could do that or um or not but it sounds like there are no other nobody else on the call has strong opinions on the on the PRS and stuff going through I think they appear to be going at a good pace so seems like that's all that's all fine course so Arie Flor is yours yeah"
  },
  {
    "startTime": "00:18:00",
    "text": "so I'm cued to sort of uh I guess comment on poll nine in the the Scrappy um rapel so there with cwt claims and headers there comes um special claims that have uh signif significance and meaning and one of the things to consider and actually we discussed this like Way Way Back the beginning when skit was first forming um it's not a Perfect Analogy but um whenever you have JWT or cwt or signers and verifiers issuers and verifiers there's always a question of is this a two-party model or a three-party model scenario so just a quick sort of summary like the two-party model you have an issuer and a verifier the issuer always prepares signed data for the verifier the issuer will identify the verifier using the audience claim uh usually and then the issuer will sign data that's intended to be verified by the verifier so that's two parties right in the three-party model uh the issuer doesn't know who exactly is going to verify what they're signing um and that's an important privacy and security characteristics for some use cases like particularly digital identity credential use cases where you know you don't want the department of a motor vehicle to know every time you try and buy beer at a gas station so um if skit has a a use case for um registering a uh credential that was issued by some original issuer but presented by an integrator uh so you know for example perhaps there is a first issuer who uh"
  },
  {
    "startTime": "00:20:01",
    "text": "signs um a certain kind of firmware and then they issue credentials for that and then later they hand those credentials to a distributor who signs that they've integrated um that software with another package in that second case when that second party registers they can prove that they hold a public key material that the original first issuer was aware of that's called the key binding you know in in oaf terminology um it's making use of this confirmation claim which is a publicly known registered claim name that's relevant to JWT and cwt so in the case where skit would want for the party that's registering to instead of being the original issuer to be a holder of a credential then we would need to be aware of these confirmation claims and their behavior I'm very interested in this use case this is actually our use case um like so you know as I've said before we came to work on things at skit because we care about physical supply chain use cases and we think a lot of the technology that skid is is developing for software Supply chains is relevant to physical supply chain and in physical Supply chains we have these scenarios where you have credentials and they're related to digital twins of products and sometimes the party that's registering a claim making you know assigned statement transparent isn't the original issuer but is instead a holder of a credential that the original issuer had provision to them so we very much like to see Scrappy account for uh whatever endpoints need to support these uh keybinding or you know interactive or non-interactive presentations"
  },
  {
    "startTime": "00:22:01",
    "text": "um it's not to say that the two-party model is like is isn't the only thing that you need in securing a software supply chain it's just that we know the three-party model exists and is popular now and I think given that Scrappy is being built at this time it would make sense for us to account for uh the three-party model in the design of Scrappy that's it so the scenario that you're discussing or sorry I jumped in because I saw my names in the Q next did you want to say something John uh uh only to thank aie for for such a great topic otherwise no carry on yeah I was goingon to say so I think it it really is interesting especially the whole driver's license or any of those scenarios where you're trying to not have disclosure of information leak Beyond its intent um makes perfect sense what I was trying to what I was mentioning it on the arback question on slack was the a scenario that I typically think of is within the software cases a a vendor you know pick Adobe pick Microsoft pick anybody IBM doesn't matter distributes some software or some component and then another one makes it part of their software so they register the use so an issuer issues a statement around the software that they've built and made statements around its quality and so forth I then want to as another software company says I'm going to consume that they're not all they're saying is they're putting that software into their system they're registering it on their skit service to say that I am consuming this this software from this third party the is that person's identity supposed"
  },
  {
    "startTime": "00:24:01",
    "text": "to be part of that system as well or is that just a matter of I'm taking a driver and putting it into my system the person that actually puts it in is not as important as a as the identity of the driver itself so that's what I'm trying to get my head around is why does the person that's registering the statement need to be captured in skit as opposed to that's just an rback call do I have rights to be able to write to it as opposed to my identity needs to be captured as well so is it optional or required I guess is my my question or awesome Steve I tried to capture what you asked in the in the notes so you should make sure it's sort of close to what you were trying to ask um arback is an orthogonal concept here uh so it sort of it feels like it's related but but um you know with arbac that's about who has permission to invoke a right operation and implies authorization in some way um when you're talking about uh presentations of credentials with confirmation the holder is proving that they are still in possession of a key that the original issuer uh assigned to them or or you know bound their credential and then they can push that presentation in a channel they're authorized to push presentations in so there is a difference in the meaning um between giving a credential registering just a regular signed statement and registering a signed statement while proving possession of a key and you can do both of those things in many different channels with different authorizations schemes and arbac could be a part of those authorization schemes so separate"
  },
  {
    "startTime": "00:26:02",
    "text": "totally separate Concepts um you asked uh you know why does it matter uh that the transparency service might understand that the party making a registration isn't the original issuer but instead is an integrator role that's kind of um unless unless we unless we describe that this is a thing that can happen I think uh the transparency service wouldn't have any way of sort of acknowledging anything other than the two-party model and so uh as a transparency service operator my registration policy could require every signed statement to come with confirmation binding in a really high security scenario for certain use cases that could be a thing that liter literally every signed statement always comes with and there has to be key binding and it has to be fresh and and that's that's a use case uh you know for some scenarios that might be out there another transparency service could have a different policy and they could say you know it's optional it's not mandatory but when present I do understand it and another one might say uh I I won't accept anything with key binding it's my policy that I just don't care about that and I don't want to receive that information and I'm not going to make in particular I'm not going to make presentations transparent I'm only going to make sign statements transparent and I I recognize I'm kind of using some language here that maybe not everyone is familiar with but when you have these binding uh sign statements with binding there's a cryptographic difference between just giving that token and giving that token while proving possession of a key and it's good to use different words to describe those two different things"
  },
  {
    "startTime": "00:28:00",
    "text": "because you get different security Properties by mandating uh one or the other um so I I think it's a policy I think it's on the edge of uh you know what we're Charter to even sort of talk about with the scrappy API like we we said we wanted to keep the policy layer kind of not in scope we're not writing specific policies but we did say have this one minimal policy where we want to authenticate the issuer and it doesn't make sense to say authenticate the issuer when you're dealing with a confirmation bound credential because what you are trying to do is actually authenticate the holder and the issuer not just the issue that's it thanks S I think you addressed my thing what my two questions like one I I agree that bunch of it is arbac which is out of scope so um makes perfect sense but what and you're saying is that this is an optional piece for registration policies to use which is awesome because it enables exactly the kind of workflows that you're talking about but it doesn't require um every promotion of content from one skip service to another to be disclosed on the second the person that's actually putting a statement on that could just be some automated system that's promoting content so I think it addresses my two questions really love the scenario I love the ability to be able to capture that as optional information for exactly what you're talking about yeah I wanted to just um pop in as well because I noticed a few a few folks who are missing from the call who were with us in in former times but I'm quite sure I've heard strong support for um you know delegated authorities of one kind or another which this also um allows if we don't have a capability"
  },
  {
    "startTime": "00:30:00",
    "text": "like this then that kind of Delegation of I'm signing software on behalf of somebody else or you know my my vrf that's actually been signed by the person who audited my processes rather than me myself or you all all of these things um that have that have been voiced in the past as as use cases for the software supply chain if we don't code that into the spec then the only place to implement that will be in the discretionary policy of the transparency service itself which is of course exactly the wrong place for you to do your uh identity management so it see it seems to me like um this is a a great idea to unlock some of the use cases that that we do have in scope I don't think it's really pushing the edges um of of scope in this case Ari because um those are those not in your technical terms but those requirements I think I've heard from this this community quite quite frequently Steve is your hand vestigial now should we let Ray in yeah right okay hi um you been completely under under under the gun on some other things so I haven't been able to really look at this much but I wanted to say on this point that this sounds like there's actually two parts of this delegation one part is where you are uh where which is what uh was just being described by ay where you have a um sort of an entity which has the power to S to approve to um you know uh give the stamp of approval on some other entity and say this entity has the stamp of approval and and so it's not the entity that's giving it that we're we're St we're you know stamping but they're they're probably the one doing the work so the entity um so there's so that's like what"
  },
  {
    "startTime": "00:32:02",
    "text": "you're saying like somebody says Okay I want to apply for a driver's license the DMV says okay uh I'm going to send your driver's license in uh to skit to have it be stamped I'm just taking this case not saying it's important uh but the DMV is not the but the DMV in this case is saying okay this entity is now that I'm just now blessing now I'm bestowing kind of like my um Authority onto it and now it has some kind of authority okay then there's a second type where and that's like the first half of a delegation in my view so the first half of the delegation is where you say this entity has has some some trait that I'm I have the authority to give to it and then once that entity has that Authority then it can do something else it could probably come back in the in the larger case and say okay now I have the authority to also submit things to skit based on the first you know blessing that I got from this first entity and that would be more like what we see in the software case of a of a place like let's say um you know first come to mind Microsoft right they have so many people there but then you have to say Okay well this person I'm going to delegate my authority to them to be able to submit stuff to skit and that would be the first step and then once that person or group or whatever it is has that Authority bestowed to them then they could then submit to to skit so then then you would have the full full delegation it sounds like what you're talking about here is only the first step anyway that's my reflection on it thank you and and by the way while I still still"
  },
  {
    "startTime": "00:34:01",
    "text": "have the floor here um I would like uh to suggest that we not try to close down the um the use cases so quickly because I think from my experience anyway they're almost the thing that's written last even though you'd like to write them first um and um and and because of that so and also I see I've seen that that in the last I don't know few months uh the various Concepts that we've been discussing have have changed somewhat and um and they may still be changing I I have a feeling that we're not in a mode yet where we can actually uh say that that is done and so I would like it to be if we're going to to be um you know taking a last call or something uh would be like a preliminary version and make sure that that's known uh because I don't think that we can say it's going to be the final version at this time thank you yeah thanks right it's good good input and just on a point of process I mean we we always can update these things the last call doesn't say this is the final edit it says this is a complete version which kind of agrees with it self and is worth reading so we can we can do both of those things but I think um in any case as we' observe we're not we're not in the second stage uh yeah either so we're gonna have to have to do a bit more bit more tinkering there okay good thank you yeah and yeah I think um if nobody else wants to answer your point I I would agree with your um your characterization there and I think the the Second Step that you just defined"
  },
  {
    "startTime": "00:36:01",
    "text": "kind of overlaps with Steve's ARB back comment which is as Ari said orthogonal so I think we're um we're dancing around the same totan pole on that one well I don't know so much that it's orthogonal um maybe when the terms of saying that it's our back like the full machine of our back might be um uh outside this you know what we want to talk about but the the actual like interaction with in terms of these delegations at the at the very moment when they when they talk to it would be uh would be noral and and also it it also broaches a question about uh whether uh you know the identity question how how the identity is handled and so forth and is SK handling that and then then would be not orthogonal to but it would actually be right on top of what maybe arback does I'm not sure and not so much role-based role-based um is kind of a little bit further away from this by defining those roles and so forth that we're not going to really we're not going to have a part in that that part of the that machine but but the very end of of the first delegation of saying here's a party that I want to use my grand authority to say is good and that's one step that sort of ory I think was describing and then the second step is when that entity and this is what ay I don't think was leave putting in because in most of those cases that I think are in that sort of personal attribute U thing of of getting a driver's license or driving certificate or something uh you don't have really an authority to do anything with skit from then on you just have the authority in the outside world to use that certificate and then they can check back but the the next step is for those parties that the delegation actually is"
  },
  {
    "startTime": "00:38:02",
    "text": "with regard to skit and so then instead of being the diver's license of you know diving certificate of you can you have the authority to dive uh then you would instead say you have the authority to come back and use skit um but doesn't get into roles or anything else it it's just a very small uh and I just wanted to bring that up um and I geee I really like this new interface this is the first time I've seen this new uh new you know meat Echo thing it's wonderful thank you feel like I should minute that as well I'll send it over to the me EO teamk you um yeah there you go AR's added it to the minutes um great okay so sound I I I think it sounds like um there is um essentially I mean on all the topic it sounds like the PRS and the motivations that are live are are in the interest of the of the group so I guess we carry on that sounds um sounds very positive AI to to your question um as well as uh as well as the directional taking skit so uh Scrappy so go ahead I'm I'm not sure if we've covered the agenda item but I wanted to you know perhaps throw onto the agenda for discussion in case there's time um this discussion around uh Jason encoding of seore uh in in Scrappy because I think um that's been an area where there's been some a lot of discussion and it seemed to be positive support for doing some of that um but you know we'll have to make some changes to get there and so in case um folks wanted to talk"
  },
  {
    "startTime": "00:40:02",
    "text": "about the way that they were hoping to see seore and cozy payloads uh exchange this Jason um if we wanted to discuss that I think that might be also a good thing to chat about in higher bandwidth that's it yeah good point so I think we're we're the agenda as as stated is done I think there's no controversy on the PRS so we we carry on with those um so yeah so for um I'll take my chair housee off for a second for this one um just to make things easier representing a company that happens to write software for a living um the experience of implementing uh the the API in general and receipts and and everything else has been very interesting we've written two and a half now uh with with my team in my company of these things and the experience every time seems to be that the Cozy seore for representing the actual sign statements and receipts and the things that we store is great um coming from a team that's been writing asn1 for the last 25 years we're very happy to be dealing with something like seabo which is at least better than that um so no no squabble at all with coore is the general thing for generally being used and generally specifying the absolute um form and interoperability of of the data structures the question arises with the rest API specifically that of course rest apis are passed across networks through different types of devices through different Library Stacks through different paes and interpreters and different gateways and things and stuff and there's an awful lot of"
  },
  {
    "startTime": "00:42:01",
    "text": "Machinery in the way that behaves in more or less nice ways with binary application types um and so in order to deal with that and make fast progress and kind of safe robust progress um team in my company has I think every time defaulted to base 64 encoding everything before it goes across the wire um so again all of the stored values all the interaction and and everything else up until the point it becomes a a rest API payload is is in Co and seall but then you package it up into a nice Json dictionary uh and all of the awkward bits are packaged up as nice b64 encoded strings uh and that's been a really convenient way of getting the the data from one end in a client that knows what it's doing to the other end in the transparency service that knows what it's doing without the bits in the middle potentially getting in the way or or messing with it so that's the the general topic and I think there three three things to say and see if anybody has any um thoughts on the matter so one is that um the data Trails implementation now passes C across the across the interface you know it's not impossible uh it's been done um but it does make it difficult to use standard tooling um two is we could consider not defining the rest API as the canonical one uh and Define some other protocol or we could consider saying that the rest version takes all of this other great seabo cozy um but in order to be interoperable with the client you have to package it up into a nice Json diction with b64 encoded things all three of these are fine we happen to have found the last of those was the most convenient uh so there you"
  },
  {
    "startTime": "00:44:04",
    "text": "go Orie yeah basically want to agree with everything you just said um in the implementations we've done we've also found it really beneficial to encode the request and responses as Jason and then to include in them Bas 624 URL encoded um binary messages uh in the case that you have to post uh something to the server or you have to get something from the server having the text armoring around the binary makes the API really easy to specify and then that makes it so that it's really easy to generate sdks and code examples from the API specification ex itself so um I'm we had previously discussed you know how many different media types might be relevant to uh the sort of skit um API and I think um it would make a lot of sense especially for resources that are expressing a collection um for those collections to be Jason um encoded resources and I think at this point we should be looking starting to look at uh maybe specifying some media types for Json encodings that are specific to skit and um using those Json encodings as a way of being explicit about the content type uh that that we're returning from the requests and then if there is a also a desire to have Scrappy support direct binary D referencing then we we should also make it clear that we're preserving those capabilities or that"
  },
  {
    "startTime": "00:46:00",
    "text": "you can negotiate for a pure binary in the case that Jason is the default so I think we're to the point now where it's probably time to start um making unique media types and talking about what is the default and when can you negotiate for a different representation that's it yeah sounds sounds exactly the same thank you for that um yeah dealing with additional media types is also a an interesting an interesting thing that I think we don't need to get into to publish a useful first version so um good Ray uh quick question if you don't mind the reason we're using the uh you know binary encoding can can we just cover that like why uh why do we need the cabore block inside the Json of course we could maybe Express a lot of the stuff in Json just um using the regular you know Json syntax so uh what what is that reason it's probably simple to answer that I hope um is it is it because we need something that is not going to have any variation of of syntax um you know that you might that might come up in a Json block such as you know spaces and whatever the the variations might be you know new lines Etc or is that is that it as simple as it is thank you yeah I'm uh cute to answer um so basically uh with skit we're"
  },
  {
    "startTime": "00:48:01",
    "text": "defining um these two sort of envelope formats these are the messages that go in you know you send a signed statement to a transparency service you get a receipt um we want those to be binary because we want them to be as small as possible inside of them there could be content that is XML or Json or whatever that's valuable in the software supply chain scenario we we know that software Supply chains have lots of media types that need to be secured so we built uh sign statements and receipts so that cozy envelope could wrap any of the relevant uh software supply chain media types but that you'd have the extensibility and tooling support that comes from using the Cozy envelope structure and we had options we could have done a hosy envelope structure but then we would have uh been stuck with Jason and Jason has some size issues that you know if you're building a something today I think probably it'd be better to start building on cozy than josy personally um but you know I do a lot of work in both of them we have asn1 we could have picked that as well I think for similar reasons building on top of cozy makes a lot more sense for us um and then you know we could have said well you know we're going to support all of them and then that would have be bad for interoperability so the reason we made these decisions is that they're important to a good design there should be only one way to create assigned statement and it should be with by implementing a already well-known and in battle tested standard that's why we use cozy sign one there should be um support for securing media types that are critical to software Supply chains and we have that with the data structure today um The Skit API should"
  },
  {
    "startTime": "00:50:07",
    "text": "avoid basically forcing implementers to have deep knowledge and understanding of multiple media types um and the skid API should also have good support for off-the-shelf tooling and other API design standards um and that's a place where Jason's Json support seems to be important in order to get good adoption and implementation so it's really just a you know it's about you know the design um good design means limiting the number of choices and making good mandatory to implement um decisions that's it thanks a lot yeah that's all yeah really helpful AR and I think that all the interoperability thing obviously is massively massively key and we don't want to proliferate with a million options um yoges um are we saying that um at the API level we want to construct a Json payload at the request response is that what is agreed which where we we will wrap the envelope Co envelope co sign one in there before sending it or may I misrepresented it or misunderstood it I think AR's gonna answer you yeah so um I I don't know um the answer the proposal that I sort of was floating was to define acceptable media types that the API will will support so you know and then there's request and response side so as a client sending data to a transparency service I should use the content type to explain the data format"
  },
  {
    "startTime": "00:52:03",
    "text": "that I'm sending so I could say hey I'm sending you Jason encoded cabore as a client and the server would say yep that's content that I understand and I will return to you Jason encoded cabore or the server could say I understand you're sending me Jason encoded cabore but I'm going to send you cabore back because we only send cabore pack um the point being that in the API specification we can make these really clear at the request response boundary and we have to do that both in the API spec and then also in the normative text that goes with the API spec um and what's mandatory uh what's the default those are questions that I think we should explain what the default is the default should be mandatory to implement and then in the case that you want uh a better user experience or you want to do some optional alternative encodings for your implementation if there's enough consensus to document those we should document them and then there'll be interoperability around understanding them I think from where I'm sitting I'm actually I would be tending to make the default Jason um that might be controversial but I think that doing that would uh potentially help with the adoption of the skit API itself and then that in turn will help with the adoption of the Cozy envelope formats but um the main reason I say that is just like the API tooling like if you try and put cozy content types and media types into an API specification tool almost every API spe specification tool that I've tested doesn't understand cozy at all and so all the off-the-shelf code generation isn't going to work all of these other interface issues are are going to be sort of problematic and we would just be sort of we would be publishing an API"
  },
  {
    "startTime": "00:54:00",
    "text": "document knowing that that was all happening I think that's a bad design um even if you know we would have preferred to have just said cozy and seore are the mandatory to support ones but Jason is optional I for the API I would say Jason's mandatory and and cabore is optional how about if we I mean I I kind of understand the sentiment behind it but I don't necessarily kind of agree the approach you are taking Json yes Json is helpful but I think the fundamental should be the way we have encoded K and K sign one and the cbar was our fundamental encoding so that should be the minimum required and if need be we should provide the right tooling to build those kind of Coes sign one envelopes where any anybody can encode a given document given issue or statements into that that kind of tooling might help the cause and then we can add optionality of Json on top of that as option two but uh making it the mandatory thing I'm not sure about that I'm not very convinced we should do that I that's all I had yeah thank you um and I'll I'll respond briefly uh I'm I'm actually fine if we say it's the the scrapp API mandatory content types are always seore and then optionally you can do the Json encoding and we Define the Json encoding I'm fine to do that um I I think you know just from a tooling perspective um yeah I I think from a tooling perspective you know most implementers are going to want that optional Json one but I'd be fine saying cabore is mandatory um doesn't doesn't bother me that's it okay let me make a suggestion um and"
  },
  {
    "startTime": "00:56:01",
    "text": "and this may what I'm find what I think was going to be pretty essential is to first of all I I support Json um at a lot um now if you're going to have a wrapper around something then it should be like if possible a minimal rapper that says I'm just a rapper and here's the version of the whatever I have inside and here's what it is and that's it um now if what's inside is another piece of Json then that that's fine it just continues to work down um if it's cabore I think it's pretty essential to have that wrapper because from from just a developmental standpoint you're going to have people have to look at these and see what they are and if it's just a chunk of um Bas 64 encoded um uh blob uh or not just a cabore thing then you need some another tool to have to read it and um you know those may not be available yet so certainly Jason has a lot of tools available for anything a browser can read it so you'll be able to just look at it and say okay there's it's just text so you could you could you could say here's the version here's what's inside and there's a there's a chance for development to sort of shortcut some of the EXT ra steps you'd have to take and then if it's uh seore um I'm not an expert on these things I know I I used to use ASN one a long time ago but they uh and I didn't have a problem with it I just you know I I know there's maybe some nuances that they don't like um to me it's just I don't care like how it's encoded as long as there's a decoder and encoder uh but um you know to not have to go through those so pretty much much I think anything that we come up with should have uh and this is what I'm trying to do also with any kind of"
  },
  {
    "startTime": "00:58:00",
    "text": "development I'm doing is is to have a first level wrapper around any Json that says here's what's inside here and then the next thing is whatever that thing is so that we can keep version numbers we can have what like you say yeah we like it this way we want to have cabore inside and then someone later says you know what that that wasn't a good idea uh what we're finding is at the blah blah blah about seabo so we need to change it then they conversion it up and say okay from now on we're going to make this the the main thing um it's it's a tricky thing to decide like what is going to be you we want certainly we want number one not too many options so that that we you know we have to develop a bunch of crap to handle all the options for readers um but then again we want some flexibility in case we need to make changes thank you great well yeah so I think that that question of the of the tool support and adoption is the big one uh and that that's that's where that comes from so um if anyone who's interested and um doing that thank you AI um particularly for your contributions today um anyone who's interested uh that'll be evolving in the scrappy repo and we all have access to the issues and PRS so um we'll develop that over the next month and hopefully get something ready cheers everybody thank you thanks good job and nice nice interface thanks"
  }
]
