[
  {
    "startTime": "00:00:05",
    "text": "good that I hear now that it works I wasn't sure we tend to be quiet um until we get a critical mass so it is the top of the hour but I'm going to wait a few more minutes to see if somebody else shows up so it's not just carsten Marco and Martin as we often have hi quick audio test we hear you you sound great thank you okay we have Ricard joined and Ira so I think that's enough critical mass it's one minute past let's go ahead and start uh welcome to the seore biweekly call"
  },
  {
    "startTime": "00:02:00",
    "text": "and uh well let's just get started right into the agenda the main thing we need to finish today um after we get through the rest of the agenda is the uh the Prague session agenda so let's make sure we leave time for that uh carsten hit it okay I don't have very many uh slides I want to talk about two documents one is in isg processing and one is approaching working last call so let's talk about the document in isg processing uh right now so this left the working group on August 20 third as -09 and we got an ad review and submitted -10 based on that uh and uh Franchesca initiated an ITF last call which will uh end on the weekend and we have a telat date on the uh 26th so one one week in a day uh from now uh right now the uh directorate reviews are coming in we got a a very very juicy um review from artart from thas fatti and that led to a PO request that is already merged and we recently got U an iotd review that also generated P request that that hasn't been reviewed yet so we have a little bit of time um to to do this and the SE genard and upster uh reviews are pending so uh it"
  },
  {
    "startTime": "00:04:02",
    "text": "makes sense to to occasionally look uh into that uh repository or watch it if if you know how to do this on GitHub um and see what other PO requests are coming in there but right now these are uh really all editorial clarifications which uh are really useful so uh it's nice that these reviews are coming in so um the tat next week uh we we may want to roll up all these pull requests in into a-h 11 before the tat or we may want to do this after the telat let's see how the remaining reviews and and the isg uh comments look like but this is just uh moving forward and the CATE document this is depending on is on the tel chat tomorrow um so I hope we can get that uh done in time so it does doesn't slow us down any questions on time tag then let me move on to uh edn so I always have this this slide that reminds people that edn is something different from cddl it's it's a bit too easy to forget uh that so we we're talking about diagnostic notation right now and as you remember we started with dra that discussed uh application oriented literals and that draft has grown into something that that could be called edn maintenance and extensions so extended diagnostic notation maintenance EXT and extensions maybe you want to change the the title at at some point anyway for two weeks ago we had the the plan to quickly do um address the issues number 11 and number TW 12 one was a a"
  },
  {
    "startTime": "00:06:00",
    "text": "missing uh text about encoding indicators and the other one was a missing aenna consideration section uh and we thought this this would lead to a dash five and we would do a working plus call right away from that now this is not what happened um there was tons of useful feedback and so we we went ahead and filled in a few more gaps uh that are between what is deployed out there um and uh What U uh was documented and also uh filled in a few feature uh gaps So based on that we submitted d05 uh yesterday and now can do a working working plus call uh again um probably at the same same time as working plus calling update 8610 grammar um so I put those changes on one slide um so first of all uh Christian had the idea that we maybe want to have a way to preserve application oriented literals when an edn uh ingester doesn't understand the application oriented literal of course the the resulting uh seore data item is a bit bogus uh but uh uh yeah it probably should be a an option for uh Indian G to to actually accept uh unknown appliation oriented literals but we now have a defined representation to hand them around at the data model level so this is kind of trivial an application attack with an application oriented literal contains the literal and the the text and we put this into an array and take that with 9 and9 UM the second thing we noticed is that we never got around to actually documenting the ellipses feature that we"
  },
  {
    "startTime": "00:08:02",
    "text": "discussed in an interum about a year ago um so uh we wrote some text and and some abnf uh for that this was tag 888 um and the idea is that in a specification you can write something like um a bite string that starts with 4711 and ends with 0815 um and uh here on array that has uh an initial member uh with with a mail address and another member that is not further specified in in this example and people who are writing examples will will be very happy that that this uh gets uh added because it allows tools to actually know which parts have been elided and and so that the tools can just stop checking them because they were um supplied um for for exposition uh only or they were not supplied for exposition only um the third one is um we had forgotten to uh document appendix G do4 of 8610 so this is chunked strings you can uh write uh sequences of of string literals and they get automatic automatically combined into one and we just hadn't written that up and uh finally uh we noticed that we have this RFC there 9164 that really cries for for having an application oriented literal uh so uh we decided to just put it in because it's I mean we have the RFC 2.2 so wasn't that much additional work um so the application oriented little addresses IP addresses as well as prefixes"
  },
  {
    "startTime": "00:10:04",
    "text": "because that that's um we don't have a a well accepted notation for that that we could put into an uh application or literate so everybody understands this sl24 thing that is on the slide uh but combining an interface address with its net mask is not something where we have a single standard uh way to do this um while we were doing this we noticed that the the uh prefix uh notation uh actually only works very well when we identify uh which uh kind of address we have normally we can see what kind of address we have because an ipv4 address is four bytes and an ipv uh six address is 16 byes um but prefixes have their their uh redundant zero bytes removed so uh you cannot see whether this sl24 is actually an IPv6 address or an ipv4 address it would be a weird IPv6 address but we shouldn't uh disambiguate this on semantic uh considerations um so we needed a way to actually say put in the tag and uh that way turned out to be just writing the application oriented literal in uppercase and we not only added this to IP but also to DTS so you can now have a daytime tag actually in the form of a an application oriented l so that was the the last change and the whole thing is now dash five and uh I think this could be working with BL C if we want okay I think the at least this chair would go ahead and start a working group last call uh"
  },
  {
    "startTime": "00:12:00",
    "text": "probably we should wait till after ietf 118 just so we don't overload people who are getting ready to go to the meeting we've well last last week we the plan was to to start then so I wouldn't be opposing any any any last call that we start now okay um that works for me then we just extend it to a week after have it end a week after after rf18 or we could end it so we actually have the result by the meeting and and can put Lids on things okay um yeah sure let's do that okay I think this has been around in interims often enough that those interest have a good starting point that's true you're right okay so we'll start it uh we'll start it today and end it uh let's say the um the Monday of ITF week yeah sounds good so we can talk about that okay okay that was all ah had oh that's okay so then we move on to the grammar update the 8 610 grammar update for which there's no slides who's doing that yeah I I just wanted to mention that that two weeks ago we said this was ready for working call so it's still ready for working BL call and we just wanted to have it at the same time so people look at the abnf at the same time yes okay so we're doing we're doing both of them okay good um so the next thing on there is Martin it looks like"
  },
  {
    "startTime": "00:14:02",
    "text": "uh okay seore and DNS so let me get back to the slides there we go okay um so yeah uh I guess most of you know already what I'm working on so um and I will only present some on the name compression that we talked last interim about uh but uh yeah first I get the motivation still and uh then summarize the ideas we talked about last time and then I'll go into the evaluation um yeah uh first we have these two graphs that I showed last time they are cdfs of the compression ratio and bit B uh bite savings um basically every everything left of the red dotted line is larger than the wire format and everything right is smaller than the uh uh wire format uh so yeah we have some that are very good and some that are not so good and especially this long tail here on uh the bite savings site uh was something that uh we noticed last time which was because there is some there are some responses that have a lot of names in them um which can be compressed and are compressed in the DNS wire format so the question was do we need name compression for the base format and basically I interpreted the last discussion as yes we need uh some name compression and so I put forward two ideas um first of all do it like the DNS wire format uh so reference name components within the SEO object or do a packed SEO light where you have a predefined table of uh name names or name name components and reference them"
  },
  {
    "startTime": "00:16:02",
    "text": "uh like we do in P C1 so uh the reference name components is basically Loosely based on Christian's idea to uh compony the name um so basically instead of having uh text string in the being the domain name we have components and I basically uh extended this idea here to add references in this case I added some tags um to uh unfed integer in which I called T4 now here because I didn't decide on an value yet but I will come to that later and this reference tag basically uh references a name component um and the question was how would we do that um uh what what what would the unide integer actually be uh in uh in The Wire format this is basically uh the offset of the name within the message so in CBO equalent would be the offset with the seore object but this turns out to be Implement really complicated to implement because uh lists can grow during the construction so uh the pointer always uh changes during construction uh and so I decided for much easier approach to basically just take the e t string when you have a tag TI and there was also question how do you recognize that the name ends well because I now use a dedicated tag it's basically just scan for the name as long as this object is the T string or the tag t uh it's a name and um so if it's not in the comp definition of uh the cddl uh then you basically left the name and you you can stop scanning for the"
  },
  {
    "startTime": "00:18:00",
    "text": "name um and uh I then you can see now how how this referencing would then work here in on the left side and in my evaluation I basically used two Tech values first seven so a 1 plus Z byte bit by teag and uh 48 so 1 plus 1 byte tag the reason is because um in DNS uh these pointers are in the DNS wire format these pointers are always two bytes long so I wanted to see if uh this makes sense to keep these two bytes or if the three bytes that we get with a one plus one bite assuming that uh these numbers in the in within the tech are always very small um are are worth any so uh any questions up until here first before I go into the next idea okay oh yeah just takes me a long time to actually find those buttons um there is a tag 25 um that that was defined right in 2013 or 2014 I forget um which um is called string referencing so essentially the uh tag gets replaced by the nth uh previously seen string I miss that that's good to know yeah so um your counting goes forward while the the counting of tag 25 goes backward and there's also slightly different semantic to just taking the previously seen string but yeah yeah yeah I I haven't checked the"
  },
  {
    "startTime": "00:20:01",
    "text": "detailed semantics here but but I I just wanted to put this in as a data point so we have had this functionality um for a while and uh maybe it it's worth looking at at the the small differences here so um does does it even make a difference going forward or backward or um is it is it just easier I think it's easier with going for W because I I will show this on the next slide um but also as I said semantics are a little bit different because you don't just take the E uh string but you also take everything that comes after it and belongs to the name so for example this ns1 here in my in my example would be ns1 example.org so the semantics are a little bit different than just taking the next uh the string um so you you essentially take the rest of the array yeah not the rest of the array but the rest of the array until it's not part of the name anymore so okay because for example I for for this NS one example I wouldn't take the r type which is 12 here and uh the one uh which is a class I wouldn't take those um of course and if the name was the name of the record not the uh the r data here in this example I wouldn't of course not take the TTL into account and stuff like that so um yeah uh it it's a little bit difference and I I admit a little bit hard sometimes to wrap your head around it at first but uh I will come to that yeah okay so that that was my my first observation I think that would just be useful material for a paper about this uh to to point to this older thing um"
  },
  {
    "startTime": "00:22:00",
    "text": "and um the other question is um what do we I mean how how do we actually save something here so one thing of course is the implicit uh table building so we we have an algorithm to build a table that uh uses the occurrence of of a text string and actually adds things that in the same array that that also contribute to a name so that's the implicit what I will call implicit uh table building and that of course uh saves uh having to uh actually Express the the table explicitly as an array and um it it saves um the reference from the first occurrence to the table actually you will see this later when I show the C light format um where where but this the object that I show here is marginally bigger and also in the evaluation you will see this uh so you're uh getting ahead a little bit yeah okay okay I'm I'm just trying to to um I mean you can measure this that's really useful to do but then you can try to understand what's going on and I I think the the point about explicit tables is um that you have some overhead for setting them up but then the the overhead of actually using them can be very very small um you mean implicit tables explicit tables okay explicit tables yeah so let let's see how how that works out yeah um so as I mentioned before another advantage of this form to Jump Ahead a little bit is that it's"
  },
  {
    "startTime": "00:24:01",
    "text": "at least in Python and also in C now I also did it in C uh it's really easy to implement because you basically just have to count the names as you add them to your object and if you have a prefix that matches uh this uh name you basically just not a prefix a suffix sorry a suff suffix then you basically just append the tag um so uh yeah it's uh that's another nice thing about this while with um with CBO um with with CBO packed if you at least if you want to do it correctly and assume that there are uh more than 16 values in there uh you might need to also count the occurrences of a string so how many how often a string appears so that you can uh prefer the more often appearing ones and adding them first to your uh EXP AR so um the other idea as I said was the spec light idea which uh is basically uh somew extension of this proposal by an Mo and collaborators uh they use the dictionary to reference the name we basically just use an array uh and we basically use the same uh semantics that we have with C pack here so um basically we now have ns1 also here in in reference in the table by the tag and in the rest of the array we actually use the simple but of course we could also use the um the inverted uh rump reference within the object itself uh so yeah basically for at least the C folks this probably looks like the more straightforward solution or are there any questions on"
  },
  {
    "startTime": "00:26:06",
    "text": "that um if this is if this is done as basically the regular p c setup um would it would the whole thing be tagged I mean it's Pro one probably two bites overhead that are not shown in the in the diagnostic notation so it would be like tag 113 off yada I couldn't follow that but so if if this is the te this is precisely the tag setup as described in in pack P setup as described in pack as tag 13 then you have 113 is implicit here yeah yeah it is it yeah sorry uh okay I skip that completely because I forgot about it because I didn't use it in DNS uh in the DNS format by now so yeah um but yes it would be basically like Tech 113 uh okay then I did the evaluation I used the same data CPUs I used for the other evaluation before I just did a little bit more experim experiments first of all of course repeated the experiments from last time we basically use the same results um and uh then also did the component reference ing which which I called compre in these experiment results um and did it as I said with TCH 7 and Tech 48 and for Tech 7 I also uh did a packed variant where I use the only references when string as a shared value and not uh allowed for inverted references like the draft proposes because since we are now using only name components it doesn't make sense to assume that there are suffixes Within in these name components um if there are they are they"
  },
  {
    "startTime": "00:28:03",
    "text": "probably are quite random and for Pack Light I looked at the unpack format as Pack Light and the pack format I basically just used the same that we have already defined in the draft and again I looked at the compression ratio and the bite savings which I defined here so the compression ratio is relative uh measurement and the bite savings are the absolute measurement and uh yeah first uh let's have a short look and at the old results again but uh for easier reference I also added the uh the plots that are uh relevant also to the other plots um because when we look at the queries we don't win as much with uh the comp uh component references but that's not that much of a surprise PR because um we only have a small Advantage when for example the SSD queries are there where you have additional records or authorative record and that is this small bump that we see there in in the compression ratio and these smaller even smaller steps that uh give an advantage uh to the uh savings um if you look however at the responses we see of course much better results um uh where we have uh the compression reference uh the component referencing uh in Orange and uh uh purple here and in magenta we have the packed light and we see here that the packed light for format uh at least for the uh smaller Savings in compression ratios first is very much identical to the pack format while the uh component reference format is actually a little bit better for the smaller compress Russ ratios and bite savings and of course also not that much"
  },
  {
    "startTime": "00:30:02",
    "text": "surprising we have a very small advantage on uh the compress uh comp uh the component referencing when we use one plus zero tags uh but overall we can say that we have uh that we have only uh very little uh responses that are not compressible anymore we have this very small tail at least with a component referencing with Pack Light there is this small bump into this dividing line um I can ah okay for when when the same is when we can omit the uh question within the response there we see a similar result and yeah um for smaller compression ratios as I said the component referencing is a little bit better better and B surprisingly for the OnePlus zero Tech because as uh cast already pointed out uh PE light introduces a small overhead for by the extra list and this additional reference that you have in there um then for the pack SE War variant with uh the component referencing um we see this very small advantage of uh of shed when we use shed value references and also no surprise because we basically assume with uh inverted referencing that there are similarities in the suffixes of the name components which is not a given and so we basically introduce uh some overhead for some random similarities and this actually is uh shown in the data so uh to conclude this is basically that we if we use name compression we have nearly no compression ratios that are smaller than 1.0 so everything most"
  },
  {
    "startTime": "00:32:03",
    "text": "most of the uh data we looked at is compressed and um the difference between the component referencing and packet light is marginal I personally have a preference for component referencing because it's more concise because we don't have this extra overhead um it is simpler to implement as I pointed out and uh the other another bonus is that at least for DNS implementers it might be more familiar because works exactly as the classic DNS name compression Works um and just to give this abandom about the flx um last time I talked also about the flag rotation maybe to rotate the flag and the options because we could save at least two bytes with that but I given that we already have one over 1.0 uh compression ratio without this modification I think since the advantage is NE negligible and we only win those two bytes in most cases I would say it isn't worth confusing implementers with having to rotate the bites okay are there any further questions just what what I'm what sorry if if this has come up earlier um and I and I missed that um you mentioned the the the compression of sponsors without requests um wouldn't it make sense no matter whe no matter whether the resquest is repeated in response or not um to tap into the requests dictionary uh sorry tables um already initially so I mean I don't know that's basically what happens uh uh if you uh if you include the uh"
  },
  {
    "startTime": "00:34:03",
    "text": "question then it uses this question as a dictionary in both uh in both in both in both compression formats yeah but it um but it repeats it still repeats them once right so if I'm if I'm sending my request and that contains my very long name. example.com well it depends a little bit if if if the question isn't present because we since we use DNS over corop or DNS of htps and we already can associate our question from what we have in our state um that's basically how you can are able to uh omit the question um okay so if you don't have if you don't have the question you need to get the names from somewhere else which is most often then from the uh from from the answer or from uh something somewhere else if they are provided even I mean you can completely omit the the names in general anyways if uh if you can get them from the context okay so if so there are ways of of sending a request a response that doesn't include the long name yes in okay so so there is no need to set so so if the DNS resolver is set up to Pro to make the responses small then there is no need for cross referencing into the table set up for the request yes um okay so but that's only trueful responses but with queries of course you always have to send the name because you need to name yeah yeah but but the respones but there is no okay yeah yeah any further questions or comments yes cast yeah um"
  },
  {
    "startTime": "00:36:02",
    "text": "so if if two people have a difference in opinion on some issue it's rarely the case that the one of the two people can't think clearly but usually it's a difference in perspective that that brings you to a different opinion and um I think this is an an interesting case of that um so the the um I think you call it name compression I'm I'm still not quite sure about the terms um so the the implicit as you go um uh approach um is uh slightly more efficient than than the the explicit tables approach that c uh uses so uh if if this was all we need to look at um and I think that that's pretty much your perspective as of course as a researcher who tries to uh look at the various approaches and find the best one uh then we we clearly would decide for that um on the other hand um C pack is a generic component that can be used in in many uh places so the the same constraint device that needs to to use DNS is probably going to use other sources of data and can uh also benefit from using cop there so from a from an ecosystem point of view how how do we make the CRA ecosystem more powerful by by including some uh pecking uh there um it probably would be uh there probably would also be a preference for for using the same format that is being used for other data um so I think it it's really important to to understand uh what is the the impact of choosing uh"
  },
  {
    "startTime": "00:38:02",
    "text": "one or uh the other so right now you have to uh compare to to the old uh DNS uh format and and you call it wire format all these formats are wi formats um but uh maybe it would be interesting to have these tables or or or graphs uh to look at uh directly comparing the the two uh packing approach so we can see how how important it is to have something specialized for DNS versus having something that can be used for other data as well yeah I agree I I can have can look into that and then probably present it in uh in frag yeah and the the other thing that I think would be interesting to look at is um U would it even be possible to do something like implicit table set up with C packed um so C can we actually eat the cake and have it too um I haven't thought much about that but I'd like to think about this a little bit and um so uh uh reaching ahead a little bit in the agenda um of the this meeting uh we need to talk about the agenda for 118 and I like that right now both SEO pack and and the DNS uh representation are on the agenda so we we can can discuss this together um so I think that that's a a good uh thing and it's a good thing that we have a couple of weeks and hackathon uh to to actually work on this before we have this discussion yeah so I'm already"
  },
  {
    "startTime": "00:40:00",
    "text": "pretty spread thin for the hacker from time I have to admit but yeah we'll find a way right I think that's I'm not the only one yeah okay if there are no further questions and comments I guess uh we can't find final decision yet but um yeah for um I guess I will still do a version five of the draft where will'll do some other stuff that we discussed previously um and some stuff I noticed during implementation um so we we have version five on Monday but not including this yet um do you all agree with that I guess yes right okay um then uh thank you from my side and uh yeah see you in park see you in Prague so that takes us to the Prague agenda um well we clearly have as we've said seore packed and uh and uh the DNS on the on the agenda uh what else do we need on the agenda other than the the normal updates where we are with the documents yeah if we have working glass cards that that actually finish by the meeting then it would be obvious to discuss the working called results then right right right so it's the the documents that are in progress and then these two right right is there anything else we need besides"
  },
  {
    "startTime": "00:42:01",
    "text": "all that or is that an easy agenda i' I've lost a bit of track on of the on the on the on the various variations of dcore is there anything summarizing to say there or is there any progress to report well we haven't done much work on that in the last couple of weeks but of course we want to uh pick this up again um I'm just not sure that we will make a lot of progress in the next couple of weeks um so that's more for an interim to pick up sure but but uh having at least a few minutes on it in uh 118 will get People level set and uh remind them that we are moving on it so why don't we put it on the agenda just for for a few minute um maybe a five minute thing what do you think yeah it's never going to stay five minutes but um yeah I think we we just need to make sure that we we don't use the ter Dore as the heading but really deterministic encoding profiles and and things like that crime and uh okay okay so then the the other thing that will also go on the agenda and that we can talk about now is the proposed dates for so we're moving on to uh the proposed dates item on the agenda um proposed dates which we coordinated with core thank you mono as always uh he always reaches out to me before I reach out to him so um but these um the dates that are here um represent the same case cence that we had in the same weeks of the year um and I just presume we're going"
  },
  {
    "startTime": "00:44:01",
    "text": "to continue with that every two weeks cancelling when we don't have anything to say the question we have is uh do we do six March uh which is it's still a week and a half before the ietf meeting so we could do it but I'm suggesting that we not schedule that one and use 21st of February as the last inur before I f19 does anybody think we really need the one that's a week and a half before the meeting well I think it's typically useful to have a slot after the uh internet draft deadline okay so I I would just schedule it and we can still we can always cancel it sure all right I'll put that up on here so then that's going to be 6 March and let's get rid of that okay so we're set with that and that will go on the agenda for discussion at 1:18 and then will be checked out on the mailing list I have nothing else does anybody have any other business thank okay thanks everybody thanks for coming and we'll see you in Prague thank you byebye in prg bye bye"
  }
]
