[
  {
    "startTime": "00:00:32",
    "text": "Or session, And this week, We have another one tomorrow. You've been to the first one. Already, so you know, the the drill we have the note well pages, which you should be familiar also already from the other working groups you've attended during this week. I have a meetings, meeting minute data George, but Hopefully. Okay. But, if someone else can also take some notes, beat that. Thank you. Yaroslav Excellent. Prime, you're ready to q. Oh, okay. A mistake. Okay. Okay. Sorry. No problem. Yes. Go and quickly scan the QR code before it disappears. Any channel like everyone, please, Please scan the QR code so we know who is in the room. Not just because you may want to later go to the microphone to ask some questions. My co chair refund is like, In the first session, he is Online. Rafa, are you there? Yep. I'm here. Awesome. Thank you, Rickak. Okay. We're ready to go"
  },
  {
    "startTime": "00:02:01",
    "text": "Yeah. I talked about the note well and the fact that we showed it already talked about it then, you are already familiar with d, meet that code and the way to join the Rich sign up. Kind of QR code, etcetera. Do things we wanted to mention at the first session already, but, failed to do so because of time issues. So there are 2 Sort of kind of announcements, so to speak. They've added those to the to the slides The first one is this, federal Federated credential management API work that has been, going on for about 2 years with, Had some interactions with the Relevant party stay as starting maybe 2 years ago already. Which in the context of, getting rid of 3rd party cookies and changing potentially flows and and adding, making all sorts of other changes in the browser. Which, have an impact on the way how our brother coach works. So I think this is an interesting topic that we need to discuss there will be various information and discussion and discussion events this year and, Rifan and I are planning to hold an, working group intermeeting as it says here on the slide and then following weeks, maybe sometime April or so, And, the group working on on this technology. Agreed to give us an sort of kind of an update, and then will have a discussion and figure out on, like, what does that specifically mean for the work we've been doing in the past and and also going forward. And I think it also relates nicely to some of the work on, native applications we've been talking about. Aaron has been presenting this work at the last IETF meeting and so on. So there's there's, stay tuned. Specific."
  },
  {
    "startTime": "00:04:00",
    "text": "The next, item is an We made that announcement already at the last IETF meeting in Prague. There would be another one of those overall security workshops that we have helped in the past, this one is coming up really soon. April 10th to 12th in, Italy And, Yeah. You can register, go there. And, and try to show. Good. Now getting to the Sorry about that. Getting to the agenda. So for today, we have several items the Chase on Wepto. Can we see the status list update, the attestation based client authentication, a non endpoint, status attestation and, a short presentation about the new document that was proposed with some early input, requested. So that's really short the last or the the the former 2 nuns endpoint and status at the station is a new document that was posted by Ori to the list and got some discussion input and the first tree in the agenda are working group items that we want to start with first. Okay. And I was stop docking and switch to the real content. Okay. And I think he was, Daniel Daniel, are you going Hello? Percent. Yes. Okay. You just tell me when I should switch the slide. Is that good for you? That works for me. Yeah. Let me see if I can switch on my camera. I can. Hello? Everybody. Yeah. I'm going to talk, about, SD. And that it's worked together with Oliver and Brian. Hello, Brian. Alright."
  },
  {
    "startTime": "00:06:00",
    "text": "See you, but you're also in a room again. Okay. Next slide, please. The agenda will be the usual, what happened since last IETF and what our our next steps. Specifically, today I'm going to talk about something that's called the draw at the CDM. And, the problem that is solved by that and how we want to solve and what that means for SDRFDC. Next slide piece. So since the last IETF meeting in Prague, we published 2 new versions of the spec 02103. Next slide, please. And as you can see on on the pictures. 2 and 3 were really close together. That's because we just made a minor change in 03. Next slide. So what did we do? Many small changes, really. So we, updated the rules that we have on how to obtain, the public verification fee, And, what ex what what steps you have to follow for the validation usual editorial changes, we had something that is that was called jot issue of metadata, we renamed that to be more precise and more, close closer to the content of the specs. And now it's called short VC issue of metadata we, make the IAT claim up and it's now also allowed to be selectively disclosable. We fixed an inconsistency in the dot well known path construction"
  },
  {
    "startTime": "00:08:00",
    "text": "you can probably guess what that inconsistency was. And edit, registration request for the ina. Some formatting and stuff and clarifications in the text And we also updated the examples that we have in the spec Specifically, we also add a example for a pit credentials or person identification data from the your digital wallet context. And then in 3, we fix that example because when disclosure wasn't working. And we should get out why. And then we fix that in 03. Okay. Next slide, please. So that's what's new. Now let's look at what's next. Next slide, please. And the stuff that I'm going to talk about is comes directly from what we need, what we identified as problems in the EU Digital Identity Wallet Contact next slide please. And For the EU Digital Identity Wallet there, so you document by an expert group of the European Commission that's called the architecture and reference framework. I supposed that many of you familiar with that. And there are some hidden gems in that document. For example, it says that You have to use w threesc verified credentials. Model model CDM, 1.1. You have to use selectively selective disclosure draw. So SD draw But this So how exactly those, used together as not defined. And, that is that is a bit of a gap there. And that led to some"
  },
  {
    "startTime": "00:10:01",
    "text": "interesting discussions among the member states, how this combination, can be achieved, how it should be achieved, what exactly so Which things? Things. You make select weekly disclosure closeable, which should only make select a few disclosable. Whether everybody needs Jason LD and stuff like that. So, we have those to technical specifications, and they cover slightly different areas and they, I'm not Like, they are compatible in various ways, but it's not clear. What way is the best way and how a combination of the 2 can be achieved in a useful way. So that was a problem that we had. And we talked to many other member states about this. It was clear that there are different, opinions on this, and we have to final alignment, next slide, please. To figure out what is the best of both worlds between those two. So for example, VCDM, that's that's No. Not a single defined selective closure mechanism. So you can use it with SD drop, but how exactly would you do that? You can use it without a mechanism as well. Those out of scope of the ARF Then there's the the Oh, Jason, wireless, Jason, LD topic, that I suppose many of you are familiar with. And from the use cases, we got the feedback that, those use case or some of the use cases already using, w PCVCM in Europe. They Half so they they they obviously use JSON ID in the sense that it as in the credential. But but but but but but but but but but but They also told us that they Don't really process it. So For them,"
  },
  {
    "startTime": "00:12:02",
    "text": "they have their use cases. They Need to find a credential format that works with Chase Noty so that they can continue follows existing use cases to use it. But also that that that They would be quite happy with long JSON of the credentials for new use cases. And especially when you want to have. Very simple credentials, I think it's a good thing to not have to use. Having to use JSON Elite, for example, for the pit credentials, I don't see a reason to use Chase immediately for those. And finally, In Europe, there's the Etsy ADIS, family of sadness, especially Jadis. So Jason JWS based electronic signatures, that are already defined in Etsy, And many, trust service providers have built services and and systems around those, specifications. So if their credentials can become aid as compatible, that would definitely be a plus. But It's not the how you would do that with the BCDM. Now if you look at SDDrop, the ADAS problem still exists because the, it's it's it's it's in the in the far in the current farm wind farm loss before we started this work. It was also not immediately compatible, and It lacked some other features that you can find in, W3G. W3cbcdm, specifically the option to express schemas and to express or define vocabularies. For your credentials. So"
  },
  {
    "startTime": "00:14:00",
    "text": "Oliver Taboo, Ellen Harvard and I, we set together and try to work out what could be the best both wells here. So, the idea is to Define something, that, combines the strength of those approaches that specifically is also compatible to existing use cases meaning you can use JSON ID if you want to, and you can use w three cvc damage if you want, if you want to. But that also produces or gives us not for very simple credentials. Gives us exactly what we need in terms of schemas and vocabularies. And so on. So That's what That's what we did. So we came up Next slide, please. We're the proposal that recalls As The drop BCDM. Yes. Whether that's a good name or not, we can make sure. Slides Just saying. K. Yeah. I'm I'm I I'll try to speed up. So the SD drop VCDM proposal here's a format, that essentially, that's what I just said. So JSON based, credentials in the EU context and bits and QES. Based on their travel credentials, taking into account existing data models, formats, and secure lessons. Next slide, please. And, the idea is that This is based on SDJOTPC. So we, take the existing standard and define it or, we, sorry, we extended very specific ways to cover those areas that are not covered yet. In the SEA drop VC, well, this, could be called type metadata. Was a gap in the spec. Anyway,"
  },
  {
    "startTime": "00:16:00",
    "text": "was no definition of a type in SDRPC. So we said that credential can have a type, but what is a type? So that definition was missing. And this is something we'll add. That will give us the opportunity to introduce mechanisms to to have type hierarchies, to have schema information to have rendering information and other things. In the type metadata, we try to keep it as simple as possible, and as few claims predefined as possible. So you can is your data structures from your existing use cases and just, and just, put them into pre dentures of this type. So this is also if you want to compatible to W3cdm, version 1.1.2. So you can layer that on top of this. You know, you can use JSON ID if you want to. But you don't have to. Next slide, please. The ideas that in the credential itself, essay Call data model, which essentially, just says you have to have A type, your credential. You can have other information there as well. Obviously, for example, status list information or an issue or whatever. But the only thing that was really required is the type And that type can be resolved to type metadata which can extend other type metadata and this, and this, various information in that type metadata Yes. Next slide, please. And, I think we can this. I essentially set that already. So this is what a pit credentials or person identification data credential in the EU context could look like"
  },
  {
    "startTime": "00:18:00",
    "text": "very minimal data set here also very simplified example. But you can see that VCT Is in this case, It's, your end. Which could be registered somewhere, that could be find resolving mechanism to figure out what the metadata is from a registry or wherever obesity could also be URL so that you can just go there and retrieve the type metadata. There's, application specific claims. We don't define those these are just in the example, like, given name from the name birth date, a CNF claim to enable key binding of the credential. Next slide and then the next slide, please. And here's a more complex example taking an existing data chapter, from the so called portable document a 1 what that is is not important, but the point here is that This is also a valid credential for SDJOR VCDM. In this case with more application specific, claims, and that is not problem for that format. Next slide, please. Next one. The next one, please. So how do we get them? What do we need to do, or what do we plan to do? Next slide, please. The idea is that we So with SD drop VC, we already have a group basis. It's a very simple format The thing that we need to extend, and that we always wanted to extend actually is the type metadata. We already have a proposal for that, what that should look like or what that could look like. It's, quite complete in terms of features yet, but we're working on that. And we already have the first pull request open for SD to receive. To, to implement that type metadata."
  },
  {
    "startTime": "00:20:00",
    "text": "And we need to define some extension points essentially just saying if you want to express a status information, mechanism. Somehow, this is This is the place to do it. We also did a minor update to a speed drop to align with Jadis so that SD drop. Becomes javis compatible. And in Etsy Javis itself, there will be a very small update required. To cover or to enable SD draw credentials that assigned by JADIS in the contact format. Okay. And that's it. Thank you. Next slide this if you want. Right on time, I guess. Thanks, Daniel. When you see define type metadata proposal exists, west app proposal. I can share the I can share the URL in the, in the chat here. Yep. My understand. I The rest of some notes in my Not that free. That we discussed internally, but we'll create proper pull requests on a c drop. Be safe all this. Doctor Fett, Doctor Jones, I'm curious about the defined extension points. Language. The reason I say that is generally in are data structures, we just say that you must ignore stuff you don't understand. And so you can add stuff to Jason or seaborne and you're good. I mean, you're hinting about status and policies and whatnot, but what what are you getting at there? So, The"
  },
  {
    "startTime": "00:22:04",
    "text": "the the thinking was essentially that right now in the status list proposal, for example, we That's that's the definition of a claim called status, for your chart where you reduce the status list. And the discussion that we want to have is Whether that definition of that claim should not move to the credential format. So in this case, ST drug VC, and potentially could also serve for other status mechanisms. Like, a different type of status list, for example, so that you can use both of them or then, provide provide both of them. I don't know what the exact semantics would be, but, Also, because there might be use cases and also sectors, that already have such mechanisms that want to express it in those credentials. That's the the idea here. Okay. That makes sense. Thank you. Has has has Daniel, you you specifically focused on on the requirements that need from the European Union with the work that is going on there, how do we ensure that the that use cases that are Sort of come up elsewhere, in other sort of, parts of the world are also covered. So we don't tailor it specifically to the EU Yes. Sort of circumstances. So we tried we try not to, do that. But, of course, that's a good point. And I guess that's that's Also a question to the group, if anybody has, concerns about this or other use case as in mind, but So we,"
  },
  {
    "startTime": "00:24:00",
    "text": "we developed this proposal, several weeks ago, we have this website that I'll share in a moment or Oliver can probably share it while I'm speaking where we have a, essentially bit of a longer version of the presentation that I gave you. And So far, we've heard mostly positive feedback from people who said at that sounds interesting to them, to have this. But, we try to socialize it to find out if if it actually also meets use cases of other people. So it's a call to the folks in the group. So if you are a our father initiatives elsewhere and Sort of maybe Make them aware of what we are doing pull them into the group so that we have some information sharing. That would be fantastic. Yeah. And please also, like, this is a more generic remark, but I I I think it's, also appropriate in this context. So when you, from a process point of view, When you when a document transitions from an individual ID to working group document, you are, as the author's, you're kind of We're languishing control over the document to the working group from yourself. And so, like you put on your, Oliver posted a link to the to the PR that is quite elaborate, on the proposal for defining this type metadata make the working group, away of it. Like, try to Do your best to involve the group in picker design decisions so that we don't have problems later on, when people suddenly say, oh, it was never discussed was basically done in a in some, private club. Yes. That's a that's a very important point. Christina said I would expect IETF process to ensure that non EU requirements are reflected yeah, of course, because of the transparencies and working group last call, idea of last call, etcetera, we'll definitely get input, but, I think we also"
  },
  {
    "startTime": "00:26:01",
    "text": "since we are the experts in that, area and, and, you particularly in the, sitting here in the group, you you have the exposure to some of the ongoing activities worldwide reach out to the people, try to establish the connection so that we can, do our best to Kabadi, the different needs and make this more generic I don't have any concerns specifically, but, I think it's in general a good practice to Yep. To do Okay. Cool. Thanks, Daniel. Run up. Okay. Next one. Think you are the next one too. Well, who's going to talk about this one? Now it's Is it to bias? I will start with this one. To my son, probably all three of us will be presenting. Awesome. I'd, I would to the slight management, right, Yep. Perfect. Alright. So token status list formerly known as Jot Cot status list. I hope you have now a better name and easier to pronounce especially. Next slide, please. So a short professional. What are we talking about? We're talking about the capability for an issuer of a token to communicate do not make status information about the token. So during its lifetime, After issuance before expiration. Next slide, please. So an example, what that can look like is We have a wallet, We transmit some kind of token This token has status information. That contains an index and a URI, The verifier Pause this third token. Finds the URI, fetiously, the URI, passes the status list and then verifies status information. Depending on the entry at the index."
  },
  {
    "startTime": "00:28:01",
    "text": "Next slide, please. I'll I'll try to be really fast because I think we have to catch up a bit on on time. Right? No. No. No. We are good. I Brian made me aware that we had 5 more minutes than the clock on my screen indicated. So Oh, okay. Okay. Yeah. Yeah. Okay. Some Yeah. So We had 2, versions 01n02. Let's go through the changes of each of them really fast. We have some of them ball. These are the ones we will be presenting a more in detail later because this is a bigger changes. And then later on, we also have some questions that we want to ask the group. So I've already said we we We named the the draft. We added somewhat bigger design consideration to the introduction So to say what we try to solve, what we see out of scope, etcetera, etcetera. Which changed the status claim to allow the reuse of, the status claim for other mechanisms. More on that, in the following slide, We have an Ana, where it's free for exactly that now? Mobile. Proposing that? We are restructuring this section We think it's a lot more readable now. After restructuring, parts of it. We added an option to return an unsigned status list, so it doesn't have to be talking. It can just be an HTTP endpoint. And you get to Jason or Seebo? Directly. Which changed compression from Jesus. This is a very minor change, but feel that this is more natural. And then some minor changes like typo and adding an example, as an access token. As an example use case. Next slide, please. And then in o2, We had, time to lift claim. The status list token to convey Cashing information more directly? Will also first start on that one. We relaxed requirements on reference token."
  },
  {
    "startTime": "00:30:01",
    "text": "Perhaps a bit more context on that. So so we also allow basically Calls assign 1, No. So, for example, mdot can use mechanism? We had a small change in the formulation for the deflate z loop compression. It was Not too clear how that works. I should be a bit clearer now. Explicitly reference the issue or hold a verify model of SD WBC. Because that kind of explains more of the overall concept of the specs as well. And we added cozy or cut seaborne and coding. To the spec. So it's basically now the costly and the costly world. Next slide, please. So let's go a bit more into the bigger changes. First of all, we we we got some feedback, and we saw that during our in implementations and discussions as well that we kind of expect difference mechanisms to be used There likely won't be the one status mechanism to rule them all. 3. Have to prepare for reuse. So what we did is instead of having the status object. Directly convey the index and URL information, we we Once to answer mechanism that is similar to the confirmation claim. So CNF. Where you have status, and then in a nested object, earthly description of the specific status mechanism. That will allow the reuse of the status claim, in the long run, Next slide, please. I To buy us a sink, you are taking a but that's Yep. Thanks. Can you can you guys hear me? Yes. Okay. Thanks, Alice. So, really, this one's relatively simple, which is, in order to, provide a simpler for, consuming parties of these status lists."
  },
  {
    "startTime": "00:32:00",
    "text": "We've added an option to, place trust basically in TLS rather than an application level signature. And, really, this is akin in some ways to the unsigned authorization metadata option in OAuth 2. And also has some abilities around enabling, statusless repudiation. Next, this one's a slightly bigger change. So so when when a token is, when the status list to itself takes the form of a token. We have Defined a new time to live, claim for both JWT and CWT generally. And we're making that asking our draft to register that claim. And basically, when it's applied to the status list, it enables away, at the token level for a consumer of a status list to know when to check for for updates. The main alternative that was considered was having an absolute time stamp for update shaking. Which was, dismissed because basically it synchronizes refresher update requests for consumers if you have a a, like, a precise time in which the status list is gonna be updates. And a a TTL on the other hand enables communicator reoccurring update and to fill instead of a single point of time without having to re sign the status alerts when there's no update Right? So the diagram down there attempts to sort of communicate that basically you have a token that was probably that was issued at some time, then sometime later a consuming party resolves that status list and then they can from their time of resolution, apply the TTL to that time window to check for updates, up until the token then buyers and the the, the intent with this TTL claim is to is for it to only operate within the, IIT and EXP sort of boundaries. So that's all on that one."
  },
  {
    "startTime": "00:34:01",
    "text": "Next time. 22, Sorry. Are there questions on that? Sorry. So the the next change is, with some will be aware that prior to draft 2, we, signaled that we were going to make the status list itself expressible, in in seaborne And, since a part of draft 2, we've added that in coatings, and this is a bit of a breakdown on the main down the bottom there, you've got the status list and seaborne format. You've got the securing envelope, which is the status as token, applying CWT. Next slide, I think. We have then the reference token. This is a representation in CWT. In diagnostics view, akin somewhat to the JWT representation as much as practically possible. With the noting the differences between JT between CWT. Fundamentally, And then lastly, as Christian said, next slide, We've also got the sorry. If we take a slide, we didn't actually have that as what we've what we've also defined is that for reference tokens that aren't themselves CWTs where, a ISO 18013 part 5 MD is such an example. It is secured using cozysine 1, but itself is not actually a CWT. Would like to be able to reuse this mechanism. We've defined effectively the, Jose sorry, the Siebel data structure that would need to be embedded in such a secured structure for using the status less mechanism. And I will handover, I think. It's Paul. Next slide."
  },
  {
    "startTime": "00:36:01",
    "text": "Thanks to Bice. Okay. So, what follows now is, some conspirations for the future and some discussions that we're currently having first of it is that we want to provide a mechanism for, verifiers 2, fetch, A list of all status lists, you can imagine a police officer loading his, device in the morning with all status lists. For example, for MDLs, so that he could use that for offline verification and, therefore, we need a way to know how on which all the interesting status lists may be the status list provider offers offers and there's different options. That are being discussed, it could be something that is working, as a relative path, like a kind of a path, to the actual status list that contains the structure could be placed in a well known, path or directory. 3rd option is we could at another URL to the status list, claim the reference token, or it could be in the issue a metadata, for example, in I I ACA, file in, in the MLKs or an open ID for BCI metadata, that would be So protocol or ecosystem, specific and the data struct but contains also need to be defined as well. Next slide, please. 2nd, the same that we have is, or identify lists, Or something that's most common out"
  },
  {
    "startTime": "00:38:02",
    "text": "most commonly known as, certificate revocation lists, this was brought up also in the discussions that we have with ISO MDL folks, that are looking into revocation, and Also, other people have come up to us, Now that we've in his status mechanism that allows other status mechanisms. To use the same syntax And, CRLs are the All is well known, Example, for a vacation, So people are looking into this, and, we get the quest whether If we want to add this to the status framework Does this belong into the status list Draft as the site option. Or is it better To start a new IETF. Drop for this. This is something that we would like to get Beg on. This issue is also a little bit Sensitive. Yeah. Next slide, please. And our 3rd discussion is on the INA registration so now we're get a a, registering in your registry for status mechanisms that's working similar to the CNF 1. I would apply both to, closely and cozy world, question is, yeah, do we to create a registry for each, like for both JWT and and CWT you know, documents and Also, question is, does it yeah, fit in there. If we wanna use it for other things that are not Jason WAP tokens or Siebel WAP tokens. And do we"
  },
  {
    "startTime": "00:40:01",
    "text": "Plan to have 1 or 2. Registries, Next slide, other Open topics. That are still open or being discussed. We need to be more precise and more detail on validation roles that will be added in the next one. We also need to add a little bit on security considerations, and we need to provide some more examples and, and have some small fixes especially on the SQL Web token, and we also wanna include an an MDLmdark. Example, There is also a discussion whether status the status object, Well, you should be a rather a header than in the payload. Another discussion is on the authorization for the for the status list. So every relying party or verifier that has seeing that your eye folder status list can patch this, today and tomorrow. And whenever he wants until it is available. And it has been discussed whether We should give guidance on some authorization. Mechanisms there, we more of tend towards dropping these considerations from the spec currently And as a last, also the feedback from last IETF on Prague was that people were interested how the different status mechanisms or replication mechanisms compared to each other We're we're thinking that this maybe does not belong into into our standard, but it might make more sense to have maybe an informational RFC draft that doesn't does this and that could also include then comparison, for example, to status atthestations or"
  },
  {
    "startTime": "00:42:03",
    "text": "to, a CRL or other mechanisms. Yeah. And, That's it. That's it. Okay. Thank you. Any questions on this document? Ori, Hello, Rory Steel. Thanks for the document. The comment about the header versus payload location is sort of interesting to consider you know, just because, you know, when you're looking at the header, you know, maybe you're looking at metadata about the payload maybe if you check the status, you might even decide. I really don't wanna look at the payload based on what I just have detected from status check. So I know, you know, it's typical in in open ID and owe off to sort of blend metadata into the payload and the header. But from a sort of designing modern security formats perspective I like the idea of, like, looking at the header, making decisions, Then looking at the payload, from a design standpoint. So I found that comment interesting, and I I wonder if it's, Is it well supported? Are there others who feel strongly about sort of an ordered processing of the secured information, in credentials based on that. Thanks. I I can probably provide some really, like, a basic sort of response to that. One is, because especially for when the reference token is takes the form of a JWT or CWT, in JWT and and shortly to be the same in in CWT a mechanism that we've actually just standardized. There is the ability to have, like, JWT RFC, CS, JWT claims can exist in both the payload or the header, right, and there is language and treatment for a if if they coexist in in how that should occur because"
  },
  {
    "startTime": "00:44:00",
    "text": "So What I'm what I'm trying to say is by registering a JWT or CWT claim for a reference token, I guess we are leaving it open through the underlying RFCs for where that Claim. Might ultimately exist in the data structure, and I think for examples like SDJWT that would ultimately use this. I believe they're intending to use the payload but I'll maybe leave it to others to to comment to to those pieces. Just one quick reply to that. Like, I, the the CWT claims and header feature is for the CWT case, in the in the case that you were using the CWT claims in or feature and you had CWT claims in the payload, you could possibly have status information in both of them. And that could also sort of be problematic, but I actually really like the potential for CWT claims in header. With status information there, and then possibly also with selective disclosure in CWT claims in header. Sort of coming in the future because the payload is often, like, it's nice to sort of dedicate payload to something that's application specific in some contexts. So Yeah. I agree with what you said. Thanks. I jump in just real quickly to clarify that the JWT spec is not that that flexible in terms of including claims in the headers. It's very specific about the context in the meaning of their usage. So, Not to disagree with the overall. Thought process or anything, but you don't, you don't get that for free by registering in flame, but it it It's it's here to has a totally different intent and and wording. Peter Kussman,"
  },
  {
    "startTime": "00:46:00",
    "text": "First thing, just in terms of the non not signing the status list. It would be good to have some security considerations to give guidance so that implementers understand, the trade off that they're making. Right? It's an efficiency versus security type trade off. We're good to have that And then you had a second, I just wanna make sure I'm it correctly, it it looked like you were asking a question whether the scope of the document should be expanded to include other types of revocation, isms like CRLs, etcetera, or CRL like systems. Did I understand that? Question correctly. Comparison. Combate, sort of a comparison with other mechanisms? a comparison, not as not including additional As Yes. Okay. That 2 different things. Sorry. was One part was that we should have a comparison of the different overall mechanisms, and the proposal was to have an informal RFC for that. Something extra, but the the question came up For example, if you have something like a CLL, what what what but in in CWD or or JOT format, where would we put that? Is it a new draft? Should it be an an additional mechanism in this draft? We were kind of favoring a new draft. But but that question was also brought up to us. Thank you. My my view would be a separate draft, just to keep things clean, would be my recommendation. Christina. Good transition. I was actually on the same topic. I was actually thinking more towards the same draft. In a sense that At least personally, I was hoping that you know, the status list Draft would kind of be you know, OSA shelf, introp option. Like, a stage of obesity, kind of sense. But that is not the direction draft has taken."
  },
  {
    "startTime": "00:48:05",
    "text": "Like, right now, the draft defines an extensibility point, which is the top level status claim, and the you know, because this draft defines that I would at least if the difference is, kind of the content, whether it's, you know, CRO style kind of registration of the you know, credential ready versus the compression, like, gzip, like, the current approach. If that it it it it feels, like, positioning that as two different ways of how the status claim defined in the spec could be extended. Like, I would hate to have to point people to to different places if it's potential, the same mechanism. So Yeah. Sounds like we need more discussion, but Those are my intuition, at least right now. Nick, Hey, Cody. It's Center for Democracy And Technology. I I've recently reviewed a similar, specification in W3C for the bits string status list that I think has some similar properties and some similar quite serious, privacy threats. As you know, in the spec the there's the threat of a malicious issuer who who gives out different status lists a different holders, such that they should work can, to some extent, create a phone home property where they can see when and where holder, presents a credential. And, and and and and and at that doesn't have to be solved right now, but I I am curious if there are, mitigation that we think can be deployed because that that's that's rather a catastrophic risk for for many of the users of this type of technology. And and"
  },
  {
    "startTime": "00:50:00",
    "text": "my my my initial concern is that the relying party or or verifier is not the one that we would typically want to to count on. And and I'm not actually that they could even detect this it is happening. I think that that behavior of a malicious issue in this case is We probably Easily detectable by a relying party that has medium size of credentials. Flowing in, because he can compare the number of different URLs to the amount of credentials that he has seen. And and and That should. Be a pretty good metric to spot that, issue as doing malicious things. So it at least is kind of easily detectable Whether this actually happens, I can't say. But it is, a threat that we've also covered in our press consideration section. Right. I I I see that. It it seems like the issue or can can add dummy values and things to And unless unless the relying party also knows how many people there should be and like, has some detailed information about the entire population of of credentials from the issuer. Yeah. So I think I I I think I just to sort of comment there as well, Nick, like, there is more work for us to describe some more mitigations there such as you know, relying parties being able to based on the herd size of the state us and then to Paul's point that, the number of status lists that are available from that issuer for that kind of credential type"
  },
  {
    "startTime": "00:52:01",
    "text": "and then it does then create a relationship to, well, you have information about the size of the credential herd, because that then allows you to sort of understand whether or not the number of status lists make sense in the context of of the credentials being issued. So I think I think there are some Recommendations we can describe to to make detection somewhat more somewhat more transparent for a loan party, but there are kind of just different trade offs, I guess, when it comes to how these status mechanisms can can reliably shield from different threat models such as a malicious issuer Okay. Thanks. I I would love to keep working on it seems like it's going to come up in multiple settings, and and I think the risk is, is quite severe. Thank you. Thanks. Ray, you 1 last question. Hi. Yes. Ray Ray lets. I'm new to this, discussion On this, I have just a couple of comments that may be useful. Offhand, I didn't see any error detection and correction of these bits. It seems very fragile. You get the index off by 1, and you're gonna get a wrong wrong bit so this this, I would say, from I'm in an auditing field and and so forth. I would consider this a very fragile protocol because it is is easy to break. You get the indexes off. You're a little bit of stale indexes you don't know what the bits are. And I don't see the error correct or the the detection of check bits on that list, but maybe I I don't know, know enough. Thank you. Yeah. If you if you use, digital signature, you would be you would be well protected. If you don't do that, can obviously be Well, it looks like they cashed the indexes. They're supposed to have that. And then now added the mechanism to an unsigned"
  },
  {
    "startTime": "00:54:03",
    "text": "version, which of course can get corrected as it gets canned. So that may be actually a consideration to think about because, cryptographic signature is obviously a good error correction. Or a or a deduction, not correction, mechanism. Yeah. Thank you. So that's, I didn't think about that. But it seems that we have a couple of things or you have identified a couple of open issues, which I we need to work shoes or So that's excellent. I have some thoughts about some of those points, but, we'll discuss them on the list. Do we have some review us in the group. I think this would be, like, we are now at the I would say halfway stage in this document and and having some more eyes on this would be useful. Anyone in the room who would volunteer to do another review of this version which has seen a couple of updates. Nick, you are going to do an review. Sure. That's perfect. Please, note that Nick is going to do a review. Thanks a lot. Okay. Next topic. Give me a second. Yeah. The at the last IETF meeting, we said that we would, Among a couple of interested party to a conference call and and chat offline. Of course, we work time flies, and we were We're guilty not to do that. So apologies for me failing on that, but I hand over to to bias and Paul to talk about the document. Thanks. Yes. Sorry, Hans. I think we're as as guilty as you are. On this one, there have been Lots of. Lots of things"
  },
  {
    "startTime": "00:56:02",
    "text": "to do. We made a lot of progress on status list. Unfortunately, we made a little less progress the attestation based client authentication, But there's a number of discussions that are pretty important way forward that we wanna discuss today. So less progress more, but more of discussions currently. Next slide, please. So, yeah, a little recap would why were you doing this? We Once you do client authentication for clients that are or have been described as as public clients. The motivation for these is also mostly coming from the very health credentials ecosystem where clients are probably Native smartphone, apps, and, we have mechanisms, like play integrity or app a test the device check iOS that may be used to to authenticate these clients and questions, how can they be used in especially in the context, of Vericile credentials or IS issuers of credentials want to make sure that they are, talking do the correct wallet. And so they get some assurance that Some regulated use cases or high assurance credentials that they wanna issue land actually in the correct wallet. And they are protected. Like, using hardware bound keys, kind of these things that you need for regulated use cases. Next slide, please. The These slides are building up very slimy."
  },
  {
    "startTime": "00:58:02",
    "text": "Okay. So progress update there hasn't there have been only minor additions, since IETF product, mostly because there have been extensive discussions, especially on and on the GitHub repo, two things that we wanna discuss, today in particular, first one is a proposal to use, default for the proof of position. Syntax, I'm sir. Client attestation, And the second one, also related, to Johannes, and and the feedback that we got from IETF and product last time. Is that this mechanism that we have being, Defining as a client authenticated mechanism, that's mainly used at the token point, people said they may want to use that at other places at other endpoints. Also, second proposal is to support a header based, syntax, to use, yes. This attestation based client authentication method. For example, for DCR, Next. Slide, please. So I'll show a recap, of what the last or what the current status quo of the draft is we have an example of token, request here, and we provide the authorization code, and then we have the client assertion type, which is using the the the client authentication framework RCs, 7521. And then we have defined line assertion, here in green as a concatenation of 2 JSON Web Tokens The first in green is the client attestation"
  },
  {
    "startTime": "01:00:00",
    "text": "So this this is something that is issued by the client back end, Oh, that's assuring of authenticity of this client, And in this client attestation, there is a public key that is controlled, by a prime instance, and, the client instance, then we'll add a client attestation, proof of possession and orange, and I connected with, lovely to the this is, the status quo currently and, the authorization server We'll check the green client attestation. We'll see that This belongs to a client that he trusts He will check that the The key matches, to, the public key in the client attestation proof of possession. Next slide, please. So Yeah. This is, how the current draft will look like if we would use also this together with depop. So we have, additionally, now here the default header, And, from the use cases where we envision this, it kind of makes It is it seems natural that there might be a depop header or as to say it likely that there is a deeper pattern because we usually we'll use, the client authentication method if we want a high assurance for this a client, And then it makes sense that we also have access token. That's not just an error but also, send a constraint nexus token."
  },
  {
    "startTime": "01:02:05",
    "text": "So, yeah, could we could we do better and and combine these kind of things, and that is where I hand over to tobias. Paul, I think we have a question from Usama in the in the queue. Simon, do you do you want to comment on this specific issue? Yes, please. So, It's more of a question. So on the last slide, you mentioned client attestation. And I'm wondering if it is what you meant here from the is, I think, the evidence it correct? Yeah. So the terminology between red and, OAuth Mostly because we also come from the verifiable credentials ecosystem where where the verifier is something completely different from what a verifier is in in rats terms we also have an open issue to kind of make a translation between rats terminology and and the one that we're using in and the and ecosystem. But I do believe so. Yes. I mean, I mean, this is not my fault of the very I'm so honored to answer your question. I think in this context, This would be the attestation result I believe Okay. Yeah. The the that's what I wanted just clarify because, evidence and attestation result, it could mean anything. So so it's it would be nice to have if the terminology synchronize with the rights perspective. Thanks. Yep. Justin? Your their their Okay. It's on it's on a different issue. Okay. Perfect. Yeah. Yeah. Yeah. It's a this is a a to be done. Okay."
  },
  {
    "startTime": "01:04:01",
    "text": "Paul, do you want to continue here? On this slide, I I'll take over from the next slide. Okay. Now I have dem. Western. Okay. Which is continue and then have a have to queue. Okay. Cool. So we we've identified that many of the use cases, at least when this draft was first conceived, which about a client authentication mechanism, and we'll cover some of the broader cases around ECR usage and those sorts of things later on in this slide deck. But for those use cases we expect, that this will will be used with depot bound access tokens, and and therefore, the need to make this work well with Deepak. As we think is quite important depop already defines a a fit for purpose, proof of possession, syntax. Putting notes management, which our draft is effectively reinventing. We also realized through, some contribution from some of the editors from Deepak that the the depot, Proof of possession syntax can actually be reused without requiring the AS a issue. A depop bound access token in response, because that that is reserved for the AS to make the decision, even if there is a depop header in a token request, doesn't necessitate the fact that the client will get, a Deepot bound access token and response. And then the draft, We believe this draft is actually really useful in the context of depop. To address something that was out of scope for default, which the ability to authenticate depop key back to the client. So I've filed issue 69 with a with a case to sort of describe that more. But, basically, with this mechanism in play 8888"
  },
  {
    "startTime": "01:06:01",
    "text": "in the proposal we have, you would be able to authenticate that the depot key is is appropriately authenticated by the client next slide. So this was another one that was raised in the last IETF meeting, Prague with some people also asking, well, I could quite like be able to use this air test station mechanism, in other places other than just for client authentication purposes, such as I may want to present this attestation towards a resource server, And, also, I may want to use this attestation a part of a, dynamic client registration request And in order to sort of do this, we considered the sister, whether or not we could shift this attestation information out of being, present and say the token request but instead into headers. Next slide. So this is, really a proposal based on those kind of 2 observations so you'll see now that the the client at the station pop, would be in effect conveyed by the depop Pop. Pop. In a in a heater, and then we would have a new hitter, which communicates the client attestation and so you've still got the relationship between the client attestation and the client attestation pop but that conveyed, through Hida. Instead of, through payload elements as defined through RFC 7523. And then lastly down the bottom, which is still something we were considering, is this client attestation, assertion type could be present if you were using VHSA shifts as a client authentication. And that's a separate concern about whether or not we would"
  },
  {
    "startTime": "01:08:03",
    "text": "define that or whether or not we would consider our gestation. Differently with, you know, the current view is we we do think that this fits the client authentication model but perhaps not exclusively. Perhaps there are other model, other usages of this safety station scheme for purposes other than just exclusively client attestation. So Sorry. Next slide, please. So the the discussion for the group that we wanted to sort of feedback to this working group is that The trade off with this proposal is that the depop key and the client instance key must be the same in this proposal. Which can be viewed as both a useful simplification and a constraint depending on perspectives. And we wanted to ask the working group whether or not they have an opinion on this. Are there practical use cases where the Deepak key and client instance key need to be different? Or does the complexity it create is is kind of more hassle than it's worth because, if we if we sort of, remind ourselves of the proposal there. Paul introduced, which is when this draft is using with DeepOp. Would then affect get 3 signatures, and say a token request, a a default when when you're using this mechanism with with depotbound access tokens. And just calling out that this issue is relatively time sensitive given a, an interoperability event in in late April kinda wanna use this use this draft, with DeepOp as well. So if we don't optimize this, it'll be a much more complicated implementation part. With that. I think there's a acute forming, so I might, yeah, Yeah. I was about to say that the queue is building up. So you I think you touched on a few interesting points. Justin, let's get started. Hi, Justin Richard. First off, yeah, client attestation is not client authentication."
  },
  {
    "startTime": "01:10:03",
    "text": "Full stop. It's not. It's a different thing. And it needs to not be crammed into client authentication, not only because we wanna use it where but semantics are important. And we should be making a strong statement here about when we're presenting this that we are talking about something that is working at a different plane of existence. And I think that the, the, the separate header proposal or something like that, that would capture this separately would be it would go a long way to addressing a lot of the concerns that I have in the Except for the other concern that I have, And that is that the where we're getting several different efforts that are putting squigglies in our jots in order to, it it tie them together. And I just have a really bad gut feeling about that. Somebody's going to cram one of these defined objects into an SG jot parser and have some weird collision failure thing that we haven't anticipated yet. Don't have an attack like that in my pocket, but we're coming up with similar syntax is to say, no, this is different. But they look really similar, from a Lexi perspective. And That's usually a recipe for things to go wrong. Yeah. So I just can I can I just also ask there? Because the proposal that we've put on the table wouldn't involve, a squidly, because we would have 2 separate headers that become related together. And could I just ask if you had any feedback on whether or not you reusing the depot as a proof of possession syntax rather than a separate header like this, separating the client instance key from the depot key, whether or not you think that is a good or or a bad idea? I would need to read the proposal before having a a a proper, response to that. But"
  },
  {
    "startTime": "01:12:02",
    "text": "Like, depop is really meant to be instance keys And I think that trying to reuse the depot header for something that's actually not asking for token or doing a depot possession is a really bad idea. Whether we reuse the presentation syntax and put it in a different semantical context. That's that's that's a different thing. You know, there's, there's a lot of ways to kind of cram this type of information into an HTTP request. But, I would not use the depot headers unless you're actually doing depot Brian, Okay. Counterpoint, to that is the depop. The depop header itself is for for possession of an instance key. This is also wanting proof of possession, printed, some key and the depop mechanism of itself defines this non exchange that is currently under specified in the construction here, and it's gonna be kind of, a pain to re specify through this and then and include application. Using 2 different headers, whether it's Deepak or not does address your squiggly concerns, so that I think it would go towards that direction. I have a bunch of different notes. I'm sorry. I'm not a and it back to client authentication. I understand why all this structured on and built on top of, 7521. It kinda makes sense. But at it's really not actually necessary. So even if you wanted to use these these 2 new headers for client authentication, you can define a client authentication mechanism straight up using the headers and just say that's how it does So even though I'd I'm I was involved in 7521. I love to see its legacy lived on. It's not needed in this. And I think it'd probably be better off just to do the headers. And if you want client authentication, just say this is the don't know, whatever you wanna call it, but you don't need to try to reuse the assertion framework and not get simple buy some of that structure you had at the bottom there. Yeah."
  },
  {
    "startTime": "01:14:02",
    "text": "I think that's all I got. Sorry. Thanks. Thank you. Yeah. Yeah. Just fine. Well, thank you. Justin Richard, and just wanted to wanted to question if it really is an instance key in the same way. Because, like, a key that's been attested to by a party versus a key that's being presented as, like, use step, I think, are saying different things. Now if we dig into this and agree that, yeah, they really are close enough. We should use that fine, but this needs to be a deliberate decision we make and not reusing that convenience syntax. Like, get it. Depop does a lot of great stuff in making that work. And reusing that structure where we can makes sense. I caution us on reusing the semantics in a way that doesn't, doesn't map as well. Good thoughts. Yep. Yeah. Yeah. I think that maps directly to the first question here about the trade off between the two. Yep. Yep. Aaron. Yeah. Hi. Aaron Broockey. Geez, I'll try to be quick. First, for listening to all the feedback on the just on the previous discussions. I I really like the the header approach to this. I actually had written up this this this a header like this in in the my notes for this session. So that's great that you came to the same conclusion. I also agree with avoiding swigglies. This one Put that up there. On the the key, the duplicate or the key issue, I agree that if it's not if it's not actually a depop key. It probably doesn't make sense to use a depop header. One because overloading stuff is is not usually a good idea, but, too, because If somebody is expecting to process the depot header, for depop. In this end in an endpoint already, and then they're now trying to layer this on."
  },
  {
    "startTime": "01:16:03",
    "text": "For a new use case to an existing system, Now you have to treat the depot header meaning 2 different things. Which is gonna which is gonna be a mess. So I'm trying to think of this as You can get away with a lot of stuff if it's a greenfield deployment. When you're trying to go in with to an existing system and add this layer then you end up with a lot of these weird situations. So I would, I would, I would, I would, rather, rather keep it clean. So if the instance key really is the key and it's used as depop, then You can use the depot header for that. Plus the attestation header. If it's not Really, the Deepop key, and you have a separate Deepop key, Then you could even add a third header, which is the at the station Top. Key. I don't remember the name of it now, but, like, there's no harm in it. If you if you really do have 2 separate keys for it for it At that point, you might as well put that put that extra proof of possession in another header. Instead of squiggly. Great, great, great, great, and then you keep the depop header clean for for depot processing yeah, I think that was it. Thanks. I Take care. As we switch over to Christina, I want to caution to think that this is really greenfield because you have to rely on existing attestation technology to make is meaningful. So and there's there's some sort of nuances with each of those technologies. But Christina, go for it. Yeah. Super quickly, basically plus 1 to Justin and Aaron Hessmazang, just wanted to go on record that you're reusing the same key for JP Pop in this client at the a very specific scenario. Which shouldn't be forced on everyone. In partially booting up to what I think Aaron said, There are implementations for using only MTLs for token binding. We're no combining at all, enforcing those implementations to process a default header doesn't make sense to me and feels like"
  },
  {
    "startTime": "01:18:03",
    "text": "over overload. So I think I hope this topic keeps coming up. So I hope at least a debottleneck we could you know, like, agree on the direction finally. Perfect. Yeah. Yeah. Sorry. We ran totally a lot of time. But Great. Great presentation. You raised a lot of issues. I hope our note take, I was able actually to catch up, looking at him and he's kind of, shaking his head a little bit. So Yeah. Okay. Thanks. Thanks, guys. That was really great. Now, Ori, nons endpoint and status lattice stations. Alright. Hello. Is Hello. I'm Maurice Steele, and I'm, my co author Giuseppe. Oh, thank you. Is, with us in chat. And, hopefully, we'll interrupt, I, as we go through this, we've got 2 documents. We're gonna present back back in the same deck. There's a connection to them. We can get into that. Does that be anytime you wanna interrupt, just go ahead. Wish you were here. I'll try and make make make make Big hand gestures, I guess, is, like, I don't know. That's Awesome. So let's get into it. So why the nonce is important. So, there's lots of cases where you need these. You need a unique one time use number or string. It ensures that each transaction request is unique. Protects against replay attacks by making each request verifiable, unique."
  },
  {
    "startTime": "01:20:00",
    "text": "And I think you've already seen several presentations today where a nonce is a you know, important part of those interactions So what's the not's endpoint? This is It's an endpoint. You get an odds from it. It's a lot of text, but this is basically what it's saying here. So it's a restful endpoint for issuing responses, And we could get really hung up on, you know, what exactly is issuing mean. Kind of depends on, What kind of opaque string or number you're getting? It's, usable in OAuth 2 and any other protocols that require issuance nonsense and This is a, I think, a really important point of the design of this document that I like personally because It's a very simple document. It does one thing. And that one thing is useful, to many other things, including OAuth. So this non stem point could be protected could be unprotected, obviously unprotected HTTP endpoints that serve important information. Have special security considerations, we'll need to think about, Can, it overcomes integrating the provisioning error pattern, which we see in specifications like like, depop, basically. I'm not sure if there's other, protocols or specifications that kinda make use of the, this pattern of, I'm, you know, I'm presenting something to you and it was important that I have some freshness proof, some, some nonsense part of this. And My way of delivering this to you is you just give me something that is gonna give you an error back, and then I use the error to hand you back the, the nonce that you will then use complete a successful transaction, there's a little bit of, sort of API design, aesthetics, taste, comments, sort of hidden in in this this piece, we we can definitely discuss that. And it could be used, with public audiences for internal infrastructure as a micro missile. Deployment, comment."
  },
  {
    "startTime": "01:22:00",
    "text": "So, what does this non Semp point do? Well, basically said it several times, and, hopefully, you were imagining something that sort of looks like this. So, on the left hand side for me, It you can see there's, a get endpoint that has no query string parameters. And it's returning a simple month, and it's the non system content type application, Jason. You can imagine maybe you negotiate for something other than that, I suppose. And then on the right hand side, For me, you get, the query string parameters, scope, pizza. And audience, Mario, viser, not choices that I made for this example, but I think they highlight an important property of nonsense, which is that they're always requested and used in some context. So, you know, how do you communicate that context? There's lots of ways you could do it. You know, we were just talking about http, header parameters. That's another place where you can shove a bunch of context into a request. So, When is it the right thing When when is the right time to use a query parameter and when's the right time to use a header parameter and, you know, could get into a longer conversation around that piece, but think the important part here is, like, 2 of the pieces of contact that are really important to consider when you're thinking about designing system for nonces is what scope and what audience. So, why do it? Well, I've mentioned this cleaner API motivation, scenario, I mentioned, there's many other, protocols out there that want a simple knots endpoint that they can just plug into their part of protocol where they need to be able to provision these nonces and then achieve them. The non design considerations can be useful, for considering privacy and security issues. You not just, you know, for for all of these different cases, like,"
  },
  {
    "startTime": "01:24:03",
    "text": "when would you want an encrypted knot? When would you wanna sign 1? When would you want a uniform random one. When you would you want you know, Mac based, like, there's all kinds of different considerations that you might use in the construction and being able to think about that in a really simple document. That seems like a, a good thing that we can, we can actually get into some depth around that because documents basically just about one thing. And protecting non sent points, you know, may be an opportunity to create new flows, Giuseppe, I don't know if you're, available, but I might ask you to expand a bit on this last one. I'm not sure fully Understand the the thought process behind this other than nonsense are often the the jumping off point for particular interaction in a in a given context. Welcome. We have your video. We don't have your yet. audio You hear me? 4, 5. We do not hear you. We don't hear you. No. Okay. Yeah. Oh, so wow. It's quite here. Que quite late in Italy. Everybody is late for the well, can you hear me now? Yes. Yes. Yes. Well, the the the last point, the It's something that opens the the opportunity. Since, you know, endpoint is just an endpoint. Outside of any monolithic call. View or implementation, or you just have the notes so you can So it protected or unprotected. So considering that this endpoint might be protected Well, several. We may have several new flows, several new opportunities, several fix Easter some."
  },
  {
    "startTime": "01:26:00",
    "text": "A piece, a piece that can be using different contexts for different scopes, scopes, even outside of the current implementation we made in Italy for the political system. In particular between the world assistance and the world provider. Probably this won't help the discussion already. So, you. Bob I Yep. understand now. Thank Thank you Thanks. I had one question because you you were saying it can be used for all sorts of purposes, but the concept of, scope and an audience is something that is or specific, And for example, like, here, you say it can be used for rats. Rats has some other needs. For example, some attestation technologies use require a not just to be of specific size So you need to pass information in about the either the size directly or the information about the attestation technology. And so like the subtle differences between the way how security protocols use nonsense in different applications and I think just saying, oh, might just use the non is it's apparently Is, like, As is, I couldn't use it for rats. Yeah. I think that's that's true. Kinda piggybacking on what Giuseppe was saying on the protecting the non standpoint, you know, it opens opportunities to create new flows. Some of the ways in which you might protect the non standpoint could be part of what enables the knots to be used in some of those other flows. And scope and audience, you know, I don't think of them as being limited to a law I think of them as is is concepts that are echoed in protocols that that need that that need that that need that. And that have a concrete, you know, instantiation and OAuth, but that you see initial used in other places. As well. I think It this is what's dangerous about this draft is, like, imagining kind of a an abs dracked."
  },
  {
    "startTime": "01:28:02",
    "text": "Concept of a nonce. And depending on how you deliver the document, you could get into a lot trouble with that so I think There's, Yeah. There's there's risks associated with it, but I think a well designed document, there could be a lot fit as well. Week, Ray. This looks a lot like the nest ramnest Beacon, service. And, that was actually pretty hard to design. Such that the Random numbers could not be, you know, generation could not be infiltrated. To have a couple of different ones and they had to be So so actually designing a random number generator that would be a service. Is not, as well, we recommend looking at that that, if for people that don't know, generates a random number every like, like, like, like, like, minute or something. Or a second. And you can go and get it. And so you can say, let's use a random number at this certain time. And, then you can both look at it and see this at the Sarah. So, anyway, It It's what you're talking about here, I think, is sort of a non trivial thing to to make it be secure. You post a link? Into the chat window? Yes. Thank you. I Peter, Peter Castleman, The I've a couple of observations 1, this feels I'm not entirely sure how I would necessarily use this non service because it's often useful to have that non in the context of a transaction having an extra end point to go call, etcetera. Right? There's sort of efficiency issues that we run into. So it's it's not quite clear, but I do wonder if there is perhaps a desire or a benefit having a document that describes how to generate good nonsense. And that may already exist in other forums, but maybe that is a thing that is helpful to protocol designers. Is here are ways in which you know, how you should think about a nouns in terms of"
  },
  {
    "startTime": "01:30:00",
    "text": "a good design, That may be, you know, I think the desire here is let's turn up an endpoint, and now you can get good quality answers. You can use them in different places, but maybe just giving guidance on quite a good quality nonsense might be more useful. Just a just a thought. Yeah. Thank you. I mean, I objective is sort of twofold. the You know, primary objectives actually to do what you're saying, which is give guidance on generating good quality for use cases. Secondary objective is to, to give at least one easy way to access it for protocols that already have HTTP sort of as part of them. Frank, I'd I wanted to maybe just provide a little bit of defense or account argument to the no provisioning by error, like, some of the existing non and actually the only nonsense really in OAuth level protocol right now is provisioning by error, but you also think of it as like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, like, a, more typical challenge response mechanism that's delivering the notes in the context of the request that you're actually needing it for. So Yeah. So it's like you're kind of, in, in those scenarios, you're hijacking the context that's coming in from from the the caller and using it as part of scope mechanism and then handing back the knots that they need to satisfy the request. So you're saying, you know, and challenge response, and there's also mechanisms to deliver a new non the context of a successful transaction to continue doing it. So And that's not provisioning by error. That's like this request exceeded, and here's your next notes. Yeah. It's and they're kinda combined, and it it's not the prettiest thing in the world, but it's also not, I don't know, maybe as terrible as it's being portrayed in in this, Do you want me to say worse things about it? Sure. Now, I'm and it would be it would be difficult to, I think, it's a it also exists, Potentially difficult and confusing to try to reconcile it with a a new mechanism for for obtaining For protocols that are bound to HTTP that are doing depop? Like, yeah, I don't think they"
  },
  {
    "startTime": "01:32:04",
    "text": "as a replacement for them. I also think DPA being down to KTP caused other problems. And so, I think it's it's worth considering a modular approach here. But I I I agree with your point. Alright. Or we do we join the queue? Yeah, 2 more chest and, Mike, and then Justin Richard. So I can only speak to my own limited experience in ignorance, but makes absolutely 0 sense to me to exist. The whole point of announced as built into just about any protocol is that it sort of inherits the context in which it is presented or generated. This is taking a self asserted context and saying attach the nonce to that, And then hope that that context is still true somewhere else. Additionally, as Brian was kind of pointing out, Nonsense get generated by multiple parties. Would we expect a client and an AS to call a, independent nonsense point to get the same Nantz, And how do they how do they reconcile that? Because in some cases, like, We're gonna have client and RS applications that are generating their own bits for themselves versus for others? Like, where's where's the good guidance for doing things like that. Yeah. But ultimately, it's the divorcing of the generation from the context in which it is meaningful that really worries me about this. I, I think that this is an exercise in premature of extraction, and it's going to be, it's going to be a net negative to protocols that are built on top of I do not think that we should be doing this. Thank you. Mike, Chargebee."
  },
  {
    "startTime": "01:34:07",
    "text": "I'm responding mainly to a comment that Brian just made. There is another context in OAuth World. Which is when you're using OpenID connect on top of OAuth. The OAuth client, aka, the connect rp, as a parameter, in the OAuth request. Called Nantz, that it provides a nonce to the authorization server aka. The open ID provider. Which is echoed back in The ID token. And that Yeah. Noncomparison@theclientaka the RP is used to prevent substitution attacks. That otherwise, would be feasible And if if I'm not mistaken, that mechanism's also used by, like, open pub key and other extensions that are built on top of, sort of cleverly reusing protocols that weren't originally considering what the non for day, I don't know if anyone here is familiar with the open pub key or some of the other code signing sort of use cases for, clever reuse of OAF protocols, but it does happen. Believable. I don't I'm not an expert in the Thank you. That's I was I was actually, like, Because you have way more to about idea of, like, the real thing. You wanna Take us along? Yeah. Like, Aaron and and Brian, is it okay if we advancing and, because I want to make sure that or we get through his his text. Okay. Let's, Erin, Can we postpone this for a second? Wait."
  },
  {
    "startTime": "01:36:01",
    "text": "Okay. Alright. Alright. So what's the status of the document? It's a 00. So I'm glad we're getting great feedback here. There's been discussion with other groups, you know, particularly has use cases where it needs to you know, the the skit sort of HTTP API for interacting with a transparency service needs to have a way of provisioning non isn't. It doesn't really make sense to use DeepOp for that. But maybe it does We'd love to talk with folks about that particular use case offline. Rats had a discussion about nonces, honest is sort of aware of it. You know, I don't think the the current document is a drop in thing for that use case, but, there was some good discussion It's at it's fairly straightforward, but, you know, I wanna echo what Justin said, like, you know, This could just be, like, to abstract and not fitted to a specific protocol use case and, you know, I still think that giving good security guidance on designing nonces in a simple document is a win for everybody, but, maybe the HTTP part is, is a loss for everybody. Yeah. Could could be. It'd be good to to chat more about it. I'm gonna Keep going. No. Keep going. No. Next steps, So, like, as I said, like, we're encouraging the use of this particular endpoint beyond OAuth since it's, it's not particularly bound to OAuth. You know, I'm also mentioning those other cases where, you know, pieces of all other open ID connect get used in other contexts. Interested in support for multiple payload formats, not just Jason. You probably know this. I'm not really a huge Jason fan anymore or was before I'm now I'm kind of like a seabor fan. So I'd love to see the seaborne and cozyser variant versions of these, and they're they're smaller. And then, you know, security guidance around, random nonces signed noces encrypted noces,"
  },
  {
    "startTime": "01:38:03",
    "text": "and then, you know, encrypted with what, signed with what, you know, you know, all of those fun fun security guidance around relatively simple concept, but we can kinda go deep if it's small document, use cases, we're gonna talk about one of them in a second. The arc architecture sort of layering strategy, the monolith versus modular comment new directions. So It's an idea, like, Keep throwing rocks at it. That's super helpful. That's it for this the This That document Jeez EPI and I are also on another document, which I'm here to present back to back. Do you want me to just go go. Alright. I wanna make sure I get through all the time. We have an another coauthor on this doc in document, Francesca Mariano, prime doing terrible on that name. I apologize. Hopefully, you're You're here with us in spirit. Right. So there's OAuth, month OAuth status at the stations, would have been good to actually maybe even flip the order of this since you're all just now so aware of what the status mechanism is and the use cases for the the bit string status listing quotes, which is really what the index status list that we just looked at is doing. And so this document is conceptually providing a sim it's providing a similar, mechanism in credential state But it's, you know, different from, like, a CRL. It's more like OCSP stapling. And, we're gonna kinda get into those details. And, of course, it has the word attestation, and then not response pull for OAuth and rats, failing to align on the use of the word attestation. Next slide. Which I can do. So what's what's the status attestation? So it's assigned, artifact like JWT demonstrating the validity of a credential"
  },
  {
    "startTime": "01:40:01",
    "text": "ensuring it hasn't been revoked or expired. It's, issued by the same issue of the digital credential or you know, you know, And and yeah. And so, basically, This part right here, If you think about the document that you just looked at, where you're, I'm as a as a whole As a verifier, I'm calling out fetching a resource that is a list of many different statuses, for many different credentials, imagine a version of that where that verifier was forbidden for making network requests to arbitrary websites. The holder Instead might have done that, and the holder could have presented that status list directly. To the verifier. But the problem would then be the holder is presenting statuses for many credentials that aren't relevant, relevant, to the holder and their credential. So then imagine that you collapse that all the way down to 1, Just the status at the station for the credential that's relevant to the holder. That's sort of what this is. And, It's sort of, you know, the nice feature about is this basically inviting, verifiers like don't make network requests to get status lists over the network. But as I just said, you can still use the status list when a holder presents the full status list directly. So This is, you know, it's also just sort of a simplification of conceptually what's achieved for a credential presentation with some dynamic state, made by a holder. And, What I like to think about for this is, like, it's really just about dynamic state, and offline presentation. That's what this is about. And that offline presentation piece is important the simplification around not having, verify or make a fetch request to get state It's also an important characteristic Right. So I've been kinda getting into the the details around this. So the I'm this enhances privacy piece like Nick was"
  },
  {
    "startTime": "01:42:02",
    "text": "you know, challenging on the, on the last presentation, in a bit string status list of some very large size filled with dummy values where the dummy values are twinkling in some way, there are channels that are available in that that you can encode information. And so it's just a slightly more complicated assembly of information, and you have to consider the privacy implications the, you know, honest participation of the protocol actors and all of that other stuff. From a security standpoint, I like to design something where, like, if there's a a channel that can be a covert channel. I like to, like, call it out then, like, say, are we okay with that or not? And so there is a this approach kinda gives us a different way of thinking about presenting dynamic state as a holder for a given credential. But because the holder needs to, obtain this at the station at a regular time interval. From the issuer so that, you know, I get it this morning. And when I'm later you know, buying, coffee with my digital driver's license, they'll hand me my coffee back, and they know that the license isn't revoked, Maybe I got it in the morning, and I presented it a few hours later. The issuer is sort of able to control that time window for refresh on the ads status attestation. And if I make that super short and kind of, like, planting, and auger in the ground and connecting that to the holder. Keep coming back to me to prove your status and revoke. Right? It hasn't it has The validity period of credentials and dynamic state about credentials have an impact on privacy and traceability of credential subjects and holders, So these app this a this has applications that are beyond just like personal human credential use cases. You can do this for legal entity documentation, supply chain, you know, trade documentation, devices,"
  },
  {
    "startTime": "01:44:02",
    "text": "you know, smart cars, like all these other, you know, non, non person entity credential use cases where you might be maybe more okay to have that that that that trade off between the validity period of the credential, and, the dynamic state associated with it. I mentioned offline presentation use case. I hope that's obvious, but I'm happy to talk more about it. That's take questions. K. So, like, from the presentations, today also, I'm I'm getting the impression that to a certain extent, we are restandardizing some of the peaches mechanism for revocation and status of the credentials in JSON in Plus CBOR format. Yes. And CBOR. And the question is, like, is it CRLs were mentioned status lists has been proposed in the past for for X5 for 9 certificates. Now we have, this one which mimics OCSP, maybe the you have a version of OCSP stapling, And and, like, How do we want that? Like, the the question to be, like, if we can it? we stop ourselves from doing Well, like, having a, being aware that we are doing that and saying, We want to do that. I think that would be an important takeaway for and myself in terms of, sharing and managing the the expectations and and also reaching out to the community who We have existing community in the IETF, obviously, before a lot of experience in deploying that technology. So we could actually leverage some of that experience. Agreed. Hi, Marty Weisman. Wanna speak up this time and about the terminology, and I think Justin's right terminology is right. It's not overloading the term at this station. I think it's confusing enough. I'll be giving a tutorial on it. In about 15 minutes."
  },
  {
    "startTime": "01:46:01",
    "text": "Just to advertise that, but I don't think this is at this station. In my realm and definition about those station. Give me a document that sorts this out between OAuth and rats. Some would somebody do it, please. Not me. A a a good work project. Thank you. I agree. John. John Bradley. All I'm just happy. The So I like the idea of validity stapling, whatever we want to call it. The the Thing is If The query by, let's say, a wallet to get the thing that says whether or not it's valid When it's presented to the verifier, if the verifier Like, if you have a bat a cooling verifier or an issuer, and the verifier has enough information to also query the validity we haven't actually achieved anything. So Yeah. So Unless we had come up with a way of blinding the ability for the verifier to query the validity. I don't know that this actually buys us much. But if we can actually have a way of blinding the verifier to be able to directly query I think maybe there's something to it. Okay. So I think, yep, One comment I would make is, like, oblivious HTTP obviously, could be used in the fetching case for the, the other status list mechanism that support fetching. And this one, you also have a place where you, you could put HTB if you wanted, but you're gonna be passing, basically a proof of possession of a credential that you're requesting of validity updated ability information for. You're gonna end up"
  },
  {
    "startTime": "01:48:00",
    "text": "And, removing some of the the purpose of making things oblivious in doing that, whether you're getting other network, advantages, you know, we could talk more about it. Yeah. So this is kinda what it looks like. You saw in the previous presentation, they had taken this confirmation claim a sort of type approach. So here's a status and here's a status attestation. They had a status and then they had a status list. We can be friends. We don't have to fight over which status list mechanism is better than the other. There's space for both of us inside of the status attribute. Regardless of whether you do JWT or CWT. This is what we're just talking about. Like, how do you get one of these things? And this is a place where you might need to have a nonce in order to participate in some flow, and I'm not a depop expert. I'm actually just here presenting because Giuseppe's here. And I I care about the use use cases for this and seabor credential space, but you guys are the how to use HTTP well and credentials prose, So and this is a straw man. This is how Holder could request the status attestation They're basically gonna make their request, and they're gonna passed their credential proof of possession for their digital credential. And that's how they're gonna get their status at the station, and they're gonna be able to staple that into their next presentation to prove now. I have a, authorization to transport this truck of goods across a border, and it hasn't been revoked because of some change within my supply chain partners within the last five minutes. That timing information piece is really important for, for these use cases. So you you, you may require some newer information than you, you were certified No. No. No. No. No. No. No. 5 years ago. Okay."
  },
  {
    "startTime": "01:50:02",
    "text": "Paul, we ran out of time here, but I quickly wanted to ask the group about the on how many people have read, the document just to get a sense of where we are if this is this new stuff, but but we have been working on the status list for a little while already. We have been talking about that sort of whole problem space. So let me ask, How many Have you read? Have you read the Well, so I just I just or the the attestation? What what is the name? Man OAuth status. The draft. Probably needs a better name. I this is correct. Yeah. Okay. Like, I it looks like, like, just from the from the count, like, are. I I think he would be good to why I would like to encourage you? To take a look at this document. I it looks like the whole problem area is is interesting and relevant to the work post in in hours for these VC like type of things but also relevant for spice And so have a look at it, make up your mind, suggest maybe, provide some feedback on the list about the design approach. I'm sure you have opinion. And, we see how we take it from there. Thank you. Cool. And then we had one document that was sent to us, a case on fine print access. Some"
  },
  {
    "startTime": "01:52:02",
    "text": "And, Kenya, you are going to percent Hello, everyone. I We can hear you Oh, I'm John India, IT development engineer representing China Unicom It's my first time Italian IETF meeting. I'm really excited to be here and looking forward to learnings from you up. Let's begin with a look at flight. Which outlines the main objectives of our discussion today. The kettle of our document is Jason Fine Green Access. First of all, let me introduce the significance traditional access control method such as role based access control. And the attributes at face to access control Although protecting data security to some extent, Gradually show their limitation when dealing with come back and the dynamic data access requirement. To address this issue, The speaker proposes, Jason Frank Win access control master. That can be applied to various scenarios. Such as web service, cloud, computing, and the the internet of things. Left. This, like, I would like to briefly introduce the data structure, we have established This is based fine green access control data format. It's a standard light. Form a use to initiate access request to access control systems. When they consist of JSON object, that contains a requested to request access results and there are fast growing excess conditions. Request ID is the identifier of request subject is the identifier representing the access subject subject."
  },
  {
    "startTime": "01:54:02",
    "text": "Operation indicates the action identifier of request body. Such as grid red update and so on. Resolved indicates the identifier of access resource. Condition refers to fragrant attributes of access subject. On the next slide, Next slide, we'll break down the proposed implementation for that's that's into the achievements that the class send authentication information to the saw and the results, GWT Talker, the request sent by the client include the token and the Hello of token contains information about the Accessing subject. Access resource and, attributes. The results, sir, was that Franklin access control policies. For different resource, which are represented and access control tree. The results were generous public parameters and a master key with suffer, text, policy attributes based encryption algorithm It's then creates a private key based on the master key and the current attributes. Send it to the clot. The server securely starts this parameters. And is the key proof We weren't. Authorized access. And the cell will verify the validity of took have this the payload information and extract the access information and the to rebuild information. That's a slide, please. Based on the extracted information and the create a fun access control policy. It is determined whether there is corresponding policy. If there is the access conditions are checked to see"
  },
  {
    "startTime": "01:56:00",
    "text": "If they are not, if the conditions are my access Access is wanted. Otherwise, access is not And the results are increase the requested resources using the algorithm. The encryption process utilizes public parameters and the access control policy. Corresponding to the access resource, resource, the encrypted ciphertext is sent back to the clot. After receiving the separate tax the client's secret decreps it using the private key and the public parameters. The clock verifies what's up in that only when the attribute is the attribute set which is a access control policy can be accessed yourself. Speak his encrypted. The bow is all the content of the draft. Thank you for listening. You have any suggestion or comments about the dropped, Yep. Thanks link. Ying Ling, for a presentation. I I posted the link into the chat window, for a document that is, you know, from a different working group that may be relevant or at least related to what you are trying to do. You might have a want to take a look at that one Are there other comments to the proposal. Chim just jump through the mic. Hi, Ralph Barrag. I just had some questions. What's the difference between this and say the Raire ritual authorization 1st spec and model in terms of the various different attributes. Question was how was this different to the Rah, quack quack quack, or how does it relate to the RAV specification I don't know if you've, there was just"
  },
  {
    "startTime": "01:58:02",
    "text": "Dema posted it into the chat window Atul, Yeah. I think, this is a very broad proposal because it covers sort of the format. It covers sort of processing rules about how to generate these things, you know, how to encrypt them and also or to use them in specific situations. I think does it make sense to sort of break it up and also, there's a lot of other work going on for example, in the OpenID Foundation's odds and working group. Which deals with like, that whole working group is probably all about what this one single proposal is about. So I think just worried a little bit about the complexity of this whole thing. And whether it can be captured effectively in in one proposal. K, k, So so you know, excellent feedback, yielding. I I I guess you will have to look at some of the documents that people are proposals that, Some people mentioned, I see Khalia just posted another one. Another relevant, effort to a protocol, So so there's a lot of, other work that relates to what you are doing. So, Yeah. Anyway, thanks for the proposal, and we always like to get input from newcomers And this, IETF newcomers to this field. So Thanks a lot. This concludes our meeting for today, and we see each other tomorrow. For our final meeting to, and we still have a bunch of presentation. So looking forward to see you tomorrow. Thank you. The intermeeting, Christina, that will we will run a dual poll to just find out what the most most convenient date is that people can event,"
  },
  {
    "startTime": "02:00:06",
    "text": "By reefer, I was height when Hey."
  }
]
