[
  {
    "startTime": "00:00:04",
    "text": "foreign make sure we don't have any permissions issues sure I was gonna get uh okay the screen share appears to be successful on my site excellent okay I'll stop that you go back to your at your slides all right I am hoping that I have successfully uploaded your latest slides it's you'll be off by minor points if at all so it's not a big deal I'm sorry repeat okay um Welcome to our uh June interim of the netwad working group I'm Lou Berger we also have here uh Jason Stern and Kent Watson my co-chair Jason's our secretary and um if we run into problems Jason I'm hoping you can help with that uh we also uh well get into the rest of the moment this is a formal ietf meeting that means our usual note well applies hopefully"
  },
  {
    "startTime": "00:02:02",
    "text": "everyone is familiar with it I see most people here have been around for a little while so or if you're not familiar with it please take a look at the ITF page and look at the note well basically it says everything we do here becomes part of our permanent and public record um we're using meat Echo if you're on the on here you figure that out thank you please do help with uh note taking um notes would be good to capture discussion particularly sort of summarizing interesting discussion points uh The Helpful you do not need to copy down anything that's on the slots um material has been posted I just did an update to the bgp slides I'm hoping that that is the we'll be able to share the right person we really only have two topics um interesting that's supposed to be five minutes but I'm going to shortened to four and I'll see if I can do it in three yeah the intro is simply what you're hearing right now and the rest of the time is going to be split between Jeff and Mahesh as they see fit to go through sort of a deep dive of something we touched on at the last iatf and really didn't have enough time which is what led to this meeting we are recording this session the hope is is that we have enough good discussion and material that this can be used as a reference to other game models regaining model writers in the future and with that I'm going to try to switch desks decks and switch over to Jeff okay thank you so while the slides are being loaded my name's Jeff Haz and the hat that I'm wearing today is you know one of the co-authors with Mahesh and the bgp uh Yang module and we're hoping to spend a little bit of time today talking about our experiences and working in Yang and the"
  },
  {
    "startTime": "00:04:02",
    "text": "what is a very very large note module and interactions with all the other modules and the sort of very long path that we took to get there leave I actually can change slides I can indeed change slides so the format that we're hoping to have today I I suspect this is not the updated deck there were two of them listed I expected to see three so just as a heads up you may be using the order deck okay the the differences between the decks are minor we'll get the finalized version of the deck for no suspicion to that it's not a big deal yeah so the format we were hoping today is that uh Mahesh and I will take uh turns sort of talking through you know a given slide because we have slightly different frames of reference for our experiences and you know what we sort of brought to this process and Our intention is to leave this open uh for discussion because you know things that we've run into uh may be useful for other people to discuss in terms of tools issue is this a modeling issue is this you know figuring out how to get bits of ietf to work with each other uh and the point here is to try to share what wisdom we've actually gotten and ideally seek wisdom others and our hope is that long term some of these things could distill down into other things that can help people at ietf you know advance and make progress on their modules whether they're very large ones like we had that work on or very small ones yeah so core lessons wise you know this is basically uh the agenda that we'll be working through today biggest thing that you have to worry about when you're working on a module is what's the content and how are the things organized you know what's the structure of it and that's a hard enough task to start with if you have people that in the case of"
  },
  {
    "startTime": "00:06:01",
    "text": "protocol modules or similar you know if you have somebody that's a reasonable protocol expert you know usually that's not a hard thing although one of the challenges we have in ietf is that we often do our work incrementally through rfcs that add to things rather than reissuing everything like uh a one gigantic module like IEEE does as part of their revisions so the consequences trying to figure out what exactly are you covering and you know which features you're actually trying to cover whether you're trying to make a module that's covering everything or you're planning to do pieces a bit of time through augmentation modules as an example any part of that conversation eventually comes down to modeling of things you know or these things features for example when you have a core protocol that has a number of things added over the years you know how do you handle your modeling in such a way that you can extend the model and basically is part of asking somebody to implement the thing not effectively asking the support features that they may not actually have so this is a challenge for certain types of protocols and we'll get to at least one example that in bgp as we work through the slide deck uh one of the other very large topics that consumed a huge portion of our time was maintainability how do you actually author a module and know that you will not get it right the first time that you want to be able to add to it that you're going to want to deal with these cases where you have new protocol extensions uh to add in not only you know things are completely brand new but simply backfilling some of the stuff you may not have chosen to do on day one and some of the challenges that you have in terms of maintainability is taking care of version either with extensible types that the Yang languages give us and you know we found this to be one of our big challenges I'm sure some of our experiences we are certain you know since we haven't actually gotten through RFC stat is that people have opinions about how we've done this and you know"
  },
  {
    "startTime": "00:08:00",
    "text": "with the cases they may disagree with how they gone and hopefully this discussion will help us grow it ietf wise to figure out how do we solve some of these you know interesting challenges and maybe if we go on to revise the Yang language at some point for the next version you know are these learnings that we can take on to maybe extend the language the next travel we'll also hit through a number of examples through things and you know it's our experience that not only providing examples for discussion points for slides is a useful way of no transferring knowledge we found that it's necessary as part of the document authoring process to provide examples integrate them into these tool chains test them out these things effectively become our unit tests proving that we've actually done our work correctly and this would be one of the slight points that we steadily work our way through and the examples You Know cover as an exam uh as an example interworking between the various models because most of our works some of them are very Standalone things but the vast majority of our protocols don't have completely independent you know life spans or fate sharing from each other you know so easy consequences are you're like uh if you have something that refers to interfaces this will often point off to other you know standard modules and ietf you know these things are fairly well established patterns and as consequence they're well tested but as we start working on things that are either on the new side of things like the policy module that we've done in the routing working group uh or modules that are working their way through standards like the TCP module you know not only have we got it right have they got it right but can you use the two things together and that is a explicit things of testability um and you'll finally you know one of the things we're intending to discuss is"
  },
  {
    "startTime": "00:10:01",
    "text": "collaboration how do we go about actually getting the work done when there's multiple parties you know we're scattered around the planet uh we have you know tool chains that we want to have for those levels of consistency with we also have a necessity of providing some level of track ability for our works especially you know for extremely large pieces of work like a Yang module so and uh you know Brad Wilton mentions in chat please refer to that uh that uh you know the Yang language itself if you know if there's issues there no please no put it into the Yang next GitHub entry so this is where I pause and give my Hash a chance to see if he wants to you know add to this particular side that is not covered in the code lessons is I think schema Mount but there is a slight to that effect and we'll talk about it when we get there okay great and again yeah please feel free to raise your hand interrupt at any time so uh Jason please go ahead and Jason you are not currently Audible okay Jason let's give you one more try and then we'll go back to resume the presentations okay Jason says that you fix his audio I'll come back later I've switched my headset input I was noticing I was"
  },
  {
    "startTime": "00:12:01",
    "text": "getting ambient so hopefully I'm a little bit better here at the moment so structuring content uh before you do any large modeling exercise you have to know the things that you're talking about you know and unfortunately for ietf we don't really have a lot of good introduction to modeling we have a lot of people that are deep experts in various you know protocols and you know as a consequence uh you know people usually know what are the sort of uh nouns of the protocol what are the things that actually you're talking about and your protocol operations uh when we're talking about protocols you know usually have some level of verbs and relationships to each other you know these things make it significantly easier for somebody that's a protocol experts to do modeling and sometimes we'll have people that are the protocol experts themselves participating in the process but just as often we'll have you know people that you know may not be either a modeling expert or protocol expert trying to contribute so the biggest piece of work you have to work on is how do you actually draft all the content you know the B2B Yang stuff in particular went through a number of iterations and you know this is one of the minor points that we did change so we sort of refined our history so a slight Point here from ietf 116 was that it was originally are thinking that the original bgp Yang work had started by people who began open config but now as we sort of work through our ietf data tracker history found that it actually went back several versions before that so you know we see that ietf has you know deep Cycles um you know some work actually started ietf open config people got involved and then eventually they went their own separate way you know forking for their own specific needs and OC has their own you know culture and you know goals for things that aren't necessarily the same as ietfs so this leads to some of the interesting comparison points later on"
  },
  {
    "startTime": "00:14:01",
    "text": "easy examples being that uh you know the goal for OC is for you know modeling basically the generic device from a configuration standpoint uh completeness of representation in the protocol Stacks is not a explicit goal for them uh you know a more vendor neutral uh background is what they're looking for whereas an ietf we're trying to provide modeling for the protocols themselves you know we may not have quite the same level of focus on configuration but you know certainly in terms of operational state you care about modeling you know the entirety of the protocols maybe one step more than they do as a project this is neither good nor bad now they just simply have you know places that uh the overlaps can impact uh specific challenges for bgp and this is true of a lot of the protocols that have a very long history you know pgp is a protocol of many many extensions and it took us a lot of years just to get all the content in and you know if somebody says well what is bgp you know these days you go off and say this is RFC 4271 so is everything in here that you need not even close so one of the challenges is you know based on the fact that ITF does not issue you know basically update rfcs that have absolutely everything that's part of the core anymore we have to figure out what is the core subset of modern bgp and the American group didn't have strong opinions on these things a lot of people seem to have a general sense of things like well bgp does route reflection it does confederations you know has you know a bunch of comment extensions like communities that everybody thinks they belong in the the core of the protocol well no it's these are all extensions so we have to decide what to do we do some lines in the sand and we got some of them right we got some of them wrong and this consequence there is an awful lot of feature creep what this means is is that as a consequence if you throw all the contents into the base model and you had"
  },
  {
    "startTime": "00:16:01",
    "text": "to go through iterations of you know did we do this right no is it the correct modeling for these things is the structure correct uh this this has to be an iterative process and it does involve not only passes from people that are protocol experts but also modeling experts in as we sort of get through is other pieces of the presentation is the usability of things correct you know so this this sort of three three-tier re-examination is a necessary part of the process you know as much as the Yang doctors are there to help us and a lot of things about the you know nature of the language how to model certain things they can't help us with everything you know they're not experts in the protocols they won't see things that are missing from the content you know perspective unless they're also experts in the protocol in question uh this becomes a challenge at review time and again you know just to emphasize the final point you know this re-examination you know from those three perspectives is really important do you want to add anything here sorry there you go yeah okay um what I was trying to say is uh no not at this point okay fine plausible materially to see if there's any no questions and you know this is theoretically a very basic thing and you know certainly for a lot of people they're going to be on this interim uh that are coordinate mod participants none of this stuff is technically new but these slides are written for you know many of the audiences in ietf and hopefully this is you know generically useful so moving on to Features you know the"
  },
  {
    "startTime": "00:18:01",
    "text": "Yang language is very nice uh compared to some of the headaches we had to deal with SNMP mibs in the sense that uh it's a little bit easier to do things that are optional you know there's no need to have absolutely everything present as a mandatory to implement components inside of your model and features give us a way to add those optional things in a flexible way the problem is it complicates the model in many perspectives makes it harder for the server to decide what to do in some circumstances and clients have to understand you know through exchange of what features are actually being used by the server to know locally what is actually being handled at the uh you know client end of things you know from a bgp perspective we tried to get very hard to go through a core set of features where we had uh things that were mandatory to implement we didn't want to have things that were you know too optional in many circumstances because now in those circumstances it does make it difficult to write things consistently from implementation implementation and to try to have a consistent user experience for the base model that we're starting with so we're really targeting what was core in the language and what was core inside of you know bgp itself places where this got complicated it is well there's some features that if you don't accommodate for them up front you can't necessarily handle the modeling changes later especially based on how the revisions to uh gang modules are permitted to do and in particular the biggest thing that this is a gotcha to look out for is for list keying that was an example if you're doing a list of routes you're not allowed to really change the keys you know that's something you have to get right very close and very upfront bgp has a optional extension called add paths that allows you to have bgp"
  },
  {
    "startTime": "00:20:00",
    "text": "advertise more than one path between two bgp speakers and theoretically is an optional feature you wouldn't think though this doesn't have an implant impact on you know the protocol but since you need to be able to model consistently a set of exchange droughts this means that even if the implementation doesn't support ad paths it's necessary it includes the path ID the path index is part of the list keys so this was a piece of looking ahead that was necessary to get the job done right augmentation for a lot of the extensions if you've done your structure of your modules right which means the key skeleton has to be you know thought about very hard up front is where most of the extensions will get added on and you know again we'll emphasize this in later slides being able to look back and say do I have enough of a skeleton to add something on that I may want to do later even if you're not doing it today it can save you an awful lot of your headache and some of these things maybe just simply strict augmentations this means that uh you know for me a protocol perspective you can add things on that doesn't have a lot of complexity and you don't have to worry about no features in a lot of these circumstances so one of the key learnings here is an attempt to try to think ahead can we do the work so that it is you know done primarily through augmentation without necessarily complicating using the Yang feature statements Jason you want to try again uh can you guys serve me this time we can okay great um yeah I'm just coming back to the same point I'd raised my hand about before about features and augmentation I know in discussions in our versioning work um I just want to reiterate that you know this way of doing uh features and augmentation where things are additive is definitely the right way to go um we've seen in in uh I think 3gpp and"
  },
  {
    "startTime": "00:22:01",
    "text": "some other discussions where sometimes standards-based modules are have other modules that deviate those modules I don't think we've seen it or at least in our group we haven't discussed examples in ietf but I would definitely want to avoid deviations which is kind of like a subtractive approach um similarly with features I know it's built into Yang 1.1 that you couldn't say something like if not feature Foo then have some Leaf but I know in our discussions we we think there may be some problems and and cause that could cause some problems and be fairly non-intuitive so like additive things like features where it adds nodes augmentations where it adds things seem to be pretty safe but definitely recommend to avoid um subtractive type um techniques like deviations or not foreign to your point there for for a lot of iitf style Yang work you know hopefully we can do most of these things either through augmentations because in many cases features are being added in one RFC at a time and you know that's usually a good General boundary for doing the augmentations where we've uh you know seen you know some headaches as an example our inter vendor comparison one of the pieces of the work that we try to do is try to construct what goes into things a lot of features know that are part of the core protocols strictly identifiable by the rfcs but there's a lot of places also where you know vendors have added on de facto features over time and part of the conversation has to be you know what do you do about those you know they if they're so built in but don't have any documentation it comes about challenging and one of the things that ends up challenging on them half the time is how do you model the configuration since you know in a lot of"
  },
  {
    "startTime": "00:24:01",
    "text": "circumstances doses are not standardized they end up with no interesting quirks to them you know they pick an example out of bgp the B2B route reflector feature has a no client reflect that's pretty consistently implemented by most vendors but in our modeling work it turned out that you know pretty much no vendor had exactly the same place where they allowed configuration for it so our choice ended up having to be we were going to skip adding this feature rather than make for complicated deviations out of it did you have anything you want to add here um yeah actually I was going to remind you that maybe the route reflect option is one example of where as Jason mentioned we want to avoid deviation um but there are cases where we were not able to add the features simply because of the implementation being different across vendors for that particular feature um the other example I also want to kind of I'll probably get into is with the augmentation is um in the schema Mound exam example in particular but let's get to that slide and I'll talk about the issue that we ran into with uh being able to Simply augment uh and realize what we wanted to realize but let's wait for that slide to talk about schema Mountain how it affected us um model okay and depending which side versions We have uploaded that maybe when you have to display from your desktop so maybe you have that one available if you have to do that um so one of the other big buckets of"
  },
  {
    "startTime": "00:26:01",
    "text": "was part of our continuous re-examination was maintainability it's been mentioned multiple times bgp gets a lot of extensions many of them are completely optional versus each other the challenge becomes yes go ahead I think Rob was in the cue for last slide oh I'm sorry I did not have myself scroll up please go ahead Rob just to say speaking is an alternative So speaking to the individual I'm assuming all comments in this uh discussion uh speaker such I think one of for me one of the sort of benefits of doing this modeling work is hopefully over time um it will lead towards the industry sort of consolidating towards a more standard um management interface because I think that'll benefit primarily customers and things who are using these devices that the more commonality there is uh the best that is and so one observation there and I'm not sure it's happening that well at the moment is if ITF reaches a case where it has good coverage of the standard protocol features I think in future be good to push to try and get the yam models designed and developed in conjunction with the features at the same time so if the vendors are thinking about those management models at the same time the event they're depending uh sorry designing the features there's a much greater chance that they will be able to reach some sort of commonality and agreement on what those models should look like rather than sort of trying to retrofit game models um after these after vendors all to sort of design their separate user interfaces and then trying to find the commonality is much harder that way around right that's an interesting set of points uh several of us on the call here are obviously old enough to remember the days when mibs theoretically were a required piece of protocols especially if you're trying to advance some of the standards process uh Yang is thankfully significantly better than SMI was to do representation of things and it means that doing it after the fact usually is one step less"
  },
  {
    "startTime": "00:28:01",
    "text": "painful and I agree with you doing the work at the same time as you're actually designing the feature would be sort of Ideal I think the challenge we're going to run into is a little bit the same challenge we have for finding anybody who's willing to do modeling work at all you know the skill set that it takes to do modeling is overlapping but a little bit different than protocol design and trying to force the two to happen maybe for the same author set may be an interesting challenge I'm sure this is a conversation the isg should take up at some point as part of uh you know long-term work but you know my sort of initial proposal would be we want to have the coupling it's probably very helpful I don't recommend it being a strong coupling just simply because no Feature work should be able to advance you know ideally at a its own pace with the manageability falling maybe a little bit afterwards usually because of the iterative process of the protocol design itself and it was uh you know everybody on this call is very well aware the industry is trying very hard to be good about not introducing non-backward compatible things as part of you know modeling work if you tightly couple things that thrash at the modeling into things and the modules that get exposed to the end user base you know gets thrashed as well and you know that doesn't really help the industry yes go please the example that actually I wanted to talk about was the color um definition that you were trying to add for example in the model but to Rob's point just like we require implementations I one or two implementations of anything that's supposed to become become an RFC I wonder if it would make sense that manageability be a requirement"
  },
  {
    "startTime": "00:30:00",
    "text": "at at the same time the definition all the RFC is being developed for that particular feature and Rob you're still in the queue did you want to add anything further okay rabbits taking himself out of the queue he's re-added good uh I'm not and he's out again uh the joys me deco okay let's move on to maintainability um you know as we're talking about how do you actually structure things uh that's a big enough piece of work figuring out how can you actually add on you know the next possible thing is itself an interesting challenge so you know asking the question uh now does this enable the future work is a important thing and how do you go about doing that in the case of you know you're developing a core module and then potentially adding in everything else by extensions well your book list is at least pre-built a little bit this gives you a chance to say here are the things that we already know you want the right uh later on and you don't have to do the full modeling exercise but being able to say well does this thing extend something that's already in the module is this thing completely off of the side these are the sort of easy tests to figure out you know is this the piece of work that is enabled right now in the current module or am I somehow holding it back somehow um the the sort of disruptive blocking behaviors this is why that we're really looking to avoid because you know you really can't undo those in the easy fashion ITF does give us rules for basically replacing an entire module but that is incredibly disruptive and you"
  },
  {
    "startTime": "00:32:00",
    "text": "know certainly not something we care to do um you know different groups have different standards in terms of the level of disruption they're willing to allow through the entire chain of modules they support ITF aims towards stability and this means a lot more Forward Thinking uh one of the ways we try to actually solve this on our part was basically they do tests and you know the test was you know can we take something augment it no even if it's a very basic augmentation we're not really writing up the full module but you know by doing enough of the skeletal extension on things this lets us you know test that we actually have done our job correctly you know has the augmentation succeeded and in a lot of cases one of the things that we noticed is that uh you know groupings in particular which are one part in nicety just simply to group things together they the groupings in some cases needed to be reorganized to allow them to be you know attached in different places sometimes the groupings themselves as part of doing the test we realize that we're since you can't augment a grouping in the current version of Yang the consequence is every place the grouping is substantiated if you have to instantiate a augmentation for each one of those things that itself is its own pain point and now certainly this is one of the uh known irritating quirks about yang right now and you know perhaps is one of the good things that will be you know part of Yang next um from B2B perspective uh we have a number of protocol extensions especially the VPN based ones that is managed by the best working group that's responsible for extending things and we had to make sure that things that best spotted the support for like New bgp Path attributes new address families for features like multicast and ethernet based vpns uh where those things actually enabled uh IDR that standardizes bgp itself regularly comes out with new extensions"
  },
  {
    "startTime": "00:34:00",
    "text": "can we actually make sure that we can do those sorts of things and you know interesting much harder questions in some perspectives is extending incrementally features that are very flexible and you know a particular bgp extended communities is a headache that will come back to with some specific study the typedef slides to talk about how this is actually really really challenging you know for something that's intended to be both flexible and highly maintainable um he also ran into some of these headaches uh for like uh route targets and Route distinguishers which are used by the vpns that had one version of modeling right now that are shipped in some rfcs that maybe long term will need to change this is where it was and see if uh Mahesh wants to add anything here um Jeff I don't know if you wanted to also highlight the example that we wanted we're trying to develop the CLI quote unquote the CLI model to see if um some of the popular CLA commands would work with the existing set of groupings yeah that's that's an excellent point um and I will skip actually displaying it for this round just talk through it and yeah if you uh all have time to go ahead and browse through the GitHub module that the B2B work is being done in you'll find inside of there there's actually one unused module that currently linked into the internet draft and you know going through you know quite a bit of history in a very short order uh when the bgp Yang module is being developed people are trying to figure out structurally how do you take two core pieces of bgp you know the destinations themselves the prefixes and"
  },
  {
    "startTime": "00:36:01",
    "text": "the sets of path attributes that go along with them and model them inside of the yang and it's the case of the BHP protocol that you know you have a bgp update that contains one set of path attributes which is a couple of the properties of the routes with a large number of prefixes that may be attached there so you have a relationship of you know many prefixes to potentially one set of unique Destiny a unique set of path attributes and you know the sharing means that if you were to model this one for one the consequence is that you'd end up with a potentially very noisy piece of modeling and you know there's a set of design choices made that well perhaps we refactor these things so that the path attributes are a shareable component where the individual routes then refer to it via you know some mechanism such as index Leaf ref Etc and you know this is a perfectly fine way if you're doing as an example a get over the entire routing table to reduce the amount of noise in the system unfortunately you know this battling stuff uh you know in terms of a pattern well correct modeling is got some interesting you know protocol challenges now as an example of some set of path attributes a is shared by you know five or six different you know routes well that's great you know you can serialize that uh individually as long as you're fetching you know the individual sub trees for the path attributes and then fetching the sub trees for the routes as long as you get the entire thing as one cluster you have the data it's made whole the referential Integrity is correct the trouble we have with any of these types of streaming mechanisms especially on change protocols you know like pick something outside of ietf gnmi from Google means that you're getting some of this stuff streamed you know there's no guarantees that you're going to get the things in any specific order and"
  },
  {
    "startTime": "00:38:02",
    "text": "sometimes there's no guarantee that you've even got a subscription to a subtree I would like the path attributes that's outside the routes themselves so this ability to make whole the data becomes very challenging for anything that tries to do a structural separation for purposes of efficiency if you're doing something like a CLI this is even more challenging you know CLI is don't split these things out no you actually stream out if you do a show B2B route on pretty much any implementation it's going to show the route it's going to show all the properties for the route it's not going to refactor these things for efficiency to try to enable things like the clis and potentially some types of streaming applications now we did an exercise you basically said well could we put together a model that is a command space module so if you did equivalent of a show BHP route and some platform could it stream out for this you know destination all the sets of attributes associated with it and it's part of that exercise we realized that well we were most of the way there all the things that were already inside of the path attributes already had most of the right organization and with a slight tweaking of the groupings we got you know pretty much 100 reusability and this means that for the same data you can fold it into multiple different types of views and provide the ability to have the information represented better for specific applications where this runs into interesting set of headaches which you know people on this call will have opinions about you know it's it's great that you can potentially enable multiple applications but if you had these things implemented out of the box as separate trees you'll just try to pull all the trees you're affected getting highly redundant data you know so this operational view nicety versus no structure is an interesting I think long-term conversation"
  },
  {
    "startTime": "00:40:01",
    "text": "Rob I see your hand up have a good audio yes so similar to this uh all related to this is probably a sort of templating where you might uh embed templates either within the model or more generically for the configuration and allow you to write a very concise configuration and then you have the same sort of question about how do you represent the operational data for those things where you do that template expansion that naturally you would do you you'd see like the expanded operational data but then obviously what can be quite a concise uh template going in on the configuration side ends up being sort of uh expanded out to a much larger amount of operational data and so that's an interesting case so scores to consider and someone says what you're describing I think exactly and your groupings unfortunately as we were saying earlier you know they're very nice in the sense that they provide us you know some ability to make uh reuse of things but unfortunately the long-term maintainability you can't augment a grouping you know that's where things become interesting uh longer term challenges for especially configuration okay let's move on to the next point and we'll actually pause from the slides in a moment to go out to some GitHub to actually talk about this um type versioning is actually one of the interesting pieces of headache that we have for certainly bgp and I suspect the problem exists in different flavors for other protocols hopefully is you know the ITF is reviewing the modules they're looking at these sorts of headaches um now in particular anything that needs to be extensible as a type ideally long term if it's moving at a fast pace you know something's changing often we're doing uh the work to delegate these types to hyana you"
  },
  {
    "startTime": "00:42:02",
    "text": "know the in the process theoretically will allow us to make changes without having to go through and issue a completely brand new RFC for things you know to basically copy and paste the same bit of data over and over again know exactly how well that process will work over the long term I think is still to be discovered um but minimally we need the ability to change these things in a flexible fashion and we need the ability to you know do so at a lighter weight than basically having the business an entire module every single time Ash did you want to interject right here okay the point I was trying to also add to it is uh the currently exist I believe no guidelines um as to when a particular set of definitions need to can or should be part of a INR module instead of an ITF module and I've had people query me on uh this that particular question so maybe this is more to Rob's to say maybe I did an IC level we should have some color or definition for what is an um what's appropriate to put in an INR module and what should be still maintained as an IDF module yeah in particular the takes something outside of the complicated pieces so like you know the uh extended Community type work um and Michael Richardson asked about uh good use of identities it will come to that as an example in a moment um for things that are code points in particular you know if there's a niceness to having the things uh published in a data type that very strongly binds you know their uh type and the code points they represent"
  },
  {
    "startTime": "00:44:01",
    "text": "together and again gives us a lot of different options for just boring numbers now we have enums but enums are not trivial to maintain on their own you know you have to go through a module update that's an example where you know the fact that when they have the number and you want to have the thing that they're tied to strongly put together that's a good place to do it and Diana maintain module um other people have taken advantage of using identities we talk about that a little bit uh you know the next Point here um in cases where the things may you know the code points themselves may not be super important you know you can model them as a base Identity or a set of identities no having an appropriate relationship Yang versioning rules let us actually extend identities without actually having to worry about a republishing the module so we get incremental maintenance without needing to you know centrally publish them but one of your challenges is even though you have the ability to do the extensions well you then have you know a question of where does the thing live now if your base module is part of a RFC and you know you have a base identity as part of that you can certainly have your augmentations for other things in a second RFC but the challenge then becomes you know if you have that potential becomes a identity itself that is being derived from and this is effectively a practice we want to avoid identities from identities you know the consequence there is that you start having dependency chains one way to sort of work around some of those interesting headaches is you know they encourage the identities even though they don't have to be maintained uh in a central place to push them towards the central place like Ayanna so we can get examples there um the BHP module does this as an example for its uh various types of capabilities and different example is uh"
  },
  {
    "startTime": "00:46:00",
    "text": "the igp modules that have been defined by LSR makes good advantage of doing things via identities rather than enums pause here to see Rob question a comment actually so to answer mahesh's question as to when is it good to do an Ayana maintained module my instinct here is if you've got another table already defined of attributes or properties defined in Ayana and you can programmatically sort of generate the Yang module from that B that either identities or an enumeration or something like that then I think that those fit quite well as some cyan maintained because whenever that master table is updated then I can automatically generate an updated version of the Yang module to go with it um in other cases where you need some sort of expert input into what's being generated and updated those I think is more on the line as to probably that might be better going through a working group but not necessarily the case but that's just my rough Instinct as to what the split should be okay any follow-up Mahesh yeah actually that was uh I remembered what prompted my comment was uh somebody asking does the cool Point need to exist in INF for it to be um in a module and I think rob you kind of clarified that there are two instances one where a code Point might exist and then um and that would be one very reason to have an eye on a module the other cases where it may not be in a code point and the question there is is it appropriate or is it okay to for it to be in an INR module"
  },
  {
    "startTime": "00:48:00",
    "text": "and I'll pause for the responses like that one I I'm not sure it's a hard and fast rule but having said that from what I recall everything that's that's there today always is a separate registry I mean the one that's probably slightly strange is the eye of types which I think is added to the to knife types list that might be and then a mid but it's generated from and the Yang is perhaps generation that's saying this so I think in all the cases I can think of there already is a separate table for the attributes but I could be wrong on that I'm not sure that's a hard and fast forward right examples of where enums versus identities you know have some interesting overlaps here if i n is controlling a central enum it's 100 clear that a given code Point has been assigned to an application if you have a feature that's done via identity if somebody defines a internet draft you know that defines an extension that's augmenting sorry that's extending that identity are they squatting out of code point or not no because there's no magic number associated aside from the stuff of the descriptive text so one of the things I encourage people to think about in terms of their I added process and know how this actually interacts with Ina and the isg is you know what level of enforcement mechanisms we can get in terms of trying to avoid code Point squatting which can cause all sorts of interesting headaches so I'm going to hit touch upon B2B extended communities because this is probably our single biggest pain point that we ran into as part of trying to figure out how do we clean up what's inside the module PHP extended communities are used by the various VPN protocols fundamentally they're just a eight byte long thing that the first two bytes Define a type and subtype and the rest of it is sort of selected based on that site type and subtype and you know bgp is quite happy to pass"
  },
  {
    "startTime": "00:50:00",
    "text": "these things around without necessarily understanding their contents but all the various protocol mechanisms that use about them care very deeply about what this stuff is pick easy examples of that no route targets out of vpns or a explicit type about that and they have more than one format and you know the choice for modeling was made for use of operations just like we have inside of rclis people don't want to put in a 8 byte hexadecimal number to get stuff done they're going to use things that are human friendly this means they're going to be able to type in something like route Dash Target colon 100 colon 200. this means that from a Yang perspective two things we need the defined type for them and we need to define a regular expression that allows them to be matched against and unfortunately this means that we have this gigantic growing set of regular Expressions because this is attached to a generic feature the you know extended community that just happens to be used in specific contexts this is where I jump out of our presentation mode and very briefly go into a screen share foreign Jason kantorlu so I um what happened there the slides dropped nope I'm trying to share my screen so I can do that and then I'll be re presenting after that okay it's uh it didn't ask me for permissions to share your screens when you tried it is it uh I have a screen share request going on right now so there should be a approval dialogue under your that and stuff yeah"
  },
  {
    "startTime": "00:52:00",
    "text": "I should be under mine but I'm not seeing it Kendra Lou oh Kent is actually done it there we go okay looks good oh actually no it's back this sharing deck I don't want to share deck I need to share screen let me cancel I'll click it again hopefully plenty of you can see it thank you and you should see an actual screen share request down hey Jeff I I saw your request briefly but it disappeared so I wasn't able to click on it but I don't know if one of the chairs did it seemed to disappear on me Kent could you go and make it let us know what you see we try again uh so I apologize Jeff maybe try one more time I just I don't know if one of the chairs is clicking on it share screen well so much for having tested this earlier so I'm not going to spend a lot of time you know trying to fight through the the UI here so let me go back to pursuing the slides I guess and then I'll just talk through the point yeah sorry Jeff I saw it come up but I wasn't able to do it I wasn't able to do anything about it I'm not sure why maybe as secretary I don't have the right permissions I'm I'm not sure so Jeff before you resume"
  },
  {
    "startTime": "00:54:03",
    "text": "um there is a question in the chat then from Michael oh yeah he was asking about the identities and I gave examples that we do have some inside the bgp module and we also have uh you know several excellent ones inside of the igp modules as well for like ospf and Isis so apparently my request this year anything is not doing anything so I'll need one of the chairs to actually re-share the screen and pass it back to me uh I can try um if you request I think I can give you permission okay so let's do the screen share one last time yes I really want to share my screen thank you so this should actually come through now okay so hopefully everybody can see my screen now um so again we were talking about extended communities and you know we have not only you know things like you know route targets route Origins other things like that um we also have things that include features of very popular in ITF right now like colors so the color Community was originally uh developed as part of RFC 9012 I'm not going to flash that up in the screen but you know poking to our packet diagram here because that's mostly from 9012 you know we have you know again it's eight bytes worth of data here's a type there's a subtype and then the bottom four octets were a color in the original RFC you know the prior to octets where basically must be zeros and no the question becomes well what happens if you want to extend these sorts of things and the srte policy feature which is being done in support of uh you know a lot of more interesting segment routing type use cases for uh with bgp is a signaling plane decided that they wanted to take you know two"
  },
  {
    "startTime": "00:56:01",
    "text": "bits of this and actually make use of them so the question becomes how do you model this sort of thing and you know part of our process here is this is an example we said well we want to add and this is inside of the GitHub that we've been doing our coordination work uh we want to add support for this sort of thing uh if we talk about where it came from and then the fact that there's a modeling challenge here and you know as an example we show the OC model that they've done for their stuff and you know they made an interesting choice you know they decided to model those first two bits strictly is a zero and one two bits long and then a colon so the question is what do you do about this sort of thing especially is it changed now if you have a uh standard 9012 implementation that doesn't understand the flags field do you want to model those bits at all you know it's not actually relevant if you do understand it well that's great we can display you know the two bits that we do know what to do from this extension RFC uh that's you know coming up and we can model it this way the question is what happens if we start adding further bits you know maybe we add you know the next two you know flipping over to uh presentations here actually sorry go back to the ietf one so if we add in you know the next two bits now do we just simply continue adding in zeros and ones no much like we have for the Yang bit string or you know what happens if we have a different example where instead of that uh you know somebody decides they want to grab the bottom two bits how do you represent that do you backfill all the zeros so this is an interesting set of choices that we have to deal with for maintainability on top of the fact that we have to actually update a type def that is used by everybody and you know the"
  },
  {
    "startTime": "00:58:00",
    "text": "you know example that we came up with you know for ours is you know we're going to add on a field designator you know so this Co you know flag let's say you know these two bits have been designated as the color only type Flags and this allows us to model this explicit set of choices and later on if we decide to add other things now we could also put on you know different flag Fields as well this means that regular Expressions written against this extended Community have a chance of being extensible in the future this is still not a great pattern we'll have some of the same challenges that we have for what happens when you you know add things that are present in the protocol but not actually signaled so it's a example going back to here what happens if somebody sets one of these unassigned bits it's present you can't configure it using one of these magic types you know you can't now print it so the challenge becomes how do you sort of fall back your display model the answer that we have for extended communities in general is we have the ability to display raw communities that are the raw hex format those are guaranteed not to change release to release it means we have to some extent no overlaps of you know known human friendly communities and you know the ones that are raw and the sort of headache we're seeing is a pattern sort of repeatedly as we're working through the operational cases for bgp how do you deal with the unknowns and there's at least one bit of this discussion that we're having about you know bit vectors that is carried through into other proposals so pause here to see if there's any questions about this explicit example foreign just to point out the relevant bits of"
  },
  {
    "startTime": "01:00:00",
    "text": "process uh you know we're doing this exactly like you do of any other git project you know we opened up issues we have discussions about it we work through the details of things and you know eventually we'll get around to crafting a pull request which we have when pending at the moment we've decided this is not a core piece of the feature and you know this is left as a lingering pull request it's possible that IDR is part of working through the RFC process we'll decide they want to integrate this but at some point you know there will have to be the internet answer for this because it's a protocol extension that's defined so Lou I'm going to switch back and request you to share the slides again and pass back to me okay thank you Kent these are all named very similarly so I'm going to just pick one and nope so one of our learnings here is that switching back and forth can be challenging Okay so we're zooming in slide seven uh type versioning like I said is a extremely painful thing when you're dealing with string types that have uh regular Expressions used as a validating elements on there uh we have some interesting challenges just for how these things were defined originally uh part of the routing working group work was to try to actually provide common types for various protocols including bgp and 8294"
  },
  {
    "startTime": "01:02:00",
    "text": "gave us some Primitives for Route Target Route Origins route distinguishers Unfortunately they probably made some modeling mistakes right there um you know they they don't provide for suitable extensibility they also don't make it uh terribly easy for you to do any updates they they didn't delegate this Diana so the consequence is if you wanted to maintain something at 82 94 there will have to be the entire Biz ideally that entire business once we actually start addressing the deficiencies profound as part of working on the bgp modules and as we continue working on the VPN modules will be to push this off to Ayanna um the main headache that we have in terms of the modeling is there's some ambiguity in the strings that they developed especially the lack of Quant qualifying keywords now if you look at mostly lies and do a show of some sort you know you do like a show bgb route and you'll see that this has route Target no colon 100 colon 200 as an example that route Target keyword is the thing that makes it unambiguous as to what the thing is actually present in the modeling that they did they just simply chose to put in the Raw 100 colon 200 numbers that means you have to know the context and as long as the context is completely unambiguous if this is used solely as configuring targets for a a VPN you know verf as an example then that's sort of safe but if you're trying to display this among a list of all the different types of extended communities which route targets one of well it's no longer semantically clear so that's the thing we'll decide about revisions as we work on the things in ietf foreign Point here bit Fields now there's a presentation I gave on this point at last ietf uh very briefly reviewed here Yang does an"
  },
  {
    "startTime": "01:04:00",
    "text": "excellent job in terms of defining bit Fields as a core protocol as a core language element when they're defined you know so you can identify Bit Zero means this bit one means that that's great the problem is what happens when you have operational state for implementations that can receive things that might be an older version so if the three bit four bit five gets assigned later on but you're unfortunately running an older version well the implementation can see it the thing that you're passing through your implementation may contain those bits you may not be able to see it but it may be impacting something further Downstream in the protocol so visibility is a very important thing from operational standpoint the bits construct doesn't really give us the necessary tool so you know the problem we have is sort two-fold there's no way to sign default names to these bits you know the consequence there is that uh you know something I was getting sent on the wire you can't show that it's present that goes back to our extended community example for colors for those unassigned bits as an example and just this messy uh you can't change the name of the bit once it's been assigned which means if you want to actually give it a name uh you're not allowed to change it no from like unknown three to you know this is now the color for an example uh the proposal for the unknown bits that I made is one potential technique for dealing with this and this generated a lot of interesting discussion in terms of whether these things are Backward Compatible changes or not I suggest that let's not take a huge amount of time in this presentation for it but let's please continue that conversation in the deadbat pause here to see if there's any questions"
  },
  {
    "startTime": "01:06:01",
    "text": "go ahead and finish no I just unmuted simply because I was getting ready for the next slide it's your show all right uh so I was going to talk a little bit about examples and the need to have them in the drafts not just for what we were trying to do but in general as a suggestion to anyone who's actually writing a Yang module um I think it helps multi-fold Runners as I talk about as you're developing the model any changes you make does it break your existing model in any way and that's an obvious way reason to have plenty of examples in um in your repo now you might choose to either share them in the draft or not but um I would share them simply because from an implementation or somebody who is actually trying to use those models can then use your examples to build upon so I I think our philosophy is that there can never be enough number of examples uh in the draft so more would suddenly be helpful um even within the examples I've seen Snippets um anonymously complete configuration examples and that's better than having no examples but it suddenly helps if uh one can see and in that particular example um how you are pulling in data for other"
  },
  {
    "startTime": "01:08:03",
    "text": "modules that you have not necessarily developed so if you look at that the example 8.5 in on draft it's not just concentrating on example as it relates to the bgp but also the other modules that it's dependent on so um highly encourage anyone who's writing models to try to develop example story Jason hi um so mesh when you mentioned that uh like I agree the examples are often very very very useful and I found them in developing Yang models as well is to have some instance data examples for myself to to kind of validate my mind oh here's what it looks like when you kind of put it together um but you mentioned that it would also help detect when you make some changes and it breaks uh you know like previous configs so I I assume by that what you mean is not just have the examples but you also are validating them validating those instance data examples against the models using like Yang lint or something um as as you turn things like to have almost like an approval pipeline as you're turning the turning the module that is correct and I what I was going to do as part of another demo if we are able to have a pull up um the repo in my case is to actually show exactly what you mentioned which is using yanglin and an instance data file whether it's XML or Json and run it against your model so if you made any changes and you forgot oops I I forgot to either remove or change a particular leaf then that example is able to catch that and tell"
  },
  {
    "startTime": "01:10:00",
    "text": "you either you modify for example are you modified thanks any other questions yeah I gotta point out for this particular slide you know the tcpm module that had been coming out was through their last call I've been through the end doctor's review and we were asked to go ahead and take a look at it because pgp is you know as a protocol uses TCP you want to make sure that we can interoper with it for things like tcpao and md5 and it was the process of writing our interop examples that we found deficiencies in the the current dspm module at that time and that uh ended up halting their last call they got some changes made we've proved that the modules interworked at that point and we were able to proceed forward so this is a excellent example of you know publishing something without trying to use it can be problematic foreign this is the correct version of the slide so um schema Mount was one other area that was um that we started to look at fairly early um although one of the issues that we ran into was that there were no public tools available for us to actually validate so going back to that example a scenario even though we had an example we didn't have any tools to validate it but ever since then I believe England has added support So the plan is for us to of course revalidate the scheme amount example that we have in the Trap"
  },
  {
    "startTime": "01:12:02",
    "text": "but um why do we need uh schema marble well if you look at the bgp model it is already augmenting the routing protocol model to add the particular bgp instance now in that particular scenario routing protocols rarely of course run in isolation they usually are realized inside of a network instance even if it's a default Network instance so how would how does one augment an already augmented model um one of the ways to of course deal with it that ITF has defined as using schema amount open config of course decided that they were going to address that by making sure that all routing instances are always realized under Network instance and you had no flexibility in changing that IDF on the other hand has decided that um it will offer the option of schema amount where you can essentially draft or graft a particular um model under any other model and create its own hierarchy so bgp in this case because it was already using augmenting sorry the network model sorry the routing model decided to use schema Mount and mount routines routing model under Network instance default as a global instance of course of bgp"
  },
  {
    "startTime": "01:14:00",
    "text": "is can be realized in that case uh running under a default Network instance for those that don't want to necessarily run instances under a particular work um but even doing that an example to demonstrate how that scheme amount can be done was important for us and that's why we decided to add that example in the draft and as I mentioned earlier that more example is of course based on existing RFC examples that are there either in the routing or in the network instance rfcs so we are hoping that with the tools now being available especially yanglin will be able to validate schema foreign hey um it's just more a time check I think we've got about five or six minutes left on the on the on the meat Echo um I don't know if it'll keep going past that for a few extra minutes but um uh we should probably just make sure we kind of hit on key messages in the next five minutes and then anything if if it lets us hang around for another five or ten after that uh that's a bonus but I'm not positive what will happen okay actually I'll hand it back to Jeff at this point to cover the remaining slides okay and we should be able to easily finish this by tap of hour and we'll try to compress you know the key points down you know the next five minutes and give up a chance to actually show a very you know very very brief demo of changes in the ecosystem he built um so again revisiting this point module into work was a very big deal we've already reviewed a number of places where this was interesting set of challenges as an example how do we actually do OTC AO tcbmd5 ibsec how do we make these"
  },
  {
    "startTime": "01:16:02",
    "text": "things actually work with bgp how do we integrate with things like policy which was itself its own growing thing and you know some of the back and forth that we had between this module in the IDR and the protein working groups you know policy module that was under their development but had substantial need to accommodate bgp you know that that was one of our sets of challenges and you know BFD itself it was people who are involved in you know that bittyang work was itself a headache in terms of Maintenance you know it had to have a small patch issued against it very soon after original publication so verifying we can actually do all these things is critical a lot of this again is coming back to try the examples test the integration we will find bugs we did find bugs and we found bugs in like four different of the pieces that we tried to work with ipsec had already long been published they're they don't have a specific piece of work at the moment open to fix their problems but this is an example at the bottom we don't have a gating process in ietf review to make sure that not only is the module good yang or if it's valid protocol components but if it's referring to something else or intended to be used by something else is the data able to be done and can that into work actually occur collaboration was a important thing here this process went down a very long time you know as I mentioned earlier on it was a cluster of original authors and then you know the OC folk joined and then split off and then it sort of lingered for a while and you know eventually sort of hit a stale point before we started getting further involvement uh and the consequence was you know if you can't move at a fast pace how do you"
  },
  {
    "startTime": "01:18:00",
    "text": "actually make sure that important things are lost and even if you are moving at a fast pace iterating quickly how do you make sure that you're making lots of different point changes to the documents are things correct at each step of the way and these are exactly the same problems that standard software development has so this project is used GitHub for a very long time but Hesh has done a wonderful job of building us an environment for this and GitHub itself gave us a lot of the structural components we needed to get the job done issues were created we track things we tag them once we decided to work on a given cluster of things you know we'd generate pull requests we had cross review we were making sure that we release against various implementations to figure out how closely we're matching the real world in cases where we didn't have no good agreement the issues will provide documentation perhaps long term especially if we archive things as to why we made some of the design choices problems we didn't have enough eyes in the work and this is a generic problem with modeling and ietf uh review ends up happening effectively very late because we published an RFC and then some vendors trying to implement the thing you know we have a lag between implementation and uh the RFC status process ideally we'd have something better to do about that but based on where the industry is in terms of ITF Yang modules that's not happening right now uh for us trying to close some of these Loops doing all these testing components verifying we can actually maintain things the containerized build environment mesh put together for us did a huge amount to make sure that everybody you know and a single git checkout with Docker has everything they need to build the modules do the validation build the resulting internet draft text this is all in one spot means that you also have a consistent version of each of the tools of the tool chain and we'll go ahead and briefly touch on the next two uh remaining slides and"
  },
  {
    "startTime": "01:20:00",
    "text": "then yield them a hash to actually now show you what the environment looks like some brief conclusions uh one of the best things we could have done is found a way to do this in less time and you know the B2B Yang work if you look at the draft is probably the largest module we have in ietf by you know at least you know 3x consequences it's just going to require a lot more eyeballs on there and it required iteration and iterating over something that large is very difficult just simply getting all the content in itself you know check to rechecked you checked eventually you stop seeing things you need more eyes um and even if you have eyes reviewing things it's the same problem we do have to get the structure right the first round we found that we actually had several mistakes in and we found that out late in the process conveniently we're still pre-implementation so this was not actually a broken thing um the tooling and the maintainability and more most importantly the testing that's part of the environment that will be demonstrated that makes a huge difference uh iesg in particular needs to pay strong attention to what we delegate the Ayanna how that actually goes into the code boy management process and you know but if any type of squatting can take effect when things are defined through identities and you know emphasizing very hard again interwork has to be tested this is where we will actually find problems uh in ITF some brief GitHub stats you know 200 issues open 135 poll requests and you know a lot of these passes were back and forth against ietf as we were working on it and OC so this is where I'm going to ask Lou to wake up and allow Mahesh to share a screen not sure if Lewis on the call but hopefully we will try this myself"
  },
  {
    "startTime": "01:22:02",
    "text": "so apparently we have to stop sharing the pre-loaded slides which looks like maybe you've done so Mahesh if you want to make a request let's see what happens there do you see my request he looks like a screen is being shared oh this is gonna work you know what um unfortunately because permissions I will have to restart and re-log in so maybe this we might have to just skip it for this time okay it started uh it started thinking it was sharing oh um let me see if I let me share it now it's saying I have a Mac permission denied problem at my end oh on your Mac okay okay there are several slides here so I don't know which one maybe this okay okay um I think that was the end of the slide presentation and um we'll have to skip over the demo uh the demo that Jeff was referring to was the containerized environment that we have what it essentially does is um it has and as Jeff mentioned the set of tools that we were able to share consistently across all the authors because each"
  },
  {
    "startTime": "01:24:00",
    "text": "individual laptop had its own otherwise would have its own tool set some tools that were available somewhere different versions and rather than debugging or working on the model itself we were spending time trying to figure out why the versions of the draft were different so having a Docker containerized way to build the draft um it was suddenly neutralized any differences the other part that is not necessarily part of the container environment was that and this is something I learned through other authors uh is keep the model separate from the draft itself so that the models could be compiled they could be validated and tested before being included in the draft and there are enough scripts around that maybe should be shared um that can be used to then include those models into the draft as part of the build process so those are some lessons or tool sets that I think would be helpful for anyone who's trying to develop a young model from scratch anything I missed Jay Jeff sorry Robbie you had a question uh lots of questions just reiterate my thanks to both of you uh both presenting here and the work you've done on here I think the one about the sort of um the tooling aspect I think that would be really good to share because that wouldn't take very long to share either an Ops area or maybe rtgwg um to give people sort of um guidance on how to do this stuff I think all that stuff is great and helpful so if you're willing and can find the time energy to present that uh the next ITF meeting I think that could be quite a good thing to present on um I think this is all very interesting as well you obviously can't fit a whole slot with this though"
  },
  {
    "startTime": "01:26:00",
    "text": "Absolutely I'll I'll share that yeah an ideal outcome from you know that particular piece from it is we end up with basically an empty blank container which can then be used as the default development environment for people doing new work your shot yeah I just want to uh do what you said Mahesh regarding the use of GitHub and all that when we were working on the BFD stuff you had or you had done all the uh build environment and having the model separate and you know validation of the examples that was all done automatically and it really helped so I just want to say plus one to what you said thanks well I guess the offer my closing remarks uh you know this has been a long journey you know we're still not to the point of no implementations yet although we have rumors that some are starting to make progress for the bgp stuff and you know the consequence of the work that we've done hopefully has helped make all the other things that we're working with a little bit better as well so hopefully this has been helpful and my hope is that uh you know this group will take the wisdom spread it around elsewhere and ideally let's write down some of these things as best practices and disseminate them whether it's internet drafts Wiki entries Etc so that the rest of the people who want to get started in ITF Yang work you know have a good place to start okay and thanks all and on behalf of the chairs um yep net mod uh thanks a lot guys I know it's a lot of it's a lot of your time to have arranged this and and take the time to present it so I think that pretty much wraps up this interim"
  },
  {
    "startTime": "01:28:00",
    "text": "someone else as something else they want to add closing moments here otherwise hopefully we'll see a lot of you at ITF see you in San Francisco bye Alt"
  }
]
