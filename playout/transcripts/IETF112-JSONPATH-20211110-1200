[
  {
    "startTime": "00:00:12",
    "text": "i think we should give it another minute or two before we start yes i agree kirsten i'm looking at the github the latest draft is 10th november still today okay so glenn while we're waiting there is a [Music] pull request to create a tools.md do you maybe want to merge that okay i'll take a look thank you sorry is this a pull request against the main repo i see no requests yeah i don't see it either so wait a minute probably i simply didn't create the"
  },
  {
    "startTime": "00:02:00",
    "text": "actual requests um yep [Music] that explains us number 135 now okay this is not changing the document at all it's just saving some information from an issue into a separate micron file yeah looks good to me i'll merge that thank you so where is it uh okay i'll take you right for it shall we start now and i i presume that stefan will join us uh at some point yeah he said 10 to 15 minutes stage yeah i mean we'll spend the first uh bit of that just getting through the the usual administration yeah [Music] cool okay so i'll do the i can do the formal introduction as i always do so this is the json path working group for i eat ietf 112. uh the usual disclaimer uh as this is an ietf meeting the note2l applies and all the bcps and guidance that you see stated here applies to this meeting as well uh if you have any questions you can ask the ombuds team uh or you can also ask francesca who is uh uh quietly sitting in the background there um"
  },
  {
    "startTime": "00:04:01",
    "text": "uh probably a good idea uh carsten are you able to take notes when you're not speaking or is there somebody else who could help volunteer uh i think it would be much better if somebody should work on that so i i'm sure pitching but uh um i'm afraid i'm going to speak a lot today okay that's fine i guess what we can do then is what we've done in the past which is i'll uh crank out some notes from from the vod uh when it's uploaded a little bit later um the blue sheets using the the shared nodes in the kodiamg and that's where i will be typing into yep okay and and then i can just sort of add in anything else that needs to be support needed including that you missed that's fine blue sheets are automatic because we're using meat echo this time i will try and do my best to keep keep an eye on the chat in case anybody needs to pipe up um and uh but if somebody could nudge me uh that would be uh if i miss anything that would be kind of helpful do we have any agenda bashing that needs to be done um the agenda is this um perhaps we need to discuss regex in filters uh again because i'm a bit unclear about the direction yep uh tim and i had discussed that as a as a potential thing and maybe if we have time for that um after after i guess cast carson's gone through the issues we can include it yeah okay so i think we can actually i think"
  },
  {
    "startTime": "00:06:01",
    "text": "let's try to do that because i think um i think that that's a fairly short item based on our discussion uh [Music] last time i mean do you want to do it now then well let me just offer the following um sure if people don't mind can take a minute um is that at our last get together we had a consensus that um we can't really have json uh pardon me or reg access unless we describe what we mean by reg x's and there at that time was nothing very concrete you know carson had scratched out a proposal so you know as things stand now we're probably not going to have rexes and filter expressions unless somebody's willing to do a bunch of work that i haven't heard about yeah i have a slide on that okay well let's push that on the stack then and uh dive into the issues okay so i guess the format of today's meeting is is that tim did you want to cover your uh your editorial notes and the things you uh the the various sections of the document only on list and go through those to start with and then we pick up carsten's issues cool uh did you want to uh share a screen or did you want me to bring up the email if you could just bring up the email sure i'm like finding my own having trouble finding my own damn email i may have absolutely accidentally yeah um nuked it somehow uh here it is okay i got it it's in the i'll drop the url into the chat just to be sure"
  },
  {
    "startTime": "00:08:13",
    "text": "um so anyhow uh having read the draft i came away actually fairly cheered up because um the draft uh isn't terrible you know the the the important parts that you know describe the syntax and the semantics are mostly pretty okay with with editorial notes uh to be added and then a huge number of our open issues are all um uh stuck down in section four the expression language um karsten you've done around since this um and everybody's looked at this i think what in here needs further discussion kirsten anybody else in preparing this meeting i actually tried to uh tackle the big things here i haven't taken all the small things um because yeah they are in the end they are not so small with the amount of editing that is required but i think some of these should probably go into issues so we can have a little bit more [Music] discussion about them and some of them are really uh editorial and and we need another editorial uh round so basically i think i get back to this mail after this meeting but um i think most of it is done at this point okay okay that's good um the one thing um i wanted to raise here is in the"
  },
  {
    "startTime": "00:10:00",
    "text": "in the a section three five i can't find it in my own notes the section that has all the different uh uh 3581 i was hoping we would have examples um do people agree with that in spirit that for each of the uh uh selectors there are several ways to do examples so there is one issue if i remember correctly that asks for an appendix with examples and i think that that's a pretty good objective to have an exp appendix that has at least one example for each uh component of of the syntax and hopefully of the semantics by that as well that's right so i found it in section 3.5.2 um which uh particularly under dot selector uh oh yeah so dot selector dot wild card all these things in 3.5 right [Music] there's the rootselector.selector.weldguardindex index wealthguard i don't know i i just when i read a spec i i i find it so much happier if you know i read each piece of little descriptive prose and an example of what that looks like yeah i mean i agree with that um the only danger in putting examples in early is it sometimes tricks people into not actually defining um the content in a normative way fair enough yeah but in most cases we already have pretty"
  },
  {
    "startTime": "00:12:00",
    "text": "well right so yeah yeah okay i'm just going to leave that in a you know as a suggestion to the editors and i might actually go and do a pr myself on that if nobody else is interested but i want to make sure nobody objects to that okay so having said that it sounds like um uh we have we the people at least on the call here have a uh somewhat shared view of the state of the spec and what we need to do to get finished let's talk about schedules a little bit if nobody objects how much work do we have left here i'm going to say not that much and we could think seriously about bringing a draft forward to the isg at the next ietf um yeah i think that's that's probably doable um just um to be clear i'm not currently working on the compliance test suite or the reference implementation so i think we're talking about just having the draft available in that time frame glenn did you go get a serious job or something uh no i got involved in some other things outside this so a bit distracted um and since marco dropped out i lost my main compatriot on those uh aspects quite like bouncing off people and rather than doing a solo effort okay fair enough so i just wanted to share my opinions there"
  },
  {
    "startTime": "00:14:00",
    "text": "on on on the state of the draft and what needs to be done um that's fine okay i'm done with that um so we we had a couple of issues queued up james back to you uh yeah sorry i've just been uh struggling to to share the screen uh and uh trying to triage it with me to meet echo um i've started it again yeah we're not off to a good start with the technology this time around uh i'll let cast and do the screen driving now and you can do your talking carsten yeah thank you so i was just in the middle of opening an issue for the inline examples okay so that's not going to be on my slides yet number 136 feel free to fill in that issue um so what i did is i i went through the issues newest first and um try to find out where we are with these issues that has turned out to be difficult uh for for about five of them because they they are really just streams of consciousness uh brain dumps and it's not even clear that uh this very defined issue is defined there let's talk about them at the end um so let me talk about the ones where where i think i understand what they are about and the most recent one uh was uh 127 when i started doing these slides and the the question was"
  },
  {
    "startTime": "00:16:02",
    "text": "should we provide for structure types in incontainable so for the in operator we would need to do two things to allow that we would have to put in a value notation for structure types and we would need to define the comparison semantics for structured types um so right now the value notation is limited to primitive types and actually it's it's different in the various places uh where uh we uh need it uh so uh that's maybe one thing where where we can think about whether it should be possible to search for true or false in a containable and so on um so that's one thing we would need to fill in and that that's not entirely trivial we cannot just copy the json syntax because uh jsonpath has a more lenient syntax so we at least have to patch that a little bit and of course an interesting question once you actually have array and object constructors in your value notation um what can you actually construct them from can you only construct them from literals or but can you also construct them from results of of nested queries and um well i would say if if we do all this then we we probably also should allow path and this but maybe we should first find out whether we actually want to do this on the comparison semantics i think that's pretty obvious it's not the semantics defined by javascript"
  },
  {
    "startTime": "00:18:02",
    "text": "but it would be a deep recursion to to define equality and yeah in in 120 or in the interim uh two months ago we we said we really just want array literals composed of primitive values um so the existence of this issue seems to tell me that we we are reconsidering this and i'd like to hear where we should go with this so so you reopened this uh karsten based on on on discussion from where in some other issues i think oh okay okay um you find it so you know i i i agree with what you said that i i thought we had addressed this and decided to go with array only and and literal only is there sentiment for uh reopening this i'm always concerned about the element of surprise if you have a comparison with a um a structured value path on the left that's a different question okay yeah i'm looking at the discussion on the issue here and the examples of course in in carson's original post are very helpful you know the so we're talking about having structured values or i'm looking at stefan's comments pardon me so are we talking about so at the current time if we look at stefan's examples of array examples his very first one"
  },
  {
    "startTime": "00:20:09",
    "text": "if you look at the array examples there are we're talking about on the left side on before the in is that the subject of the issue well the issue is really is about the right-hand side but yes if we don't have structured values in our notation at all then we cannot even write the second array example the the examples are instructive i mean the second one is a different semantic yes the containment that's being a substring or something like that yeah yeah i mean my the last comment from stefan um agrees with my critique of that he says he agrees that we shouldn't deal with subsets right so i mean the difference between the second and third examples are is interesting so the third example if you allowed literals on the left hand side makes sense the second one doesn't yeah well it's false uh it makes sense but it's false yeah you're correct you're correct and uh and then you know there's the corner cases about the empty arrays yeah i'm not sure that's the corner case i i think i think if we take out the subset part of the semantics the second example uh becomes false"
  },
  {
    "startTime": "00:22:00",
    "text": "and one two three four the fourth example becomes false and the first thing becomes true uh yeah the third one's true as well and uh and the last one is also if you're going to allow that kind of thing true yeah yes yeah so to to me it really is a question about user requirements and i'm just seeing two comments in the chat from people who actually are users and it would be great if they could speak up and tell us whether they need i i was looking in uh the the big comparison and uh no there's not much there so this you know this this does actually add noticeable complexity um unless there are voices saying they need this my instinct is to say let's just leave it with literals only i mean i agree with that but i'll go further and say do we need the in operator at all ah i started my crew do you hear me now hi stefan hi hello hello everybody hiya okay you are discussing uh issue 120"
  },
  {
    "startTime": "00:24:00",
    "text": "7 127 uh one no 27 okay yep sorry we've got uh daryl in the queue daryl speak up hey um just going i'm just going through some of the examples that we use within um the overlays proposal that we've been working on for open api and i can't think of any scenario where we would want to do um in with a structure we do have scenarios where we would want to be able to use in um [Music] with a with a primitive value so i i think allowing in with primitive is is a nice compromise uh and i do see lots of usage of queries um across different scenarios with just in of a primitive because in with ids or in with tags you're looking for is this tag in this list there's this id in this list but the structured one i i'm struggling to come up with this scenario for yeah my feeling is that the literals matching literals in arrays is pretty easy to specify and not that hard to implement um [Music] so i would lean to leaving the in operator in yeah so we only need a value notation for raise which right now doesn't exist did i have a slide on that no [Music] oh i i did so this production ray literal isn't defined at this point in time but it should not be too hard uh to define it [Music] so that that would be the action"
  },
  {
    "startTime": "00:26:00",
    "text": "uh from this issue and it does it doesn't seem that an array literal would screw up or collide with any other syntax or anything like that so just to be clear the uh that scenario with an array literal on the right-hand side uh would be equivalent to a disjunction yes yeah okay it's a bit more compact well i see what you're saying glenn so you could say it you could do it as a bunch of ours yeah so it's just syntactic sugar really yeah and i think the important thing is that we actually define the semantics of in in terms of the semantics of the equals operator so we don't repeat ourselves here after that um i mean this isn't the precise um issue we're talking about but my concern with the in operator is when we have a path on each side and when we have a structured path to a structured value on the left-hand side and a path to an array containing that structured value on the right-hand side and then i think it violates the principle of least surprise but i'm happy to put that on the back burner if this is out of order no no it's highly material i mean we could say that we could say that unless the left-hand side selects a primitive the answer is always false yeah and i think that violates the principle of least surprise in the case that would also make it hard to actually extend this later"
  },
  {
    "startTime": "00:28:04",
    "text": "that leads me back to the examples um yeah so we have a general issue that that i think isn't really [Music] encapsulated in an issue of its own but it comes up in other issues what does it actually mean to have a path somewhere in an expression a comparison expression or in a place where boolean expression is required i think we have pretty good consensus for what it means in the boolean case but we haven't really discussed what it means in a comparison uh case and this would be essentially inheriting that problem that we haven't discussed what a path means in a comparison position i mean we could print the problem by by having literals only on the left side of n on the left side that would be weird i mean sorry uh primitives only yeah but literals literals only no no paths on the left side well that's why you usually have an in you want to see whether the thing you found somewhere in the document is in a set of values yeah okay fair enough the the more interesting question is what happens if if it's on the right side because then you have a note list and is that actually the same as an array or do we extract arrays from these nodes"
  },
  {
    "startTime": "00:30:00",
    "text": "that that's not where defined and on on the left hand side of course if the path is a note list with more than one element we also have to decide to what that means right but but for defining it from the point of view of somebody writing a json path they think in terms of you know json stuff not not node lists um and you know these examples here and from stefan are presented that way in terms of json yeah so they don't don't address the the other problem that i was trying to bring up if you write a json path you might might have in in your mind that you have nailed down a specific node with the path expression and then of course the semantics are symbol just extract the value from that node and compare it as as we would compare a value on that left hand side and if that value is structured it cannot match anything on the right hand side because we only have simple values in the array literally that that's easy but if the path actually gives you several candidates um what does that mean well that's a different issue that's but it's probably an issue that will inform what we do with this issue so so daryl what would the shape of the queries you might like to do look like would would it uh would you know you would you say dollar dot a dot b in you know dollar dot c dot d kind of thing uh interestingly we we use it this particular in the opposite case so we have a notion of um"
  },
  {
    "startTime": "00:32:00",
    "text": "i want to apply this or merge this change uh if um this literal trait exists in the list of traits associated with the target so the the path is querying into the dark for an array and we want to know whether a particular literal is in that list so we would be literal is in list of trades so literal is in dollar dot trade list or something like that i mean we could i mean i can see both scenarios but so suppose the the path on on the right side of n is identifies anything but an array then the in does not succeed is that right yeah it doesn't it wouldn't i wouldn't know how to interpret that question was that the note list resulting from the path actually is converted into an array for this interpretation i don't think that's what i'm saying i'm saying that if i say something is in dollar dot a if if dollar dot a is not an array not a json array then it doesn't match yeah so the alternative to that interpretation which i understand would be that you actually use a path that delivers the number of nodes in place of an array and go through the node list and see whether you have a match so you say in dollar dot a dot star you"
  },
  {
    "startTime": "00:34:00",
    "text": "mean yeah something or into a particular property in an object so you you'd path into there'd be an array of objects you could path into a property on that object and that would produce your node list that you could then query json world key so so in json we have you know objects and arrays and objects have members which have names and values okay so basically selecting a member of an object if you had an array of objects you could select a member of an object across an array which would then create a node list of all of those the literal values of the member if the if the member has a primitive value so if you had an array of fruit objects and every fruit had a member which was a color you could pick out all of the blue fruit we have a different issue on whether selection actually is possible because what you describe is a projection where you take an array of objects and extract a single member identified by by a name from sorry the array elements yeah okay so it's it's the in operator becomes is there a blue fruit in the list yeah okay but we already can do that with a filter expression so um the the simple case where we just want to know whether it's there or not doesn't need the in operation that can"
  },
  {
    "startTime": "00:36:01",
    "text": "be done with the filter expression and if the filter explosion impression is empty then you don't have a match and if the filter expression is not empty you do have a mesh right yeah which which brings us back to is in only useful when you have an array of literals primitives i think that would be a good simplification i think this is a quite good example regarding issue 122. i think i didn't cut it right carson your example at color in dollar dot dot allowed color i i was thinking about loud colors uh so returning an arrow an array of arrays but this example with a lot of fruits and note lists of fruits and then selecting all blue fruits is a nice example where we generally are generating an array of object members and then query by the in operator if that color in this case is included or is found in this array assuming you have an n operator the saying in when you're talking about an array that's part of the you know json data as opposed to in when you're talking"
  },
  {
    "startTime": "00:38:00",
    "text": "about the results of a query with star in it or something like that feel like really different things [Music] this requires to to turn a note list into an array and this is the only uh one in the spec where we uh demand this well it's the only place in respect where we actually handle arrays because otherwise we we are only handling primitive um types so that that would not be a surprise but yeah we don't have to turn it into an array we could simply define what it means to have a path as a container we can use the array as a useful analogy for defining that but we don't have to say the path turns into an array because that has other interesting issues okay so no another point of view it's okay another way to go ahead yeah another way to sidestep this issue is the approach i pointed to before in proposal a which rather than allowing a general path on the right-hand side of in would have a more restrictive path which should only deliver a node list of maximum size one so we'd have to be an empty node list which would yield the value of the result false or it would be no less than a single value and then we'll be testing against that single value uh especially that gets rid of the options of having dot star and square bracket star and similar things and dot dot and so on where the single value could be an array yeah sure and that's probably just the case and n doesn't make sense unless it is"
  },
  {
    "startTime": "00:40:02",
    "text": "yeah right so let me let me throw another example at you that i think is is would would not be able to be do done if you had that constraint so i have a json document with a list of companies and each company has a member that is an array of locations where that company is present so it's an array of objects with like an address with a city property and i want to do a filter on that set of companies so it's find me the company that has a location in the city of detroit so there i mean i would use a filter and in the filter condition i would have an in and i would want to do in and i would want to have a path on the right hand side of the n that digs into the locations and pulls out the cities that each company is uh present in and there may be multiple cities that the company is present in so if if the path on the right hand side only brings back one then am i right understand that that wouldn't be something we could do so the current time the in operator is a boolean right it just selects something a filter expression assuming you had a city field in your um so if you had a city field in your objects you could do it with an existing filter expression fine if the city field were an array oh um well i'm thinking nested right so you you've got one array of companies and then in each company you have an array of locations with addresses so you'd have a filter but in that filter expression i presume"
  },
  {
    "startTime": "00:42:00",
    "text": "you can put an in condition in the filter expression yes so you essentially need a nested query yeah at all you you write a filter that gives you the list of companies and with the the nested query you look into each company whether it actually has the value you're looking for so you would have a nested query where the query for the location would be nested in the query for the company okay so you'd use a filter for the second thing too okay yeah so maybe that's i have to look into the filter syntax a bit more yeah we need to make examples so i think that that's really what my takeaway here that we need to make examples that show that we don't really need a path on the right hand side because these can all be done with filter expressions and if we have these examples then i think we can simplify this to just allowing array literal on the right hand side of the container at that point it seems much less valuable to be honest i tend to agree with carson's approach to have a nested filter to in the first step select the areas the area of cities a company is present and for each company for each cities of each company i will test by the in operator if"
  },
  {
    "startTime": "00:44:01",
    "text": "that city of question is contained okay so so um examples would be helpful as you said um at the moment based on this discussion i'm i'm having difficulties seeing where an in operator with just an array lateral on the right is interesting and valuable do we have use cases for that i mean it becomes a shorthand for or right at that point correct yeah i don't have a strong opinion on this um i never having used this construct myself in jason pass i just don't have a strong feeling for how useful it really is and whether it's worth the work to to put it into the spec it sounds like you know most most of the kinds of things we're talking about can be done with filters do you think editors do you want to put it in well i still think it would be handy and if we define it in such a way that it really doesn't add complexity because it's really just a shorthand for for"
  },
  {
    "startTime": "00:46:02",
    "text": "this junction of comparisons then i think it's not a problem putting it in anybody object to that approach we are discussing having structured types in comparisons and on the left-hand side of in the containable and i also tend to allowing this if it's really straight forward and not very complex with implementations so having structured types on the left means you have to define uh object equality have we already we haven't done that yet have we yes but you can also have a path on the left hand side yeah yeah so you have a left on so if you have a path on the left hand side and the path selects an object yes and then is that always false or are we going to try and do object equality in an array that might be appear that might turn up on the right-hand side if you have an array on the right-hand side and exactly this object is in this container in this array you will get a match this would be the consequence of that"
  },
  {
    "startTime": "00:48:01",
    "text": "right um does anybody have an opinion on that that strikes me as as requiring us to define object equality have we we haven't done that yet anywhere else have we no [Music] and i would say it is near trivial to do that that there are way more complicated parts in for instance equality of strings than inequality of arrays and objects um but yeah it just adds one additional thing you have to think about uh so this is not about in this is about equals equals would allow values on on both sides that that are structured and then the next question is how far do we go with the value notation for these values so are we able to notate arrays and and objects that's not much harder than defining comparison so it's also a relatively inexpensive thing to do so if we actually have use cases for this then i would say let's go ahead with it yeah i'd like to see a use case which can't be satisfied by filters alone i think daryl may have one sorry i don't really have guidance to offer here i i i'm in favor of keeping the spec as simple as possible but if there but you"
  },
  {
    "startTime": "00:50:00",
    "text": "know it does sound like a tractable drafting problem to to define what the literals look like and and produce surprise free results but it's a substantial piece of work um so i think i what glenn said i'd want to see i'd want to see use cases yes use cases for this would be very helpful so james is there a document where we could find those rdap use cases uh i guess you're talking to james gold yes sorry um uh he did post a link earlier in the chat other question is are there any examples james so how is rdap using json passes there so yeah so james posted a link to the draft in question in the chat if you scroll up a little bit or i can paste it back in redacted fields in the registration data access i'll pretend i know what that means are there examples yes uh yes there is around uh section 3.2 can you hear me yes yes got it yes you're audible yeah yeah there are examples um pretty much the goal of that draft"
  },
  {
    "startTime": "00:52:02",
    "text": "is uh i'm not sure if you're familiar with who is for domain names um art app is a json version of who is um and pretty much uh the need is to be able to explicitly specify what data has been redacted for privacy reasons uh and so uh one approach that was being discussed wasn't used like placeholder text and that sort of thing but the decision uh was within the working group was to create an extension to explicitly specify which of the json members have been redacted so you can tell the difference between it non-existence and redaction so um pretty much there's the use of json path to formally define uh what members have been redacted now there's a combo of whether or not there's redaction of object numbers or of arrays because um rdap actually includes the use of the name of it already uh fixed length arrays um that uh include contact data that uh you pretty you can't remove you just have to clear it so we need to have the ability to specify positions within an array so there are uh examples within the draft of the use of jsonpath so if you uh review it and take a look uh please provide any feedback related to any uh changes that uh you're thinking that you're you're considering in this uh draft and whether or not it needs to be fixed in the rdap redaction act so james i'm looking at your first example here just above section four um okay and yeah i need to get to it myself hold on sorry about that"
  },
  {
    "startTime": "00:54:01",
    "text": "all right okay and the first so you say you know we're looking inside the redacted object and it's got a path member and i think it's actually probably got a json syntax error in there but let's not be pedantic so the first part of it is a filter expression right if i read this properly i did validate the the json path which uh which application used to validate them but uh they they were they were act they were correct at the time yeah you've got a uh a a new line a return in the middle of your yeah that's because that's because of the pagination oh okay sorry pardon me pardon me okay sorry about that you know am i my internal mental json path parser isn't that great um but this looks like yeah this is not you know honestly the uh there is a the name which we're going to be setting up in iana registry uh as well uh to enable for a more human readable indication of what the redacted member is but then to have the actual expression language for software to be able to identify elements so if you actually applied the json path you would expect to get an empty field back it depends there's two different ways to redact one is to remove and the other one is to have it be empty right so j j cart is the name of the uh of the rfc uh that's used in art app to express contact data and so uh that uses a heavy dose of"
  },
  {
    "startTime": "00:56:02",
    "text": "fixed length arrays and so uh to be able to redact let's say i don't know a telephone number in j card it's not removal it's actually blanking out or having to be a null string got it these examples are useful thanks um but on the face of it it looks to me like they're all filters we're not really using the n operator no no that's what i was asking i want to know whether or not in was applicable but yeah we don't have the use of the inoperator in this rat i think we just run out of use cases in that case yeah um i'm so let's the radical idea would say let's just take n out if you want disjunction just write a bunch of you know i can't disagree with it sorry did you say you did or didn't disagree i can't disagree it's yeah i agree entirely but um others are pushing for this so let them speak so i think our trait scenario where we need the on the right hand side a path would need the n is that not because i don't think you can use an or because i want to find you would use the filter expression you you would use the value that you're looking for as as the comparison value in a filter expression so you you just filter out all the instances that have that value and if that list of instances is empty then"
  },
  {
    "startTime": "00:58:02",
    "text": "you don't have a match and if it's not empty you have a match but how do i do a filter that says this array of strings contains one of these values are you talking about literals are you talking about things you find in the document so in in the target document there are objects that have a member which is an array of string literals yes and i want to get all i want to pull back the objects that have an array that contains one of one of those stringless rules yeah so then you have nested filter expressions you have a inner filter expression that goes through the array and gives you those array entries that actually are what you're looking for in the end you either have a match or you don't have a match and you use that boolean to actually control an outer filter that gives you the objects that have this array right and that's why i said we really need to create examples because it yes twisted thinking but i think it comes in quite handy at the end yeah i i agree i'm trying to create that in my head and failing so exactly not not made for hits it's made for editors okay i'm starting to hear that um uh we're not 100 we are not at the moment convinced that in really adds value as anything more than syntactic sugar and even at that level there's not a lot of huge demand for it um um carson as uh well one of us should should write that query i'm going to have to go off and ready to convince myself if it works but i'll take your word for it"
  },
  {
    "startTime": "01:00:02",
    "text": "yeah can can whoever's work taking notes make an action for me okay um so karsten are you okay with just leaving it out what is it the in i'm okay with it but i also was trying to accommodate what stefan said stefan what do you think uh regarding uh accepting structure types on the left hand side no just the the the proposal on the table is we don't really need in we don't really need the in operator yep we have a we have a lot of use cases that can't be solved with the filter operator well the field operator is is useful if the the right hand side comes from the document if the right hand side is part of the path expression then this is just a shorthand for a disjunction for an or but it still might be a rather useful shorthand yes it's correct you can you can substitute the inoperator through a chain of or expressions yes i think this is correct so it's you can uh call it uh"
  },
  {
    "startTime": "01:02:03",
    "text": "we can substitute it so we we do not need it well okay let's minimalize the spec it's okay i'm a minimalist [Music] and one advantage is that it's relatively easy to add later on because it would be a syntax error in the current spec so i'm i'm not feeling too uncomfortable uncomfortable with leaving it out because we can always edit data okay we've invested quite a bit of time in this shall we for the moment uh declare that we will simply not use this operator and you know note that it's easy to add back in if uh real demand manifests okay with me yes yes okay okay kirsten you want to move to our next issue yes we spent the first hour on the first issue and we only have about 36 left so um there is a proposal for an extension that that kind of adds x include to the jsonpath and i would like to not do this here speaking as an individual uh i think that this should be uh another ex part of whatever we do in the extension space i'm just looking at this thing to see are there compelling example use cases in it"
  },
  {
    "startTime": "01:04:05",
    "text": "oh my gosh it's huge i also tend to not include this it adds a lot of complexity to the spec there's also a ton of weird corner cases that comes with this yes it reminds me an awful lot of xml dtd's for better or worse yeah actually the main problem with the proposal is that it destroys data transparency so you no longer can have every uh json string value in your input document because some of these string values suddenly mean something else and that's a pretty big step okay is anybody going to speak up and say we want this thing um unfortunately the uh both uh greg and the uh aforementioned author's name is not here i don't think i think what we probably should do is uh comment on the issue uh with with sort of the consensus from this meeting that i think we should include this in the base rfc but we should leave it open that it should be possible uh when we if we support extensions yeah the fun part is that this can be framed as a preparation step before you apply the actual json path processing so it could be a completely diff different part of the processing model and wouldn't influence json path at all that doesn't mean you would implement it"
  },
  {
    "startTime": "01:06:01",
    "text": "way okay so um somebody will take the action item to um write a comment on the issue about this who who can sign up to do that i can okay thank you kirsten thank you thanks oops what happened oh um yeah number 123 is absent equal to absent so we are now in the the realm of comparison semantics and uh we we have json values that we can compare with currently just primitive values and we have [Music] paths that we can write into the comparison expressions and these paths of course can create an empty node list and the question is what happens if you have two paths on both sides of the comparison and both return an empty node list does this compare or does it not compare i see the javascript behavior is um that undefined equals undefined yes ever the optimist my natural inclination would done for the original is the original proposal saying it's false if i have two things that don't"
  },
  {
    "startTime": "01:08:01",
    "text": "exist i don't think i'm ever intentionally trying to detect that condition well and uh as uh who is it as daniel parker writes in j way you would it you know you get uh that match can never work unfortunately we have no undefined data type in json so we can convert it to false and this is where a lot of arguments came up when you compare existing value false to an not existing value converted to false must be true but i think we need to distinguish these cases and this is a little problem but it's no problem to handle these two undefined comparisons like javascript not a number where we are not a number is not equal not a number in javascript it's we i think we we are free to define it we don't need to handle it loud like javascript where undefined is equal"
  },
  {
    "startTime": "01:10:00",
    "text": "undefined yeah i have to say in my mind that this feels like not a number and the semantic the not a number in any comparison is always false yes yeah if one if one wanted the semantics that not finding something on the left hand side and not finding something on the right hand side means it's not the same then we could do something like not a number but for some reason i want that semantics so if if i'm comparing two issues and and uh one issue doesn't have a pull request and the other one also doesn't have a pull request why why shouldn't that be the same is the is i mean what you really want is an exists predicate which really asks the question you're trying to ask yeah we have that we have that so you can combine then that's what you should use and it should not we we want to compare a missing thing is equal another missing thing and in fact we are interested in the things themselves but we we can't compare them and discuss the missing of them it's i'm not quite sure what both both uh arguments have some little truth i think it's"
  },
  {
    "startTime": "01:12:00",
    "text": "a definition thing i can't remember how many implementations to uh equal and how to unequal yeah so see actually see bergman actually posted on the issue and saying there's there's no consensus not even a majority oh yeah yeah yeah i i remember basically naive javascript implementations will probably do it in the case of jsonpath though we're using boolean expressions primarily for filters right so it's the case of i want to go and retrieve a bunch of objects that meet a criteria in the case where we run into does not exist then we don't know whether it's equal or not equal so i would have thought the default behavior is don't return that thing if you can't determine whether or not the condition is met which i think is going back to the not a number approach right indeed i think that's a fair analogy so karsten you seem to be the one here who who likes this um well first of all we all agree on mapping the empty node list to a value and we we just disagree on whether it should be undefined or not a number [Music] and i think that that's a significant progress having that agreement and then we can actually look look at examples and use cases to decide the undefined versus not a number uh thing"
  },
  {
    "startTime": "01:14:11",
    "text": "so you had the use the one use case of you know what was it with prs with no um something or other issues npr's so you look at does does the issue have the same pr as some other issue and if it's not there then yes it has the same pr but if i want to to test whether it has a pr at all then i do what lynn wrote in in the chat so i would first do an existence test and and then do a comparison lens example had an existence test and a few more existing sets which is not what i meant but we have existence tests so we can [Music] code ourselves out of either decision uh we just have to decide so at the moment you would prefer undefined like behavior yes we don't vote we don't vote in the itf but at the moment i think you're in a minority there yeah yeah we call that in the rough because we don't count but it seems most people like like another number better [Music] than undefined to be more concrete here if i have two objects and i compare the color from both but they both have no color and i uh ask if a dot color is equals b dot color should be true i like carson's approach"
  },
  {
    "startTime": "01:16:00",
    "text": "if you really want to know if one of the objects has no color color is missing you can explicitly test that with the existence operator so at dot color and at dot color equals dollar dot color for instance yeah so you whatever we decide you can always write an existence test that inverts what we decided so the question really is which is the the default what happens if you don't uh further specify it with an existence test and yeah my gut feeling is that that undefined is uh the right thing so to to um paths that create no nodes are the same for comparison unless you go ahead and do your own existence check and i'm hearing other people saying that they would consider that unnatural my intuition says that the potential for surprises is greater in the undefined case but i actually don't have an example to back that up should we should we have a use case contest on this one yes please okay so i think our takeaway should and please this is just please disagree if you'd like my feeling is we should take this to the mailing"
  },
  {
    "startTime": "01:18:01",
    "text": "list and and store some use throw some use cases at each other and uh use that to guide our final decision yeah but we we have whittled it down to undefined and not a number so these are the two semantics that we have to decide between and that that's a major process great yes uh i think we just successfully got rid of this problem um yeah here the um [Music] we don't have an in-operator anymore and we have we haven't defined what a ray x operator is so maybe we can skip this one as well this was we had a long discussion about truthiness so what what does it mean to use dot foo as a standalone expression so what what does a path expression mean in the context of the expression [Music] language and uh for for comparisons i think it's it's pretty clear that we fetch the value uh that is at that place and we we still have to find out what we do if there is no such value but this is the undefined versus nan problem but for a boolean context we had some discussion on whether we go with one of those truthiness things or turn at fu in a boolean contest context to a pure existence test and my proposal is yes it's an existence test and there are"
  },
  {
    "startTime": "01:20:02",
    "text": "two reasons for that uh one is we don't have any other way to do an existence test and this is the best uh and shortest way to do it and second it gets rid of the truthiness weirdness that we all love in in javascript is an empty array true or false is an empty object true or false and so on it's a string with a single zero character and a true or false is a string with two zero characters and 12 volts um so we wouldn't simply simply would not open that kind of ones so so just you're you're in favor of pure existence test yes right does anybody want to argue for the you know the the alternative glenn no i fully support that okay that's what i thought i just wanted to make sure i was reading you correctly i i like it i just have one clarification if foo was present but a boolean member that's false it returns false even though it's present right no no i think that's what we're just saying but so if you want to use the value of that path expression you need to put in a comparison ah so you'd have to say at dot foo equals truth true you don't get at the value without using a comparison expression got it thank you yep"
  },
  {
    "startTime": "01:22:03",
    "text": "i sense something like consensus okay i invite that up again okay one eight yeah i think that's just the same [Music] issue and uh probably we can resolve it in the same direction i like to have issues like this at the end but yeah so the question was do we do any normalization in our comparisons and it turns out that existing implementations don't which [Music] being a german i consider to be a bit of a problem so this may be a place where you want to to do some extension sooner or later but i'm i'm happy with that as the basic uh behavior so it would essentially be a byte string comparison if you think in utf-8 or a code point sequence comparison if you think in unicode code points and we can always go ahead and edit normalizing later and we probably would add a normalizing comparison but also a normalizing indexing and that's maybe something that people don't have in mind when they discuss this so if i'm looking for i i think that if you want normalization you really sorry i chair hat off but i'm passionate about this one if you want normalization you have to ask for it"
  },
  {
    "startTime": "01:24:01",
    "text": "yes i totally agree with that because you have to say what kind of normalization exactly and and i think you know if you look across the spectrum of iatf rfcs um the the practice is is very uniform that um don't normalize just don't well it's a little bit more subtle but uh yeah you don't just normalize everything upon ingestion that that it was a mistake that should never be done by the way to be better i think i prefer uh code point comparison to a byte string comparison because that you know you might be using java and it's actually utf-16 inside your code you know you don't have to look at bytes right yeah so we can phrase it as budget and that's not called unit comparison but point comparison good uh [Music] i didn't write any texts for this 109 let's have a look here filtering without child selection yeah i think that the question was uh can can your well right right now a filter expression always goes into something and selects things from that and can you actually write a filter expression that is not going into something which is a bit weird but there were some examples in"
  },
  {
    "startTime": "01:26:00",
    "text": "that ticket i'm going through this trying to find the thing you can't currently do okay uh stefan has a nice comment back in july yes i re i'm reading my comment so oh gosh that was exactly my reaction when i read the slides i sympathize with you nuts and not summarizing this one question yeah so my take is this really all works like it should and you you have to work hard to come up with a an example where where it doesn't work"
  },
  {
    "startTime": "01:28:00",
    "text": "so maybe the main problem here is that came up after about half of the discussion that we don't have a good way to get at the key of an entry of the member i think i understand the the question now again we we we do have a problem uh to select from the argument take take the initial question there is the argument is an object having four members a b c d and we are not able to query the argument having a member named a or d it's simply not possible you all we can do is iterate over the argument and we get the values of each member but we cannot address the key so the the the subject of this issue was in the end i i think that we need something like at key or a function to address the key of that current selected member or"
  },
  {
    "startTime": "01:30:01",
    "text": "element makes no sense but the key of a member but only no not not only for the top level object but for every uh object but carson was correctly referring to the possibility to have queries containing queries but this is not possible at the top level and this is the problem uh addressed here i think if i remember correctly yeah once you have selected the value you have lost the member name that's really the the problem that we have in a nutshell uh for objects deeper in the in the tree we can resolve this by having a query inside of a query but this is not possible for the top level object i think having the key syntax seems like a fairly natural extension to support that well that means you can get at the key but then you no longer can get at the video isn't at the value in this case yes"
  },
  {
    "startTime": "01:32:01",
    "text": "that's why it feels kind of there's there's at for the value and at key for the key of the of the value referenced by app yes and and how do you construct something that you actually return assuming it would primarily be used in filters that's right you're looking for something that can be used in filters sorry you're looking for something that can be used in filters right right so at key equals a yeah but that still the filter gives you the value not the key so the the expression language would have a way of getting at the key but it doesn't allow you to return the key so you're essentially in the where clause of a select statement but you you don't get to modify the select part of the select statement so oh i see they want to return the key as well and they know that yes and this is entirely outside the current processing model which is why it's so puzzling it's quite simply as that you want to query the top level argument for uh owing a member named a does the top level object have a member named a that's at current not possible [Music] well the querying is possible you can write down the where will you but you cannot write down the select"
  },
  {
    "startTime": "01:34:00",
    "text": "what you get is the value not the whole thing was there actually a request in the thread for that because i think the initial request was just being able to filter by the key yeah i think that that was a bit of an [Music] unfortunate phrasing all we can do is to iterate over all members of the top level object and ask for their values but we cannot ask for the uh for the key so uh it's simply not possible to answer the question via a query does top level object have a member called named a you can answer that question but you cannot return that member how can i answer that question no no no it means earth a b c d if you are if you ask at dot a you ask for the first member do you have uh do you are you object and i have a member called a yes it's one level deeper what you return is wondering deeper but the question that you are answering is the same i'm trying to explain that this is really a problem with what you return and not a problem with selecting in the right place"
  },
  {
    "startTime": "01:36:02",
    "text": "the the ad is during the iteration process will deliver the members a b c and d and if you query at dot a you ask for each member do you have a member named a so it would be true hold only if a or b or c or d do have a member named a you wouldn't be able to use a filter expression because that has the semantics that you are describing you just would write at dot a so you you cannot undo the diving into the structure that the filter expression does but i don't think that's actually a problem the problem here is that people don't want add.a they want a new object that just has the member a and nothing else and that kind of projection we can do i'm confused this is a very confusing subject [Laughter] what should we do oh i i thought i understood it but now i realized i don't understand it oh i agree that we need"
  },
  {
    "startTime": "01:38:04",
    "text": "an example chapter in in in the spec where where we do need examples like this and solutions i'm looking at the very first statement of the problem yeah and i'm having trouble understanding what uh what he wants what does he want his output to look like what i mean what yeah i think we need clarification really he wants to select all sub-objects of the the top-level object except the last one so you need to identify the objects via their key but you can't so it reduces to the problem to ask the selected objects selected by it for their key right good go ahead if you look at the solution he provides he essentially is doing projection and again json path is not doing projection it's only doing selection so the where part of an sql statement it's not doing the select part and of course we could put that in but that would be a pretty significant"
  },
  {
    "startTime": "01:40:01",
    "text": "addition to the processing model i mean at some level the a member of an object is not really a standalone citizen where the member includes both the name and the value right yes but once you have a member identified by the ad operator you cannot tell its key anymore well that's the point isn't it that doesn't identify a member it identifies the value of the member yes so we've lost context yes you know a key function would be magical in a sense because you're applying key to a value and you're suddenly able to tell the context so i think it breaks our processing model and we should support this it's interesting because because we've noticed the problem properly in the spec we're doing we started with james bath and james path is optimized for projections and isn't as good at actually pointing at things it's maybe maybe the answer is you're using the wrong tool for the job if you want to do projections adjacent path should focus on selection yeah i confess to not having thought about this one enough i'm looking at the various proposed solutions and none of them are really beautiful"
  },
  {
    "startTime": "01:42:05",
    "text": "yeah so for people that are as old as i am jason passes x path and not exit 30. now if you had the at key syntax that would allow you to do selections based on what the key of this value was so it's still in the spirit of i'm selecting things not projecting things yeah um it just doesn't support you would go up in the hierarchy which we currently don't but that's a smaller change to the processing model than actually adding protection that key does i mean you know it's as if each val each each member value had a sort of a pseudo attribute a pseudo member of itself called key that point back points back to its parent right sort of like the dot dot on yep exactly but again i think you know we should probably hunt for examples as to uh specific cases where that's absolutely neat because it is only a problem at the root right and maybe there aren't that many scenarios where it's it's needed well the lack of projection is a problem everywhere so i think i could make examples that expose this problem at other places in the route"
  },
  {
    "startTime": "01:44:04",
    "text": "but i think trying to bring projection capabilities in as well is probably a much bigger issue true [Music] so where are we coming in on i think um i think we acknowledge the issue the you know the issue is a real issue um so first of all are we interested in trying to solve it um and i'm not hearing a lot of eagerness to try and solve this one absent some more compelling use cases it's a fact that this issue did come not very uh often in the past so it's not a very important issue i think i tried mentally to put this object in the first comment one level deeper and even then you cannot you cannot exclude the d member only in that case where you [Music] where you name explicitly the other members but this is not practically with big objects i think so it's okay i agree if we don't care much about this issue so should we say provisionally that for the moment we are going to acknowledge but not address"
  },
  {
    "startTime": "01:46:00",
    "text": "this issue and encourage anybody who cares to bring a convincing use case yes so i write won't fix yeah i think even with a convincing use case i wouldn't want to put it in necessarily because i think it's probably out of scope it's a significant extension of the processing model yeah and i don't think we necessarily want to address all use cases okay what got some got any more yeah we're on slide 14 of 37. i think we just closed this please look at the last pull request that was merged but i don't think we need to discuss this here i think we have consensus here so this was about the order of results and we are saying this is pre-order but acknowledging that objects are unordered in json so there is non-determinism and there are some better words in that request that should be explaining this seems like the only sensible thing to do this is pagination which i think is a good thing but maybe outside of jsonpath um so typically when um i would write a query i would then tell the api oh by the way only give me the first 20 hits"
  },
  {
    "startTime": "01:48:01",
    "text": "that i would see that in the api but of course there are cases conceivable where you want to have pagination inside a json path expression i'm just having a hard time thinking of such cases yeah i mean i mean the whole point is that jsonpass should be declarative right and it specifies what what the output is not how you access it well giving a number i want 20 of those that's still rather declarative so i'm not sure that is a good argument but i think a good argument is that this is something that an api usually does i i'm not sure i'm sold on the the scenario of paging but i think the scenario of just being able to say select object but only give me back five of them i think might be a valuable use case because i may want to present those on the ui i may be only interested in getting some sample set of data to play around with there may be a thousand objects in the target document but i only want to i only need a few in order to achieve my goal and rather than returning the full results and then throwing the rest away if we can save effort where the the selection mechanism only has to find a few i can see value there can you not do that with our slice i very possibly once again showing my ignorance on the spec"
  },
  {
    "startTime": "01:50:03",
    "text": "a slice only applies to raise doesn't it we're talking here about a node list that's true i think we need to decide if we uh want to uh allow or support some kind of post processing of the results of a query which i would uh suggest that this happens here or to extend the query capabilities to do exactly that so return only the last five or the first five or something in somewhere in the middle five elements of the of the result note list it's hard to do but it would return again a note list which subsequent queries would be both possible theoretically there currently isn't any ordering capabilities in the results right in in the json expression so i don't know whether saying first or last or middle actually adds any value i think it's purely just a limit capability that"
  },
  {
    "startTime": "01:52:00",
    "text": "is the useful thing oh yeah i'm coming down on the side of comparison here is this this feels like an api problem not a you know our title is expressions you know expressions for for json and this doesn't feel like part of the expression seems fair i agree with that and we probably also can come up with a way to take this information on to a json path if people find that convenient so we have in sql we have limit we have offset we have order by which is pretty important if you only want to have a limited number of results um so that would need to be part of that extension um but then i'm cognizant of time because we've got only about seven minutes left um and glenn you said you wanted to cover uh regular expressions which is still um a handful of slides down is that something we might want to cover and then leave a couple more minutes to wrap up and uh perhaps discuss when we might have our next meeting if we are uh having an interim sure cool so you know looking at the slide here um is the first option open to us is there a regular expression flavor that we could select there are two [Music]"
  },
  {
    "startTime": "01:54:06",
    "text": "i'm trying to swap in this discussion um we didn't like xsd for some reason well we didn't like one aspect of xsd so we essentially if we do xsd this means subsetting character subtraction is a non-starter in most implementations i guess my concern is that um regular expression syntax and semantics seems like an orthogonal concern uh to jsonpath we ought to be able to mix and match so um you know i prefer to not to have to freeze or pick a particular regular expression syntax in the standard but to allow you to make some matches so you could then have json path over xsd or jsonpath over re2 or whatever regular expression language you choose it obviously the limit's interoperation but i think it's it's more attractive for standard yeah but little yeah it's operational is a big deal i would hope that the same uh the same json path applied to the same argument would produce the same result modulo ordering uh consistently yeah i mean what i had in mind was that uh jason path over princess re2 would interoperate perfectly with jason path over re2 but not necessarily perfectly with jason path over xsd"
  },
  {
    "startTime": "01:56:03",
    "text": "well first of all regular expressions are a mathematical concept that that is expressed in these various forms of real world regular expressions and some of them are going pretty far away from the concept of regular expressions like like pcie and ecmascript that was built from pcie and some are rather closer you can actually use the implementation of regular language to to implement this um so that that's for instance true for the xsd regular expressions so by by defining a subset that is essentially within the the field of chomsky type 3 languages the mathematical form of regular expressions so we could have something that can be mapped to to just about any flavor that is out there but that's a piece of work that has to be done i have started it in in this irig x document but it probably needs a couple of more iterations before it's ready for consumption and implementers you know aren't i suspect in most cases going to be thinking about the chomsky type they're going to be thinking about what library can i use um because you know i don't think a json path implementer should have to also implement regular expressions they should be able to say regex.match yeah that was my concern really if you have to build up a mapping to your um whatever your language uh library is for regular expressions and do do a mapping of iregxp or whatever then it's puts a big burden on the implementer i will say that most of the people i interact with who are interested in"
  },
  {
    "startTime": "01:58:01",
    "text": "working with jason path are also in parallel working with jason schema um and so they have their they've picked their particular flavor and there would be value at least to that part of the audience to um doing something very similar what clever is that it's a they reference ecma 262 and then they have a recommendation of sticking to a subset [Music] so i regex might be the way to go for the json schema and for jsonpath also well so there's the possibility of the of looking at trying to adopt what jason schema did there's the possibility of subsetting w3xsd there's a possibility of writing our own so we have three options on the table all the various things before us this is the one that has the greatest potential to delay the product of this working group by years yeah absolutely perhaps we should take this little discussion to the list and present those three options well could we also include my option which was to factor out the um regular expression language yep"
  },
  {
    "startTime": "02:00:00",
    "text": "and realistic there's five options the other one is don't have them yeah yep okay shall we shall we leave as an action point to take the list yes please okay okay we are out of time and i have to go do some things anything else we can squeeze in yes the one thing that we do need to discuss is when our next meeting is itf113 is um happening in mid-march as i understand it and i also understand that it won't be in bangkok this time but i'm not certain of that should we be scheduling an interim meeting uh before then say in january or february after new year if we want to finish this we should have one about once every month yeah okay um perhaps it's too early for sorry go on let's try for january okay well okay i think we can put a doodle pole to the mailing list okay okay okay thank you everybody this has been super constructive um and i think we've pushed this thing a little further uphill and i'm optimistic that we have a finish line inside if we can figure out what to do with reggae yeah thanks guys it was great okay thank you everybody i have to be rude and run away right now bye thank you thank you everybody thank you cheers"
  }
]
