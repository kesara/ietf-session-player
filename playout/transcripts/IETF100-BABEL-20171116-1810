[
  {
    "startTime": "00:00:16",
    "text": "yes we have three present day sandy is the air is here and I can say talk about yeah we\u0027ll get started in a minute or two we have a sounding board not sure I\u0027m good Oh "
  },
  {
    "startTime": "00:03:20",
    "text": "yes hello okay hmm I guess we should go ahead here this is the Babel working group I\u0027m Donald Eastlake from Huawei yeah one of the co-chairs I\u0027m Russ white I just sit up here for because I\u0027m okay so this is the note well which I imagine most of you have seen before you should look at it in metered if you haven\u0027t by contributing to this working group or various other area IETF activities you\u0027re subject to the IETF IPR disclosure obligations it\u0027s a general request to review documents we\u0027d only do fairly good about that in this working group I think and this is the proposed agenda so we have scribed to take notes question is who have somebody to be a jabber describe for us yes and if somebody on job Neverland that wants to say something again will get repeated okay sounds good okay so I guess I\u0027m gonna talk a little bit about the status of things here we have a bunch of working group drafts there\u0027s a short applicability draft it\u0027s currently exist fired hopefully get rule reactivated shortly a information model "
  },
  {
    "startTime": "00:06:21",
    "text": "draft and the main draft currently working on is RFC 6120 six bits so people who aren\u0027t aware of the idea of the working group primarily moving the existing experimental Babel rfcs to standards track so 6126 is the base protocol draft this is revision of that which also incorporates extension mechanisms and there\u0027s also a source specific routing draft which is working with graph we\u0027re sort of connected in some mysterious way with the home networking group which profile has a profile for use of Babel no and there\u0027s a few personal graphs out there not at the bottom this slide are the existing experimental rfcs so we did okay on the first few milestones while we\u0027re running a bit behind on the current ones but hopefully we can agent progress on that RFC 2616 126 this has been working group last call and I believe it announced to end tomorrow which is when we were going to originally meet so we can maybe talk about that when the status comes up during some of the presentations and stuff but there was a good support on the mailing list so is David here Opik we have a microphone here other way when while David is getting ready I thought I would point out that on the network collective we\u0027ve been doing a history of networking a series of videocast and we had Julia\u0027s on to talk about the history of Babel if anybody wants to go find it kind of cool listening to them talk about where it came from instead could you post a link to the mailing list please Thanks all right all right good afternoon everyone my name is David skinned Ozzy and I\u0027m gonna give a quick update on two of the babel drafts so our main one 6126 Biss and these are specific routing so a lot of the actually most of the text and the dress is not mine it\u0027s Julius\u0027s and machos however the slides are mine so any mistakes for my fault it\u0027s not "
  },
  {
    "startTime": "00:09:21",
    "text": "theirs all right so Joseph ordered this to the list but in case you haven\u0027t seen it people are mentioning the Babel protocol in more and more places uh probably because it\u0027s blazing-fast I\u0027m not totally sure how that fits but I thought that was funny all right so kind of a quick overview of what we\u0027ve been doing with 6126 base from 6126 so the main goal is to go from experimental to standards track and a lot of it is kind of clarifying the spec from so we had a few people who did implementations from spec only who had feedback myself included and so we we made all the pieces that those people found just slightly confusing much clearer not that it was unclear before the draft of the spec was really good and we made two minor extensions to the encoding and one is mandatory sub T of ease and the other is unicast hellos so I\u0027m going to give a quick detail of those so Babel specified in 6126 base mentioned the possibility of extension of sub T Oh is an extension but didn\u0027t specify them that was specified in a second RFC later so one of the goals of 6126 base is to unify those two documents but also we realized that it would be cool to have a way to say that sub chilies are mandatory what that means is if you receive a sub Joey that you do not understand and that is mandatory you drop the entirety of e and the main use case for this is source specific routing so the initial version for specific routing and the first draft was how denotes own TLV yep Toni Pete question and Tony PJ / and with the mandatory bit you have proven already more intelligent than all the other AG peas combined in this forum thank you so force or specific routing now instead of having a TLV for specific routing and having like everything we defined in there now it\u0027s just one sub T of e that\u0027s marked as mandatory and the reason it has to be mandatory is that if one router treats a source specific update like a regular update occurs cause routing loops however with the mandatory bit when it sees it it just drops them so everything\u0027s fine and one of the other reasons is we also have another draft which is tossed specific routing and if you have used T all these you have to have a Tod for every combination one for social Pacific one for toss with a one for source and toss and so they cause exponential really fast so we\u0027re however with mandatories up to all these you can stack as many as you want so those are the main goals and so the other one was unicast ELO\u0027s so there are two reasons for those one is performance because on a few link there technologies performance of multicast is really bad "
  },
  {
    "startTime": "00:12:22",
    "text": "the most common one is Wi-Fi but also there are other technologies they don\u0027t even support multicast so in the original Babel spec you could run every TLV on unicast or would you guess however you wanted with to accept acknowledgments need to be unicast and hellos needed to be multicast so now we\u0027ve introduced a new concept of a unicast hello and that allows you once you\u0027ve discovered another house to run the entire protocol of a unicast so that\u0027s not only more efficient but it allows you to deploy security with unicast swing solution such as d TLS or IPSec as you may have guessed those slight changes to the protocol don\u0027t have full backwards compatibility however one of the great things and one of the reasons we design it this way is you really don\u0027t need a flag day that\u0027s really important because today there are active developments in Babel in production and it\u0027s just not feasible to ask people to update all the routers on the same day and from what Julis has told me the plan for Babel T which is the open source reference implementation is - so the codes already been written is to push the change that understands mandatory bits newcastle o--\u0027s and make sure like it drops mandatory bits that it doesn\u0027t understand and we can draw in gas flow as well and only much later or it starts sending them and that allows you to once you\u0027ve upgraded all your routers to understand these that you can start sending them that\u0027s pretty cool then for those of you who have been paying even closer attention I\u0027m just going to quickly go through the changes between - oh three and - oh four ah clearly the most important change is that I\u0027m now co-author that\u0027s awesome but apart from that things that actually matter we clarified a few things there was some confusion on the list for some of the data structures one of the really important things about Babel is that it only specifies the minimum of what needs to be specified to work really well and a lot of study can you hear me Lorenzo that might be the wrong room who is this we have someone in the ceiling all right never mind where was I yeah and so however it still gives really good guidance for implementers because really simple protocol to implement thanks to this and part of this was to make sure that those data structures are truly conceptual as guidance they don\u0027t enforce any way you don\u0027t have to implement them this way we also tweaked how we want it to present unicast hellos to make to give more flexibility the implementers and only give tips on methods that had actually been implemented and tested um another slight change that was made was on the whole time one of the problems well if you were tracked a prefix you can\u0027t "
  },
  {
    "startTime": "00:15:22",
    "text": "immediately start routing people to a larger prefix that encloses this because that could cause routing loops so the initial Babel spec said you had to have a whole time like on the order of 30 seconds and however Swann got a first name came up with a better algorithm which is you that solves things but you there\u0027s a better property if you actually have an acknowledgment from all of your neighbors to confirm that no one is gonna route that prefix to you anymore then you can release the whole time so that allows much faster convergence in those scenarios we also kind of discussed a bit more on sector requests the discussion on buffering and jitter became more of a should because jitter is not the only way to solve the the all router synchronizing problem we we can advice for how to do running router IDs and we made a few things give more clear guidance on sending requests so in terms of next steps with this document it\u0027s in pretty good shape the changes that I\u0027ve been coming lately are pretty minor and as dalla was saying we went through last call which ends tomorrow and might take chairs can correct me is that we had pretty good support the one item that I think needs to be cleared up before then is security and I\u0027m going to let Julius talk more about that in his talk because I think we all agree that security was really important we\u0027ve put work in to be able to make it easier so as you can castelo\u0027s and then the question that remains is how we specifically solve this and in what document any questions on 61 26 bits before I go to shore specific routing nope and so specific has just a minor update from below 201 we are mature I did more introduction background explaining what the this extension accomplishes and specified wodka request the dash 0 0 had several proposals that were up for discussion the working group it we reach consensus that basically Walt care requests are irregardless of all extensions so walk our request is when you ask another water and we\u0027re back so we are what care requests are when you ask another router "
  },
  {
    "startTime": "00:18:22",
    "text": "give it few updates for everything it has and the question was if a router that understands some extensions and so Walter requests the one that I\u0027ve sent some extensions that cannot be the same necessarily the same set what you do and the simplified answer is you just send everything you have it makes all implementations simpler maybe at the cost of some efficiency but it\u0027s worth it and that\u0027s about it any questions testing another good microphone do tell them that great so I guess you can keep it I\u0027ll put this one there all right well thanks we call Julie except so thanks for the presentation I guess there weren\u0027t any questions on that I think you\u0027re on right by talking the sound of a is the echo bearable okay so hello so i\u0027m julia scrubber track and i\u0027d like to say just a few words to start the discussion about babel security next slide please next slide yeah so first I\u0027d like to disclaimer none of the ideas in this talk are mine I\u0027m just going to summarize things that have been explained to me by Markus Steinberg Dennis of Shankar token and the audience and David skinny and Anton and ASIMO and in rough chronological order and so if there\u0027s anything I say today that is wrong I would like you to ask to blame them not me on the other hand if there\u0027s anything right I will be glad to take credit next please next please there is a delay before you see it I change it you say yes but then apparently takes two or three seconds before you okay thank you so the first thing I would like to stress is that babble is a completely insecure protocol so I\u0027ve been rather I\u0027ve been stressing this on the mailing list I don\u0027t think we should be saying that in our in the best RFC in the core specification that babble is susceptible to such an assertion attack we should be extremely clear about the fact that without any additional security mechanism babble is susceptible to any sort of attack so a babble announced "
  },
  {
    "startTime": "00:21:22",
    "text": "basically says look folks I can route back the package to that destination and if you send a false update if you spoof an update for ITF prefix then you can pass yourself for say the ITF website and redirect all traffic this time to the IDF\u0027s website now people think that you need to be sent the network sir can achieve a lower metric that\u0027s not the case if you cannot achieve a lower metric you can do the attack by using a higher SEC no and there is something that is just works in any routing protocol that uses the longest traffic semantics just do a longer prefix attack and that will catch the traffic with no effort next please now the okay now the other thing to understand is that babble is vulnerable to replay so even if for some reason you cannot craft a false applause update what you can do is capture a properly formulated say a send to find update wait until it is legal to send it again for technical reasons it will take between a few minutes or a few hours so you capture a lot of updates and once you have a collection of AB days you just resend them so what that means is that in order to be suitable for babble a security mechanism needs to be able to protect against replay next please now I would like here to fix the scope somehow somewhat there are two basic approaches so very roughly speaking there are two approaches to authentication one is the end-to-end approach you identified another an announcement at this source and every receiver of the announcement will verify it and the other is the hub to hub approach if when it\u0027s the only the communication between net neighbors that has a sanctified and any properly identified node can spoof any data now end-to-end is the holy grail it\u0027s something you would really want to be able to do but in practice it\u0027s extremely difficult and so I think we should consider it as somewhat out of scope which doesn\u0027t mean we shouldn\u0027t be able to experiment with it next please so there has been quite a lot of work on security in Babel and the user base of Babel basically using two techniques one is to use lower layer security that could mean a physically secure Ethernet but the guy was a machine gun in front of every third neck socket this can be radio links protected by some link layer protocol such as wpa2 and people have been running babel over VPNs most notably oaken DPN and the other approach is RFC seven to nine "
  },
  {
    "startTime": "00:24:23",
    "text": "eight which is a fairly complete I\u0027m going to say a few words about it later protocol for authentication at the application layer of Babel now this has served as well losers haven\u0027t been clamoring for other mechanisms however we are now aiming for standards track and so we need to define one or more security mechanisms and let\u0027s send a clear message to the user base saying look unless you have a good reason to do otherwise this particular algorithm is the one you should be using for security please so what are the approaches I know about for Babel I think my analysis is that there are two serious contenders for being the one security algorithm one is to use an H Mac approach together with a replay protection mechanism so that\u0027s something similar to what OSPF does with RFC two three to eight five seven nine nine seven four seven four and of course there is Dennis\u0027s extension for Babel seven two nine eight and the other approach that is being considered is to use DTLS but DTLS is a unicast protocol and so you need to run babel over unicast and there are other approaches and i don\u0027t think there are strong contenders right now but I wouldn\u0027t like two people to feel that they should be prevented from experimenting there is lower layer security approaches there is something similar to what was proposed for DTLS but using IPSec I think the person who suggested that is in the room there is something that users have been clamoring for and that might come in the sir to some of you plane tax password you know you just dumped a plaintext password in every babble packet and if the passwords don\u0027t match you drop it it turns out that that sounds quite a lot of problems because most of the so-called security problems are actually misconfigurations I\u0027m not very keen on implementing that I don\u0027t know how well it will go and I\u0027m in doubt and I have no doubts that there are others next please so the protocol that has been suggested quite a lot due to Dennis of Shankar who has who has designed and implemented and written it down in RFC seven to nine so it uses H Mac based in integrity and a certain tenth occasion it has algorithmics ability with two mandatory to implement algorithms and it has a fairly refined scheme for replay protection that doesn\u0027t require persistent storage and doesn\u0027t require hardware clocks and that\u0027s important because we want to be able to run babel and embedded hardware now seven to nine nine eight is reasonably easy to "
  },
  {
    "startTime": "00:27:23",
    "text": "implement I haven\u0027t implemented it myself but I\u0027ve checked Dennis\u0027s implementation however it\u0027s a new security mechanism and some people are a little bit nervous about having a new protocol stack and so that\u0027s apt something that\u0027s absolutely great if you need to implement it from scratch and as was explained in Prague RFC seven to nine eight has a rather subtle flaw that needs to be fixed next please so the other serious contender is DTLS with Babel so the idea is the first suite Babel to be a unicast only protocol to use multicast for discovery only and all the rest of the protocol you run over unicast duplicating announcements to every single neighbor and then the unicast traffic is protected using VT less so DTLS is something you\u0027re not going to re-implement from scratch just for babel however it\u0027s an already existing security mechanic so that\u0027s a solution that\u0027s great if you already have a DTLS stack it\u0027s absolutely horrible if you need to reimplemented from scratch and that the idea has been around for a long time it was explained to me at different times by Markus Steinberg Toki Highland and David skein ASCII next please so the original plan when I designed Babel back in 2010 was that any GL he could be sent on it over either unicast or multicast and then there are two cases in which I didn\u0027t achieve that hello\u0027s can only be sent over multicast in RFC six one two six and ax can only be sent over unicast acts are not you\u0027d match in the protocol but hellos are you are essential and in six one two six bits David and pokey have fixed about one now all Bible two Yogi\u0027s can be sent over unicast so it\u0027s now possible to implement Babel over unicast only and only use multicast for discovery so that means that you can use a unicast family security mechanism and it helps people it pacifies people who have an irrational dislike of multicast you know who you are next please so we\u0027ve started working on that last summer together with Antonin decimal and he basically did all the boring bits understanding how it needs to be done what needs to be done which DTLS library to use and at that point just as he was going to get to the interesting bits he ran out of summer and his work has been extremely useful he identified some tricky parts first of all we need to decide which tlvs we allow in multicast so we are going to allow some unprotected TLD because we "
  },
  {
    "startTime": "00:30:23",
    "text": "need to do the discovery of our multicast and DTLS cannot protect multicast but that means that you have to specify exactly what do you drop and how do you allow protected packet.d TLS is client-server Babel is peer-to-peer so at some point you have to make the impendence of the to the TTLs libraries want to use connected socket and the Babel implementation uses the sample implementation of Babel users and connected sockets and finally the implementation is extremely inefficient if you starts running everything over unicast next please so here are some preliminary answers to that question to those questions the witch deities do you allow in unprotected packets the simple solution is to say hello only but in this case you are allowing somebody to spoof hello\u0027s which makes you vulnerable to the US is that a problem is that not a problem in do we want to solve it it can be solved if this turns out to be something we don\u0027t what DTLS has time server Babel is peer-to-peer well-thought you can do that after discovery you decide that the guy with the smaller or the larger it doesn\u0027t matter Rooter ID is the client and the other one is the server there\u0027s an issue if you do out-of-band discovery discovery is not being done in the protocol you might do discovery in some other way that doesn\u0027t give you the Rooter ID and at that point you need some other mechanism details libraries won\u0027t connected sokka\u0027s we\u0027re using unconnected sockets and here it\u0027s a little bit involved I won\u0027t get into the details it was explained to us by marker Steinberg you need to run the library in memory and do all in to talk with yourself and finally well we do unicast inefficiently in the current implementation because the current implementation does not use unicast much this solution is to rework that that\u0027s a simple matter as hacking and the only problem is that there are only 24 hours per day next please so it\u0027s not my road to tell people how to work on but just in order to start the discussion I think that we should consider thinking about producing a revision of seven to nine eight that fits well with six one two six bits and solves the security flow of the current read the current version and ideally we\u0027d have at least two interoperable implementations we definitely want to experiment with DTLS over unicast I think we could finish that in a reasonably short amount of time once exam time is over and ideally again we would have two interoperable implementations and we would write down all the tricky details that have to be solved I think that if we succeed in "
  },
  {
    "startTime": "00:33:23",
    "text": "those two points we might be able to publish both but we need to pick one which is the recommended one and of course if people have other ideas and other plans I very much want to hear about them and those two plans should not prevent other people from experimenting thank you for your attention okay people have questions comments deerskin Ozzy Apple thanks joy yes I was how we\u0027re getting some pretty bad echo from oh yeah I just wanted to play that I personally really prefer DTLS to 7298 because of the flexibility it gives one example is that you can bootstrap ETLs lives symmetric keys or a symmetric keys or a PKI or whatever you want so it really eases the trust model which is a question that\u0027s still open no net right now which is one of the use cases for Babel and also it gives better security than the H Mac extension given that it encrypts everything as well which is always a nice property so that\u0027s kind of my take regarding the mandatory to implement topic I would so maybe not today is not the right time but I would be mostly against that because if say you have a use case where you\u0027re running everything over IPSec then you probably don\u0027t need this but I think in a scenario where we want things to interoperate like for the whole net profile for example we could make it mandatory and that might be the right solution my mind are you hearing this really agree with everything that David said it is probably good for you to be muted because otherwise is feedback this is time and so Julius one of the things that came up when we were talking about security on Wednesday is that you\u0027re using the multicast packets to check link quality and that that can be used as an attack if they aren\u0027t authenticated have you have are you is that is that a true statement currently over Wi-Fi we are using multicast for link quality what needs to be done once we switch everything to not vary unicast is an open question so there\u0027s the comment I made at the end about the do s threat which is oh all you can do is hellos as do as this "
  },
  {
    "startTime": "00:36:23",
    "text": "system is that a problem for us okay so the other question is have you looked at how things have changed in TLS DTLS 1.3 Noah heavens okay it might be worth investigating that because I think it\u0027s I think there are some significant changes and you know given that this is essentially new work we might as well if there\u0027s something in DTLS 1.3 that makes it better for us than DTLS 1.2 okay do you have anything concrete in mind here or just generally speaking about the one point so so unfortunately my cache is blown my recollection is when I looked over DTLS 1.3 it seemed like it was it seemed like it would be better but I don\u0027t really remember why that was so I need to reinvestigate that as Steven biologists today ago yeah I mean I think it\u0027s given that this is a kind of a greenfield using T that\u0027s 1.3 is probe probably going to be cleaner because you don\u0027t have any backwards compatibility issues but DTS implementations probably will so you may get the backwards compatibility so when you go and try and pick up somebody\u0027s code to just do it might make that much difference so and then are the MT I think so there is a there is a BCP that we have that says you need to have an empty ice security answer for things like this it does have a few get-out-of-jail clauses which might apply for things like HomeNet because they\u0027re small so you\u0027d probably get pushback so I think if if you can come up with something that people are happy enough with with everybody I\u0027m having implemented that would be better so good ok so the main point I think it\u0027s premature to have this discussion right now right now we need to have a solid proposal we need to have a solid proposal and the solid X and the solid implementation once we have a solid implementation and a solid proposal then we can do all sorts of fun stuff like discussing nti issues that makes sense it\u0027s Ganassi I agree as well I wanted to respond to Ted\u0027s point so I\u0027m not a TLS expert but one of the as far as I know the changes into in detail s13 wouldn\u0027t really make big changes here it\u0027s obviously a better protocol however also TLS and DTLS are designed for forwards and backwards compatibility so whatever we come up with I think I don\u0027t think the version of TLS is a big deal Ted "
  },
  {
    "startTime": "00:39:27",
    "text": "lemon again so so the thing that I remember and I may be Stewart sorry maybe Stephen can tell me whether I\u0027m completely all wet about this is I seem to recall that DTLS 1.3 is a little bit easier to wrap into protocols that weren\u0027t really designed with DTLS 1.3 in mind but that may be a completely wrong recollection because that\u0027s teen program and I don\u0027t think so particularly but I think yeah it certainly is worth looking us and you know a profile of DT that\u0027s 1.3 for this might be smoother because it is better designed however again I\u0027d say that I imagine the likelihood here is that people won\u0027t write new T TLS implementations they just pick one up so it\u0027s going to do all the versions and so you get all the crap barbar start so I some of what I\u0027ve heard about the 1.3 is that they did deprecated a whole lot of things as no longer being permitted to be used and that certainly would be desirable but it\u0027s my understanding that the protocol itself didn\u0027t vastly change you know all of the handshaking and all of the underlying mechanisms so it it might be useful to consider that yeah okay are there further comments or questions Billy David Dennis wanted to but I believe he cancelled himself from the queue not pending now yeah this is um Barbour again I do have a question so Julius if I\u0027m listening to you correctly would that mean also that from the perspective of the HomeNet profile that you would suggest kind of holding off on that until we have a security recommendation here I would never suggest what this profile has been two years I would never suggest holding off on that I want it to go out as soon as possible Barbara oh okay Dennis isn\u0027t going to type a question I guess right so okay okay let\u0027s move on then sandy do you want to give your talk now "
  },
  {
    "startTime": "00:43:07",
    "text": "okay afternoon afternoon i\u0027m sanna down from the GE this presentation is for appearing ipv6 we have co-author Tony that\u0027s the first Allah to see the motivation of this dropped government\u0027s lack home net may not have hardware support for peer encapsulation and pure s or even support for special Ethernet type it means that and the process in PR working group there is also am pure as encapsulation and Ethernet an encapsulation poppier but the internet helpful for peer has has not been allocated from a Tripoli so there we have only from now until now we have only the MPS encapsulation functions for comparing capsulation um and the 91 pv6 encapsulation for peer hope I hope forwarding in pure ipv6 a Berman\u0027s could allow to process peer in the slow path and like a control plane processor and please feel free to the slow path because we just mean and the network this kind of network folks more than folks more pay more attention to service\u0027 divert diversification then forwarding efficiency so please feel free to this world we not mean that you\u0027re not your network is bad all your 40 if in just as a too slow no no just from feel free for it and the important reason for fear is the the most important for this solution is here is simply another next protocol for ipv6 ring and you know that it will take a long time to achieve using at the tab from my people year and so we think this watching will if you explore the peer employee in crime environment so mmm is the solution the solution is very simpler and the para designation of ipv6 package\u0027 and said to the neighbors link local address or well of the Lubeck interested yes once the destination is asserted to the neighbors loopback interface address the edges should be the same is the neighbors be AFR prefix that\u0027s its defining in peer architecture and the source of the packet he should be the "
  },
  {
    "startTime": "00:46:07",
    "text": "BFI ask unified interface address and the address should also be the same as the BFI as prepare for prefix and efi a means the ingress router of the domain when domain so it\u0027s defined also defining impure architecture structure and the TD air should be set 1 because we think Pierre is a hop by hop forwarding punching and in order to avoid the loop all the other things so we said that if he are said to the set the TDR to 1 it will guarantee the beer for working correctly and the next protocol should be defined to indicate the following pair packager another flow ID is the copy of entropy field in VR encapsulation so it\u0027s very simple the pure header is follow following the ipv6 header the Fermata is aligned with PR NPA ampere as encapsulation doctor for a now and purest version so we know that the s and the PCBs have no significance here and the pifd ID is also the combination of stop the man said I didn\u0027t for bits jinglun the remain feel the remaining fields are unchanged the ways the PR and purest encapsulation dropped so it\u0027s simple function and questions okay I\u0027d read the draft or I think it\u0027s some cool work and it looks to me like it\u0027s eminently implementable right right as either to come implementing the PC or in the small network oh whatever why you want to use that you can implement an English machine so you can verify the possibility of this function and at the later I will do this there is a one thing that is not entirely clear to me so now we have multiple encapsulations for a beer so suppose you "
  },
  {
    "startTime": "00:49:07",
    "text": "have a control protocol that is so you have a control protocol that is negative that is announcing beer roots so it\u0027s babel for argument\u0027s sake how does it know which encapsulation to use on a given link how do I know that on this particular interface I\u0027m going to use the ipv6 and encapsulation rather than the native encapsulation I think I prefer the loopback interface at address for the encapsulation of course the link local address is true but I think the Lubeck it\u0027s Ãºnica that uses the loopback interface address of neighbor and this and the destructor is for the data forwarding plane of the tier 4 of the PR technology and the previous slides is full of coupling of 104 how to build is a peer forwarding so if we combine it it worked we can we had to be are reformulate my questions you have this beer extensions for advertising beer roots in OSPF and in babble should extensions you loose Tony P so yes correct is our heat actually unspecified but if you think through that if I announce to encapsulations possible encapsulations for the same combination of whatever we have their nose subdomain si I can run per link a different encapsulation of my choosing okay and I think that\u0027s worth the architectural go that\u0027s unspecified currently though with that will be able very easily we will be capable to very easily basically migrate from this kind of hack right which allows you very quick deployment to something like reports the issue type is really really wonderful in signaling question captivation to you it\u0027s yes it could but it\u0027s a differentiation without distinction I\u0027m not sure I understand that perhaps I should let you know this term right okay it basically means yes you could and it will behave in a specified way but the ultimate outcome will be the same whether you do that or not because it\u0027s a help I hope forwarding paradigm don\u0027t forget so I know from both sides that the binding "
  },
  {
    "startTime": "00:52:08",
    "text": "exists in fact I just need from the destination site to understand that the binding exists and the encapsulation confusion signal ah it doesn\u0027t matter in fact all right we can take it over oh okay I guess I\u0027ll leave that up yeah that\u0027s the end of the agenda items a couple items there to discuss on the list including the security questions and any technical details these things so anyway I guess we\u0027ll see people on the list and at the next ITF meeting perhaps in London in March so thank you all for coming I think that people mostly at this meeting did an excellent job of giving their name when they went to the microphone without even being much that much which is pretty remarkable and thanks to Barbara for volunteering to take notes and so forth that\u0027s it alley-alley-oop jeburk the red one "
  }
]