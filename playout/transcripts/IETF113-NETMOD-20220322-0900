[
  {
    "startTime": "00:00:05",
    "text": "normal like pre-covered ietf they're confusing hard time believing but then i think they're uh they're looking at the total attendance remote and so we're at the top of the hour okay so we click started we definitely have less people in the room physically and virtually than normal but uh welcome to netmod at ietf 113. um you have the chairs myself lou berger uh kent watson and joel juggling and in the room we have charles eckel who's uh volunteered to help us out um uh it doesn't look like he's gonna have too many people in there to uh to manage but we appreciate the help very much as this is the ietf we have our notewell which talks about um our rules governing our participation in these meetings in our mail lists and uh in the physical and virtual uh hallways and if you're unfamiliar with it please take a look at the uh note well and uh similarly we also have a code of conduct that talks about how we should treat each other professionally and with respect on the administrative side we are using meat echo for q control there actually is a nice slide for those who are local who that talks about how to do that but we're in the second day now and all three or four of you are professionals at this point at the new meat echo tool um for the rest of us uh you're hearing this so you've made it uh welcome uh i've put the note-taking link in uh the chat also there's a nice button for"
  },
  {
    "startTime": "00:02:01",
    "text": "meet echo to take you there please uh jump on to that the hedge dock the notes page and help ensure that we capture um any of the discussion in the meeting you don't have to capture all the presentation just the the discussions all material is posted and we're driving it from a presentation from that from the data tracker and from the material manager first up on our agenda is the important topic that we've been working about versioning and we've had two documents go through working group last call recently and we have another set of documents that we're hoping to last call soon but the authors tell us there's some issues to work through and that's what we'll be trying to do here um uh the uh if you look at the hedgehog you'll see that there's a version of a slightly modified version of the agenda in there and you'll see first up the overview is going to be covered by joe clark so that's the first dvd and then yang packages is going to be covered by uh by jean we have several non-chartered items as well and of course the the node tags which is the working group document since the last meeting we've had several rfcs published that's great after all that's why we're here is to get these documents through the process appreciate everyone who worked on it whether you were author contributor or just working group member who commented on it so thanks all um for getting us over the hurdle of getting those documents uh published"
  },
  {
    "startTime": "00:04:04",
    "text": "we have uh two documents which are almost perpetually post last call waiting on a minor update uh and expired and i was gonna put the person the author on the spot i saw he was about to move uh maybe he wants to come to the mic and say something yes rob wilson cisco so yes i i had tried to find some a co-author to help with this um last late last year and that fell through and there's somebody else who's interested scott man um manson said he might be interested so i'll chase to see if and get him but i need i think having somebody else to help me on on finishing these would be helpful uh but otherwise i still want to get them completed it's just fun in the time all the other workload so apologies uh just occurred to me maybe reach out to don who commented on it earlier and see if he'll help you out because i know he's become more active in the idea don fedec try him us we can talk hopefully okay uh yeah we look forward to like getting that done uh they're very useful uh pieces of work and we don't want to lose that that went there all the effort that went into that um we have uh three others i mentioned the last two um that we have got mine's killed in the tower go ahead oh thank you all right scott do you want to say something scott we can't hear you here's some issues yesterday with this michael son i don't know there we go well we lost it all right not just for your information i never saw the mic button go the color it means that you you're unmuted so you were muted that whole time uh kent uh do you want to add anything"
  },
  {
    "startTime": "00:06:01",
    "text": "about uh 69.91 only that it completed your class call and it's i think it's on me now to do the uh shepherd write up and move through the process okay uh great yeah on the the other versioning documents um we did get some uh comments we i believe a new rev is is needed these documents will once they're complete we'll um we will hold them until the whole set is ready to go so there's other other documents that are on the agenda until they're ready uh once they're also passed working group last call we'll put them through the isg as a set so they can be processed as a set um that's uh that's our plan uh we have one document that was returned to the working group it's not on the agenda um it needs um uh it doesn't need a lot of work but it needs someone to pick this up uh to really close on it kent you're looking for a volunteer to help out there right uh volunteer for syslog yeah or do you think that's covered up yes if someone could help with that it's a it's a working group document it doesn't need to be the original authors um really all that needs to be done right now is to update the i think the examples uh i mean originally it was to go through the whole thing to make sure um you know what all the needed updates are but i think a quick review and i i feel like it's probably just a matter of updating the examples and then putting it back into the queue that's all we need someone to help us with that very easy all right well if anyone's willing um please contact the chairs or even better just uh uh um suggest changes on the list and then we"
  },
  {
    "startTime": "00:08:01",
    "text": "can uh close this document out and bring it back to the ihg we've had no incoming uh liaisons or communications and um uh i think we all are well adept at working remote just a reminder though that we do um we can do formal interims and if you have a topic that you would like to request to be a formal interim just contact the chairs and with that we're ready to move on to uh the versioning update joe are you here you're here yeah i'm gonna pass slide control oh you're in the room even better hey joe uh charles do you want to take uh slide control or i'll send it to you is there a thing or you just okay i don't know if we don't have a clicker for you so you might need to tell me i can for future speakers the app uh lets you do that if you had the uh meet echo app but since you don't i gave it to uh cool this is uh even though on the agenda it says that this is going to be mainly on module versioning um and and yan would cover uh simver this is going to cover kind of an intro where we are as well as module versioning and simver uh i'm joe clark your host for this particular part of the program next slide please charles so that's me uh i it says rob will be presenting packages but jan will actually be presenting packages and in"
  },
  {
    "startTime": "00:10:00",
    "text": "this deck we have some backup slides that cover kind of the wherefore uh some examples but we won't bore you with that we'll just focus on what has changed since 112. next slide please so just as a recap these are the five from the requirements doc these are the five drafts that we are going to come up with some of which have already happened and we'll be focusing on the semantic versioning and the module versioning and then as i mentioned yan will get into packages and the next set of work in the order um that we are going to look at it are the protocol operations so version selection uh is next and then the tooling around all of this uh the yang the related yang tooling um to process the uh the versions to uh look at uh like the lineage of these yang modules um all of our work is being tracked in git so we we kept the old design team um get repo we have issues there uh and uh next slide please we meet regularly every tuesday in fact today is a tuesday and we are going to have or at least attempt to have our meeting today um it is at 2 p.m or daylight savings time and we're kind of in this interesting bubble where the u.s switched and the rest of the world hasn't yet but generally it's around 9 a.m eastern 2 p.m in the uk we have a number of represent representatives that attend us consisting of operators various vendors where we discuss all of these five drafts and we've kind of been tackling them in the order that you saw on the previous slide these meetings are open to all we host them on webex the chairs set that up so by all means you are are free anyone is free out there uh i think most of the people in this room actually attend those meetings um"
  },
  {
    "startTime": "00:12:02",
    "text": "but you're free to join and and help us with these discussions we bring back minutes and we bring back discussion points to the list jason stern has typically been doing that so you'll see updates uh on the netmod list as we discuss things next slide please so what have we been doing since 112. as lou mentioned we we got the module versioning and we got the simver drafts into last call and we'll talk about the comments we got on those in a bit so we've been focusing mainly on the packages on what what is the the kind of the where for the why of yang packages what does the structure of those look like we've explored uh different uh kind of different layouts or different architectures for that opening and closing some issues we've talked about different types of packages and yan will get into this idea of an api package versus an implementation package as well as what is the metadata around yang packages what does that look like and what are the use cases that led to as i mentioned a ton of issues and we've been working through them what's going to happen next as we'll see is we're going to focus back on the working group last call comments that we've received on the the two drafts already as well as continuing in in this packages work next slide please so module versioning so this was the the first draft and that leads in december uh we just closed working group last call um lou mentioned uh there will be a revision uh at least one revision of this draft uh jurgen italo and andy brought up issues we haven't had a chance yet on the the kind of the author's contributors call to go through all of these that's going to be kicked off probably today if we get some critical mass but certainly in the next few weeks"
  },
  {
    "startTime": "00:14:02",
    "text": "we'll be discussing these issues and you see some of them there we had some contradictions in normative language around file names and ultimately we want to clarify and improve and discuss different ways or different complexities with the solution so that we're for the most part from a a consensus standpoint that we're comfortable with with what the yang versioning the module versioning solution presents and how it will be used uh next slide please joe before you go on i should have mentioned that uh based on the update we'll decide whether there needs to be a second last call if it's mainly editorial and consistency checks uh uh changes we won't do a last call but if there's something really substantive there that needs to be discussed at the working group we will my feeling right now is leaning towards not but you know if the authors feel differently that's important input also thank you thanks um we will i i i i kind of um evaluate some of what uh jurgen andy uh and atallo especially on on module versioning have said it's kind of like what an aed might to do it might do with a discuss i think it's going to require a lot of that discussion back and forth and the the changes that come out of that as you said we'll see uh the level of substantive change that needs to happen um and and perhaps a another last call might be warranted um with uh the semver draft uh mainly jurgen responded but italo we'll we'll actually look at atallo's comment in a second here some of uh jurgen's changes were fairly editorial uh in nature he recognized some typos um some some things that were"
  },
  {
    "startTime": "00:16:01",
    "text": "quote-unquote low-hanging fruit to fix they have already been fixed in our get repository however there were some things that will require that additional discussion and so i've raised issues for that and we're going to go through them again anyone's free to join and help us with those conversations and we'll get back to the list so we're not ignoring you year again we will we will get back and address um these items that we uh we have as issues here uh next slide please it's hollow's comment was interesting so he asked what about in in like the code begins or in uh rfc version three format the source code what since we're proposing an alternative file name um and this the alternative file name is with the revision label which can be a yang simver we would in the module versioning draft we state that you'll use a hash mark to delineate that what comes after is a revision label italia asks should we change the code begins and the source code tags in the uh internet draft language to accept those um alternate file names and if we do if we do do things other than a revision date do we run the risk of blowing up the line length because you could have a fairly long module name with some ridiculously long revision label as well um so we discussed this a little bit and the the consensus among among the contributors is keep it either as it is now or or rob is actually fairly keen on what if we stipulate that don't include anything just the module name and this is where tooling will come in and find the latest revision in the module and extract that to a file as both module name at revision date and module name pound or hash"
  },
  {
    "startTime": "00:18:01",
    "text": "revision label as is present in the module this way it's it's a little simpler it actually reduces some of the errors we've seen in extracting modules where people change the revision but they don't change the code begins tag and hilarity ensues with the zim tool and and what's happening in the data tracker in yang catalog so we're going to figure out what's the best solution do we leave things as they are now that's obviously easiest or do we add some text that says we recommend not including the revision date there either and and leave it up to tooling to do the right thing so that's kind of the one issue we discuss we are of course open in all of these to what the working group may uh may want to suggest or offer in terms of guidance next slide please the other uh big thing that was raised so so jurgen commented on the the last call uh on that thread that lou started and then started a new thread uh in parallel to that uh with an alternative to yang simver and to some degree um the the module versioning as well um and just by way of an example and this is directly from his email what if on every node where there is a non-backward compatible change that's nbc non-backwards compatible there is a tag that is added nbc change as an example listing the revision date at which that non-backwards compatible change was introduced and then describing what that non-backwards compatible the semantic change uh need the semantic change that was uh that was done in the beginning a while back when we first started talking about uh yang versioning um this was brought up there was some discussion um with this there was"
  },
  {
    "startTime": "00:20:00",
    "text": "some back and forth that maybe this would add too much verbosity um this could be something that that gets moved into the tooling section but it needs further discussion uh we we fully admit we've read uh we've read this we've we've heard both jurgen and andy's comments here or read them i should say and we're going to discuss this um further and and decide what the the the response what the action to take here uh is going to be so this is going to be one of those uh items that gets added on to the to-do list for our weekly calls after this meeting next slide please all right so this takes me towards the end of my section and and i'll be handing things over to yon as i mentioned we're discussing these weekly uh the issues here you can look at our whole issue tracker at the the github project link there and you can also look at the latest revisions of all of the drafts and see what state we are even if before we publish to a data tracker um so uh going forward we're going to address we're absolutely going to address those working group last call comments that we got on versioning in simber we're still focusing very much on the the packages draft and getting a lot of good input from the the various participants on our contributors call and then we're going to break into those those final two final two work items on version selection and the schema comparison or the tooling uh as it were once we're kind of getting that same last call state for packages so uh any questions before i hand over to yon i just see yon in the queue i think unless jan you have a question i think you're there to present and i can uh relinquish the floor"
  },
  {
    "startTime": "00:22:01",
    "text": "yeah i'm ready thanks charles okay yeah thanks joe john do you already have control of the slides or do you need that i seem not to have okay i'll give it you should have it in just a second well for some reason it's not letting me switch glide right now so yawn you should have it yep okay thanks it works now so now presentations charles all right okay okay there were more slides in that one so i thought he was uh taking over uh no it's it's the next presentation i don't know why it's not letting me have to do it now uh let me you have to pass control back to me i'm doing that now then that's odd do you have control yet lou uh no it says it's uh taken so maybe you can you can do that if you have control okay oh no i i think i can do it here i got it now yes it's just a little slow there it is thank you you now have control and you know and for others you have to take control remote control and then you have to then you can make the change and then give control all right thanks we're all working so uh first a few updates on what's happened since 112 and uh one of the things we've been talking about is something we call issue 57 it's about what we do with mount points when they appear in packages i mean mount points are not used extensively at this time but over time they may be more"
  },
  {
    "startTime": "00:24:00",
    "text": "common and the question is what do we do if there is a mount point inside the package uh should we in some way prescribe or allow an implementation to prescribe what sort of packages that may end up being mounted on that mount point or not and it's an open discussion let's say another thing we tried or discussed is about the how packages are communicated when you connect to a device how do you know which packages are implemented on this device i mean if you remember from my discussion earlier about how net conf performance can be increased i took a real world application and measured it for one hour and all the traffic that was sent there to a particular device and we found that in that particular real world application 91 of all the traffic was hello messages and that's kind of high but that was of course a device that was using a lot of yang 1-0 modules with zhang wanted one the traffic would of course reduce dramatically when it comes to hello messages but in principle the mechanism for finding out what's available on the device is still fairly similar even with the angle inject library it's just that you're exchanging the information in young library less often but what we can do with packages is then to try to reduce the gap with how people think about what's running on the device we don't generally go around and list and say what's this device doing and then you list 1 000 modules we think of it as functional groups something like packages but now we have a number of different mechanisms that a client needs to understand in order to be able to manage the device generically we have the young 1.0 mechanism hello we have the young the 1.1 mechanism with the young library we"
  },
  {
    "startTime": "00:26:00",
    "text": "have net monitoring and it's starting to build up with different mechanisms that you need to understand and packages would be the fifth mechanism adding to the list of things you need to understand to do this so we had a discussion of could we maybe integrate this into yang library in some way to reduce the gap and reduce the amount of code that you need to have in order to understand but in the end we gave up and found that the gain of trying to integrate those two was not really making things easier anyway in the end so we have to live with five different mechanisms we are talking about uh the issues 133 135 about optional packages or optional modules that are optionally part of the packages and this ties back with this discussion that i'll show you in a few slides about api and implementation packages but while we of course interested in a lot of flexibility when it comes to the package concept flexibility is also creating um complexity so we are looking for the right balance there we talked about uh adding revision labels uh for packages and we decided that we propose to you to itf must use yang zamber labels for packages and we recommend that other organizations should use that another concern we have had is how deviations are part of packages and we updated the text to make it even more clear that the standardization body cannot use deviations in their definitions and the reason for that is that that would basically create a sdo war you cannot an implementer cannot implement"
  },
  {
    "startTime": "00:28:00",
    "text": "uh an sdo that is leveraging in other sdos packages if if we allow deviations in these uh of course implementations can use deviations a particular device can have deviations from a standard but the standards cannot have deviations in themselves then we had some smaller fixes about cleaning up the language in the spec so we use the schema terminology consistently we had checksums for packages for a while but they have been removed now i think there there is some value attached to this concept you could verify that the modules are indeed the ones that you expect so that even if people forget to add the revision statement when the module is changed that would be detected by checksums but there's also a bit of complexity defining how to compute those checks i see that chances raise his hand um yeah thanks uh so i just had one question going back about that standards creating a deviation uh of a standard uh how do you envision uh biz versions working would there at least be a like a bit of a transitions i just forgot what's the right mechanism for that to to illustrate that while it's in progress the the sort of uh task force that is working at this is called the zhang versioning design team right so all of these five or six different documents are about versioning and how you handle things that are changing over time so i i think well in any way deviations are not the mechanism to communicate version changes"
  },
  {
    "startTime": "00:30:01",
    "text": "deviations is for a vendor to say i am not fulfilling this completely or at least not the way that it was intended exactly but standard bodies should not use deviations ever i'm not sure if that answered your question no no not really but i think i'm but but that's okay okay let me explain let me explain i mean i understand in theory that what the deviations for i just hadn't i had never thought about how it actually works when a standards organization updates their own specification with a biz version that is going to make a change to an existing standard in which case it seems like that might look like a deviation or i just don't know how your how that's being represented until the new standard actually becomes uh the standard you know i thought maybe there'd be some transition period where it might look like that you might actually use deviation but i don't know what type of statement you would actually use in that case no it's not a statement like that i mean what you would see is a new version or new revision of the module or the package yeah i guess so okay yeah and then there are some rules for what you can and cannot do and still call it backwards compatible right if you if you are breaking those rules you have to announce it as non-backwards compatible yeah thanks uh yeah checksums we removed those because of the complexity even though they have some merits we talked about or we're in closing the discussion about nbc changes and parents in history and there was some mix up between version and revision statements in the terminology so we cleaned that up and we also had a discussion whether"
  },
  {
    "startTime": "00:32:01",
    "text": "these version labels that we are talking about here could be applied to sub modules as well and we decided that we should allow it but not require some modules to be versioned using our concepts here then we have a recent discussion has been around api and implementation packages so separating package definitions into two types where api packages would be packages coming out of say standard bodies or maybe a product line in a vendor that is standardized putting it together a package that will have many different implementations over time and then we have the other type of package which is an implementation package which would then contain all the details all the modules nothing is optional in the implementation package because it's it documents the actual implementation and it may contain deviations then and to separate these two could be useful because it's more clear than what you can and cannot do with within the package for example in an api package you wouldn't have any deviations whereas in the implementation you might uh but it's also we are trying to discuss to see exactly where is the line is it really worth the effort to separate this into two different kinds of packages and what does that difference look like in the actual here are some examples okay so we have been playing around with adding a package type leaf in the yang package instance and which could take a value of api or implementation and we used to have something called mandatory feature in the package definition but if this is in the implementation package it sounds kind of strange to say that it's a mandatory"
  },
  {
    "startTime": "00:34:00",
    "text": "thing yeah of course it's here because we implemented it so we decided in that case to call it supported feature that is more neutral to the two cases the api case in the implementation case and then we have this list on the bottom with the implementation implements package where you could list all the packages that are that are implemented whether they are part of the api or not and then in yang library we would add a reference to the implementation package for for schemas so that you can see you can move over from one from the young library world to the packages world if you like and we are considering having two different lists of packages uh to make this even more clear than to have a packages and the api and the packages implementation underneath but this is still under discussion we don't know here's an example what it won't look like you have an api package that could be coming from ipf so it's routing for example this corresponds rather well with how people think about modules and sets of modules and it's routing would then consist of itf network device idfpgp and itf is is in the particular versions but it would also list packs that is compatible with that we know that would work here it's not part of the package so if you say if the device says that it supports itf routing we would know it has itf bhp and isis but it would not necessarily have rip vrp and eccles but it's still valuable to have the information about compatible packages as a designer can pick a package that should work well together"
  },
  {
    "startTime": "00:36:00",
    "text": "and then on the right side we have the implementation package example we call it vendor router and here you have things like supported features which is not relevant for an api package and it then this lists all the packages it's implementing for example those that were required idf routing along with network device and bgp and isis but it also supports vrp and eccles it has some modules that are not part of any package really added on top of the thing and that is this case we have this vendor pgp deviations module that's topping off the whole thing so this is the sort of idea that we think about when it comes to packages for now so this is discussion uh is this split between api and implementation packages useful do you think it's an open question to the thor i'll wait another 10 or 15 seconds if somebody wants to say something otherwise i'll move on so is your question of on a feature level or an implementation level you know are you are you asking is this capability needed or is this realization of that capability a um the right way to go yeah i mean what i'm really asking for is this concept that we should spend time on in in the group do you think okay we have a few people in the queue benoit first and then in room second and then tom next oh okay so i think the implementation package is"
  },
  {
    "startTime": "00:38:01",
    "text": "the most useful one out of the two the the other one might be interesting uh let's see if if the implementation package first work works if it does then maybe it's a nice to have to say the itf is proposing this bigger package that you call api and by the way apis work to me because most of them are apis but the itf is targeting this specific set of modules to work together so if you have to focus in phases well obviously implement implemented implementation package one is the one to go with in my mind thank you jan thank you tom hill bt um i'm going to say exactly the opposite of memoir i feel like the api packages are absolutely the type of package that i would prefer i would much prefer my devices to do what i tell them instead of tell me what they would like to do thank you but to answer the question can you repeat your name please useful discussion thank you can you repeat your name i don't know who that was tom hill bt ah thanks tom so i see myself next in queue and i was going to say that something along the lines of tom that you know as a from a a provider standpoint or a user standpoint i could see wanting to define a package and then have my vendor tell me what they actually do so i i i think it's a useful concept also from both perspectives thanks that was my comment thank you uh so"
  },
  {
    "startTime": "00:40:00",
    "text": "we have been discussing with uh about how much optionality we should allow in a package uh of course we want package to be a flexible concept so that's you can say yeah okay routing is here that means you have a bgp and isis but you could also have erp and icons in there and those are then this optional packages but from a client perspective this reduces the value of packages because it would be nice if if clients could just connect to a server and or see oh you have these four packages and then i know what it means exactly i know what i can do because if some things are optional then it needs to drill down deeper and say oh so you have routing but you specifically have vrp so there's a lot more work for a client to figure out if things are optional so then the second alternative is to not allow optional modules but have this list of compatible modules that to make it easy for designers to figure out which combinations of packages might work well together and this is still certainly being discussed and we feel that probably or leading a bit towards the second choice here but it's still very open and if we want to have um optional modules we have been designing it like this in the yang we have a field called optional which could be true or false and both for on the package level and on the module level so it could be listed there if we wanted to have optional features in packages and with option two it might look like this instead that you don't have any optional leaf but on at the end we have a separate list of compatible packages and compatible modules that are not part of the specification of this package but could be seen as guidance for designers that are picking additional"
  },
  {
    "startTime": "00:42:00",
    "text": "functionality i see charles yeah um yeah this is charles but actually tom i just wanted to ask you to come back up because there were a couple questions regarding your statement just i think people didn't hear you well at the mic so maybe just get a little closer to the mic so we're having tom hill come back up again hello um it was quite loud in the room so i apologize if i wasn't well heard so just to repeat what i what i said i i was going to point out the opposite of of what benoit um had iterated i am much more in favor of api packages than implementation packages and the reasoning behind that is because i would like to define what my routers across multiple vendor types multiple software versions what they adhere to and the power the packages that they would and the modules that they would form into yang rather than query them and ask them what they can do i need to be quite prescriptive about making sure that they are in uh aligned in the the yang that they generate and that's why i think i prefer the api package i can see reasons for both but i prefer the api package i can't see any of the questions in the chat today so were there any specifics no just that they they hadn't actually let me see what exactly scott said he said i didn't hear tom very well was the point about listing conformance as part of the package it's about enforcing conformance to a standard i i don't particularly see it particularly i don't see it extremely useful to have a router tell me what it can do if all of them are telling me something different so as far as standardization goes i would like to be more prescriptive thank you"
  },
  {
    "startTime": "00:44:01",
    "text": "very much so i would like to come back to that as well i understand as an operator that you want to request you know young support as packages from multiple vendors now and that's obvious right now jan can you go back to a previous slide where we're comparing this one exactly right so the one on the left is the list of things that typically you would ask from different vendors right and you would say give me this set because i need to be interoperable right the one on the left and then the one on the right is okay what are the vendors doing right now at different stages that's the way i understand the one on the right which is like okay you aspire to go to the one the left and right now because there are different versions it's life cycle etc you have the one on the right so my question is is is it the right way to formalize the one on the left and if you go back to your previous slide uh yam right this one is it the right way tom to formalize all this the one from the itf one in this format because you want to compare easily what you want to have with what you are receiving right now from the different vendors or just telling the vendors this is my list of things i want in rfp is good enough see my point it doesn't help me if some of my router vendors are producing yang that is different to the others so i can i can entirely see why we would want to have both types of packages it might suit different operators absolutely fine but for me lots of networks lots of platforms lots of vendors and i don't want to write extra code i need to be more prescriptive and focus on enforcing the left"
  },
  {
    "startTime": "00:46:02",
    "text": "and not we might forego some features but we're also hoping to encourage interoperability across vendors which is why i would like to be more prescriptive about the packages and the modules rather than query the router and say what can you do and say i would like you to do this specific thing so typically you would have what i see on the screen the left one and this is what you want to do what we have today is basically the right sorry what we have today is mostly the right exactly and then what we need is the left exactly and then we want to have tooling that would just compare two views and you could just say from a tooling point of view this is not what i want vendor you go back and upgrade your router implement more etc yes and if i can point at a package an api package and say please support this that's why i would that's what i would like to see thank you you have several more in queue i don't know if uh benoit and tom want to stay around because it might be relevant uh robert or rob sorry yeah so robinson um speaking as a contributor so i just wanted to emphasize that this these two types patches are solving different problems as has been has been discussed here that the api package is trying to to give the specification of what is desired and the implementation packages is giving the real implementation of saying for a particular device this is what it's doing and you may have that implementation package just being served up from the device itself in the same way that yang library gives you that information today and it also allows a vendor to advertise that off the box and say for my particular version of this os these these the packages that i implement the apis that i implement and i have these deviations because i can't implement them completely faithfully but it allows the the people who write the instrument instrumentation code to know what those differences are so it's"
  },
  {
    "startTime": "00:48:00",
    "text": "about one is about advertising what you want to be doing and the other one is about advertising conformance that's mainly coming from a device thanks rob done my homework uh the thing i'd observe here is that there's sort of a heating set of requirements and we've touched on some of them what i would sort of highlight a desired behavior is as much as the thing on the left is what people may want you know here's a set of things that are supporting a set of protocols and the modules are part of them what is perhaps better to focus on is the top deliverable is for a given module egp is an example it's going to have a set of dependencies and other modules and we look for for that version bjp what is the compatible set of it modules that you pull into you know implement bgp or any of the other protocols ideally just like with uh linux distribution when you have the sets of things that are compatible the expectation is that a method of these things will all pull in compatible libraries across the board so if i pull in bgp and it depends on ietf routing and if i pull an isis it shouldn't be incompatible so i i think the sort of list of what we want to be able to get inquiry to have a particular combination what we need to focus on is here's the individual item and the things that are independent and then make sure that all of these pets harmonize each other and fill in some"
  },
  {
    "startTime": "00:50:08",
    "text": "uh do you hear me yes so i think it would be very interesting if we could uh specify a method or maybe even a tool that would say that does this implementation package fulfill the api package does it does it do everything that the api package is asking for thank you thank you yeah i think this that's part of the discussion about optionality we have been trying to make sure that the package definitions are such that if a package is announced we would know rather quickly and easily from a client side if that package is fully implemented we of course have deviations that goes on top of this and it complicates the picture but that is how we have been discussing when it came to this question here uh actually what we wanted to know really was whether this concept of api separate from implementation package was a relevant concept and from the discussions that came in here i think we struck a chord and definitely feels like the distinction here is meaningful to people so that's a good thing to to understand from this thank you i only have a couple of uh slides left i think uh let me yeah we talked about optional modules uh and how that would look the i think we have already talked about this so the last thing is about scheme amount uh as i mentioned earlier we have been thinking about what happens if you have a mount point in a module that's inside a package can we in some way convey what to clients what they will find at that mount point"
  },
  {
    "startTime": "00:52:01",
    "text": "we have seen a number of different use cases and for some of them it's fairly easy to describe you must find this or you must find one of these but in a more general some of the more advanced use cases it's kind of it gets tricky to describe this so we don't know exactly how far we should take this in a meaningful way what we're looking at here is for a young package instance to list the mount points here and then you can have information about what packages that might be or must be found there and i think that was everything we had from the package perspective in the versioning design team so i think uh any any other questions no none in the room no one in the queue that's great so that was your last slide right there yes so thank you very much thank you next up for your chin see if i can get these slides okay chin you should have control okay okay can you hear me yes we can okay thank you good morning everyone uh good afternoon uh this is ching i'm going to uh present this"
  },
  {
    "startTime": "00:54:00",
    "text": "participating pack and the main objective is status update the current version number is version six recapture a little bit about why we propose this worker self-describing data object tag is very used to classify the data especially for the operational data and you can capture those data or example kpi data so it's a you know similarly choose a module tag another difference the multitasker only used at the module level and for the object tag used at the data node level so self-described uh describing bit object tag can be using streaming telemetry scenario targeted to reduce the amount of the data export destination so current status of this work has already passed through the young doctor last call review and also we got us official review from agent pearl so many thanks to uh mahashi and asia uh changed uh since the zero floor and we actually made a two update this is the released actually the main change we have made the first we add user tag maintenance clarification because in the job we define not only user tag but also ietf tag and reserve tag how user tag is distinguished from other tag so we add some clarification and secondly we provide a guidance to discriminate experts for evaluation of young data model tag registry and also young data object tag prefix rejected and we made a two update to the bigger one and v2 with additional text and we also enhance the security section"
  },
  {
    "startTime": "00:56:02",
    "text": "for the user pack management and in addition we actually based on young computer review we changed the data object name into the short name and and also we made some other additional changes to address the region's comments and comments from young doctor review and first actually we made an update to the figure man with additional tags you can see in the version uh four in the left actually we only described the uh the several tag uh object tag and the metric tag and the metric group tag property attacker and discuss just introduce the relation with the data object uh so in the version six actually we uh try to you know add additional tag which because we already added the minor source tags so we change the metric group attack to magic type tag so this is kind of you know rewarding and so you can see the change we have already made and this kind of mighty source attack is not actually a new attacker it has already been defined in this worker mostly used to capture the data object from multiple source so second change we actually uh made in the ayanna section actually we really need to provide guidance for the designing the experts to for for assignment policy so so we make a change to section 9.1 and section 9.2 and for section 9.1 we we didn't actually add any specific guidance but we added some statement actually to make sure that presumption of the code point can be granted hold and in section 9.2 actually we added the"
  },
  {
    "startTime": "00:58:02",
    "text": "guidance for the second expert and to allow the expert to verify the associated tag to confirm a specific criteria defined in rfc 51 1998 next is the user tag for meta clarification and as we clarify we uh introduce we define the user tag and ietf tag and also resolve attacker we only readjust the ietf tagger for usertag maybe uh conflict with other type of photogrammetries of tag so because it can use prefix started with a user column or it can have no prefix so to address the issue actually we added some collaboration text to make it clear so you can see the change we have already made in the section 4.3 and also in the top sec in the beginning of the section four and uh next is about target management conflicting resolving we think that this issue has to be discussed on net network manager we actually this is maybe not only applied to this job but also applied to the module target that has already published in the nether mode the working group and the problem is when one client add or remove the tiger uh for some other client may get a wrong data uh so we talked with uh agent on the list about this and we think what pack imaging mostly done in the implementation stage better we do see some cases you may add a remote tag in the running timing stages so how to deal with this so to address this issue we added some text in"
  },
  {
    "startTime": "01:00:01",
    "text": "the security section to really strictly the client with a specific client level or specific privilege and this issue we actually we posted on the list and we only solicited feedback from audio tagger also about having here the feedback and the so for next step we think of all the issue we received has been addressed and we are happy to receive any comments in this meeting yeah thanks hello hello yeah hi i'm in queue as contributor uh if you don't mind going back once a month i'm not sure why tag is any different than a um any other read write leaf here or leaf list uh you know i i don't see how it um reveals anything additional than you would with anything that could be written um from a client so maybe i'm missing something yeah this is actually based on the comments raised by the agent and he thinks there's potential risk for this kind of tiger imagine conflicting i'm sorry yeah yeah so i don't see anything wrong with the text that you add i just don't see that it's a unique um vulnerability yeah i agree okay uh rob go ahead you're on the cube i'm checking out"
  },
  {
    "startTime": "01:02:00",
    "text": "uh wilton sorry rob wilson as a participant so um just looking in the module and use node instance identifier which i think is the right answer and it looks like that allows you to associate a tag with a particular instance in the data store or also gives you the flexibility of leaving the keys out and associating a tag with um all instances or a subset of instances is my first question is is that the intention seems like it's a good thing to do and if it is um it may be helpful to to to sort of spell that out and clarify that in the draft that these that you have that flexibility uh when you're using this yeah we we do have some examples in appendix actually to you know use this attacker to apply to the instance the data object so we have such kind of flexibility so do you think we need to add some text in a normative part to spell this out um i need to check i only have a quick look um so maybe the text is there but i think spelling that time if it's not there already would be helpful so i just are just gripping it for the um uh attack the um yang type so so it might be there already but it's be useful over there if you can okay okay got it thank you so any other comments okay uh thank you i think that's uh all you have right thank you"
  },
  {
    "startTime": "01:04:01",
    "text": "yeah uh but oh you so you think the document's ready for uh working with last call right so we didn't talk about that uh yes yeah whether we last call immediately or not it's good it's a good time to get uh extra review from the working group um the chairs will uh discuss the the working glass call after the meeting um personally i don't see any reason not to do that but you know that's just one opinion i'll definitely talk with the co-chairs okay thank you thank you i think we're going to move it on to system defined configuration give me a moment to switch slides yeah i think i have requested to share those slides oh okay i got it thank you so hello everyone good night and this presentation is about the system defined collaboration work with that we have the and in john this work and so this last item meeting where i just do a lot of passion on knowing this about the open issues of this work so thank you everyone for getting involved in this work and sharing her great ideas about his work and there are a few issues which i posted to the mailing list since last item meeting if you can still remember that maybe the most debatable one must offline validation of running along be required let's say that the client references a system defined configuration which is not present in running actually and maybe for online"
  },
  {
    "startTime": "01:06:00",
    "text": "validation the server can just accept it but for offline validation it will fail and maybe we can say that the server can just validate running by validating intended but it's true that both the 9 15 and ns3 42 defined that running must always be valid and also to maintain backward combability especially for those lexical lines which are heavily relied on the offline validation of running we don't really want to break those clients and the existing implementations so the authors decided to answer yes to this first question yes we think that must offline validation of running alone be required and the second issue should the origin b system or intended for system configuration which is copied and tested into running i think we received different opinions about this issue but more folks seem to incline to use intended as the value of origin but it's also okay to use already ecosystem it's a value keeps unchanged so the current draft doesn't really limit which origin should be used about this issue and then the third issue about immutable flag uh it has already been defined in another individual draft since we may not restrict this flag to system configuration only so the following presentation given by me we will talk about this issue i will present this and then the the last bullet should be with origin parameter b supported for intended currently this parameter with a reading can only be supported for operational"
  },
  {
    "startTime": "01:08:01",
    "text": "data store and we think that this system configuration may also be present in intended and clients may benefit from this always original parameter being used for retrieving intended however we find it's not easy actually to support this idea because there is a one statement which are derived from ocr function defined in this with origin parameter leave data node so i would rather keep it as it is without more extension about this parameter so if there is no any other comments i the authors like to close these four issues after we have oh i iso can't in a queue do you do you want to say something can't yes can you hear me yeah i can't hear you okay um on the last point i'm wondering uh i mean i do understand that it's defined the derived from or self when expression but we could i think this rfc could update that other rc if necessary and and extend the expression so that it could be operational or system and because it's like it expands the scope it wouldn't break any existing modules um so i i just don't know if the reasoning behind not moving forward with this is you know just because that's what it is currently another and we don't want to update the other rfc is is justified we should probably discuss what what do we want and then um and then decide whether or not it's worth updating the privacy"
  },
  {
    "startTime": "01:10:00",
    "text": "yes i agree yeah we can discuss about this this issue further and maybe we can do that uh rob wilton as a participant so i i'm conflicted on one um about must running always alone be valid so although i agree that it's always useful to be able to validate running so you should have that capability i do wonder about whether that makes life difficult so if you're creating interfaces today i think the interface itef interface is yang model allows the interface type to be instantiated by the system and to then be added in and i don't know whether what the answer is are we saying that actually we want to always force clients to specify that interface type whenever they configure an interface to make that like a valid configuration or are we saying that actually we allow the system to instantiate that value in running which again is sort of breaking the idea of the running data to always being in control of the client um or always the reality that actually the system will inject an interface type as it needs to and then do the validation against the intended data store so the value's there as required so um i think it would be potentially useful if we we wrote down the actual configuration steps for that example and there's agreement as to how this how this should work and how it should behave to to understand um what what the actual operational steps would be for this and to check that that makes sense okay blush do you want to say something yes just"
  },
  {
    "startTime": "01:12:00",
    "text": "reacting to rob there are a number of other uh sdos for example 3gpp which explicitly state that some items are created by the system so if we would want to restrict that in any way that would be a big problem thank you john so i think that uh if we want to go ahead with this uh yang project that where we can reason about obligations we should stick to those formal rules about what's in the configuration should really be there as just as the configuration the young specifications already say but what we can do and what this the draft is already stating is that if you have a client that understands that the system might create things and request the system to fill in things by adding a flag to the edit configurated data operations so i just want to make sure that existing clients that are not expecting any sort of interference with running can expect that to go to continue like that but where clients that would prefer the system to do things automatically can collapse thank you yes i i think the maybe the intention here is to keep the legacy clients can working normally and we do not really want brexit clients which heavily"
  },
  {
    "startTime": "01:14:01",
    "text": "relied on the validation of learning alone so maybe this is intention about the first issue yes i i just want to add that it's not exactly the validation that is the problem here uh the clients can validate or not but it's the reasoning about the data on the server that let's get broken if things are interfering with in runtime without letting the clients know okay thank you i think as long as the system creates things in a predictable and well-defined way that is usable if it's not described clearly in lang which it cannot be today then it's not then do still rely on the developer to have additional information besides the yang in order to do that and that's what i would like to leave behind you would be killing 3gpp young model modeling not at all you just need to define some additional attributes or for edit config and someone and this draft actually defining one such attribute i'll have a look at it but i have in 3gpp for example there are and in some other places there are young extension statements explicitly stating that this or that is created by the system yes we can of course discuss whether extensions are supposed to not necessarily be understood by clients but this is at least declared something at least until now there was no restriction on the system itself updating the running configuration i hope it stays like that but let's discuss"
  },
  {
    "startTime": "01:16:00",
    "text": "so rob wilson as a participant so back to yan's comments so just trying to understand are you saying that what you think the best way of achieving this is that having an extra option to the edit config request explicitly says i want you to copy um the system parameters into running and that would allow a client to effectively provide a partial configuration that for example leaving out interface types and by having that explicit you copy this into running it then becomes valid and can be validated and a client doesn't that doesn't necessarily have to then pull that configuration back up again it could always leave it say different is that what you're suggesting that's what i'm suggesting and that's what's already in the draft right now yeah i will present about this letter okay thank you yeah by the way you're a bit over time but we had some extra time at the end of the session and so we'll give it to you about 10 minutes so since we have a quite a lot of discussion on the melody list and the authors try to update the draft and reflect some working group feedback into the new version and as i listed here the most dramatic change compared to the previous draft is that instead of saying that there is no need for offline validation of running alone be required and the client of the server can validate running via validating intended we here admit the requirements of validation of offline validation of running alone and define that any referenced system configuration in syst any reference the system configuration in system data store must be present in running to macron invalid and since we already defined that the"
  },
  {
    "startTime": "01:18:01",
    "text": "reference system configuration must appear in running we don't really need the system parameter which is used to return a merged view of running and system configuration previously so we have just removed the definition of this with system parameter another change is about that the convenient because if people can still remember that we used to have an object called convenient we want to avoid or at least reduce having copy the entire contents of system configuration into running when possible so we have defined another parameter reload system and this is used for edit config and edit data operation and it indicates to allow the server to populate the reference system configuration automatically to make the running configuration valid without the client doing the the option explicitly and the server can can auto populate of the the data store only when this parameter is provided and for lexical lines which know nothing about this parameter they don't see any change in the edit config or edited operations so this is about the draft updates and there are some quotations from the current draft which i think is important for understanding the ideas and the principles of the draft so i just give some quotations here the very first one that server must ensure that running contains any referenced system con system objects as i have mentioned in addition to being consistent with the definitions of in existing rfcs we are intended to maintain the backward capabilities for"
  },
  {
    "startTime": "01:20:00",
    "text": "lexical lines here and clients must exp either explicitly config system defined nodes in running or use the resource system parameter if the first sentence is said that the reference system configuration must be present in running i think this this sentence answers the question of how how can it be in running there are two ways right clients can explicitly config the system-defined nodes if they do not want the system to touch the configuration actually or they can use a reload system parameter for convenient so two ways define that online system awares clients copy reference system nodes from system how clients are aware of the system that store can find appropriate configurations beyond the scope of this document and obviously the system data store is designed as a standard mechanism to allow the clients to see what system configuration is available but for lexi clients that know nothing about this document so it's it's out of scope how they can find the system configurations and the last one if the readout system parameter is not given by the client the server must not modify running in anywhere not specified by the client there is a desire to let it declined on the configuration so there used to be an objective mention in the draft is the client control the configurations should be totally controlled by the client so we have just so we just think that even the server is allowed to configure the reference system configuration automatically it is only triggered by the reload system"
  },
  {
    "startTime": "01:22:02",
    "text": "parameter so the server's modification to running without being asked can never be allowed yeah flash i i saw you in a queue sorry this last bullet if i'm not misunderstanding it this is a very big nbc change and different clients might have different ideas about this so i have to check on this but this for me is a showstopper and there are some other uh sbos like uh 3gpp or run very clearly state that some things some uh list entries are only created by the system itself so this would i don't see how this last bullet can work together with those things go ahead please i'm sorry can't just chair bellage can you repeat that or the last bullet on slide four can you yes here it says that except for some cases the server must not modify running in a number of other sdos most notably in 3gpp and i think also in oran there are young modeled objects which where they have a sentence that this object is created by the system only so the client is not even allowed to create that object we have around i don't know 160 gang models in 3gpp and some of them depend on the system to be able to modify the running configuration now this seems to be in conflict with usborne"
  },
  {
    "startTime": "01:24:00",
    "text": "i think i understand uh so now i'm i'm going to switch to speaking as contributor i remember several years back when we were working on yang next i forget which uh city we were in but you were at that time talking about 3d 3gbps need to dynamically create configuration i uh i don't believe there's a lot of support for that being able to do that i think there are a number a big number of companies in 3gpp participating in this standardization so you don't have a big enough support and i'm not asking for anything i'm just asking you to not to do a big nbc change that's all i'm asking because this that the until now it is allowed for the system to modify the running configuration if you say that from now on it's not allowed that's a big nbc change we need to discuss this um i think the appropriate thing would be for 3gpp to put the system created things into the system data store i understand that that didn't exist before but that's what it should have been that they moved forward anyway with an effectively unapproved um non-standard approach is something that we should discuss whether or not the idf caters to i don't think i until now i'm sure that it is well it was nowhere restricted that the system can itself update the running and i don't know about any of the young rfcs that would restrict it until now so i don't agree with your statement that's not approved approach it was actually just discussed on the mailing list not that long ago and in fact i think there was a vigorous discussion about how the system can act"
  },
  {
    "startTime": "01:26:01",
    "text": "and and itself make the update to running as a client and and that whole discussion was in fact to avoid the uh appearance of system or the server making changes automatically but please let's take this offline thank you yeah i was just that this is louis contributor i was just going to comment if there's no rfc that precludes something we can't say that it's not allowed just an email you know if we have to go by the documents and if the documents are quiet on a topic we generally in the ietf said that's a loud behavior so we should think about when we start adding new restrictions the implication on someone who might be doing something that is wasn't specifically recruited so um i i guess i'm agreeing with belage here that this that his point is something we should consider in this document of how to how to deal with clients sorry how to deal with young models and implementations that might have been doing something that was not previously discussed in any document we did have this discussion more than once or in the last few years and that's why i say that i always took care to remove any statements that would preclude to prohibit this behavior and also we risked uh really alienating a big community 3gbp and old radio operators if we force them to avoid yank they have at this point two solution sets one based on yank and netconf the other based on json schema and the open api it would be very easy for them to say"
  },
  {
    "startTime": "01:28:00",
    "text": "that okay then we forget yang because it's not good for us we i don't think we want to do that yeah and more than that this is a change in allowed behavior you know before the document was silent our documents all the i don't think anywhere talked about this explicitly in an rfc so we we had something that was allowed in existing rfcs this changes that so i think we have to take that into consideration okay thank you so there is an open issue we have some discussion on the mailing list about this issue but not much and i'd like to receive some more feedback here so we have proposed a reload system parameter and the question is this this without system parameter variable for us we propose this parameter for convenience and we would like the client to avoid at least reduced copying the entire contents of system configuration into running when possible and especially for rest conf protocol where a complete understanding of this server's configuration is really desired and injecting multiple disjoint pieces of the configuration is perceived as complicated so but this parameter also brings us some implementation complexity when the server resolving the result leave reference the server must be able to identify if the missing reference instance is system defined and then the server must be apt to configure the reference system defined instance into the targeted data store and i'm also thinking that when the servers or the populating is enforced"
  },
  {
    "startTime": "01:30:00",
    "text": "should depends on the target data store for example if the target data store is running or set up the operation should be enforced at the end of the edit config or edited operation and if the target data store is candidate maybe it's delayed onto a commit or valid operation taxpayers so i believe this this follows the young constraint enforcement model defined in the rfc 7915 so after the evaluation of how much value it brings and how difficult or complex it will be to implement does this value that the value of this parameter deserves such an implementation complexity so this is an open issue for discussion any comments on this you're pretty much out of time so i think you should try to wrap up and then any more discussion has to be on the list yeah this is the last slide thank you so so one thing i was expecting on your last slide was a request for adoption um you know it's clear you're generating a lot of discussion so at least we should resolve those uh points that we still have the question of whether or not the group wants to adopt but i think that with the uh current open issues you know uh it would be a little bit contentious so uh if you can address those and then come back to the working group with changes that would be great okay sure thank you thank you yeah so if there is no other comments i will put this open issue to the oh there is another another open issue addressed by"
  },
  {
    "startTime": "01:32:01",
    "text": "kent on the mailing list about this about this one so uh let's move into the the next presentation uh okay you should be able to present yeah thank you so this is about the immutable metadata annotation and and uh i mentioned earlier the this idea an immutable flag is derived from the system defined configuration work because there are some system configurations which are generated to be non-deletable or even non-modifiable to clients they are configured but with only two clients and but some some are read-only while others can be modified so allowing some configurations modifiable while others not is inconsistent and introduce confusion actually so to resolve this issue we want to define a standard mechanism to see what system configuration is with only two clients and if there exists some system configurations which are generated to be immutable we want to make this information visible to clients so this is about the motivation so a metadata annotation called immutable has been defined to indicate the immutability of a data node and although this concept is motivated by system defined configuration we do not really want to restrict this flag to being used only for system configuration and it's used to annotate instance of"
  },
  {
    "startTime": "01:34:02",
    "text": "young data nodes rather than schema nodes and after it's created any data node annotated with immutable equal true is read only to clients which means modification or deletion should not be allowed but the following operations should be allowed like create an immutable data node with some value initially set by the system if it does not exist in the data store and the immutable system configuration is is not present in running and the client can configure it with the same value as found in system data store into running so this should be allowed and delete the parent node of an immutable data node unless the parent node is also annotated with immutable co2 for example we cannot re really delete a leaf data value inside a list instance but it's okay to delete the whole list entry which includes that immutable instance so this is about it did it operation it should be allowed here gives some example about how to use this flag so on the left side of the slide there is an interface configuration with an immutable type when the client retrieves a targeted data store like system and got such a reply it should realize that the type for interface eth0 it's read-only and should it should not be allowed to modify it but the server should attempt to accept an edit config operation towards running to configure the interface eth0 configuration with the same value of the type as in system and any other values should not be accepted it should be rejected"
  },
  {
    "startTime": "01:36:01",
    "text": "and on the right side of the slide there is a system defined neck rules with the leaf list and the list entries annotated with immutable equal true the username here is defined as a leaf list the user or the mean for the admin group and guest for the group visit is generated to be immutable which means that deletion is not allowed and the rule list instance for the admin excel is also immutable so any modification and deletion to this list entry is not allowed while the other these entries like the rules entry for visit scl uh the annotation for this and the annotation for this entry is not specified and the default is the same as the the parent node of the the the same as the in the immutable immutable value of its parent node which is the neck in this in this example so and the default immutable value for top level that node is false so it's this is about the examples of how we can use this immutable annotation so there are some open issues about this work and the first issue is the backward capability what if the lexi clients receive some annotations they do not do not understand and i they we have two options here and option one is that annotations always return body client ignore unknown annotations silently and option two is to define a parameter in the operation request to indicate including an immutable annotation in its response and the current draft follows option 1 but i have such a concern that the design may break the lexical line"
  },
  {
    "startTime": "01:38:01",
    "text": "but maybe i think it's okay because there is a fundamental requirement and defined in the 79 15 2 it says that the annotations set by a server should not break clients that do not support them so this is about the first issue the second is that how would the client know if immutable is applied to the whole list release entries or both the same applies to the leaf list because these annotations can only be attached to individual list or leaflets instance then how should we indicate the immutability of the whole list or leave list the whole list of the whole leaf list so so that the client can understand that the additions or deletion to the list or leave list is not allowed i think this is a question so and then the the third one is that when should the server reject modifications to immutable data node and the current draft said that the error reporting is performed at various different time according to the selected target data store so we we we all know that if there is uh an attempt to modify an immutable data node the server should reject it but when should it reject if the target data store is running or startup should be in an edit config or edit data operation and if the target data store is candidate the reject is delayed until a commit or valid operation takes place the last issue that should we allow the client to delete an immutable system initiated not in running and yet because i know that there seems nowhere to i actually did the system"
  },
  {
    "startTime": "01:40:00",
    "text": "defined configuration in system because we already defined that the deletable system configuration must be defined in factory default and the non-digital system configuration must be defined in system and system configuration system data store will be merged into intended and sent and much into operational so even we can even the client delete an immutable system node in running it will still print in operational if it's taking fact so but i also like to ask to the working group should we allow this operation okay i i know rob in the queue but this is my last slide so go ahead rob so rob wilson as a participant contributor so as a participant so um where is the previous work on the with systems data store um i'm quite supportive that i think that's solving a good thing i have a bigger concern here that if we allow um servers to to arbitrarily decide that some configuration is immutable that that makes life much harder for generic clients because they won't know up front just from the schema what things are immutable what things may be immutable and what things aren't so it feels to me that having a mutual confidence makes life harder for clients and ideally we shouldn't have it it is my opinion now i know that um balaj may feel differently for his implementations or the 3gpp stuff that uses this so um so i have concerns there so i think the another way look at this maybe as a way of of not encouraging a mutual configuration but a way of describing it if it is there in which case i think that for like a first question your option two of having a request that returns a parameter that says return this seems like a better choice to me so it allows you to annotate stuff that's immutable it"
  },
  {
    "startTime": "01:42:01",
    "text": "doesn't say encourage and say you should do this and and i don't think it should sort of change the behavior of the server either way it's just providing some extra metadata that comes back out and then so for the last one um in terms of should we allow our client to delete an immutable system data node i think that's that should almost be um yes in the sense that if you move from one entire configuration to another entire configuration any cases where you have that you have arbitrary restrictions on that makes it very hard for clients lots of operators like to do like a commit replace of the entire configuration and anything where you say oh no you're accidentally changing a type from a valid type to another valid type for an interface for example that just makes their instrumentation instrumentation code harder okay thanks yeah i agree with rob in to the sense that this sort of restrictions certainly make the life more complicated for a client but on the other hand the rfcs are already saying that i mean 7950 and so on they are already saying that a server can reject any configuration for any reason basically uh so we are already in in the dark when it comes to rejections they can happen anytime for any reason but uh this this initiative here to at least tag things with immutable helps the clients to at least have a chance at knowing where these business restrictions sit so i think it's a step in the good direction but i agree completely with rob's general view that any sort of restrictions on this is making life more complicated and i generally prefer a more permissive view where clients can write anything and if"
  },
  {
    "startTime": "01:44:00",
    "text": "the server doesn't like it it will say okay operationally down or wrong type of hardware or whatever it is and not execute on it but allow the configuration to go through thank you i i think to to respond ian and rob i think this is not really a restriction because there does exist some system configuration which is read only generated to be immutable to clients yeah that exists such kind of system configuration and we just want to make this information visible to the clients okay let's go ahead so i think it's very interesting and important work i'm not up to date sorry i will catch up but i would just like to list three use cases that are already in use in different systems that might profit from this one is again 3gpp and some other sdos are using something called invariant which means that once you create it let's say a leaf you cannot change it and we might say that this is not a good idea i might even agree with it but it's the fact of life and we either support that or or they will put uh young extension statements on that or we will not document it still will work that way just it's not documented in yang anyway so this invariant yeah it's there they are using it for the last 10 years and they won't stop using it the other thing that we have discussed a number of times was capabilities where yeah you would like to say that i don't know i support reporting periods 1 5 20 and whatever and i want those to be visible and i want those to be static no new values created no new those values removed"
  },
  {
    "startTime": "01:46:02",
    "text": "that's again something that's already in use and another use case i don't know that if this is the correct tool for that is system created and system enforced access control rules where we say that this thing in the configuration is must be there and it no one is ever allowed to remove it some some implementations are using such immutable rules for that as well thank you thank you so rob wilson as well as participants again so just sort of back to yang's comments and bellagio's that i so i think that i feel that um providing metadata information to tell clients about how the system is behaving is is fine and good i just want to make sure that by doing this work we don't sort of encourage this is a good thing to be doing so i think we need to have some sort of warnings to say this like we should document the problems of having the immutable configuration and why you might want to avoid it but if you do have it here's how you can tell the client about it i would like to agree and there are a few specific places like typically complete the restore backup copy con copy config replace full config that are problematic in this area so we could and should list them but yeah they are still a fact of life thank you one more thing if i made this draft states that immutable is in that instance data but one is right yeah but even in your second bullet here when you say"
  },
  {
    "startTime": "01:48:02",
    "text": "that immutable is applied to the whole list to me that seems more like a schema level immutable and actually that's what you need in some cases because yes i agree if i think about it you could have a third value instead of yes and no on the metadata saying that all elements but what if you don't have any entries at all and the list is still immutable and you have no place in the instance data to state that it is immutable yeah i i still have one minute left so yeah and can't i just wanted to mention that i think invariant is very different from immutable and i don't i don't want to treat that in the same way we can talk about that later but okay thank you and i was just gonna ask for a clarification on a previous point but if we're running out of time it's okay okay is there anything else no more questions thank you very much for this and we're going to move on to the last uh presentation okay thank you okay can you hear me yes and you should have slide control oh okay okay to get select control okay"
  },
  {
    "startTime": "01:50:00",
    "text": "here i got yeah okay thank you i'm using i'm presenting this draft which has been uh submitted to this because the technical content of the draft is related to the tease work but we have a thumb ups on the process that we can follow to move this draft forward and we would like and this issue can be more generic than just this document we would like to get the feedbacks from the netmod working group so what is the problem we are trying to address we need to do a tiny and backward compatible update to a young module in this case the itft types which is already published in the into an itf rsc and actually the change that we need to do in this specific case is just a new type def and a new grouping with tulips so it's a very small update but which is blocking some other work and there is some reluctances from the people on moving those definitions in in these d types because of the piece of portion we didn't find any other approach at this moment in time to update a young module after being published in rfc than doing the beast the problem of the piece is that the base rsc is a very long rfc and i calculated four pages in the pdf version and it doesn't contain only one module it contains other modules another module which does not need to be updated so it's not very clear what it will happen if to that module if you replace if we obsolete the c8776 and the content that we want to publish is quite mature because it's something which is already present in working group documents some of which are working actually the working group also started a few minutes ago on one of them and we just want to make them in the types to make available to a broader scope than just the documents and the yammers where they have been originated so because of the dependency and and the maturity of the dependent work we need to have a fast approach or a fast process to to get this changes approved"
  },
  {
    "startTime": "01:52:01",
    "text": "by the itf without really delaying the process of the other working group documents and the b is is quite an heavy document what's happening okay yeah so what do we need okay this line of battery is more about the content and there is a new type depth and a new grouping which is coming from working group documents and next is about what we propose so to to to have a fast solution so what we propose is to have this new document that is rafter which is updating rather than obsoleting the rsc 8776 and it is defining a new revision of the itft types only of the itfd types such that the the documents that depends on these definitions can import this new version in this device i'm using the assembler label just to simplify the slide to understand to clarify which one is rough which one is approved and which one is uh an update of which uh and and then other drafts can still point and it can still import the t types back tt packet types from the lsc8776 if they see if they don't need uh any update for that for that module so as you see there are other documents which are quite mature and which depend will depend now from the new dock from this new document so we need to have some fast approach in the standardization to avoid stalling the progress of something which is rated for publication and what are the issue that we have the first issue is that we want to limit the scope of the work to make it faster only to the what we update so the td tiny and vector compatible updates that we need and for for the proposed solution that we would like to follow with this document is to include in the main body of dlc text only the changes not the definitions which are already in rsc8776 however by doing all of the changes we i"
  },
  {
    "startTime": "01:54:00",
    "text": "we are afraid that we create some problem with a young tool chain like rfc strip or the young catalog which is extracting the whole module from the rsc so to to solve this problem the proposal is that we can include the whole module revision into an appendix these appendix is just providing the complete revision and we can consider these appendix as out of autoscope for the review and comments it is there just to allow the tooling to work and but now we have a possibility to get the text in the main body and the text the penis will go out of sync so to make sure that there is alignment we can generate the text in the main body with an automatic simple lift tool uh we propose one in the document if there are better tools we are uh willing to to take them into account such that by running basically what we are doing we are updating the the young module in the in the appendix run the tool and get the the new llc in one shot and keep consistency between the main body and the appendix so what is the next steps we would like to get feedbacks from network working group and also from the ads about the proposed process whether the process that we would like to use to update an accm model is reasonable and and then we can progress the technical content of this document through the this working group or following the working group normal processor thank you and in the in the backup there are some uh and there's a drafts we describe additional alternative options that we have evaluated and why we think these approaches will be better thank you all right um danny so i just wanted to give you my experience having gone through this recently we had just published rfc the pft yang module and had to go through a process of"
  },
  {
    "startTime": "01:56:02",
    "text": "actually correcting the proposed model so it was a backward incompatible change so which may not be exactly what you're looking at but i think in terms of a process it was very similar so what we had to do was the we had multiple modules first of all in the draft and only one of them was being updated so we went ahead and made the change in that model and of course updated with a new time date stamp so that essentially indicated that it was an updated module we then went ahead and added an explanation in the appendix section describing what the change was and finally if there were any other modules that were dependent on it those were also updated to reflect the fact that they even if they were not being directly impacted they that the model that they were referring uh had changed so therefore they had it had to undergo a change also so in i think in summary that those are the set of changes now i don't know as far as fast or slow uh the approach uh is still taking months we still haven't finalized the draft is still not approved and this is about three months old at this point but you need a visa corrector sorry what was the question did you publish an rfcbs yes so we published it as an rfc biz so you will see i think it's called rfc 9127 business yeah"
  },
  {
    "startTime": "01:58:01",
    "text": "the the there's a uh jeff put it into the chat mahesh before you go away i know you've already walked just to clarify there were you updated the versions even of the modules even of the modules that were not changed i believe so let me confirm that by taking a look i we had to update some of the dependent what i call the dependent modules but let me confirm that give me a sec yeah i think that's an important point of what to do with the modules that aren't being changed in the document thanks i think rob you're next uh yeah so rob walton so so my thoughts on this is i think that um because this is a backwards compatible update to that module i don't have any issues with this going into a separate draft that's updating that base draft and i have no issues with updating just one of those modules i think that's okay and i think the dependencies will work um if you go back to your previous slide please i wasn't so sure about your proposal of um effectively having a diff in the main part of the draft and a full version of the appendix i think you'd be better off just putting the latest version of the module in the main body of the draft because that's what you're now publishing and then having some text which could be in the introduction it could be in the appendix that flags what's been added or what the differences are i think in terms of the review process you just need to make sure that when this goes to young doctor's review or and through the isg review we're saying look these are the only things that are changing and if that's highlighted i think most ads will be happy just to do a diff review of the new stuff they don't they won't review other stuff that's already there so that's what i would propose so you propose to put the main body and to let the chairs and the authors and the id to figure out that what the comment is only on the deltas you i mean you can always add a comment in that's removed by the rfc editor at"
  },
  {
    "startTime": "02:00:00",
    "text": "the top of the document saying you know please this is the only thing that's changed please focus the review on these parts and then that gets deleted later that seems reasonable to me okay sorry if i'm jumping the queue oh we have jeff please okay i was just going to answer the question that lou asked about did and did we have to update the other modules the answer was yes so what we changed was the types module and if any of the modules imported the types module then we also bumped the revision date on those modules that were importing the updated module all right didn't he expand it sorry go ahead the the uh there is some controversy as to what we ended up doing so what the language requires us to do at the moment is just simply bump the things that aren't directly impacted there was a long set of threads where we attempted to get the yang doctors to chime in and this where tom petch basically wanted us to have every single thing that used this module also bumped in some fashion we did so primarily for bfd but he was sort of pushing to have this done across the board i don't think that's necessarily reasonable what i would suggest is uh most of this thread is available on the bfd mailing list and i would suggest taking a look at it because that's affected the procedure that's under debate right now i might assume rob ah good rob removed himself um yeah i think uh italo rob gave you the solution that you want which is just do a"
  },
  {
    "startTime": "02:02:00",
    "text": "just take the the module that you want to modify and put it in its own um document that updates the space uh the base rfc rather than do a this and i think that covers the narrow case that you're covering you're discussing um the vfd conversation is much more interesting because it's uh nbc but i think rob is giving you a solution that'll allow you to move quickly and only update the piece that you want i do also want to echo the comment that rob made that going forward with a way that requires new tooling is probably not the way to go um and you know creating uh new ways of defining modules with diffs and things like that is is just likely going to cause a lot of confusion now the narrative part of your text of course can uh highlight the differences um but the module part should be a normal module that our tooling supports okay and maybe we can put some comments to clarify what has identity okay we can follow that approach thank you with that we're actually a little over and uh thank you all for a good session and look forward to hopefully seeing you in person in philadelphia okay thank you thank you bye-bye thank you oh and charles thank you for uh supporting us in the room yeah yeah you bet you and kent made it easy for me"
  },
  {
    "startTime": "02:04:25",
    "text": "um you"
  }
]
