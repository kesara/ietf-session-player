[
  {
    "startTime": "00:00:04",
    "text": "patrol now thank you okay it is time to start our session welcome to netmod and philadelphia and online uh i am lou berger we have with me kent watson and joel jugley my co-chairs they are both online and uh kent will be the one coordinating the slides and handing it to the different presenters so i think this will all work well uh that's the ietf so we have our usual note well the short of this is anything you say here uh becomes part of uh our permanent record and is considered a contribution if you're unfamiliar with the notewell please take a look at the main ietf page and follow the links to familiarize yourself with that we also remind everyone that we do have a code of conduct which says please treat each other professionally and with respect for this meeting we are using the integrated meet echo cue management everyone should take a look at the qr code that's up on the screen or go find it off of the main agenda page and we're going to try to use that to manage the queue that'll be particularly helpful because my co-chairs are remote and we'll all try to watch the queue but having that integrated queue will make it easy on us we've also been asked to remind participants that masks are required in session and keep them on uh the the mics seem to work just fine with the with the mask on"
  },
  {
    "startTime": "00:02:00",
    "text": "um remote participants if you're hearing me you've already figured this out you're on me deco i'll point everyone out also to the there's the uh note taking the joint net oops uh we have joint note taking um the link is here it's also there's a very nice way of getting it from need echo you just go sort of off to the right in the upper right and it says meeting note taking and if you click on that you'll join us at this page it's really helpful to help capture the comments that are made during discussion you do not need to capture the presented material um it is great if you capture someone else's and it's even better if you go make sure that your name is captured correctly in the minutes and that your comment was correctly accurately represented all material has been uploaded we have one late edition from our ad that will try to get uploaded before he talks at the end of the session we're going to spend much of our time today talking about yang versioning this is a topic that i'm sure most of you are really familiar with it's been going on for a bit we have done a last call on the first two documents and we had talked about holding the documents up uh until the full document set of five documents was ready for last call in discussion with the authors and the aed we're going to actually do something a little different basically the consensus among the those working on the document is it's not close to ready and they need a bit of time and rather than hold up uh these other documents for a long time which we thought originally was going to be a short time but now it's a long time"
  },
  {
    "startTime": "00:04:01",
    "text": "we're going to wait for an update that you're going to hear about today going to discuss that resolve any of the issues that are open get out a new version do another last call and then progress those at least that's the plan right now that is different than what we talked about previously uh okay so that's going to be the majority of our discussion today and then we still have some time available we're going to talk about a couple of unchartered documents and we had 25 minutes left on the schedule so in thinking about what we might do with that time to make good use of us all being together we have two topics the first topic is going to be yang next which we've talked about a few times and we're going to have an informal discussion led by the chairs and then the other topic is our id presented some ideas on how to move faster to the iesg and we're going to talk about that as well and i think we have 25 minutes for those conversations we have uh one recently published uh rfc thank you to everyone who worked on it we're here to publish documents it's always great to see everyone and meet and talk but our product of the documents so thank you for all who made that happen we have a couple of documents or a few documents that are posted last i don't call what that was uh rob are you getting ready to go to the bike all right so rob wilson just want to speak to the two documents that uh the intense extensions and sub interests feed our model that i've been setting for a long time so i'm glad to say that um scott and donov uh kindly agreed were"
  },
  {
    "startTime": "00:06:01",
    "text": "offered to help me progress those forward so um i've sent an email on the first one to them today i've had a quick chat with this week but the aim is to try and get an updated version of the first one out quite quickly i don't think that much to resolve and then we'll resolve the issues the other one and hopefully get these finally done soon so i think when i discussed it with you and the second worker glasgow would be appreciated on that on those updates that would be that'd be great as soon as you're ready please make sure to send something to the chair saying we're ready we'll push go and get these documents done thank you thanks yeah i really appreciate uh getting them out while balancing your padded load i know it's quite a bit being a.d uh the next document is uh the abyss on 69.91 that one is last call and we should expect a um a write-up soon from the the shepherd so nothing really interesting there and then we have the two documents that we talked about already uh that those were the post last call that we have the new plan for uh syslog was returned to us a little while ago it needs a minor change and that's going to be talked about i believe next just before the meeting we got a we received a liaison from uh oran and there this is unusual that they're actually asking for a response usually we get liaisons and they just want information they just are informing us of an activity and this one they've said we really want these documents to be published the ones we just talked about and you let us know when you expect them to be published so uh we had actually had the whole conversation about not holding these documents up before this came in and it sort of lines up well so you know i don't think we have too much to discuss in preparing a response we expect to draft one and send it and"
  },
  {
    "startTime": "00:08:00",
    "text": "uh if someone feels like giving us a draft rather than waiting for the chairs we're welcome to to take a look at it and the way to submit that is you send it to the working group list and say we propose this this is a response and if no one does it the chairs will probably get there oh yes all right said that he will help us with that thank you and again just send it to the list and say this is a draft a proposed response and this is a little boring we all know we can how to work remote uh now we're well seasoned at that at this point the main point in showing the slide is if you would like to use the working group resources for interims or informal meetings they are available to you and with that we're gonna move over to the first slot and joe are you i don't oh you are here awesome all you say is next then it'll magically happen hello i'm joe clark and this will be short um this is about the syslog draft no good deed goes unpunished i offered to take on this work to push it through since i know that there were some cisco people who'd worked on it and i really wanted to see it um ratified um so i took that uh unfortunately next slide please uh we only had uh or i was only been able to give or ken was only able to give me the rev 23 it was currently at rev26 the rev23xml so i had to back port a lot of the changes that had happened into that so i could at least get an xml that"
  },
  {
    "startTime": "00:10:00",
    "text": "that looked like the what was published in 26 so we did that mahesh was generous enough to provide his build system and he helped clean up some of this so we got uh the 26 there and then we updated things so that it had the right boilerplate and the right year and all of that and past id knits and everything looked good but then it was still broken and the thing i want to focus on the most is what you see there in orange the replace the old key store um grouping in there with the uh crypto types asymmetric key pair with cert group so next slide and i'll show you i realize this doesn't give enough context this the this quote-unquote cert changes in the draft this is under the signed syslog container area in that draft so if you support the feature of signing your syslog messages you need a way of reflecting what cert you are going to use in order to sign that and what key you want to use in order to sign or to use that cert so i think i've picked the right grouping here i think i picked the correct thing that that bundles i had to change some of the text so you can see what you what what it previously was what it now is uh and this seems to be restores the semantics of what this uh this grouping should do for allowing you to configure and support sciences log messages with this so i i would love to hear if i got it right i got it wrong but if i got it right i feel that the draft is where it can be to do a last call and hopefully push it through for ultimate ratification and i see kent coming to the queue kent yeah hi joe thanks for taking on this work really appreciate it um i do think"
  },
  {
    "startTime": "00:12:00",
    "text": "that you got it right uh it may be just one minor thing the um you have asymmetric key pair with certs plural grouping and it might be a symmetric key pair with cert singular grouping both groupings exist but what you want i think maybe with the singular not plural um regardless i'll be shepherd for this and we'll uh look at it again i i did look at both and and now that you're saying it and i'm on the hot seat i can't remember why i chose this one but i i consciously chose this one after reading uh through the crypto types draft but i would appreciate your insight was kind of what i was hoping to get um so thank you but that that is it uh the next slide is just my call to action um on this i would like the working group to kind of weigh in if we're ready i would like the last call and we'll see if we can't get this one finished thanks all right thank you very much and next we have no tags no tags sorry hello everyone my name is ching and i want to talk about unload attack in young lady motive so this is working cool job the current version number is zero eight next so a little bit a little bit recapture so what is this job uh talking about actually uh actually uh we we know the young module can comprise a set of uh data node and they know in a young data model maybe in in a single young data model or several young data model may share the same uh common characteristics uh or feature for example the both can be seen as some some kind of kpi data so"
  },
  {
    "startTime": "00:14:00",
    "text": "no tag really want to capture this kind of uh characteristic data and uh so uh currently uh no tech job has already got a review from young doctor and also uh the working google last call has been initiated and we got a lot of comments and thanks all all the reviewers and uh actually one substantial comments actually about the mechanism defined in this child whether it is generic enough or take it to some specific use cases so for these uh comments actually we uh take offline discussion with the reviewer juggen and we got a lot of suggestion and we listed several questions here we will you know give a detailed discussion about this question and our answer and you can see the current version 8 actually try to address all the comments during working with last call and a young doctor review next so this is a change we made actually when we started from zero six we actually made a two update actually the main change actually we changed the title uh since based on it is a touching with single no tag not only apply to some schema level tag and but also instance level tags so we change the title to reflect that and also uh we actually update the introduction and abstract and try to make object more clearly to cover both cases know the never type and the instance level uh schema level tag and instance level type and to make it more generic actually we in original version actually we have several young extension"
  },
  {
    "startTime": "00:16:00",
    "text": "actually we try to we have three uh extension not like metric type and opn tags that is not a magic enough kind of term actually we try to consolidate into one uh general young extension also in early version we have object tag and a property tag we think they are not important anymore so we just remove it and we actually uh we document clearly which tag uh can be captured how application can be supported to re-synchronize deploying uh any update in the section three based on the comments from eugene and uh also actually we clarify schema level tag can be used in the xpath query in section 3 and we also made several other changes in appendix so you can see that actually some of them just the editorial chain next so uh to uh revisit the question we discussed with yogan actually we have five questions actually try to go through this question actually the first question is about no tag whether it is schema level attack or instance level attack actually our answer is you know we cover both cases originally we focus on schema level attack better based on the managed discussion we think it would be useful the current both cases uh actually so uh for example our design uh we define the node node id actually as the node instance identified so this can fully support these both cases so we update the uh abstract introduction several sections to try to reflect this so for this one actually if anyone seems has any"
  },
  {
    "startTime": "00:18:01",
    "text": "different opening please let us know next the second one is about how no tech can we change it uh whether the tag changes frequently or not actually uh we actually we know actually there's another rfc called more uh mod module tag actually which is obviously 8819 actually they support both system tag and user config tag so actually for this job that we also support both tag so system system tag can be seen as a schema level tag actually so system client can add text into the data node list uh of the node text module if a model writer uses young extension to define the text so this is usually to tag a specific schema notes and actually usually this kind of tag actually are static and not changing frequently but for instance level tags so the client can dynamic to add or remove an attack on day node instance during the running time stage actually so this one actually the uh is possible so you can see it's possible to to change the tag but we think also not frequently actually you can see plan a can add tag client b actually can track these tag changes by you know subscribe these kind of tag changes so client a actually change tag changing can be automatically synced to the to plan b so [Music] so we actually uh this is a"
  },
  {
    "startTime": "00:20:01",
    "text": "discussion actually based on the discussion actually we actually made someone else's microphone i had to mute it thank you you're good okay so we actually uh so you can see this kind of change actually in the introduction or sample use case section we try to reflect this uh discussion uh in in the curtain version eight next so next is how tag are retrieved so we you you know actually no tag actually can be retrieved but we have uh we can retrieve the tag we can retrieve the data whether they you know can be retrieved together or they should be received separately so our answer is you know for uh tag actually uh you know tag receiver it should be recovered from the data retriever so we have two way to retrieve the tags the first is we define the ietf node tags module so we can you know allow the client to use a standard portable operation to retrieve the node tags uh to get this contact another way is you can use the get schema operation to this camera schema node tag so this is a you know similar to the obviously 8819 yeah next so question four is about a tank retriever skill actually i think this question also relates to the question two uh uh actually we in current version actually we we think that we can"
  },
  {
    "startTime": "00:22:01",
    "text": "use a standard protocol operation like get get config data to retrieve the tag and we use a standard field operation so we have no intention to extend a filter operation for tag retriever so that we will not use as a special selection filter so we clarify this and secondly actually we have two type of tag schema level tag instance level type so for schema level tag uh system only at one entry in the node so the frequency uh so tag retrieval scalability is not a big issue but for instance level tag actually client can use like edit config to add a tag or remove the tag so the number of the tag the client manager is controlled by the client itself so i think the scalability uh still can be uh controlled actually so here we also uh discuss uh about you know this instance can be tagged with the different tags so uh so this tag actually by design cannot be retrievable uh every for example for instance that is tagged with a different [Music] rob wilson so i just got a quick question on the first one about um getting data and you're saying you're going to use xpath filter for as the operation to basically select to just return data with a particular tag set is that right yeah and so why was it why did you choose to do it that way and not added an augmentation into the filter to say i want to just receive data that has this tag set what because that because to me xpath is a quite expensive way to do this whereas a filter operation that"
  },
  {
    "startTime": "00:24:00",
    "text": "just said i'm just looking for the data that is that's marked or tagged this way seems a lot cheaper computationally for the backend servers so i was just wondering why you went that way and not the other way uh actually we as we clarify we just try to use a standard selection filter we don't make the changes so we think we can go this way but at the complexity uh we so actually we we we use this kind of tag actually uh you know uh to capture the the the some of the common characters uh data actually uh i so what what do you suggest uh so so my suggestion is i think you're saying you're gonna use xpath i i guess it's doing with attributes or something to filter the data and the attributes to check against the tag but i always see the x-path filtering is quite an expensive operation and aren't sure necessarily whether all implementations support that or they just support subtree filters i'm not sure how you do with the subtree filter whereas if you looked look at like the nmd nmda netconf extensions they augmented like the get data operation had new fields new options for like limiting the depth of the now today to be returned or filter it on uh some um of things like the origin metadata and i was wondering here whether that would be another option to have another augmentation to that to say filter on these tags so we just pull out the data that has that tag set or maybe the descendant data that has a tag set rather than using the xpath mechanism yeah we don't use xpath maxim to to get together actually these just you know you can use this this kind of standard operation to get the data you can do the second for your for example client get all the"
  },
  {
    "startTime": "00:26:01",
    "text": "data they can do the second uh level uh local uh filtering uh so let me sync up with your flan okay next it's not exactly to this slide just generally to the draft you have these mask tags and if you can use this mask text to remove text that or mask text that that the model designer put there i see that as a very uncertain man is because maybe the module designer knew that this must be tagged x and then the user comes and says say no x i see that is a big problem so is there a priority between somehow these tags and masking i think that what the model module design decides should stand yeah this design actually borrowed the same concept from module tag obviously you know used to you know remove the tag [Music] i'm not sure uh this will make some of our use cases impossible if if this the schema tags become so unreliable uh level attack actually it's kind of static yes but if they can mask them then they are not static anymore isn't it yeah um perhaps discuss it on the list yeah maybe yeah we can take a to the list for for discussing this yes thank you um"
  },
  {
    "startTime": "00:28:00",
    "text": "next question yeah next is about the module writer guidance actually there's two relevant questions one is you know we define the maximum in this chapter so how these relate to the metadata annotation mechanism how this how this can be differentiated from metadata allocation annotation the other question is how this can be different from the simple young extension statements for things that are static so we compare the metadata annotation with uh with the mechanism we define in this chart actually we think metadata annotation actually usually are tied with a given date node instance so uh usually the value of the metadata annotation is assigned by the server if we don't worry for origin value it can be assigned by a server sent to the client that you indicated the origin particular data instance but for no tag actually in defining our job actually retrieval essentially by they know the tag module so it is actually created or removed by the system client so here we give example you can tag the schema sheet to to uh to to to apply to a whole list so this can be differentiated so the second is how this differentiates from the young extension statements actually we also give analysis actually for instance level tag and schema level attack for instance level attack actually this yearly only tags they don't know they are rather than actually statement or data modules so so we don't use the node tag to tag a revision statement in the data module but uh but definitely actually we can provide some of the additional ordinary information"
  },
  {
    "startTime": "00:30:01",
    "text": "or they know the property we give example in appendix and a schema level tag actually this can be deleted by the uh they know tag module and remove from operational they store but such kind of tag because it's kind of static that still exists in a young module so this still can be differentiated from the simple young extension statements so [Music] yeah next so we will allow to hear all the comments and try to resolve this and uh for the next step we want to yeah hear guidance from chairs yeah i i it's there's clearly some comments in the room on the list it wasn't clear to me that jorgen's comments were all addressed and i know the last uh he did not send any comments after the last update so it would be good to make sure that his comments are addressed as well as any other comments that came in as part of that discussion and it sounds like you have a couple of new comments we really have to close those all out before we can uh yeah yeah we we take this offline with jugang and uh have several iterations and the the latest version he hasn't confirmed all the changes so we will uh you know ping that we're gonna again take it to the list together his conversation yeah yeah we are coming up on august and that can be tough for a lot of people but maybe we should if we if we're not resolved by the end of august we probably will schedule a interim to try to close it to force all the issues to be closed but look for the new emails sounds like you're going to get a couple from the room yeah thank you very much yes thank you thank you next up so we're going to do the overview of the yang versioning discussion we have 45 minutes on this and i was just going to give you each 15 unless you want to do something different"
  },
  {
    "startTime": "00:32:00",
    "text": "might not take that long we'll see we'll find out uh hello everyone yes this is the um beginning of the uh three pieces on the young versioning solution update uh next slide please so we're going to have a little overview for myself um then we'll go on to individual drafts with balash and joe next slide so a quick recap on the versioning solution um the complete solution consists of five drafts updated young model revision handling module semantic version number scheme uh yang schema comparison tooling version yang packages my favorite protocol operations for package version selection and the working drafts can be found on github at the moment with all the issues logged there next slide please uh and just a quick wrap though if you're having a look at uh wondering where some of these drafts are those are the urls next slide please so um a a brief overview of what we're doing on the weekly versioning calls at the moment um authors and interesting parties we are meeting every single week these meetings are open to all it's not a fixed list of attendees we're having regular participation from five different companies um it is quite vendor heavy um i believe there's only myself and maybe one other who who represents an operator so if you are interested in versioning package versioning or anything of the sort please do consider coming and joining in from those backgrounds we're obviously bringing key issues back to the working group mailing list and yeah the times are there at the moment so of course if you'd like to join us in and you can and you're able on those time zones um please do next slide thank you"
  },
  {
    "startTime": "00:34:02",
    "text": "to dive into it a little bit more deeply um the main focus of the weekly meetings at the moment number one is processing the feedback from the last call on the module versioning and yang some of the drafts we've had a lot of complex discussions around this it's it has taken quite a bit of debate and a number of the the weekly calls have been taken up with this um we're in the process at the moment of addressing each of those and posting responses back to the mailing list and there will be some updates to the drafts required quite likely the second main piece of work at the moment is beginning to look at the schema comparison draft the last call on module versioning drafts made us realize that the schema comparison is fairly integral we may move some parts of the schema comparison into module versioning per element non-breaking changes or breaking changes takes for example we haven't yet looked at packages or whole version selection drafts um i i believe uh next slide please i think there's a note on here that we are heading in that direction so our next steps finish processing all the comments received on those two drafts there are quite a few as i've mentioned get all those back get the drafts updated we are expecting um to do another working group last call for both of those drafts with the intention to bring them to rfc we won't wait any longer for the remaining three drafts comparison packages and selection um the work is taking quite a bit a lot quite a lot of time to converge but the the array of is of course asking us for when the drafts will be completed um which has um i think kick things in into higher gear and of course as i mentioned"
  },
  {
    "startTime": "00:36:00",
    "text": "more work um will then continue on schema comparison packages and version selection next slide please yeah i think that's the end of that part so we'll move on to was it blush next i think yeah that was far less than 15 minutes okay part of this weekly group and part of the auto group next we had one last call with uh some interesting comments and some basic comments we released a new version but that's mostly just to keep it up to date so not to let it expire and these are the main issues heavily with the first one whether we should have uh data node change on on the module level or is it enough to have or is it better to have it on the individual data node or schema node level next please let's catch us doing it okay so uh we got the uh module versioning marking that says the change is not compatible and it indica indicates so it's basically just indicates it's not compatible and if you have sembler and a revision label for it that would also give you an indication whether changes are compatible non-compatible or maybe just editorial and we could put these we our plan was to put this information on the module level the revision information we got a proposal that it's better to put it on the individual node level and we agreed that just quick it might be better if you move the mic a little closer for the"
  },
  {
    "startTime": "00:38:01",
    "text": "remote people they're not hearing you too well or raise it or something so the waters or the weekly groups consensus is that both module level and node level are valuable but they really serve different purposes next just a quick rack up this is what we originally planned put the marking into the revision information this is basically a node level statement next and this is how we believe a node level or schema node level statement would look like this indicates that one leaf or one container or one item is has changed it indicates when it's changed so you can track back that you know with the revision statements and the development steps and maybe have some description also this uh these two are not either or they can the node and the module level can uh live side by side and help each other maybe editorial change can also be marked but that's open question next so the or alternative proposal was that we have to put have to mark every nbc change non-backward compatible change uh without some annotation and that means that there if there's no annotation then this is a not changed or changed change the backward compatible or editorial uh way and the consumers of the module will"
  },
  {
    "startTime": "00:40:02",
    "text": "have to look through the scan the module to find what kind of changes happened in the last time we think that this has problems we first of all it might end up with a lot of such annotation and these annotations and we have to remember that some other groups sdos 3gpp or on i think a broadband forum as well they release modules multiple times a year and that means that they will have more changes they will have more nbc changes and that might clutter up the module and it will be difficult to find the containers between all these annotations also can we convince all these groups to use this it's not not sure and also how do you handle deleted nodes if the node is deleted you can't put the marking that it is in nbc change on something that's not there and also uh we see that it is a it might be a problem that what if the author forgets to mark something as ndc change that would automatically mean something it might be just a mistake but now it became a backward compatible change next please so the weekly group came to an idea consensus that in some cases where node data change notifications are good we should use them and the authors may add them any any place but we should not say that if it's missing that it implies something if you have a list of 20 leaves and you forget the 15th to forget to annotate the 15th that doesn't mean you mean something that means that you were tired and you forgot one from"
  },
  {
    "startTime": "00:42:01",
    "text": "20. so tooling should be used as much as possible to instead of these individual annotations and that would also mean less text next so mostly tooling can apply the uh versioning and other nbc rules that are already defined in the rf rfc and in the versioning draft uh it is not reliable everywhere because of multiple reasons one is that yep sometimes it's just not possible to find out if it's the plain english text that the description changed you might or might that fight or might not be backward compatible and for some complex statements like regular expression when or a must statement figuring out whether a regular expression changes compatible or not that's very tough probably tools will not go into that details so the authors will be allowed to mark anything and and they might say that yes this regular expression change is actually compatible or it is actually non-compatible next yeah so where should we we agree that this pair node annotations are good and useful in a limited way so not for every node but for nodes where we can't decide or a tool can't decide whether it is backward compatible or not we have to define it somewhere we said that we should put it in some draft the idea originally was to leave it to the schema compression draft later now the idea was to at least define the extension itself in the module versioning draft and then two defaults and how it is exactly used that could be left when we define how the two actually"
  },
  {
    "startTime": "00:44:00",
    "text": "works but if we if the that would allow the author to explicitly put in statements like i changed the description and this is actually an uncompatible change because it really works differently but we are not decided fully there yet and yes we need to be hurry up because bbf already chosen version scheme we don't want two other groups to choose versioning schemes independent of the idf next okay then the question came up if something is really and uh non-backward compatible should we allow the author of the draft or author of a yang module to say that no this is compatible even if according to rules it is not and yes we see that there is a there are a number of use cases things like that turn change where actually the the value space may not even change at all then evaluating these complex statements the two might not be able to do that it's just too much for them another case is when we really correct mistakes what if the though i allowed an ip address to contain three five five instead of two five five yes the pattern is changed incompatibly but it is still not a real change because the ip addresses were not 355 earlier and in some cases when all the clients are unknown strictly for vendor modules then it even an incompatible change might be a don't care next so that's uh concludes a statement or statement about this breaking proposal of the work group last call that yes spare node"
  },
  {
    "startTime": "00:46:03",
    "text": "not generally and not they won't replace the module level annotations they serve different purposes and both are needed the next question you want to ask if there's any questions on that before moving on or no one's come to the queue but it seems like you would like some input yes any questions or opinions on this i think it's after lunch the energy level is low all right okay thank you the next topic that was discussed quite a bit during last call is this derived revision import or import by derived revision is it needed why is it done this way what risks does it carry will it is it a compatible change to the original draft now today we have these two methods for import plain import which means anything can be used it has risk and actually in our own rfcs we try to try to restrict what is imported using comments or not comments but description statements and references not very good or we can have import by exact revision but that means that if the imported file is updated then you need to update importer and that's not that's a big work very hard to coordinate and it's not a good solution which is uh shown by practically no one using it so i scanned the all the ietf modules i think i only found one usage of import by exact revision so we are asking for import by derived revision basic idea is that i have one or two new things i need that by the the importer needs it"
  },
  {
    "startTime": "00:48:01",
    "text": "and we want uh but otherwise i don't want to update and i want to follow the revisions we don't want to have a strict linkage between the revisions of importer and the importing imported module but we do need some kind of things and this just enhances compiler so if let's say i have five revisions if any anything can be used but if i tell the compiler that two are actually unsuitable that's a big improvement and if the compiler doesn't understand this import by derived revision extension and no worse than before it's still the same five that can be used next okay so why did we do it this way really the most common problem was really that i need the new functionality in the imported module to be there and i usually only need one one or two or a few smaller items from the module from the important module not all of the things i also want to follow the updates if there are error corrections or just to avoid using very old modules and we don't want to update all my importing modules all the time and yes there is this trade-off that either you specify a very precise and set of modules that you are willing to import but then this is complicated and restrictive or if you specify something simple like what we propose and then there are some risks what things we didn't want to do is one is that if a module is changed the imported module is changed but only some part which i"
  },
  {
    "startTime": "00:50:01",
    "text": "don't care i don't want to update my modules for that also we could in earlier versions of this draft we had very specific uh ways or statements how what we want to import we had ranges of module revisions excluding or import or or including additional ones open-ended ranges closed end ranges and all these niceties had logic behind them and they became so complicated that no one understood them except maybe the water so we want to avoid that and below we have a few examples where the this import by revision including your functionality was x really really needed and actually used already by text message text descriptions next please okay what do we accept expect from tool behavior so one could say that this is a critical thing if the new things are not included and we include some or import some old revision then it's better to fail or we could do what 7950 says that if you don't know the extension like this import by um by derived revision then just ignore it and the consensus was that let's go with the 7950 behavior because already to fail on this unknown extension that would need updating the tools and yeah if we update it why don't you update it to fully so we expect that these will just be ignored if if i'm not recognized by a tool and then we have a small separate problem the lower point is about revision label"
  },
  {
    "startTime": "00:52:02",
    "text": "scheme we have revision labels defined what how do we know what kind of scheme that uses maybe there are multiple schemes that are slightly incompatible so we have another extension revision label scheme that specifies actually what is the scheme for the revision label should we make the usage of this mandatory if and only if the revision label is present and the idea is that for a standard models yes please specify what your revision label scheme you are using for other modules vendor modules this should be recommended yes questions comments uh so robot from cisco so i want to speak actually back to the previous section so at the moment how the draft is specifying it is effectively saying on the revision or derived if you support that extension statement you can only select a module version that that is derived from that specification so it limits the sets you choose and we play a bit of a game in terms of saying that you're not really changing the behavior for a compiler that doesn't support this extension statement because it could have chosen that module version anyway it's also quite ambiguous what the behavior is in the uh more recently in the author's group and things we've had this discussion about a slightly alternative interpretation of that so rather than the revision or derived being strict it has to be a later version or not it becomes a sort of um suggestive approach this so it suggests a version that you should use um but doesn't doesn't mandate or require that so a compiler would still be allowed to pull up and or use an older version or different version that isn't in that classification or original derived and and effectively the suggestion there is if you if you do choose a version that's compatible uh and within that within the sort of selection criteria that's great and if"
  },
  {
    "startTime": "00:54:00",
    "text": "some reason you can't find that and you choose another version then you might have a warning coming out during the past saying that you're picking up an older version and in many cases it might be that that's you then it fails and you you're missing a type or something and so you can't compile things together but it also might mean that if you have like branched histories it allows you to use a young module on a different branch that might actually have the type you want because it's been added in two places but it's not derived from that original thing so it sort of solves that problem but the reason that i quite like it is it also means that the behavior now is completely sort of consistent with um not understanding this extension as well because you're not ruling out which selection of modules you're using you're just giving a hint to the compiler as to which one's a better one so i don't know if there's anyone in the room has they understand my explanation have any thoughts on that as to which way might be a better way to go but we'd like to hear it if you do thank you next please then we had an issue with if i we got no comments and about revision label in the file name the proposal is that we find it very useful to reference files with the revision label it is much easier for some for people to recognize 3.3 but then sometimes to recognize the exact date especially if we have let's say multiple tracks yep using the revision labeling the finding is just convenient so now we have two possibilities for the file name it can include the date with this add sign or it can include the revision label with a hash mark both are allowed"
  },
  {
    "startTime": "00:56:01",
    "text": "actually you can have you know your file system the same yang module with two different names actually we already have this situation because you could have it one with or one and one without the data already so i think we still would we see the advantages of this next please and there was some discussion whether this whole versioning issue should be part of yang 1.1 or as an extension or should it go to yang next or yank 2 or however it will be called and yes we agree that this should go to yank two and it should become a mandatory part of yank2 but that doesn't mean we should stop working and we should wait for yanktubric or yang next because that takes a lot of time so do it now in yang 1.1 as extensions and integrate it into yang next when whenever that happens so yes it's needed urgently don't wait and i actually went uh this is lou uh i i went through my notes on this one because i i felt like we discussed this at the last meeting but i didn't see it in the in the minutes so i thought it would be good to state here again that i believe this was the consensus at the last meeting although it's not supported by the minutes okay thank you and i think that's my last slide any questions comments yes how do we get to the point where the document is done to the uh and we have no more uh questions so that we can press forward with it at last call and publish i think the idea is to have uh one more last call at least for the we have a few decisions on these issues can you go back to slide one please"
  },
  {
    "startTime": "00:58:03",
    "text": "remember you're talking to me yeah okay you can't can you go back to slide one please yeah you listed a whole lot of questions and i was sort of expecting to ask yes for feed specific feedback because it would be good to close on these so we can as i said press forward i think we kind of settled on most of the issues maybe the where to place the per node extension that's an open one and uh we need to add that if we settle that then we need to adjust to the current versioning draft maybe a second last call to agree agree that it's finalized and then yeah okay so it should not be much much change except of that as i see then what i'm hearing is even though they're presented as questions you think they're pretty non-controversial and that you would expect that any objections would be brought up on the list and hearing none you will proceed with a new version that captures your conclusions yes okay all right that sounds like a plan to me i just didn't like leaving it with open questions and we're here to close issues so thank you so with that i forget who's presenting next are we back to joe all right well this is an update well if you're tall this is an update on the semantic yang sember the semantic version like um revision label scheme so next slide please kent"
  },
  {
    "startTime": "01:00:01",
    "text": "so the current status we did release an 07 there were very few comments from jurgen that were addressed in here semver the way it's written on their website december 2.0.0 website is capital s capital v in the camel case there so we did that to make a visual disambiguation between the simber 2.0 spec and i use the air quotes for those not in the room you can see on video because they did in fact change 2.0.0 multiple times but never never increased their own uh revision or version number uh but we did anchor to the one that we are using um and we clarified some of the use of our semantic version uh the the con or the concept of semantic versioning as opposed to the semver the spec and the yang simvers specifically there is more to do there there's more text to be added there is a github issue on that we've been focusing a lot more on just uh as balash mentioned addressing some of the issues uh but but to uh uh lose question we need to uh shore up the text so folk have like a focus session on each one of these drafts shore up the text uh with the responses to the the comments and then get another uh more detailed revision out we also fixed some typo in the prefix small things like i said and we compressed the acknowledgement section not to say we removed acknowledgements we just made it less taking up less space on the page next slide please so that's the boring stuff more interesting stuff are the outstanding issues or is the outstanding issues um the the the big thing and and balash hinted at it uh that that was"
  },
  {
    "startTime": "01:02:00",
    "text": "raised simver if you look at a a semantic version a yang simverse string let's say you can't tell unambiguously and and authoritatively where it derived from and that was never the intention we'll get to that revision labels are not designed to be linear they're designed to anchor you to a revision and and just like in fact i stole shamelessly stole bellagio's slide we'll look at that again um it's simver but it isn't and we'll get to that i have a slide for it um you know for those who can't wait for the movie it it it isn't but it can be yang simba is trying to encode the release train um it may seem that way we have a lot of vendors on the call but you could in fact create your own revision label scheme that honestly does encode the release train and andy brought up an issue there was too much much work involved or too noisy to bump the yang simber for work in progress and we'll talk about each one of these the next slide please ken and this is uh balash's slide he did a great job he did a great job on this man um the idea here is no you can't tell just by looking at the simver like in in this example you uh or i should say in the in the top example that if if uh you have a a 1.0.0 and you have a 1.1.0 and then you see 2.0.0 you can't say that 2.0.0 contains everything that 1.1.0 has because it as you can see from the slide it derived directly from 1.0.0 so while you your brain might logically assume that well they made a minor revision to 1.1 surely they just added some things that they put into it out of there's no way to know that what you do know is that 2.0.0"
  },
  {
    "startTime": "01:04:01",
    "text": "points to a revision and i can look at that revision and then i can work my way up using the yang module versioning work and say it derived directly from 1.0.0 so that i know there may be stuff in 1.1.0 that it isn't reflected in 2.0.0 and yes it would be nice if we knew directly that the 2.0.0 must include but because branching the fact that branching exists at all is there it means we can't know that it's not the labeling that breaks this this knowledge it's the fact that branching is allowed even in the the base simver i can do this as long as i constantly work linearly as long as i always say that once i come up with a new major release i'm never going to do anything back on the minor or sorry on the previous major then you know that it's always going to derive from wherever you were in that point i'm never going to go back i'm going to do 1.001.10 2.00 and i'm never going to go back and create a 1.2.0 but that's not the case we know that's not the case we're not enforcing that just like tom mentioned in in his intro we're just saying this exists and we're allowing authors to signal it through the module versioning and then by extension the um revision labeling so it's not the labeling that breaks this it's not the labeling that causes this confusion it's the fact that branching can happen and what we're trying to do is give you a more human readable anchor point the revision label that gives you something that says okay i can look at that and i can kind of get from what i know of simver i know that between 1.1.0 and 2.0.0 there are some potentially breaking things"
  },
  {
    "startTime": "01:06:01",
    "text": "non-backwards compatible things that might affect me and now i'm going to go and look at that further that's what we're doing with with the revision label next slide please pausing a little bit to see if there's any questions okay it's simver but it isn't it's a dessert topping it's a floor wax it's both yang simver can be 100 simver we have additional additives we have the underscore compatible and the underscore non underscore compatible you don't have to use them if you want to do things there's more that is in line more with a straight capital s capital v semver you can do that in fact the ietf we don't ever expect to see underscore compatible or underscore non-underscore compatible what we do expect to see is things that look more and behave more like the true semver 2.0.0 for that spec that we we reference so semver r simver yang simver is a super set of the semver 2.0.0 and you can choose to use the pure some respect though there is an action for us we have to clarify what is unique we have it in there but we need to in no in certain terms spell it out that underscore compatible underscore non-underscore compatible these are unique to what we're proposing the rest completely in line with the rules of simba you can you can use the rules of simber with your revision label scheme you can declare a revision label scheme that is simver"
  },
  {
    "startTime": "01:08:00",
    "text": "and follow those rules you can follow those rules with our yang simver you don't have to use compatible non-compatible next slide please aha i hope i understood this correctly we are not necessarily encoding the release train of software into the yang uh in the yang simba what we are doing is reflecting what changed in the module at a high at a high level we're reflecting that we're saying if you if you remember that picture two slides ago that if i had 1.1.0 and i was using it and now i am using or i have a module two dot i produce a module 2.0.0 that there are potentially well there are back non-backwards compatible changes in in 2.0.0 from 1.1.0 or from 1.0.0 they may affect you they may affect the work that you're doing the tooling that you're creating the interaction you have as a client with this with the server that supports that new version we are not necessarily reflecting the underlying software of the of the server meaning the features the capabilities of the the software release train of the vendor a vendor could come up with their own scheme i work for cisco cisco could come up with our own scheme for revision label that really reflects the ios xr version if we wanted to but what we're trying to do here with yang simver is reflect is give that high level understanding you can look at it and quick glance and say i know that there are and you can read the draft non-backwards compatible changes between this version of a module and that version of a module or i know there are potentially those minor changes there are back there are backwards compatible changes things i might be interested in"
  },
  {
    "startTime": "01:10:00",
    "text": "learning about or i know there's only editorial changes it's just come typo fixes no semantic changes between these two that's what we're trying to convey with yang simver next slide please okay i actually like this um bumping uh the the work in progress but i i realize that that it's it is work um from what i have seen working at a vendor there is a tendency to implement work in progress drafts especially ones that are long running people look at that and they go that's interesting i want you to do that okay and so as a product manager goes yeah we want to make money we'll do this how do you know what they implemented what version they implemented well there might be in the documentation some draft that says okay i implemented in this version of our product draft dash netmod dash something maybe that was a bad example there but whatever you might see that but how would you reflect that with a yang module what we want to be able to do is is say specifically that every release or every revision of a yang module in a draft if you've made changes to it we want you to bump that that semver label that revision label and have it be the rule is it has to be unique so we bake in the draft name and its revision and we do the name in there because there can be parallel work streams working on the same revising the same yang module so we have the uh the draft name in there with its revision that keeps it unique so we can always use that as an anchor point to find the revision defined the inheritance and and and the the changes that happened within that module if you change the draft but you do not"
  },
  {
    "startTime": "01:12:02",
    "text": "change the yang module if you're just adding contextual text explaining things updating the formatting of the yang tree you don't change the module you do not have to change the revision label just like you don't have to change the revision but if you make a change such that you change the revision of that yang module then you have to update the sember as well the revision label we need to make that text a little clearer in the write-up as to why and when you make those changes and it was brought up because i i released a new version of the yang zimber draft but the yang uh the actual there is a yang module in that draft the the revision label didn't change and i said well we didn't make changes to the module so if you implement this nothing has changed so we don't want to gratuitously bump uh the revision and we don't want to gratuitously bump the december revision label either we think that makes sense sorry very sorry next slide please i think that's it okay applied the last slide that was costly that is the last slide okay um so that is uh the update on yang simvar um with some of the work that we still have to do um questions all right thank you i guess i have one question this is louis contributor are you assuming that you never use the date with sever based on the previous draft are you assuming that you never use the date um you could use the date what do you you could i'm thinking about how"
  },
  {
    "startTime": "01:14:01",
    "text": "if both the date the the previous semantics if i read it correctly allowed for both correct it wasn't either or it was both um in the revision or derived no in the previous in the previous craft you mean the file name or because in the in the module change the revision statement so that must include the date just as to this this will be uh so would you expect the date to change in the version not no they would both say the same they would so if if i'm making it i just felt like it's not it's one changes than the other must they must work in synchron they both identify this version so in the case where we have an updated draft where you do not change the december what happens to the date the date should not change either okay if i don't make a change to the module i shouldn't update the revision of the module because it's identical to the previous there i mean you could it would to me it's a gratuitous change i agree with you i just that's what you usually see with drafts at least i'm used to seeing people updating i've seen both to be fair to you i've seen it yeah i so i think it would be good just to be clear what the expectation is in the document totally agree with you and some set liquid um is there anything wrong with gratuitous version bumping um i i don't think there's necessarily anything wrong with it it um i guess this gets to the noise uh bit that andy was raising that if you if you keep bumping these you keep incrementing so there's a few sets of tools that extract yang modules and add them to the file systems of like"
  },
  {
    "startTime": "01:16:01",
    "text": "get repositories you just keep adding on to that and you're not re and you could interrupt uh people like oh i've got this new version i've got to look at only to find out that it's the same as before it just adds work where it seems like you know get doesn't really allow you i used just get because i've been using it a lot this week if you do a git commit you haven't made any changes it says you can force it but it just seems like why create that churn sure i'm just um i'm just trying to take the parallel from pure development space where i'm trying to also get my head around the whole version tracking and it's sem verb and not send there and and i just think it might actually help if we working towards this idea that we don't have these inversion branches i mean if we look at the development flow you've got you've got branching but you also have merging you merge back your features into the parent thing and then that follows december properly it's from me personally i think um and i'm new to the room um it just feels like we're adding confusion but i do take your point about you know gratuitously bumping stuff and why that might not be a good thing the uh the merging is is is interesting because you have you can look back at that history and you can see that that that a branch has has been merged back in um here you we don't have the the the linearity of like looking back in a um in a yang module you could still reflect that if you if you did in fact merge you could say that okay i i merged uh one i i merged some of these features and from a if you had the revisions you would be able to to in fact see that"
  },
  {
    "startTime": "01:18:01",
    "text": "okay this 2.0.0 really did extend from one but looking just at 2.0.0 compared to one just looking at those two strings together you don't know for certain where they inherited from you have to do the the upward tracking to find out if there was a merge and where that merge happened and when that merge happened so i think we still get that it's just not visually comparing the two simverse strings charles yeah charles eccle and um you know i just think it's uh there's different consumers of these doc these drafts and the yang models they contain and i think some of the consumers of those will be following you know the work of the itf data tracker they'll know when a new draft comes out so for them it's probably not a big deal but i think there's a lot of consumers of this that that really just care about the yang gang modules and for them to it's just better if they don't see a change i would think if nothing changed like i would save them the extra work and the churn and hey why does this thing keep changing so i think it's better for them if you don't so i would say it's while it's not horrible to gratuitously update i think it's better not to and and i take the comment from you lou that that we can be better about describing that being extra explicit uh robertson cisco i was just going to reply back to anne's comments and things so i think our aim and our goal here is to try even for the vendors to get a sort of linear development of the young models that's what you want that's that's what you're aiming for and the case where the branching turns up is because we've shipped to release and we've got a bug fix we need to put on to that and we can't we can't easily update that order at least to the latest yam model because it's got a load of other code that we don't want and that's where we get the branching so it's sort of quite limited stub branches um and you would i would expect the"
  },
  {
    "startTime": "01:20:01",
    "text": "stuff you're adding into those branches bug fixes are either going into the main line anyway or either way around whichever way you put them so you could you could mark the merging to say you've done that but it depends which way depends which one gets written first i guess so you won't always have that you might be you've done in the fix on the main line and you're back porting it to older releases so i just brought up the uh outstanding issues to make sure the group the room and everyone understands the plan is is you're going to do an update and you think you're going to be ready for last call once that update's done or you think you have more issues to discuss you want my honest opinion yes i honestly think getting people on the call who are going to be vocal about this would probably work the best to close these out once and for all um rather than just doing a another round of email last call even though i know pro probably process-wise we have to do that that's my honest opinion all right so what you're saying is you'd like to do a new version and publish submit for publication well i would like to do a new version i think the last call is important but i think if in going back and forth on the last call it might we might be able to hammer more things out if we did like an interim getting the the the passionate people together to to have that conversation more live than than an email now i've opened a can of worms so rob wilson uh not with my id hat on so um there's just been an observation here that the the people who've been raising lots of these issues during the working with us calls unfortunately are not able to make this meeting so they're not here so we're"
  },
  {
    "startTime": "01:22:00",
    "text": "discussing all these issues but the main people we want to have those conversations with the other side are not here so it's making it hard to resolve them and we can try and resolve them over email we spend a lot of time discussing them within the authors like on those weekly meetings and and a lot of considerations gone in but i think in most cases we've had some tweaks and enhancements and things but also is we think we are we're on the right track and we need to get this through so um so my view as a contributor is we need to put the updates into new versions of the documents we need to do another working last call and a proper full one to say look this is this is where we're gonna get and then flush them out we need to do an interim after that to resolve those i don't know but so so what you just captured i think is the chair's plan okay so if everyone is okay with that and i know you you would maybe for not but you can live with it and uh if everyone's okay we're gonna proceed that way so we look forward to seeing the the update and uh look we'll the working group should look forward to the last call second last call thank you no thank you all right we are now going to move on to the non-chartered uh items uh shifeng yeah hello yes you sound good thank you please proceed okay okay thank you so hello everyone uh this is twofold from huawei and on behalf of the authors and contributors i will give a presentation about system defined configuration work i will present remotely yeah so actually this work has already been presented for several times and at the same time there are a lot of good discussion on the mailing list and so many folks have shared their excellent ideas and provided a very great input so thank you all based on our a lot of discussion i think we do have reached some agreements which"
  },
  {
    "startTime": "01:24:02",
    "text": "are already be written in the current version of the draft and the very first one is that config true read-only system data style to hold configuration which is provided by the system itself so the system data store is read only to clients which mean that any added operation to modify the contents of this data store directly must be denied but system may change dynamically for example when the device upgrades or hardware results is available and the second one is that any reference system configuration in system must be present present in running we had a really rigorous discussion about whether offline validation of running alone is required and to avoid the changing the definition in 50 and 842 and also not to break any lexical lines which relies on the validation of running along we agreed that the validation of running is required so as to say any reference system configuration in system must be present in running the third one is about a result system parameter which controls whether to allow a server to copy any reference system defined configuration automatically this provides convenience to ensure the second bullet we can say that since all ref any reference system configuration must be present in running and a client can copy the references the reference node from system to running explicitly but manual copy and paste may not be desirable so we do allow a client to carry a result system flag in their edit config or edit data operation so that a server"
  },
  {
    "startTime": "01:26:01",
    "text": "can resolve the reference and copy the reference system configuration automatically but if this parameter is not provided the server should not modify running in anywhere not specified by the client and this is the last bullet point in the previous version it was a very strong restriction to say that the server must not modify running if not asked but to avoid any potential non-backward con non-backward con probability and after some discussion on the mailing list we weakened it and just said that it should not modify ronnie if not asked so it is preferred that a client can control configuration in running as much as possible and running is only updated by the client a client can benefit from such a behavior which should work as a best practice so blush do have something to say i saw you in the queue to the last bullet i objected last time and i still have to object that there are people out there who are using yang for example 3gpp and who prescribed that the system must modify running in some cases so putting such a should not here i don't like it we used to have some some discussion on the mailing list and there was some agreement to say that we would like a client control objective to say that a client would like to when when the client retrieves running he won't like he would like to get what was exactly said to the to the server so we used to have a client control objective um i i think this is the"
  },
  {
    "startTime": "01:28:02",
    "text": "this should not is work as that best practice not a restriction if you have some other design consideration you can still follow your principal so just show not not a really restriction i think many many notes have on out o m automation and then that would also violate this and the discussion whether that's an onboard client or the system itself changes it that's philosophical so yeah we don't seem to agree thank you okay job do you want to say something uh robertson cisco as a participant i i think they should not write here i think that otherwise it's sort of breaking how this how the whole young ecosystems have been designed to work and i do take bellagio's point though that i would say in that case you've got automation running on the device you treat that as another client and that's fine i have no issues then then it's modifying it but it's still ultimately if that's under the client control and they can turn that off or turn on and do whatever they're doing that's fine so so maybe that's the get out clause but i think this is right in my view okay so kent yes hi kent watson as a contributor um i also think this is right um but i want to note that there's existing rfc the one that defines the crypt hash um and specifically it's you know for user management and for how to specify user passwords and it says specifically that if you um and it defines it in the description statement that if the password sent from"
  },
  {
    "startTime": "01:30:02",
    "text": "the client to the server begins with dollar sign zero dollar sign it means that uh the text thereafter is clear text and it's expected that the server will replace with and with an actual uh hashed password and it on the server that way and then when retrieved back to the client it will be of course not the same as what the client had sent it will then be hashed so i think that's a that's an example of an already existing rfc that doesn't really follow the should not principle but it's okay because they described it i mean the best practice stands uh even though the description statement's there i think it's perfectly reasonable for that to be the case okay thank you so jason okay jason hello can you guys hear me okay yes yes we can hear you um jason stern um i i agree uh i like that uh second uh second bullet that um basically saying the running should be valid and should be able to be offline validated and that my big concern is that um at some point and maybe we're never going to look at it but um you know nmda mentions the the some of the some of the translations from running to intended include um templates configuration templates and that for me is a big problem here and i'm you know i'm hesitant to tangle up this work in templates but i'm worried that we might say running always has to be um valid and then when we tackle templates at some point i i don't know how that can work with running being valid so i know you won't have an answer uh"
  },
  {
    "startTime": "01:32:01",
    "text": "chiffang but um it's just it's a concern that may be for some discussion as part of the work uh yeah we we said that ronnie must be valid is referenced from the 7915 and instead of that we can also we can just say that any reference system configuration in system but must be planned in running but whether that would ensure that running must always be valid because of we can have some template expansion issue maybe that will cause running invalid i'm not sure i think the template maybe should not be included in this just in the scope of this work now so yeah we can have more discussion it could be that could be i just i'm worried about being so strict about the running and then we just reverse that when we figure out templates but okay that's something just to be discussed yeah okay i understand your point so rob all right so i'm going to try and avoid going down the rat hole that jason's putting in front of us so i think already actually though at least an mba says that running has to be valid but this part of that and templates and outside i just want to go back to kent's comments and it's like yes i think that's a great example of why this is a should not at the bottom and not a must not i think that's a there's a good case of why you pragmatically make sense to modify it to to keep the data safe so that's fine but i think clients would cope with that so it makes sense to me okay thank you so let's move on uh since last itef meeting it would be actually good to try to wrap up because we're now over time okay okay i will be quick so this last item meeting blush has read some comments to help improve the document and thanks blush very much for your review and based on that the following updates have been met change the system behavior to of modify"
  },
  {
    "startTime": "01:34:02",
    "text": "running from must now to show note if the result system parameter is not given by the client i think i have we have already discussed it just now and then define a a rest com comparability ui for reload system rescoff query parameter so since we updated the rescoff protocol to support a new result system parameter for post and put method and this capability can be used for a rest conf client to discover if a rascal server has implemented the reload system parameter and we also augmented the copy config rpc operation to support resolve to support without system as input parameter since we only extend the edit config and edit data operations to support this parameter in previous versions and we think that copy config could also be useful when you copy the configuration from an offline value to running data store and the parameter may be needed to allow the server to copy reference system configuration into running automatically to keep running valid then we have already we have also made several editorial changes to for clarification and explanation uh which includes that a more clear definition of system configuration states that system configuration is created in system and appears intended applied system configuration also appears in operational with origin equal to system make it clear that system must always be valid and make it clear that any updating system will not will not cause the automatic update of running even if some of the system configuration has already be copied into running explicitly or automatically before the update and finally finally that we clarified the"
  },
  {
    "startTime": "01:36:01",
    "text": "relationship between read-only two clients and overriding system configuration which seems contradictory at first glance when we said that with only two clients it referred to the contents of system data store the client is not allowed to modify directly but the client may overwrite a system defined data by writing the intended configuration into running so read-only and or writing system configuration they look conflicting but they are different so and this is the last real content slide so then or isaiah okay so a question to the group i should have given you a little more warning um but we would like to know if you are interested in the working group continuing to discuss this so um we're gonna hold for just a moment we have 37 people hopefully we can get um little bit more of participation so the way this is trending it's clear the group is interested in your work so we look forward to seeing the next revision of the uh document and to uh for you to continue discussing it on the list as you have been so uh thank you very much and you have another slot now and maybe if you can eight minutes okay so then this is about the young extension and metadata annotation for invisible flag and [Music]"
  },
  {
    "startTime": "01:38:00",
    "text": "we have blush drawing this work since last itef meeting so this slide is about the use cases that promoted this draft i tried to use some diagrams to clarify and hopefully they can help there are two examples the first one which is shown on left side of the slide and interface data tree the root is the container node interfaces and its child which is an interface list node exists in two interface entries inside each one we have the name as the keynote interface type and mtu value we can see these two interfaces as the system defined ones when the device is powered on and the related hardware is present and a client may try to edit some of the system predefined values for example a client may want to change the interface type ethernet into tunnel with an edit config operation for example or try to modify the mtu value but if a client trying to set the type of interface t e 0 0 other than the predefined ones which does not match the real type of the interface so will reject that request while the configuration such as mtu created by the system is free to be modified by the client so for this example interface type is immutable and independent of how it is instantiated the immutability is uniform inside different interface instances so while in the right diagram the case is different let's say that we have applications module to define some application layer protocols and in this case the application is defined as a list which is a child node of applications and within the application list there is a protocol name which is at the key and the underline transport protocol tcp"
  },
  {
    "startTime": "01:40:01",
    "text": "or udp and the port number and for the convenience of the users the system predefines a number of common applications much more than just ssh and the tftp shown in the diagram and those predefined ones are read only and cannot be modified or deleted if the predefined ones do not meet the requirements of the client the client can define their custom applications for example ssh application with tcp and 22 000 as the ss report and modification or deletion to the custom application instance is allowed but the predefined ones are read only both system defined and user config applications can be further applied in security policies for application access control so in this case application list can exist in multiple instances but some of them are immutable while others are not so there are two different kinds of use cases of immutable flag here i'm using system configuration as examples but to remember that the immutable concept can be used outside of system configuration so to be more specific we agree that it is already the case today that a server can reject any configuration for any reason for example when a client is trying to modify an immutable configuration but this work tries to provide more visibility to the client as to which nodes are immutable i think the client can benefit from such a standard behavior a standard mechanism up to which allows it to see what configuration is immutable on devices so the preferred solution consists of two parts both an immutable young"
  },
  {
    "startTime": "01:42:02",
    "text": "extension and method notation and for young extension we allow an argument to named exceptions defined to indicate specific operations are permitted for example if a create exception is declared for a particular data node it means that the client is allowed to create the instance of that node but modification and deletion is not allowed and for mandatory annotation it's used to indicate that when a particular instantiated data node is created the client cannot update or delete it and this annotation is only applied to the list of leave list entries or instances inside the particular list entries and currently it is defined as a boolean type but if we can agree with this solution we may discuss later if a simple trial force is enough so since the immutability can be applied to a node both in the schematic and in the data tree we make a statement that the server should not return annotation if a particular node is already marked marked as immutable by young extension without exceptions for update or delete operations because that means the update audited any instance of the data node is not allowed so there is no need to annotate the instance repeatedly there that will provide no additional information so any comments on this anthony hi and some set liquid um immutable by its very name means you cannot modify update or delete and i just noted there that you're saying exceptions to specific operations and then you've given examples of create update and delete i think we might just need to clarify that if we're talking about things like sub-objects which we may be able to create but the parent cannot be touched"
  },
  {
    "startTime": "01:44:01",
    "text": "um because otherwise exception suggests that the object is not immutable okay so flash you do you want to say something yes i think this might be a misunderstanding because this immutable with extension with exceptions means that you can create it but you can't delete it for example or you or you can say that you can create it or modify it but not delete it so maybe the immutable is not the best name that we can agree on that and any suggestions are welcome but okay yeah but we can call it float okay and bellage you just gave a uh example where there were um two exceptions and it's not clear in the draft how you support that but i'm glad to hear it does as a participant i'm really conflicted with this work because um i don't like the fact that you're sort of potentially stopping clients from modifying or controlling the configuration which is something that they own but at the same time i can also understand that if servers are doing this and going to reject it anyway then it's just adding extra information to make it easier for them to do it so i'm my conflict is are we going to then encourage more server implementations to then choose not to do this or have more restrictions and make it hard for clients to manage another way of thinking about this though is about putting the conf of what's modifying the running configuration that a client has control over versus what's in like um system configuration so even you delete it from the running config you're saying well it's going to still be there in system and that's another way of thinking about it so that could be another way of phrasing it and the last point i want to make is um"
  },
  {
    "startTime": "01:46:00",
    "text": "a game in like in interfaces and things be very clear about the fact that you can delete the interface and its type but you just can't delete the type itself once that's been set you can't change the type so maybe the draft is clear on that point but i'm not with the latest version while we hear the next question there is a poll going on same question as the last time are you interested in us continuing why this could encourage uh bad behavior i rather see this draft as documenting what people are actually doing and in some cases this is reasonable and existing behavior there is running code actually implementing this in a major implementation there are other standard bodies who prescribe this kind of behavior so better tell than just do it in plain english text joe clark cisco um i think rob touched on the thing that i was concerned about looking through this and that is i see a lot of language the server must reject the server must reject and i was going to get up here and say well if this is an extension and certain yang clients can ignore it and you also mention snmp and other non-yang related things it's really not must reject okay they will reject but they would have rejected anyway and i think that is probably worth calling out more explicitly in the text to indicate that this is like palace you just said more of a documentation more of a clarification than a by nature of this extension is the server is enforcing this the server would already enforce this and and that wasn't clear to me in reading the draft okay thanks yeah so we we are actually at the end of our time uh chiffon uh so i think the"
  },
  {
    "startTime": "01:48:00",
    "text": "you know the the takeaway that i see from this poll is that there's still interest in hearing more and i think your plan was just to do another update and then discuss on the list is that correct yeah yeah so since we still have an open issue so i will ship that into the mailing list i know i'm running off time so just put this open show to the mailing list yeah thank you i do appreciate it and it's clearly work that the group is interested in so that's it's really good to see the contribution thank you um i actually got rid of the poll i don't know why it's still showing yet oh there we go thank you whoever maybe can't fix that um in the in the last 10 minutes we had uh two topics we were going to try to hit one of them is uh yang next and the other one is uh from rad uh kent rather than having a a large discussion on yangnex do you want to just summarize sort of where we are and what the what our discussion has been in our thinking yes absolutely thanks um so uh on monday the net conf working group um you know had a chair-led discussion at the very end uh prompted by uh a.d rob wilton on uh you know whether or not netconf should know what we should do about the rest conf next and and netconf next uh issue trackers and one of the things that was mentioned is that in netmod there's also the yang next issue tracker and that any update to yang would necessitate updates to netcomp and rescoff well anyway the takeaway um is that you know the the netcomfort group is going to do what it can uh to uh you know make updates to the protocols without requiring um you know updates to yang but then here"
  },
  {
    "startTime": "01:50:01",
    "text": "in this working group what to do uh there is it was mentioned this has been discussed before i think actually initially we started talking about yang next uh gosh four years ago it seems and then we touched on it again not too long ago perhaps it was a year ago and the takeaway uh is that it's intrusive and we're unsure if the market will accept an update at this time um but at the same time we we see that you know it's getting old and at the edges and we might a refresh it seems eminent uh or looming um and uh but one thing also is that it was noted any update to yang needs to or i should say let me be more specific any update to rc 7950 would necessitate first a refactoring or factoring out of all the netconf and xml bits that are in 7950 to basically make it a a protocol independent uh specification not tied to netconf and uh so um that you know some of the discussion that's been going on with the chairs and the ad is that the netmod working group should proceed with a 7950 biz that does not change the yang version it would still be yang 1.1 but it would you know basically remove all the netcoff and xml specific bits from it and that would lay the groundwork for then uh the the serious gang next updates to come in and and um and you know for those non-compatible changes that that were that we need we know are coming but um you know we're we need to do this first part first so that's the current plan or thinking and uh just wondering from the room if"
  },
  {
    "startTime": "01:52:00",
    "text": "there's any agreement to that and also if there's any interest in working on that certainly if anyone's interested in working on that you know please approach the chairs thank you so i think the best way to do this is if you have a any specific thoughts or objections to a basically editorial revision of the rfc that splits out the language portion from the net comp portion if you have any thoughts or objections on that now would be a good time to hear it i'm not seeing any so the last question on that topic is if you are willing to work on it please contact the chairs or even better submit a individual draft on it and help us get started thank you rob um so i actually think that martin might already have some starting textures we need to we should sync up with him as well so that might help but i don't know um so this is um five minutes just to um talk about i gave a presentation to the icg at the retreat about how we manage uh young worlds in the itf and i had some proposals there about how we potentially try and do things a bit differently and they were quite positive of trying to do things with it differently and said well off you go go and take it to net mode and see what they say so i don't think we've got time to get some many answers here but hopefully um i'll open up what the issue is and the ideas and we can maybe start and and see if there's people interested in trying to go down this path so today uh the itef's really slow the publishing model so we sort of know that that's fine and we work on lots of different young stuff so we go to the next slide i don't think in this audience we need to say much um and the goal of what we're trying to produce here is not individual yaml to individual protocols we're trying to develop a cohesive um api between the management client and the device for for managing it so although we definitely separate animals really what matters is do these things work together and solve all the problems and things and"
  },
  {
    "startTime": "01:54:00",
    "text": "implement all the functionality you need and we're doing some work in there to help with young packages to bring these things together but still in the itf we have this goal as does open config for doing cohesive api next slide please uh we've got some problems though so um we're not very focused in the itef of doing this cohesive api the way we split it out into different working groups we paralyzed that in terms of getting the yam models done but we don't have the sort of focus on one api that the open config had um some of the rfc 7950 update rules make it hard to fix them we're working on versioning things to help that um but the itef is way way too slow i mean maybe it's massively too slow here and open conflict is getting more traction in the market and if you want itf to remain relevant in terms of the young models that it's producing we need to change and finally the fractured market i don't think is good i don't think that's helping young adoption i think that's making it harder for operators to choose which path to go next slide please and open config they have problems as well because they turn to they turn very frequently um they in terms of their participation it's not so open even though it's named open config and the models and the design of them are less technically flexible um so they have issues they're not perfect time it's not like we can just say take open config and we're done so next slide please uh next slide i can skip that because that's fine uh what's all the remaining property to deal with so this issue about the itf not being focused on a cohesive management api that's something we definitely need to fix i think the yang packages work i hope will will help with that and start with that because we'll be defining sets of young models that work together uh and hopefully finding some of the gaps and fixing those so that's one thing we're already fixing the 7950 rules to allow you to version upgrade stuff um but some of them but the key one is this itef being slow to standardize so next slide please so the idea is to fundamentally change how we manage young models in the itf and the idea is to stop publishing them in rfcs and instead"
  },
  {
    "startTime": "01:56:00",
    "text": "start putting young models in github and version the young models themselves in github as standard code assets and so that raises lots of interesting questions and this is not a trivial easy change to make because the itf process is all about publishing rfc documents and things but these aren't documents these are code assets and we should be treating them as such um so the idea therefore is we still need some rfcs to sort of support the young models that provide the sort of descriptive text you get today that describe the model behavior and things like that so that's all useful that's all great that stuff shouldn't necessarily have to change at all if you're putting in a minor bug fix and the example that came up recently in the netmod one is the fact that the ipaddress type that we use either the the definition of address type is wrong or we've got 50 rfcs that's using it wrong and we need to fix those and i look at publishing or republishing 50 rfcs and go ah i don't do that because the amount of work for it to go through the g makes that not like a pleasant idea so so this is the idea um is to try and do this um and hopefully try and involve this a bit more i think the next slide has a few more details and this isn't a massively thought out i don't have all the answers and really what the picture here is to get a fifth of the room is yes should we be heading in this direction and uh and is there somebody who's willing to help write some drafts here experimental drafts to actually test the waters and get people to review this and comment on and there'll be a lot of feedback and there'll be pushback in various places and things but we've got an opportunity to try and do this and make it better some ideas here is you effectively have some level of stable branches and you can put in bug fixes and things and you'd have some level of reviews for minor changes that happen within the working group and just keep them there like a working group last call and say look this looks good this is done and then every maybe a few years you might then if it's very stable um publish an updated version say we're good or if you're making major version changes then you'd have to go through like a full idf last call review so it's trying to get a balance between stuff that the"
  },
  {
    "startTime": "01:58:00",
    "text": "smaller group of people can agree that these are right versus ones that actually really need a benefit from a wider itif review so so that's my quick pitch and comment um that's reasonably yeah sensitive clarifying questions by continuing this are you thinking heading towards an experiment and running a process experiment i think yeah i think so i think i think that's what would be helpful is i'd like somebody to help write an experimental process process experiment rfc to say if you want to try and do this because i think we need to write down what it is how it's going to work what the rules are on things and then try and test it and see and refine it and be able to take that out and i think we would have the support i'll have to check the isg of running experiments so we're going to do this and maybe that's a good way of of testing the water without upsetting too many people straight away how fast do you think you can do this if if i can get some help writing some of the text i think again reasonably fast if i'm stuck with me writing the document given how quickly i've progressed the two young models with me and my workload that's the tricky thing but this i think this really matters so this is important and we have to do this so i chair a different group and in that group we have a really small document change and me as co-chair want to move faster than the authors which is weird but um i would love to tie together that draft and that module with this process and get those authors to help you out and let's let's run it fast i mean it there's it's it's like adding two identities to a module this should be a no-brainer it should be take you know 10 minutes but we're going to take 10 months instead so if if there's somebody is anyone here in the room they're not in there they're not in the room they presented the last time but uh we can get them okay by the way it's italo we talked about this at the last meeting bernoullis actually i support the id"
  },
  {
    "startTime": "02:00:01",
    "text": "and how fast could it be the young catalog was done actually with that exact id in mind that if the itf was not fast enough we just forget about that there is a block there with the paper from 2015 which says disrupt the itf uh process so if we just post the the the young module in the catalog and they arrive by default there what do we need kind of funds up this is the version that people are using or not and this is the process is actually easy we've got everything in place to do that so i just heard a co-author volunteering thank you benoit did i miss that kanta's chair uh one person did not raise their hand or rather they raised their hand saying that they would not uh they would not like to see this work proceed i'm just wondering if that individual would be willing to speak as to why they did not raise their hand you might have to unlock the queue i'll do that well i guess i didn't feel that strongly so uh thanks for those two uh lightning talks and uh uh we are out now at the end of our session appreciate all the really good contribution in the room online and on the list and look forward to seeing you in all all those places but hopefully in person at the next meeting thank you all"
  },
  {
    "startTime": "02:02:03",
    "text": "right"
  }
]
