[
  {
    "startTime": "00:00:05",
    "text": "okay i just passed you the control oh that's true so in the room we are seeing the slides but with a dialogue in front um sorry is there meat echo in chat here should be right there i don't see them yet a window wanted left okay it was highlighted presentation views okay it's all correct no just local speakers no let you try unsharing the slides and reassure them and see what happens still there though somebody has a pull up so maybe we can"
  },
  {
    "startTime": "00:02:00",
    "text": "try canceling the pole just give us a couple of minutes to resolve this there's a pole window i believe open which is causing to overlay on the slide deck see that's the one yeah whatever you just did what was what would you do yeah i just killed the poll okay i think that fixed it so kent i'm going to pass the presentation ball back to you all right with those few glitches away uh this is the net count working group um meeting in itf 114 next slide please okay that's a note well most of you are familiar with it if you're not do take some time to go through it anything you speak or discuss in within the halls of this meeting are part of the itf contributions next slide um so a couple of additions or changes so we of course"
  },
  {
    "startTime": "00:04:00",
    "text": "have the meat echo session uh you're here you know that uh you should be logged into the meat echo session whether in person like the version that you're probably running if you're in the room or if you're remote then you have a full version with the house icon the meet echo session will also act as a virtual blue sheet so if you're logged in it will record you as an attendee to the session there is a chat window i think for the first time we are introducing zulip so uh monitor some of the chats on that session jabber comments of course will be reflected within the zoolop session we have a two-hour slot um and we have not a completely packed agenda so we'll probably be a little flexible with time but we'll try to use the timer if necessary the queue will be managed by a meat echo so whether you're in the room or remote do try to line up in in the queue session before you speak so to queue up use the icon with the hand symbol on the um and then to speak make sure that you have hit the play button this is for the remote audience and of course remember to remove yourself from the queue once you're done talking there is a note session which i believe the agenda has been pre-loaded"
  },
  {
    "startTime": "00:06:01",
    "text": "we welcome your comments our contributions to that notes page so may please add that add your notes or your comments to that page you can right click to make it a separate window if need be next slide please all right so the status of this charted workgroup items the https node updraft and the shepherd has written up um on the document thanks microphone the we publish dash 11 and they should be a dash 12 soon that we will publish that should address the comments we received in the shepherds write-up the client-server suite of drafts all the working group last comments issues were resolved and at this time the documents are ready for write-up which is something we i'll be working on we are of course looking for volunteers to help in writing there are a total of nine documents and if anyone is willing and wants to do a shepherd dried up please do approach me the udp native draft is work in progress will be discussed in this meeting and so will the distributed node draft the adaptive subscription draft was adopted as an experimental draft so it's been marked in as work in progress but is not being discussed in this meeting"
  },
  {
    "startTime": "00:08:00",
    "text": "next slide please all right uh so on the agenda under chartered items we have uh alex who's going to discuss both the udp and the distributed native draft and then we have chin who who will talk about the newly adapt adopted this pagination terms next slide please under non-chartered items we have continuation of the discussion on the transaction id and will present that and then we have a new draft in the form of net conformer quick and as that will be followed by sean turner who will give an update on netconf over tls 1.3 and for the remaining time we will have a discussion around netconf and rescon next so any questions concerns anything you want to raise at this point all right nothing in the room and i don't see anyone in the queue so maybe we can switch to the first slide deck and alex um sorry do you listen to me no okay"
  },
  {
    "startTime": "00:10:15",
    "text": "thank you hello um hello to everyone uh this is alex juan from insalion and on behalf of the authors i'll be presenting a little update on the udp native draft so next slide please on the agenda today i will present a little context on on this draft the two changes the two draft we did to address the last itf comments and the plan changes for the upcoming versions of this draft so next slide please um so udp notif is um is a udp based transport protocol for young push the notification message is outside of the scope of this draft and uh for that we propose a shim header to uh send uh information directly from the line card without impacting the router the performance of the router next slide please so this protocol is designed to be deployed on on secure networks but for unsecured networks a dtls layer is proposed on section 6. next slide please and on the last day etf 113 we"
  },
  {
    "startTime": "00:12:00",
    "text": "we received two comments from the working group chairs uh thank you very much for that the first one is that uh how can we configure this uh dtls layer for for this transport protocol and the second one that uh it should be [Music] it would be better to add some examples of these configurations uh files for netconf next slide please uh to address that uh between the 5 and the 06 globally we updated the biggest changes the young model and the young module to address the first request so what we see here is that we added a new flag to enable the tls or disable it and then the dtls container to set up the dtls layer parameters this dtls container imports actually the the tls client server draft grouping and right now we we do believe that we have everything we need to to configure it but uh we're still waiting for the implementation to check uh to check that nexus light please also reviewing the the young module we added two missed features one for dtls and one for segmentation we renamed also the the global grouping name to udp receiver grouping and made the port mandatory since there"
  },
  {
    "startTime": "00:14:00",
    "text": "is no default jana port anymore next slide please we did some rephrasing on the max segment size uh leaf uh to include the options octets on on this uh on this lift and then lastly the the flag uh for enabling the ttls layer and the container with the dtls parameters next slide this uh we had one last request that it is to update the shim header version to allow at the collector uh receive different versions of udpnotif the one uh before it became a working group document and the current one so we addressed that by updating it next slide please and then uh since we haven't still checked on this yam module we did not address yet the examples but it's planned on our timeline to implement these examples and test it before put it on the draft um next slide please so yes that's it for the udp native and if you had any questions we the feedback is welcome just go ahead and yes um"
  },
  {
    "startTime": "00:16:01",
    "text": "on slide eight you showed enable dtls boolean flag and then immediately underneath it the container can for the details configuration i think uh better would be to put make the container be a presence container and remove the enable dtls boolean leaf so okay so putting the leaf inside the a dtls container what you are asking right and no not not putting the leaf inside uh removing the leaf and instead making the container be a presence container so you add a descendant of note called presence ah okay okay okay let's see okay bin well hello alex so i'm born with less so i was tweeting your slide about secure networks and then i was reading your security consideration and just editorially uh you could be adding a reference to an rfc that i like which is about limited domains and internet protocols this rfc 8799 i'll be sending an email that explains why we need to make a distinction between something which is a control domain and something which is over the wild okay we will do that all right uh just one more uh so rob wilson cisco so just a quick question on the version change could you just explain again why that's being done so when you want this to go to rfc is the intention that you ship it with version one or you go back to version zero but i didn't quite know"
  },
  {
    "startTime": "00:18:01",
    "text": "what we would like is to the rfc version would be the last the last version on the draft actually so it's to to allow the collector to collect the others versions of this already implemented draft okay um so is this an i am managed registry for these version numbers how's that managed right now i believe it's only on on the draft there is no jana on there but uh so i think it would be helpful to add a section on a consideration section there isn't one that says that that there'll be registry set up to manage those version numbers if you said if you can have a version that's shipped or effectively deployed already that's reserved i think that would be pretty quite helpful okay okay i guess we can move to distributed nordic yeah so also on behalf of the authors just a quick update on the last draft they published the next slide there's one only um so [Music] it hasn't any change on this draft actually and there are some corrected needs on the last version and the authors they believe that it is already really stable but that since the only reference to this draft is udp native they would like to wait for the udp native to be last core before thus calling this one"
  },
  {
    "startTime": "00:20:00",
    "text": "and that would be it right um speaking as a contributor did you get and probably this applies more to your previous draft actually so did you get a chance to discuss with sean turner on yeah the dtls container for udp notif um not yet he and we will do that uh during the week of the ietf okay following that question would be considering that this is a security feature i guess we need to send the draft for a sector review so could you let us know when the document is ready for a sector review okay i will do that all right thanks alex um okay yeah good morning everyone yeah my name is good morning this is chinwu i want to talk about this pagination magazine for netcop and resconf so here we have three relevant jobs has just been adopted uh actually the name we listed here at"
  },
  {
    "startTime": "00:22:00",
    "text": "uh the also this job that we actually from the design team so this is another thought that was in this job so i just want to pay so the update what we are doing what is this job about next so first motivation and goal actually what we propose is this pagination mechanism so traditional we use uh nano uh transitional user uh net net call for protocol like uh operation like uh get or get configured to do the data retriever but when you're facing large amount of uh data retriever actually especially applied to the list or leave list for from server side you may take a a long time to send this kind of data and when the interface between the uh for example net client and then not medical server uh they have a bandwidth uh constraint or results concentrated so this kind of latency you feel by the client will be even worse so from the client side actually they may need to consume more uh uh resource to uh to integrate this kind of data so uh our idea is you know uh to borrow some concept from uh circu s statement when you use to query some database so you can actually uh integrate the back-end system in in a server so you can use some kind of index mechanism to faster locate the data so this is the motivation for this worker try to you know quickly to query or locate the data using index magazine next so we have three relevant charts actually these three jobs actually"
  },
  {
    "startTime": "00:24:02",
    "text": "related to each other actually the first one is the list of pagination medicine try to provide a generic mechanism and this can provide you to do the filtering or to do the sorting and retriever actually is the most applied to this list or leave list and we also provide the nanocop protocol extension and the rest com product extension so this the other two actually use the the first genetic mechanism as a basis next so first i want to introduce this pagination mechanism drafter so in this job actually we uh define uh six query parameters so as we uh you know uh clarified actually we tried to borrow concept from the circu statements that are used in the you know database query actually if we download select where these kind of semantics actually we introduce similar schematics here for example where this you can see this as a selection filter it can help you to filter the your interested result set and sort by you can see this actually it's kind of index node actually you can use this index node to quickly you know locate the the uh results center set entries and also we have direction to give you you know uh when you do the search or get it without the bank you need to know what is the order it could be dissident order or accident order and offset actually it allow you not from the first entry actually you can skip a several entry start from there and"
  },
  {
    "startTime": "00:26:03",
    "text": "tell you uh how many entries you can return in addition actually we introduced separatist limit this kind of parameter these are actually you know different from the limited parameters actually they only apply to child list or child leave list so they can help you to return the number of entry in the child list or leave list so we also you know provide a server processing order the first you need to process aware and then you process sort by direction offset and limit and uh also we actually introduce metadata attribute and we call the remaining so the idea is you know these remaining parameters will use we together with uh the limit or seven uh sublist limit uh actually it will tell you when you do the query you uh you may need to know uh how many uh engines are left left in the result entry without set actually so remaining will tell you that this kind of information next so here we'll give the example uh as we uh present actually we have six current parameter we use a combination of these six parameters in a request response to guide how list and data list can be returned actually uh we have a job actually yeah this uh yeah the job that you you can see the appendix they have uh um example module so they will tell you the schema so in the left actually in the request that we actually uh we have we actually uh"
  },
  {
    "startTime": "00:28:02",
    "text": "you know focus on specific list that we call the member so the member is kind of is defined as the list actually it under the members container so we use where to do the selection filter and sort by you can see this uh you know as an index node so member id is the index node actually so we also set direction actually it's kind of dissident order and uh offset uh so you you know start from the second entry and then you uh uh the limit will tell you you know from the second entry you'll get a you know uh two two entries so start from second and s and three so this uh two entry so you can see this kind of example next so uh for remaining actually we as we have actually applied to the dissident list or leave list so we give example to compare you know when we use the remaining uh when you use a sublist limit or when you not use a sublist limit with a sublist limit setup onset actually you can see actually you can return the whole results actually it will return the the the total uh entry inner result set but uh when you set a sub limit uh parameter for example you set a submit parameter one actually you only return one entry but they also tell you for example you the total you have uh five entry and you return one entry the remaining one is four entry so it will so this remaining will tell you how many entries are left uh in the result set"
  },
  {
    "startTime": "00:30:01",
    "text": "next uh we also define the server list pagination constructed discovery this is the most actually only applied to the config force list or leave list since the inter action with their content may be limited so you can see actually we organ from the system capability module which has already the rfc and we introduced two parameters one is concentrate the second index the country that will tell you uh uh which uh config force node uh constraint actually uh index actually uh you know is uh uh used together with concentrate when you set a constraint and you can say well it will tell you which node can be used in the where or solved by the expression so here we give the example in addition for this uh uh construct discovery actually we allow more uh extensibility for concentrated parameter uh so you can add uh besides the concentrate and index two parameter we can introduce some other parameters so give some example for example you may be not supported 100 x pass 1.0 syntax so you can add some other parameter here yeah next so second job is a net call product extension next so in this job actually we uh provided two extensions the first is we augment the three and net club rpc statements uh state get and get config and get data and also we align with the list pagination chart for query parameter you can see all these query parameters"
  },
  {
    "startTime": "00:32:01",
    "text": "actually has been put here actually to try to align with this paginating maximum job next so we gave the example how it looked like when you use this pagination then called protocol extension so similar to uh like example in this pagination magazine draft actually you use a combination of all query parameters in a request and a response and you can uh you know to get the the the interesting entry you you really want to retrieve actually use this current parameter as some constraint or as some filter next so second job is the rascon protocol extension next so we introduce three protocol extensions the first one is that we add a list and leave list as a valid resource target for get actually most of these this pagination focus on you know uh data retriever you know focus on reader information but also we actually allow you know this can be applied to the delete operation so in the right way give example uh how to you know uh to delete the whole entry uh in the list using the delete operation the second we added new material type we call the application that slash dash data plus xml list last we added six new parameters similar to the net code vertical exchange in draft that's all next so here we give the status update of this job that we have three jobs actually so we can"
  },
  {
    "startTime": "00:34:00",
    "text": "see the history of this job we started from last year november actually in uh 100 herald we presented these three jobs uh actually on behalf of the design team and we uh actually introduced the motivation goal and also solution and also we designed him discussed found two open issue and so we brought up for discussion and later on after ita 110 we uh actually try to uh close these two open issues so raise the the discussion on the list one is focus on cursor support uh so this cursor related to the index uh and we come up with a solution the second one is a remaining annotation this also gets discussed on the list and we come up with solution and we get some feedback from winning neptune from pbf and we actually reach agreement on the the change what the solution looks like and uh uh also in uh february 10 uh in this year actually we confirm all the change actually and make sure we resolve these two open issue so the chair actually uh uh helped to initiate the covert option for this work so we got a quite a lot of review from andy chovang and and also actually there are two issues actually uh discussed one is related to the edit operation extension actually this is most you know applied to the delete operation so whether this should be in the scope so it would suggest actually say this can be addressed after working with uh adoption uh after working to adopt this job the second one is uh"
  },
  {
    "startTime": "00:36:00",
    "text": "uh really you know we uh the nanocop actually has a lot of uh uh workload actually client server so this so what i'm suggesting is uh you know push it back a little bit for adoption and before moving forward and getting client server uh progress actually now actually we see the client server job already you know uh adjust all the issues and uh so we so this job get adopted so that's our kernel status and uh we think that's all we have we are very actually look for more comments and review on this worker to help her to improve this work and next so comments questions hello my name is interesting and important work but i have a few comments one it is not required currently that the server keeps a stable order of sorting between times so directly every millisecond you could change the order of your list you should address this the second is that uh sorting is in some cases very complicated if you think about sorting alphabetically in some european languages the o with two dots is after the simple o sometimes it's after zed or how do you sort the of a string where some of the names are chinese with chinese characters some of them are europeans the third is"
  },
  {
    "startTime": "00:38:00",
    "text": "what how does this work if the expat filters resulted let's say two lists selected not one single list but two lists then yeah how does that work thank you yeah good comments actually yeah i think yeah we will uh try to come up with a solution here i think this is a very good uh comments actually we have the base base work actually but uh the the use case you raised actually you have two lists that is complicated we need to figure out how to address this yeah yeah thank you for the comments so before john uh you come on this mike i just want to a quick reminder do contribute to the notes and the meeting page especially if you're asking a question to help improve the notes continue thanks i'm john o'brien uh thanks for doing this work a couple of minor comments on the choice of keywords i would suggest preferring uh keywords that are already going to be familiar to implementers and operators specifically instead of sort by i would suggest order by and for the direction i would suggest defaulting to ascending and descending and i admit that i have mixed feelings about having alternate keywords that mean the same thing yeah thank you for raising comments actually in the design team we actually back force to discuss the water termination terminology will be appropriate actually we do use you know autobio before and also and for direction actually used as a dissident but some uh design team member actually i remember remember correctly is per actually he suggests we use some other terminology but i think it's a good comment so we will see how do you you know reach agreement on this thank you"
  },
  {
    "startTime": "00:40:03",
    "text": "uh robertson cisco is a contributor um so one thing i want to understand is the sort of performance impacts of this where you do like a filter and then a sort and then you return a subset of the data then when you get a subsequent request is the server going to maintain any state for that or will they have to effectively re refill to resort to get the next batch of um data to return because certain had a large list that could be quite expensive to do that calculation many times yeah so is that i don't know i haven't read the draft close enough to know that's a potential issue or not and again i don't really know the databases where their cursor mechanism whether they affect their cursors maintain that state to avoid that issue but i don't know yeah we are struggling whether we should define this as a stable stable mechanism so i think yeah we can think about that and see whether we need to cover this kind of case uh how you address this uh yeah thank you tall people jeff has um so balaj and rob have both hit two of the points that i've talked about which is the stability of the stored orders especially if you're using an offset as you know the next entry you know if the entries are constantly changing that offset becomes meaningless the second time you come around to your you know display this thing the usual workaround for this sort of problem is that you keep track of the last key displayed and as long as you have a stable sort order show me the entries that are after this as my cursor is the thing that generically works in most mechanisms so you may wish to consider that somewhat towards rob's point a way to maybe choose to think about this is rather than having the queries run over and over again an option not a mandatory one that you"
  },
  {
    "startTime": "00:42:00",
    "text": "should consider is the ability to request a stable snapshot to be taken for the data in question so and then you pass in some sort of identifier to resume a specific walk on a specific set of data this way you can actually do the work once maybe save it to a file temporarily and you can resume your snapshot within that file now the problem that you have with that is sometimes the data set is so large or there's not enough persistent storage available to do this sort of thing so it can't be a mandatory thing yeah good comments yes thank you we'll consider that okay yeah we don't have anybody else in the queue so continue the discussion on the mailing list thank you so with that i think we can move to the non-chartered items all right go ahead yen good morning so we can flip to the next page so i just wanted to give a brief update about this netcom transaction id work that's been going on here basically there are two additions since last technical editions one is about last modified transaction id mechanism something that we used to have in the in the draft works before i published it that i removed in the end but now it's i've added it back because of popular demand and also some integration with yang push so that uh yang pushed together with transaction db both become better and i will go through those two points"
  },
  {
    "startTime": "00:44:00",
    "text": "on slides a little bit but we can go to the next slide first so most of the work in the o2 rev of this document has been to clarify and extend the text to be more clear about the concepts here so i made a few changes of terms i've added more clarification about the candidate data store we have discussed or introduced better diagrams for the message flow and improved the examples we've changed from itf interfaces to active access control as an example because some people found itf interface to be confusing in this context uh provided a more specific list about x paths to the places where these additional attributes can be found and can be added just to make it easier and clearer next slide please so if you remember i will just very briefly touch on what this transaction id is about uh it's let's say one of the problems that we're trying to solve here is that when the client is getting the configuration from the server sometimes it wants to get the full configuration but sometimes it only wants to know if things have changed or not so it would be convenient if we don't have to get the config and get it again and see then try to compare and see is this the same now or has things changed somewhere and that could be done with the transaction id next slide another problem especially related to young push is that if a client is pushing something to a server that it's interested in and it might also be subscribing to young push notifications it will hear updates of the same things it's just sent there in the config so it would be sort of echo and it would be nice to be able to"
  },
  {
    "startTime": "00:46:00",
    "text": "cancel those day because we don't want to process and treat all these updates and there's also currently quite hard to know if you get if i send an edit config to the server and get the yank push communication back it's hard to know if this is indeed the same as i just sent or if it is some other client that did something that resembles my change but it's not exactly the same thing so with the transaction id this will help too next slide please and the third thing is that it's sometimes important for clients to be able to make changes and be guaranteed that nothing else has changed in between since last time it's of course possible to take a lock but that is not very that's a cooperative in an environment where there are many clients that one client would take a lock for extended periods of time to prevent others from making changes is kind of not nice so we don't want to prevent others from making changes but we want to know when other other clients are making changes and transaction id can help with that too next slide please so i would then dive i mean this is a the overall high level description but now i will dive down into the one detail which is this last modifier transaction id mechanism to show how that compares to the previous etag solution next slide please so here you can see on the left oh colors went away that was pretty but okay you can see here on the left you have a particular particular get config message reply where you can see that last modified attributes are in there if you look closely the colors went away now so it's kind of hard to see but it says txid colon last modified and some date stamp"
  },
  {
    "startTime": "00:48:02",
    "text": "on several places in this content uh so that is and then you can compare on with the right side where you can see how it was in the previous uh over the other mechanisms with the transaction ide tag it's basically a similar attribute txid colon etag with a sort of random string or identifying string of the change so the only thing that is really the difference between txid last modified and txide tag is that now we have a time stamp instead of some other string but other than that it looks much the same next slide please one detail though is that in rest conf there is already a sort of last modified mechanism but that rest conf that is by rc8040 the rest conf specification itself has this built in already but the timestamp format in there is based on the date and a time with no we just second one second resolution so in the proposal i wrote here i reused the same format for rest conf which is without fractional seconds that's uh that's nice in a way because it aligns well with the the rest of rest conf but it's not so good because it's quite conceivable that you can have more than one edit config change within the same second and then this becomes ambiguous so i'm on the fence here how we should do this should we keep using this existing restconf date stamp format or should we add fractional seconds in the document the drev2 document here now it is the same as in rest conf but i'm not sure i'm not convinced that it's that's the best choice i'm not sure actually i would like to ask the room we"
  },
  {
    "startTime": "00:50:00",
    "text": "can do that after the presentation here but what's your opinion about this should we keep this low resolution and be aligned with rest conf or should we do it with a higher resolution just like we do for netconf here next slide please and the other detail i want to show now is this integration with giant push just to show you very simply what that looks like it actually is quite simple so next slide please so here colors went away i don't know exactly what happened with them but on the bottom you can see on the left side here under push subscribe you see near the bottom itf netconf transaction id yp with etag true that is how a yang push user would enable transaction ids for young pushes for this particular subscription so it's just a simple leave that is added to the subscription to to get this functionality and on the right side in the updates you can see right around middle you can see yang patch patch id 0 edit and then it says transaction id called an e tag and then it gives a particular name for this update and that is how transaction ids would be integrated with yang push so it's a very unintrusive small amount of additional data that goes in there to enables us to identify all the changes where they're coming from and that we already have this information in the client and so on that was basically all i had but i'm happy to answer any questions or comments and in particular if people have opinions about the resolutions and time stamps for the last modified thing i'd be interested to hear okay rob"
  },
  {
    "startTime": "00:52:01",
    "text": "robertson cisco's contributor um so in terms of resolution the timestamps one thing i wanted to understand is if you have a fractional timestamp are you expecting every request to have a unique value so you you wanted to guarantee uniqueness on that that's right okay a client that is asking for uh for for a transaction id would like to be able to compare that with previous ids that it has is this the same or not and with the one second resolution there's potentially a risk that some things have changed but it still has the same time stamp but erickson i think without some allowing that two transactions in the same second have the same transaction id according to the last modified that's not acceptable this makes this woman is unreliable defeats its purpose so either you have to do something there one is to have a detailed timestamp and having the order of the transactions that's also a nice feature yes but in the rest conf i think some of this functionality is already defined by rfc 8040 like how you can retrieve information that is new since a particular timestamp and that is not something that this particular draft that i'm working on here can change so i think even if we yeah i'm not sure how useful this feature would be in rest conf if you need that's high resolution john hi john o'brien university of pennsylvania um i have some uh sort of poorly formed or incompletely formed um questions having to do with um"
  },
  {
    "startTime": "00:54:01",
    "text": "kind of what i already know from you know sequence numbers in dns which seem relevant to this use case and things like um boot time in snmp which also seems relevant especially when we're talking about using a time stamp to determine whether something has changed and the device for managing and the manager might not have good knowledge of uh whether the managed device has good time or whether the the time its idea of time has changed since the last time we asked it are those considerations that you feel like are have been addressed by this draft yes the reason i did not include some sort of timestamp in the original version was concerns of this kind i think time is a complicated concept but i i understand yeah i agreed to add it but then i only define one operation on these timestamps and that's equality there's no other operation that is valid thanks good good um i'm so i'm thinking uh the timestamps are maybe it's okay to use second level resolution and for clients where it matters they shouldn't use less modified instead they just use the etag um and that's that's what they do and also i mean keep in mind that we're i mean for things that are sub second resolution we're talking about configuration database mostly um you know the updates that you know the the optimistic locking uh so it's both configuration and configuration changing at sub second resolution can happen in some scenarios but um it's probably uh not as common of a use case so i think last modified has value for common use"
  },
  {
    "startTime": "00:56:01",
    "text": "cases and for those extreme use cases they probably shouldn't use glass modified yes i tend to agree for for some use cases it may be convenient to have a small and simple mechanism rest conf is geared towards those kind of not not so complicated use cases in many in many environments so maybe there it has the value but i agree e tags should be used when things are need to be strictly correct all the time uh robles and cisco it's the other any other thought just in terms of what john was mentioning is would it make sense to have like a logical timestamp here so a counter rather than a timestamp so something that's guaranteed to increment every time a configuration request comes in a sequence number or something that would then guarantee that these are unique and ordered if that was helpful uh we have the e-tag mechanism which i think is a more robust and secure mechanism for doing this sort of thing and the the reason that we added timestamp is because in rest conf there is already in rc 80 40 there's like half of this mechanism is already defined there so we just added what was missing with the transaction timestamp so then it becomes a complete mechanism but i i agree that time may not be the best way of keeping track of when things have changed or not so i think if you are concerned about keeping perfect track of this you should use the e-tag mechanism instead which is a mandatory opera mandatory mechanism time stamp mechanism is only optional okay so it might be helpful if the draft was clear that the or the problems of doing the comparison of timestamps and and basically just give some advice as to what not to use them for and push especially towards the etag if that's text isn't already in there yeah i tried to specify quite clearly"
  },
  {
    "startTime": "00:58:00",
    "text": "that the only operation that is valid on these timestamps is equal testing for equality but maybe of course we can add more text about why that is but right um so i'm going to start a poll to say um oh sorry we have more okay hi uh charles eccles cisco sorry for the delay i wanted to let the stuff on the timestamp thing uh finish because i just had another question about um in the case of an uh two questions actually the first one was the draft talks about you know you send the the e-tag or whatever and if if there's been a relevant change the server uh wouldn't return you know would return some kind some type of error um rather than or you know the server does something different if there's a relevant change or a change that's um of interest to the client or something like that that there was the wording like left some wiggle room as opposed to saying if the e tags match you do this if they don't match you do this i was just wondering it was that just the way of describing it that left that wiggle room or is there actually more than two cases of match and not match uh it would be good if you could point out the section that was unclear to you so i can make sure that it's clear but in essence you're right the only thing that we want to match here is the transaction ids or the payload that the client sends down but it also is there is the case where there are let's say a when condition that is changing that that makes the server change the"
  },
  {
    "startTime": "01:00:00",
    "text": "configuration in an area that is not related to the particular edit config request i mean it's related to but it's not part of the edit config request and that is also included so that perhaps that is what i was trying to say okay all right um and then the other thing was in case the the server can't um according to these new rules or the rules on this draft in case the server can't make the change uh there could be a couple reasons one could be that it was like a the change that was being made just uh really didn't make sense so that data doesn't exist versus it's because of the e-tag and um i didn't know if the error that the client would receive does it distinguish between those cases or do both cases look the same to the client no there's a specific error message for that it's you can you can find it in the in the document there it's defined exactly what it should look like okay great thanks okay if there are no more comments uh jan i'm not sure if you're actually asking for work group adoption at this time i didn't see a slide i don't know how to do that but if you think the time is wrapped then uh please go ahead okay the time is right is what i want to say okay all right so uh having cleared the deck of a large number of documents from the working group maybe this would be a good time to ask the question do you consider this work useful and would you like to see this draft adopted as a work group item so i'm going to start a poll and have you answer to that on meet echo"
  },
  {
    "startTime": "01:02:29",
    "text": "okay so the trend seems to be fairly positive we will go ahead and send a formal notice on the mailing list to see if the workgroup wants to adopt the document is about group item thanks theon thank you sorry so i am okay and present for the authors because they cannot attend the meeting next page so for lighter conf we already know so this is all the slides i just thought so let the car already use uh somewhere for closer to the mic leatherconf already used security uh transfer protocols such as a simple object access protocol and the secure cell and the extensible to something"
  },
  {
    "startTime": "01:04:02",
    "text": "secure transfer protocols is utv-based because of this there are some shortcomings for example the head of nine blocking in the tcp so these sword comments can be overcome if we use quick as a secure transport protocols so in addition to overcome this shortcomings the the quick as a secure transport protocol have also some other advantages for example quick quick convection established is very quick and also quick the they have uh authentication and the encryption for the header and the payload and and so on so that's why we propose use quick as a transport secure protocol so here we just give some details about we about to use the quick as skill transfer protocols so here we just talk about the connection management first we have a draft version identification so basically this consists of a token such as noc which is sort for net conf over quick and then plus some numbers number one versus number two and so on when we want to set up a connection at first"
  },
  {
    "startTime": "01:06:00",
    "text": "we need a half of we need negotiate the first numbers so when both sides agreed or both sides support the common versions then we can stop we can continue so also both sides should also consider the transport protocol maybe the version is greater than 1.3 something so after this stage and then we can hook up try to build the connections so basically here the when nightcom connection is built over quick the light conf manager will be the uh the the client of a quicker and then netcaf agent will be server also the manager will initiate the connection so this basically about the connection of light conf over quick and then we consider the result shutdown the connections so in this case first we have a review the ways greek terminated their connections the three ways for quicker to terminate the connections one way is that the idle timeout is enabled in this case when idol timeout and then quick will shut down the connections so another way is that either side of the quicker then they just in the connection close so in this case the conversion where we're closed and the third way is that so something wrong happened we cannot access some state whatever and then we just slightly reset the connections that's the stereo three way the quick connection will determine it"
  },
  {
    "startTime": "01:08:00",
    "text": "so because netcam connection is over quick so we in this case we will disable the idle time out in the quicker so in this way in normal case the light connection were there forever and then we just uh when knight conf entity receive was in the closed session so in this case netconf entity will shut down the quick connections associated gracefully so in another case is that so when that conf entity receive or initiate the queue session when selection is open in open state and then this in this case the latch entity will also gracefully shut down the quick connections so the third case is that and then when that kind of connection detects something wrong in the quick or under and then we shut down the connections so that's the way more consideration about that curve over quick connection termination so next page so here we just uh we'll talk about some more details about those connections so in order to talk those more details and we just give a uh the protocol layer of light curve so basically this is described by the rfc for six two four one so let count layers we have four layers content layer operational layer mesh layer and skill transfer layers so here basically we just focus on the communications between the manager"
  },
  {
    "startTime": "01:10:02",
    "text": "and the uh agent so this connection uh or communication is rpc based and then we have two uh one one uh one type of connection communication is a bi-directional for example when when manager send the configuration to agent and then agent will after something and then an agent will send a notification to manager so this is a two-way communication or called bi-directional so another communication is we can classify as unidirectional for example when agent uh when we age in the front found something wrong whatever they just send the notification to the manager so in this case manager don't need to reply so this is the one directional or unidirectional so for these two types of conventional communications and then we can use the quickest stuff or my opinion those two types of communications to the quickest strains very easily to the next page so basically this gives more details about we have a two type of communicational strains one is bi-directional in medical so this bi-directional communication can easily map to a quick stream string string ids because in the string quick string id there's the last two bits and then those last two bits identify or indicate whether this this string is unidirectional or or bi-directional so we can directly my opinion there's light curve communication different type of communications to the quick streams identified by the last two bits of quick string ids so next page"
  },
  {
    "startTime": "01:12:00",
    "text": "so about authentications using a quick handshake so basically we just reuse some kind of procedures or whatever rules already defined for example for the server identity we just reuse those rules already defined in the uh four to four six four six four six uh four six four two in that one and then for the client side client identity is local policy determined and then we can also use third party authentication so let's look at details next page so these are basically this is the description or rules defined by rfc 4642 which is how we identify a server so basically so client must use the server name that the civil line is also used when we open the connections and the second rule and the third rule and this one don't need to go repeat this one because this one all this is already described in rfc 4642 so next page so if this uh proposal move forward and then we will need a some kind of uh ayana assignment so here one uh request is for the alpn uh registration this new registration will be just we"
  },
  {
    "startTime": "01:14:01",
    "text": "have a protocol and then maybe we'll just use an oc as a product id and then we just have this kind of a sequence there and then we also need a udp portal number because quicker is based on utp so next page so this is the first presentation so we would like just to collect uh all the feedbacks or comments from all of you but because i'm not an author i don't have those details and i would like you to send those questions to the to the least because i'm i don't because i haven't spent much time around this one i just put the time to digest this draft and then prevent the draft thank you so before we have the first speaker come up um are the authors in the room even if they're remote or virtual and please uh step up there and help the presenter and answering some of the questions go ahead thanks uh anthony somerset liquid um considering it's over quick and it's over udp and it's net conf i've got a few reservations because of you know udp is not like guaranteed reliable yes quick is better than playing udp but um the bit i wasn't seeing at least in the draft was how we would necessarily get that reliability of because of the conflict that we might be sending or receiving to ensure that it gets there um i haven't seen that and i think we would need to address that yeah i think that's a good question whether a creek can provide the same level of reliability as tcp i think we can do some search or research"
  },
  {
    "startTime": "01:16:00",
    "text": "i don't know whether the water i don't think a water is uh in the online right now but quickly the connection rented a protocol i think it should be reliable all right um so speaking as a contributor if in summary what i guess i'm gathering from your presentation or the presentation that you put forward is really the change is only the inner consideration page or the other protocol considerations that we need to think about yeah i think so because this one you see we already have a click there and then we just about how we use the light conf of quick is just how we reuse the quicker stuff i think it looks like a pretty straightforward pretty straightforward and then we just request some kind of code numbers there well so rob wilson cisco as a country uh i'd like to say thank you for presenting if you're not for the author of the draft and i thank the authors um for bringing this work to the working works i think is interesting and useful and i think certainly something that's worth thinking about um i can see potentially netconf over quick could have some useful benefits particularly in terms of the separate streams but i'm not quite sure whether uh the way that yang push is set up today whether you'd actually really see those benefits or not and in terms of the separate streams for separate rpc requests again i'd imagine today a client would just open up separate sessions and you could coalesce those together and avoid that but otherwise um often with the netconf request you'd expect"
  },
  {
    "startTime": "01:18:00",
    "text": "them to be serialized like an edit config request and then a get request you expect those to be processed in order and you might want to allow those to go in parallel but there's other considerations there which may mean that that's not the right thing to do and if you do need to do that having a separate session sort of solves that problem quite nicely so um another aspect to this is in terms of the start-up time i can see for some people that might be a little bit helpful but again in terms of the sort of exchange of capabilities and things i'm not sure you'd see that much benefit so um later on there might be discussion about where does netconf go and where does rest conf go i wonder whether quick is more better framed in that discussion or like a future version of of the protocols rather than necessarily adding it to the current one whether you'd actually get any real benefits over just using tls anticipate yeah i think a very available comment and then also uh i would ask author to consider your suggestions and comments yeah very good thank you yeah thank you everyone for the valuable comments and the suggestions okay all right in light of the fact that i think as rob mentioned maybe we might want to consider this as the part of yeah rescant next and net continents will skip the hum on this draft so the next presentation and the final one actually not the final one but the one is on tls at conference tls 1.3 hi my name is sean turner it's nice to see all of your masked faces up here um all right so that conf over tls 1.3 next um the motivation here really is that i deal with some very pedantic people and"
  },
  {
    "startTime": "01:20:01",
    "text": "they read some drafts and they're like well that one says tls 1.2 what about 1.3 i'm like okay so we can write a draft now the thing about tls 1.3 is that you can just kind of use it but there's some there's some differences that you need to deal with the first is zero rtt now what it says in the in the appendix of um a46 is that like in absence of an application layer proto protocol you shouldn't use zero rtt which is zero round trip um i think you guys know about this it's in the rest conf draft it's referred the whole nine yards um but i kind of figured it's better to be explicit about this because people see this as the go fast button and it's actually got some problems and i'll get into that in a second um and i also like to stand on the shoulders of giants hold on sorry um and so we decided to do was just base it off uh 75.89 so we looked at the only two things that we needed to talk about to profile it which were zero rtt and the cypher suites and everything else says do what's in that draft so it's a very simple draft it's very short um we purposely decided not to update 75.89 because i didn't want to get into the whole you got to pick this one this is the mti over the other one it's just kind of like you can implement it 1.2 is out there for now i think it's going to be around for a while but we did update the iana registries to point to this draft in case you wanted to do it so just kind of like dotting us and crossing t's so next so the next uh the big thing with zero rtt so if you don't know about it it's a way that allows you to send early data um to clients or to the server in the first flight now the way this works is you basically go back to the server the second time but in the first exchange it's giving you a pre-shared key and so then you can use that to basically protect the subsequent messages it does make things faster it can be loaded via this exchange or it can be loaded out of"
  },
  {
    "startTime": "01:22:00",
    "text": "bands there are some problems of course because the data is replayable and so that can cause some problems and again the whole point is just to basically say don't do it now on the rest comp um draft i think there's also some recommendations about not supporting zero rtt this is just making it a little stronger and then the only other thing you need to say about it in the draft is cipher suites and the cipher suites are specified slightly differently and the mandatory to implement are a little bit different um and they're all forward secure so it kind of makes sense to kind of move up to the next uh level of more modern cryptography and that's really all that's in the draft and i'm asking for working group adoption all right i don't see anyone in the queue or maybe now uh rob wilson cisco i think this is really helpful to do so thank you for taking the time to do this and to explain it because i think it's helpful for the world to sort of move more towards tls 1.3 so um so i'm definitely very supportive of this yeah and again so the way i was always thinking about this is we'd specify it and if you were like no we want to put in this other document or the next version or whatever great the text is there take it do it you see what you want to do with it if you want to move it forward with it that's great too all right if there are no more comments then we're going to do a quick hum on whether we want to adopt this document as a work group item look that's like instant gratification i can see it on the screen"
  },
  {
    "startTime": "01:24:23",
    "text": "all right i just went ahead and closed the poll i think we have an overwhelming response and we'll take it to the mailing list to confirm the adoption thanks sean thank you all right with that um the final item on the agenda was discussion on rest content context slide so we have something to look at sorry ken during the title the first flight of the chair slides so there's something on the screen sure so can't you want to kick off the discussion audrey yes sure um of course uh yes so uh neck off next and breast conf max there are issue trackers in github for each of these drives and of course the thinking is well of those issue trackers was to collect um issues that you know we've discovered over time and ultimately roll them into the next"
  },
  {
    "startTime": "01:26:00",
    "text": "major versions of these protocols and the same time as this we're also tracking issues in the net mod working group on yang yang next is the issue checker there and many more issues been filed on the yang next issue tracker and it goes without saying that an update to yang would necessitate an update to netkoff and rescoff to support that next version of yang and so i guess the conversation is do we want to when when does the working group think that we might have appetite for some of this work um are there you know are we beginning to feel like the protocols are getting old and we need to freshen them sooner rather than later i guess we're just curious as to what people are thinking along these lines all right any comments on whether there is interest in the work group to see whether protocols both rescue and next and netcon need a refresh so um as the chairs know i when we discussed this before the meeting i was quite keen to have this discussion um and see there's feedback from the working group about this sort of topic so some of the things that i think are interesting the quick that was just presented um is one option something's interesting the other choices is in terms of netconf being xml based whereas a lot of the world's moving towards json or binary encodings is that something we want to consider um and potentially updating the protocols for i think there's other areas of where um things like we have the shared candidate data store do you"
  },
  {
    "startTime": "01:28:01",
    "text": "want to be trying to move away from that and moving towards like private candidates what's that sort of thing um and there's other places in netcoff where i think that the specification is a bit ambiguous and could certainly be clarified or simplified in places as well so i think there is personally i think the scope to do something here if there's an appetite within the working group to try and actually drive this forward the obvious question that kent raised was about um the dovetail with yang next and do we need to wait for that to do that same time which might take quite a long time i'm not sure the the two necessarily need to go hand in hand but in the previous discussions there is some work about moving some of the um almost like the protocol stuff that's documented in rfc 7950 potentially moving that out so there is some sort of cleanup work of course to be done at the same time so i'm just i'm interested in other people's thoughts on this matter as anyone's willing to share them thank you jeff jeff has uh the thing that i would be interested in seeing that being somebody that's strongly following the netcave work but is sort of soaking in the streaming telemetry work in a couple different forms right now is again is rob saying get away from the xmls the you know tool that everybody likes to use get into something that's more of a compact binary form uh the phrase i sort of sling around work these days is that printf and scanf are not your friends you know the the cost of those you know in terms of uh serializing stuff and deserializing them wastes a huge amount of time it wastes much space things like ip address is an example just work to get that in and out of that format for a large amount of data so waste the cpu you know it'd be nice to see something you know as an example cbor being used where we have a compact format uh nice canonicalizations and it's realizes into a small form i think the interesting question i'd have uh again being sort of a"
  },
  {
    "startTime": "01:30:01",
    "text": "couple steps remove participant is you know what happens to yang as an example yang very much does its uh types right now based off of regular expressions on the actual ascii patterns that you should print things as what happens so you want to say well this node is my type ip address but you wanted to actually show up on the wire in binary format what does that do to your validators that sort of question so and jeff since you again speaking as a contributor since you mentioned binary encoding and there is an issue open on the issues page if you could add your comments to that that would be helpful the quick protocol is also an issue open on the issues page so as rob mentioned maybe we should discuss that as part of revving the protocol some of the other areas that we're looking at and also documented as issues on the page uh relate to a private candidate data store issue that i think rob just entered a couple of days ago there's some macam integration improvement requests that andy has indicated and of course there's the json encoding support in netcom which we might have to think in light of the fact whether we want to move towards a more binary encoded format or whether we want to support json so the cleanup of the specification"
  },
  {
    "startTime": "01:32:00",
    "text": "relative to yang and xml i think this was referred to by rob again with respect to rfc 7950 where probably there are more references to netconf that probably should be taken out of that document so overall um quite a few issues the question is of how much interest there is within the working group to pursue this work so can't do you think it would be helpful to try to get a poll on whether there's enough interest and then of obviously who if anyone is interested in picking up some of the work i think a poll would be good but before getting to that with regards to binary i'm almost wondering if it's something that we need to do at least in terms of there's co-op and seabor already they were created as effectively binary versions of netcaf or restaurant would does it make sense for netconf working group to define another binary protocol or would that be the answer i can understand fixing many of the other issues and moving to json and things like that but for the binary is that something that we think we should do here i think we saw a few nodding of heads as far as um sibor is concerned but maybe rob yes just for clarity i mean i think that uh co-op aims to be really concise and things in terms of its format and things i wasn't necessarily thinking that the messages had to be necessarily defined in a binary format but merely that the data that's been carried uh being carried in like cbor rather than xml or json and in particular my interest is in like the streaming"
  },
  {
    "startTime": "01:34:01",
    "text": "telemetry side of things we're getting data off the device a lot of the data there i think there's definitely benefits to having that go in a binary format i would echo the seabor uh what we said about cyborg and if at the same time we can distance ourselves as much as possible from google protobuf that would be fantastic so rob mentioned the stronger desire for um when pushing telemetry data off box and with the notif you know the suite of notif drafts that we're planning to publish so so far there's https notif and udp notif and uh it was discussed at the time that we started creating these drafts that it would be ideal to create a binary notif of some sort you know for pushing um telemetry data or gang push data if if that were the only focus if it was just the binary notif would that resolve um like 80 or more of the primary concern for wanting to move to binary all right jeff has so uh kent the answer to your question is it shouldn't matter if it's the notification case or whether it's the normal cases you're going to want the protocols to be able to deal with the same binary format regardless of you know which was being used for but for the streaming telemetry it's absolutely one of the core use cases i think effectively because"
  },
  {
    "startTime": "01:36:00",
    "text": "operations like gets for simple operational things for small tables it doesn't really matter what the encoding is it's a small amount of data you don't burn a lot of cpu but any case where you have large amounts of data coming out like say doing a get for the bgp rib you know that's a huge amount of data being able to minimize that time would be good and if you have a streaming feed of like hp routing state as an example minimizing that's also a core use case so i think to answer your question it doesn't really matter which is your use case the telemetry feed will be sort of more of a motivating use case i think but it should apply across the board it's common code well i just as respond to that i think it might be a great simplification if we can just focus on a binary notif form because um as mentioned there's uh for instance udp notice right so it's completely different protocol but it doesn't affect the configuration side of things um i understand that through uh netconf you know a client can you know interactively request for the bgp rib data and it would be a huge xml or json response but if we have binary notif and there and the client is using yang push um then then that would that's how they would resolve that issue um so i don't know i i think it warrants more discussion thank you just as a quick follow-up if you think about printing any large xml document how much of the overhead is just simply the tags and that's the single biggest thing that you get out of any of the binary formats those things just drop out did you want to prepare a poll right so before actually we jump into"
  },
  {
    "startTime": "01:38:01",
    "text": "poll and there's one other topic i briefly wanted to touch upon is so one of the issues that um we opened some time ago was around the cleanup of hello message and capability in netconf now tied to that is actually the work of yang library and i think the the versioning scheme mechanism i don't know if we have the authors here but was there any desire to see that maybe the fellow exchange work is something that needs cleanup or the fact that we want to use yang library as a way to improve what is exchanged at hello time i'll let jan speak to this first and then uh yen you might want to unmute your microphone or we can't hear you okay we still have a few microphone issues can you try speaking again no okay you might just put some comment on the key in the queue yeah or type into the chat window sorry so while jan's doing that robots in cisco so we certainly discussed this in the context of yang packages and the versioning work so it's a good good"
  },
  {
    "startTime": "01:40:00",
    "text": "thing to raise this and um i know that yan is concerned that we seem to have lots of different mechanisms for exchanging things like yang library data and which models are being supported and and there's different other cases where you sort of exchange these lists of models the idea with young packages it sort of simplifies that and it stops you having to exchange this long list of young modules you can just exchange a reference to that but it does become another mechanism so i think that yes if we were doing a new version of the protocol and yang patches was completed in that time it would make sense to try and use that as the mechanism to say this is the sport supported schema for the device and try and simplify some of those mechanisms so i think that would be useful and sort of cut back on the proliferation and then that agrees with what yan thinks okay so before we go to the poll any more comments or questions all right thomas thomas from swisscom maybe regarding the notification message header suggestion that we are adding also the the x-pass the young model and the versioning aspect there so if you're talking to make it binary that would be very helpful okay just make sure you add it to the notes page also so i'll go ahead and start the poll"
  },
  {
    "startTime": "01:42:38",
    "text": "okay let's go ahead and i'll end the session thanks mahash so benua clay's answer yes right but actually i'm not interested in everything so i'm interested into you know the binary encoding and the header and some of these so i was not too sure what to answer so i said yes [Laughter] i also think that these issues could be hand handled one by one as opposed to yang where we have big issues that need a second revision i see this more as additions than the revamp of the system okay so um so just quickly going back to the poll uh even though it was generic and applied to almost all the open issues um we still had a fairly positive response so the question i think which is being raised is are there more specific hot button issues that need to be addressed before"
  },
  {
    "startTime": "01:44:00",
    "text": "others and that's something i think we can take as a poll also on the mailing list we could certainly try to go through a whole process but may not get a sense so maybe kent and i will discuss this and bring it forth in the group mailing list to see if there are any specific issues that we might want to address before others ken what do you think um and i was actually i have to um come clean i did not reply to that poll i didn't know how to either um it i guess really i was thinking the poll is you know do we start to work now or you know if we know that the uh yang next is looming um and it's necessitating a change in netconf and rescoff already do we have to block for uh the yang next work to you know complete or um you know move forward and i guess your proposal is let's see if we can find some items to move forward now which makes sense and uh of course anyone is welcome to write a draft to move any of those items forward when possible that'd be great ron robertson cisco so um so there were some poll votes against doing this work it'd be interesting for those people if they have a chance to either put a comment in the chat or come up to the mic and explain why they think we shouldn't be doing this that would be really helpful i think i don't know that's aligns to bellagio's comments maybe in terms of be able to split the work up but if there's anyone that wants to share their thoughts as to why we shouldn't be doing that that'd be useful to hear good point drum so for those who did not raise their hand"
  },
  {
    "startTime": "01:46:00",
    "text": "either because they were confused about the question or um one did have specific views on why maybe the work should not be pursued i would love to hear from you too okay so i see a comment from yan who says there are currently three mechanisms defined for clients to figure out which modules the server supports then he goes on to say i think a couple of the next issues might be worth working on is that a yes or no maybe a poll for individual proposals might be more interesting than a yes no global answer so he was one of the ones who posted did not raise his hands all right unless there is um there are any more comments um we can go ahead and close the session we will take this to um the mailing list the question of whether we are in any way tied to yang next we should be wait for it or maybe pick up some of the items uh more heartburn issues as what we want to start our work off with so right if there's"
  },
  {
    "startTime": "01:48:00",
    "text": "nothing else thanks everyone for attending the session and hope to see you guys soon plus"
  },
  {
    "startTime": "01:50:10",
    "text": "[Music]"
  }
]
