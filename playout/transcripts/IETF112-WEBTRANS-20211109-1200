[
  {
    "startTime": "00:00:14",
    "text": "foreign hello good morning or you know afternoon or middle of the night evening"
  },
  {
    "startTime": "00:02:04",
    "text": "so apparently folks are having a hard time logging in to um uh either to data tracker to the integration with meat echo so maybe let's give them a couple more minutes to enter the meeting you you"
  },
  {
    "startTime": "00:04:41",
    "text": "you uh since mike asked on the chat this is just making sure that audio works can someone confirm on the chat that you can hear me uh we can hear you just fine david all right thanks yeah we're we're still waiting on some more participants to get through uh i'm seeing victor all right then i think i think maybe at this point we can get started or not what do you think yeah i think i think it looks like uh the log jam has been broken"
  },
  {
    "startTime": "00:06:01",
    "text": "we've just added like 20 people in the last uh minute or two okay all right okay thank you this is the itf 112 meeting of the web trans working group a few meeting tips this session is being recorded a data tracker login is required to attend i know a bunch of you have had problems with that but hopefully you're through it now you don't have to fill in the blue sheets that's automatic you can join the jabber room via the data tracker meeting agenda uh please use headphones or an echo canceling speakerphone and stake your full name before speaking so we can get you in the minutes so we are going to be running a queue i guess david you'll run the queue and this is a little bit of advice on how to get into it and out of it you use the basically the hand tool and then you'll need to enable your audio or you'll be talking well muted you do or you can enable video you don't have to um it does help a little bit with the comprehension but it isn't required so the notewell this is an itf working group so itf policies are in effect and by participating you agree to follow those processes definitive information is in the bcps below in this slide and we encourage you to read them and understand them and also of course personal information you provide is handled in accordance with the privacy statement also we like to be clear that the itf meetings virtual meetings mailing lists etc are intended for professional"
  },
  {
    "startTime": "00:08:00",
    "text": "collaboration and we have itf guidelines for conduct anti-harassment and procedures for the same if you have any concerns about anything you're observing please talk to the boots team who are available for you and you can do that confidentially and of course we strive to maintain an environment which exemplifies dignity decency and respect and we expect you to do the same so a little bit about the meeting the agenda is up on the web we also have the notes segment is enabled in a jabber room i guess alan has volunteered to be the jabra scribe we are looking for note takers and would like to solicit volunteers for that do we have volunteers for taking notes in the notes app as a reminder to folks taking notes is not very hard they don't need to be perfect because we have the video they're mainly to capture decisions and we can't start meeting without a volunteer so please volunteer to come and help us take notes i guess we can try drafting people if they won't volunteer we really really do need a notetaker i see james volunteered in the chats thank you so much james uh thank you we have a second person as well to"
  },
  {
    "startTime": "00:10:01",
    "text": "assist all right secondary is even less work this this is spencer uh i can do that i i can help james as well thank you very much spencer thank you very much of okay so uh some other meetings this week which you may be interested in there's a media over quick side meetings and if you go to the link above you'll see when they are there's one today a little bit later and there's another one on friday so we encourage you to have a look at those uh they will be uh talking about some of the issues of transporting media over quick or or web transport okay so the agenda we're mostly through the preliminaries thankfully we should do the agenda bash but here's basically what we have on store for you we have a web transport update from the w3c yanivar will do that we then have victor talking about web transporter http 3 and eric talking about web transport over http 2 and then we'll have our wrap up and summary is there anything else that anybody wants to put on the agenda okay not hearing any suggested modifications i'm going to turn it over to jan ivar for the w3c web transport update yanivar all right can you hear me we can all right great so this is an update uh from the w3c web transport working group uh with progress we've made since uh last itf111 on july 30th the status is now a we published a another working draft which means we're technically no longer first public working guy we're just working left so yeah um we finished we believe we finished all discussion of issues in our minimum viable ship milestone that we advertised last time there are four non-editorial issues remaining that are ready for pr but we"
  },
  {
    "startTime": "00:12:00",
    "text": "believe there are uh not controversial and three editorial and attractor for web platform tests which are been added some decisions and pr's we sort of error handling in the algorithms and there's a new web transport error dom exception with the following members and there's a source to say whether the source of the error is stream or session session being the entire connection uh and with a also an eight bit uh stream error code that defaults to zero this means that um upstream of a sender even you can now abort a what wg stream with a new web transport error and you could specify stream error code that will be sent to the receiver there's also a max datagram size read-only member on datagrams that is a user agent implementation defined integer um you can query uh there's also center side now takes streams of buffer source objects as input which means array buffer or array buffer view we added in uh minimal prioritization which means that all outgoing datagrams have priority over outdoor other outcome data like uh in other streams uh we added a 32-bit close code which is not an error but we can await the web transport closed promise with a recent string as well next line we also had an annual tpac meeting october 26th slides are available in the link here we highlighted different clips for those coming from a websocket background and also from a webrtc background to try to give a broader overview for people of web transport we also highlighted a chrome update uh they are shipping web transport in m97 uh which is built on the o2 version of the draft and has support for 8-bit reset stream code and i really 32-bit"
  },
  {
    "startTime": "00:14:01",
    "text": "closing error code no origin which trial is required this is fully shipped available in window and workers uh only secure context um some things that still need to be added are you know deeper prioritization of sending and stats also the hash based certificates instead of web pki may be available m98 as we said uh implementation is fairly mature covered by web platform tests using an echo server based on aio quick also a presentation was made by a member for multicast for the web from the w3c multicast community group with the demo and uh they made a request to the w actually clarified uh the member made a request to the w3c to add multicast datagrams as a use case and so the w3c is not requesting this but we're forwarding that request for consideration by this working group because it's more network related looks like also an issue was identified around bi-directional server-based video conferencing and low-latency video upload from client to server so this is an important use case for for us and we've seen some evidence that better integration between encoder and congestion control algorithms can be helpful uh not sufficient stats apis are not available today in web transport to do that well we believe uh web codex api for average bit rate result target for instance can results in overshoots uh when keyframes are sent and undershoots for delta frames uh while an application can always send less what the condition would they will allow um it's not really easy to send more than the congestion window permits because uh"
  },
  {
    "startTime": "00:16:01",
    "text": "what you want to do probably is like additive increase to probe for more uh network availability uh however that doesn't allow you to re-enable dropped layers which would be a multiplicative increase so with that application filling in the congestion window by probing that this end is gonna practically get stuck in an artificially low rate and there's also some conflicts potential conflicts with other congestion controls being discussed such as this paper and rdp over quick so the wtc working group is requesting that the this working group support this use case because it's an important use case and help us develop measurements that uh can be used to do this more effectively and that's it thank you okay thank you yanivar i would note that some of this is being discussed now on the media over quick mailing list and uh with respect to rtp over quick there will be a discussion in abt core uh later in the week okay so we're going to hand it over to victor to talk about web transport of http 3. right there hello can you hear me we can okay so uh i'm going to give update over web transport to reach free as well to go over some issues i don't expect this to go over too long because most of the issues are either the easy issues were addressed and the hard issues require more discussion that this missing is likely to fit uh but uh uh next slide so let's start with there is a new version of draft draft o2 uh it incorporates like"
  },
  {
    "startTime": "00:18:02",
    "text": "months like six months worth of changes to the draft and it includes the clean close of the entire session reset error codes and bunch of other stuff and this is the version that is uh in its non-pooled incarnation shipping in chrome 97 uh which means at least we as a club team would have to maintain it for quite a while uh uh next uh slide uh so one of the details which i had to add because i realized we don't have anything like that is we added a header that indicates the version of the draft you're using uh it is intentionally framed in the draft version and it will uh probable so that and we will likely reshape it or remove it when we ship the final version uh but that this is how it looks uh right now uh next slide so let's move on to the issues as i said i didn't put that many issues on the sides uh because most of them are eyes are closed or uh require more effort uh next slide uh so the first issue we kind of discussed in past but never came to conclusion is how do we do we need a mechanism for training sessions gracefully that is the equivalent of a go away frame for uh"
  },
  {
    "startTime": "00:20:02",
    "text": "for webtr uh one sec uh that is to say do we need anything like a go away frame and the reason we would want it for individual session is that uh we have similar capabilities and protocols like age free uh and uh people have expressed interest i guess the people who expressed interest are look and allen so i wonder if either of you still thinks that's useful or can elaborate on what you think about this uh ellen yeah this is alan frindell i'm still inclined to say there is value in having a go away capsule well the capsule may be a loaded term based on what's going on from yesterday um but as long as there's a structured way to send messages over the extended connect uh stream then it seems very lightweight to be able to add a message like go away and uh we've seen lots of examples of people building protocols without things like go away and it causes a bunch of problems for for servers that that want to drink gracefully and anybody who would want it i mean you can always sort of build it yourself by adding a control stream inside your web transport session and defining your own framing but it seems much cheaper for us to add a mechanism for it martin will argue with me martin uh in in this case i'm not sure what the semantics you would attach to a go away would be it's gonna depend on the application that's using the web transport isn't it"
  },
  {
    "startTime": "00:22:03",
    "text": "okay waiting for audio yeah i i mean it can be a signal that just says but it signals just an intention like i would like this to go away soon and can include information like and the last set of whatever streams i received anyway uh you know could be identified by these numbers and what the semantics are you're right are sort of dependent on whatever protocol is running over top but the i think the high level signal is still valuable yeah i i guess what i was getting at there was if there is a generic signal then it would wouldn't really make a whole lot of sense to attach anything with to it because the the concepts that an application uses the sort of granularity of its stream usage and datagram usage is unknown and unknowable i agree with what you're saying i think the information you can include is information that is exposed at the to the web transport which is like i i have seen these stream identifiers like they have at least been whatever like pass to the application uh but everything else i guess it's certainly possible the application has higher level semantics and that that it would need to convey beyond what's in the transport in which case they have to write their own frame anyway um okay yep that makes sense another possibility is that i'm not sure if we've defined on the connect stream is it okay to have unknown capsules then people could use that connect stream as a control stream or is the messages are the messages on the connect stream only the ones defined in the standard and if you want to send any other messages which are session level messages"
  },
  {
    "startTime": "00:24:00",
    "text": "they have to go over some stream that your application controls i guess to the later comment uh about messages i think that control that capsules are to some extent not controlled by application because they're in some in some sense privileged as in uh we assume they come from the browser and not from the web application uh in that sense uh we can't really give you the full control uh but also in general my intuition is uh we should not add new concepts which are already trivially achievable with the apis we give uh because it's just like adds multiple ways to do things that are somewhat redundant i would i don't i don't know that how trivial it is or if it's you know everyone there because there may be applications that don't use or need a control stream i don't know and so and requiring every application to do it i guess we had this discussion i don't know four years ago and quick when someone tried to add go away originally go away it was a quick frame and then we said no make every application do it uh and now we have so um i guess maybe the same principles apply here i don't know i still think the like signaling the intent and capturing transport level information to the other side about what's been received is uh a building block that can be reused and it's low cost but i don't know i don't need to die on this hill either if people feel strongly that it's the other way uh all right thank you uh lucas hello um so i i think i was agreeing with martin's earlier point that the value of this uh"
  },
  {
    "startTime": "00:26:01",
    "text": "thing go away whatever you want to call it depends on what information it includes and what the receiver would act upon so i think i don't understand really what does ads above http 3 go away um and what it would include that's generic enough that anything else that the web transport layer would be able to read that and act on it um so maybe there is if someone has a proposal but right now it kind of seems like impossible to define and implement in a way that would work for everything to me uh eric negren i guess the benefit of doing this in the um at this layer would be um if there was an intermediate that wanted to go and and send that um send it to both of the endpoints but without knowing the inner protocol the endpoints were using such as like if you had a cdn that implemented web transport the alternative may be on the api side um if there if the api exposed up the the h2 or h3 go away as part of the the web transport api but i'm not sure which would which is going to be cleaner from a a just only keep it at the h2h3 layer or also have a way to send go away through a capsule or capsule equivalent uh alan yeah the i think i now the context is like paging in after months and it being four in the morning um the intermediary case i think is the one where it's useful because you may have first of all the intermediary goal that is sort of proxying web transport without understanding the underlying protocol and it wants to go away and it needs to tell both endpoint like it's"
  },
  {
    "startTime": "00:28:01",
    "text": "got a web transport session going in each direction and it wants to tell both of them that it's going away and it may be using pooling so i guess in that case the http 3 level go away is probably sufficient but there may also be cases where somebody wants to make a web there are pool web transport sessions and i want one session to go away but not other sessions or other http requests that are on the same connection which is why it would be a session specific message rather than a connection specific message uh all right uh i think my main question is think we it sounds like we need a specific proposal that explains the use cases that this is for and my question would be alan would you volunteer to write a pr or a proposal for how to handle go aways in web transport over http free uh yeah i can write a pr uh and we can people can argue about it we can we can repeat our arguments here on the pr uh all right uh uh uh coots either of the chairs recorded on the issue while i moved to the next slide or someone uh next slide go ahead thank you david uh now here is an interesting issue that we uh have historically just punted until later and the later is kind of approaching uh and that is at some point we agreed that it would be useful to support pulling of multiple web transport sections or of with each other and with regular http free traffic uh and in order to do that we need to"
  },
  {
    "startTime": "00:30:02",
    "text": "have some understanding of how to do resource management namely how do we limit namely quick provides flow control for all of the resources but the flow control is it's not it's connection global and the pulling is between sessions that are uh in some sense not related to each other and in ideal scenario we would strongly prefer to isolate the sessions in a sense that even if one session uh misbehaves and acts in a way that starves itself as a connection it does not serve others of resources uh and the question is how do we do that and currently there are no specific proposals in uh at least the ones i'm aware of so i was wondering if we can at least start discussion here and i want to do people have opinions or ideas about this uh martin for someone to say something okay so um last time we talked about this you raised the point that we essentially give sites the ability to use fetch to consume all of the available bi-directional stream resources for a connection sort of almost"
  },
  {
    "startTime": "00:32:00",
    "text": "without constraint and we sort of assume that there's enough resources there that they can they can do that if they so choose and the more that i think about this the more that i think that that sort of class a fair attitude toward this thing might actually be the best solution at least for the meantime it doesn't mean that we might not choose later to do something but maybe maybe we can just do nothing for the moment that is that is definitely a possible approach we can take uh and yes the cases i'm afraid are the pathological interactions that are novel to web transport for instance your web transport opens so many streams that you cannot fetch at all yeah that seems entirely possible particularly given some of the patterns that that yanivara shared with uh us it is not entirely clear to me that such patterns would be possible with fetch because fetch is a more complicated structure and it has its own limitations and things oh don't don't make claims like that because that's just a challenge yes uh well i am not challenging to intentionally do that i am saying i'm talking about likelihood of that occurring unintentionally right uh spencer thank you and i was actually just following up with uh martin do you do you think do you think that the philosophy fair attitude would be easier to"
  },
  {
    "startTime": "00:34:00",
    "text": "add or to take another ad later or to take away later i don't think it's particularly difficult to add some controls i think it's pretty difficult to add them in such a way that they would be reliable and such that you could depend on them being there and depend on them being effective so if there's something that was truly bad going on and things were breaking i don't think you could rely entirely on whatever mechanism that you introduced but that's just guessing i'd have to sort of think about what sort of system that you might want to introduce i've got no way no good ideas at the moment unfortunately okay thank you oh oh look us hello um i was just reading up on the issue uh which is like a year old so my memory's a bit hazy but um it kind of seems a bit similar to a discussion we are having a few weeks ago on the http priorities draft unrelated to priorities but around the ability for endpoints to detect how many concurrent streams they might be able to open or that they gave to the peer to be able to open um some of that hinges on the quick api that is exposed up to applications and that you know you should assume that the api gives you all the information you need to know but that assumption maybe doesn't hold for different implementations so i think like if if if we look at it from a perspective of trying to avoid a client consuming all of the concurrent um request streams or bidirectional streams it could open um like i i honestly i don't know if if we can assume that that information is available directly to clients but that if if it was in some way that there seems to be to me an api issue not a protocol one such as you could"
  },
  {
    "startTime": "00:36:03",
    "text": "say at the the browser level just ask for a share of the available connection resource for concurrent streams that the server would let you open because you're not going to know that information until you create the connection uh and that could vary by server so i i i i don't think there's much we could do here but i could be wrong and i'm happy to be wrong thank you lucas uh your attacker can you hear me oh yes uh so that i dare you the memory consumed in the connection should be a function of the boundaries so that even if we have many many streams the bytes transmitted per second shouldn't increase by creating more streams so with ideal implementation [Music] the constant memory should be enough is that right uh that is to some extent correct but there is also the issue of not just limiting the buffer size but also the total number of streams uh so my in fact this is like more of my main concerns is that their quick has some limit of how many streams you can open on the same http free connection and those that limit is shared between"
  },
  {
    "startTime": "00:38:02",
    "text": "regular fetch requests and web transport in the situation when there is pooling so uh the problem here is how do we make sure that we don't open too many web transfers so we are incapable of doing fetch and vice versa thank you uh dragana hi you hear me do you hear me yes yeah okay sorry i haven't used that this often um i'm afraid of uh different implementation having different limits and this really being the timing issue that pages opening and there is a lot of fetches and then they cannot uh open the streams and that's this is like timing dependent that uh for application developer can be pretty tricky to like notice the problems uh by testing uh i i'm wondering if this is like going far away uh like in the different direction i'm wondering of having the um guarantees about the limits first rap transport session to make this um debuggable but this is like uh opening the different kind of uh issues uh around that uh i do some so i agree that we should have sub give developers some idea of what their they should at least expect the browser to support because uh if my web transport only supports four concurrent streams that's well that's a very different situation if it supports 100 and that would"
  },
  {
    "startTime": "00:40:00",
    "text": "to some extent the fact even the fundamentally how i design protocol uh so yeah i'm just wondering about the pooling uh behaviors different different browsing genes that there are some of them pull more that some amber moon less than if you open two three taps that in the end that transfer doesn't work because they are completely to the same but this is like a different yeah okay i see thank you martin point here is probably one that we need to pay a little bit more attention to um when i suggested we just sort of do nothing i hadn't sort of internalized that problem but you can imagine how easy it would be to use up all of the streams it's just a for loop with a create stream call right and you've used them all up the streams are easy to create but there's no guarantees about the number of concurrent streams that will be available to you at any time quick doesn't provide any any real guarantees http 2 has this sort of you you can have 100 concurrent streams or um whatever the number happens to be and you know what that number will be but quick you you only get new streams when the other side decides that it wants to give you something and it could reduce the number of concurrent streams so i think there's there's minimum guarantees and i think there probably needs to be some sort of cap the more that i think about this is we've discussed it and it's coming back in i see so it sounds like"
  },
  {
    "startTime": "00:42:01",
    "text": "we have some ideas on how this should work uh and uh i think that we should discuss the rest on the mailing list because uh i think we've spent already like 20 minutes or so talking about this uh but yes this is definitely needs further discussion and probably mailing list uh thanks for free everyone this was very valuable uh next slide oh so the next issue is what do we do with redirects and there are roughly two options we have to follow redirects or to not follow redirects and diverges to the application we had similar discussion a while ago in w3c uh and i think back then we agreed that we should redirect to the application because that makes the stack just much simpler but i wanted to know what opinions on this matter to fox since this working group have uh so oh if anyone has opinions please during the queue uh if no one has opinions i uh uh i think i will just close with the double ifrc conclusion which is uh we don't support redirects uh uh david"
  },
  {
    "startTime": "00:44:00",
    "text": "uh thanks speaking as individual contributor and the person who followed this issue um i'm okay with that i i don't have a strong opinion on what on whether we should support it or not i just think we should be very clear in the spec uh whether it is supported or not uh i see thank you uh martin sorry i'm going to have to refresh my memory on bcp56 biz but i think if we're playing http we have to play by the rules and 3xx is one of the http things that you just have to deal with um and so there are three x's that don't make any sense for web transport um but there are three x x's that probably do uh i can't remember which one which one goes where but i think that if we're playing http then we have to not pretend yeah i can see that from my personal perspective and my intuition is roughly redirects are the things that people don't build in initially and then when they don't build it they end up regretting this and i know that because i used to support a certain very ancient legacy protocol with a server that i needed to move and i had to do really dirty load balancing tricks to move it because that protocol did not support redirects which made it a lot harder uh so uh i"
  },
  {
    "startTime": "00:46:00",
    "text": "so i think we need to figure out whether we actually need to do redirects according to the bcp and if that is the case uh i do we should support them and if not we should revisit this uh uh all right uh next issue and i think that's the last big issue we should address uh is the issue of request forgery and this probably is not a very good summary because uh martin wrote much more uh but uh basically in the issue is oh uh there are multiple forms of attacks that uh exists in which you a can confuse appear into billy in which you can confuse various parties into believing that you are speaking a protocol different from the one you're actually speaking on one level uh there is obvious attacks like the ones we one of the reasons we don't get uh rock quick sockets to web directly is it allows you to bypass authentication and whenever in web transport we go out of our way and as a part of requirements we have to identify that all of our traffic that is initiated by a web application is identified as being initiated by a"
  },
  {
    "startTime": "00:48:01",
    "text": "web application as opposed to any native client but there are also families of attacks that do you can still perform uh and one of them is the one websocket tried to avoid with masking is an attack where you try to make your traffic uh from client to server look like certain kind of http traffic uh and that would lead intermediaries to assume that you're speaking http even if you're obviously not and websocket addresses that by trying to make the traffic unpredictable via masking and the question is do we need to do anything similar in web transport or not uh and i wanna hear people's substances especially martin since he filed that issue and i'm not even sure if my summary is good or not martin takes about five seconds for this to come through so victor the only thing that i'd probably correct in your summary was that the impersonation of another protocol is not just http you can make it look like other things and i think one of the um the net slip streaming stuff was was using i think stun at one point or sip or something else it was a whole bunch of different different loopholes that they were looking to exploit so because you have essentially full control over the the packets that are being exchanged between the client and the server you can you can do a lot"
  },
  {
    "startTime": "00:50:00",
    "text": "um i'm not yeah harold harold's much closer to this than i had it was it was done with um special control over the udp message fragmentation which i don't think that quick natively has but it's worth considering um i have not come to any conclusions myself on this one i was hoping that mike harold would be able to provide their insights and i know adam rice has been doing some work on this as well yeah so the questions i would have like the first question i would ask is uh is this specific to web transport or if this is a problem why is this not a problem with something like fetch it is a problem with fetch yep okay uh harold yes so the problem with masking is if you give the attacker control over basically the first bytes of a packet then uh you can count on some idiot box on the on the network somewhere doing something inappropriate with it uh so the reason why uh the natch lip stream attack worked was because uh stun sent packets that were chopped into more than one udp fragment and the attacker had control over the first bytes of the of the b fragment fragment now if you encrypt content then the attacker does not have control and if you have a header that is uh controlled by the protocol the attacker does not have control so"
  },
  {
    "startTime": "00:52:00",
    "text": "if you and if you encrypt what's the what the attacker has control over and and and format the rest according to your own rules you're basically safe against forgery that's the that's the short version now web transport didn't encrypt so therefore they did masking instead no way web sockets i mean it's much better to encrypt as quick does i see uh thank you davis quinase um yes speaking as individual contributor again so um encryption helps but not in this scenario because it is predictable uh the issue here is uh the the these attack setups include like a a participating evil web transport server with you know like evil web transport javascript on the client and so even though we are encrypting because we're using stream ciphers in quick you can have the evil web transport server send the keys over the application layer and the packet numbers it is receiving from the client so the client can pick some packet number in the close future and then blast that a bunch of times because since it's a stream cipher you can you know if you know what the uh you can recover what the key mat is so you just absorb your plain text with that and then you can have influence over the cipher text so you can defeat the protection brought about by encryption using this um so so we we still have a problem we need to solve is kind of all i'm saying uh but the next step is how do we solve it my personal take is this isn't specific to web transport like you have the same issue with regular fetch requests and so potentially the best solution is"
  },
  {
    "startTime": "00:54:01",
    "text": "to do the same thing as what we did for the slipstream attack which was to add a few ports to the fetch tcp block list so i think the solution here is that we need a fetch udp block list of ports which would solve the problem for regular http requests and for web transport um that means that here in terms of itf we would have we would do nothing and then we would kind of punch the problem to the w3c uh that would be my personal put here yeah so i agree one thing i will notice is as far as i remember web transport actually respects the tcp blood port block list and the other thing is uh this will protect us against port blocking will attack us against this netflix streaming attacks but that doesn't mean that it will protect us against all classes of attacks that we may not be yet aware of uh uh utaka only for client to server direction server to client communication is not masked because the original scenario was the client attacks proxies living between the survived client but given the scenario scenarios for web transport it seems the client to server and server to client both needs masking is that right well to some extent i don't think masking can help on server to client because if server is malicious it will do like the entire attack depends on the premise that"
  },
  {
    "startTime": "00:56:01",
    "text": "both web application and the server are malicious and you it doesn't help you to demand to require masking on server because the server can already send whatever it wants uh and the fundamental problem of this attack are the client to server flight as far as i understand in that case the the masking sounds relying on an assumption that the sabbath client is safe that and it sounds understick to me well it is not as much as safe as is there is nothing we can do about it because the server can send whatever it can yeah yeah yeah i i i see uh i i guess i'm not sure how this works out in case of nas lip strumming but in general the problem is we're where it is forging the packets that initiate from a fan network thank you thank you uh harold i kind of kind of panicked when i realized what uh what what you're saying about an evil server being able to leak the keys and thereby influencing the ciphertext because that that attack will actually work against anything that uses quick and that means that uh well first of all it's a much bigger problem than i thought and second it's not"
  },
  {
    "startTime": "00:58:00",
    "text": "this working group's problem to solve the first the first bad the other is good for this meeting but not not for the not not for the ecosystem if that if the attack is real then it's then it's uh applies to any protocol using quick yes i think i think my intuition is that this is an issue we should probably uh punt to quick working group uh because this is much extends far beyond web transport uh and to some extent this is the problem that can be addressed in various levels but i don't think we are web transport is the correct level uh does anyone object to that conclusion uh martin uh just a note i think we're almost out of time on this segment so we should probably do we have any more slides victor no this is the final site okay i i was going to say i only object to it to the extent that it might then not go addressed in if indeed we believe that it's being addressed is necessary but um if if we take the necessary steps to ensure that we have a discussion perhaps in http perhaps in tls then i can live with that uh thanks martin uh this is all for my"
  },
  {
    "startTime": "01:00:00",
    "text": "slides uh uh i'm returning mike to the chairs okay i think we're going to move on to eric kinnear with web transport using http 2. all right we should have audio and next slide please so we've had quite a few changes since we last talked if you may recall at ietf 111 we talked about moving to a layered design uh which effectively pulls in kind of a minimal set of framing from quick and runs that over a single hv2 stream uh in large part because we were saying that it was easier to build something on top of hgv2 then to own an http 2 implementation and expect those implementations to change um martin has also graciously uh said he is willing to join us as an author and has been contributing a lot of nice texts so thank you martin next slide please so i drew a couple of fairly crude diagrams to kind of help us all page in what we mean when we talk about these things so to set the stage here i've got this box in the middle that we're going to worry about in a little bit later but instead of adding additional frames to http 2 we now have an h2 implementation on either end there's client server pick your favorite intermediaries um and we use extended connect to say hey i'm speaking web transport and then that connect stream becomes the thing that carries the entirety of the web transport session so when we've talked about kind of breaking out to use native um streams or datagrams when they're"
  },
  {
    "startTime": "01:02:01",
    "text": "available or something like that this is kind of the the far end of that spectrum where nothing is broken out and everything is self-contained within the single connect stream next slide please if we then move into what was inside that box in the middle we have a web transport session where we have bi-directional streams we also have unidirectional streams and we also have datagrams and of course these can be initiated from either side which is why i've got some of them kind of anchored on the left and some of them anchored on the right but conceptually what we're doing is we're taking a lot of the framing that we were adding into http 2 and lifting it up one layer so that it's effectively version independent next slide please in order to do that we end up pulling over a subset of the frames that came from quick and we saw a variant of this slide at 111 and in actually writing up a bunch of the text and the definitions there's a couple of issues uh that we need to work out which we'll get to in a little bit but in general it was fairly clean so there's kind of the main set on the left you've got stream and datagram and we also brought along padding and that allows you to do you know the bi-directional unidirectional streams and datagrams and then there's a set of reset streams stop sending kind of state management there and then there's flow control which is pretty much lifted exactly from quick which is subtly different from h2 but that's not the end of the world so for that we have max data for the whole web transport session we have mac stream data for a given stream and then we have mac streams for stream counts and brought along the uh the blocked variants of those frames as well for the same purposes as we have them in quick and next slide please"
  },
  {
    "startTime": "01:04:04",
    "text": "so we've got a couple of issues that i wanted to bring up here so that we could kind of talk about them as a group and hopefully make some progress on unblocking kind of some of the remaining questions as we were specifying exactly where the different bits and bytes go the first one is when we talk about mirroring quick there's kind of two pieces that come into this and the first one is that there's a couple of fields in certain quick frames and i've pulled up uh reset stream as an example that are just not necessary uh in the way that we're doing this so for example uh within reset stream there's final size and it turns out there aren't very many other examples of this um but here is an example of a field where both sides already know the amount of data that's that's gone on the stream we don't actually need final size it's not communicating anything that's interesting and so the main question is we're talking about hey you know there's some additional lifting necessary in that you now need to parse a bunch of these frames one of the ideas that was brought up that is potentially really attractive is you know you could just reuse your quick parser for a bunch of these frames and so rather than needing to do a bunch of lifting to handle all of this stuff you could just say hey this looks like a quick frame at which point we could just leave final size there and your parser would just do the thing and you just wouldn't bother looking at what's there and it's a variable with vintage so it wouldn't take up very much space and we could all move on with our day we can talk about what our appetite is for that if we go to the next slide the other thing that comes up there is we've added a length field to every frame um that gives you a couple of things one it lets you take unknown frame types and be able to skip them and you're packing all of these frames"
  },
  {
    "startTime": "01:06:01",
    "text": "into a reliable byte stream and so it's really kind of nice to have the delineations of where things are especially since things can't be lost and you can't just ignore any of them um we've currently put that right after the type but it is entirely possible that we could put the length first and i think alan had the interest made the interesting observation that if we put the length first you could consume the length strip it off and then shove the entire rest of what's there at your quick frame parser and be done and so i think the the place where we want to stop right here is to get some sense from people of is this an attractive thing to do is this a as somebody who's implementing this you say oh yes this is you know substantially easier if i don't have to do any of this parsing there's a bunch of variable length integers here i'd like to just take my quick code and you know strip off the length and shove the frame at it or does this become useless and and not actually particularly helpful i see martin is joining the cube well i was just going to point out that you could be even even more clever than this and use the same length field for multiple frames because that's what quick does right and you but i'm not sure that i really need to go there this is this is the fallback protocol and we could we can always be too too clever uh i kind of like the way that we have it in the draft at the moment and i'm comfortable then saying that this is not quick and removing the final size doesn't doesn't make me at all uncomfortable i think that seems pretty reasonable lucas yeah like if if you're gonna change the frame layout then you're not gonna get any reuse from quick unless you start to"
  },
  {
    "startTime": "01:08:00",
    "text": "special casey quick parser which i wouldn't suggest anyone does like the parsing code for these things is like if you have a length it's pretty easy it's not that hard to you know copy paste the code and call it a web transport frame parser or something so i'll just go for the simple thing and not try to be overly clever thanks all right alan i i guess since this is my suggestion uh i'll just say that i think i prefer like having the i would either put the length first and keep the flame formats the same and then just reuse the quick parser i mean yes you can copy and paste it but uh i think i would prefer not to uh and i don't and the other option we have talked about is that quick itself doesn't have the lengths and do we need them here do we want i mean the main benefit is you could add more um you could add unknown types and that's why you have a length if you otherwise you know exactly what's going to be in there that's what quick does you can't add unknown types in quick so i think it's sort of bound together we could drop length all we could we could drop length entirely if we don't want to support unknown types right it seems like we're kind of walking into a binary decision of make it look like quick or it's okay that it doesn't look exactly like quick and we're fine with that ian actually i think ask basically the same question of like um is that do we really think we need a length here because yeah i think you know out of a slight preference we're just like not adding a length and then like making it look like quick because it does seem slightly preferable to me but um and i'm not sure if i understand like why we care about skipping unknown frame types but um maybe there's some use case that i'm missing so um the other thing i wanted"
  },
  {
    "startTime": "01:10:01",
    "text": "bit but like at some point can we get back around to it looks like there's some functionality that on the session layer here um that is per connect stream in hp2 and we when we go back to hp3 like max data and such apply across all sessions which we sort of alluded to earlier today um i'm not saying that either of those are right or wrong but it does seem like the functionality that you're mapping over hp2 is offering is actually a slightly richer functionality when multiplexing than the hp3 version is that correct yes and there's an entire slide in section later we'll talk about this kind of all of the questions we had earlier about pooling and flow control and all of those things are effectively gone when we talked about this but we'll get to that in a little bit okay sorry to start yeah better you're awake it's great victor oh i just wanted to say that in general the landfills it sounds like a great idea for anything that is not super concerned about the size and we're not concerned about the size here so uh it sounds good to uh keep lens and remove the final size all right david uh speaking as participant um yeah my general take here is that since uh this is the fallback transport we don't need to squeeze every single bit of overhead out of it the same way we do for the quick transport layer so having a length seems like a recipe for fewer headaches down the road and once you have a length um i this this is then becomes a segway into your next slide which is this is starting to look an awful lot like a capsule and why don't"
  },
  {
    "startTime": "01:12:00",
    "text": "we simply bingo thank you mt why don't we just use capsules then because this sounds exactly like what you want to do and as a wise mt once said why have another frame type and you know another extensibility joint when you can just use a capsule type and then we register whatever eight capsule types for all these wt frames and we call them wd capsules and we move on um that would be my put here so i think just to make sure i understand you're saying make it a capsule register it don't worry about trying to make the types overlap with quick because we're doing a separate parser anyway and so this is the we're not super worried about making it look like quick just make them be capsules and keep going yes that's what i would say gotcha thanks ellen so the only thing i would say about capsules here is that i don't like all that is going to buy you is a parser that knows how to parse a type and a length and then give you a blob or you know and go to a more specific a type specific parser which you have to have anyway um so i'm not sure that the capsule protocol like that code i'm not worried about either copy or pasting or templating or whatever the parsing of the type and length it's more handling the specific type types which i already have code for in quick and would rather just reuse that that's a lot more code to copy and paste versus like getting out the the type end length or in you know or if we decide we really want length then length and type would be my preference um so right i think what we're deciding between is effectively length then type and keep final size or type then length and cut final size um but it is is final size the only"
  },
  {
    "startTime": "01:14:02",
    "text": "field that would be that is not the exact same as quick i'd have to double check when the sun is up but if if it's not the only one there aren't more than one or two others yeah i mean if it's i don't know if it was the only one it's one bite that you would be sending in an error frame like i just don't i mean i would just keep it the same but other people make different decisions all right david i would just to echo what uh i have and i think empty uh have been saying on the chat uh like given that there are like six frame types that all have like on the order of two to three fields on average uh like reusing the quick frame parser sounds like trying to shoehorn something that doesn't fit so i would very much push to like not have that as a requirement and then just say we have a different uh encoding of the frames their semantics are the same but we can have a completely different encoding like when it comes to processing these uh frames like all the hard part is the stream logic it's the flow control it's the all that machinery which you can reuse the parsing is like you know 0.1 percent of your code size at the end of the day so i would very much push to drop the trying to reuse the quick parser and then things become a lot simpler and it also avoids some kinds of confusions down the road when you have things yeah like final size or others that could you know mean slowly different things i think that makes a lot of sense so i'm i'm hearing a overall lack of concern with having it not look just like quick and then people think it's it's a reasonable thing if it's a little bit different um and that we sidestep any of the negotiation issues by having a length in"
  },
  {
    "startTime": "01:16:00",
    "text": "there and can just keep going all right thank you all next slide please for our next issue as david alluded to earlier uh if we have this type and we're not sticking the length in front to try to do anything cutesy um the thing we were just looking at happens to kind of already be a capsule and so effectively my understanding of what we're doing here is saying yeah previously when we defined these frames we used the exact frame types from quick but now we're going to just register them as capsules and keep going so it sounds like this probably falls out from what we're doing before but i thought we'd stop and talk about it just in case anybody feels really strongly one way or the other so basically assuming whatever is going on in mask we resolve and come to a adequate consensus on for where http datagrams are going what this will end up looking like is you make this connect stream and then you start sending capsules which are effectively just the web transport frames that we've been defining um and we're just gonna say one capsule is one web transport frame effectively types are kind of in this more shared place but otherwise we're good uh and then the other question there is do we make web transport datagram be its own thing or do we just use the actual datagram datagram from http datagram land and i see alan is in the queue i i mean i really i'm not sure what the value capsule brings here even if the format is defined exactly the same it now means we have to register our type the types for this protocol in a global place when i don't know that that it's not like some other protocol is going to want to parse these frames"
  },
  {
    "startTime": "01:18:00",
    "text": "in their capsule handling um nor would we really want to handle their capsules in ours so even though they look the same i don't think they need to be the same and uh if we were saying that it's no big deal to copy and paste your quick parser then it's definitely no big deal to copy and paste your capsule parser and there there's one other thing that comes up there as well we had some interesting conversations around capsules and intermediaries but we're doing all of this over a connect stream already so david's well so i mean not to open up the uh capsule discussion that we are having in mask and that we will be having as part of the uh masked http datagrams design team but um in general um my i think a lot of this comes down to what your plans are for getting across intermediaries um if at the end of the day uh for let's say you know if you have like an h2 to h1 through an intermediary are you saying if you're saying that web transport needs to be done reimplemented on each hop as opposed to it can go through intermediaries seamlessly that kind of changes the outcome here because capsules gives you a the the justification and motivation for having capsules as a shared infrastructure layer is the idea that they go through intermediaries just unchanged simply and so that way if you get on that bandwagon yeah you use the general capsule registry so you don't need to have your own iana registry which saves some work there and then they just you know you put them in your stream they get across to the other side you don't need to worry about things like intermediaries but you know that comes down to if we instead say well transport needs"
  },
  {
    "startTime": "01:20:00",
    "text": "to be re-implemented for each german area especially between h2 and h1 then that is a bit less attractive so clarification question there we're not talking a whole ton about h1 specifically here because we've been continuing to focus on h2 to keep from expanding super rapidly as we type all this in but if i weren't using capsules and i sent connect to an intermediary that then was doing h1 to the back end and it made a sensibly tcp connection somewhere and started sending my web transport frames are you saying that's meaningfully different if we call those web transport frames capsules um the the meaningful difference is that it so first off you're right that like if we're just focusing on h2 it's not as bored but i guess you know if h2 to h2 have an intermediary in the middle uh it's if you're using capsules and we you know i'm waving my magic wand and we have defined a you know generic capsule thing where you tell the intermediary with a simple way oh yeah this is a capsule protocol then i will just be forwarding these to the corresponding connect stream on the up bound connection um then you get that you know forwarding property for free um whereas if you don't then you need a more you know web transport specific uh handling at that layer thank you okay we can also uh have this sit until the design team and mask comes out which is probably something we're going to want to do either way yeah to add a quick note on that our goal is to have that mass design team happen very soon like most likely next week so just this would be a small delay and i think that makes sense um sorry just the last thing i want to to add here is that that what you're describing the like oh i if i need to get the bits from"
  },
  {
    "startTime": "01:22:01",
    "text": "i don't want to participate in this thing and i need to get the bits from one side to the other that is already free because it's on a data stream and that's what intermediaries do right they take data from one side and they put it to the other side and they're not participating anyway they're not parsing these things it's fine the only reason they would ever need to parse them is if they were actually participating in the protocol because they have to understand it anyway um so again i just don't i don't think the only thing i think a cap bringing account even if they look exactly the same and you overlaid capsules here all that would mean is we need to register our type in some other global type and then we i don't know not sure why we care what our type numbers are but like we have the sort of global registry of things that can never appear in the same place all right so it sounds like we're gonna sit on this until we hear which way we're jumping over and mask either way um but let's take some of this discussion onto the issue and see if we can actually write down i know some of what you were just saying um david might be worth putting in the issue so that we have you know something we can refer to later and say okay here's the kind of concrete difference between these approaches all right next slide please so this is where we start getting into some interesting questions where eventually we'll talk about this with http 3 as well so right now as i was saying a minute ago we're kind of at one end of the spectrum in that we've pulled all of these things into that connect stream so there's the you know sequence of data frames that is this web transport session and the lifetime of that connect stream wherever you are on the spectrum is going to determine the lifetime of this web transport session but we're currently"
  },
  {
    "startTime": "01:24:00",
    "text": "we have retracted everything back into that uh into that connect stream and that makes a whole lot of things fall out rather nicely like flow control becomes fairly elegant and a bunch of other stuff pooling is a non-issue um there's all sorts of things that are nice about that but part of how we got here through what we've been calling the web transport framework um is effectively that you know we can have a fallback or something like this but we want to be able to use the native implementation of things the example here being http 3 with http 3 datagrams we want to be able to send actual datagrams when we're over something where the transport does have support for that capability so when you pack your web transport datagram frames into your h2 data frames and send them on your connect stream they're not actually unreliable um they can be unreliable when they get somewhere and you know flow control has some interesting lack of application and so they may be dropped but they're not going to get lost in a lost packet that is not retransmitted so with that said h2 does provide native streams and so if you take all of our words and don't really think too hard about it you could assume okay well if there are native streams even if there aren't native datagrams then we should split out every web transport stream into a native h2 stream and the last bullet on this slide kind of goes to where we are right now which is we didn't actually do that because there didn't seem to be significant benefit from doing so so if anybody feels strongly that we need to do that now would be a time to speak up but unless somebody can see a significant"
  },
  {
    "startTime": "01:26:00",
    "text": "benefit for us doing that there's obviously benefit for doing that for datagrams but for streams themselves it doesn't seem like it it really helps one way or the other and there's all sorts of nice benefits to having them inside the connect stream all right we'll take that as a happy moment next slide please so we have an issue in github and i think this is one of our last ones here that we're going to talk about but we have an issue in github to write up um kind of how flow control works with this whole thing um and so i wanted to just kind of talk through that and make sure that everybody's comfortable with where we think we are um and how this is going to interact with some of the pooling so you end up with four nested layers of flow control which is rather a lot but does mean that each concept and each kind of scope if you will uh gets its own level of control and you can do exactly what you want so i drew a picture for this on the next slide in case it's more interesting so if we go there so this is kind of the diagram from earlier but i squished the two of them together and if we advance one more slide i added some pretty colors uh so you effectively have flow control where there's you know the h2 connection that's governing everything across all of h2 that's uh useful for saying you know here's how much you can send across all web transport sessions that are going on then there's the connect stream itself um and so that one you know contains an entire web transport session"
  },
  {
    "startTime": "01:28:00",
    "text": "and that allows you to limit the amount of data for that whole web transport session um and that's especially useful when we talk about cooling and things like that right so those kind of outer two boxes are the things that allow you to have multiple web transport sessions and express the relationships between them um then the next two colors are within a web transport session you have the kind of overall session level flow control which is analogous um to what quick is doing or a little bit like what h2 is doing which allows you to control the total across all of the web transport streams um and then each stream obviously has its own flow control so that ends up being a lot of flow control but with all of that possibility to potentially screw things up you also have the ability to control all of these relationships between the different things and you can have multiple web transport sessions and they can all be pooled and you have limits on the number of streams that can be established both within web transport streams and within h2 for the connect streams um so without a whole lot of extra effort or anything like that kind of the existing model that you're using for h2 and for quick um applies respectively here um and much of the pooling questions become moot and we continue on our merry way so the current proposal here is we're going to write up a bunch of text that describes how this works to help people go in eyes wide open and make sure that we avoid any of the kind of common pitfalls but unless folks have strong objections or feel strongly that this should be different it seems pretty workable and in the absence of anyone in the queue we'll take that as being workable all right next slide please"
  },
  {
    "startTime": "01:30:03",
    "text": "so we have an issue on github for doing some error handling to which the initial response is yeah we should probably do that so the existing draft we did not import all of the error handling from quick that goes along with these frames and so we have kind of an outstanding item of we need to import that over but we wanted to talk a little bit about the shape of how that should look and interestingly we had a conversation in h3 earlier this morning about go away and some of that for non-error cases next slide please so we could bring along a go away here we've got a way to reset individual web transport streams already we've brought those frames over so effectively we could pull over the closed web transport session capsule this is the one from h3 we could just bring that over and say it looks the same in h3 as it does in h2 there's a bunch of different ways we could shape this so the real question here is do we want this to look just like we do in h3 do we want to borrow things from how h2 handles some of these things where do we want to go alan uh yeah i mean this may also depend on where things go with capsule um so whether or not we want to reuse that thing so i don't know"
  },
  {
    "startTime": "01:32:02",
    "text": "i think that makes some sense if if we're sharing capsules with h3 and especially if we start using these capsules over h3 in some cases the benefits of sharing those goes up significantly ian seems like this the same question is very relevant to the hp3 mapping so um as much as possible shouldn't we make sure our answers for the two are similar or should they not be similar and um i don't know yeah thoughts i think that makes a lot of sense i don't have any strong reason why they shouldn't be similar which in my mind is usually an indication that they should match martin but you want to see what here one is one is that things have gone poorly and you want to tear the whole thing down which is the thing you send before you close the stream and the h3 web transport thing already has that we should have the same thing and if we're using the same format then we should use the same message uh just makes it easier to forward these things right they're end-to-end signals um again the same applies to the go away discussion that we have previously so uh let's work out what the requirements look like uh see what airline comes up with with respect to to go away and then we'll we'll take it or not i think that makes a lot of sense so we're gonna effectively import whatever we end up doing in h3 and our discussion earlier was super relevant to this victor slight question about the slide what does mean web transport over h3 shares our space with h3"
  },
  {
    "startTime": "01:34:04",
    "text": "so there's some text in the h3 document right now or at least the version i was looking at when doing some of this um where we take a error code and apply a transform to it to be our actual error code because we needed to put those errors in the same registry in space as the other h3 ones so note this is a different error code this is for resetting streams not for resetting the streams inside with transport the closer transport capsule is for resetting this session yes so i guess the question i would have is uh this is does this issue cover both streams and sessions or that's that's not something that we've been super clear about but i think the the short answer is yes um we've we need to be able to to uh remove a stream and we need to be able to say this is very bad you just uh you know did something that doesn't align with the spec or or broker requirement that i had and the whole thing is over and we're not going to be talking anymore so this this issue i think the original intent of the issue was was for the i need to tear down the session um but we need to have the ability for people to do both and we've got that pretty well spelled out i think for streams but obviously we shouldn't jump in one direction strongly for streams in a different direction strongly for the session uh okay it sounds like i need to take a closer read on the issue"
  },
  {
    "startTime": "01:36:00",
    "text": "uh thank you all right so it sounds like we're gonna see where we wind up for h3 getting rid of the whole session and then import as much of that as we can which seems totally reasonable right next slide please this is our overall discussion of any h2 things assuming that there's nothing major that anybody wants to bring up for h2 specifically we can move on to the next bit all right so this is kind of the last section of this which is i think what ian was alluding to earlier um next slide please so of what we just did in moving to this more layered model where we're using web transport frames on top of http 2 rather than adding additional frames into http 2 is we have now defined a way that you can use http semantics with ostensibly any http version not just http 2 to communicate via web transport frames uh with the other side and we've talked about how that works really nicely with flow control when everything is kind of retracted back into that connect stream or that connect exchange message and we've also talked but not actually done a lot about being able to split out to use native features like datagrams in h3 and maybe not doing that for streams in h2 but you might choose to do that for streams in h3 because you wanted some of the benefits that h3 provides around you"
  },
  {
    "startTime": "01:38:00",
    "text": "know blocking between streams and that sort of thing which doesn't exist for h2 and so the the question we come back to is should all of the mappings of web transport be doing the same thing in other words should this be the generic set of web transport frames that you can speak and h3 might break those out into datagrams and streams and otherwise look very similar to what it does today but should that be a version independent thing and if we go to the next slide please try to capture a little bit of why we might want to do this or why we might not want to do this but i think there's there's kind of two things going on that are a little bit in conflict one of them is uh that if you are going through an intermediary being able to do this you know using hp semantics to talk to the remote end allows you to ignore much of the pooling questions it allows you to go through an intermediary really nicely because you're just sending web transport frames um in h2 you're just sending those inside of data frames um but that your intermediary can go from h2 to h1 to h3 and back again and you don't really need to care i mentioned already pooling becomes much less of an issue because all of the limits about how you handle streams are fine here but then there's also some drawbacks to this approach which are if you've retracted everything inside of this connect stream um pooling isn't an issue but that's at odds with splitting out datagrams and splitting out streams and if you split out the datagrams and just let out the streams now you have to deal with the pooling for them again um and the real thing that i think gave a lot of folks pause is how do we negotiate which one you're doing like if i'm implementing h3 do i suddenly need implementing web transport over h3 like do i suddenly need to be able to handle web transport frames coming in on a new"
  },
  {
    "startTime": "01:40:00",
    "text": "h3 stream and on the original connect stream that that's carrying the lifetime of the web transport session and that's kind of annoying and like could the same web transport session do some things in one place and some things in the other place or do we negotiate that like i'm doing this in this mode um where do we want to go from here so i believe the next slide is just a discuss slide yeah so if we go back one just so we have our kind of pros and cons things where do we want to go with this like we don't have to touch h3 at all but there is some architectural elegance to having the same thing that is version independent and the mapping of it onto h3 provides these native capabilities um and it happens to solve a number of other issues so i'm going to hand over the q and the mics to the chairs here because i think this is a little bit larger than h2 and something that we need to talk about as a whole group so i think martin yeah just a time check this is the remainder of the session now uh yes the chairs will want to save like on the order of five minutes at the end for wrap-up but this is the rest of the discussion that we were thinking of having today sure that's it this is this is a great discussion to be having i think that we should be talking about this so thanks for bringing it up eric i raced an issue on one of the repositories today on exactly this topic i think it'd be really nice if the protocol that we define here could go over http 3 but i think it's also a reasonable position to say that if you've got http 3 then you must use datagrams and you must use"
  },
  {
    "startTime": "01:42:01",
    "text": "the native quick streams for transporting the stream the datagrams and streams across that connection simply because it is much much easier and also because it provides the sort of performance guarantees that we're looking to provide from the protocol this really does exist primarily for the purposes of integrating with the quick capabilities and not not just sort of serializing everything which i think might have some surprising consequences for for things but i do think it would be nice if the if the protocol was defined as the one protocol with the http 3 draft effectively just describing the the way that the streams and datagrams are lifted off into those native capabilities uh my uptake is that we should not require servers to implement with transport over h2 if the only protocol they're interested in is web transport over h3 and the reason for that there are servers that would be only interested in web transport overage free or web transport in general if they can rely on quick performance guarantees uh and because of that me they are that would mean they're not really interested in other versions of web transport and this would effectively require them to implement twice the code uh that's my opinion on this matter yeah i also if if we're allowing"
  },
  {
    "startTime": "01:44:03",
    "text": "um if they're the same protocol and h3 receives the frames that are only allowed on h2 then it has to have sort of error checks to like say no you can't send wt stream this is h3 sorry um i mean and except for the right so right now we would only have one shared message between what you can send on the h2 connect stream at h3 which is the closed web transport session maybe they'll be go away maybe we'll come up with some other shared things that don't map to any like native h3 semantic um but i'm inclined to say you that they're that they're different and uh you can't i mean you you don't you can't speak those each two frames over an h3 connect stream um and we should just make it not possible to do so yeah i think that could make some sense i martin's proposal is kind of attractive which is you could almost do a slightly modified version of that you could almost do the same um or at least where they overlap the same set of things but require them to be split out into streams and require them to be split out into datagrams when you're operating over h3 um and i think that would address victor's point which is where at that point we wouldn't be asking people to have to implement both you would implement one thing which was this is how i speak web transport over http semantics and if you chose to only support h3 that would be totally okay you would send those things over http 3 streams and over hp3 datagrams and if you chose to also support h2 you would take effectively the same things and bundle them up in uh you know a connect stream in data frames and you'd have that for free but"
  },
  {
    "startTime": "01:46:02",
    "text": "we wouldn't be asking people to actually support two things i think architecturally in words that sounds really nice but in practice allen just pointed out you know it isn't a 100 overlap because a lot of the things that we're trying to provide with the web transport frames over these data frames in h2 are things that are already available natively in h3 anyway and so you know we could write a lot of text about how that's kind of a null mapping and it's all really the same thing underneath but at that point we're just calling it that because it sounds nice um they could just remain separate things that don't actually overlap and i don't know that that would upset anybody uh what so conceptual is the way i see web transport is web transport is it well the overview draft is called web transport protocol framework and what web transfer fundamentally provides it provides a model of how you interact with a remote server and that model is fundamentally based on quick that is to say uh my idea of how this works when i started writing the web transport overview and work transferred over free draft when we first adopted was that there is this model of that web transport has streams and datagrams and then web transport over http 3 and web transport over http 2 are implementations of that model uh but the level of abstraction is not on this frame remapping which is just something that kind of naturally emerged for those two yes cases but the level of abstraction is fundamentally the streams and data groups model"
  },
  {
    "startTime": "01:48:01",
    "text": "uh and the i think there is a value in that uh because this is on some conceptual level is a very clean model so i think if we if we said that you weren't allowed to speak the h2 version over h3 you know the feature you would you might lose is if for some reason you had a client that was talking h2 to an intermediary which it must have advertised web transport over h2 support but it didn't really want to go to the trouble of looking inside the data stream and it's speaking h3 upstream to a web transport capable h3 server so now that proxy has to do the translation it's kind of what martin pointed out in the chat like it has to parse that data stream and pull all the things out and um and translate it for that upstream h3 but i think that the converse requirement would be like the proxy can be dumb and the server has to do it is like it's probably worse so my my fundamental argument is if we are talking about cost as a proxy versus prof to the server i would focus on offloading the cost of the server because the servers are typically individual web developers and part of reasoning behind the web transport effort was making life easier for them"
  },
  {
    "startTime": "01:50:02",
    "text": "sounds like what we're saying is that we're totally okay if these don't look like the same thing um and we'd let we we'd let any intermediaries have to deal with translating between the two and pooling works great right up until your intermediary because you have a bunch of different connect streams um assuming that you know h2 is is the leg that faces the client and then upstream depending on what's going on with pooling there and how we choose to solve that in h3 it's possible that the intermediary needs to make multiple h3 connections upstream um and vice versa you could have a client that's speaking h3 to an intermediary would make multiple h3 connections and then those might be shared over a single h2 upstream which seems not unlike how we do other things just one thing that brought to mind is that the you know the stream limits can just be different on different sides of these things and this is not an h2 to h3 specific problem it exists even with pure h3 or pure h2 intermediaries and it it was sort of all it was true in h2 sometimes with push where you you'd have like an upstream server that was allowed to create a push stream but then the downstream session didn't have any push streams available and so you kind of had to handle this this case but it might be sort of hairier in web transport where it's not directly related to this issue but since we're talking about intermediaries it's just a potential mismatch"
  },
  {
    "startTime": "01:52:28",
    "text": "right thanks eric bernard could you go to the like chair wrap-up slide please um [Music] yeah well we have eight minutes left uh if someone has something that they think could be useful to discuss in like under five minutes they should come up now otherwise we're gonna wrap up and give some time to uh roam the hallways and eat some extra cookies um so uh thanks everyone for coming to web transport we had some good discussion on quite a few issues uh we do realize that we are a bit blocked on the mask work with you yours truly will work hard to resolve that as quickly as possible um and but otherwise um yeah thanks everyone for coming uh we're making good progress and we're looking forward to you know having this in in a shape where we don't move quite as much bernard any other words you want to add uh yeah just to note that web transport is available now in chromium so you can actually this isn't just an academic discussion you can actually play with it and in particular some of the quick media over quick stuff um you know we have all the apis now for people to actually build things so it's not just an academic exercise it's out there yep definitely uh spencer go ahead"
  },
  {
    "startTime": "01:54:00",
    "text": "i just wanted to say that uh james and i uh have had pretty close notes to the discussion but uh if people could take a chat take a look at them and see uh if we're massively misquoting anything i think we have question marks on everything that we didn't get there's only about two or three of them but i just wanted to let the chairs know that okay cool thanks thank you spencer all right and uh we wanted to especially thank um alan for the jabber scribing which didn't wasn't required today but thanks for keeping an eye on that and thanks also to james and spencer for the work on the minutes i've been keeping on them and they look absolutely great thank you so much for taking the time to do that we really appreciate it um okay uh that's all folks and we'll see you on the mailing list to keep discussing these issues um otherwise um see you in march at the next atf if we if we don't have an interim before then okay thanks everybody bye"
  }
]
