[
  {
    "startTime": "00:00:02",
    "text": "When you lay on to menu, you're Oh, yeah. It's very Israel. About that. For him. I know. A week. It's a dangerous game. Hi. Very last meeting in response to a due for any Right? Is not a fun that time? Yes. Take my suggestion to Hawaii here and then just draw on them and then back No. To where we are. I think not. So we need your tie breaker. Yeah. Food. What are what are the trends? I don't"
  },
  {
    "startTime": "00:02:12",
    "text": "Okay. That's what your I don't know. Because it it is actually it and have I may apply. No. So that's, like, the easy part is not quite some kind of well, I mean, how do you won't do anything to effectively now I can start, like, Yeah. Play them Coastin to I 20 minutes ago. You know, you get the nice shape. I I don't wish if I understand if you don't care about on that question because that leads to, like, I mean, it's like, aren't just like that. Okay. Alright. Oh, yeah. Box. No. No. And"
  },
  {
    "startTime": "00:04:02",
    "text": "We should Yeah. Because like, Yeah. Yeah. Yeah. Oh, is that different? Maybe. Yeah. I, like, I asked I'd okay. I didn't the have did it say? Okay. Let's let's check. It'd be worth actually checking. Alright. That the machine is we don't don't It's not loaded. Not really. Quick. Yeah. Reset to open address validation papers. Yes. I don't know if you saw Oh, no. So, we're like, you're just good to call out. Yeah. It's pointing. Alright. I did that on Sunday already. Yeah. All really bad right now. So RFC 9000 assumes that the server can always because It says if the plant is coming in the initial one with a recent move. It won't process. So we'll reset this Alright. new Welcome to MASK. Before we get started. Who wants to take notes? I thought that would quiet the room down. See you've got a thing. Yeah. Alright. An active excuse. An intent laptop screen, anybody like to volunteer to take some loose notes here. Yeah. And and so"
  },
  {
    "startTime": "00:06:09",
    "text": "We've got Brian for backup notes. So whoever wants to do notes will have Brian is an awesome note taking partner. Schedule Thank you, Brian. Got this. You, Mark. I mean, it sounds like yeah. We'll try to keep it. Fairly straightforward. Wonderful. Thank you, Martin and Brian. Okay. Let's kick things off. Welcome to mask at IATF 119. This session is being recorded. This point in the week, you likely know how to join the queue and leave the queue. If you haven't yet, make sure scan the QR code if you're in the room so that you can actually speak at the microphone. Also helps us take attendance and fund things like that. You've also likely seen the note well These are the terms under which we do work here in the IETF. Please make sure that you actually read it. I know we tend to breeze through it in the slides, but there's a reason we put it up at the beginning of every meeting. And we also operate under a code of conduct in the IETF. So if there's ever a concern, please make sure that you come to the chairs. You can contact the ombuds team. You can talk to an AD. So there are definitely resources to make sure that those concerns are addressed. We have some helpful links here, which are probably more useful in the PDF form. And we have an agenda for today. So thank you, Martin. We've got scribes. Would anybody like to bash this agenda? We're gonna start with our working group documents. Ideally make some good progress on each and some of the remaining issues that need to be resolved. And then at the end, we've got a, preview of potential new upcoming work which an extension that we talked about previously but had deferred"
  },
  {
    "startTime": "00:08:02",
    "text": "due to lack of need, for which apparently a need has arisen. With that, let's start with Tommy and Eric. Just Tommy. Firms your selection. Alright. Hello, everyone. I'm Tommy Pauley, and I'll be talking about draft on our quick aware proxy. So this is the extensions to connect UDP to optimize things for quick, mainly around allowing it to do forwarding mode to skip extra encapsulation. So this is coauthored between myself, David, and Eric Rosenberg, and fortunately, Eric Rosenberg was unable to make it to the meeting. Due to schedule change. So he will not be presenting. So you'll have to forgive me for the second half of these slides, where I am less prepared because I was not planning to present them. But go with it. Alright. So what are we gonna talk about today? First, I'll just quickly recap what we're talking about here in case you haven't been following along. Then most important things are we have the design team that we'd had for quite a while that was working on how to add, encryption to the forwarding mode, And, hopefully, we can converge on, closing that design team today. Would love to see that. And then we also have our other major issue, from Martin Duke that is our loop issue, and hopefully we'll have a way forward there also. So help us along here."
  },
  {
    "startTime": "00:10:03",
    "text": "Alright. So as a, brief recap of what we're doing, So we have Connected UDP, The client, tells the proxy extra information about the quick connections it has, specifically the CIDs and, the proxy knowing about what CIDs are being used between the client and the target. Allows it to do fun things. It allows it to reuse ports and use connection ID demultiplexing it allows you to say Hey. Our outer packets look all like quick short headers anyway. Let's just not re encapsulate them and have them all on the outside and avoid extra overhead of losing our MTU there. And so that's referred to as forwarded mode. And then in the current version of the draft, we have a notion of virtual CIDs, which are The CID is used between the client and the proxy, for the packets that are indeed then forwarded onto the target. But, spoiler alert, the rest of the packet, is being forwarded is not modified. Yet. So here's a basic look at one of the ways you can use forwarding mode. In terms of how we use mask for private relay when we have 2 hot proxies, What we do is we do forward in mode, across the first hop proxy, and then kinda terminate the tunnel at second hop, then the second hop does kind of full tunnel mode all the way to the end. And then leading into the issue that we're trying to fix with the design team, The concern which is very valid, is you are using forward in mode, it is a lot easier to have someone passively observing both sides of the proxy And even though the connection IDs are changing,"
  },
  {
    "startTime": "00:12:01",
    "text": "you can recognize the content of packets on both sides. And then and and for more information about where it's going. In some cases, like, when you're just having long chain of proxies, that's relatively, deterministic. That may not be interesting. But it's not a great thing, to be forced to leak. That's what the design team was looking at. Alright. So we had, form the design team to analyze the threat of track traffic analysis on forwarded mode, especially when compared to the normal connect UTP tunneling, and to propose a mechanism for adding encryption when you're doing forwarding. So there is a pull request out Polarcrest99, You can go look at it if you wanna see the whole content, In the GitHub, it has, like, a rendered view so you can, like, look at it in the pretty form. So the overview of the solution is there's a notion now of packet transforms. That are negotiated when you are going into forwarded mode. And we define specifically a new transform called the scramble transform. It uses AES 128 Block ciphers, and it scrambles up. The bids, and I'm not gonna put all the details on this slide. You can read it in the pull request. We believe it works. Thank you, benchmarks, for figuring out all of the bits we should do there. This means that on when you look at the packets on both sides of the proxy, They do not look the same. Note that this does not solve anything about packet size or packet timing analysis, which is a also a very easy way to do correlation, but that is a problem, that goes beyond this particular area. And so the goal is to prevent passive byte recognition And, you know, some of these other attacks that you could have that are passive,"
  },
  {
    "startTime": "00:14:00",
    "text": "around timing. You also have with any kind of normal or naive implementation of emling, And we also note that various active attacks of cases where you're able to drop packets or inject packets, or or, duplicate packets. Allow you to learn about the correlation of a flow on one side of the proxy and the other side of the proxy Regardless of doing forward in mode or not, regardless of doing scrambling or not. If you just wanna see how the transforms are negotiated. Essentially, it's this little bit in bold. Got modified. Instead of just having the header that says I do forwarding, we add some transforms about this That transformed to you. Support, we're renaming null to identity Thank you Martin for a teaching us the correct pedantry around, I'd, transforms. You're absolutely correct. The identity transform is the right one to do. The no transfer would make everything 0, not a particularly useful packet forwarding mechanism, but, Yeah. I guess we could define that one too. It's just has a very, very low throughput. And then we have a key that you use for scrambling. And then on the response, the proxy can say, yes. I also support scrambling And here's my key that I use. And As I've mentioned before, when we've talked about this overall protocol, Both the client and the proxy have to agree to doing any type of forwarding mode or any type of transform. Otherwise, you are going to get your normal tunneled mode. So if you don't wanna do this type of thing, don't do it. You don't have to do it. It's fine. Okay. Just noting that this proposal doesn't have an explicit transform that allows you to add padding or chaff or other timing things,"
  },
  {
    "startTime": "00:16:03",
    "text": "talking in the design team, I believe, you know, it is possible and certainly doable that we could define other transforms that would allow you to both scramble and add padding But, we agreed that essentially, like figuring out the right schemes for how to add half or timing to really stop traffic analysis is a much bigger research project that is not appropriate to try to stuff into this document. And so that is, extensibility work that new documents can handle. Alright. I see we have a queue. Do you wanna go to it right now? Happy to. Right? Yeah. So this is this is a clear question here. I think I think I might be restating some things that you just said, but maybe also not because it's quite earlier. So a transform is capable of taking a if capable of mapping m input packets to n output packets. Correct? It's not like a one to one mapping between the input, like, for every packet that's incoming, I don't have to generate exactly one packet outgoing. Correct? Correct. The Okay. The transforms that this document defines r one to 1, but there's no requirement that all transforms would be 1 to 1. Cool, then we can let this be. Future us's problem. Exactly. Thank you. Great. Great clarification question, though. A good point out. Martin. Martin Duke, Google, no hats. So it seems like it is true that even in tunnel mode, you have to, like, design stuff. But with tunnel mode, you can simply add padding. Yes. Whereas I mean, I I haven't read the PR, but it doesn't sound like you can sort of arbitrarily add adding to, like, the core pack it, or maybe you can. Can you? That the proxy cannot."
  },
  {
    "startTime": "00:18:03",
    "text": "Like, I mean, the the yeah. You you you can't you can't add adding that is only added on one side Yes. Right. Which is not the case in telco. Right. Of the party. Mode. So this seems to be a bit of a downgrade in terms of your ability to obscure stuff. Right. Correct. Okay. this you stick to If if transform, think, like, our analysis was it's pretty trivial. To design a transform that lets you do that, We just aren't specifying it here because the way to use it correctly goes Far beyond what we want to say. Alright. Fair enough. Thanks. Potentially pointing to Like, I don't know if it's, you know, engineering work. It's more almost more like research work someone should talk about how do you do Good. Patting, chaft techniques for these types of tunnels and actually analyze the impact on and liability. Okay. So next steps here. Actually, we've already merged a couple PRs against the design team PR. So we renamed Knowles Identity. We added some extra text into the security considerations, talking about the active attacks, At this point, I think the design team is happy. I'd like to get the chairs to, like, close our design team, maybe get consensus to merge this design team PR into the document so we can move forward. Do people think? Barring. Mark. Anyone hopping into the queue? Oh, hello? Not gonna be that easy. It's a hike, man. You should move it up to tell the big big room. Just because I haven't double checked. Can we repeat transforms? Can you what? Can you repeat transforms? Can the client say I accept this set of transforms, presumably they advertise a set of things. Can the service say I would like you to"
  },
  {
    "startTime": "00:20:00",
    "text": "transform using the scramble transform 5 times. Now that doesn't that one doesn't make any sense. But what if it's something else? I don't think the semantics of this Allow that. What what what what are you imagining? Can here? I can I jump in Please, Ben. So the the the semantics are modeled on the accept better. So the answer is currently no. Yeah. I think that would be a mistake if you're talking about the sort generality that, Brian was asking about. Because there's always the possibility that you might have sort of compositions of transforms. So you have a simple transform that you can can compose. That does make things more complicated though. Great. Because you could also just define, like, scramble pad. Scramble plus this. It, like, just have, like Right. It it becomes a combinatorial explosion, but at at something might be easier to deal with than saying, have to apply this transform, then this transform, then this transform. Correct. Because, realistically, I imagine there's going to be sets of Overall transforms, which may themselves be composite in a way that are like, this is a thing that makes sense to do in a deployment, and we don't need arbitrary composition. Yeah. So one of the compositions that I mentioned, you might Find interesting is Please please put a length prefix on the front of this thing. And then the next transform is please take 3 of these and jam them in the same packet. Yep. Yep. Yep. That sort of thing. So, you can have this arbitrarily complex, but it sounds like We don't want that. We just want 1. I think you even said we would define a complex transform that would know how to Pack. Packets. And the proposal there is that would just be a differently"
  },
  {
    "startTime": "00:22:01",
    "text": "transformed for the corporations that make sense. Thank you. Correct. David. I'd David Skkenazi, plus one to what you both said. Okay. Thank you. May I could have been just to clarify. I think we should actually say you can only apply one transform. Yeah. you But, actually, that brings me to another question. Can apply you can only apply 1 transport to 1 packet, but can you somehow apply different transforms to different packets for whatever reason. I don't know. So so, you know, transforms come along with Other parameters like scramble comes along with the key. So I certainly imagine you you could have, like, Random chaff transform, or, right, random padding transfer that says you apply this algorithm for creating these size packets and not every packet will have the same padding attitude. Like, they may there may be some randomness in there, but that is a property of the transfer as a whole and maybe their parameters the transfer that tell you to how to generate the correct patterns. Yep. Many answer. No. You always Apply 1 transform to all packets. That's it. Yes. Great. Good good clarifications here. Alright. So it sounds like we think we're ready to potentially barring any additional feedback this week. Let's run a consensus call against the output from the design team and then merge that. I'm seeing some thumbs up from some of the crowd. With that, I do also wanna say thank you. We had a nice pile of about seven people who are working on this design team. So thank you all for the extra time and energy to go away and then solve some of this in a way that's harder in a larger group Cool. Alright. So we will we will run a consensus call on that. And then assuming that we end up in good shape, we will close the assigned team and thank you. Send you on your merry way. And I'll I'll I'll point out, That, you know, of course, this is Not the end of this document. Like, there's this is just, you know, to merge it."
  },
  {
    "startTime": "00:24:01",
    "text": "Oh, and one of the things once we merge this in, I think we need large editorial paths to make things much clearer, that this is in here and kind of rewrite the flow, So, I'm eager to see this merged in so we can try to rearrange the whole document and make it much clearer now. Great. Speaking of next some of that. One of the other questions that's come up is kind of implementation status. Is there anybody who'd like to waive their hands or pipe up in the chat that they either have an implementation or are thinking about having an implementation I see some hands. I see some hands. And I see a head. Yes. like, So now I I think at this point, the implementations I know, Ericsson, we, and I guess, David, like, Have the current draft? Don't know if anyone's done that transform yet. Right. have? So I think the next you you Oh, great. Awesome. So they had it pulled. So, yeah, Marcus said that Erickson's implementation implemented the transformers in hackathon I still need to catch up on that. Let's let's do interrupt testing on that. Great progress. Thank you. Gwixlandtacathon. Okay. Moving on, just wanted to talk about one more issue on the document, which is loops, loops So If you haven't read the issue, you can go to issue 88. I think this is the one that Martin Duke filed. Clients could be evil. If you have, like, a long chain of proxies with forwarding going on they could craft the, virtual client IDs they're using to cause infinite loops. Between proxies when the proxies share a, client facing IP address with other conceptual proxies or just kinda like themselves, So and this is also dependent on proxies reusing their sockets, their five tuples when they're forwarding traffic. So essentially, they"
  },
  {
    "startTime": "00:26:03",
    "text": "are unable to distinguish kind of which stage of forwarding their in. And so, Things blow up, it's bad. I don't think anyone has actually, like, built a scenario like this yet, but it definitely possible. We don't wanna build a little time bomb here. And so, again, these are not my slides. This is Eric Rosenberg's thing, but I'll try to speak to it on his behalf. So he's opened up a PR on this, I think Yeah. So he's opened up a PR that tries to solve this with 1 of the approaches, I think the issue list a couple different ways that you could handle this. And the solution in PR 104 is to say that the virtual client CIDs. So the virtual CIDs that are used in the direction between the proxy To the client, that those need to be chosen by, the proxy. And today, they are chosen by the client, which is A nice thing when you think about, like, oh, you get to choose the CID that you receive on. But in order to avoid the loop, having the proxy choose that during the negotiation, is one way to break this looping problem. So the main question is, like, are we okay with this solution? Does add a bit of complexity, like there's so we we use capsules to negotiate all this stuff. Anyway, there technically is, like, another capsule you need to do because so today But with that before this, we have the client registering its CID. Say, Hey, I've told the target that I'm gonna receive on this connection ID and here's the virtual connection idea I would like the proxy to send to me on. And then today,"
  },
  {
    "startTime": "00:28:03",
    "text": "the proxy would just say, like, yes. I see that virtual CID. I will use it. In this variant, the client sends you it it's real CID, and then the proxy determines the virtual CAA to use. And then the client needs to acknowledge that virtualized CID and make sure that willing to receive on that it does add a little bit of complexity there. However, The nice thing is that this doesn't overall add any back and forth to the number of round trips that you need, to get to forwarding mode. Because you already had to have another round trip to negotiate the target CID once you learn what CID was selected by the target. So it adds complexity, but it does not add time. It's just you know, number of bytes that you need to process and an extra check to do. So It's not like super, elegant, But I I think it's It it's the clearest solution. It's the most tangible solution we have to this problem right now. What do people think? Alex. Alex from Hopsky Google. Sorry. Clarifying question because I seem to recall the last time we talked about this. The problem with the solution that I seem to remember us having is this would work except for the part where we can't ensure the client actually uses the proxies chosen connection ID. How are we ensuring that the client actually uses connection ID that the proxy says it should use. So this is the connection ID upon which the client receives packets from the proxy. Right? So The client has told is, you know, real CID to the target. So that that's fine. Right. And this is just like when the proxy receives A packet. To that real CID. Now it's gonna apply the transformer. It's, you know, it's gonna scramble all the bytes. It's gonna slap a different CID on there. The proxy is saying, I'm going to put this other CID. On your packet."
  },
  {
    "startTime": "00:30:00",
    "text": "The proxy chosen Virtual Connection client ID. So the client doesn't really have a choice. The client can acknowledge, like, yes, I'm willing to receive on this CID, and it could like, no, no proxy, like, this is not good for me. It conflicts with another CID I have. But the proxy is just gonna send on it. There's nothing about, like, the client not using it correctly. But but what's stopping a client from sending connections sorry, sending packets with that contained connection ID and thereby recreating blue. You only receive so this is only applicable to short header packets. So this is only downstream. Okay. Thank you. Yeah. Yeah. Yeah. So I I think, like, overall and correct me if I'm wrong, Martin, the the loop is downstream packets. It's like, I like, the client sets up the virtual 380s such that when a a server is start sending something, it ends up just like spinning out of control. Oh, right. I haven't thought about this in a couple of months, but if I recall correctly, since the client essentially, if you have a daily chain of proxies and the client is essentially essentially setting all the virtual CIDs in the entire chain in both directions. For hop n Prop n plus 1. It says use this CID to send the hop in. It tells Hopin you will receive a I this other CID for this loop c But And plus one is sending from, like, a pre from a from a different a different hop in the path. And so and gets confused about where it's receiving it from. So you're essentially telling two proxies who are talking to each other in the chain, giving them different CIDs to use on a particular Truill Lake. That's where this arises. If the If the downstream proxy is not getting that from the client that should solve it. Although I should probably read this and think about it some more. Seems like it would solve the problem."
  },
  {
    "startTime": "00:32:01",
    "text": "I I don't know if there's an issue if anyone has a deployment or client CIDs are important for routing or not That would be the only real problem I could see on the face of it. Right. Marya. Yeah. I just have a question. I used Are you just applying this if you believe there's an or when do you even use it? No. This would This would change what you do all the time. All the time. Okay. Which, you know, it it adds a capsule, but it doesn't add time. So Yeah. I I I think from from the perspective, like, you know, on the client, because I I think mainly the complexities for the client to have to now accepted virtual safety from somewhere else. You know, practically, at least in our implementation, like, you only set up the the mappings and, like, the forwarding rules. Once you finish this entire negotiation anyway. So It doesn't really change too much. Just like where the bytes come from. Martin. It's so long. Hello? I should just move. So Does does this create a situation where the, on on the virtual connection ID side of things, the client chooses the connection ID that it sends within the proxy chooses the connection ID that it sends with. Which is the opposite. No. In the it creates the the scenario now where the proxy chooses both. The Because today, before before fixing the loop, proxy chooses both. thing. Client chooses what it receives on the proxy chooses what it receives on. Standard quick. This modifies the steps that the client no longer gets to choose what it receives on, or rather it gets to acknowledge it. It gets to, like, argue about it, but doesn't get to actually choose strain your client Yes. Port allocation strategy. Yes. It does. Yes. That that is the trade off. Of this. And so it's like,"
  },
  {
    "startTime": "00:34:04",
    "text": "how painful is know. That that's why I don't think this that constraint? I elegant, but I don't know a better solution. So it's Kinazis. Just for what it's worth, it's a mess kind of in all cases because, conceptually and quick. Does any endpoint chooses what connection ID it receives. But the second you start doing connect UDP, and you proxy the clients packets are now popping out of the proxy. So in regular we don't have that problem. But with quick wear, now you can have the Clients packets come out of the proxy's address, and now the client is picking the packets that go to the proxy, and that's the case here, even before the attack, So whichever way you look at it, it's It's gonna be wrong one of the ways. Absolutely. Even without forwarding, When With forwarding mode, we have this bug as well. Yeah. But even without forwarding, like, when a connect UTV proxy is sending packets up, like, It's receiving Package on a client chosen Connection ID, It's just dialing a quick connection. There. It's just a UDP socket. That that's right. But if you the second put forwarding mode and you merge the you two sockets on the proxy. The proxy now gets packets from the target to the proxy aimed at the client using the connection ID chosen by the client for that landing on the proxy. Just to be very nitpicky here. It's not not when you enable forwarding mode. It's just when you enable quick aware at all. Right? It's like, the moment you tell the proxy here, my CIDs, I'm letting you know how to do socket sharing, port sharing, That is based on client chosen CIDs now at the proxy. I'm yes. I'm realizing that maybe we should I don't know if it warrants a design team or at least a smaller group because this is enough of a headache that we might wanna take it offline. Yeah, man. I think this is a good solution. What it makes me realize is that the the ugliness that we're adding here is actually just, like, payback to the clients Right. Because the the the proxy already has to deal with"
  },
  {
    "startTime": "00:36:03",
    "text": "receiving client CIDs, and now the client has to deal with receiving proxy CIDs. So Oh, yeah. Okay. Alright. Mary is in the queue. You have one more question because I probably didn't read the PR. Doesn't can that not lead to conflicts for CIDs at the client side. It could. And if it did, you would you would instead of acknowledging the client BCID, you would close the client CID and say, sorry, I can't can't forward like this. Okay. And then you might open a new connection start over again or whatever. Or No. Or you you just say I just keep on tunnel mode. Like, it should be very rare. Ah, you okay. You can stay on Tana Mobile. Yeah. Exactly. Like, until this finishes, you you have a working anyway. You're just not forwarding. Yeah. Okay. That is the end of the slides here. Read this PR. Chime in on the issues. That's it, Martin. Yeah. So, just one last clarifying question And so, we've been saying, oh, you know, clients can't route by CID. Is that going to be a so this is also true of Upstream, downstream confuses me. Earlier, proxies in the chain on their target facing interfaces. We don't think we're having deployments where there's routable connection IDs. Because that's that's actually where this arises. It's not really untrue clients as it were. It it it it It's correct. Okay. And Already there. The proxy can only choose to share ports or share sockets when it is guaranteeing that there are not conflicting CIDs. It already has to manage that. Or if it doesn't wanna manage that, it just has a unique socket per Right. So it's fine Okay. too. So, like, remind me, in Connected UVP, we do not give the proxy of detail on the client CID. Well, there's no veto on the client's CID. Even here, it's"
  },
  {
    "startTime": "00:38:00",
    "text": "so in normal connect to UDP, you must have a unique UDP socket. For every connecting you'd be request. This allows you to scale differently. But the trade off for scaling differently is you need to be aware of the CIDs and you need to and and and if you have a conflict, you need to have a separate socket. Which is the same thing on the client Ah, okay. Yes. Thanks. Okay. Okay. Let's move. Thank you for the input. Thank you. Alright. Up next, we have Avi. We'll send a consensus call for the design team output. But for some of the CID, discussions here, it'd be good to get a few interested folks together in the hallway over the rest of this week. See if we can nail something down. Alright. So hello, everyone. My name is Abby Singh. From Google and I'll be presenting connect you to be buying today. Yes. It's called Bynam. We've changed the name. It used to be called listener and I'll talk about it in the following slides, But first, I'll go through very quickly, but connect UDP binding is. It's that, oh, you can use a single connection to go for multiple targets. So in traditional, connect UDP, you could only one target and But here, what we do is You when you specify the the connector to be listen header. I mean, it it will be called connected buy now. In each datagram, you add the IP version IP address and UDB port to specify"
  },
  {
    "startTime": "00:40:00",
    "text": "which, which target you want to reach And likewise, the proxy will in return do the same thing to say which target it received this packet from and and is forwarding the packet from. So Yeah. As I said, from client proxy, it's the target IP port per a load in. From proxy to the client, it is the the source IP and port per payload. Well, some talk real quickly about the changes we've had since last time. Can we renamed connect you to be listening to connect you to be buying after having a session here and also on the mailing list. And this seems to be a general consensus that this name is more appropriate. Secondly, we just, this is a small change being, changed the, the, sorry, the header to connect you to be buying, like the, that camel case, to be more compliant with how HTTP fields are it. Are assigned And so I'll talk about the pending PRs now, and these address some of the previous, the issues that were, that were discussed in previous IETF sessions, So the first one is Adding the IPN port to the response header So when, I'll connect you to be buying request is made and the response headers are returned. Now we propose to add a proxy public address, header in there, a response header in there. And it can have up to 2, IP and ports. So ipv4nv6, respectively. And so this way, the the client knows which"
  },
  {
    "startTime": "00:42:02",
    "text": "public IP, imported. It has been assigned, and it can use that for purpose. Yes. Ted Hardy. Sorry. You were much quicker at answering the queue than I was expecting. I I just, whether it makes sense to wondered for the V Six, permit 8 prefix rather than a single V Six address since, a V Six host may, in fact, be using, a a prefix to to select from a variety of these six addresses Not I don't think it makes sense to do that in this case. I think sorry. Go ahead, David. Okay. If if you don't, I just want you to think about it because obviously with privacy addressing many hosts do change their their So outbound, addresses at different times. depending on the the model of the deployment, you might actually see that now you may have a mechanism for them update the proxy public address. Or you may say they can't do a change if they've got an active connection using that proxy public address, but it it It it's actually not very V Sixty. I see Chad. Jumping in as co author. So the idea here is that the goal of getting the client this address is to then can communicate with something else to tell it that's how you get back the proxy, which will get back to me. So you get Okay. So when you prefix wouldn't work for that. your socket, you've committed to bind address for the purpose of this request. Okay. Thank you. Go ahead, Tom. Alright. Tommy Polyapple. Yeah. So, I mean, kind of on that point because this as far as I understand it, is not communicating these are my public addresses in general. They're saying, I have bound a socket, and I have now allocated you This address and port"
  },
  {
    "startTime": "00:44:00",
    "text": "maybe it has v4v6 because you can support both of those, but, like, know have this instance. It may not be the same addresses you get. When you do another bind request to the same the same HTTP session. server, in even So I'm wondering, I I haven't thought this through, but, like, should this just be a proxy status parameter, like, we already have proxy status that comes back that tells you, here's the road IPs I picked here. So these other things, adding just another parameter that's saying in my overall proxy status, I assigned you these local addresses he seems like it just fits better than having a whole new header, header, and we already have the semantics to understand the proxy status is saying, like, this is a proxy telling you what you got for this one request. And maybe it's more clear than saying public address and you could have the misconception that this is, like, my generic public address for all things. Yes. I suppose that works, And I there was another discussion I remember, which was about out. Do we want to make, fix this address permanently for for the, for the given, stream and Sorry. Go ahead, Jonathan. I was, like, I mean, Go ahead. I'm I'm sort of Tandem can't do anything a little bit based on what Ted said. So if you're addressing this particular thing. Okay. So, yeah, I mean, I was thinking given what Ted said, privacy address, so I wonder if it'd be useful to some flag that says give me a unique V Six address that hasn't been used by anybody before. 1, So for because if you're if you want a new V Six address for privacy, you're addressing purposes. Then it would be particular. It's not one that you've used before. But you don't wanna be able to, I have to say, who you is for these purposes. So just one that no one's used before is probably easier semantic, but"
  },
  {
    "startTime": "00:46:00",
    "text": "do people wanna do V Six privacy addresses? I am getting a workout this session. So So so in general, the reason people use these 6 privacy addresses is that you want your host does everything on the same address. So you want to change them periodically. This case, we're talking about proxies that many users are sharing a pool of addresses, so you don't really have a need for that as much because The the idea, if this is a kind of privacy reserving proxy, like the ones we are deploying, every connection is gonna get an address from pool, and it doesn't matter if it's the same one or a different one. You don't need one just for you. And you actually the contrary one that's mixed. There. Alright. So should we think about some clarifying questions? Or should we move through our 11 remaining slides in 12 minutes before our discussion. Okay. I'll take the last we get deep into 1, and the at the very moment. It's a clarifying question. What what is the actual format of that header? Like, You can't example, but is there a list of what like, to Tommy's point, maybe it would be better if this was articulated via like a structured field reeway, you had the V Four and V Six. Keys that told you exactly what type because my understanding of that, it's a one exactly one of the 4 and v 6 and That's right. Yeah. If if you're kinda, like, if I put them in the wrong order, you're gonna blow up, like, Mhmm. PRs, before I define it John I'll read, but if if it looks like that, like, gonna fuzz you and break it. Like, like, there's there's much better ways to to stroke for that in my opinion. Yep. Okay. I'll move on to the next address. If you want to interact more about this way, we can have a discussion and also, please interact with our PR and our, and our GitHub. And this so this is the big one, which is compressing away IP and port"
  },
  {
    "startTime": "00:48:01",
    "text": "talked about this a bit before. And Tommy had a very interesting suggestion that actually kind of helps us do two things at once with, with the compression And I will explain that in a bit. So we want to do both compression and the IP restrictions stuff that, oh, maybe I don't wanna listen from all anymore. So this kind of, this PR that I have, Potentially, addresses both. So the first one is, so we're defining 2 new capsule types there's a compression assigned capsule, and it, request that uses is, the use of a context ID for a single target. So once the, this compression assign, has been exchanged, future dataograms would only need to contain the context study, and they could skip the the IP port, it will save a few bytes. And we're so there's another type of compression assigned that we're defining here, which is and uncompressed ones. So if you set the IP version to 0, you we use that context ID to reach any target. So now you could have contact studies, a context ID that could be used for uncompressed targets and then, define more context studies to for just specific targets, one target per contact study. And so this is how it would look like. So there's a commission assigned that plant that's just caps capsule. That's the So format, and then there's the target information with IP IP address. IP address, unique report. The same things as what we had in the initial a draft with the data, with the data ground. And so to accept this compression assign"
  },
  {
    "startTime": "00:50:02",
    "text": "the other party would need to echo back the compression assign So what we're saying is both the proxy and the client can do compression assigns. To say to save on data. And, they would need to echo back to confirm that, that the combustion assigned has been assigned, and they both have the mapping for this context ID. And So but the you could, send the compression and sign and immediately start sending UDP, Datagrams, but, knowing that they might get dropped until you get the confirmation that compression has assigned has been accepted. So we have another capstool will be called Compression Close. And this is Another kind of response that you could get to confession assign if you want to reject the compressor compression assign, you say compression reply with the compression closed with the context ID of the compression assigned. And this could be done to if they do not want to allocate the memory for this specific, thing, let's say that there's restrictions on memory. And compression close, can also be used for another thing. It can be used as a request to close and existing context ID. So if we had Let's say we had a contact study that was open to accept from any and all targets. And And I wanna close this now since I since I've exchanged all the information I needed, and all I know all the all my targets that I wanna, talk to and I have already assigned them contact studies. I can just simply close traffic from all unknown destinations by sending a confession close for that specific context ID. And another thing another specification here would be that compassion clothes,"
  },
  {
    "startTime": "00:52:00",
    "text": "for an Good. So Compression Close could be used to free up memory the proxy as well. So proxy can also send combustion clauses. So if if a target hasn't been talked to in a while, the the proxy might do a little cleanup Yep. Yes. So I have all the, example here So there's a compression assigned being sent, and it says IP version 0. I wanna use context ID 2 for for uncompressed targets. And then after that, all data grams will contain Once that is exchanged, all the diagrams contain the IP version IP address, IP, UDP port. And, likewise, in, let's say, if I did a confession assigned with context ID 4, and I specified the IP IP version IP address UDP port. In the future, I'm, omitting that information And so if So in this example, when we're doing a compression close, 1 and it gets confirmed, the proxy will reject any any traffic that's from an unknown target. And that's like That's the entire, new, for request, I would like to discuss this with the group, Martin, please. No. So, Having closed act from both endpoints, is something that we learned in quick doesn't work very well. Because you end up in a situation where one side thinks the thing is not there, and the other one doesn't agree. Necessarily, So there's a risk here."
  },
  {
    "startTime": "00:54:02",
    "text": "You have the same message sent by both the client and the proxy, that the status of the compression context isn't clear. Now, if the use of the thing is only in one direction, that's fine. That may make it a little simpler But you have to I think treat 1 or other is a request. Of the the primary actor. So I think if the if this is I'm as a client setting up a compression context to send in a particular way. Right. Then then should be the one to close it. Because then there's then there's never really any ambiguity about the status of that context from my perspective Whereas if the, if the proxy can close it, while I'm in the process of using it still, then we have a problem. To To answer that, the The way you can make that work is you you can treat you you even though The same ID is used for both directions. You can treat your state as unidirectional. So when you send a close, you put it in a I am no longer sending with this but I can allow receiving with it until you receive 1. And then kind of vice versa where if you first receive it, if then it means, okay, I will no longer send with it and you and you also echo the close. And these are close are sent with capsules, so they're wanted you to eventually get there. However, they get reordered with respect to the actual Yeah. and if if you get a data gram where GDP. And the you don't know the compression, drop it on the floor. Yep. I'm Right? So let me let me get this right. Both signs have to close. Yes, 70 Yes. Every time. Well, What? Jonathan asks what if they don't? I think the answer is, That's great. We, we have ways to deal with that in protocols, typically. So execute, execute the usual"
  },
  {
    "startTime": "00:56:01",
    "text": "thing. Okay. Okay. Wasn't clear. That wasn't clear. Yep. yeah. Sorry. I didn't clarify that there. As you can see, there's a Oh, bonds for comp compression close. Compression close, can either be used as a response to the compression assigned or it could be used as a, as its own request to close an existing contact study, and it has to be replied back, It has to be echoed back. The context ID. That we have. Okay. Ben Benjamin Shorts. Times bench where it's about a so I'm a little confused about using the compression context to represent firewall. I, like, just my my reaction, my gut reaction is like This you're mixing these two things in a way that's gonna get really confusing. It's gonna be very hard to do things like, say, I'm garbage collecting this old allocation but it's new, like, because I don't wanna build up an unlimited number of these compression contacts, but I don't wants of block packets from that that endpoint. I'm just not expecting any right now, so I don't wanna waste space on it. Things like that So my Yeah. I I think that you are going to want a clearer distinction there between opening and closing these compression contexts and and blocking Certain categories. So my understanding is Would you like to have a separate category of capsule in this case, I guess, to define what like, like,"
  },
  {
    "startTime": "00:58:02",
    "text": "specific use case it is, is There are a lot of different ways to spell this, but in terms of state machine, basically I should be able to open some contexts. And then Kill them again and get back to whatever state I started the connection in. Right? Right. I should not be stuck on some sort of one way treadmill where I can add new contacts. I can never get back to the the state that I started in. Mhmm. Alright. I I'm next Tommy Poly. think Overall, I think this is interesting. I think it looks Could I need to think about it more? It's a little it's it's a little cute to combine everything. Not necessarily bad. I had a clarifying question just to understand maybe if you go back, this actually, like, the first one sure. Like, so actually that one. Yeah. So My understanding is, like, in the current spec with before we have all the capsules, we, with a header, say, This is my context ID. Yes. Context is not allowed to be 0 because That's right. 0 is reserved for the standard connect UDP that doesn't have addresses in it. Yes. So when we do this, do we get rid of the header? So the that's a good question. We have the header and the cap like, why do we need the caps up here? That's a good question. We could I mean, we just have this, spec that this is connected to be bind. And we could just not have the, the value is the context study, right? We don't we just need to define that this is context, this is mine. So that could be removed. I while in the hackathon, I was thinking about that exact thing. And The other thing that could be done, I don't know if there's any use for it. Which is just, oh, this is going to be the first contact study as I assign."
  },
  {
    "startTime": "01:00:02",
    "text": "But I don't know. I don't think there's a use for it, so it might just be better to remove it. Yeah. I I just wanna make sure there's only one way to get that initial context ID. Right. And I, you know, I I think if we look at the precedent of Connect IP. We have cases where you send capsules pretty much always off the bat. Right? And that's not bad. So let's just make sure there's one way. Yes. Yes. Yeah. That makes sense. I like, while working the draft, while implementing it, I came across on the same exact thing and it will be changed in the PR, but Mira. Yeah. Just a thought on this, closed thing that sounds to me like this is actually something more generic that you you know, if you wanna do it, maybe you also wanna do it for other cases where you use capsules. So I'm not sure we should specify it here, but I I also feel like I'm not sure we need it. If it's only to clean up state, then maybe it's easier to just, like, close your connect and do a new connect and like start fresh or whatever. Like, for me, it adds a lot of complexity that Not sure. I know if it's needed, actually. I think, like, the power of the benefit here is their IP restriction part, which, been through several times, and I like, I think it's that bet that added benefit I feel I personally feel makes it more worth it to do this over it was just for, 1 of the 2 things. But I don't know if anyone has any opinions on this. Thanks. Alright. Bye. Alright. We are carefully at time. Thank you, sir. Alright. Thank you very much. Wonderful. Alright. A quick reminder, if you haven't yet scanned the QR code now is a great time, while we get set up for our next presentation, we can"
  },
  {
    "startTime": "01:02:00",
    "text": "start an audience participation activity, give it a little stretch, Get ready for our, next awesome presentation here. Alright. It is definitely awesome. No pressure or anything. Hello. Start with the pressure. Did be that could go? Alright. Take us away. Out of the show of hands. I've been told I've been great at talking into the mic. So if I'm not, please let me know. Slides are over there. Alright. Back from more connect to ethernet. There hasn't been actually any chance to the draft we have a bunch of issues open on the GitHub now. It'd be great to, like, work on them some We are still in the adopted ish State waiting on the recharter? That is in progress. Suppose the last time we hadn't started yet. We think we are now in the home stretch, but I don't wanna jinx anything. Yeah. It could fail. It could succeed me. Mhmm. Let's see what happens. Between IITF 118 and now, we had our coordination call with 802. Seem to not have a problem with this, which seemed to be one issue to one point of contention last meeting. We'll get some feedback from them early. We'll get some feedback from later."
  },
  {
    "startTime": "01:04:04",
    "text": "But it sounds like we worrying about this being called ethernet Terrible much. And here are the issues that I have that I pulled out from last meeting We'll go over them 1 by 1 n, See if we have some discussion. We'll start with the big one. MTU and fragmentation. So we're tunneling Which means we're eating up MTU. Which means we don't have ethernet's standard 1500 or So for the payload. We don't have the standard ethernet m to you. This may or may not be a problem depending on the use case. We've got A couple options, and neither of them are great. We can Fragvent, We can Drop. If things are too big, I suspect people are going to want different things there, so this may need to be a knob we can tune for a given connection. We can also start being somewhat of a middle box. With some deep packet inspection. And doing our Like, trying to adjust the existing connection or connections as they're being set up to fit within our MTU. I haven't done anything on this yet, but I hear other, layer to VPN's have done this successfully. This shouldn't be part of this protocol. I don't think."
  },
  {
    "startTime": "01:06:02",
    "text": "But it may be a recommendation to implementers. Like, The smart side of this may want to to muck with things a little bit so that you're not dropping packets, might be a good idea to looking to practice of previous Ethernet encapsulations at the ATF VXLAN comes to mind. believe they are I it's just dropped if, MTU is too big and it really down to implementation to do MSS Climbing or something more creative Mhmm. Brian? Hi. Another clarifying question. So is this there seems to be an assumption here that the idea is that We're using this to encapsulate IP traffic over ethernet as opposed to stuff that is non IP over Internet? Is is that, like, is that the case, or you basically just sort of, like, bridging to IP networks at layer2, using this, or is this for traffic that is non IP. I am happy for this to cover non IP traffic. I have ideas for how to help with this issue for IP traffic, I haven't looked into how to fix it for non IP traffic. So the fact that we're looking at sort of like PLPMTOD and things like that for for IP traffic is not basically saying we're excluding non IP traffic from from the Ethernet. Stuff. Right. Okay. Cool. Thank you. Anything more here?"
  },
  {
    "startTime": "01:08:02",
    "text": "This is an open issue. That's It didn't propose I am promote I am proposing that there needs to be discussion on this open issue. I if I had the solution, I wouldn't have opened an you had updated the document. Alex. Alex Chernowski, Google. So my concrete proposal here, which sort of outlined on the GitHub issue, which I'm going to say here to be provocative to hope that someone actually replies is we should probably Say what you should do but not do anything which is sort of mandatory to implement here as except for maybe saying you can do full size MTU over reliable streams since I think fragmentation is more evil. And basically tell people about implementations should and I do mean all caps should try to get into a world where they don't have to do Ben. Hey. So Yeah. I think It would be like, like, the the logically correct thing here, I think is Is that the we're creating some kind of virtual interface. We need to just like, expose the right MTU off of that interface, interface, and, that actually reflect the the characteristics of the the link. And So, like, I think, normally, that's what we should require, and then Yeah. We can recommend the different strategies of, like, should you you know, should you choose a bigger one and and do internal fragmentation or send large packets over capsules or or whatnot But the normative thing, it should be that the the Indicated metadata should Reflect."
  },
  {
    "startTime": "01:10:01",
    "text": "The observed behavior. Yeah. There's a couple of things that can get interesting there. For instance, if you bridge it to A physical segment. Now you're bridging things with 2 different MTOs, and things can get weird. Also, Quick connections, for instance, can get rerouted and the path onto you can change. So you get to update that On the fly, that's gonna be problem regardless, but Lars. Hey. Las Vegas are good. So so, have a simple suggestion, which is to do the absolute simplest thing works for the use cases that were originally presented and and no more rather than, like, trying to build a perfect these tier. But the other thing that we can do we recognized as it's much harder than we originally thought and dropped it. Just putting that out there as an option. I'm in the proposal. Brian? Yeah. So, I, Plus one to what Ben said, plus one to what what Lars said. I think I would connect this later. I wouldn't say at all costs, but, like, fragmentation is one of those things that you think is going to fix your problem and then end up now you have, like, problems. It's like the regular expression of expressions of networking. So Let's just not do that. Miria? Mia could have been I think we should not describe any of these hacking in the document. I mean, if somebody really wants to do it, then they can probably still do it. So by default, I think you just have to drop the packet. We could figure out if there's any kind of solution that we can do on the mass layer that helps a problem somehow, but, you know, that's just like"
  },
  {
    "startTime": "01:12:01",
    "text": "additional efforts, so I'm not sure we needed. Mhmm. Is there anybody who would find their use case or otherwise be very up set with the drop of the packet approach. Sounds like we have several suggestions to do that, but not a lot of people pointing out problems with that. So maybe let's take that as input and keep going. Yeah. Oh, I see Christian joined the queue. Cantierry. Yes. My mic was muted at the mic. That's weird. Yeah. I was saying this business offer sending Messages It's a larger than the MTU. Is They, common in media over quick. And the the consensus in media about quickies. Don't try to use it again so that Yeah. Effectively use short Unity of streams because short video streams have many of the property of that gun that we want, like a no end of cube looking and things that And that might be a better deal than trying to use, fragmentation on top of the diagrams, etcetera. Zy ahead. And, Jahem. So I can't agree with what we just said. Like, we should not do engineering or cry something hacking to solve this one. If there is something that we could do in the mask,"
  },
  {
    "startTime": "01:14:02",
    "text": "to help it. That makes sense. We should do it. And I also not sure, like, because, Eric wanted to, like, if we drop, what are the problems there would be? I'm not sure, like, we have an app expert part is in the room, to actually adjust that? So maybe you should reach out to the people who has been doing tunneling an internal link, previously in IETF. That's kind of like Now but my suggestion would be So Please involve, like others that we have already done that or, like, or, or, like, or, like, or, like, or, like, or, like, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, or, like, sake for expert opinions. Unless I'm wrong, people people here are, like, disagree with them. Like, we're lacking some sort of expertise on this dropping these packets. Please shut up. Alright, Alex. And then let's keep going. Hi. It's Alex again. I wanna address, the idea that Christian just proposed so the initial implementation for connect IP which was called Cuba. Did in fact do the entirely short lived streams thing because it predated datagrams. It's great. It works. It won't work here because we're in the context of HTTP. So we can't go and create new streams easily. Right? It's a pain in the butt. I don't think that that changes the semantic of, like, just throwing it on capsules on the existing stream that we have I know Martin and Chad raised the concern about performance problems, but I think ultimately the question really here boils down to there is a network that we're connecting to which has an existing MTU. We need the interface MTU to match quote, unquote, and the behavior needs to be If we're talking about IP traffic, PM to UD will probably work, and you can get away with making it smaller. If we're talking about other protocols where we don't know what their behavior is in the process and the process of dropping these frames."
  },
  {
    "startTime": "01:16:01",
    "text": "We don't really know what's going to happen. So, like, my personal opinion is We should probably try to see if we can get away with doing drops. And if we can't put them on reliable streams, but we probably need implementation and real data to actually make this decision. So I think I changed my vote to, how about we actually get some concrete implementation data and come back to this issue when we have that rather than purely ideological discussion. And I agree with, as I had, we should get more input I think that's what is one way to forestize question. Alright. Thanks. Hopefully, the others will go quicker now. So last time we'd also talked about some MAC address filtering, Do we wanna dig deeper into this Like, it was mentioned briefly last time, If we wanna do something like a like, server MAC address assigned, like, the IP address assigned that, connect IP has. Or just Let each side to side what MAC it's using. Yaroslav, for some, it really feels like implementation detail rather than protocol specification unless we're looking to signal some filters in the protocol, which I don't think is the intent. Filtering was mentioned last time as a potential Interest. Which is why it's here at all. Lars. Lastly, good. Again, so for this and for all future things, so I don't have to get up to the mic again. I would prefer we do the absolute, simple, most thing, which is not do anything here. And if somebody needs it later, we"
  },
  {
    "startTime": "01:18:02",
    "text": "reopen it or we do a biz or we do whatever. So so let's keep this simple. Sounds good to me. And to respond to Lars David's Ganazi, I think A lot of these, issues were filed because folks asked questions. But I think I'm strongly in support of what Lars said, which was even if they ask a question, maybe the right answer is That's great. We can deal with it later in an extension. So I would for this and a lot of the future ones. That's probably what we should do, unless we have ones where we think it won't work. Alright. This was a question. I think it's entirely out of scope. We can figure out an answer to it later if we want we cannot it was asked at the last meeting. I think this is a place where if if we have demonstrated folks with use cases that need it and etcetera, etcetera. If if we've met that bar of this is worth the energy, let's maybe talk about it. But, otherwise, I think having written it down and then saying, hey. If you'd like to be a proponent of this, please come and actually bring that. Otherwise, it's gonna sit and to be closed as as a future work if anybody needs it. Yeah. And I think a bunch of these might fall under that category as we go forward. That is a lovely theme. Let's keep it going. Never mind. I'm standing on an extension point. I don't need another one. Other layer 2 things can To different extended connect, it's fine. This is an implementation detail. I don't think we actually need to talk about this. I put the slide there for a reason. Was Nick at 1. Frame delivery order. This one is actually a little interesting. I've been digging into, pseudo wire 3. And"
  },
  {
    "startTime": "01:20:01",
    "text": "They were pointing out in their work that ethernet doesn't have a guaranteed delivery order except Maybe when doing link aggregation, I think this may also be a knob that could be tweaked, and perhaps we can send flows down their own streams or something. If we need guaranteed delivery order, but probably for the most part, we don't care. If someone wants that knob, they can shop. Also a thing I noticed while reading the pseudo wire stuff. They don't send pause frames. There's probably a good reason for it. Perhaps We should not send those either. Mhmm. And then, like, what do we wanna do about vLAN tagging. The easiest thing is to ignore it and just let them through, but we could do more interesting things with it potentially. That could be more extensions to extension work, And that's racing through all those things. Beautiful. Thank you. I think so. If we're summarizing where we are other than administrative procedures and things. There were a lot of different questions and concerns raised in the previous conversations. It sounds like as a group, We are comfortable in an approach of let's be absolutely minimal. Anybody who wants to come bring an additional further extension to this somewhat extension. Can certainly do that and and bring that activation energy, but we aren't trying to go grab all the things. We're trying to do the smallest thing we can. Will fit this particular use case that we decided to take on. It sounds like that's a I'm seeing some thumbs up, and otherwise, generally happy expressions. In which case, beautiful. Thank you very much, sir. And if there's nothing else, Alright. We have one last last time permits presentation from David. There is nothing else. There is another question regarding the"
  },
  {
    "startTime": "01:22:03",
    "text": "Ethernet part. Can you go back a little bit, slides choose the concern of the FCS part, frame, frame checking, sequence, what FTS, no. Yes. This is the one thing is here because there is no one scenario, in the the ethernet, the PTO session type links with GPP. Basically, it said on the ethernet tab from the u, you said it's going to strip of the the preamble and SAS. And then it's going to send out If we're using this proxy, if you have both there. That means in in that case, we may have trouble There's a speck in the 5 g, already. Let's talk offline. Yeah. Yeah. Well, already. I can tell you that there's really something, here Alright. Sounds good. Thank you very much. Alright. This last this is not something that we're necessarily considering adopting or anything this time around. But as we've been talking about, our general strategy right now is the remaining work items in mask are the things that you need in order to make mask actually work in real life for real people. And so this is an extension that we previously considered. And There are now apparently real people who have real lives, that are not in this room. Who have needs. And so this is a preview of something that we may want to consider and hopefully spark some offline conversations, help make concrete, and then can talk about in future meetings. Would you like me to share slides for you, or did you bring your fun little gadget that Oh, no. If you could, that would be easier. And by fun, little gadget, you mean the phone that your employer makes. One of those things. Yeah. Or yours. Alright. Thanks. Well, I think Eric covered the, the overview here. Perfect. So I wrote a draft and I submitted, like, At least 3 hours ago, so I hope everyone in the room has had time to read it. Next slide, please. But now, so this came out of a discussion with the Chrome OS"
  },
  {
    "startTime": "01:24:01",
    "text": "team that happened after the draft deadlines. So I figured I would just present the overall idea But anyway, Most VPN protocols today allow you GNS configure information in line, mainly, you know, what is the IP address of my GNS name server? You also have other cool things like, split DNS. These domains go through the VPN. These don't. Or search domains. Next slide, please. And that's, you know, I could v 2 does that. I open VPN, all the things. Connect IP doesn't do that. We talked about it in the early days of working on that draft and kind of There was a lot going on. So we decided to really are kinda design principle for ConnectIP was what is the minimum we can do to support a few use cases So we kind of punted it and said, we can always build it later as an extension using capsules. Well, the future is now. It is later, and some folks were asking for this. So, Next slide, please. What do we do? The problem is that if you don't have this and you wanna build, like, a personal VPN using mask and connect IP. You're sad because you have to change it as your configuration information, and that's kinda really annoying, especially if these addresses change. Next slide, please. Luckily, and I've just covered how to use AI to make images, watch out. You can just shove the DNS configuration information in the capsule and then you're happy. And Next slide. And that's pretty much the entire idea of the draft is there's a capsule to say, hey, can I have DNS configuration information, please? And, here's your DNS configuration. Have a nice day. It mimics what we did in connect IP for IP addresses. It It also does, split DNS search domains because, like, I did a little bit of research on what other VPN protocols use and people thought those features were useful. And that's kind of all there is to it. Next slide. And That's it. So the the idea is"
  },
  {
    "startTime": "01:26:03",
    "text": "Do people think this is somewhat useful, do you wanna know what I typed into Geminiy at those stupid images? But but like the, at some point, please read the draft. If people think this might be worthwhile and worth the working hoops time. I'd like to see where this takes us, but We have time. Martin. Just as far out of the day. Yeah. Yeah. Keep it snappy. So the signal we're really looking for is, this worth time and energy is the So I'm not sure that I'm entirely happy with the idea of doing DNS over yet another thing. When we already have DNS over HTTP and that is what we'd doing with all the UDP. So, then Why does that not work here? So so the idea is this wouldn't be is how you send DNS through mass because you're right. We have a ways to do it. This is you're trying to set up a VPN. So you brought up a ton device on your client that's gonna tunnel part of your traffic and you need a way to say, send my DNS through the through the VPN. And, like, that's what every platform supports. Otherwise, you're just leaking your DNS out onto the Yeah. That's all there is to it, really. It's, it's like, what is the IP address of my DNS name server? Yeah. There's other ways to do that. We only give them a dough endpoint, we can just use a URL. Right. Right. Right. Right. Right. Right. You could, but, like, at this point, I I the like, that bit of OS code doesn't have DOW code. And so that would be nice, but, like, right now, all it, like, What it has is, you know, Resolve comp. Fix that."
  },
  {
    "startTime": "01:28:01",
    "text": "Yes. And Lars. A a half series comment going completely other direction from what Martin just said is that you could just tunnel DHCP, and you get every so that is another option. We we explicitly decided not to do that when we built connect IP. We could have built connect IP that way. That's how Wireguard works. But we decided to exchange the IP addresses. So, I mean, it's it's not a crazy way, but that's not what we decided to do. Tommy, Tommy Paulley. As someone who for ipsec wrote the way to, like, not have to do it through DHCP I I I am sympathetic to this. Think it it's fine, like, That's Like, the way that Ben on this was describing how he would be using connect IP as more like how I wanna use connect IP, but I are some use cases that are like this. So, like, sure. Fine. I do wanna make sure that I have I haven't read the draft because, you know, it wasn't posted, but how dare More, right, more recently with, like, I We have this stuff related to ADD. About making sure you can communicate the encrypted, like, the equivalent of DNR and this. So you are signing up to do all of that too because this is yet another place to put like, the name and the SPCB, Stuff. So if you're willing to do that, sure. Yeah. Job security. Mark. Hi, Mark Smith. One of the key differences between B4 and B6 is that all the links are treated the same. There's no IPCP as it was in in PTP. So long story short, VPNs are just another link type. And rasanddocpv6. They are, but it's split. Well, I'm I'm just saying that No. So so you you use your RPV 6 model. So you see it across. I can ring Absolutely. Primary light will lower. That is true. But for, like, you I'd be too tunnels, like, you explicitly say,"
  },
  {
    "startTime": "01:30:00",
    "text": "don't send RAs. We send the or IPC signals that are configured. Were you using agv2, you say change the configuration information using a v 2. We don't set our that's what we said for ConnectIP. I think we have explicitly explicit text saying not to send our eyes. So it's I agree that that's how you could build it. You're totally right. That's supposed to be the model. Yep. You know, the digits. Okay. So Things aren't doing that. They're coming up with their own versions of I I mean, I I I V2 was the well, was done way before my time. And tell. Well, but, yeah, it's it's you know, I'm just saying the way sir. And, Ben, hey, hey, that's where it's We're at time. I'll just say I think we should at least weigh that option against This one, I physically, in addition to the what I what I really want is like overarching configuration. Another Another option to To test against this would be, a like DHCP or RA mode. For, For connect IP or profile, I'm that's an option. I mean, that's not something we would love for our use case. But, but worth considering, for sure. Thanks. Thank you, everyone, and Alright. Please re the draft at some point. Let me know what you think. And, otherwise, we'll discuss it on the list. Beautiful. Thank you all. Thank you to our note takers, especially. Have a great rest of the week. Saw that beautiful. So the dotted line is, like, basically, fuzzy data that isn't all the way in yet. Thanks. You can't just"
  },
  {
    "startTime": "01:32:04",
    "text": "make another quote. Got it. though. So, like, it's a real load of all spike, Right. Yeah. Yeah. Yeah. I saw that. I saw that. Nice. Yeah. Thank you. Yep. Hopefully, Wilson. But yeah. Right. Right. sense. Okay. Yeah. That makes Okay. Try to write down things I'd like to do, and then I will have my brains basically. But thank you. That is beautiful. Thank you."
  }
]
