[
  {
    "startTime": "00:00:12",
    "text": "that's just like daniel and christina did at oauth yesterday okay is this the agenda yeah no no okay so the first is harness the hpk okay i will be able to switch between these and know what to project next meetings so welcome to jose we'll give people just a couple minutes um but um for instance maybe we can look at the notewell slide while we're waiting i guess are you able to advance the slides no no you can try to give me the control of them when i see i can file the control to"
  },
  {
    "startTime": "00:02:00",
    "text": "other people but not for myself i mean obviously i can just share dislikes myself myself so that i can control them um okay so hello everyone we will be getting started uh this is the this is the cozy meeting for this itf if you are in the wrong room you are welcome to stay so this is our not well it applies for all and the meetings please take a look at it if you haven't done that already and if you have any questions please talk to us or anyone maybe the idea before participating in discussions we live by our code of conduct please take a look at it"
  },
  {
    "startTime": "00:04:01",
    "text": "i know we have been circled quite a bit during this idea but it's important to make yourself familiar with it and this is the administrative part we have our minutes at the following qrl uh who will be willing to help with the minutes okay marco thank you if anyone wants to be helping that will be really appreciated and for jabber and john i think you said you can help right okay thank you john and uh here is our agenda uh it changed a bit since the original upload on data tracker so i made that visible here is there any bashing of our agenda i'll take that as a no then we can start with the document status so and [Music] we have the following documents that are passed working group last call um the first one is the hash algorithms as far as i'm aware there are no pending changes or no pending action items it's just waiting for the other documents in the cluster to be ready before getting published and then for the auth 48 documents [Music] we have a few iterations done recently i believe all the comments that were"
  },
  {
    "startTime": "00:06:00",
    "text": "raised were handled uh i know some participants wanted to do one final pass through the documents but other than that they should be good to go then next is the x509 and document i think paul we should chat how to how to upload the new revision um yes okay and yes then the final of those documents is the counter sign document i saw that the responsibility did the review and it is now in last call uh paul voters 80 um i just wanted to let you know that um i i'm i'm new at the ad role this is my first full-time uh itaf at the sd that's the ad and about half the people who've approached me so far are approaching me about this cluster of four documents that are waiting for a very very long time and sort of ping-ponging between karsten ben uh and uh and the rfc editor um we really need to get this out so so so i don't know what i can do anymore because i already sort of tried to give you deadlines to get this cluster out because there's really a lot of people both inside the idf and outside the iitf waiting on these documents to get our synonyms to god so um i'm thinking of in about two weeks to just push the button to the rc editor to say publish this i don't care anymore what the status is so please get carson or whoever needs to do things to do them in the next two weeks so that we can get these documents done"
  },
  {
    "startTime": "00:08:03",
    "text": "i suspect ben cadek is on the queue to talk about this very thing i recognized ben yes uh sorry i was a couple minutes late late joining but i wanted to be here to be able to speak to this topic and so um i did send some updates to the rc editor based on essentially a full review of the text and i looked over the resulting diffs and they're they're basically good uh karsten spotted a duplicate word we had the dreaded the the going on and i think there's like one other cosmetic tweak that i know of and the only other thing that i still need to track down is just the specific numbers on the aead usage values and so i'm thinking that the two week time frame should be reasonable here i also had a list of open issues or potential open issues that i sent to the auth 48 thread and i was hoping to get some more input from other people on them because my proposed resolution was basically don't do anything for almost all of them so if the the chairs or kirsten or somebody wanted to chime in on that or if somebody else from the working group thinks that they have some good insight i'm happy to send that list out more broadly so i think the only other point i want to add is for paul and just to check basically that some of the changes that were made in auth48 were of this heart that would require ad approval as potential content changes basically and so if you could also take those two weeks to confirm that you've looked those over and you don't have any concerns that you want to push"
  },
  {
    "startTime": "00:10:00",
    "text": "back on that would be helpful to make sure we can actually publish at the end of the two weeks while speaking yes i will i will do that thanks and i'll thank uh kirsten again for his help and looking over many aspects of it yeah thank you ben and karsten for your diligence as well as evo in moving this forward um i see marco in the queue yeah hi this is marco just a comment on the counter sign document please just a comment on the counter sign document i noticed the latest revision in section three refers a course document and the specific reference got changed compared to the previous version yeah i believe the previously referred document is more appropriate because that's where the actual counter signing happens i was just double checking this morning with the security ids looks like the case uh i'll send out the mail to the last call thread also all right paul speaking yeah we briefly talked about the the reference being wrongly fixed so i'll i'll double check this with roman so thank you okay and i think those were our slides then i will move to harness [Music] this test okay cool so russ and i will briefly talk about two issues um in the cozy hb key document as you know and there's uh the hp key document was was published as an rfc coming out of the irdf and"
  },
  {
    "startTime": "00:12:00",
    "text": "this document describes on how to accomplish the functionality of hbke with the cosy structures next slide so we are version two of the document uh if you've been following the mailing list you've seen a lot of exchanges back and forth between hillary and myself um thank you larry for all the the reviews i there are two aspects um that are worthwhile your time here uh this is the first one which i would like to cover is we need to have an agreement on the format of the public key encoding the ephemera public key encoding that is sort of included in the encryption so here i just instead of copying the entire sort of structure of the hb key with the recipient etc i just focus on what's in the what's conveyed in the ephemera public key and i think discussion wise we got a little bit stuck between hillary and myself on what the right format would be and that's why we are seeking out to get feedback from you on the on your right hand side so the public key the nist b256 r1 curve in cosi is described in the following way so you see the key type which is set to this value ec2 obviously there's a key id in there or not obviously but there is a key id in there there um or potentially then there's a curve indication uh because obviously there are different curves uh and then there's the encoding of the x y value and there may be a compressed encoding of the point depending on how you set the y coordinate okay that's also basically taking from the cosy rfc that's not my uh invention hillary proposes a slightly different format so he um would like to use"
  },
  {
    "startTime": "00:14:03",
    "text": "a different key and key format and this is the octet key pair if we remember that correctly key id is the same so uncontroversial he wants to use a new uh value for the hp key so it's just um temporarily assigned to that specific number and then he basically takes the output of the hp key algorithm that produces this ephemera public key and dumps it into this this raw data and i think having two formats for a key is not ideal so we i think we should pick one but which one not wearing my chair hat mike jones is there a compelling reason to not use the key format that's already been standardized by this working group yeah and i think that's where hillary and myself um sort of divert in in the views his opinion is if i correctly uh reflect it and maybe he's online is that um he wants to basically use hp an hb key library to export um what comes out of it and then dump it straight into uh this uh field in the last field shown on the screen without further sort of post-processing so to speak uh i think that's that's one uh argument but maybe uh some of you guys have some additional input or different perspective yeah mike prorock yes thanks uh mike perrock here um one of the things that concerns me in looking at the kty discussion both on jose and kosay is potentially overloading octet key pair"
  },
  {
    "startTime": "00:16:01",
    "text": "and especially crv to apply to things for which crv either doesn't apply or isn't fully described by a single parameter i am strongly in favor of the proposal on the right from the screen size which i believe is yours honest as far as kty uh ec2 in this case with xy coordinates because it completely describes what the actual key type by family right as defined in the rfc is as well as how do you actually reference that from a curve perspective in this case we've run into similar issues from a post standpoint where we're getting into families of algorithms also that don't have curves or other things like that right that are novel constructions for which we need an answer to this and so i think by going in ec2 kty type here we're setting that direction as a group as to a good path forward so that we're not overloading and encouraging implementers to make mistakes as far as selection of algorithms so that's all thank you i'll make a meta point um those of you who want to join the queue should actually join it online i'll nonetheless recognize tobias but the next time please join the queue so that we're fair to the online participants okay thanks um yeah i'd much the same as the sentiment express before i i think um we already have a key representation format for p 256 keys this is really just embedding it in a high level application so the p256 public key representation with ec2 makes more sense because the the octet key peer representation here as well tends to sort of stretch the notion of the curve field with a custom tag too um to kind of layer on a higher level algorithmic sort of representation which is hpke and kind of conflate the application so i think the p256 the existing curve represents key representation here should be sufficient"
  },
  {
    "startTime": "00:18:01",
    "text": "i recognize david brown so i think that excuse me i think my opinion is probably pretty similar i don't have strong opinions on which but i'm concerned that the left proposal is taking a specific implementation to drive the spec rather than representing what is actually in the key i think well i was um like huge dutch consensus okay as chair i'll observe that no one is speaking for alaris proposal other than obviously alari should we do a hum on that at this point to try to provide guidance to the editors oh and shoot do you know how to do the online homes so sorry uh balance 80. um whether or not you do a hum i don't think really changes march anymore right because you still have to go to the list to confirm it anyway and i think sure you know the humming here is already pretty much in favor of the proposal on the right from what i can see so i mean you're free to hum but you would still have to go to the mailing list anyway so i don't think it matters in this case okay i'll ask a different question is anyone wanting to come to the mic to speak in favor of the lorry's proposal otherwise um i see ben maybe okay i recognize ben yeah i guess this is maybe a clarifying question but larry's proposal had the he did as a 65 byte string which uh in my understanding has a clear decomposition into x and y coordinate"
  },
  {
    "startTime": "00:20:01",
    "text": "and so that would tend to if that's correct that would tend to lead me to also prefer the the right-hand side proposal using ec2 keys and the only reason i can think of that would strongly make me prefer lr's proposal would be if there was some ambiguity or difficulty in actually converting the representation uh away from from that proposed representation so ben this is russ my understanding is he's just using um the exact hpke algorithm that's uh in the rfc and taking the dump of that straight from the library okay so he doesn't want to have to peek into the internal structure of the hp yep that's what's going on as best i can tell okay uh to close this out eva do you agree with me that the chairs should send a note to the list saying the consensus in the room appeared to be to use the standard representation and asking if there's any discussion on that yeah just record it in the minutes just for the chairs of you that is what's in the draft right now is the right-hand side okay so that's what i thought okay next slide please so one of the places that the this draft is being used is in the suit working group where we have encryption of firmware that's being loaded onto iot devices and so the encryption um has to be done in conjunction with the bootloader and the the thing that is going on is the firmware signed and encrypted"
  },
  {
    "startTime": "00:22:00",
    "text": "so we don't really need an aead because the signature provides the integrity and the way that some small devices manage their memory such as flash blocks they want to be able to encrypt chunks of it that match the size of the flash blocks so that the bootstrap loader and the encryption can be easily tied together so in those cases uh counter mode or cbc are much better aligned with that but cos a encrypt demands an aead um and so we think we should register some non-aedi algorithms with big notes in the registry that says you know only use this if the data is already integrity protected in some other way or the approach we do not recommend is we define some cosa encrypt light and that seems like way more work to not be an aed as opposed to a note in the registry so we're advocating uh hanus and i are advocating the register of the non-aed aead algorithms with appropriate notes and we're willing to write they are the internet draft if the group agrees that that's a reasonable way forward we'd like to hear from you recognize cedric i thanks i'm wondering if you could reinforce the settlement by saying that integrity protection should be guaranteed before can you get thank you sorry yes can we ask for that the integrity protection be guaranteed before decryption rather than separately from encryption to prevent attacks on unauthenticated"
  },
  {
    "startTime": "00:24:01",
    "text": "decryptions that are still possible in principle i'm i'm not sure i understand what you're asking or so you could authenticate after decryption or by your signature independently i think asking for the signature to be checked before the description occurs it will be structurally more secure and so if you can renounce the text right where you're authentication by signature default description that would be stronger than separate okay i recognize jonathan hamill hi uh jonathan hamill canadian security chain center for cyber security uh just a clarifying question you mentioned about notes guidance on uh use of these uh additional registry items where would that be put in the registry itself i'm not aware of a there's a description column but where would that appear yeah we'd we'd have to uh in the iana considerations ask guyana to add a place to put it thank you john matson i i support registering encryption without integrity this has popped up in other places as well for example group or scoring i think there was some web discussion here where it was needed i think in general the default recommendation is strongly to use aad unless you know what you're doing and yeah so i strongly support you and don't invent your own crypto algorithm recognize brendan moran can you hear me yes that's great um it is not practical to require a integrity verification prior to decryption in a firmware update scenario the reason for this is that a device that is fetching an encrypted firmware may require that it fetches a"
  },
  {
    "startTime": "00:26:03",
    "text": "block decrypts it in place and then writes it to flash otherwise if you don't follow this procedure you're doubling the flash cycles and you're risking the survival of the device when you have to do an in-place decryption later because that requires additional journaling on top of what you already might be doing so this is a very specific use case for firmware and in that case it's i don't see it it being practical to require that you do integrity verification in advance of decryption so brandon i think you're talking about the um potential for burning out the flash cells with too many rights is that your point um it's not just when you said damage device uh it is that that's that's only part of the story though um it's also the energy required to write to the flash um so so there's multiple aspects here okay thank you i'm i'm going to recognize ben and then john and cut the cue in the interest of time benjamin so i was doing a quick read through uh the 8152 is struck and while we do only talk about authenticated encryption modes uh i didn't find anything that specifically says uh you must have authenticated encryption so i think that would tend to support registering the algorithms but i would add to that that you really ought to include a section in the document that's like uh how to encrypt for non-authenticated encryption modes uh or whatnot um i'm just pulling up the actual section so then ben i think you'll find it in the definition of the alg parameter it says identifies the aead"
  },
  {
    "startTime": "00:28:02",
    "text": "well but we also have ae modes for key rap right and that's how i read it is what i'm telling you okay i i will i'll check that rap isn't integrity protected key rap is an aead well there's no associated data just to solidify my point to russ uh we've got a section heading that's like how to encrypt and decrypt for aead algorithms that's currently in in the struct and just do the analogous thing for that when you do this right okay john bradley um john bradley yubico um as as i recall when we were doing jose we made the explicit decision not to have um non-aead encryption uh to event attempt to prevent people from shooting themselves in the foot that's correct so it would be possible to have a define a composite algorithm that did as was originally suggested encrypted and then signed um that would be one possibility i'm i am sensitive to the constraints for software updates i don't know that there's a perfect solution for this but it that is a pretty special purpose use case and we have to balance the the overall good for of you know making this exception for cos a versus you know how many people are going to use it inappropriately because they they're not reading the registry um versus the utility of of having it as part of jose so i don't know i wouldn't rush necessarily rush into making a general exception for jose to have"
  },
  {
    "startTime": "00:30:01",
    "text": "non-aead bulk encryption well i guess the alternative is software encryption not using cosa which i think would be worse in my opinion so it would be my suggestion russ to write the draft and as i told you previously there is a precedent for registering cose algorithms as deprecated from the get-go we registered rsa sha-1 i personally did because it's in tpm 1 and is used as deprecated because we're trying to get rid of show one but it's there in practice and i view this as somewhat analogous um i'm not promising the working group will adopt the draft but i think the next step is to write the draft and make the case all right thank you all right so we'll see how the adoption call goes next is seabor encoded cert by john matson uh yeah i don't have any slides so just a bit of update we have submitted a new version just to not make it expired we have not had super much time to work on this due to other things and me being on parental leave but there has been work ongoing there is a master thesis student looking at ocsp"
  },
  {
    "startTime": "00:32:02",
    "text": "encoding in in cyborg or in c509 specific seaboard there's also been a lot several people expressing interest derek atkins and manisha malik has requested c code implementations uh on either the mailing list or on github [Music] armando garcia from franhofer has announced that he's soon ready with his c implementation and this is great news it has been requested i think also more implementations of the c5 serum 9 is a good step to move this forward also comments from kerry bonnell from ddesert that suggested a change in the general subtree thing and also suggested some improvements to the document structure to place things in subsection to align with rfc 52 80 seems also very good suggestions we will look at these and make issues otherwise i think i think it would be good with more reviews as possible we hope to be able to work more with the document later this year are there people in the room or online that are willing to do a review of this draft great thank you if you want of course you can always just do a review and send it on the list but thank you okay next up is tobias looker to talk"
  },
  {
    "startTime": "00:34:01",
    "text": "about two drafts the bls key representations and the claims and headers and in full disclosure i'm a co-author on these so i recuse myself from all chair actions about these documents okay thanks uh next slide so so just a bit of context this was recently um adopted by the working group um and this draft registers the required parameters for both the jwk and cosa key cryptographic key representations for the what's known as the beretta lynn scott bls family of curves both the 12 381 and 4 48 581 variations um just a quick note about the the bls curves um they're said to be pairing friendly uh which enables some novel algorithms beyond namely digital signature algorithms beyond um standard or conventional digital signatures um and the bls uh family are the most popular in use today um the only others that are notable the bearing nedo curves um however bls are favored in most applications and there is a formal definition of the bls curves as a work item at cfrg as well for context next slide so just a quick note on a couple of different algorithms that this uses one is an aggregate signature scheme which enables aggregating signatures of the same payload together whether it's same result can be checked against the individual sinus keys uh this is useful in multiple applications most notably in blockchain applications it's already in use and and networks like ethereum and file coin and the signature scheme itself is also a item of the cfrg so"
  },
  {
    "startTime": "00:36:00",
    "text": "this draft we're talking about is only registering the key representations but this is really just talking about the algorithmic usage of these keys next slide uh another scheme uh example for these key representations is a scheme um known as bbs signatures which uh have we proposed to the uh cfrg this week as a work item um and most notably that scheme supports several different novel properties such as selective disclosure proof of possession and unlinkable proofs so yep next slide and that that's this is really just informational context for um the algorithmic usages and um of this scheme so i actually think that the last couple of slides were just really inform informational um so we can probably um skip let's get past this really the the updates for um for this draft at this stage uh with bls key representation um we can probably just flick through these things um is that the the key key parameters have essentially been defined in the draft the only um outstanding item uh that that uh i have on my list is to produce some samples for these key representations um in both kosaki and jw key as informational um so yeah any comments on that draft okay maybe switch to the next okay uh this is a this is another draft so um"
  },
  {
    "startTime": "00:38:00",
    "text": "next slide thank you uh so so the rationale for this is that um jason webb tokens which is obviously a related predecessor um to cebu webb tokens um included normative texts that permitted you being able to put jwt claims um in the protected heater however when cwt was standardized it it didn't really define the equivalent behavior and and this draft sort of rectifies or creates a mechanism to do the equivalent in cwt um and in general being able to put cwt claims in the header of kosovo structures has a has a couple of possible useful applications um next slide please so one of them is encrypted cwts in some scenarios when when you're encrypting say cwt there's a desire to have some of the claims that are also going to be present in the payload replicated into the unencrypted header you know this includes things like the iss claim um or token validity information they might facilitate in the decryption process help you help you say identify the key that you need to use for decryption or validate aspects of the token prior to investing in a decryption of it next um another use case we've found as well is is when you're using a kose sign structure that's featuring a detached payload so the payload may not in fact be a cwt and it may not actually be in this in the structure being able to use um standard cwt claims in the cose header of the uh of the structure just means that you're not re-redefining claims that are equivalent to cwt claims um for bespoke purposes so again we've found applications where we are producing content uh signing signing a signature over a detached piece of content and we want to be able to describe who the signer is and maybe some validity information over"
  },
  {
    "startTime": "00:40:01",
    "text": "that signature over that payload which isn't a cwt itself like a cwt structure so being able to put information like who the signer is and typing validity information in the header again is beneficial there and last one thank you and so just one key design consideration to sort of call out here the cwt claims namespace and cosa heater parameters are distinct registries they have distinct numeric allocations for their claims that pre-exist therefore we can't merge them like as as is the case in jwt where you can simply put iss directly in the header so this draft essentially intends it as as is registering a new header parameter whose value essentially is a map or structure that contains the cwt claims inside it so with that that's uh it's main only the description any any questions on that what are the next steps yeah so the the only outstanding question uh that i think we had we had um some feedback on on the list briefly about um whether or not to include a sample cddl within the draft to make it clearer exactly how it's essentially how it is represented within a coza header so that is something for me to follow up on ken then uh michael uh yeah just wanted to say thank you for the work on this tobias this is uh extremely useful especially downstream and other work items uh as a co-chair at community credentials group for instance i know there are multiple drafts kind of in process that will leverage"
  },
  {
    "startTime": "00:42:00",
    "text": "these kinds of techniques to kind of provide a pathway into more binary representations of some of these items and that's critical for high volume traffic especially in cyber physical supply chains where data still needs to be verified so very supportive of the work very much thank you for your time and effort on this and then kirsten yeah um i think it's a good idea to be able to to transport cwt claims with any cosy uh structure um the the one thing i'm not too sure about is that i understand what that specifically means um so if if you have a cwt in there and are putting a few more claims on the outside then it's pretty clear to me what what the the the combination of those claims would mean at least if they don't conflict with each other but if you just take a random cozy design data structure and and slap a few cwd uh headers on top of that that may not have a very well-defined meaning so the the answer to this question is of course that you can have more than one such header parameter for each weird kind of meaning you might have in mind so so you don't have to have a single header parameter that says i slap a cwt claim on this cosi structure but i'm not telling you what it means um that would would not be so useful so that's maybe a direction that we should look at come up with a few examples and and explain what putting the the data actually means um the other question you had is uh should you put cddl there and the answer of course is yes"
  },
  {
    "startTime": "00:44:02",
    "text": "so sorry just so i can clarify carsten so so in particular your question is around um the usage of of the parameter in um say the detached um payload case where the the um overall structure itself is is perhaps not it's not actually a cwt but um using that heater you're saying would be misleading well it's just not clear what it means um and i think we we should be very explicit these cwt claims are all defined in a way that can that they can be used in a certain context and if you pull them out of their context they still might have a meaning but not necessarily so i think it's a good idea to be explicit about what what is meant by that right i just um just to clarify though my observation is is if you register this as a general purpose claim where cwt claims can go applications would be free to use that and even structures that are using detached payloads right well i'm not talking about the claims the claims are already there so let's look at the not before claim of of um that we have in cwt that that's already registered now if i slap this not before claim on top of a firmware upgrade that is signed by me what does it mean so this is mike speaking as an individual i agree we should produce a treatment of these questions in the document we'll take an action item to do so and send it to the working group for review yes so i have a comment on that yes yes please okay yeah so uh we we know cwt is"
  },
  {
    "startTime": "00:46:01",
    "text": "cwt if it's a c if it's a cwt officially it's used for authentication and it has the authentication semantics like shaking his head no um uh so we we there so there's a draft uh for uh content types for eat and you know as we know eat uses cwt so there's you know we're trying to work through that there so i guess you know i'm not saying i have a the exact answer here but it seems like it is related to the content type that might be uh you know in the the cose header or in the surrounding mime identifier or in the tag identifying some tags around it so it seems like it might be related to that that was all we really wanted to share on that um design consideration so we'll take the action to document up some more of those cases to to describe the behavior and thanks thank you next up is ori steele about post quantum hello can you hear me is it good all right um so it's my first time presenting at ietf so uh apologies for any missteps as we get through this um so today i'll be talking about some work that we've done to attempt to represent some of the key and signature proposals that are coming out that are post quantum resistant so what's the deal with post quantum cryptography hopefully you've been uh reading the news lately there's been some announcements about it why do we why do we need uh post quantum resistance in in some of"
  },
  {
    "startTime": "00:48:01",
    "text": "these cryptographic constructions for digital signatures or key agreement and there's a long answer to that which i encourage you to to read on your own but essentially shores algorithms is involved in a number of the the answers um to specific uh questions on that front so um why are we here uh at the at cozy to talk about this um essentially what we would like to do is to support an upgrade path for folks who've been using uh cozy and hosey representations with uh you know pre-quantum algorithms for these post-quantum algorithms so we want to give developers a sort of familiar path to upgrade where things kind of look the same but now they've got some coverage for some of these post-quantum attacks so what algorithms and why as i mentioned before this is mostly focused on key and signature algorithms right so key representations for post-quantum schemes and signature representations for post-quantum schemes and i want to be very clear like we're here to propose the envelope formats the serializations for these not the fundamental cryptography uh that would be more appropriate at the cfrg and the works already uh underway um so specific uh constructs that we're looking at this there's basically your two two main families the lattice approaches um with all of the wonderful drama that comes along with them and the hash systems um and so we're hoping to register uh representations for both of these so that we don't just register one family that might all of a sudden suffer from a particular attack you know say on lattices if we only looked at registering lattices and there was a you know critical break um you know and attacking lattices that wouldn't be great so if we let register lattices and hashes together we get a little bit of a better defense and at the bottom you know like as i said at the beginning the biggest announcement is nist has finally"
  },
  {
    "startTime": "00:50:00",
    "text": "announced the candidates for standardization and there's been a call for additional algorithms um additional signature algorithms as well so keep your eye on on those announcements from nist and um that's a major reason why we're here to talk about it today next slide please i met the question do you want to take questions now oh yeah please yeah yeah uh just a clarifying question um you've said here that it's key representations that you're looking at signature and key representations do you mean signatures and key exchange algorithms or are you looking at encapsulating keys so we're primarily just looking at key representations like jwk or cosy keys and signature representations like you know the jwa jws versions or you know cwt representation so not uh it's no not any fancy sort of encapsulation in this this one you wanna think so no so no key exchange algorithms yeah this is uh mike perrock i'm uh one of the authors on the uh spec uh uh so brenden yeah just clarification we're avoiding any of the key encapsulation stuff right now we have focused 100 on the three signature algorithms based on three different classes of problems so we have dilithium uh representing uh learning with errors type problems uh you know falcon uh coming more out of the entrue side of the world and then uh coming in also with us thanks for the hash side but we've avoided it for a variety of reasons any of the actual key encapsulation exchange stuff for the time being that is a topic that will come up later but we'll have to wait on cfrg actions and some other items that we're involved in so okay thank you yup thank you"
  },
  {
    "startTime": "00:52:01",
    "text": "next slide please there are two more people on the trail i'm ben and kate here so i think i just want to uh solidify the previous questions so like you're looking at the key representation so you can like publish the public key that was used to make the signature yes sir and john yeah john erickson i think cozy should definitely standardize everything i think we should limit us to what in this standardize it but i don't think we should make sure that this it's not published before nist has published the final standards they might change we i don't think we want the situation where somebody starts implementing and then we are there there are discussions right now under this email list on exactly what what kind of uh algorith symmetric algorithm to use at least in the key exchange uh waiting with key exchange seems good because it might rely on hpk for that john mike again here uh yeah fully agree i think we should wait you know for any kind of final publication type stuff especially because parameterization is so key with so many of these problem types one of the important things though to get the draft out early and you know being refined is the fact that there are federal executive orders here in the us that are forcing us to identify a path for interoperability and crypto agility so if we're not doing that in a standardized way we will wind up in trouble where one agency is attempting to do something one way private sector another another vendor in private sector another way and so we won't be able to actually see how this stuff works in practice uh when we're working on a hard timeline so it's a little bit of a nuanced situation compared to normal but fully agree until we actually hit final standardization and can lock in the"
  },
  {
    "startTime": "00:54:01",
    "text": "parameter sets for each of these algorithms we should not uh attempt to finalize uh and publish i'll make a clarifying point about itf process which is pertinent to this which is it's possible and often normal to get a draft to essentially final status even to the point of it being in the rfc editor queue but it to be held there until the normative dependencies that it takes such as the algorithm definitions themselves are final so um i mean our area director could also confirm this but i would encourage you to work in parallel with nist and the cfrg so that we can all land at the same time thank you for that advice that's quite helpful though pop out is 80. so yeah i i encourage you to to join the the the pqc list that we just created uh because this is coming up in multiple different uh working groups and so on one hand we want to avoid like everybody doing their own thing and coming up with something different uh we want like people to learn from each other uh and and move forward in a somewhat more structured way and see if we can we can like de-duplicate some of the work yes and uh we are already on that list and actually are making sure that we have co-editors on this uh for instance michael osborne and christine who are working on some of the kind of lower level representations of some of these keys so that we have good overlap between the authors and editors etcetera that are working on this perfect i think this is my last one yep so i think we've gotten into a bunch of the specifics already but just to sort of highlight the nist announcements a sphinx plus that's the hash based system uh falcon and dilithium two lattice-based systems that"
  },
  {
    "startTime": "00:56:00",
    "text": "are included in that announcement um as i mentioned before you know we want to see an intuitive upgrade path for these post-quantum schemes in some cases there might be folks who are jumping you know from staying in rsa for a very long time to some of these newer systems if we have an encoding representation that can support them um so uh as i mentioned you know some agility in the in the post quantum sort of family is is is also an objective and we we want to anticipate the potential for you know exploits or attacks on a particular family so um again cryptographic agility a good thing another sort of key goal here is as we mentioned these envelope formats and we were talking about you know kty and crv and these other key representation um components um registering you know two new families of cryptosystem at the same time really forces us to re-evaluate uh or clarify how the existing term definitions for kty and you know crv these other uh key represent key representation terms are to be used and so this is a great time for us to provide better guidance on clarity on some of the the questions that were raised before in the hpk talk um and again you know in the draft we're going to be calling for reservations for some of these uh key and signature you know types the the algorithm definitions the key type definitions uh john what about hybrid systems or whatever the idf choose to call them yeah i think nsa said they will go with pqc only in cnsa 2 does here at least i think that was what france has said that they will enforce um hybrid solutions for the next"
  },
  {
    "startTime": "00:58:00",
    "text": "years will you standardize i didn't see that in the draft is the will you is the solution to nestle things or will you suggest some it should be discussed at some point yeah i think it need probably needs to be supported both purely pure pqc and hybrid excellent question there's there's been some discussion about that already um and and my my position on it is we should be clear about representations for post quantum schemes before we talk about hybrid schemes combining them so i i see this as a necessary step towards that objective but um certainly they can that work can start happening in parallel as well and i i think both of those are good ideas to sort of proceed with just specific to this draft we're only focused on the post quantum key representations and not registering approaches for hybrid schemes or a two minutes next slide this is i gave him the harder ones or he's going to put me on the spot but i would say let's just uh being time conscious since we've had good engagement here can we flip to the next slide here really for us this is about next steps we've gotten things up to 101 draft had great feedback in especially from some of the authors and great support from folks who are working on the core signature suites really big next steps for us now is clarity on kty and alga as mentioned by ori and also has came up with the illari situation earlier in some other contexts as well so those are things that i think are great discussions on the list um we are now adding since standardization path has been announced we are adding in good detailed examples for falcon and sphinx so we have those in for dilithium already we'll now be doing the same for falcon and sphinx and that moves us into piles and piles of test vectors which i'm of course going to try to hand to ori but always love"
  },
  {
    "startTime": "01:00:01",
    "text": "help on um key thing for us is we would love to get this adopted by the working group there are a lot of details here there are a lot of smart people in the working group and in the room we want feedback in because this is going to impact all of us uh so that's kind of the next uh key step that we're after is kind of moving it you know hopefully from a place where we can begin to really work on this seriously into broader work with the working group itself any discussion on that point in the interest of time does anybody want to speak against a call for adoption being sent to the mailing list hearing none the chairs will proceed to do so thank you thank you mike and ari okay and that brings us to the end of the meeting we have zero minutes for any other business if you want to say something please go to the map now okay well i think no one running for the mic and the meeting is officially over thank you everyone for your participation thank you oh okay"
  }
]
