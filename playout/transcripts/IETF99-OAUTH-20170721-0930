[
  {
    "startTime": "00:00:05",
    "text": "okay here quick the guys claim that you are first legend I missed you guys too yeah I had another meeting appointment was it interesting you there\u0027s no possibility to discuss something anybody in such a large group yeah William - William do I knock your slides for the device bro we want to achieve did you need to click yep thanks all right good morning everyone thanks for joining us on Friday morning here to "
  },
  {
    "startTime": "00:03:05",
    "text": "talk here to give a bit of an update about their device for draft so just a quick word on the status so we\u0027ve actually already cleared working there have been a couple of changes proposed so I\u0027ll go over those changes but hopefully we can get this thing done pretty soon so a bit of a recap first what is the what is the device flow device flow is authorization flow designed for devices that have internet connection but maybe they don\u0027t have a browser or they only have a very limited input mechanism in that case the user will be reviewing the authorization request on a secondary device like a laptop or a smartphone so how it works some like this the TV app as an example the TV app will display a URL that the user will need to visit on their secondary device and a code that they\u0027ll need to enter user then visits that URL on their second device and is the code and from that point it looks a little bit like regular or from a consent point of view during that the device continues to poll one of the endpoints the token endpoint with a with the device code to see if the user has completed their action and if they have completed their action they\u0027ll get back the Refresh token an access token so it\u0027s kind of like the authorization service sort of issued like an authorization code that\u0027s not actually yet valid and at some point in the future it may become valid or may become invalid it\u0027s gonna work all right so on at the important stuff what changed since 98 the first thing is we had a fairly lively debate on an if you recall in Chicago on the user code pram so this was a proposal by James manager from Telstra and the idea was what if we could include the user code in the verification URL so if you\u0027re not familiar with the draft the authorization server responds with a number of different fields in the authorization sorry the verification URL is a separate field to use a code and the intent is that these things are separately consumable but you know what if you want to do something like this right so what if you want to have a QR code or you know any kind of like non textual transmission of that URL depending on kind of where you are like I think I think in America people don\u0027t all really know what QR codes are so we don\u0027t actually see this a lot but it\u0027s kind of a good example you could replace that with a Bluetooth it would if you want any any way of transmitting URL so what we talked about this was kind of generated a lot of debate particularly because I said that actually my own company\u0027s server won\u0027t be using this for people like well why are you putting in there the consensus call was that it is worth doing so in the 0-6 update we did "
  },
  {
    "startTime": "00:06:06",
    "text": "actually document that with some appropriate security considerations this is an optional enhancement so it\u0027s fairly well interoperable because the authorization server will still display all the information and we\u0027re actually requiring that the client still actually display the two pieces of that information separately so if the user doesn\u0027t know how to process that thing whatever that may be they can still sort of fall back into it manually and the authorizations have actually doesn\u0027t support that and the user happens to scan it they\u0027re just gonna end up at that URL and have to type in the code anyway so it\u0027s kind of like the the client it\u0027s completely interoperable in a sense that the client doesn\u0027t have to actually rely on the service appointment it can it can just sort of try it as a best-effort and everything will kind of still work these are kind of one of the nice things about this this flow is that it\u0027s sort of very fairly durable what we see a lot of people doing is they might try some more advanced method of pairing say the TV to the phone you know maybe they have their own app installed so you know you you you might and this is like out of this spec but you might like to open up that app and do something and then kind of fall back to to this stand flow so Justin I think is joining us at 3:00 3:30 in the morning apologies he\u0027s online at 3:30 in the morning he posted there\u0027s a couple of open questions at least I\u0027d like to go through and just remember that the draft is sort of beyond working group last call but so this is the last chance to finalize some of these normative things so the first thing he suggested was instead of specifying the user code parameter in in at your old construction that I mentioned what if the authorization server has turned a separate parameter so just to be clear currently the authorization server is returning to fields verification your I and a user code and we have normative text to say that you can join them together using a URL parameter justin provides an alternative which is have three parameters related to this whether it be like a third kind of optimized URL so I don\u0027t know if Justin if you\u0027re awake did you have any comments you\u0027d like to make it this time on that since it was your idea hey Justin go ahead you can see it all right morning everybody so the basic thought here William if you could actually go back to your your high definition TV graphic there thank you so this picture is actually impossible with the current spec because what you would actually get is example.com slash device : user code equals wdg boobarella "
  },
  {
    "startTime": "00:09:07",
    "text": "what\u0027s etc and yeah that thank you you would get that on the top line that URL and if you go go back to the other thing you would you would get the plain code on the next line and then then that QR code so this this picture you you can\u0027t actually get this picture with the current spec ah I think you can actually say unless I\u0027m anything which is entirely possible right I kept you out because the device authorization employees returning HTTP colon slash slash example comm device that part as the verification your I then it\u0027s returning a separate Jason parameter called user code without with that value spec is basically named as an optimization if you wish and you want to display that verification your I non so textually then you can use a parameter standard URL parameter that happens to match the key of the jason called user code and pass in the euro so this basically tells you how to construct this optimized euro so that\u0027s constructed client-side then i correct right that was that was unclear to me even in in reading the new paragraph in six so let me let me reread that again and I may have some some wording changes so see I thought that this constructor URL was coming from the server so that\u0027s my mistake but because I garden path on that I\u0027ll I\u0027ll read through what is that section three three one again and and see if we can armor that a little bit better so that somebody else doesn\u0027t do what I thought that you were by investing that we\u0027re doing so be back yeah great okay fantastic so I withdraw my my proposal okay whatever it was it\u0027s three in the whatever I hate you for joining his goal on your prices to see them alright want to make the same suggestion that Justin was originally making for a slightly different reason and that is as it stands with just the two parameters you are then requiring the client to do this construction of the complete URL you\u0027re requiring that the user code parameter then be standardized so the client knows what that is that\u0027s putting a bunch of work on the client which historically doesn\u0027t always go so well additionally it\u0027s limiting flexibility on the part of the the server because now the the endpoint that receives the "
  },
  {
    "startTime": "00:12:11",
    "text": "user code via query string and the end point that the customer would type that quick user code into have to be the same which may or may not work out they may want to use a different URL for the parameterize endpoint perhaps one that is going to be captured by their mobile app if it is on the device whereas the simple to enter shortened form of the URL may not be that\u0027s a good point Oh buddy something important ah I forgot meeting minute taken Mike can you take if you know it\u0027s is that possible because you\u0027re not presenting today or you have no left and that was from Annabel Backman from Amazon Mike for your benefit yeah um for the Chavo can someone take a look at the Chavo room to see what a chest in or or hunts or fill both some questions it\u0027s Friday yes see if someone could I could open the chat you don\u0027t give right the chopper okay thanks okay sorry um so what is the conclusion okay well firstly to discuss your point um yeah I think it\u0027s a good point I guess you could potentially two different targets for that a couple of other things I thought about in trying to trying to come up with an opinion on this was also an you see end of a higher entropy code for that magical one so that that could be beneficial in some way yeah I guess I\u0027m it is why the other thing is that you would actually know that the authorization server supports that um yeah on the flipside I guess it\u0027s you know it\u0027s one extra piece information coming down yeah I don\u0027t know I just broke both his I complex like you said in this case I think the construction the URL is very simple so as much as I would normally agree like let\u0027s get everything away from the client as possible I would really hope people couldn\u0027t make a mistake with this bit but maybe it maybe they would URL parameter encoding is hard I mean it\u0027s not but yeah harder than we think it is yeah that\u0027s a good point that probably should be added if we keep the context "
  },
  {
    "startTime": "00:15:13",
    "text": "sofa pill they didn\u0027t quite catch that D card asked is is the either a requirement that the existing user code be you\u0027re all safe and I\u0027m not intelligible we may specify an alphabet for it we may specify a character range for it I believe there\u0027s a character range required as specified right which i think is probably URL safe yeah I was gonna say if it\u0027s not required it\u0027s certainly highly suggested by the by the character suggested to be easily interpreted by the user right we\u0027ve known the authorization server to attack the client though there\u0027s some kind of weird malformed girl something in my experience I\u0027ve seen with clients implementing our os/2 based services is they frequently aren\u0027t reading these specs so yeah I know right yeah so it\u0027s a banking on clients having an understanding of what is in the spec and isn\u0027t and and what the actual you know what\u0027s reasonable to expect around the values these parameters isn\u0027t necessarily a safe assumption as far as right hoping that\u0027s gonna make things easier for them right just let me know when I\u0027m you guys hear me yes oh so oh thank you life so I to Brian\u0027s comment about the character set suggesting things that are easy to type I want us to keep in mind that that presumes a you know a us style you know ASCII keyboard is as far as things that are quote easy to type there are lots of keyboards around the world that put lots of non URL say characters well within reach and it might make sense in other contexts to have things that are very easy to recognize and type that would still need to be URL encoded so Annabelle\u0027s point about URL encoding I think does have merit from the microphone suggestion shucky yes Annabelle back then Amazon reiterating just in suggestion that we have a separate parameter that contains the I guess clickable URL that has the code embedded in it so there\u0027s two experiences we\u0027re talking about here one which is the the primary one that Williams presented that is the customer "
  },
  {
    "startTime": "00:18:14",
    "text": "user types in a URL and then types in a code the alternative is the automated experience where they engage with the QR code or through some other mechanism a URL is opened that already has two code embedded in that have a separate parameter for that URL so that the client does not have to try and construct it that reduces the amount that we have to standardize on these endpoints cuz then we no longer have to standardize a query string parameter for the the user code and it opens up flexibility for the server to use a different endpoint for that express the code in some other means or have a higher entropy code that just decouples that from the streamlined four user entry experience this is Dave Robin I was I would not wanting to repeat everything she just said because I think it\u0027s great but one other possible wrinkle here or a use case is that in this case where you\u0027re presenting the the the type of all URL and they\u0027re capable code you\u0027re sending the user to a very ui/ux HTML based server guy that\u0027s serving up human pages he may in fact be turning around and sending it with a no garbagey code to the back-end server who\u0027s actually completing the operation so with there\u0027s some opportunity here to just send them straight to the garbage you got you know the skipping the the whole UI server the one that\u0027s got pages and stuff to interact humans in and so with this option with the QR code they could scan that go straight to the final representation guy with the the right code and just skip a step skip a server waiting for you so nuts a chimera number as such I support on about idea I mean in one of the the implementation we have entirely off we actually do sin your eye which is good idea as well as we kind of send sure called the image itself okay because the tunnel could be really dumb right I\u0027ll just scan you use a code in the text and I don\u0027t quite see the exact constraint and user code so okay actually what\u0027s it to that point - somebody\u0027s point it might be you know if it\u0027s a user call it might be also a good good idea to you know not to constrain too much right in the sense that for example if you\u0027re using Japanese form right smartphone it\u0027s actually much easier to type Japanese character them "
  },
  {
    "startTime": "00:21:14",
    "text": "off of it so I have a question for you if you could say that for one second so so do you think that would actually make the most sense from a user point of view in Japan to have a like a hiragana code or yeah okay that\u0027s much easier okay so we should we should document it as unicode yeah but then that means that but no exactly that means but that means that composability of your eyes Walter Scott their card Amazon we recently looked at stuff that people could type in across the world and concluded the digits work really well okay and that anything that\u0027s a char set it\u0027s like it\u0027s confusing with different boards and all kinds of other locales and so potentially just having a few pure digits cuz you only got 20 bits now and I lose half the res right everybody can notice what a number is yeah I guess that\u0027s kind of why we landed on on the imma characters to double the right but are you buying I mean all you need is one more right character one more thing and accuracy like how many how many numbers do you typically use in such a I don\u0027t know if you\u0027re talking to this exact type of flow but no not that exact type of flow but we as we\u0027re choosing things we realize that numbers are much easier for a number of different types of input Marian isms right particularly when you move to voice right mm-hmm good point so that\u0027s a kumara Inara again yeah i fully support if we are just going to number that\u0027s you okay I\u0027d probably rather not do that because it\u0027ll bring our running code out of compliance but I I think it\u0027s an extremely good point yeah I mean yeah right yes so so dangerous things with characters you can accidentally create words which actually happen to us so we dropped all the fouls so that\u0027s a kumara again if you really want a high entropy stuff it\u0027s actually kind of good to send down the QR code image yourself you can climb a lot of deceit right so the QR code with the has a complete URI I got my gear ID to an image which you download and it\u0027s the card yeah so I guess the only drawback with that is that it assumes that a secure code so this is in my example was was the example um I guess I could see like NFC being another way to represent that "
  },
  {
    "startTime": "00:24:14",
    "text": "that Europe potentially oh you you mean like you mean like adding another parameter yeah I\u0027m the so we\u0027re talking about optimizing user experience right right yeah so if it\u0027s targeting the QR codes in the QR code directory if we are targeting NFC maybe optimized towards NFC okay actually have another localized usability question for you you can st. so so do you see like this actually been successful with QR codes as per this example in Juba well right and you know bunch of ATMs are actually using that even not not even within Japan but for example in Singapore I guess the same in Australia as well so you know two people doesn\u0027t have to carry around a mouse right core right but just use their phone and and you think that that parameter should that be additional to the additional parameter or should that be instead of that\u0027s a good question okay that\u0027s really well yeah that\u0027s a good question but yeah if it\u0027s okay then you know well you also have to think about I\u0027m not very familiar with the NFC kind of things but if you think about sending something for the consumption of NFC device and I have to do that you may need another one so you might have you might you might want to have if the John Bradley yubico if the device supports NFC just sending a URI over NFC is actually pretty well understood that\u0027s enough yeah I don\u0027t know that you need to send a set unless you\u0027re doing something super complicated just sending the you if we had a separate URI having the device send that over NFC you ought not to need another parameter or must be conveniently horribly wrong so the only question is whether or not devices have a library to create the QR code locally yeah that\u0027s that\u0027s ridiculous it doesn\u0027t history that could be a remote okay Jerry yeah so I guess like as as currently written even with the even disregarding the decision between the composability or not the kind of point was like he\u0027s this year all that you can use transmitted however you want to transmit URLs and so I I did like this it was FET and yeah yeah to that point I think if we try and get into tailoring the spec to particular transmission technologies where we\u0027re gonna go down a huge rat hole of "
  },
  {
    "startTime": "00:27:15",
    "text": "never-ending do we want to support this do you want to support that yeah if we limit the spec to getting the code from the server to the device and give it with it with enough flexibility that the device can then get it to a secondary device through whatever transport makes sense then I think we\u0027re solving the right problem right yep a couple things pickhardt again it\u0027s not clear to me where we\u0027re really working on Interop right as opposed to this just being a best practice so as I looked over the doctor wasn\u0027t really anything it says like who are when are they two different parties as opposed to all the same party but it\u0027s all the same party to do whatever they want right which means maybe this is more of a good guideline around how to do it well so people don\u0027t do stupid stuff but is there it might be easier to sort of call it case where it really is requiring they are two independent people right which you know auth is you know there is two different entities that are trying to yeah at the flow yes I mean Justin I actually did do an interrupt s he\u0027s servin my client written commitment apparently it doesn\u0027t mean like like like a real like yeah the world instance where the device and the server are from two different players yeah does that happen I I am not aware an example that comes to mind I guess that doesn\u0027t mean there isn\u0027t one okay so so we are but I\u0027m not sure that it would necessarily work that we would necessarily want to do this because the you know the model here is a very browser web oriented model where the world\u0027s moving more and more to a mobile app model right look at the youth the customers aren\u0027t gonna go and pull out their laptop necessary they\u0027re gonna pull up their phone absolutely are pulling out their phone then you\u0027re really trying to bind the device to potentially an app running on the phone and that the users already authenticated that app right as opposed to making user authentication to something in the cloud that they don\u0027t really other credentials or anything for and so I could see the QR code helping where you really scan it with a QR code which essentially eventually launches the app on the phone and so the users already authenticated and randon really the only UX is an approval process by the user right and in that case like you\u0027re saying you don\u0027t actually need the Interop you control both sides no you don\u0027t I\u0027m not no noise okay right so in the Alexa world right there\u0027s many third parties that are putting out devices where you want to enable that third party to make calls into Alexa okay so we do require some inter out there although we could just say what to do correct our world yeah but it would be nicer if it was standardized and was "
  },
  {
    "startTime": "00:30:16",
    "text": "more of a practice but we would probably want more of a flow like that right I described in a flow that\u0027s very web oriented I that makes a lot of sense to me um also I presume you may need a fallback in case the user doesn\u0027t have the app installed or is using a device not supported by your app it\u0027s pretty hard to turn a device up against X you\u0027re climbing yeah I guess it\u0027s not a requirement just hard right because they definitely exist use case I\u0027m aware of where where you may want like an optimized flow but then you still want the fallback of the browser so you still want to fall back yeah but the you want the 80% case to work super quickly right right and actually one of the cool things you can do with this with this construction here is that you can actually use this as a paring a visual pairing confirmation code too so the fact that that data is already there be like the Bluetooth kind of parent like you know Easy\u0027s your TV thing I loaded I scan something but is it really particularly helpful when you\u0027re working on the team it is like hundred of those devices in proximity but also relevant for Ponson hotels john bradley yubico so i\u0027m influenced by the arguments that having a separate precomposed uri that could have a different endpoint and perhaps different into amount of entropy then the user type of all one is probably a good idea given that a lot of this will be either NFC your QR codes to to an app which is I think they growing or even audio to an app there\u0027s a number of different ways I don\u0027t know that we should add the QR code directly we may want to leave that as an extension so that apps could have an introspection endpoint that gets a QR cry from the URI etc so I think that you know trying to generically add QR codes or sound files etc should probably be left as an extension but I guess the other thing is that doesn\u0027t Google already do this sort of thing with printers there are you know Google doesn\u0027t yet make printers but there are printers that use we have Isis absolutely right so that is the case of a third party client okay yeah yeah I mean YouTube speakers customers actually YouTube\u0027s app but yeah right okay no that\u0027s a good point the printed one is I guess I thought you were meaning like with that "
  },
  {
    "startTime": "00:33:16",
    "text": "printed you know potentially be doing this exact flow to another authorization server as well and well what we have to do is care about the interrupts where the device manufacturer I ye Epson isn\u0027t there they even still make printers I don\u0027t know that they\u0027re they\u0027re not providing the Oh hot server it\u0027s um ready their personal or some print service which is offered by Microsoft or Google or whoever right so we have to think about some of the interrupt things oh I can also by making the code numeric for four reasons at least as a recommendation all right so I guess I feel like there\u0027s sort of two changes that we\u0027re proposing here one is to move to a separate your I as the current optimal one and allowing any character in the user code but suggesting numbers is that what I\u0027m hearing strongly suggesting numbers well that we may not care about anymore if you\u0027re saying they could kind of make up anything you still want them to go and make it you are all safe right but only only with this proposal I guess if we move to the separate your I then I guess that that doesn\u0027t matter anymore what\u0027s that your your wanting the client to construct no move away from the Franklin stocking so the client would no longer be constructing the URI if we combine the two proposals right yeah I mean I just worried that clients doing stupid stuff of URL encoding something extra and then it breaking so like if you\u0027re handing them down to URL you want it to be a if yeah I think if we make it unicode then I definitely agree let\u0027s just send a set a separation Here I am a sense so I don\u0027t want to vote on that needle nobody how this truth do we need a consensus call on any of these items oh no that is early age yeah not I think that also sums and like a fairly recent I don\u0027t think we need to okay like having a euro safe and making recommendation to use numbers like okay who wouldn\u0027t alright so I think the decision then unless anyone objects um so Mike Jones I guess an ala bit I don\u0027t "
  },
  {
    "startTime": "00:36:19",
    "text": "understand this well enough to make a really informed comment but introducing a second endpoint that\u0027s distinct from the one that\u0027s already in the spec seems like a pretty big change to do at this stage in the game yeah that\u0027s the language people have been using is having a separate URL and a separate and white so what am i confused about I was gonna grow up and say the same I mean it sounds not to get into the details but it sounds like a bigger change than a working your last call change and you might want to be spend another couple of weeks working with less coal something like I believe the suggestion is to add a new parameter which has a pre composed version of the URI which enables the user code to be have higher entropy and be pretty URL encoded which gets around the problem I we also need to think about the user displayable user code if we are actually using utf-8 what is the script there\u0027s there\u0027s other issues that tend to send specs into a tailspin once you actually attempt to internationalize them in that way not that I\u0027m saying it\u0027s bad but just sending you to a utf-8 characters doesn\u0027t actually work for everyone but certainly whatever we do with making the displayed user code internationalized that immediately leads one to having a separate precomposed URI I believe Ana bio made the suggestion that if you had a separate URI that you were sending precomposed you or riot could actually have a different path but that would be an implementation detail we\u0027re not saying that you need a different endpoint but as an implementation detail if you wanted to do if the AAAS wanted to do an optimization nothing forces it to have exactly the same path I guess we will have to look at the pics to see how this could comment on the you gf8 concern because I think we like not to walk away here and have that whole thing blow up so I guess we\u0027re not gonna require our clients can display any character they ascend at them you the authorization server would have to use its best judgment for the market No he\u0027s so the the client needs to know in some way what the script it\u0027s supposed to display utf-8 characters in that the server on its own okay if if these are actually interoperable separate devices "
  },
  {
    "startTime": "00:39:21",
    "text": "if you had you know I have a Korean printer that knew that it was going to use Korean script that but as soon as that shipped to South America that\u0027s not gonna work so well so somehow we are actually allowing international like characters as opposed to numbers the script needs it\u0027s not my fault I\u0027m not I wasn\u0027t yeah i yeah i think dicks idea is looking better by the minute I just just said that the utf-8 might be Japanese character would be easier to type that alphabet right in Japanese smartphone keyboard but I was just asking for something some cause some kind of thing which is reasonable to people to type in and numbers just is it okay so let me let me only see if we if I get this right well we\u0027re gonna keep it the same it\u0027s it\u0027s numbers and A to Z at least we don\u0027t break my Interop wait a minute wait a minute if we\u0027re if we\u0027re saying our sending characters shouldn\u0027t be harmful to your Microsoft would agree yeah so let\u0027s keep it as is and add in internationalized like usability considerations and suggest numbers as the as that to solve that problem Annabel Backman Amazon just to completely bury the utf-8 discussion they keep in mind that the more complicated the display requirements for the client the more devices and use cases we exclude from being able to use this the whole point of device code is that it is usable in scenarios where the device has constrained input and output so if you\u0027re agree if you\u0027re trying to output everything in Unicode that\u0027s gonna be really hard on a really low res LCD display I agree I\u0027m right I\u0027m sad I\u0027m sad that we won\u0027t be I\u0027d have a emoji based user code now but that was a brief for a few brief minutes that looked possible and then quickly to further address Mike\u0027s comment and John is right that I think we\u0027re we\u0027re not talking about necessarily a defining a separate endpoint we\u0027re just talking about defining a separate parameter with a URL that may or may not point to a different endpoint and bear in mind that the spec itself says nothing about what those endpoints do it\u0027s very deliberately leaves that up to the a s just as oweth leaves the process of resource owner identification and authorization and all of that up to the implementers did but the this spec leaves everything that happens at these endpoints up to the implementers alright "
  },
  {
    "startTime": "00:42:21",
    "text": "later on so so we went from here\u0027s a URL type this in and type in these characters to you know multiple at least two ways you can get hopefully to the same place as anybody don\u0027t security analysis on this are there any aspect is there any security aspects involved in you know two ways that are supposed to take you to the same place we should we could talk to the security research and let them do include that in their formal analysis they like today I am no idea I mean I guess part of the discussion we had at the last idea force that that there are you know when you when you present that the like the first generation of this user interface here\u0027s an input box you know type this right that\u0027s like maybe harder to to confuse or you get confused users over or get wrong I have no idea but again this seems like something crankiest crank this out in a in our last call comment dish needs somebody to look at the reviewers it sounds like this change will what we if we accept the change yeah we have to look at the text and I think we we definitely have to discuss it on confirm it on a mailing list so yeah whether it would be big enough in the end to have another working group last call I don\u0027t know but it shouldn\u0027t be a big deal anyway and then that was not a joke with the security researchers like they we had this this meeting and they they offered help with some of those activities so we can we could yeah yeah I mean definitely one of the things I liked about the old way is that it kind of full it sort of falls back very nicely if if the if the server didn\u0027t understand the ural it just displays the original you\u0027re all anyway but I guess it shouldn\u0027t be sending something it doesn\u0027t understand in the revised proposal anyway so dave roman i think is a method documented 0/6 being the old way I\u0027m curious to make sure we understand where we\u0027re ending up and where we\u0027re going with this because I think I heard two different things um one is that if we make the code URL safe then composition by the client there\u0027s no problem we don\u0027t have to worry about we don\u0027t say a lot of things about it but also then we have this idea of providing you the complete URL which requires no composition so the question is implementations aside yeah are we deprecating what you show on the screen right now in other words the code is only for typing into web pages and the compose URL is only for you know sending it as a parameter having what you have on the screen now of user code equals "
  },
  {
    "startTime": "00:45:22",
    "text": "that which is composed by the client somehow based on these two P the first piece is one and two to make this URL is that option still on the table other than I mean other in fact that implementations are doing it today perhaps but if we have option three if we have parameter three I might make the case that client composition should never be done and this server parameter of user code equals should never be allowed that it\u0027s opaque because you know I\u0027m that that just that user code equals URL parameter is just not a thing yeah it\u0027s either opaque in case three parameter three or it\u0027s never used in one and two you go to one you type - yep I do agree so we should document one or the other not both absolutely and and maybe yeah absolutely let\u0027s not do both let\u0027s pick one Annabel Backman Amazon - the security considerations point there is text in version zero six of the draft that brings up remote fishing concerns around the composed URL so that the current draft does actually address the or at least raised the risk of increased ability to trick the user when you\u0027re not forcing them to type in a code that they see on a screen so I encourage anyone who\u0027s who\u0027s interested or concerned about that risk to review this back and take a look at that language and see if there if you have any concerns beyond what\u0027s address there no it\u0027s it\u0027s it\u0027s more guidance for the authorization server around making sure that the experience they present through that composed URL still gives the the end user the ability to detect that phishing might be going on yeah um it yeah it kind of raises the bar necessary for that experience basically yeah and comment on phishing I guess like one of the things that we were trying to establish is basically are you setting up a device and use that device currently in your possession that was sort of the the challenge that we were trying to answer and so when were think about like what UI to show we really think of asking that question like is the device in front of you and is a display nice coat you know to try and mitigate that you know might be the draft Lucy Lynch just a process thing Honus I think these are enough changes that it\u0027s breaking for last call and it you would have to last quick again since fine thank you all right we do it there is another another open question so let me let me go this say yeah we added some ascii diagrams that\u0027s so good justin pointed out that after discussion at least that while it\u0027s a polling protocol there is no actual requirement you have to pull at it there\u0027s no requirement you pull that anymore you can follow a slower interval you can wait for user interaction to initiate a a poll that would look more like a single request okay so there is another "
  },
  {
    "startTime": "00:48:25",
    "text": "another last me of talking a little proposed after one group last call and this was an interesting one because they were kind of three people it kind of came up with it all the same time well the same time and an edit this question um at least for the minutes in the working group what is motivating people to want to make these changes now i really don\u0027t understand what these are for i wasn\u0027t what we have fine I guess I don\u0027t really know what they might\u0027ve sup but I I\u0027m assuming that I was the one grab last call that triggered some last minute reviews it\u0027s maybe miss perfect fine to provide these comments at this stage even at the idea of passports so I don\u0027t think I\u0027m not questioning process I\u0027m asking from an engineering perspective why do people want to do it differently than it\u0027s already specified I don\u0027t understand that I don\u0027t I don\u0027t think they wanted to definitely my sense is more like people and I\u0027ve seen this in other environments since we are further along in the process people look at this and found out that they can actually use this document to cover some of the use cases specifically some of the IOD use cases and it\u0027s actually experienced that myself in the healthcare space some people look at it isn\u0027t that I actually this is what I want their card Amazon I mean we started looking at this and started looking at where we\u0027re going and then we saw some of the issues particularly of characters vs. digits okay so they the other kind of major change that was proposed is is relate to this fact that you may have multiple device is that our actual the same so take for example a Roku device if you have say two TVs you may have two Roku\u0027s both authorizing to YouTube or or however and both would actually the same client ID and so the reason proposed around ok so if they both have the same client ID and the user say loses upgrades or souls or stolen or something if one of those devices is gone how do they revoke just that one device and as written the the spec is doesn\u0027t really provide any help to the authorization server to provide a good revoke experience I guess you could look at when the token was last used but that probably doesn\u0027t help a hollow someone bought it off you and is continuing to use it so this this is an edition it doesn\u0027t really change the actual protocol at all it just passes a little bit more information about the device to the authorization server it to allow the authorization server to store this information these three fields associated with the grant the motivation is is for revoking so let me give you an example with the with the Roku the device ID would be a unique ID of the Roku the purpose to revive that is so that that device can be represented as a single entity for revocation so you could have multiple apps from the same authorization server with one click the "
  },
  {
    "startTime": "00:51:25",
    "text": "user could revoke that entire device the second is the model just so that you know hopefully this is available to the app they can just like kind of query like what am i running on like oh it\u0027s an Xbox 360 is Xbox one or whatever which may actually have the same client ID depending on on the implementation and then the final is and you know this week extremely optional they\u0027re all optional but this would be the most optional it\u0027s kind of like does it have my secretary name if so past that as well so then you can imagine this revoke experience or it\u0027s a William you know you have a chromecast and a Roku and another rogue or something and it\u0027s like living room Roku and you can kind of just revoke that and and yeah Annabelle vacuum and Amazon this problem doesn\u0027t seem unique to the device flow to me it would equally apply to a native apps running on mobile devices where you do have rich user input and you are potentially entering credentials right on the device so this spec does not feel like the right place to solve this problem yeah absolutely right that any native app has the same problem and justin has a spec from 2010 to sell you yes so he can\u0027t had this idea all those years ago I hadn\u0027t actually seen that tool until recently we kind of came up with this to try and solve that revocation experience there was another contribution on the list as well it was similar I will point out that the device authorization endpoint is strictly speaking a different endpoint so while we for better or worse reuse some parameter names across the two endpoints I and given this in working group last call just from a well about to be again from a kind of process point of view I think we could document this here if this was an acceptable pen and I mean if we really wanted to we could review these names and maybe not call it device but I guess I don\u0027t disagree I guess I\u0027m just not sure exactly like how do we solve it like now for the device for you and given we would actually need to document it separately it doesn\u0027t matter I guess I I think if we end up with two different ways to do the same thing that creates a lot of confusion for for implementers my other concern here is that if we are overly prescriptive about what pieces of information we\u0027re asking for for device identification we run the risk of ruling out use cases where right potentially we need more than just these three pieces of information that we\u0027ve identified here that work for the cases people are immediately familiar with okay two points about that so what when is our optional so for example like I know there are some device that may not have an ID so don\u0027t send it you know it\u0027s it\u0027s still useful from a UX perspective to know the name of the device you can still perhaps do some useful things around that particularly it has a name that could be unique and the user kind "
  },
  {
    "startTime": "00:54:25",
    "text": "of differentiate even if even if there\u0027s no like even if you can\u0027t correlate the different grants in order to revoke the device and ones yeah on the other point was the other point William I think this issue came up in Chicago already like in a question of like what are we actually identifying in terms of client in there I had the impression that we also talked a little bit more about our more extended functionality than just having some parameters that are obviously non cryptographic so one could argue that maybe you actually want to do some form of authentication potentially at the station that stuff you have been proposing in a different context that would actually be appropriate here as well because those are those are parameters you use them for revocation but you actually as the title says you may actually use the mouse for authorization I mean that\u0027s not as not as we can\u0027t use them here now because they\u0027re just physics unless you could the device which is big I guess I guess I should get your other point to that you know maybe these aren\u0027t enough premise my hope is add you know if there is a common minimum set that we think a lot of devices need you know if you drop reasons let\u0027s let\u0027s document that column unit of Z I guess not trying to capture the every possible field ever but I mean I I do have a very specific use case and a reason for including these for potentially including these parameters like I mean honestly I don\u0027t really mind if it doesn\u0027t get included this is something that you can always don\u0027t miss separately you can say like hey if you\u0027re talking to Google like won\u0027t you just add these and then we can give you as abetik revocation experience.i we have a use case for this I think it\u0027s a reasonable use case so I\u0027m keen here any others I don\u0027t personally I haven\u0027t actually personally seen the attestation or anything like that in the wild but I guess the attestation is obviously on the sort of more extreme and in the middle that would be some form a cryptographic form of this and and this is sort of like on the on the on the on the other extreme it\u0027s basically some parameters that the device can easily sort of free flow right okay I just I don\u0027t really have a strong that proposal bed hey I do depart so the device IDs problematic because if you\u0027re just declaring it there\u0027s no binding time that\u0027s not enough attestation right you\u0027re trying to say I\u0027m a particular device and yeah anything could do that the other two are useful from a UX and and because users not going to know whether it\u0027s the right device ID thing easily or anything right so what you\u0027re trying to do is is it in the authorization on the web app or whatever app the user is when they\u0027re deciding whether they want to enable this device is you can be showing the model and the name as part of that to sort of complete the flow of am i authorizing the device that\u0027s showing me display here and so "
  },
  {
    "startTime": "00:57:26",
    "text": "the device would show here\u0027s the model here\u0027s the name to help circulate complete that and so that later on when you want to revoke it you know it\u0027s the right one but also it helps you from knowing you\u0027re authorizing the right one okay yeah so they do I studied suggestion is just as acro mobile ID for revocation just so you can you it\u0027s not meant to be for her to use for the authorization service they can present like a yeah they can just group the grants together do you see a security issue with potentially like do you see you know if someone faked I agree that it\u0027s fake of also dude you know he\u0027s a bad effect goes like group together understand the value so that the values around users so the values are let\u0027s say the one authorization set has two apps say like YouTube Google Play Music right and so I have two devices you know living room Chrome car Roku and like bedroom Roku and then rather having like four four things displayed on for revocation we could just have to for example write could just be okay you have the living room Roku and the bedroom Erica if you revoke one of them it revoked both grants so just knowing which are different clients right which are different client IDs instead of knowing all right babies for those who have a separate device name from the user experience may or may not that could be both wolves record all of this is happening at the authorization server side there\u0027s no reason for the device to be passing this information and the authorization server could just assign a surrogate ID to each of those authorizations yep but in that example I gave you would then have four discreet authorizations two times two you wouldn\u0027t be out of group them I see okay yeah that\u0027s that\u0027s very yeah so that that\u0027s that\u0027s why this one exists or essentially remove all the things from a particular device because assuming the device will provide the same idea all the time Hey yeah sure Mia if it doesn\u0027t it\u0027s useless so yeah it\u0027s just just to conceptualize all the grants and group them so that that\u0027s the purpose of one of ID and then the other to it regarding model and name they do introduce a potential phishing risk if the authorization server is not validating those against a whitelist associated with the client ID and if you\u0027re requiring the authorization server to do that I\u0027m not sure how much value it then having the client provide this information but really it really gives you just used client ID because in this case you have one client ID but then use it on on many different devices so you wouldn\u0027t you wouldn\u0027t necessarily know or you could definitely not know the device name or the authorization so it wouldn\u0027t be able to infer the device name just from the client ID because if you have the app running on thousands of millions I\u0027m more concerned about device "
  },
  {
    "startTime": "01:00:26",
    "text": "model okay because if you\u0027re if you\u0027re displaying that to the user and telling them hey you\u0027re registering a Roku three but the client ID that\u0027s being provided is for some other device then you know you so yeah just to comment of the the last one first so you said what is the value of the client providing this information I would say one of the value is that assuming legitimately provide information is that every vacation you know if I just see some random things what\u0027s that I can\u0027t be bought racing I\u0027m gonna revoke it right if it says hey this is like your Roku don\u0027t Rover you know this is euro car make the ID I don\u0027t know revoke that so best of ov the client providing it\u0027s an optional parameter but if they provide it they\u0027re at less risk of getting revoked I\u0027m not trying to endorse right goodbye I\u0027m more concerned about a malicious party using Association requests to put up a prompt that\u0027s saying I\u0027m authorizing my Roku 3 when I\u0027m actually authorizing yes to is the fact that those parameters are essentially rentable and they are not cryptographic okay right two comments on it firstly if we add this let\u0027s make sure we do have that security consideration that\u0027s a great point a lot of the thinking I was doing around this was revocation but you\u0027re talking about consent yeah I think from a concern point of view I agree you you might wanna have a whitelist so here\u0027s one possible implementation is not not wouldn\u0027t be normative but you could have say like a known list of ten um that way you\u0027re not just rendering random attacker provider text button let\u0027s say it\u0027s like Xbox I think you know the U badge of that is when I said before is like one of the main questions we\u0027re asking trying to prevent against phishing is is this your device and is it in your possession right now being able to say it is this your Xbox now if that was from a whitelist of ten I I don\u0027t particularly see how replacing this device with Xbox would be bad I definitely see replacing this device with random hacker provided text would be bad so okay yeah I think you make a good point yeah there\u0027s security considerations text is good I go back to the kind of earlier points about implementers and clients not always reading the spec so he should weigh the value of you having that specified in the request versus derived on the authorization server side from a client ID versus the way the convenience of that versus the risk of people doing it wrong right okay maybe it is in the dock and I don\u0027t remember it but there\u0027s a number of uses of this it isn\u0027t asleep clear to everybody some people view that the device there\u0027s only one thing on the device but the model is that there could actually be a bunch of other apps "
  },
  {
    "startTime": "01:03:27",
    "text": "running on the device and so the device knows who it is but rap is trying to install and boot up you know so it\u0027s you know you\u0027re trying to enable Netflix on your Roku right which as opposed to just enabling the device right you may want to call that out because it may not be obvious to everybody okay yeah thanks at that point now it\u0027s deadly true and then sometimes people are just trying to revoke the service as opposed to across all devices and sometimes they\u0027re trying to revoke the device right and all the surfaces aren\u0027t it right so I think we doubt we have this it would always be revoking the service across all your devices without the ID okay you know there\u0027s almost funny cuz actually I guess I didn\u0027t include this in the earlier drops but we had actually go I actually documented this you know as it proposal internally like a bunch bunch of months ago so so curious Cala people John and Bradley from yubico so before Lucy gets up to throw this particular cold water I\u0027ll beat her to it that device ID is actually a correlative all identifiers and many device manufacturers go to great lengths to prevent different apps on the same device from knowing that they\u0027re on the same device so there\u0027s going to have to be some significant amount of security considerations I\u0027m minded to privacy considerations I minded to separate this from the spec that\u0027s about to go into last call this probably needs to be its own spec and consider what how this relates both to mobile devices mobile devices limited display devices and attestations etc I think this is its own fairly large ball of wax I think that trying to stick this into the device back at the last minute is going to cause the whole thing to blow up in iesg review with all sorts of just she\u0027s already got a list of discusses that would completely tie us up so I would say don\u0027t fall into that let\u0027s not fall into that hole let\u0027s get the device spec done and consider this as part of a separate add-on Brian Campbell well are you have you for John to speak for you or be interested to hear your points if you having to if you\u0027re happy to let John nurse before you then if you\u0027re going through a full security audit again I think you\u0027re at least a year out again on this document if you want that that\u0027s one way to go I think you could drive a truck through this okay I guess in defense of these three "
  },
  {
    "startTime": "01:06:30",
    "text": "parameters they\u0027re not they\u0027re not trying to be anything more than just self client asserted you know unencrypted unvalidated you know revocation hits as I think it\u0027s good that you\u0027ve brought this up I could add it underscore hit on all because I think the the context of of this document sort of makes the whole topic more under standard rather than I\u0027m talking about in the abstract that\u0027s why we hadn\u0027t had this that discussion before so it was a good good that you raised it but clearly as as you can see we can all see we need a little bit more discussion on this and then we need to make a decision on is this a separate effort or is this something in there or are we actually doing something completely different I I don\u0027t know Lucy yeah you mentioned several issues like multiple devices renaming revocation all of which are extremely complex to manage to add that at last call in the spec is that can help okay but I don\u0027t I I think we shouldn\u0027t get hung up on the last call so we thought that like coming from the last night yet meeting with that we are done but often the last call is away for people to look at it and actually raise things so last call is not always the last call so so I think this is it\u0027s as good as any other time to raise these issues so Justin yes Justin yes so a couple of things about that one actually this this loops back into Mike\u0027s question earlier of you know why are people bringing up all these things now and part of it is that this spec has sat kind of pseudo stable and dormant for years so people have actually been implementing this for a really long time in non-standard but mostly kind of compatible ways and so now that it\u0027s finally going through the standardization process people are starting to pay attention to a wait does this actually fit the use case that we\u0027ve been deploying for five years so that\u0027s where some of this stuff is shaky now we are also really seeing a bend in the curve of adoption of sort of alternate modality devices which first devices IOT devices and things like that where this stuff kind of does make sense and in addition we do have some interesting use cases like the one I posted about on the list from one of my clients where you know this this mode really does make sense but it\u0027s only very recently that this kind of stuff has been coming up so this is the right time for for all of this to get hammered out and I think that\u0027s why we\u0027re seeing that all that said everything I\u0027m hearing is that this stuff belongs in a separate spec I threw a link to just such a spec into the chat just now "
  },
  {
    "startTime": "01:09:30",
    "text": "because I don\u0027t know I thought it was a good idea back in 2010 and in in any event I agree with the sentiment that that this really should kind of live in its own space because what Annabel said is also true this applies to more than just the device flip so we\u0027re not just talking about device ID in my original spec I called an instance identification because I was thinking more in terms of like I think it was dick was saying like public clients and a bunch of other things this has applicability beyond other things and as has been brought up it\u0027s a big ball of wax so I I am with the thing with the sentiment that it is too much to try to just slip this in here at the last minute because we can do this in a standardized way across multiple flows that does address all of the security and privacy and other considerations as a separate document Justin can you post a document that you mentioned to the mailing list write it in to some child actually it\u0027s it\u0027s on the thread that\u0027s discussing this the minutes what\u0027s that perhaps a draft Richard Roth instance - zero zero thanks Jesse no your yeah uh I\u0027m inclined to agree I guess I\u0027ll be working like the native apps stuff for a while and we definitely saw the same problem there so if you\u0027d like any help you know reviving that doc I\u0027d be very willing that\u0027s Brian from ping this may be mood at this point but I\u0027ve had just one comment about the device ID that may be still useful it seemed to be a lot of concerns and about the stability verifiability and privacy concerns of the device ID when what I\u0027m hearing is there\u0027s a very specific use case for using it to group authorized apps for the same authorization server system from the same device we right I understand but maybe it could maybe this the same sort of things could be accomplished with just some sort of model or name or nickname or nickname hat giving up the group ability used but if you think about like my Roku I I\u0027m authorized with yeah with YouTube and Pandora and Netflix and so and those are different services so there\u0027s no even physical way to there\u0027s no way to group those anyway I have to go to the different things so maybe within a single service having to give up that particular grouping is is a worthwhile in terms of avoiding some of the other "
  },
  {
    "startTime": "01:12:30",
    "text": "issues he said maybe we could accomplish this with what did you say maybe maybe the group he is not just want to hear what he said maybe the grouping functionality could be dropped in favor of just a name hint you know what was the thing you were proposing basically just drop in device I got from this and and I was using different names like Kent just - yeah - maybe alleviate other fears but but really just taking the device idea in the grouping out of it might be a way to accomplish more or less the same usability functionality with one small loss and maybe getting rid of a lot of the concerns around privacy yeah just what one bit of feedback on that the only things I guess I sort of see that users mostly visualize their their equipment as devices not as like YouTube on my Roku and like play music on my Roku I think the mental model is more like hey I\u0027m like you know I don\u0027t want my Roku anymore here it is Brian you take it but I better go in and like to leave my account from it and I think I think that Mandal model does suited but yeah I agree you\u0027re saying it\u0027s a trade-off and maybe it\u0027s just not worth with a cost to say just yeah absolutely well maybe we should consider that with with the with also look a little bit of a time ago yes yes great discussion you in any way but alright I can get through the rest in 30 seconds so so just to reiterate brands comic because you all you need is a locally scoped identifier you need you don\u0027t need a globally scoped identifier the global one is the problematic one absolute absolutely and and I think the the locally second one is preferred for a privacy point I agree so it\u0027s like a publisher device right it\u0027s probably needs to be pairwise in the way that we\u0027re doing other things pairwise and may relate to some of the stuff that we\u0027re doing around logout so or token revocation etc because it really is by whoever\u0027s doing the authorization so the CID or there may be other things that are more appropriate than a device ID which is why pulling it back and looking at it yeah my broader perspective okay well I mean I\u0027m sensing a fairly consensus at least to look at that as an option in the future right all right well glad we had the discussion let me just wrap this up there are no more new changes to propose so just to go over to run encode did an update Google\u0027s a s is actually now a hundred percent spec compliant with the zero six version three we had there was like one difference since IETF 98 and I don\u0027t think we invalidate that today so let\u0027s hope not miter ID I believe 1.3 should be released now since it was that\u0027s we get released in Chicago that\u0027s another and this one\u0027s an open source implementation on the server side we have also an open source client implementation the plan is to move this "
  },
  {
    "startTime": "01:15:32",
    "text": "into the Apple project which once it\u0027s actually Saturdays and just and I did some interrupts between the two so yeah there we go and I think we\u0027ve done putting you know fairness there\u0027s a couple of other open source implementations oh right yeah I\u0027m not trying to uh not try to exclude any so I guess if yes please great yeah well and send them through the list because I\u0027m not sure if I if I have that list I would definitely quit in the slides if I did all right thanks everyone I really appreciate the discussion [Applause] all right Oh - token exchange been out there for a while in fact I think it was the last time in Prague that I came but it heads with Mike a little bit of trying to reverse the direction of this and we came to some compromises to move forward which which were done shortly thereafter and that was about two years ago so yeah here we are that\u0027s a picture from last time we\u0027re in Prague next slide please so I try to give a little bit of context even though it\u0027s been around for a long time just for people aren\u0027t totally familiar with it a reminder and this is a slide of one specific use case that\u0027s available with token exchange token exchange is an extension to OAuth that allows for basically arbitrary exchange of tokens some client doesn\u0027t matter who it is how the token needs to get a different token for some other context of use and token exchange is just a framework to facilitate that one particular use case that we hear a lot is a client in sub-zero obtains a regular old auth token through whatever flow device flow authorization code though it doesn\u0027t matter it gets won through a normal offload it has it and it sends it in step 1 the resource server through a normal you know RFC 6750 request would be the resource server received that but it needs to get a new token with similar content suitable for a back-end service that it has so it does in steps 2 \u0026 3 it does a token exchange here Sansa token up to the authorization server in exchange for it for a different token that is suitable to send to the back-end server and then passes that along just as an authorization token as well this isn\u0027t the only use case but it\u0027s one that\u0027s that\u0027s enabled by it by this protocol and is pretty common so these these two spec encompass senator kokkonen get it took them back "
  },
  {
    "startTime": "01:18:32",
    "text": "now there\u0027s some other concepts in there you can send two tokens which allow for you to express types of delegation and so forth but but it\u0027s hard it\u0027s really just exchange a token or two for another token that can be used in a different context these are these the wire examples here are actually examples from the first part of the specification if you all look in detail at at but I\u0027m just trying to give a little bit of context because the next slide doesn\u0027t have a lot of context just the status update so draft 9 of this was published earlier in July with pretty small changes which were addressing working group last call feedback and I do highlight here that these were addressing what I feel like are actionable and meaningful working group last call feedback there was one set of comments from someone that has made a lot of other comments on this and other specifications that are are not necessarily meaningful or actionable and I\u0027ve addressed them to the best extent that I can but I don\u0027t think that there\u0027s anything additional that can be done I don\u0027t think he represents any sort of consensus opinion and I further a little bit early thought that myself we we look carefully a kiss called he would like us to beat him to see because sometimes for some also for some you comers and he hasn\u0027t been acted under in the group directly so it may be it\u0027s sometimes be a language issue it\u0027s like a terminology language etc attitude it\u0027s certainly possible just for what it\u0027s worth he\u0027s been active in a number of other groups which um consistent behavior but the things that we have changed based on that changed one word from a non normative can to may just to try to clarify things that was actually a result of his feedback added a statement clarifying that the validity of the subject token or actor token the tokens you send in their validity has no bearing on the validity of the token that\u0027s been returned outside of the context of the exchange so they have to be valid when you exchange but there\u0027s no correlation implied thereafter so once you have a new token it\u0027s it\u0027s it\u0027s decoupled from the original token that\u0027s always been the intent in the case where there was some wording out last call feedback that asked to clarify that we did change one error code from a may use in a certain context around requested resources being inappropriate or unable to fulfill I had a May in there which I it should have been a should I think in retrospect I think it was just a careless wording at the time so we tightened it up a little bit clarified text it\u0027s the same normative stuff about using non identity claims within the Act claim and then being meaningless so that you shouldn\u0027t use them there and I added a little bit of privacy considerations actually I stole "
  },
  {
    "startTime": "01:21:33",
    "text": "some wording from from ws-trust to sort of be all encompassing about the privacy considerations of this use because it\u0027s very difficult to cover them all but I wanted to address some feedback that those were missing and and provide a little bit of a little bit of guidance or at least awareness of the privacy considerations involved so those are the changes that have been made they\u0027re all relatively minor as I said so yeah next steps next up series i\u0027m pending your review of the other feedback and discussions with with people i would ask that we transition this to waiting for write up and/or moving forward and this is a photograph of a busker i\u0027m not exactly sure what i meant by it but it feels a little bit like the state of this draft sort of like waiting and boredom but with some sort of impending danger of this giant snake around his neck at the same time but it was probably lated i like photos and so you can you can interpret that how you will good idea any immediate comments on this document or are you guys are you guys good you\u0027re a working group last call as we decided at the last IDF meeting the band was to wrap this up and and ship it okay all right I\u0027ve went a lot better than Williams no Williams you never know yeah only this minor changes only editorial changes all right the other the other presentation I have today has a very similar title and I get confused typing in URLs and end up with the wrong one all the time but this is off to two combining we have another photograph from Prague the last time we were here because that\u0027s what I want to do so try to set a little context here without getting too deep into it this this draft is intended to provide an OAuth to you proof of possession mechanism we talked a lot about the value of proof of possession on Monday I believe it was in terms of what what that can bring you in terms of preventing issues with lost or stolen access tokens so this is a one mechanism to provide that proof of possession and defeat you know play or replay inadvertent play by the wrong party of lost or stolen tokens and OAuth context and that that includes access tokens refresh tokens and authorization codes next please so current status here jumping out of the context into the weeds on the token binding working group documents there\u0027s three of them GLS negotiation the protocol itself the message format and how it all applies to HTTP are all very very close to being submitted to the ISP for publication as my understanding is that they\u0027re waiting for the working group chair go ahead and or the Shepherd right off if any of you know the chairs "
  },
  {
    "startTime": "01:24:34",
    "text": "of that work I can\u0027t quite recall who they are perhaps you could encourage them to continue that work I believe they\u0027re also Sri cently some NIT fixes on the drafts which are very minor but important in any way they are in a relative relatively good state and and very very close so that\u0027s good in this draft that token Bonnie draft four of that was published also early in July apparently I did it on the same day there\u0027s some very minor editorial fixes more clearly defined how to convey the token binding information of an access token in an oauth2 token introspection response this itself was is very similar to the work that was done in the NLCS bit around around token introspection all catalyze from a comment that Justin made at the last last IETF meeting which was that there was a lot of assumptions being made about how this would work with introspection that were not clearly stated in the document so this just just calls them out very explicitly and as a part of all this there is now an introspection request introspection response parameter request registration to ion are being made in the OAuth M TLS specification which sort of broadly encompasses all of this and is applicable here because we\u0027re using the confirmation method as well my expectation is that that document will progress more quickly than this document so I put the registration request there and then removed an open issue related to that and again just clarified exactly how that would work um and I also added a long rambling open issue about the need to allow for a web server based client to opt out of having refresh tokens bound while still allowing for access tokens themselves to be bound I\u0027ll talk a little bit about that on the next slide so getting into open issues in the document I\u0027m defined the conventional wisdom here about having a lot of text on a slide mostly because I wasn\u0027t sure how to narrow all this stuff down to a slide and it\u0027s meant more for me too as a reminder of what to talk about you get a picture excellent so one of the open questions has been there from the beginning is what should we do in the case that a refresh request for a token bound access token is received but the Refresh token itself was not token bound that\u0027s a it\u0027s a fair question it leads into the next question if I won\u0027t read the whole thing but it\u0027s about web server clients so tow combining at its core is developed for use cases where there are many many many different clients web browsers native applications on phones and it\u0027s a nice way to sort of "
  },
  {
    "startTime": "01:27:34",
    "text": "dynamically create additional trust and bind tokens from those individual devices when it\u0027s brought into the OAuth fold there are different kinds of clients and one of those clients is is potentially a web server uh you know Facebook from its web servers acting as a client calling services at Amazon and token binding of a refresh token in that context is a significant issue because those web server clients are likely distributed across many different nodes very likely geographically distributed across different data centers maybe even different cloud providers hosting them and shared access to a private key is oftentimes cumbersome impossible in such environments and this is all before we get to the question of what token binding client-side API is are going to look like and my expectation is that what is already a very cumbersome sometimes impossible problem will not be made any easier by the api\u0027s that are provided around token binding because they\u0027re really meant to be they\u0027re not ephemeral keys but they\u0027re they\u0027re sort of on demand generated client-side keys that adapting those api is to be able to also securely store private keys and share them with the entire set of your clustered applications is it it\u0027s not gonna happen I think there will be a small subset of implementations that could figure out how to do it they will be in the vast minority and I think if we don\u0027t address this problem it will severely hinder the adoption of token binding in this context and the real value of tow combining in this context is to bind the access hook it\u0027s to prevent them from being misused or replayed in other contexts where when we have the Refresh token is already bound to the client credentials established with the web server client oftentimes yes that is a client secret but those are long long client secret strings and we also have stronger forms of client authentication that a comp that can accomplish similar similar benefits like mutual TLS so I\u0027m I\u0027m strongly advocating the need for some kind of solution here I see two possible approaches and one is to toggle the behavior based on some kind of client metadata so metadata client registration metadata isn\u0027t required but it\u0027s often used and even when it\u0027s not used it strongly suggests a model for client registration data even with with providers that do static registration and we could put some stronger text around that but a way for individual clients at registration those that have client credentials established private clients to say please do not bind refresh tokens for me even though I would like access tokens bound and then the the way that access tokens are bound are by presenting the token binding information at runtime which includes "
  },
  {
    "startTime": "01:30:35",
    "text": "the provider and referral combining I think that\u0027s probably the the most straightforward solution it\u0027s easily implementable easily understood the metadata parameters already largely exists so I think it would be just some some wording around their usage and some normative language about Bom right now they\u0027re just sort of suggested of and indicated and they could be enhanced a little bit to say in these in this case we\u0027re you know this indication is false the authorization server should not took combined refresh tokens getting back to the rebinding the refresh tokens to just sort of further complicate the one of the main problems is the only way to request token by an access token is through the presentation of the sec token binding header after negotiating token binding and including a referred token binding in that and the only in in order to do that by definition aspect you also have to provide a provided token binding so there\u0027s no way to make that request without providing the data that\u0027s right now in the standard said to be used for both for binding both refresh and access tokens and yeah I\u0027m sorry that was a bit of a diversion but sort of missing that before the other potential solution here right yes um mcjones Microsoft I just like to say that I think that the metadata approach is very reasonable and I really don\u0027t want to think about what are the security and threat implications of providing a rundown way to disable the security feature I think that\u0027s a fair and reasonable criticism of the option that I had not yet presented so I guess I did sort of allude to it but way to look into the future we did discuss this a little bit yesterday to try to clarify our own thinking about it the other option would be allow would be to allow for some sort of parameter on the token endpoint request for the client to express the token binding ID that it would like the access tokens to be bound to it could do that without negotiating token binding without providing the provider token binding which would then mean that the the authorization server would have no way to bind the Refresh token but it would have data sufficient to find the access tokens I was I was kind of liking this approach for a while I think there may be other simplifications of client-side API is that it allows for I actually think the security implications are okay in this context but having said all that I think that the metadata solution is is more straightforward easier to implement and solves addresses the immediate problem and doesn\u0027t open up any potential security issues that I I\u0027m not aware of even though I think it\u0027s okay and continues to use consistent behavior around around how to\u0027 combining is conveyed and verified and so forth at the at the token binding for HTTP layer "
  },
  {
    "startTime": "01:33:36",
    "text": "so at this stage I\u0027m inclined to suggest request that the the next revision of the document include addressing actually both of these issues based on client metadata because the client metadata can also take care of the understanding or at least clarifying what to do in cases where access to and refreshed okay don\u0027t have the same binding information John Bradley yubico I vote for option 1 I think option 2 has a couple of decomposable points I don\u0027t a runtime switching is going to cause problems there may be other reasons to have token binding negotiated on that TLS connection I think there is a separate issue lurking in there whether or not we need a separate parameter for for being able to express the referred token binding separate from the referred token binding in the token binding header but I think that\u0027s kind of a separate issue so I think dealing with an in metadata saying it\u0027s okay with sufficiently strong client authentication because in principle you want to authenticate the client if it\u0027s a server we could direct people to use a sign jot or or other stronger mechanism so they\u0027re not passive using HTTP basic and passing them the that on the on the line so I think we can give good advice about using mutual TLS sign jots etc in combination with token binding for the for the access tokens I think we still need to have a just a discussion point on whether or not in these clustered environments it\u0027s actually reasonable that the token binding API that\u0027s provided can get the refer token binding from another node or can we should we be saying yes the node that it\u0027s going to use the access token has to be the node that\u0027s used getting a refresh token so there\u0027s more discussion that needs to happen on that particular I agree with it but it is separable from here so I think leaning towards metadata William yes I don\u0027t know if he explicitly called this out so I just wanted to ask is this only for confidential clients I don\u0027t think I explicitly called it out but yes okay so okay thanks for the clarification great yeah cuz I guess like a native app for example doesn\u0027t have that its own only is it not a convention but it\u0027s also shouldn\u0027t be distributed so that\u0027s right it\u0027s probably falls in the category of hey you really should token buying the Refresh tokens yes and secondly I guess like I do we want Iran to be using two combining for OAuth eventually so ideally yeah I guess the "
  },
  {
    "startTime": "01:36:36",
    "text": "only risk I would see is like you know if we all have too many people to opt-out of too many things and then I just like it\u0027s too hot I don\u0027t implement it so I don\u0027t know if you have any thoughts on how to encourage you know people are still buying their access tokens even if they click the opt-out box for for the Refresh token um I hadn\u0027t thought about it so much in in that context more the other side of it that I felt like not providing this opt-out would de facto mean that people won\u0027t be able to enter a minute so but I think some there may be some guidance or wording around this that that helps address or alleviate those rights issues like for example could you see a world where refreshed recombining like potentially where refresh token binding is optional but access to combining could be compulsory like for a particular ization Center and I\u0027m saying like in five years but like yeah is that a post like um from from DS design yeah I think so John Bradley again so we do have the mutual TLS option and in some cases mutual TLS for access tokens might better fit somebody\u0027s deployment use case I wouldn\u0027t say maybe mandatory proof of possession access tokens there may be more than one mechanism for doing that he did say in in the context of a particular authorization server might very well well but even in particular authorization server might might but you could yeah so we don\u0027t want to be overly prescriptive but I mean the concern I think at the moment is the only way for somebody to turn off being broken because they have a cluster and by default the Refresh tokens are being token bound would be to disable token binding on their calls to the to the token endpoint which mean that they can\u0027t do access tokens talk them down to access tokens so this at least allows somebody to have that to be able to do talk about access tokens without without token binding the Refresh token correct so this is a first step not necessarily agree William Dennis just to clarify I wasn\u0027t saying that we should be prescriptive in that sense but just that a particular authorization server itself could say for us access token token money is mandatory still even with this sort of real like say even if they implement these minute of it yeah I think so all right great next one it\u0027s a little better um a couple more openness open issues one is a question of whether the scope of this document should include some kind of standardization or at least guidance on using token binding with client authentication and or authorization from yeah the 75 23 which is the client authentication and authorization draft "
  },
  {
    "startTime": "01:39:36",
    "text": "in in some ways I feel like this is easily inferred from the existence of the confirmation claim how it\u0027s used and would be using this you know in this context in other ways it might be useful to just say something about it here because I think it is particularly for client authentication it\u0027s maybe a really nice useful security enhancement mechanism but right now it\u0027s not in there and it would it\u0027s sort of left up to the imagination or an exercise to the reader John yes we should write it down because it\u0027s only self-evident to us using the confirmation claim in a self-signed jot for client authentication if formal economist to space yes it is actually just self-evident to us you\u0027re right the the scope of people to whom it\u0027s self-evident is probably relatively small um as a co-author in the document what specifically you want to like give us a short summary of what you would like to like that since John\u0027s in favor I\u0027d love for him to write it down but since I know that won\u0027t happen it would be a it would be hey it\u0027s probably a small subsection of the document that describes how one would use the confirmation claim with the tbh token binding hash confirmation method inside of it in the context of the JA client authentication not again not real controversial yeah looking forward to see it there okay yeah and then this was this is all sort of related but the metadata needs some work the main problem I think is that there\u0027s a reference to the OAuth to protected resource metadata which is not a ongoing draft so we\u0027ve got a kind of a hanging dead reference I think it needs to be removed and some some clarity about what canon cannot actually be inferred at runtime from the metadata values and what can be enforced should be added there this has been sort of an ongoing reminder to myself that it exists as well as a hope that mike the look the original text would go back and fix it although we we chat a little bit about this yesterday and in the context of a similar problem with the open ID connect layer so combining spec that has similar issues and I believe I believe I have some ideas basically about a roadmap about how to how to keep the same intent remove the hanging reference and clarify the text in a meaningful way so I think we\u0027re good on that and certainly anything that\u0027s written will be another draft and available for review I so it\u0027s on my list to do like I said these were just listing the openness what if what do you so be a little bit more precise what do you want to do there like you want to remove that reference and that reference "
  },
  {
    "startTime": "01:42:36",
    "text": "in that particular metadata field are gonna go away and there will be the text around what\u0027s currently there of detecting attacks what to do in cases where bound tokens are expected but not received we\u0027ll be just reworded to clarify what what what is and isn\u0027t possible and perhaps provide some guidance on what to do alright next slide please so just looking ahead hopefully the the core underlying token binding documents progressed RFC here pretty soon I know Andre is looking forward to that not even though he\u0027s not listening right now work through these open issues I think I\u0027ve a way forward for a lot of them so that\u0027s good we definitely need implementation experience and feedback here there\u0027s there\u0027s growing implementation experience in tow combining in general but most of the client-side implementation is currently in the browser so we haven\u0027t seen like client-side widely available libraries yet server sides also questionable but coming along so this is still early I think there\u0027s a lot of room to learn and work from there but it\u0027s progress and then get the band back together again I 100 and in Singapore and here\u0027s a John Belushi impersonator just uh just to help you get the band back together or get in the mood for it that\u0027s all I\u0027ve got dick Hart Amazon in the current token binding it it are both access tokens we\u0027re not really dealing with a TLS proxy around how do we push that proof of possession all the way through to the application and preserving that integrity is that viewed out of scope for this document or is that in scope I would view that as out of scope for this document because it prescribes how it\u0027s done with OAuth um there is a document that was just accepted as a working group item in the token binding working group that describes how to convey the information from the TLS terminating layer as a reverse proxy convey the token binding information that was verified to any applications in the backend which would allow them to to do what\u0027s implied by the the auth layer which is trust in the TLS layer around what doing yes right yep so that doesn\u0027t provide the same security characteristics of other proof of possession mechanisms that go from client directly to the application that\u0027s correct so is there not interested in doing I mean I consider it an OAuth problem it\u0027s a proof of possession type token we\u0027re trying to go and add proof of possession in 200 auth to flow of witches you know protocol works at the application layer as to how do we get that signal "
  },
  {
    "startTime": "01:45:36",
    "text": "uncompromised and securely all the way to the application layer so you\u0027re saying that you don\u0027t consider that being scope for OAuth the token bindings really how do I move this it\u0027s bound for all of us but it\u0027s not as cool for this document okay okay yeah I mean the it\u0027s in scope it\u0027s on scope for this document and that the technical solutions right now I\u0027ll rely on some kind of established trust between the TLS terminator and the application and that\u0027s that\u0027s the work that\u0027s going on but you could argue from that for example the document that justin has been working on with HTTP signing is such an application layer pop approach but it\u0027s the right one or not is a separate story but you that\u0027s true so this is a this is a TLS layer binding approach and yeah with with with everything that comes in with that if that makes sense to you yeah I think you know Microsoft had something internally that they were using around how today move that continued the signal all the way through to the application mm-hmm did you do you want to speak up we do but I don\u0027t know the mechanism well enough to speak about it at this time okay um and just from a technical perspective I it\u0027s I don\u0027t know of a way to do it that is tightly bound because it\u0027s it\u0027s bound to the TLS connection between the client and that TLS termination so everything how it happens behind that is simply moving signals but not not something tighter than that and if there\u0027s a practical but wait the verifications happening at the application layer that\u0027s correct and so if the GLS proxy doesn\u0027t know the currently the tokens opaque I mean not okay if it\u0027s visible and so I think the Microsoft solution was they\u0027re encrypting the token so then the proxy wasn\u0027t able to go and see what was the ekm in the token very well I don\u0027t know I mean we\u0027re not go Appa blah there are okay so nobody nobody\u0027s won you guys considered out of scope for this back and to nobody has a clear idea about how to solve it yep I would say that\u0027s true but to be fair I\u0027m not sure you clearly articulated the problem so yes I mean you\u0027re talking look the problem is is that the TLS Terminator is in a different trust domain than the application okay that\u0027s about it that we trust we trust the thing to terminate TLS but we don\u0027t necessarily trust it for managing the tokens okay then that I I don\u0027t that\u0027s certainly not in scope for this document I don\u0027t think there\u0027s "
  },
  {
    "startTime": "01:48:37",
    "text": "a viable technical solution using token binding I could be wrong but so for anybody running in AWS right they\u0027re having to trust the terminator if they\u0027re sitting behind it yeah which they do now on lots of our deployments don\u0027t but they give it their private key what\u0027s that but they provide it with their private key right well they trust them they trust the TLS terminated to manage TLS but they don\u0027t trust the Terminator to manage the token or manage the authentication authorization so so in AWS you know API calls that don\u0027t see before which gives you an - and proof of possession okay which you know transit fine through a TLS proxy and so ideally we would like to use something was more standard but it doesn\u0027t have that the token binding and access token look what you\u0027re proposing doesn\u0027t solve our problem and give us similar security characteristics around what we already have a ciggy for okay I\u0027m not familiar with that I would encourage you to look at what\u0027s being done in the token mining group yeah on the other side of it I\u0027m hopeful that systems like Amazon\u0027s application-layer load-balancing will deploy what\u0027s being proposed and tow combining right now so you can enable your customers applications to do tow combining both of cookies and OAuth access tokens and other things like that okay I think we\u0027re talking about different problems now or at least in a different context so there John Bradley yubico so I did attempt to extract the information from the devil the other day about what Microsoft is doing for office 365 native apps and there is some notion that there is an additional token binding ID which is added to the token binding header which he\u0027s generated by the native app that is signing over some piece of material which is the goat she aided from the thing behind the proxy to the app itself and I asked the devil to have his minions provide us with said information but it is potentially a chip it\u0027s not something that would work front with a with browsers as deployed it may be something that\u0027s secretly in Microsoft\u0027s library I don\u0027t know since he\u0027s looking he\u0027s looking at "
  },
  {
    "startTime": "01:51:38",
    "text": "you\u0027re looking at me like like I\u0027m crazy which is probably because the devil is full of lies so so there there is potentially something there we don\u0027t I don\u0027t understand it enough to be able to write it down or adequately explain it so perhaps if more information can be provided to this working group in the token binding working group we can understand why Mike wants additional token binding IDs passed through and all of the other sort of intertwined issues sure sounds like an OAuth eager to meet back down but hey so some kind of signing or application layer piece would would provide it it\u0027s not token binding and just to reiterate like we can\u0027t write standards based on unknown individual deployments we have to build them on other standards so that that\u0027s the context with I\u0027m working in here so under a pop of Microsoft trying to speak of the devil or and a half so I\u0027m not not entirely familiar with what was just sad right so like I know what the implementation of token binding looks like in Windows is I worked in bad it\u0027s just an implementation of the standard where we build messages where we\u0027re allowed the caller to specify what type of binding they want to do so basically that\u0027s what we have you know on top of that how a specific system uses that I don\u0027t really know you know it\u0027s can\u0027t comment on that I would be surprised if there was a solution that provided the end-to-end token binding validation of the type that was just discussed because that doesn\u0027t make a lot of sense to me if you are if you\u0027re terminating TLS at the TLS terminator that\u0027s where end-to-end ends you see what I mean the terminator if you don\u0027t trust your TLS terminator you know it can inject requests you can you know do all sorts of bad things you know you can you can have an architecture where the backend server actually verifies it or combining by having the TLS Terminator pass the ETM and the you know token binding message to the backend but it\u0027s still not really you know and to enter the application because again you\u0027re still trusting that your TLS Terminator is passing the correct information to you so I\u0027m not aware of what that\u0027s actually we discussed this in the context of the proof possession work in ours and we had this write that which we need to update at the architecture document that talks about these different ends and in these different nuances and which is why we had for example this HTTP signing solution specifically to deal exactly with the fact that things terminate in different places and so you have different ends in that in that communication yes you all know we ran into some issues with the HTTP signing but and people have entertained other ideas and maybe maybe there\u0027s there different layers on what some of the deployments want to provide in terms of security guarantees but I "
  },
  {
    "startTime": "01:54:39",
    "text": "think it\u0027s definitely in scope of our work we just have to come up with ideas on how to best solve it and that had had been a problem in the past we didn\u0027t make sort of rock-solid decisions and then move that forward but there are documents out there that at least say something but I\u0027m not gonna I thought I had something intelligent to contribute but I don\u0027t think but it\u0027s Friday okay sorry this is Dirk from Google I guess dick I then it sounds like you already have a proof of possession thing going with your particular authentication protocol that you\u0027re using so you\u0027re good right what what\u0027s the question jacquard Amazon we have a what I would consider a proprietary mechanism that we call sig v4 which is how API calls a need of us are made and so that works but it\u0027s non-standard so we would prefer I would prefer moving to a more standard model that worked across the internet as opposed to us having a model that works really well for us but it wasn\u0027t working would you elaborate a little bit on how your solution looks like because I\u0027m not familiar with it so Sigma there\u0027s a secret you sign a request and then that you you sign the request you sign everything and then that\u0027s verified at the application layer so are you essentially saying is is it an HTTP based signing mechanism or is it like a JSON based protecting some sort of constructing and a request token if you will it\u0027s more HTTP base I\u0027m essentially signing the whole request okay yeah so it\u0027s just that which is enough proof of possession mechanism sure right does that relate somehow to what Justin had written up I don\u0027t know okay but it prevents compromised TLS proxy from changing your request so I looked at the when I was writing the initial HTTP signing thing I did look at the AWS solution and a few others there\u0027s a I believe it\u0027s cabbage or carriage I forget his last name there\u0027s another specification out there and one of the issues with a lot of those is that they presume that the HTTP "
  },
  {
    "startTime": "01:57:40",
    "text": "message itself doesn\u0027t get transformed and that was a problem that I personally ran into a lot of with OAuth 1 implementations with parameters getting reordered and added and stuff like that so that\u0027s why my my version differs that\u0027s that\u0027s really the main difference between the one that I had proposed and these other ones which say effectively you know take the HTTP message you know as as presented and do your signature on that on both ends and my understanding with the AWS side is that there\u0027s there\u0027s just a lot tighter control over you know where you get access to at the application layer the HTTP bits and so yeah I\u0027m definitely I was aware of that it is related in the sense that they are solving a lot of the same problems in similar ways but there are some different considerations in play but I hear that we sort of have an action item for Dicky to look at the current actually HTTP signing working group document which I believe it\u0027s expired that\u0027s why you you couldn\u0027t find it under on the page data tracker page so I think that would be a useful step and figure out whether that\u0027s actually solves the issue that you\u0027re having how does that sound right and if people wanted to have a you know a mode of that one that just signs the pristine HTTP request that should be easily doable - so yeah so the build iron token vine what was that Nia so Nick said that it doesn\u0027t lay on top of Bill combining oh yeah a player there they\u0027re orthogonal you could apply you could have a token bound to the procession access token where you\u0027re signing the HTTP requests at the a player and you\u0027re also doing token you\u0027re binding the token to the TLS Channel you could do both well that\u0027s the feature that I like about finding is it you\u0027re not having to do client management of a key right so that\u0027s that\u0027s one of the downsides of sig before is that you\u0027re having to go and manage a secret over with the client token binding enables you to get many of the characteristics of proof of possession without actually having to do key management and the client about how do you get the key to a "
  },
  {
    "startTime": "02:00:41",
    "text": "client so I like the kit that characteristic a token binding but then wanted all the security features we still had and proof of possession all the way through to the application okay um I wonder like what would be a reasonable next step on that issue is not it\u0027s not totally obvious to me but uh maybe you can still have a look at the document and see but you you\u0027d be big because you want you want to you want o confining you don\u0027t want to have it at the epic public up to the application you don\u0027t want to you want to have a standardized you don\u0027t want to have to manage keys in the client so you still have to manage keys in the client you don\u0027t have to distribute keys to the client it\u0027s just a little which I understand is the hardest it\u0027s hardware to service a hard part it sounds like you\u0027re asking for a HTTP level signature with the toe combining key know did come P yeah maybe that sounds conceptually like what you\u0027re looking for which is I don\u0027t know whether it\u0027s possible but I mean we we were we like the idea of token binding right but and we like the idea around not having to do management around distribution of keys we have a mechanism that works now that gives us a lot of very powerful characteristics that enabled our customers not to be worried when there was compromises on the TLS staff so we\u0027re reluctant to not continue to have that and you know so I\u0027m just phrasing that you know we\u0027re interested in solution like that I don\u0027t necessarily know exactly how if you saw up so I was trying to figure out where there is in scope for this particular document because this has many of the right characteristics it just doesn\u0027t deal with TLS proxies which is most of all our our deployments are have a TLS proxy so yeah so the answer is it\u0027s not currently in scope okay there\u0027s workaround TLS proxies that is in scope but does not address the OAuth does not address your specific concern which is not unique to OAuth which is fine but but I think the the issue needs to be around Tomas because we are talking about doing the application layer yeah I know an API access mechanism and no authors primarily but the issue described is also applicable to to normal use cases to talk them about cookies that if you trust in the TLS Terminator in that context is exactly the same thing but I think right in a cookie world there\u0027s no other mechanism right that the TLS is passing the cookie and that is your existing prescient model wherein an API "
  },
  {
    "startTime": "02:03:43",
    "text": "access what\u0027s that yeah right but token bindings giving tools to address that in a standardized mechanism and those are being worked on so for cookies sure and for no but you know just the same issues exists with cookies like there\u0027s not a magic I\u0027m saying in cookies there\u0027s there\u0027s there\u0027s no binding of the whole request and the cookie from the browser all the way down right so you\u0027ve had you\u0027re not losing anything and moving to token binding that\u0027s also true in Oh F so you\u0027re referencing your proprietary solution and and wondering why the standard doesn\u0027t address and saying that we\u0027re losing wondering why I\u0027m saying you would like to be able to move up to that level of security characteristics about we have okay I hear the requests I don\u0027t think it\u0027s applicable here but but we need to we can still discuss it and I think I think it sounds like something having said that you may have noticed that I disconnected my laptop meaning that we I believe we actually done over time already so thanks for showing up Mike took meeting minutes so we\u0027ll distribute them and yeah thank you all for showing up and and contributing to the work "
  }
]