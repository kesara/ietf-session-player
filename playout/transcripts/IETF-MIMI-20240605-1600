[
  {
    "startTime": "00:00:49",
    "text": "hello everyone can you hear me today okay great um welcome to the June 5 me interim see people are trickling in here so first St um let's remember the note well which addresses the policies under which we uh conduct this meeting please familiarize yourself with it I think we have a notetaker who is Tim today so thank you Tim for agreeing to take notes and for our agenda today we're going to be talking about metadata privacy um picking up some of the conversations we've been having on the mailing list about this and following up from our prior interim on this topic Brendan is going to walk us through some examples live using uh whiteboard hopefully if that works um so no slides today does anybody want to bash the agenda okay hearing none I think we can"
  },
  {
    "startTime": "00:02:01",
    "text": "oh Rowan I just wanted to make an announcement that uh probably before the end of uh by the end of today maybe tomorrow there will be a new version of the content document that has the seore um the the cabore binary format like fully in there as the only format just an folks thank you um yeah we'll look for that update on the list okay Brendan you are up uh so hi uh I saw this morning that Rowan sent an email to the list um saying that discussing the the invalid commit problem requires in-depth details of MLS and that this should happen in mls in that mean um I just wanted to ask you to expand on that on in terms of like what work you want to send to the MLS working group I mean I think that both BR and Richard said this pretty well but like if you've got if if somebody could come up with if this if the problem that we have in Mimi is a problem that somebody could have outside of Mimi with MLS then we should discuss it in MLS um if the thing that we're talking about as Richard said is talking about an invalid commit because of something that Mimi did that wouldn't be a problem wouldn't make the commit invalid outside of Mimi then we then we should discuss it a Mimi so my problem with that was um I believe with Richard's email he said um let me see invalid"
  },
  {
    "startTime": "00:04:01",
    "text": "means discussions of the ways in which commits scope bad and the possibilities for detecting that Badness get very MLS Technical and these problems are MLS general not Mimi specific um so I mean so you you focused fused a lot of effort on invalid commits there's there's plenty of stuff that we can talk about about what the Privacy what the you know privacy properties are of you know the for example like Richard's email with four different you know here are four different things four different sort of privacy levels that we we might choose um there are implications that are visible to users that have to do with whether you can be offline or whether clients can be offline or not and read messages at different times there all sorts of sort of user visible things that I think are relevant to Mimi that we can discuss about you know what what what are the requirements for the thing that we're building and what are the privacy and what you know the Privacy requirements are for for the system um so you know if you start with that I think we're gonna have a good productive discussion okay well sure let's start with that um so in that thread uh I believe a lot of the feedback that we got was Richard listed four different models a was I believe closer to what we currently do which is the Hub and the followers can see group info and membership B was that the Hub can see group info and membership but followers only see local membership so the Hub can see everything but followers only see things that are local to their um their own members uh see was that the Hub can see"
  },
  {
    "startTime": "00:06:01",
    "text": "group info and suit Anonymous membership whereas followers only see local membership so followers only see things that are related to um their own members but the Hub can kind of see everybody but it sees everybody behind a pseudonym and then Model D was that each provider can only see local membership which is closer to um what I've been sharing with the group and a lot of the feedback that we got on that was um I like d but I don't think that is possible um and nobody ever really expanded on why they don't think it's possible so that's um where the idea came from today to basically talk to concerns people have and try to like whiteboard examples so are there any specific examples of things where people don't um know how to do a specific thing in the context of The Proposal that I made yeah um so I'm surprised other people aren't aren't chiming in here but we we have we have requirements for client for multiple clients for offline users where somebody can add a new client and begin sending to in begin sending in the room immediately um that's one um another one the sort of General one is that we have a number of uh a number of the providers who say that their customers are asking them for the ability to enforce some level of um some level of uh of policy uh enforcement which they can't which they can't do unless at least the Hub has"
  },
  {
    "startTime": "00:08:00",
    "text": "knows the roster I'll stop there and maybe somebody else has something interesting to say so the first one you said was that when all the members of a group are offline someone can still join that group and start sending yeah yeah most most important in like one-on-one groups or you know in very small groups so it's not C me that whether it's doable or not but it's not but it's not also not clear to me how you propos to do it when um invalid commits are generated um let's say for the moment policy invel commits are generated now you have some some some uh um uh nodes having one one set of groups and one set other set of groups how do you plan to manage that oh so specifically the problem of how do you handle the case when someone sends a fragmented up when it's forked yes I I say I'm not saying this is UNH handable I'm just saying I don't I don't do not understand how you anal um okay so to work through this for the first example of external joins so um um this is kind of the diagram that I drew before of well basically whenever you start a group you start out with a single basically Epoch a single box where all those messages go inside of this one box all of the messages are linearly ordered um and when you write messages to the epoch you write an application message you write an application message each of these dashes in the line is going to be an application message and then when you are done with the group you send to commit um and that commit immediately"
  },
  {
    "startTime": "00:10:03",
    "text": "creates a new Epoch um so and then that Epoch is sort of correlated implicitly with that commit because it was created right after um right after that commit was sent and then you can start sending application messages to this one and all of these boxes are basically stored separately on the server they all have identifiers so maybe this was box a and maybe this was box B and this identifier is derived from the MLS key schedule in an unpredictable way where you would only ever be able to know B if you successfully process this commit right here um so the way that you do external joins in the context of this is that you will have a group and this group has a series of commits um and whenever people send their commit um one of the things that they send with their commit is the group info that is associated with box B so so a commit in this context here is actually an MLs commit plus a group info for the subsequent Epoch um and so whenever the DS is basically hosting this group um it can see that this commit got sent right here um that it knows that it sees that the commit got sent it sees that everybody processed it it sees that everybody moved to box B and so the conclusion for the DS is that box B is the most recent Epoch for this group um and so whenever"
  },
  {
    "startTime": "00:12:00",
    "text": "someone wants to externally join the group use red and we're going to kind of draw over here like a little protocol diagram of like DS and then user so the DS sends this group info for Epoch B to the user and then the user sends back an external commit that corresponds to the creep info um and we're going to denote the external commit with a little red diamond um so then the DS takes this little red diamond and it um pops it right into here it never tells the user specifically about Epoch B I think that from the group info you can't compute anything about group or about ug B you can just create your external commit and that external commit can be added toou gry um and then what happens is that if the users see this diamond and they like it and they accept it then everybody will process it and move on to the next EP which is EP C so how does the Hub have the group info and and not have metadata about the group so if you support external join then protecting metadata of the group is kind of pointless because anybody can just like join the group and then they immediately knows who's in the group so like supporting external join is not compatible with um having private group membership if that makes sense I don't think that I don't think that"
  },
  {
    "startTime": "00:14:01",
    "text": "that does make sense but I think that you you've not stated that quite quite correctly but I'll let Conrad go first okay um can you hear me m works okay thanks um yeah so the first question starting with the the group info um how does the so does the group info in this scenario include the registry uh yes the group info includes the ratchet tree so this is kind of is one of the when where I see advantages of not having encrypted hand check messages because the DS can actually track the group state in small groups this is not much of a problem probably but in bigger groups and or if you use a PQ Cipher Suite that has big public Keys the overhead here is going to be substantial if you upload a the whole registry every time you do a commit right this does this goes back to what I was saying before about um well I mean I guess that external joins no it does okay external joins always mean that the group membership is public because anybody is able to just immediately join this group and then when you're joined to the group you're able to see the ratchet tree and all the members of the group so it's not possible to support external joins and also have private group membership so um the issue that you're talking about with it being slow to upload upload the whole ratchet tree that is more so an issue for sending welcomes um and you're right that it can be an issue for sending welcomes but um addressing that can can kind of be handled separately from external joints yeah so I'd be interested how we would handle that separately because I don't see it ever be as efficient if as if we just track the the group and then on the notion of uploading a group info meaning that the metadata is necessarily going to be public because anyone can join I don't think that's quite true either for example if you have a user um"
  },
  {
    "startTime": "00:16:02",
    "text": "that has multiple clients and you just want to have another client of the same user join then that user could join on the Mimi off like authenticate itself on the Mimi off level and then uh want to join the group anyway and there's no metadata privacy leag because the user because not not any you know any client of any user can join the group but only clients of users that are already participating in the group could join so I think there are there are definitely you know cases where the the two you know having metadata privacy and having a group info uploaded to the server are not mutually exclusive that's definitely super interesting use case if you can do external joins just for other clients of people that are already in the group then yeah it wouldn't have to be public so and and I mean that's just one way of doing some authentication that means uh not everyone can join the group could be you know um I don't know we could have stuff on the Mimi level using the invite links for example that ran talked about in earlier M meetings but yeah I think I'll just leave the queue for now and let Rohan continue hey uh okay so um in so I I I I'm trying to figure out what privacy problem we're solving if we're if we're adopting this this third use here that if if we have if we have pseudonyms for that that are you know per group pseudonyms for every user and the um and the the you know commits are sent to the our the The Hub gets to see every every commit and every proposal um but the followers do"
  },
  {
    "startTime": "00:18:02",
    "text": "not um what the Hub knows basically is how many at any given epic how many uh member how many mls members how many devices from from each uh are present from each provider and of of course any of their you know any of their local providers if if the if their interface allows that and so there's you know that this your your model here was based on this this idea that um that you would have the Hub would know even less but then when I asked about these external commits then in this case the the answer seemed to be well you can't get this property that I you know that I came up with this architecture for unless uh unless you again give the Hub the ability to see the entire roster did I understand that correctly so supporting external commits is um I mean supporting external commits for people who were not already in the group is I think a different problem or it's something that I think is maybe separable from the rest of me from the rest of me like you can have groups that support external commits from people who are not in the group um and when you do that in that case the group membership is already public because you're supporting these external joins from outside people so it makes sense just to have unencrypted handshake messages um but the thing about my proposal is that it does not or the thing about my proposal is not that uh it's super privacy forward in"
  },
  {
    "startTime": "00:20:02",
    "text": "that um everything always has to be completely 100% encrypted and private and like secret from the TS um all that my proposal does is it allows you to turn handshake encryption on or off like it's a choice do you want handshake encryption on or off um do you want some MLS extension that gives you you know additional functionality with the handshake encryption on or off so that's the thing yeah um so I'm just gonna I'm just going to say that what I specifically propose on the list if we want if the the Privacy characteristics that we want are are the that third you know c um you can you can still do uh a private handshake message you could include the hash of the uh framed message inside of the uh aad and then you could send the you could send another copy of the the framed message that contains the commit directly encrypted directly for the Hub then the Hub would have the commit um and It Could reconstruct the group info um it would have the roster the followers wouldn't have that information um and you know the that would be relatively minor change to what's in the current document but this requires the use of pseudonyms [Music] yeah I believe the problem with pseudonyms was that it had a lot of restrictions on when people can actually join groups and like who can actually add people to groups um I didn't hear anybody voice any concrete use cases that that I thought were uh"
  },
  {
    "startTime": "00:22:00",
    "text": "because you have this this encryption key for being able to decrypt the ratchet tree so the consequence of that is that if you ever externally join a group like we're talking about doing here if you externally join a group when you join you're not able to decrypt the ratchetry initially you're not able to decrypt the pseudonyms immediately I mean um so you don't know who's in the group uh okay so you're saying that the verification of who else is in the group that you wouldn't be able to tell the real identity of those people in until after until it was too late effectively did I yeah essentially when you join a group you don't know the members of the group until um someone of that group comes online and can tell you the decryption key for the pseudonyms which seems like a weird case okay enough okay I will let so um I want to understand if the idea here is that all of this gets applied on a group by-group basis because it's pretty clear I think from the past discussion in the working group that having a mode where you can do external joins is um is expected right um so are is the expectation that the creator of the group would choose whether this is a super private and secure group and therefore um uh it will have all of these you know it will be designed in this way the way that you just described and then there's another option which is not private Visa The Hub or the other um uh the other providers and also how does that work given that the Hub will then sometimes know the identity of users and sometimes"
  },
  {
    "startTime": "00:24:01",
    "text": "not and it's the same users who are in different groups uh so you're exactly right that this would be a group by-group thing where it depends on the group whether the group is um whether the group has private membership from The Hop or not is basically um a decision of the group Creator or it's something that's negotiated by all the members of the group I think in the gist that I shared I said that there would be like a little key package extension that um you know maybe would support negotiation in some way so everybody would have the extension that says you know do I require um public membership or not for some reason um and then if no one requires public membership then you just encrypt the handshake messages um so yeah it's a group by group basis it's a decision of someone whether the handshake messages are ined or not and then the second question about what was the second question um I just wonder if the same Hub having um the same users in groups with private membership and groups with non-private membership creates a way to De anonymize the users even when they're in the group with private membership no um that shouldn't be possible I mean if you're in a group with public membership then the DS knows which groups you're in and if you're in a group with private membership and it doesn't so it's a separation yeah okay first of all uh just wanted to uh say I think we do need two modes we need some sort of flag that allows groups with metadata privacy and without that seems like fairly natural to me uh and that's kind of independent I think from whatever method we go for or we end up going for either the handshake encryption or the pity or maybe mix of both who knows uh and then yeah the other one just wanted confirm with the pseudonymous approach if that's the one"
  },
  {
    "startTime": "00:26:01",
    "text": "that Rafal and I put forward uh yeah so there is the difficulty of uh new members having to know a secret key to deson amize uh existing group members but I would argue that you if you want to protect the Privacy somehow uh you need some sort of secret information that distinguishes the Hub from uh other group members so I think if we like of course maybe that's uh that's not quite true but I would assume that we need some sort of distinguishing Factor here whatever um whatever method we go for so yeah what do you mean we need a distinguishing Factor uh I mean something that distinguishes the the information that the Hub has from the information that the users have if if you want this exter like this external join where someone can join the group completely without any interaction with existing group members um then you either leak all the metadata uh by you know uploading everything that's fine if if that's what you want or you share some sort of secret information that then allows the new group member to somehow get access to the metadata that the Hub does not have access to or it's not meant to have access to so I think there needs to be something uh there that's necessarily going to make joining tricky without the help of an Insider uh yeah but there's other ways I'm of course open to hear it just seems implausible to me so I guess that's me um I'm honestly kind of having trouble keeping track of all the details of the schemes we're talking about here I I recall that we got kind of a presentation walk through of of Brendan's scheme has this been written down in in kind of graph form"
  },
  {
    "startTime": "00:28:00",
    "text": "because I think that might help flush out some of these details um so that's one one point and the other thing I'll response to something I was said earlier I think Brandon you're I broadly agree that we have a pretty hard trade-off between enabling new devices to show up and this uh privacy property from The Hub so I think that's like capturing those sort of tradeoffs um would be something good to do when comparing these kind of goes to that what's the Privacy model question oh yeah so I mean this is written up in a gist that I shared on GitHub or on the list previously it's not written up in draft format to okay so um some information that group members have and that the Hub doesn't and that allows clients to discover who is actually in the group so I think in the like the Canon of MLS if handshake messages are encrypted then that secret information is just the MLS key schedule where you can only add people to the group if you can send a welcome for the group that's valid um and if the the handshake message isn't encrypted then you can do external joins and then there is no private information and we can definitely work on like gradients between that like Conrad said earlier the idea of being able to only have external joins for uh new clients of as team members I thought that was a really good idea and um seems like a straightforward thing to work on Eric"
  },
  {
    "startTime": "00:30:09",
    "text": "hello your hand is up sorry um I also like Richard a little trouble following all things being discussed here um uh um I did look at the just but frankly it's a little sketchy so um I think really a draft probably is the next stage of the equation um um and then I think um depending on how that goes maybe line team but um I think I think this is turning into a little bit difficult difficult to track for people okay thank you um and just a check in people feel like they understand the external commit flow here roughly in terms of this proposal just to be clear or to make sure I understand in in this scheme uploading a group info means leaking the metadata to the hub uh um not necessarily I mean you could have an MS extension like I think that when you proposed uh the the pseudonim extension that you were working on I said that it would be really interesting to apply that same encryption to the ratchetry instead of applying it to people's credentials um because then what you would have is you would have a way for um whenever someone sends a group changing the ratchet tree they could"
  },
  {
    "startTime": "00:32:03",
    "text": "update the encrypted ratchet tree with a logarithmic amount of data um and then that would make it easy to have groups where the handshake messages are encrypted um but you could still do basically assisted joins where I send a welcome um and the welcome has like the hash of the ratchet tree but you have to go download the ratchet tree encrypted from somewhere else right so I I remember you you you suggested that and we did think about it we did kind of walk through it a bit and what we ended up with is that if you did that you would always like if you do a commit you have an update path so you have to update the essentially your path and the encrypted vet tree thus leaking who the sender is at least within the tree and that again leaks metadata about you kind of so that's you know you can do it kind of but it's in the end the metadata you lose a lot of the metadata benefit that you get from encrypting head check messages and then of course if you encrypt the group info just sorry one one second if you encrypt the group info you again to encrypt it with some sort of key that then again needs to be shared and then you end up in the same situation that you're in with theonomous approach where you need to share some sort of key with anyone who wants to join to allow them to actually decrypt that kind of stuff all the the registry so on the first point of you lose some of the metadata protections I don't think that you lose the protections at all I think this is exactly what we expect um which is if I am a local provider then I can kind of see directly which of my members are participating in the group I can see whenever they send a commit and update the ratchet tree I can see where they are in the ratchet tree um sort of indirectly like we're talking about but if I'm a hub provider and I'm"
  },
  {
    "startTime": "00:34:00",
    "text": "interacting with follower providers then whenever I see changes coming into the group um I can see like some sub some subsection of the ratchetry belongs to members from this follower provider but I don't know anything about those members um so I think that's kind of exactly what we expect oh I mean I see the The Hub provider would see the direct path that was changed and so it would know who who in the tree the commit would come from it can see whether commits come from the same people or not but it can't see uh that person's Identity or anything no exactly and that's similar thing in the pseudonymous approach so you know you kind of you degrade privacy to the point where it the the thing there's not that much of a distinguishing advantage over theonomous approach and I mean a bit to be fair you know if you do a a remove and you blank a path then you don't really know if I'm updating a path or if I'm blanking a path if you doing the encryption right and stuff but it degrades in the direction of the pseudonymous approach let's say it that way I'm still not sure that it does because in the um in the pseudonymous approach you have to do this like um key exchange with anyone that you want to be able to add to a group here you don't have that issue so if you just encrypt the ratchetry directly then what can happen is that I can fetch a key package for you without any prior consent from you um I can fetch the key package I can add it to the group I can uh encrypt that key package so that nobody can see who I'm adding to the group or at least nobody who's outside of the group can see who I'm adding to the group um right the whole key package thing you"
  },
  {
    "startTime": "00:36:01",
    "text": "get away without having a mitigation there that's true that's true so so you don't need that but what I what I was saying is that you need a if you want someone to join externally without any help from an existing like online group member then that person or that client needs the information required to actually decrypt the retry and then again you need to sh share some sort of secret out of band no exactly like we talked about earlier if you're supporting external joins then and having encrypted handshake messages isn't going to work in the first place like you have to do something else well I thought you meant that we could have encrypted handshake messages and then do this uh partial updates of the retry using the encryption method I thought that okay maybe we've been talking past each other no those are different points so supporting external joins is the problem of someone who has never been in the group being able to join the group um what we were talking about with being able to encrypt the the ratchetry with what you were talking about um with with your proposal is assista joins so what that means is that I can send a welcome to someone and add them to the group and maybe the group has a quadrillion members in it but um the the amount of data that I have to upload to send that welcome is still small I see that's what we want okay I see what you mean yep that makes sense so that you could do but the metadata question would still be the same more or less in terms of what the Hub sees and what it doesn't see MH yeah you're right it is some linkage okay so um moving on to the second point that I think Richard brought up policy enforcement so my proposal or in my proposal um this all"
  },
  {
    "startTime": "00:38:01",
    "text": "has to be client side so clients are the only ones that are ever trusted to actually enforce policy and I think that is kind of um a natural a natural result of MLS being an encryption protocol that you can't really look into it and see what's happening that's intentional um so all of the policy enforcement in terms of like saying like Alice can't add someone to the group um that would only be able to be enforced by individual clients um and of course it also means that everybody needs to have consistent rules for what policy enforcement is so that everybody enforces policy evenly and well would happen if someone ever sent an invalid commit so going back to this diagram um let's say that someone sends well the colors are going to be confusing um let's say that someone sends an external join here um but we don't like this person um we don't think they should be allowed to externally join because maybe they are not a new client of an existing member or something um so what all the clients or what all the members of epoch would do is they would all just ignore that and Skip straight over it um and then go to this next external commit which is valid so that's how policy enforcement Works does that Rowan um so in this case there would you would basically Fork right I mean because whoever sent the first external commit would that would create that would create a new epic and since the the DS would presumably take the first one of"
  },
  {
    "startTime": "00:40:00",
    "text": "those that it got and assume that it was correct unless it had reason to believe otherwise and it would and it would offer that you know the hash of D to everybody and people who didn't you know basically everybody else except for the sender would say hm like I don't like that that looks invalid um and then they would need to go and explicitly request C at that point did I understand that correctly um so you're correct that it's a fork but I think the fork is less of an issue than you're saying because whenever we Fork the cinder um who sent this commit the first invalid external commit what happens is that they get this new Epoch D um and then they would essentially be sitting in D alone because everybody else would see that and they would proceed to see so there is a fork just one person is here alone and then everybody else is here I so yeah I I understand but but everybody else didn't get C they had to request C so C why didn't they get C what do you mean when you say they what do you mean when you say they have to request C so you're so in you're under the modification of your gists you're saying that both D and C are delivered to every to everybody this the part I'm confused on too can I can I try to restate maybe and see if I understand correctly yeah please go that in your version of this does the Hub and all other entities just blindly put forward any message from anyone that thinks is a group participant um because there's no way to determine whether whether whether D or C is valid exactly okay thank"
  },
  {
    "startTime": "00:42:02",
    "text": "you and I mean that does sound kind of severe saying that we will push forward any message that might be from anyone um yeah I mean my concern is that this basically yeah okay I maybe this isn't this isn't a denial of service amplification attack uh because you're sending both DNC if you had to request C then this would be a potential amplification attack um but still the fact that you could cause more messages to be fanned out that it it doesn't feel great but I don't see immediately a problem with it so so I think this actually gets back to the qu the third question which I was asking which is how do you resolve these issues and it seems to me your answer is you say you don't right namely that um that as far that that you simply have a you simply have a partition and that everybody bad is want partition everybody good partition and that's fine is that a fair to how you think this resultes yeah that's exactly right okay um so I I that is like making the clients like a lot more loadbearing um in terms of like any defect in the client potentially creates an un an a largely undiscovered and undiscoverable on partition um so if you say I have a pair say I have a pair of clients or some same implementer which both which both implement the policy incorrectly right and um and so so I set a bogus update or I set the bogus update or whatever and now I'm just partitioned off and it's like I'm not even sure how how I find it out do you have an answer how they find that out um so what I said when we talked about this at the sorry can you m yeah oh sure sorry thank you um so what I said when"
  },
  {
    "startTime": "00:44:04",
    "text": "the question was asked at the last interum which I don't think he liked very much um was that if you have two clients from the same implementor that both Implement like buggy logic where they send a bogus commit and they go off in their own Fork essentially what happens is you just let that fork exist and you let those people go off on their own Fork and it's basically a human problem to say you know hey you have a bug you need to fix this and I remember you saying you didn't like that because you didn't think it was operational operationalizable um but I mean bugs are kind of by definition not operationalizable like someone has to do something to fix them well but my point is it's not even detectable is the situation you sitation I understand it is I just stopped getting messages from everybody it's DET by by who by The Hub who can see that there's now two forks in this group right because the option is the two people who go off on the fork either we break the client and the client stops working immediately and forever as soon as they do this or we allow them to go off on their fork and the person who runs the Hub can see you know all the clients from this one implementer are buggy well right this is in fact why I asked you to like write down the draft right because like those are two different things and um and so like I no I don't think that being silent is acceptable um and I think if the Hub is supposed to do something then we have to describe what the Hub is supposed to do um and um and like and so I I think this is like worse than like the Hub Ash doing some filtering right because do some filtering and actually's an opportunity to tell to tell to reject the thing so the client doesn't get forked out so like you're you're proposal is I'm just is I'm just like purchasing off for days"
  },
  {
    "startTime": "00:46:01",
    "text": "or weeks until like until my importation is fixed and that is like a substantially wor experience right so um so so so I think like really does need some recovery mechanism that is better than that I can imagine a number but I but better than that okay yeah so I think that the solution that we would have here is essentially whenever the DS sees that there's a fork so we see that this group has gone off in two forks we don't know why um it's still essentially a bug where there's you know something that could be looked into by a human but also you could just do kind of a rough group consensus where it's not a blocking consensus in terms of like everybody needs to agree before we can go to the next Epoch just the dscs you know everybody went off on C and this person is in D alone that that can't be right that this person isn't D alone and everyone else isn't C so what we're going to do is just like terminate the group and say you can't send messages to Epoch anymore um and then that would prompt the client to do a re external join and then they would re externally join back into C so um and what happens to the majority of the groups the defective ones if the majority of the group is the defective one um I don't know what to do there okay well I think I guess I guess what I'm asking is not for you to solve this problem with the microphone when I'm asking for you is to Sol is to solve the problem on paper um and and and or or or that we mark an unsolved problem and then we say have to solve something but like that's what I'm asking for okay okay so I think that um that is policy enforcement kind of wrapped up Richard since that was was your point"
  },
  {
    "startTime": "00:48:03",
    "text": "does that sound at all acceptable to you or is it really important that the DS as someone who was outside of the protocol can enforce this policy is the screen share broken it seems right to me yeah I see the screen share as well again I I think I need to look at a document and really understand the approach here but um it's not totally implausible to me that we could as eer said make the clients more loadbearing uh in terms of policy enforcement but yeah I'd like to see it okay this one's good um also in terms of fragmented update path so um the update path is kind of a specific problem where if you list the ways that an MLs group can break there [Music] are fragmented update paths and then there's everything else and the key thing about everything else is that um Everybody agrees when the group breaks in any other way other than a fragmented update path um so"
  },
  {
    "startTime": "00:50:04",
    "text": "everyone agrees and so you can follow this kind of branching Dynamic pretty clearly when the group breaks in basically any other way but when you have a fragmented depa path everyone does not agree it's sort of natural that one subgroup of the group is not going to agree with everyone else um so that's a work that I would propose sending to the MLS working group to create some kind of extension to deal with this in some potentially tractable way so Brendan um we already have the authentication code um which at least allows you to detect if there is a fragmented update path um the Authentication code is that basically a secret that's derived from the key schu which just everybody wants to agree on yeah you I think I think in in the RFC it's called the epoch authenticator which yes is a value derived off the key schedule that you dve using some label from the EPO secret and reflects agreement on the EPO secret and all that in sales okay yeah so I mean detecting that um detecting that people have forked off is actually relatively easy because when you have a fragmented up tapate path what's going to happen is you're going to have this Dynamic up here which is that people go off in two different forks and that's immediately detectable by um by the DS at any rate and of course you can also give the user some kind of mechanic for seeing that people have gone off in different Forks you can give the the clients a mechanism for seeing that some clients are in different perks than another one"
  },
  {
    "startTime": "00:52:01",
    "text": "um the problem here is more so um opening up the the MLS key schedule a little bit and proving to the DS that the update path in this commit was fragmented and because of that this person should be banned and I should be allowed to rejoin that's uh the work for MLS um it's actually being able to update being able to to to open open up the MLS ke schedu a little bit to prove that someone did something bad but without breaking the the security guarantees of MLS and that's also why that needs to be um sent to the MLS working group is because it's a pretty direct cryptography problem to say like hey I want this like internal part of the the key schedule that I want to share with my DS to prove misbehavior um but I want to do that in a way that's not going to um compromise my own security so it's not detecting the problem it's proving it in a court of law is the problem okay um so that is all of all of the points that we had written down earlier is there anything else where people feel like they don't know how to do something that they need to do in the context of The Proposal that I shared or are we done everybody understands this proposal yes um so well I mean I I think that several people have said that they'd like to see you know more details uh written down written up yeah but um like in Broad Strokes I feel like I I am getting the gist of what what you want to do U but I'm not getting a you"
  },
  {
    "startTime": "00:54:03",
    "text": "know I'm not getting a strong sense of from a privacy perspective why we need to do um why we need to do this approach in order to get some privacy property and then in terms of um a fragmented update path I'm also not you know if this is a that we solve in MLS this uh I'm not seeing why we need to go with you know one approach or the other based on on that because it would that would that solution from the MLS working group would work in either you know would work for for any of any of the approaches that people have discussed we no longer have you know are like working with um so that I mean if if you do want talk about invalid commits um we have to dig a little bit deeper into the ways that MLS can break um so with my proposal the the only thing that needs to be remanded to the MLS working group is this right here which is the fragmented update path we need some way to see a little bit deeper into MLS to make sense of that thing that my proposal has different from every other proposal is that it handles all of the everything else problems right because in my proposal if you send a commit with an invalid Mac or um signature or whatever I I think people want to see writing up the everything else like maybe maybe Conrad has something to say about that no I mean I I agree and we we had this discussion that even in even in the approach where we have public handshake messages there are things that can go wrong you pointed out that can go wrong"
  },
  {
    "startTime": "00:56:01",
    "text": "uh that are not detectable by the U by the DS um I think and I wrote in in one of the mails that I think it's this is kind of somewhat orthogonal um and by that I don't mean that um it depends like depending on the approach we take this might enable uh encrypted handshake messages or not but whatever approach we have for encrypted handshake messages we can also deploy for unencrypted hchc messages is what I was trying to say and so maybe we should discuss this somewhat independently in terms of uh what what do we actually want what kind of guarantees do we actually want and then we can figure out like how do we square that with uh the encryption or non- encryption of HCK messages do that does that makes sense I'm still kind of trying to wrap my head around when you say they're not orthogonal you I mean because they're not orthogonal in the traditional sense of like solving one is independent of how we solve the other because if we solve the invalid commit problem in a specific way um that does very seriously impact how we're able to solve the metadata privacy problem right because if we if we solve the end problem like this or we have this hands off TS um then solving the medad Privacy problem is just a matter of turning on MLS handshake encryption um if you don't need external commits which many of us do yeah I I agree that they're they're linked certainly um so yeah maybe it makes sense to to discuss it in this context but um what was I going to say right yeah"
  },
  {
    "startTime": "00:58:00",
    "text": "and so so just to kind of try to figure out how we what we do next with the action items and one of them is is uh is the right write up that I think you already uh you want you said you wanted to do on on your proposal and you already have I think uh a pretty thorough right up there um but also then maybe a comparison between the pseudonymous approach and the um and the encrypted approach in terms of the functionality we get how are they different in terms of the functionality we get or we don't get and how are they different in terms of the Privacy we get or we don't get I think that that would be very helpful and I'm happy to uh you know um have out or or do this and if if uh yeah if we want to do that okay thank you um yeah this may just be a different version of what you just suggested Conrad but I feel that we're um we struggle in part because we haven't written down what we think the the metadata privacy requirements actually are for Mimi um in detail and so maybe that would come out of the exercise that you just suggested Conrad but I I think we really need that to move forward in the next round of this conversation so whether that's like a separate articulation of that from each of these two proposals and then we can compare or a unified um set of what those requirements are and then we we look at how the the various proposals fare against them but I feel like we keep like veering into different aspects of the solution that may or may not relate to requirements that some people think we do or don't do not have and um it would be a lot more clear if we had them written down and then we could use that as the benchmark"
  },
  {
    "startTime": "01:00:02",
    "text": "yeah thank you um okay so we do have some action items um but I mean unless Eric you have some suggestion for like an example I could work through that would help understand it then I think I I might be done for today I not at the moment okay I will write it up like you asked okay okay thanks um so just to review what we think the action items are here um so I think Brendan you're going to write your proposal up in more detail in a draft that's one action item M yes yes okay and then um Conrad I I liked I I liked what you suggested um maybe you could you could restate for the for the action items sure sure um I'll try to find out what the diff is in terms of functionality and and privacy between theonomous like the vanilla approach theonomous approach and the encryption approach now I'll sync with Brandon to make sure that I you know I get it right in terms of the encrypted stuff because some of some it I might not have fully understood if that's okay with you Brandon yeah that's good thank you okay that sounds good as far as next steps I think anybody else have anything before we break okay you get a whole hour back enjoy see you on the list"
  }
]
