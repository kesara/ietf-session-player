[
  {
    "startTime": "00:00:14",
    "text": "hello everyone uh I'm gonna wait few more minutes probably just to give people a chance to join so wait maybe till or 5 e e e"
  },
  {
    "startTime": "00:02:27",
    "text": "Ryan do you have a question no I was just waving e e"
  },
  {
    "startTime": "00:04:21",
    "text": "okay let's uh let's get going so uh welcome everyone um this is the uh one of the aw group virtual interim meetings so let's get going as a reminder the not well applies here so make sure you're familiar with this because this governs everything that we do at the ITF so make sure you're familiar with this um our schedule is today we'll talk about Pika H we have one more meeting next week and we will be done with those interms um and yeah next week we'll be talking about talkking status list all status at station and Global token revocation so that's our schedule um any comments questions if not I'm gonna share slides and see if I can hand the Reign to Richard let me see SL all right I think I have control of that let's see yep okay over to you all right thanks rat um so I'm here with Sharon um to talk about uh Pika um we we presented this at the last ietf meeting under the name signed jwk sets but we needed a catchier name and a"
  },
  {
    "startTime": "00:06:00",
    "text": "cuter mascot um so we came up with with that one so this is largely we we got an internet draft published after the ITF meeting um and the content isn't really any different than what we discussed there so this is kind of going to be a repre of what the technical content we talked about at the ITF meeting but you know now with a an actual internet draft out there for folks to read hopefully some some folks have taking a look at it uh and uh hopefully getting to an actual adoption call at the end Sharon you want to say anything by way of inter yeah I just want to add that we we did actually like we had our own design initially that we came up with and then we realized we could actually pull most of the design from the oo Federation draft so you're going to see a lot of format in here that we just like copied whol stale from there because it was exactly exactly what we needed so we figured not to reinvent the wheel just pulled it right out and used it in the draft yeah great great Point Shar and thanks thanks to Mike Jones for uh that comment at the ITF meeting there was a bunch of um useful content in the open ID Federation draft that we R using here all right so let's dive into the background here to kind of get folks on the on the same page as to what problem we're trying to solve so I think most folks on the call here have probably done this like oo open ID dance where you get some signed statement from an oo or open ID provider you know something like uh you know some jot some ID token uh something like that and you want to verify the signature on that so you need to have a uh get the keys that are trusted for this this issuer um right so there's um a standard open ID Discovery mechanism that you use to uh go get those that key set over HTTP there's a similar one in sdbc um which you know it conceptually hangs together you you trust this thing because you over https from the by issue"
  },
  {
    "startTime": "00:08:02",
    "text": "URL um but it has some problems in operations um in particular that key the key that you're looking for to verify this thing doesn't you know isn't always accessible in that in that way um you know it can be accessible due to praic reasons just like the key server being down uh due to some transient outage um or you know it could be that the key has been rotated and the you're trying to verify something older um that isn't reflected in the current key set that the that the issu is publishing anymore so that's the the kind of underlying problem we've got here I want to talk about two ways that that manifests um the first one comes up when we think about things like MiMi or like uh you know endtoend encrypted Zoom or WebEx you know cont applications like that where we might want to use uh things that are issued by an O author open ID provider um you know in particular things like verifiable credentials um so in these settings you know when we think about normal ooi stuff normal open ID like stuff like the client there's pretty unitary clients um you know you're like using Google login to log into you know uh you your favorite web app of the day and that the server over that web app you know does a bunch of these logins and caches everything but in these new applications that are doing these end to end protections uh the the relying parties who are relying on these issuers are much more distributed um so in a meeting like this you know where we're trying to present credentials uh to each other that are issued by some issuer every individual software piece of software that someone's using here is a client and so you know you're not going to get caching benefit there because you're not doing a buil of these credential verifications you know you get within a within a meeting but maybe not a you know much more than that and so you know especially if you've got fresh clients you're going to get a bazillion requests going to this key endpoint uh on the op uh at the when people join the meeting"
  },
  {
    "startTime": "00:10:01",
    "text": "or you join the messaging session or what have you so like that's you know Annoying for the for the issuer right because they now they have this giant you know bump up in the metal traffic they've got to handle on that key end point static objects it's not terrible but it's annoying it's unnecessary um as we'll get to and for the from the application providers point of view of course there's downtime risk here so your you know your authentication aspects of your end and security are reliant on this fetch going to an external uh provider uh that that you can't control and if that external providers down and people get you know login errors or authentication errors what have you um so the idea here is that it would be nice if we could have some caching and redistribution of this um of these keys that the clients need to fetch so that you know something like the app provider can can own its Destiny a little bit more so the app provider could fetch the's keys and cash them and redistribute them what without the app provider also becoming trusted by virtue of that right so so we want the client still to be able to verify that the keys came from the issuer but have them mechanically you know cached and redistributed by the app provider and so you know maintaining that trust that un you know when even that you're being uh distributed by untrusted intermediaries is kind of the goal of the extra mechanism we'll talk about here and and by the way it's like very very similar to the way if you might do a TLS handshake you're not going to go get the certificate from the certificate Authority you're going to get the certificate as part of the handshake right because it's been cashed by the server so this is very very similar idea that we want to bring um to open ID connect the other use case here and yeah go ahead no no um yeah so this is another use case and this is a historical verification of objects that have issued biops I should give a little bit of background on this this and I know there are folks in here that are um"
  },
  {
    "startTime": "00:12:02",
    "text": "like intimately aware of this application and working on it so if I don't know what the etiquette is but if people want to chime in here kind of where this application came from but um if you have a a a situation where like what we have with Open Pub Key which we've built on top of oath or if you have with verifiable credentials or with SD jots or any kind of situation where you're getting a credential from an OP where that credential has a binding between some kind of public key and um an identity signed by the op if you want to use that credential so you can see the square in the middle that's the credential you have the the key of the developer which is bound to the developer's identity the op would issue that credential for example in an sjot or for example in an open pubkey PK token um and they would um then allow the developer to sign something right so what we see see here is we have the op um signing the credential in order orange then that credential contains a binding between the developer's identity and their key and then that key is being used to sign some other object which in this example is a container so if your application is you want to sign um containers like some sort of software artifact and you want to sign it using credentials that are issued by an OP um the difficulty that you may have is that you know the container may need to be living and being signed for a period of time that's longer than the the lifetime of the op key so that's the fundamental problem you have this container and it's signed and you want to be able to verify it sometime after the op key is rotated or um you know if the op is not available at that particular moment that you're trying to verify um so you can do this like magically you need some sort of way of of attesting to time and so the solution here uses a timestamping Authority so imagine you have an authority that can say object X existed at times T um so we use that Authority to prove that the verifiable credential"
  },
  {
    "startTime": "00:14:01",
    "text": "agre existed at time T right we could use if we had that timestamping Authority that was stamping that the credential was actually used at time T we might be able to use it to verify that the container was signed at time T except there's one really big problem how do we know what key the op was using at time T if it's already rotated it and we has no rec we have no record of what the op was using at that past time right so the problem is we want to be able to take credential from the past and verify that it is actually a real credential at that time in the past and if we have a tam stamping Authority that can say this is what was going on at the past and this credential existed at the past we would like to be able to validate that that uh op's key was actually the correct key at that time okay that's what the paa is solving so the paa is going to allow us to say that this was the op's key at a particular time um and so it's unlike today when an OP May rotate its key and there's really no record for the outside world of what it did or what it was using in the past with this we can have a record of what it was doing at a particular time so it's sort of two properties what Richard mentioned was the redistribu redistribute ability and the caching so the ability to cach the key and and just redistribute it in application so you're not dependent on the latency of the op or something in a in a sensitive application and in this case it's actually having the credential and being able to look at it at some different time in the future and know that that was what the credential was at that particular time all right should we go on Richard or do we wna let's see if they anybody has any questions about those use cases anyone have other use cases you'd like to contribute yeah too we have some interest in this I'm Joel from jumpcloud been working with Sharon and and um you know around some"
  },
  {
    "startTime": "00:16:01",
    "text": "interest at uh actions taken by our admins um as they manage policies manage users and other things and admins may leave organizations signing Keys may change so we're looking a way of having a lasting record that some action some policy some command that an admin has done and signed by their key even though that admin is gone that key may be gone we still want that chain of trust leading back to that signature um so that's where we're interested in this okay thanks Joel anybody else okay back to you guys yeah so so as Shar was saying and thanks for the great great kind of transition there en Joel because this is this is really about you know extending the chain of trust so right right now with the Technologies we have we've got you know a way to take this signed object you there's several ways you can take signed objects sign with a key that's issued in a credential something like a PK token or a verifiable credential or SD job BC any of those kind of credentials in the middle you those can get issued by openid open ID providers in various ways um and you know the the discovery stuff kind of makes that tie together uh in you know the normal way you expect the signatures to work what we're adding here is assigned object format to say that op key that signed the credential is actually belongs to this uh um uh open ID provider o provider um op I'll use op to be generic across this too um right so if you think about the discovery mechanisms we have today you know you have an issuer field an ISS claim in a jot for example that says the issue of this has this domain name and you can you know is identified by this URL in particular that domain name the way that the trust chaining Works in today's uh scheme where you f you use HTTP to do live fetch the keys um when"
  },
  {
    "startTime": "00:18:01",
    "text": "you're verifying if you think about it the the chain of trust there kind of goes you know you you chain up to the issuer uh URL and then the HTTP https chains you from the issue URL through the web pki to some web pki rout of trust so all we're talking about here thanks apple is um trans instead of you know doing that that web pki chaining through https and sending that in a TLS connection doing that with assigned object instead so instead of having you know a bunch of bytes over a TCP connection you have a bunch of bytes in an x5c header in a jot that lets you verify that you know this this object was signed by someone who holds a given domain name so it's kind of like it's kind of like taking this online key exchange process that you would do in HTTPS and just stuffing it into inside the paa and we have that X5 field x5c field if you see the Pika is the square in the middle we've got the x5c there which is basically some sort of formatted um certificate that what is what you would have gotten anyway if you would have used as https um although with just a little bit of an asteris because sometimes when I've talked to people about this I've confused them by saying this chains to the same um you know key you would use in HTTPS we're not saying you have to use the actual ual key that's in your TLS box that's speaking TLS for you at that time but we do we are saying that you would kind of chain to the same route right Richard like how would you how would you explain that um what that key look like you can have a special key for your paa but we want to chain to the same place that you would have chained if you had been speaking https right I I think at this at the level of the specification here will be agnostic as to the pki but I think in practice you know the way you design it is to reuse the web pki uh that people you know know know and"
  },
  {
    "startTime": "00:20:01",
    "text": "trust for these things already um so I what what AA looks like is basically you know you take the jwk set you're used to Distributing through that HTTP endpoint uh you make that the payload of a jot and you put the uh certificate chain in the header of the jot um so at that level I I think it's hopefully kind of unsurprising to folks um a couple of interesting bits here you you can see the the the search chain up in the header um a couple of interesting bits here that we we pulled from the the open ideas um are about managing the validity intervals of these things so right obviously jots have these iats and uh X fields that uh Define the validity interval of the JW um here that's kind of nice because it ver it you know bounds the validity of this statement that the op is making about their keys but it's also useful to do a similar dance for the keys themselves so we have these I add and X fields on the keys uh within the the jwk Set uh that Define when the op was signing with that key and that's useful especially in those kind of historical use cases because if you're trying to say like I'm trying to verify an object that claims to have been signed at time T you can verify that the uh op claims that they were signing with that key at time as well all right so it's not just that you know you have a jwk set uh that expresses everything that's valid for for an OP you can also bound the the lifetimes of those keys within the scope of this this statement um I think that's the main I wna I want to say here yeah I just want to say something here so like another way to think about this is the op Keys each have their own interval and that's like the interval for signing and then there's another interval which is the paa validity interval which you can kind"
  },
  {
    "startTime": "00:22:01",
    "text": "of see at the top of the payload and so that um is how long this paa statement is reasonable and there's like one other really cool thing that actually Richard and I didn't design but we just pulled straight out of the Federation draft if you look at the the second key you can see it's like revoked at time reason key compromise reason code one so like we pulled that straight out of federation we didn't plan to put that in but we saw it and we thought this is great because let's say you have a key that you had a paa for and that key was okay and then like a year later you decided that that you discovered that key had been compromised you can reissue the Pika um and say that that key was compromised and now you've basically revoked some sort of historical information so we we have that kind of for free we got that out of the Federation draft so that's there as well Brian do you do you want to talk about the the jot type thing I can't hear you Brian if you're speaking oh actually by the way do do we have someone taking notes on this because it would be good to collect anything to make sure we it reflected no to do that like think H is hes didn't join today so but uh yeah typically hanis was and and I completely forgot about this yeah we have the recording anyway Brian go ahead you you couldn't hear me because I raised my hand instead of unmuting thus further showing my incompetence um sorry that's a total sidebar but for the type either use something meaningful based on the uh JWT BCP that I don't know off hand but um you can find it or ping me and I'll send you a link or just omit it entirely but is a little pet peeve of mine type jot is like just a waste of space in"
  },
  {
    "startTime": "00:24:01",
    "text": "everyone's time so I it's a unnecessary pet peeve but here we are that's all I'll take on that thanks Ryan Christina hi yeah um you mentioned Federation draft I was wondering if you looking at a trust Mark mechanism so I feel like being able to add trust Mark here might be an interesting way that you know can add additional contestations or something to I mean to be fair trust works are pretty under specified configuration but just I guess just ping is there an appetite to explore that and I and I can elaborate later I'm not going to place to elaborate on right now but yeah so thanks for that um I admit I am unfamiliar with the trust Mark stuff I think you know without you know with that caveat I think I would probably say like let's solve the immediate kind of cryptographic trust problem first and then we can go about adding more metadata after once we've got a signed object we can add more metadata well that the thing like in some use cases the cryptographic trust I don't at least in the some of the EU use cases that cryptographic trust kind of requires those trust marks in some use cases um but yeah no like sorry I'm boarding a play I won't be able to speak much after this um they in general supportive over this draft but um yeah I think that's one of the area from the EU use cases I know I would be curious to kind of explore on update followup great thanks yes this this is the last slide we have so um I think the proposal here is we we've got a draft out there for a couple months at this Point um I would"
  },
  {
    "startTime": "00:26:00",
    "text": "uh propose that we we take this on as a working group item um I know that's the chair's prerogative to actually make that call but um love to hear feedback on that idea yeah I think uh I'd like to wait until Vancouver so when we have the full kind of work group kind of uh present there and discuss it there so if we can plan on U presenting this again in Vancouver and then I think we'll be better better position to make a call for adoption at that time next s Richard um I I yeah I guess I'm not sure what we're gonna gain between now and then um maybe we go ahead I want more people to uh hear this presentation visibility provide feedback because the the LI the number of people tended here is limited compared to the full work group meeting in person right yeah I so if I if I may chare a bit from the floor like a tactic IID used as a chair sometimes in pass was to issue a working group second last call in a document to kind of solicit people to comment as if it were a last call um so maybe if you're worried about making sure that there's enough you know folks who have seen it and do it we could we could have some sort of you know call for feedback um so so that we could proceed a little more directly um once we once we're sure we have visibility like you Carston car yeah I'm a working group chair so so I apologize if if I'm thinking like I'm in in the working group's eye chair um but the point of a working group adoption call is to get this discussion going and we have an interim here we don't even need an interim to start a working group adoption court and uh so I I think pushing this into a working group AD call is valid uh there are a"
  },
  {
    "startTime": "00:28:02",
    "text": "lot of people who are not saying anything but thinking of course this needs to be done um at least that's what I'm thinking um so why not just uh do a working grp adoption call and if problems come up there you can always extend the adoption call or or do another interim or whatever uh I don't think we need another ENT Vancouver is not not far from now um anyway it's something I'll I need to discuss with with Hanes and and we'll make a decision later on on call for adoption okay any anyway Brian you want to say something I was half joking but sort of sort of trying to agree with maybe some kind of like uh warning or preall for adoption you know message to say like turn up interest beforehand and then consider like looking at the C for adoption um in Vancouver but some I don't know nudge or something to to try to Peak uh people's interests before the the meeting yeah that that's reasonable thanks Ryan um Joe were you trying to say something yeah I mean I I I think most of the feedback I've seen there's been some discussion on the list and and I know you know we have use cases that kind of align with this draft and so I think there's been some fav discussion on the list I think we'd like to en encourage that you know and adoption call is a way to do that but you guys could do it in in whatever way you you see fit but um I think it would be good to have some more discussion here uh but it's thanks to the authors for putting it"
  },
  {
    "startTime": "00:30:00",
    "text": "together okay okay awesome anybody else has any further comments yeah we've had a lot of uh Meta Meta discussion here about the process if folks have substantive comments about like whether this seems like it's on the right path or you know how's the that would be helpful as well I would love to hear from the docker folks because this is actually so there's several folks here from Docker that we've been talking to I guess they're not super iters Like Richard and I am so it would be lovely to have just some words from them and how they're thinking about this just so the group can see and then you can meet them as well maybe we'll see more of them in the community yeah that would be great um I see James in the queue there hi go ahead I'm James um I said something in chat but I'm I'm working on supply chain stuff at Docker and um we we looked at uh Open Pub key over the last year or so and we've been following that project and um we're very keen on the idea that um if you're building something on say GitHub actions you're able to to sign stuff in an open pup key like way uh sign images and add attestations build attestations right there rather than calling out to third party signing things which is kind of what everybody's doing um but of course the um the log of um public Keys open Pub key needs um is a bit of a stumbling block for us on that so so just to kind of add weight to the idea that this is like super interesting um you know we we would be very keen to engage with ODC providers and push them in this direction if if if um this was I don't know how I ietf works and how you get people to actually adopt these things but um people like GitHub and and uh Google who are doing builds would be very interested in working with them to um adopt P Thanks James so so like officially typically what we do is um call for"
  },
  {
    "startTime": "00:32:02",
    "text": "adoption on the Ming list so the official call for adoption is always on the Ming list all right so we would like you to engage and and and reply on the Ming list because that's the the right way to do it right so obviously these these meetings are important but when we make a call for adoption it will be on the mailing list so please monitor that and reply on the list okay yeah well I'm on there thanks awesome Johnny hello yeah i don't have much more to add to what James said I also work at doer by the way with James um other than um for what we're doing like it would be awesome if this you know was a thing that existed that we could use it really feels like the missing piece of the puzzle for um the open pubkey container signing story um so yeah I'll also be looking at that list and hammering the reply button awesome thanks good anybody else okay um Richard and and Sharon thank you very much uh I'll I'll discuss this with the with the Hest and um uh we'll see what what like I just want to brainstorm it with hanis and we'll make a decision it it's gonna we might we might delay it until Vancouver we might push it a little bit earlyer but but we'll let to know okay okay all right thanks for the time thank you all very much thank you appreciate it thank you thanks everyone thank you bye thanks folks thanks"
  },
  {
    "startTime": "00:34:26",
    "text": "e e e e"
  },
  {
    "startTime": "00:36:26",
    "text": "e e e e"
  },
  {
    "startTime": "00:38:25",
    "text": "hi guys can you guys hear me"
  }
]
