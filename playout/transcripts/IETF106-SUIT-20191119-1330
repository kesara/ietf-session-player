[
  {
    "startTime": "00:00:17",
    "text": "[Laughter] [Laughter] [Music] it is 131 so it\u0027s time all right so I think we\u0027re gonna get started so here\u0027s the note well plead oh please let us know if you have any questions so administrative tasks we have to note takers and a driver scribe so thank you if you want to follow along with the notes etherpad link is on this slide you\u0027re more than welcome to help out in addition to our two note takers here\u0027s our agenda for today any agenda bashing alright so working group status we have two drafts that are currently in working group last call I think we yeah we\u0027ve done at least one working group less call so I think we\u0027re gonna want to have some discussion during the draft updates about next step on on those two documents we also have the suit manifest which is progressing you know rather well there\u0027s been some recent updates to that and and so I know I\u0027m personally interested in where the next steps are there two milestones we\u0027re doing okay on our milestones we recently revised them we\u0027re expecting to submit three documents to the IAS G there are two documents to do is G this month the "
  },
  {
    "startTime": "00:03:18",
    "text": "architecture and information model so we\u0027ll need to talk about how we can accomplish that and then we\u0027re expecting at the next IETF or by the next IETF to be able to submit the suit manifest to the is G as well or if tea doesn\u0027t continue to give us issues I think that\u0027s so I think with that we\u0027re going to switch to the hackathon honest ok this hackathon announcement as you can see if you have been following the mailing list and you\u0027ve seen that we boasted a few males before doodle boil finding a date for a hackathon and be decided not to do it in at this meeting but actually do it separately so this it\u0027s always a question of distraction and so on this is a very busy meeting as you know or all IETF meetings a very PC and we\u0027ve been quite successful in doing the hackathon last I mean in actually in Berlin so we thought that we should do that again with the help of Matias I don\u0027t see him in the room right now or is he okay um but in any case he set up a website which I think by now includes a registration link so the idea is that we have a three day event three four days the first day with a tutorial and that tutorial is focused on giving you some or enough information hands-on information so you can then actually be productive at the hackathon so this is not a one day slideshow but it\u0027s a the whole thing is it\u0027s very hands-on oriented and will cover the work from these three groups namely suit deep and rats because they are all interrelated and we haven\u0027t worked out the tutorial day the agenda yet but that weeks I\u0027ve had a chance to talk to a few folks here and and find some some volunteers to present and you will have to subscribe register I would be free of charge for you but I need what we Mateus and I need the registration information for two reasons first of course the logistics catering etc for the for the host but also because I\u0027m ordering hardware so that you actually have something to play with "
  },
  {
    "startTime": "00:06:18",
    "text": "and needless to say that I need to know like what hardware do you to order because there\u0027s obviously some slight differences between the different groups and for the rats our group the current so it hasn\u0027t been fully finalized yet the hardware selection but for the rats group we are thinking about using one of the latest nxb our bots on supporting arm be a dem so we can actually test out these the results from from the rats at the station work for deep emmanuel suggested a port also from nxp one that is an earlier generation using Bluetooth Low Energy using um v7m and for the software updates in uh not for that for the deep work they might be um or Dave suggested that we actually use virtual machines but in addition I want to also order either the port that he\u0027s recommended on the list today if you have been to the earlier deep meeting or the ste stm32 mp1 port that I\u0027ve been using recently recently so there would be a mixture of different devices out there and and depending on who registers for what will make those ports available there will be a little bit of effort for you for those who participate up front because um we need to make sure that we have the software development set up appropriately sort of we don\u0027t waste time fixing those issues during the hackathon and and also the tutorial so I would encourage you to participate specifically if you want to get a better understanding of the technology because I think that\u0027s the only way to get there and I think this is a unique opportunity because you will hear from some great speakers during the the tutorial and then hang around to the nice environment in Berlin to work on on these protocols and we\u0027ll make some make code available as much as we can beforehand so that we can start with a good baseline and then look at some more interesting advanced use cases at the hackathon on the date you see it on the slide MIT or February based on on the research from the duty board and yeah we also would like to thank that the chairs of the three groups for their support and yeah hope to see you guys there thank you so next up we have the suit architecture okay that\u0027s a short presentation short because we have been running the working "
  },
  {
    "startTime": "00:09:22",
    "text": "group last call since I think February or April so it\u0027s a little longer working group last called and usual but I have been a couple of updates in between based on the feedback in and this is just a sort of a brief history or status version five four included some extra text on boot loaders because um there was the request and in version six we added the deep related information because of the decision from the working group to harmonize the work between those two groups so that has been done any more recently um Kathleen has posted a review a more detailed review and which led to version seven which is the most recent version you have under on in the repository that been various changes throughout the document but I specifically wanted to point out one change that concerned the section on state-of-the-art security mechanisms where I went into a little bit more detail on what the different security state-of-the-art security mechanisms are because Kathleen was specifically commenting on on those and questioning the value and on sort of the meaning of what we have written there and so I have specifically pointed out the authentication integrity protection confidentiality protection of the of the firmware image and potentially a manifest as well and then talked a little bit more about the hash based signatures and they are used in the sort of like or the potential danger of quantum computers and the fact that you have a certain amount of unchangeable code in a bootloader and so if you nail down specifically cryptographic algorithms then devices that have a longer lifetime obviously will then be at the disadvantage when when suddenly these quantum computers in their probe this when existing security mechanisms as a key security mechanisms suddenly don\u0027t work anymore so that\u0027s why I made this a little bit more explicit and also um we talked about sort of term meant under mandatory to implement security algorithms and I try to be a little bit more generic here brought it in listing his specific algorithms because probably the architecture isn\u0027t the right place to make those recommendations anyway which is in line with what we did also two hours ago or so in deep in the deep architecture so in the bottom paragraph on the screen it says has to be defined is the intent that that\u0027s going to say is defined and the super manifest or what is the "
  },
  {
    "startTime": "00:12:22",
    "text": "go for that yeah but maybe the wording could be better um but has to be defined elsewhere not in this document not in the architecture doc is it in the super manifest document right now and if not where is it or is it something that the working group still needs to do good question that\u0027s a good question I have to check I have to check I don\u0027t know Brendon up here he comes thank you okay he\u0027s coming to answer here at Brennan hey it\u0027s not currently defined in the suit manifest do you think that it should be I can\u0027t see somewhere that would be better noted the suit manifest has not gone through working your class call yet and so we will leave that as an action item for this you manifest and the architecture document can then just say it referencing the I would find an issue okay great thank you thank you okay good the audios audio at least works for Brendon this time Dave Walter can you go back one slide oh sure so heavy dave Walter Mayer have you considered 128 bits of security in this case cuz you know software updates can be long-lived information you know a lot of the existing European and missed guidance indicates 128 bits you know for information that has a lifespan of you know 10 years or more that\u0027s also reflected in in RFC 7925 good point I probably should update that then point to those other guidelines you\u0027re right so should that be because you start off on us by saying maybe this shouldn\u0027t be in the architecture document do you want to move right he length discussion the super manifest and just reference it here yeah we okay I guess I better do that okay good idea um so the other question which I think was a little bit more generic which I wasn\u0027t able to answer in form of text in the in the document yet or at all is the document currently from the history of the group focused very much on low-end IOT devices and Kathleen was saying like is there anything in the air that prevents us from using this on other IOT devices that are bigger and like a classical linux based device embedded device I mean rather than something that already has like a laptop has a perfectly fine software update mechanism so we don\u0027t need to work on that but one could imagine higher end IOT devices "
  },
  {
    "startTime": "00:15:24",
    "text": "that use classical Linux maybe use some of the stuff we\u0027ve work on in in the deep working group and so you may actually use that the same software update mechanism there that we develop here and is there anything in the document that we should be doing to explicitly call out those cases as well and yeah I I and it\u0027s a it\u0027s really a question for a working group to rather than me unilaterally suddenly expanding the scope of the work here so I think maybe question for Brennan because I thought that there was a statement that he had already added but maybe it\u0027s a super manifest document there was some statement about you know nothing in this prevents its use in larger scenarios some paraphrasing of that but I don\u0027t remember which document they got put into you but that came up we and Brennan was presenting to the teep working group and I think some statement got at which was maybe in an interim early this year and then he put in some statement after that I thought but I don\u0027t know which document it was um yeah but they\u0027re still in some sense there\u0027s a little bit of we can put that statement in the our double check whether it\u0027s India but the other question is of course to go and look into details and in some examples like does it really do we really cover everything that needs to be done or I\u0027ll be talking about extensions here as something else maybe we missed something because so far the focus was on something else and even a deep case while the devices may be or are larger and different to what is the primary focus here so far there we have been talking about updating trusted applications and what Kathleen was talking about is updating everything else as well including the rich operating system like in Linux updating the Linux I\u0027m fitting the the monitor code updating the the REE OS and so on it\u0027s on Brendan go ahead oh yeah the the update that I put in was definitely in the manifest document and it said essentially that while it\u0027s for informed by firmware update use cases there\u0027s nothing that prevents using it anywhere else and in fact I don\u0027t know how useful this is but I have seen a few a few instances of people using an update system very similar to this for updating Linux devices and even seen some discussion about using it to update Windows devices with whole system images thank you yeah the question it\u0027s like do we do we really need to do something here in this document or can we take this and move forward and sort of progress it to do the I use G and then get it published I was just gonna add our Charter doesn\u0027t preclude a solution "
  },
  {
    "startTime": "00:18:25",
    "text": "that works for higher-end devices either we just wanted to make sure that the solution we did design would work for Class two devices yep so if we have text in the architecture document that says that you know it is intended to address a wide range of things scaling all the way down to class two devices that implies it can also scale up yeah I will double check on whether that\u0027s indeed sort of crystal clear it may not it may not be entirely there yet so I would I would do um yeah I mean I\u0027m happy with the phrase that Brennan mentioned but he said that was just many manifest yes so maybe maybe something over and that should address odd uh review comments that Kathleen raised I haven\u0027t seen her so far yet so she may actually not be here she\u0027s not here okay my collage isn\u0027t I I feel like we\u0027ve been through this like discussion like 12 times Michael Richardson which discussion discussion a bit about about the upper bound of it I feel like we did this in the chartering even so I just don\u0027t know why we really I like I can\u0027t like I wasn\u0027t gonna stand up because what was the point we\u0027ve done this ready bit why are we still talking at this point so so do we really make maybe the issue is that that as the document goes Kathleen\u0027s issue is the document goes to other parts of her and other companies they\u0027re like oh but this is only for IOT right blah blah blah blah or whatever that means and and so we actually just have to kind of beat them over the head is that really what it is because I\u0027m like well I totally expect to someone to upgrate upgrade the BMC of any kind of a server system using suit right the the basic micro controller okay I totally expect that that\u0027s that\u0027s I I think that\u0027s totally in in skiing in scope but but maybe the guys over there thinking you know that bill 3u servers just hasn\u0027t occurred to them that they\u0027re BMC\u0027s an IOT device does it turn power on and off yeah right well maybe it\u0027s a beauty but perception issue and but I in in I had to as yet at the of the document I had to somehow have to address those reviews and and so I\u0027m trying to figure out what can I do differently or better maybe we just need more examples that\u0027s that\u0027s all this is explicitly included for instance blah blah blah and we should just ask for you know 10 10 10 points of weird things that people thought about that would be appropriate for suit that no one wouldn\u0027t know wise think about I mean what why not yeah okay and then hopefully we are done with that are there anyone in the room "
  },
  {
    "startTime": "00:21:55",
    "text": "that have any additional issues for this documents because if not after we address this one question our plan is to just send it forward to the isg all right sounds good Honus when when can we expect an update are you saying by the end of the meeting all right I\u0027m Yasuni you\u0027ve set a precedent okay yeah as soon as you give that to us Thanks all right so next we have information model Brendan you want to step in the queue all right Brendan all right next slide please so the last call has been going on for a while but I think that maybe the middle of August do not many people notice that it had it has started we\u0027ve had a fair bit of review already I actually just got a review yesterday which I\u0027ll come to in a little bit so I think that we are progressing pretty well here if anyone has any further comments now\u0027s the time next slide please so one of the big changes was that I\u0027ve added in a few new threats and security requirements that justify the architectures mention of an end-to-end security model previously that hadn\u0027t actually been mentioned in the information model next slide please so there are a few different threats that I added in to to cover that so first there was the interception of data between the update service and the device and then he exposure threats a specifically extraction of signing keys from some form of signing service that would be if it were hosted or potentially if it is is a non hosted service then as well the possibility of a manifest being modified in some way between the author "
  },
  {
    "startTime": "00:24:56",
    "text": "attempting to create a manifest and it actually arriving and being signed by whatever signing service be that local or remote next please then the requirements for mitigating those threats so they proceed kind of naturally their secure channels are necessary to protect status reports key protection is necessary to prevent key extraction manifest checking would be an important part of validating manifests to make sure that they haven\u0027t been modified in some unexpected way and of course making sure that a trusted environment is used for constructing manifests next slide please so there are still some more reviews coming along there was one as I said that just came in yesterday and evidently I\u0027d missed a whole series of the uses of mandatory rather than required I added in some examples of uu IDs specifically the white labeling use case where one vendor sells the products of another vendor under their own branding ad and one of the features that had previously been in the information model was using channel security for authenticating updates specifically where the manifest contained only a URI the intent there had been that you didn\u0027t need additional authentication steps to be able to just replace the URI of a manifest so that a gateway for example would be able to override where a device would look for its update or look for a further manifest but what was pointed out to me was that this would allow a an attacker that is able to compromise the channel or the communication partner to then get all of the devices that it communicates with to make arbitrary requests over the network so this seems like we should probably plug that hole and so I\u0027ve explicitly disallowed that in the in the information model now and I\u0027d be very interested in the feedback from the working group on that particular change one other minor change in the information model as a result of the reviews that I\u0027ve just recently received was to define a maximum size for the integrated payload now the maximum size that I\u0027ve defined is the whole thing has to fit in memory which I think is a pretty reasonable approach to saying how big it can be now we might need to be more specific than that and again I\u0027d be interested in the working "
  },
  {
    "startTime": "00:27:57",
    "text": "groups feedback on whether we should be defining a numeric maximum size or leaving it as just the whole thing has to fit in RAM next slide please so we\u0027ve asked for further reviews and we want to make sure that the document is complete and I think that it\u0027s in quite good shape now and so I\u0027d like to know if there\u0027s any more feedback next please or is that it I think that\u0027s the last one is nice that\u0027s the last slide all right so very quick update there does anyone have any issues with the with the current draft including several of those changes in github by the ones not in the posted copy yet those the ones would be in print and specs book to cap that\u0027s correct yes hi there\u0027s a sink of the mic Hank hi this is a manifest related question is that okay it\u0027s somewhat cold connected but okay for the manifest it goes here okay Brennan I\u0027ll have to knock you out of queue yep hi Manuel here Emmanuel gonna be fine okay yeah just bouncing back on a comment from Brendan on whether we have to put in numerical limits to the size of payloads and things like that I think this might be a little bit difficult like on our and for example with our riot implementation we really try to push down the RAM requirements quite a bit such that payload actually definitely does not fit in RAM so we use things like clock wise and things I had to actually bring down the minimum Ram requirements so I think we have to be careful here not to not to put any strain on on the RAM requirements we may however try to look at flash requirements I mean if you can\u0027t like put there somewhere so we\u0027re in the memory and maybe not in the RAM that this whole payload then you "
  },
  {
    "startTime": "00:30:58",
    "text": "have a problem but also yeah that was it Brendan you\u0027re back you want to respond to that sure yeah hi I\u0027m Manuel sorry I I think I must have not been quite clear enough this this is specifically for the integrated payloads so this would be if you\u0027re passing something very small along like I don\u0027t know maybe an encrypted key that\u0027s being delivered to a device so not the whole payload of the of a firmware update but instead just a small payload that a device is using for some other purpose and clarifying question Brendan please thank you since we just had the discussion about whether this could scale up to larger class devices than class to you are you thinking that the maximum size would be independent of device size are you thinking that the maximum size would be for the class 2 devices or something else well this is why it\u0027s currently defined as the whole manifest whatever that means integrated payload or no integrated payload has to fit in memory and I think that that makes it fairly straightforward in that respect ok sorry let me rephrase the question if it has to fit in the devices memory who\u0027s expected to know how big the devices memory is and what that limit is because is the manifest author expected to know that because maybe the device is a tiny IOT device maybe it\u0027s an 8 gig memory device is the manifest author expected to know that or is the spec take some number or what what is your proposal yeah that\u0027s exactly the problem that and that\u0027s why I\u0027m asking for feedback so my inclination would be to say all right one of two things either the maximum size should be defined as you know enough to fit a a key IR aqui wrapped key or it should be defined as it\u0027s up to the implementer to know exactly what fits I don\u0027t really like it\u0027s up to the implementer to know what fits but at the same time picking a number out of the air might break some use cases so I\u0027m a bit I\u0027m a bit confused as to where we should handle that so if I understand right you don\u0027t have a proposal and you\u0027re asking the working group for advice between the different options here is that correct yeah so it\u0027s it\u0027s a binary choice here either we define a number or we say it\u0027s up to the implementer to know and I I prefer having a number but I recognize "
  },
  {
    "startTime": "00:33:58",
    "text": "that having a number is going to break some use cases so I\u0027m not sure exactly where we go on that one how do we deal with multi-party update cases where there are multiple implementers and they might not there might not be pre knowledge of the size cuz our architecture allows for those kinds of cases the size of memory right okay so the the other possibility here is that we look at capability reporting we\u0027ve talked about capability reporting a bit in the manifest Draft and maybe that\u0027s something that we need to address as a working group so capability reports would possibly handle this situation where you\u0027re able to get information back from the device at the time of manifest creation and look at you know how big of a manifest will this device accept and then that makes it sort of academic the other working your participants have an opinion on this question this is hummus in the deep working group Honus in the deep working group if that when I am going to talk about the protocol there\u0027s actually capability discovery mechanism to do that but I but I understand it the difficulty because obviously like the manifest needs to be needs to fit somewhere in memory so that you can then verify the signature because otherwise of course the many manifests will in general be very small but so so that is typically not an issue as Manuel pointed out but one can imagine cases where you specifically with the use of public key crypto you you may include not that not just a signature but also a key and so on and so on so then it could get larger of course and so III don\u0027t have a specific recommendations on what number to put in there so I I would prefer to actually to leave it open but did point out what the problem is I think there\u0027s you can\u0027t do much more than that so this is a favor it\u0027s occurring there is a slight analogy with something like a reassembly buffer in protocols where for example what ipv6 did is they said you must be capable of reassembling something of at least this size for some number like 1280 bytes or pick a number or whatever but you were allowed to pick something larger than that and so that means if you are authoring something if you want to be perfectly interoperable you make sure it\u0027s no larger than that minimum if you have specific knowledge of the other end you could go larger than that and still "
  },
  {
    "startTime": "00:36:58",
    "text": "be compliant so that would be a possible approach that we could take I don\u0027t know if that\u0027s the right thing or not but that would be a way that actually supports both sides and says you it\u0027s not a maximum size but it\u0027s the maximum size at which interoperability is guaranteed without without knowledge of the other ends okay that\u0027s a that\u0027s a third option right so I think there\u0027s three options now that talked about any comments on that third option yeah lot of energy your own picking one so right after the discussion Brendan do you have any preference from what you heard out of the discussion of their working group so far I\u0027m gonna have to think through that a bit more I\u0027m afraid I like the suggestion that that dave has proposed but at the same time I think that the danger in that is that you end up with a whole bunch of devices that implement explicitly the minimum and rather than what they need okay so I\u0027m gonna have to think through it a bit more I I don\u0027t think I can make a recommendation just yet so I\u0027ll make a recommendation on the list once I\u0027ve had some time to think through it a bit more okay here dress since we\u0027re trying to get this sorted by the end of the month can we do it in this order make the recommendation of the list discuss that update the doc confirm the last call issue is resolved yeah that sounds good to me okay so just working back from for the rest of the the month we\u0027ve got what 12 days 11 days so you actually need to think through this to post a solution well I\u0027m hoping to make a recommendation you know sort of within the next I don\u0027t know two days so not long I just a not in the middle of the meeting that\u0027s all right so I mean thinking through that so if if you post something to the list in a couple of days maybe we we post an updated draft next week if we after "
  },
  {
    "startTime": "00:40:00",
    "text": "we\u0027ve had some you know some conversation about the the solution and then we could have a couple weeks of of last call review before we you know we close out the document that would put us a week into a week into December but that\u0027s not too bad but would something like that be doable yep this is might I\u0027m just wondering if if you put a maximum limit what would that be just just to get an idea Mohit so I was looking here at defining the maximum size of an integrated payload rather than the maximum silence of the manifest itself it might be more useful to define a maximum size of a manifest but that can be highly dependent on the on the use case it\u0027s not a fixed size format and in that respect I mean maybe that\u0027s one of the things that I need to work through in the next couple of days what makes sense for the maximum sizes in in that respect when we look at things like embedding into boot loaders keeping it really small is very important so getting the size of the manifest down for that use case is something that we we should perhaps be you know defining the new maximum size for the manifest in in each use case I mean if you look through the examples that are in the manifest document already then there\u0027s a few examples of what sizes could be I think that it\u0027s something that we should probably you know take feedback on as much as we can at this point but I think it\u0027s easier to decide define a maximum size of a payload than it is of a whole manifest right so in the payload Bay load like you would typically have keys signatures so just take like what is maybe not completely insane but somewhat nonsensical and then define so I don\u0027t know four zero nine six bit RSA keys and then taking some signatures and and then defining the maximum limit yeah I mean the other the other thing that might show up there is configuration so you could imagine fairly easily a bit of sea bore being delivered in an integrated payload because it makes more sense to do that than to have a completely separate transfer to handle that you know relatively small chunk of data and and that\u0027s where things get a little bit more complicated because what\u0027s a what\u0027s the same size of seaboard to deliver to a device in in the manifest rather than outside of the manifest so that so that\u0027s essentially "
  },
  {
    "startTime": "00:43:03",
    "text": "the use case that I am trying to work through is if I\u0027m delivering something reasonably arbitrary like a configuration blob in the manifest how big should that be well that\u0027s highly dependent on exactly what\u0027s being delivered and that\u0027s why I I\u0027m sort of trying to work through this before making a direct recommendation as I said this is something that only came up in the last 24 hours for me so I haven\u0027t really had time to work through it yet so after listening to this I think I\u0027ve changed my mind maybe we can document all these considerations and not give any minimum or maximum I think for implementers like even if they\u0027re pushing updates they probably do some kind of testing before they start you know push any any sensible developer would do some kind of testing before they start pushing updates so we document all this and then don\u0027t give any likes min or max thanks for your feedback running on your slide you say several proposed changes in github defined maximum size in github is there any specific value proposed in github right now or not no there isn\u0027t at the moment what it says right now is that it has to fit in Ram okay and the reasoning for it has to fit in RAM which isn\u0027t in github I should probably put that in is that we we need to be able to verify the signature across the manifest in one go because otherwise that leads to a time of check time of use vulnerability okay so in the interests of facilitating consensus since we had one person actually express an opinion rather than saying need to think about it then is there anybody that would have an objection that should they should we actually choose to go with the not defining a strict number in here is there anybody would actually object to that trying to facilitate some advice for consensus I one person said that makes sense okay so first your ears we\u0027re hearing general support by that but since it\u0027s only been 24 hours and has been discussed on the list we need to confirm that but if that helps you Brendon know what to think about well that\u0027s that for me that\u0027s the status quo that\u0027s where it already is so I\u0027m I\u0027m reasonably happy with that yeah but what was implicit in that was that we would define or that you would define some some considerations relative yeah and it\u0027s and it\u0027s clear that those considerations do need to be defined good yep great thank you very so next up we have I think the manifest so Brennan if you would stay in queue please go ahead all right next slide so I we had a "
  },
  {
    "startTime": "00:46:04",
    "text": "draft five approved for adoption about four months ago now we incorrectly said submitted version four sorry about that so that was immediately updated to or not immediately shortly after updated to version one which was the correct version version 2 was announced on the list recently and contains some relatively minor changes mostly in terms of text not encoding next slide please so primarily what was added was an interpreter behavior section which defined an abstract machine now that is mostly informational it\u0027s essentially a mechanism to help implementers to understand how to construct the interpreter the other thing that this will do is make it a little bit easier for us to do some testing so we also added templates for constructing manifests and then the text field items which have been missing for a while next slide please so for interpreter behavior it goes through a number of steps first there\u0027s a set up phase so that\u0027s what to do before invoking the interpreter it includes things like clearing out any parameters or making sure that you\u0027re loading the most recent valid manifest the next thing is required checks and that\u0027s things that the interpreter has to do so for example that would include validating signatures that would include making sure that there is a vendor ID and class ID check that\u0027s been done then there are commands that have to appear in the manifest and as I said that could include the vendor ID and class ID some of the other checks that might show up are things like making sure that the right sections of the dependencies have been executed then it goes through to explain how an interpreter should behave and the intent here is that two different interpreters should interpret each manifest in the same way and that gives us the basis for enabling consistent behavior across devices and across implementations which will be really important for interoperability later on and then we define an interpreter abstract machine now this is a relatively lightweight definition it\u0027s just a series of statements of exactly what each different element in the manifest commands should do and the idea here is that we should be able to build very fine-grained test vectors for interpreters and interpreter validation Suites so that\u0027ll make it hopefully a lot easier for people to be confident "
  },
  {
    "startTime": "00:49:06",
    "text": "that their manifest interpreter is behaving according to the spec next please I\u0027ve also gone through and added some sections defining what serialized processing would do as an interpreter so that\u0027s where each component ID is processed in sequence and that\u0027s out of sequence with the with the normal manifest flow the the idea here is that for extremely Ramkin strange devices it\u0027s still possible to handle multiple components and then for large devices where parallel processing is relevant how how you process commands in a parallel processing interpreter and and that would also allow out of order processing of certain commands then I\u0027ve added a section on how dependencies are handled in the interpreter behavior section as well next slide please so then I\u0027ve added a new section on creating manifests and this includes one mention of including source material in the text section of the manifest now this might be interesting for intermediate systems since the author can provide a a document that is in a more conventional form and that would allow intermediate systems to handle it simply but then at the same time that can be pruned with the with the severable section that it like meet with a text separable selection so that that\u0027s never actually delivered to the end node so we\u0027ve also added templates so the idea there is that it gives the authors of tooling some help on exactly what different use cases should look like once they are built into a manifest and then there\u0027s a few use case templates that explain exactly which commands you would need to accomplish different tasks next slide please so I\u0027ve added in some text field definitions those have been noted noticeably missing from previous versions of the draft so there\u0027s a few there\u0027s the the ones you would expect here vendor domain and model info are the inputs to the UUID v function and that which might be useful in some cases then the json source and yamo source are two examples of a an input file that you might use to create your manifest in the first place and then that input file can be included in the text fields as well next please so for next steps we think "
  },
  {
    "startTime": "00:52:07",
    "text": "that the draft is in a pretty good state there\u0027s been a few editorial PRS which most of which have been merged we\u0027re wondering if there\u0027s a better name that we could come up with than just suit manifest because right now if you don\u0027t know what you\u0027re looking for I had you probably won\u0027t find it for technical proposals for Version three we have a few which I\u0027ll get into in a moment so we want to look at the use of run sequence versus try each which was introduced in version 5 of the individual draft some discuss the examples themselves and then I\u0027ve got a couple of proposals for new flow control primitives next please so Brannon you want to generalize to something like software update manifest maybe I mean something like that yeah if you a search engine won\u0027t find yeah exactly so the problem with suit manifest is that you\u0027re not going to find it if you search for it so and to come back to the discussion that we were having previously with Kathleen\u0027s feedback if we leave it as suit manifest then it\u0027s it\u0027s quite clearly not for larger devices right because it says IOT right enough and so maybe you software update manifesting didn\u0027t catch that this is Dave I like Ross\u0027s term this is software update manifest sounds great to me okay he suggested tuxedo manifests but oh I like it so I think software update manifest is a good idea Rob manifest was Russ\u0027s real suggestion as opposed to the tongue-in-cheek one yes so the thing about run sequence was we originally introduced it to allow conditional processing but it was a bit ambiguous on what\u0027s whether it was a soft fail or hard fail and then it didn\u0027t have an else clause which meant that if you went through and tested a number of sequences and they all failed there was no way to catch that case in the manifest itself so as a result of that we introduced we introduced the try each construct now the thing about that was that it\u0027s explicit that it\u0027s soft failure even in its name and it definitely has an else clause so the question is should we deprecate run sequence now there\u0027s the possibility that we could use run sequence for another use case which is specifically serialized out of order processing the idea there is that you have several sequences each of which need to be "
  },
  {
    "startTime": "00:55:08",
    "text": "executed in order internally but the order that you process the sequences in doesn\u0027t matter that seems like a fairly advanced use case so maybe it would be better to just deprecated run sequence and introduce a new extension next please so next the example section is very big now there are a few options that we have here we could prune some information because maybe it they\u0027re a bit too verbose right now for example there was a JSON representation in each of the examples and I\u0027m not sure that we actually need the JSON representation since we also have the Seaboard decode our sorry seaboard debug info version of the information we can move them to an appendix in fact we should move them to append an appendix if we do nothing else and the other option would be to move them to another document with more extensive use case information now my inclination here is to move them to an appendix and prune the for representation I\u0027m not sure that moving them to another document is the best answer but I\u0027m not sure it\u0027s not the right answer yeah so I think reading with you okay the first two options please okay good I\u0027m glad we have some agreement all right next slide then so the map test executes concept I was talking about I the idea here is that we have a fairly common set of patterns so there\u0027s a a for each component things so you I have several components and I want to do the same thing to each of them and then there\u0027s set a variety of component parameters so set the digests for each of the components or set the size for each of the components and then there\u0027s another one which is choose a set of parameters based on some system properties so that would involve essentially running the same sequence multiple times until you find one that matches and then there\u0027s the prioritized parameter list which is a generalization of the prioritized URI list that we\u0027ve discussed previously and that was a request from someone that I think I think that might have actually come from discussions with the teep working group but I\u0027m I\u0027m a little hazy on that one and so the result of that was that I\u0027m I was looking for a catch-all approach since these all seem to share something fairly common so what I\u0027m going to propose is a map test execute structure now the idea here is that you first have a list of component ID parameter set pairs so a set of parameters that gets applied to a particular component ID then after that "
  },
  {
    "startTime": "00:58:08",
    "text": "you have a test that makes sure that that set of parameters or the each set of parameters is valid and aborts if it\u0027s not and then an execute which runs a command sequence that can\u0027t soft fail and wearing an error would cause command termination next please so there\u0027s an encoding there and I should stress that the idea here is that there is exactly one test sequence and exactly one execute sequence it\u0027s not one test sequence per parameter list next slide please so there\u0027s a trade-off here so to make this work properly there has to be a temporary set of parameters that is used before a test happens to prevent side effects in the system so that that does cost some RAM to implement the the benefit though is that it does produce a smaller encoding of repeated patterns now I should just I should make this clear this is not something that\u0027s mandatory for the standard to work at all but it is something that would produce smaller encoding under certain circumstances and that\u0027s specifically where there\u0027s repeated patterns and parameter changes I\u0027ll bring this altameyer just a quick clarifying question what why do you need a set of temporary parameters for both lights so if we go back a slide are two slides make that yeah so you have this this structure where you\u0027ve got a map of parameter sets and then a test that happens after it now you you would anticipate that the parameter set will not be applied to your overall system state until after the test has succeeded but because of the simplicity of the interpreter you would have to apply the parameter set before running the test in order for that test sequence to to have any effect since it\u0027s going to work on the parameters that you\u0027ve just set so the temporaries are there to manage the state of the of those parameter sets until after the test has succeeded at which point the temporaries would become committed does that make sense yeah yeah my confusion was mostly around the terminology I think yeah thanks oh they\u0027re enough yeah it\u0027s the terminology is maybe a bit still of a work in progress so the question that I have is should this be an extension should it be optional or should it be required under certain circumstances now my recommendation is that if we use it at all it should be required under these specific circumstances if you have more than one component it should be required and if "
  },
  {
    "startTime": "01:01:09",
    "text": "you have if you\u0027re using something like a V offset or a B offset based execute in place images then it should be required under other circumstances for so for single image devices with a single offset then it would not be required at all so that\u0027s my recommendation if we go ahead and use it if we don\u0027t then it could be added as an extension later on so I\u0027d like feedback from the from the working group on that specifically on my recommendation to make it required for multi component devices so I was just thinking on the question of should this be an extension or not and you know are there anyone in the room that would implement this if this feature was was provided it\u0027s a compression algorithm effectively for compressing the manifest itself sure I have on the thing that I sent the list I did show what it would do in a variety of circumstances so I don\u0027t know if that\u0027s helpful or not in evaluating it and maybe this is something that people need to look at a bit more before they decide on it yes fair enough okay well in the absence of any commentary on that let\u0027s move on so the other option would be for each component it\u0027s a bit easier to understand but it\u0027s much less flexible than the map test execute construct and it implements only the for each component in a list do something structure rather than all four of those examples that I provided earlier and it expands on the the previous concept of using true as a catch-all so this would allow you to say you know I want to apply a given sequence to all but one of my components whereas the previous encoding didn\u0027t have any construct that would allow you to do that so either map test execute or for each component would allow you to do this this kind of construct but the for each component one certainly is a bit simpler and I think that\u0027s the last one oh no it isn\u0027t there\u0027s a road map okay yes so we have a fairly stable document already but we want to make sure that it is just ready to go before the hackathon in February and we\u0027re planning to have code and tools developed as input for that event so we\u0027ve already got those in development so it\u0027s just a matter of getting them ready for release and we\u0027re hoping to start a working group last call in March I think that\u0027s it hi this "
  },
  {
    "startTime": "01:04:16",
    "text": "is Hank hi Brennan my hack I have one comment on getting things smaller I\u0027m somehow involved in creating a lot of SIBO data items in the last year\u0027s and some of them unfortunately still have text values this cannot always be avoided I saw a bunch of new text values there so hi yes so we are considering in general to give a ad for compression to a data item and as you are concerned with sighs I just wanted to pitch that here I don\u0027t think if it\u0027s useful or should be scrapped after uttering it it\u0027s just the combination of zebra and z4 was also used for the DNS aggregation benchmarking thingy and from the icon guys and there were kind of fond of it because it reduced the amount of data significantly depending on femicides I\u0027m not sure how much entropy is in there it might not matter but this is my first comment just to as a food for thought I\u0027d say before we go too much further can I recommend not l said for the issue though the reason that I I recommend against L said for is that it has a 64 K table size oh you\u0027re a bit painful good argument thank you I would keep that in mind okay second one comment on your comment Hank I mean one of the things that we need to think about though if we\u0027re gonna look at any kind of compression on on these data elements is sort of the the the size reduction versus processing cost some things in the mind to ask everywhere so just I\u0027m okay with that and and they don\u0027t do it is totally fine I\u0027m not married to any of this more of interest to be right now is the second question I have in in second we just had an interesting input from Kathleen Moriarty because the coast wid seaboard data structure that is also an optional item of the suit manifest was proposed as I was proposal from Kathleen to make that a CWT structure and set of a coastward structure the argument here was it would ease adoption of the data structure as the suit manifest basically has the same data structure as the coast with sea bottom I would like to ask this group would you see any obstacles in "
  },
  {
    "startTime": "01:07:18",
    "text": "having a specific suit manifest tag instead of a CWT tag in front of the manifest map and if so is that a realistic threshold or is this just a a felt problem I don\u0027t know I really don\u0027t know because I would think that if you make anything that is a Siebel map a CWT you always inherit all the CWT normative language which also includes for example the inclusion of all the seven claims and these have nothing to do with suit manifests and for example they have nothing to do with a course which software identity check and so my question is would you be pro or con tagging this suit manifest with the CWT tech for the sake of bigger adoption in the field because CWT parsers are everywhere this is the argument III I\u0027m just reflecting the argument and I see the same problem o applicable of this argument here this is why I\u0027m I\u0027m highlighting it personally I am pro suit tag do you think Pro and I would prefer a suit tag to a CWT tag and do you think that the suit tech the Hinderer adoption because it\u0027s not the CWG and they\u0027re less common I don\u0027t think it will because I think that suit is a sufficiently specific use case that if I for example we\u0027re updating or designing a firmware update solution it wouldn\u0027t matter to me whether it was a CWT or not okay so I just wanted to point out that our our Charter is that is to create a suit manifest format not to adapt you know CWT too close with an ii but but still it came up there and is this is this is the exact same symmetric structure I thought I would ask the same question here this is honey so what happens if you just take the CWD but not the mandatory fields in yet would that still be then okay because then the differences may be may be minor because some of the I don\u0027t form the top of my hat I don\u0027t remember what are the mandatory fields to be honest at best before I D those things and I think the issue is non-issue here so putting them in this kind of messing up a semantic messing up so I think we\u0027re gonna have to take this to the list because we\u0027re out of time for this topic so if you could post something to "
  },
  {
    "startTime": "01:10:23",
    "text": "the list so there would be there would be great Brendon any last word before before we wrap up no I think that\u0027s it for me well I guess the only thing was to respond to one other thing that Hank said which was that we\u0027re adding a bunch of text fields and I would note that those text fields take only the size of a digest to populate alright great so now we\u0027re gonna move on to the other work phase I\u0027d like to have Dave Tyler talk about manifest requirements from the teep working group and then we have one other presentation so you have ten minutes okay I\u0027m gonna try to be fast and I hope Brennan stays at the mic here as you may know the teep working group bottom IETF meeting or so ago de pet decided to take a dependency on the suit manifest or the software update manifest if you\u0027re not familiar t p-- provisions code and configuration into a trusted execution environment brennan prison to the soup manifest to the teep working group at an intra meeting and as a result of that the teep working group has gone through to compose what is the requirements and the suit manifest that it may or may not already meet and this is the list of stuff that came up in the t p-- meeting and we wanted to walk through these briefly and get a yep that\u0027s already in there or nope we got to do something to add that okay so I\u0027m going to walk through these briefly and this is really the only slide that I want to walk through unless you have questions but otherwise this is my only slide right and so let me just prefix this by saying Brendan showed a bunch of use case templates and so you might think about should we want a use case template for any of this stuff as an interesting question so let me walk through these things because earlier in this meeting we said hey the suit manifest or soft right Nate manifest could be usable for a larger class things you know updating Linux updating windows or whatever but hey has anybody gone through to validates that would actually work well that\u0027s the exercise that teep just did for a trust execution environment it says would it actually work and this is the list that we came up with in the teep meeting and so I\u0027m gonna walk through each of these and hopefully we can say this is already there or it\u0027s not already there but it could be easily added okay so here\u0027s the four things the first one is to say for any dependency from a particular item that needs to be installed a thing that has a manifest any dependency the ability to list one or more you are eyes and those are not you are eyes where the binary can be downloaded these are binaries for which you can use a protocol to negotiate the security mechanism needed to say get the decryption key or whatever else okay and so could we have a URI associated in dependency that\u0027s not the URI for the binary itself that\u0027s point that\u0027s number one yes I could we don\u0027t currently have "
  },
  {
    "startTime": "01:13:25",
    "text": "that but it\u0027s an easy add thank you because that\u0027s the main thing is each of these yes it\u0027s already there or it\u0027s an easy add or it\u0027s a hard add and so thank you easy add okay Hank did you ever come in on that one not anymore trying to stay in ten trying to stay in ten minutes okay number two the on certain types of te es there is in order to install the binary you have to do a particular thing that\u0027s to create this security domain concept so you need some type of a command or directive of whatever it says create me a security domain if it doesn\u0027t already exist and here\u0027s the ID of that thing there we just need to be a way to express that in the manifest that should be doable already that\u0027s already doable if you need to do explicit create operations that might be an easy add rather than an already doable yeah this is a create if it doesn\u0027t already exist and you know test and create if it doesn\u0027t exist I think we already have that available okay and just the notion that the thing that you\u0027re trying to create as long as there\u0027s some way to say the thing that you\u0027re trying to create is this security domain or some way to designate that\u0027s what it means when going in to this particular place on the device yeah I\u0027d like to talk with you a little bit more offline on that but I think that we already have that and if not it\u0027s an easy add great okay number three and I\u0027m pretty sure this one isn\u0027t already there because Brendon presented this at the inter meeting but since it came up in T we said the ability to update a file that is not a binary executable definitely have right that\u0027s my understanding yeah also this is why I\u0027m here this is bear the coast with extension and the soup man if it\u0027s best cut to kicks and basically if the manifested save is somehow lacking some semantics there I think it all can be added on by the root cause with extension so my personal belief was this is already there and Brendan talked about this danger meeting I just wanted to confirm okay and then the last one is if a device has multiple trusted execution environments say it has you know SGA exit TPM and whatever else attached or whatever then you can indicate which one of those Hardware places is where this binary should be installed to so the this is the exact intent of the component ID as long as each of these can be identified by a component ID that\u0027s the whole point of it the yeah so it\u0027s really is the component ID sufficient to do that and hopefully the answer is yes but we need to actually test that these are all things that if we think the answer is yes we could actually use the hackathon to actually verify that that the component IDs should be what you use there that\u0027s that\u0027s the whole point of it okay great so it looks like we have maybe too easy ads and two things that should already be possible we just have to confirm and it works great in an implementation thank you that\u0027s my report out from the "
  },
  {
    "startTime": "01:16:25",
    "text": "chief working group sounds like we can use it just fine and we should think about we Brendan should think about should we would it make sense to add a use case template for ATP use case or not how do we want absolutely okay all right yeah I\u0027d love to do that all right great that\u0027s the end of my presentation good afternoon everyone my name is saya enjoy and I\u0027m studying in some university and this is my third time participating in ITF then this is my first first time giving a presentation in ITF so my whole body parts are so shivering right now but it\u0027s I wanted to be at honor to stand here and this is my first step of my work so uh any comments or feedback sore it\u0027d be so grateful so today I\u0027d like to discuss about a distributed for suits architecture model and the contents of today slightly traditional suit architecture proposal and next step so let\u0027s see the traditional suit architecture first then let me explain my proposal then my next step so the traditional suit architecture is adopting client-server model so apparently manifests and firmware images are downloaded from firmware servers so the picture on the right side of my slide is exactly from the architecture stretched of suit and there is a server in between author and former consumer but that client-server model which is which has centralized architecture can cause overhead on servers and that overhead occur update failures and also servers can be targeted because of that centralized management and other Authority so it can be targeted by an attacker for using an attack and plus we\u0027d like to define a new issue called author disappearing issue which is literally happens when an other authors disappeared so if authors disappeared for Amir\u0027s consumers who have not yet updated to the latest version cannot catch up so let me illustrate the author disappearing issue more specifically within scenario so maintenance of servers as dependent on the author\u0027s management like for example for short period work for a long period others could be disappeared because of a bankrupt war an attack by an attacker and for that period they cannot manage their servers and servers have begun after that so if servers are unavailable "
  },
  {
    "startTime": "01:19:26",
    "text": "of course that data is are unavailable - so in that case when firmware version 4.0 is uploaded by Ana thought there then status tracker giving notice to a consumer that they have to get updates and after that in case of former version 4 it can be update updated completely but in case of former version 5 if other disappeared after they uploaded consumers cannot download the tuxedo manifests were from our images from the servers because servers have begun so they cannot get the files so to sum up the shortcomings of current state architecture because it\u0027s adopting traditional client-server model it can also with an author disappearing issue and I am suggesting that blockchain can solve the shortcomings because its provides distributed storage for manifests and for mirror image files and it provides irreversibility for manifests and from our image files which means this data is stored in blockchain can are not going to be erased where changed so in case of blockchain supplied on the on the architecture when from original five is a loaded by not there and on the blockchain and even if after authors disappeared like consumers can still download that files because lock chain is still gonna store that data even after the authors disappeared so my proposed architecture is just like this and former server in original architecture it be changed to blockchain and it\u0027s gonna have distributed storage and that is gonna be your irreversible and it\u0027s gonna provide high availability and high reliability and to solve bottleneck problem can be awkward and bulging Network we decided to have registration notes and retrieval notes and registering registration notes are which process the note registrations based on IP so when authors wants to upload their primary work from our images were manifest files on the blockchain registration notes will register the files based on your eyes IP and retrieval notes are going to retrieve retrieve the IP where URI when from your consumers once or download the files so there are public private consortium platforms in blockchain and private because of public public blockchain platforms as the aspects of public "
  },
  {
    "startTime": "01:22:27",
    "text": "launching platform is that everyone is opened to read or write data so there\u0027s a high risk of attack so private or consortium platforms would be better to use in this architecture so for large companies producing IT devices I have a question but I\u0027ll gladly defer to Brendan first yeah this one this page sorry I was actually just gonna wait till the end that that\u0027s okay keep going okay so for large companies producing IOT devices and have it be better to have private blockchain platform because if because they have much power than other small companies so it\u0027d be better to have their own system to manage them and small medium enterprises with higher possibility of other disappearing issues it better to have consortium blockchain platform because even if they have disappeared other disappear issue the nodes connected to that enterprise could be connected to other enterprises that managed together so yeah this are two architectures that can be adopted so the question was yes my question is this is Dave Walter Meyer my questions on this this model so earlier when you were presenting I was wondering you know who\u0027s gonna host this blockchain yeah so for large companies are you envisioning that that would be used in a case where different parties were authoring software for the devices that those large companies are producing or were the large company be the author because if the use case is to to protect against the author disappearing if they\u0027re hosting their own blockchain it\u0027ll probably disappear yeah actually the notes constituting the blockchain it\u0027d be not only authors but it\u0027d be participants who want to be that well notes of the blockchain so there there should be a Ellis management of author but participants normal participants users gonna have that data too because they\u0027re gonna be the users and that\u0027s much clearer in the consortium case where you know a bunch of authors and consumers can band together and and host the you know the necessary nudes that\u0027s that\u0027s the idea there right yeah yeah okay Brendan isn\u0027t me okay so can you go back to slide 5 please just like fine yep okay so I\u0027m I\u0027m a little unclear on what\u0027s happened after the authors disappeared why is the server or the firmware server no longer responding because a the disappear point "
  },
  {
    "startTime": "01:25:30",
    "text": "disappearance point of former server it be a immediate or a few few days after or but the point is that servers should be managed by an author and ok so the idea here is that the server is manufactured by the author or is managed by the author I mean yeah like they had me for the cost of managing them we\u0027re okay right okay understood so suit was designed for the for use with content distribution networks specifically untrusted content distribution networks yes and that was the intent from the very beginning would you say that a blockchain would constitute an untrusted content distribution network ah yes because yeah blockchain works under it based under location works based promise trolls and just like servers get a servers get certificates it data just like just same things happen in blockchain because notes are gonna can\u0027t make get consent notes are gonna give consensus on only data that have authorized wave certificates so then it sounds to me like the existing suit architecture actually already is compatible with us because if we if we say that blockchain is an untrusted content distribution network which we just did then I would say that since suit is designed to work with untrusted content distribution networks we\u0027re already with there we\u0027re good [Music] if there\u0027s a efficiency of explaining the beneficent beneficials of blockchain then I think I have to explain it more specifically by mailing this okay the other question I had is how does an offer handle it and three people at the my client and Brendan\u0027s point is that he thinks that the the blockchain can simply be a URL like any other URL that\u0027s his point yeah you mean yeah the blockchain is gonna store the manifest files and many festivals or store distributed Li and your eyes got containing that many Fitness well yeah yeah still watching can give integrity and irreversibility for their that that that is okay let\u0027s go through the rest of my Klein please keep your comments short because we only have a couple minutes left let\u0027s go ahead Michael Richardson so um I I like this I I like "
  },
  {
    "startTime": "01:28:33",
    "text": "the concept that that the firmware is distributed independently of the authors and there\u0027s a number of groups the the secure home gateway project is here labs actually wanted to have exactly that we wanted to collect all of the firmware from all the devices that we\u0027ve ever seen specifically for the author disappearing case and you didn\u0027t update the latest thing before they went away and so this is really interesting and I think that a little bit I have very pessimistic views of blockchain but the one advantage is that stuff is hard to delete from it and so you can\u0027t take things back because you you know you didn\u0027t want you didn\u0027t mean to release that version that get people whatever so I think that\u0027s a really interesting thing I do have some questions as to what the incentives to verify the blockchain for the various participants are I think in the the shd case we would be quite interested in verifying that the blockchain for free okay maybe others don\u0027t would need an incentive but I think that that\u0027s that\u0027s why my major usually problem with locked chain is why would I care right and so I think in this case there\u0027s some value and and finally I think it\u0027s reasonable that quite a number of entities hospitals for instance will be quite willing to run a the server a couple of devices inside that have external connectivity to talk to the rest of the blockchain but also have internal connectivity to track to a whole bunch of devices which they otherwise don\u0027t let out on the Internet and so I think that\u0027s a useful thing and it\u0027s just a distributed cache that\u0027s cool thank you so we\u0027re officially out of time but we could take like if these are very short comments we\u0027ll take them now I\u0027ll go fast first of all you\u0027re doing a great job for your first IETF present a indeed I wanna I want to I want to agree with what Brendan and Michael said so this kind of things been done before it reminds me of like distributed file systems over blockchain like interplanetary file system stuff like that it\u0027s currently in use for for stuff just like this for maintaining immutable files on a distributed file system using it for suit is cool and there are some use cases where you could actually do that I don\u0027t think that we would need to make any changes to suit to support this I think that you could just take suit and just distribute it over a distributed file system like this and you\u0027re good to go so I don\u0027t think you need to make any changes here but it\u0027s an interesting project this is honest I was wondering about one thing which you may not have addressed yet is if you if there also disappears the other problem is what happens with the keys because the the manifest needs to be verified so that also has the private key and unless he makes that available to someone else you\u0027re not going to get any updates in "
  },
  {
    "startTime": "01:31:34",
    "text": "the future anymore which could be could be a problem I think that should be more disguised myself so I think we\u0027re gonna have to take this offline I\u0027m are you available afterwards to answer any questions so I think what that we\u0027ll have to you know to close the the working group meeting thank you we\u0027ll see you next time in Madrid if you haven\u0027t signed the blue sheets please come up here for the blue sheets now "
  }
]