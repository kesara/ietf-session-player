[
  {
    "startTime": "00:00:36",
    "text": "it's just a little after eleven um i'm andy malus i'm going to be sharing this combined ietf 112 pals mpls and detonate session the session is being recorded as are all of these sessions as i said i'm chairing stuart and tariq are my co-chairs for this session as well although i'll be doing most of the heavy lifting in terms of the slides and and moderating the speaker cue and so on our working group secretary is dave cena crop dave thank you very much dave put together the agenda and dave will be taking the minutes for the session as well and by the way the minutes are available on ether pad slash hedge docs slash code imd whatever they're calling it these days so please if you'd like you can watch along and you can even type in to help out with the minute taking which will be done live in the ether pad slash hedge doc okay with that and go on to the next slide this is the note well uh this is something that you've all seen before and so i don't think we need to go into it in any great detail so the purpose for this meeting uh this"
  },
  {
    "startTime": "00:02:00",
    "text": "is a joint session of pals mpls.net this is the third such meeting that we've had since ietf 111 we're discussing basic architectural issues that have arisen from drastic proposing new applications and uses at the bottom of the nps label stack and that was the actually the initial intent and it's kind of groans from there and if you were in the mpls session um last period then you got to hear lower give a really good summary of uh of how we're coming along and and where things stand right now um so i highly recommend if you weren't in the mpls session previous uh the that you go to the meeting materials and you look in the mpls session and take a look at lowest slides from the last session as well um so a quick overview of the agenda it follows right here i'm actually not going to read it because the next slide is going into the agenda in in much more detail um the open design teamwork has not completed we will be continuing the open design team calls following this ietf meeting okay so next slide so this right here is the meeting agenda i have pre-loaded all the slides into meet echo so for for the speakers out there i will be running all the slides and when you want to go to the next slide just say next slide and i will switch it but i'll be doing all the projecting which is much easier than switching it to each of you individually so i'm doing the chairs intro right now next we'll be having matthew who'll be speaking about requirements for the mpls label stack indicators then we'll have balaz giving us an update on what's happening with debt net and detonates use for the ach uh then kuriti has two talks one after the other uh the first on the mpls first nibble and next on the special purpose"
  },
  {
    "startTime": "00:04:02",
    "text": "label now we have 30 minutes allocated to kuriti's two talks and what i'm going to let greedy do is basically manage that time himself so as long as treaty stays within the the 30 minutes he can feel free to switch from one talk to the next talk um when he feels comfortable to do so uh then we're going to have the network function indicator from john drake we have 20 minutes of open discussion time allocated on the agenda so what we'd like to do is during the talks when presenters are actually presenting their slides if people could just ask questions for clarification only and not start to argue points or make points of your own what we'd like to do is table that kind of discussion for the open discussion period following the presentation of the slides especially because you may find that if you have a question or a comment it may it may be taken care of in a subsequent slide either from the same presenter or from a subsequent presenter so we'd like to ask that you that you keep them your major discussion points for um item seven on the agenda and finally stuart is going to be listening along he's going to be taking notes and then um at the end we're going to give stuart 10 minutes to basically summarize what's been going on what he's heard and what we would like to do going forward so with that uh first of all do we have any questions on on the agenda or any comments that people would like to make right now before we we we get started and i'm not seeing any hands raised so let me move on to my last slide these are the online resources for the meeting so that this is um urls you can click on for the agenda of course to get to directly to etherpad or you of"
  },
  {
    "startTime": "00:06:00",
    "text": "course you can get there via the ihf agenda page as well you'll notice on the left of course in meet echo there's the notes section or or the the discussion that's exactly the same as the jabber room for pals so you can you can want to do the the java discussion either way either directly in meat echo or via your favorite jabber client um we also have an open design team wiki for the implants open design team group so i'd like to appoint you with that and the wiki is always there if you have any questions about what's going on in the design team you'll probably find your answers on the wiki so you can search there first if you have any issues with meet echo the meeting audio or so on send an email to support iatf.org and they will have someone help you and we also have a meet echo tech who's monitoring jabber for this session and for all sessions so with that i'm going to switch to matthew's deck so if you wait one second thank you and matthew take it away thanks andy uh hopefully you can hear me yes so this first presentation is about um the requirements draft um for mpls label stack indicators for ancillary data so this is um something that i've been editing along with stuart who's been been helping thank you and next slide so so this draft specifies the requirements for indicators in the mpls label stack of ancillary data that exists below the label stack and the intention is that this will be a product of the mpls open design team this is version 0 of the draft so this is just a this is the first revision of the draft"
  },
  {
    "startTime": "00:08:03",
    "text": "and the intention is that it's it's going to describe the behavior of the protocol mechanisms and procedures so so just to be clear this is not implementation requirements um and we want to be able to identify the toolkit through these requirements and any new protocol work that's that's required the primary objective of this is to avoid piecemeal solutions um to different emerging applications for these indicators in the mpls label stack and we want to be able to ground the work um very clearly on existing mpls architecture next slide so we kind of started by by trying to define some terminology in in the draft and the two key things really are ancillary data what an ancillary data indicator is so we propose that terminology for ancillary data is data relating to the mpls packet that may be used to affect the forwarding or other processing of the packet and this can be done at either the ler or lsr and it may be implicit so it's implicit in the context of the the lsb or flow i've encoded within the label stack so it's actually explicitly encoded as in stack data in the label stack or it's after the bottom of the label stack but not considered part of the payload um or it's within the payload um and we need an ancillary data indicator this so this is an indicator in the mpls label stack that ancillary data exists in the packet um it could optionally also indicate the specific type of the ancillary data next side so i've i've kind of summarized some of the there's a couple of pages of high level requirements in in the draft as it stands and and i've clustered these"
  },
  {
    "startTime": "00:10:00",
    "text": "together um on the next few slides i've only called out the key ones um from from the draft um a lot of these requirements were kind of gleaned from discussions in the open design team or from some of the uh existing uh proposals for for solutions um so so what we've tried to do is to take those kind of those sort of protocol specific requirements in those and generalize them so the first this first slide on the on the requirements is a set of architectural principles so the first one is that mpls combines extensibility flexibility and efficiency using control plane context combined combined with a very simple data plane to make forwarding decisions about the packet and we want to maintain those principles so any solution must maintain these properties of mpls any solution for um for this also must not restrict the generality of the npls architecture so it must be applicable across multiple different applications multiple different domains um multiple different use cases for mpls it must be able to coexist with and not obsolete existing mpls mechanisms so we're not we're not looking to obsolete the existing mpls data plane and control planes for example and it needs to work in it to some extent uh at least in in an existing network which uses existing control planes and data planes um ancillary data indicators should make use of the existing mpls data plane operations um we may we recognize it may require extensions to the mpls data plane but they mustn't be inconsistent with the mpls architecture that is defined in rfc 3031. next slide"
  },
  {
    "startTime": "00:12:01",
    "text": "so now there's a set of um protocol capability and backwards compatibility requirements so this is really about you know defining the the the requirements for capability advertisements capability negotiation procedures um making sure that um bad things don't happen um for example um adis are not delivered to notes that that cannot process them and then start discarding data for example so so the first one is of these is that neither an adi nor these ancillary data must be delivered to a node that is not capable of processing it um and care needs to be taken in the coexistence of ancillary data and existing post-stack data mechanisms so for example things like the gach the mechanism is required to enable an ler to insert adis or inserting adis to determine if the far-right earldr can accept and process a packet containing a given adi next slide please so then there's uh some sort of high level requirements for for the protocol development development work um so any solution needs to accept the principle that special purpose labels are the mechanism of last resort so the the reason this is in there is that we have a very limited pool of free special purpose labels um we can use and ideally we're trying to avoid either allocating special purpose labels per application which is part of the reason we're doing this work um ideally we'd like to avoid allocating any special purpose labels in for these protocol mechanisms because it's such a limited bulk let's look at other mechanisms first the mechanism to indicate the ancillary"
  },
  {
    "startTime": "00:14:00",
    "text": "data must is present must operate in the context of the top of stack um lse so the idea of this is basically in mpls today typically an sr will look at the top of stack and we make a forwarding decision based on the top of stack so we don't want to break that principle with with this with adis the mechanisms required to enable an adr inserting adis to determine whether or not the path can pass the label stack and process the adi at the location this is inserted so this is really saying um you need to insert if you're targeting an adi for a particular uh downstream lsr you must be sure that they can actually see parse the label stack to a sufficient extent to be able to read that adi um we need to be able to support this for point-to-point support to monitor paths um but we only expect what a specific adi to be supported for one or the other um data plane mechanisms for adis must be independent of the control plane type so it should work you know with ldp rsvp bgp static labels igp advertised labels and so on so basically anywhere where you can use the mpls data plane today a um must be defined for the control planes to be able to determine the the ability of downstream lsrs and odrs to accept and process uh given adi and it should be possible to include indicators for ancillary data for multiple applications in the same label stack but each adi only supports one application next slide okay and we started to write down some security requirements as well um i'm not a security expert but uh i've seen some of this work going on in other working groups related to"
  },
  {
    "startTime": "00:16:00",
    "text": "what you can expose within a an outer or underlay protocol header depend you know based on on what it's carrying um so there's a couple of requirements in in in this draft as it stands um so the first is a solution must be provided to verify the authenticity of ancillary data processed in the lsrs and the design of the adis and the ancillary data must not expose confidential information to the lsrs and this is in there because there may be confidential information in the payload that potentially could be used to generate an adi but obviously you don't want to expose anything that's actually confidential about that information in the underlying to the underlay network next slide thank you so the next steps um to clean up any any duplicate requirements in the draft we'd like to continue to gather requirements from emerging applications um and also there will be some some kind of companion architecture and framework uh document i think that'll exist that will hopefully help to drive some of the requirements and we would really appreciate some review and feedback on the on the list and into the open design team thank you thank you matthew and i see the tweety has his hand up really hear me right yes i can hear now okay there were a couple of comments i had on previous slides one that we should use the special purpose labels as a last resort i think that one um first of all we've been using special purpose labels for other things um but um especially and i know that there's a specific solution but the fai approach essentially lets you use"
  },
  {
    "startTime": "00:18:01",
    "text": "one special purpose label for lots of things so i think that that sort of um persimmony of special purpose labels can perhaps be uh you know pull back a little bit if you say that when you do the special purpose labels you try to do multiple things with a single special purpose label so i think that ability for a special purpose level to carry many more functions and many types of adi if you were doing one adi per spatial purpose label yes i'm totally with you but given a new mechanism where a single special purpose label can be used in a multi-purpose fashion i think that requirement and you know especially that term last resort i think is something that we should rethink so maybe you can soften that by saying if you're trying to do one special purpose label per type of adi then it absolutely should be a last resort but if you can carry multiple types of adi with a single special purpose label then that becomes a valid solution does that make sense yeah i think that's that makes sense because of course what we're trying to do here is to provide a framework or a set of a mechanism that will work for many future future applications for for adis rather so if presumably if we we can have one one special purpose label we're not going to be we're not being replicating multiple different specials for special purpose locals yeah yeah and and could you go back to that slide and the slide before it because i had a comment on the previous slide too but um i have to uh let's see that slide there um no"
  },
  {
    "startTime": "00:20:00",
    "text": "just know about that one um no it's not this one okay uh maybe i'll look over this oh yeah this one this one yeah thank you thank you okay so neither an adi nor ancillary data must be delivered to a node that's not capable of processing it when we did uh elis we said hey you know we will ship this if someone can handle it great they can do a much better job of load balancing if they can't okay there's no harm no foul um and i think we have to be careful that if we classify adis into if you see this you must process it and if you can't process drop the packet um then i would i would go with this particular thing that ideally you don't even deliver it to a node if you know that it can't process it well the next one sorry sorry sorry let me just finish um but if it was like this is an optimization if you can process it and you know do better with the packet go for it if you can't process it ah no big deal and and so that distinction for example let's say that a slice identifier is really important you want that end-to-end guarantee for that slice and so if you send it to a note that doesn't uh understand it um then you know bad things will happen then um you really don't want to send it to that node so i think that that first bullet may have to be softened as well okay tweeting and we have to interrupt because we are getting along in the agenda um so like so i'd like to ask if you have any further comments keep them for the discussion area or take it to the listening list okay okay great thank you"
  },
  {
    "startTime": "00:22:01",
    "text": "your audio is breaking up terribly i'm not sure whether you've done something to it since we first started no um let me see one second okay how is that now no it's still breaking up maybe it's just me but it's still breaking up no it might be my headset it's terrible oh yeah okay i'm gonna switch to my laptop microphone can you hear me now much better much better thank you okay very good i'll just use the laptop in that case okay very good um thanks for letting me know by the way and uh now what we're going to do is we're going to switch to the next top which is going to be greg so let me switch to greg slides thank you and that should do it no thank you nope wrong slides wait one second no no that was right oh wait wait one second so it so it disappeared so wait one second let me make sure that i have the right one [Music] greg mursky okay there we go okay great ah thank you andy um okay so um this is um resulting from our discussions in um that on um oem4.net over the mpls data plane next slide please um so there um deterministic networking data plane um uh we are working with the uh mpls and"
  },
  {
    "startTime": "00:24:03",
    "text": "and for mpls uh the two sub layers been identified it's a deadnet a service sub layer and a forwarding sub layer so um for their um procedures we are using their pseudo-wire architecture and um for their detonate service sub layer uh need to use uh the sequence number and that net flow identified using the label and their sequence number in a control world so that's why we identified as a uh deadman control word and the use of that control word in um is mandatory okay um so uh on this uh figures you can see that effectively what we have is that that net is uh using a multi-segment uh pseudo-wire approach next slide please so uh in the figure would just um remind how their encapsulation looks and we have a label stack then s label that identifies uh their detonate flow and this is the bottom of the stack label and that immediately follows uh uh the deadnet control world so that's uh takes care of their um data traffic next slide please"
  },
  {
    "startTime": "00:26:04",
    "text": "so in control word the first nebo is all zero and then it full uh using their sequence number and the sequence number is a critical for uh that net because uh in the service layer uh nodes uh dedicated nodes uh can be placed with a uh packet replication duplicate elimination and order preservation functions sub-functions and for duplicate elimination and order preservation the sequence number is critical essential so that's uh the payload must have the thickness number and the sequence number space is circular so and monatomically increasing okay next slide please so here you see the service layer uh being presented um serviceabler.net uh where we have um placed uh replication uh point duplicate elimination and ordering uh so uh the pre-off as an acronym for all these mechanics that used in a [Music] service sub layer is effectively a pair packet proactive protection so it might look uh similar to uh 1.1 protection but in the classical one plus one protection uh their destination selects uh one uh source"
  },
  {
    "startTime": "00:28:00",
    "text": "uh to receive the packets whereas uh with the pre-off what happens is that uh packets being replicated at replication by replication function and then they can they will uh travel on this joint paths at somewhere there will be an order preservation and elimination functions so the elimination function is just to eliminate unnecessary copies so thus uh in the definite domain uh we can achieve our we can decrease their packet loss next slide please so the oem for the service sub layer is is important and what we have considered we consider it to use ach and use reserved field as a sequence number so that um oem packets uh can be processed uh in a way similar to the data packets and by the pre-op replication elimination and other preservation functions in the main but then when we started looking and we found is that we need some more functionality from their deathnet ach next slide please and what we are considering now is that again so uh what is being presented uh today is only individual draft it's not"
  },
  {
    "startTime": "00:30:00",
    "text": "yet been discussed by that working group because uh our meeting i believe on wednesday so uh you can see here is that um new format for that net ach so the first nibble is still is one uh but version is uh one as well so we are taking the next uh version number and uh um it has a sequence number and a channel type and then the second 32-bit uh word uh is used for note id and some um other fields that we still thinking of how they interpret it but we just um put the level uh flags and the session identifier uh for placement so but they might be considered for now as reserved as well but in general so what we're proposing is we're proposing to change um to take a next step uh from um ach as defined for the pseudo-wire and that was uh previously up to now defined in that networking group document as one 32-bit word and uh using the version versioning extender applicability and use of deadnet ach and i'll probably pause here to see if anybody wants to have a discussion about it yes creating short is that a good enough sequence number um"
  },
  {
    "startTime": "00:32:01",
    "text": "yes uh that is might be not good enough and that's very good question so uh what might happen and again that we'll discuss more in more details in that note group is that uh the sequence number will be moved uh to their second word and that space can be reused for some other uh elements that we think that are needed in that net service sub layer because the reason why we introduced this uh new format and it was because of our analysis of uh service sabler and deathmatch and bill watts so i'm happy to hear that because one of the things that i was thinking is that um that space of the first nibble is really short and you know that first nibble came from a hack and i'll talk about it in my section but i'm thinking that we need an extension field that says here are subtypes so if you say 0 0 1 is definite oem then you could say i have uh subtypes of the deadnet om and so extend the space that way as opposed to try to live within that that really small space of just 16. so i think there are ways that we need to think about this so that we can really uh use that uh mfn the first level more effectively yes but it worked out yeah actually what we are taking advantage here and that's might be a good uh recommendation for uh more generic mechanisms is the versioning yeah the versioning is one aspect of it but typically versioning means you know i have i have some function that i have an"
  },
  {
    "startTime": "00:34:00",
    "text": "updated version of the same function but if i have a different function that still falls under oam for that net then you know so i i think it's useful to to step back and think how you want to do this so you can have version you can have multiple sort of sub functions um it's an offline discussion but i think it's one worth having okay thank you all right and uh we'll probably have more discussions so welcome to that net uh meeting um this week and uh i think that that will be a last slide or less substantive slide okay thank you very much our next speaker is going to be karini so let me load his slides and karini you're doing the first nibble first there we go tweety thank you can you hear me yep we can hear you fine okay okay okay i just got a message from me echo that my audio was not visible or audible okay so yeah i want to talk about the first nibble and and several issues that we have with it um so next slide please so the mpls first nibble is the high order uh four bit field of the first octet after the last label in the label stack so you pass the label stack you say oh here's the label with the end of stack bit or the bottom stack that's set okay the first thing that i see after that take the first octet take the high order four bits that's the first nibble and it became special for a few reasons um first thing that you know people started using it for um"
  },
  {
    "startTime": "00:36:00",
    "text": "is for load balance we'll get we'll get into that so the the point is that that first nibble uh became important and so what uh and and there have been a few rfcs that have dealt with it indirectly so what we decided to do is to step back look at what it's being used for look at how it should be used and then based on that make some recommendations and so we want to come up with a requirement and a recommendation on the use of uh the first nibble and and you know stuff around that we want to registry for first nibble values and we want to register for postdoc data so sort of the first nibble also is used for uh to tell you what is going on in the packet so next slide please so um just to make sure we're all on the same page here you see um ahead of you know on top of the label one that you see would be a layer 2 header saying this is an mpls packet then you see a bunch of labels you see the last label with the s end of stack which set to one the first nibble after that is what we're calling the mfn or mpls first level next slide so there are two cases in one case you actually have the payload the actual packet being carried over mpls directly after the last label this is how a lot of things started when you were doing mpls for traffic entering took an ipv4 packet and just stuck it in there when you did mpls for vpns ipvpns which came first you again do the same thing so you had a bunch of labels the last label might just be a traffic engineering label it might be a vpn label"
  },
  {
    "startTime": "00:38:01",
    "text": "and then you had a v4 packet or v6 packet so that's the case on the left the case on the right essentially says oh wait i want to put some extra metadata before i actually start the packet so the case from the left you also could have had a layer 2 packet you could have had an ethernet packet saying i want to do a pseudo wire or i want to do vpls i'm going to give you a bunch of labels the last label is my vpn label my vps label my pseudo wire label and i've got a layer 2 packet in some cases we said no we want to put a header in front of those two so typically a control word and and so then we said okay if you're going to put a control word that will help with a few things for example let's not use the first novel being 4 so that someone who's looking at this won't mistake this packet for a an ipv4 packet and try to do some fancy load balancing on it so then that's where we started putting a post stack header which is what i'm going to call it uh so control word om word uh or words uh a bunch of um sort of extra metadata before the actual payload starts so those are the two cases next slide please so why did we why are we talking about the mfn why were people using the mfn well the first reason that they were using it is as a heuristic can i tell when the packet when the payload is actually an ip packet because if i can see an ip packet i can extract fields from it and do better load balancing otherwise i load balance on the transport label or maybe the transport label plus a vpn label"
  },
  {
    "startTime": "00:40:00",
    "text": "and i get some load balancing but not very good load balancing so that was the first heuristic that people were using and then the second was kind of sort of let's use it also for the type of post-stack data that's carried if you're so the the heuristic number one uh works for the case on the left uh in the previous slide curious or the the indication of the type of postdoc data works for the case on the right where you put values that are different and then say oh this is going to tell me something useful about what kind of data i have so um essentially uh that post stack data started off being control words initially the survive control word then a death net control word but now it can also be a beer header or a gach or something so you know that they suppose stack data in two ways one is a signal in the control plane hey i'm doing that net uh as greg just said that net must have a control word so look for it or hey i'm doing survivors and i have this option to carry and control word i'm using it so expect a control word for beer and for jch it's actually heralded by a label so there's a gal label excuse me or there's a beer label that says um what comes next is a postdoc data which is of type beer or of type gach so so there's a combination of i there's stuff in the control plane that tells you that this is happening and then there's stuff in the data plane that tells you that this is happening next slide please things are broken and the biggest problem is that you can have any kind in"
  },
  {
    "startTime": "00:42:00",
    "text": "principle you can have any kind of layer two packet uh following the you know what i said there are two cases on the left you can have an ipv4 ipv6 packet or you can have any kind of layer two packet and if it's a layer two packet you're gonna do potentially bad things because you'll interpret uh in the cases where the first nibble is a four or a six we'll interpret the packet as an ip packet and try to load balance on fields that are not meant for lower dancing so um the theoristic can fail badly now given that you know we said we want things to continue working as they are you know we have this big caveat but that should continue to work but at the same time to the extent that we can prevent um confusion of an ipv4 or ip version number with the mfn we should do that and we have new and better ways of load balancing packets so we should start using those as well next slide so these are the echoing what uh matthew said up front we want to allow current implementations to continue working even though there may be some heuristics that are less than ideal um i think we should point out that there are these issues but hey if you have an implementation today that looks for the mfn and tries to load balance on it keep going but we should lay the groundwork for better more efficient implementations and lay the groundwork for uh easier identification of the psd when there is psd and you know to the extent that we can make it self-contained so much the better next next slide"
  },
  {
    "startTime": "00:44:00",
    "text": "so in the case of an ethernet payload the mfn if it is you know carried as a naked layer two um over uh mpls then uh that that first nibble is part of the destination address the part of the oui it can take any value and so there are rfc that says you really should have a control word but i think that's weak and we should actually go go on to a must so we'll talk about that in a second the current psd types uh you know when we say here's a control what we're staying away from four and six but even they were saying okay we'll use five for beer and we'll use one for oam but you know what if there's a new version for ip that is like seven or maybe they want to reuse ip version one what do we do it's like let's not even go there um let us stop confusing the ip version number and the mfn and so again for backward compatibility if you see a 406 and you want to try to recognize that as an ip packet and do load balancing go for it you know understand the problems that you can have but if you see any other value even if there's a new ip version one please do not uh use uh one as i can go look for ippacket or ip headers or do do not use seven for that so let's decouple the mfn and the ip version numbers next slide okay so um we we want to be careful also not to try to back door an mpls protocol field in here so the mfn kind of sort of was used as a protocol field at least to recognize ipv4 ipv6"
  },
  {
    "startTime": "00:46:01",
    "text": "yeah okay we will leave that in for backward compatibility but no more what we will use the mfn for is uh to identify the type of poststack data so zero means uh a control word one means om five means beer you know and and so on this is why we need a registry so that's what we're gonna do right the other thing we're going to do is to say for all non-ipv4 non-ipv6 payloads they must be a psd there must be this kind of header that says um i have a control word it might only be uh i'm going to put something non-zero here non-496 here but other than that i'm not going to do anything else and so if you do that then you're not going to have any confusion of uh non-ipv4 packets being treated as ipv4 and load balancing happen there so there's a there's a recommendation for this but we're trying to make this a this requirement going forward so existing implementations yeah they'll do what they do uh and they understand the the sort of what trouble they can get into there is a recommendation that's a more like a requirement there's a recommendation that uh for load balancing purposes don't even look for those things it's actually a lot more efficient to use a fat solar wire or an entropy label uh and and you actually get much better load balancing you do less work and you get better load balancing by by doing that so so the recommendation is to use uh faster wire or entropy labels for load balancing and it worked for more than just ipv4 and the mandate or the requirement is going"
  },
  {
    "startTime": "00:48:00",
    "text": "forward implementations uh can can only have naked payload of ipv4 and ipv6 any new versions of ip or any other layer 2 or layer 1 packet that's carried here must have a post stack data um the other thing that would be nice i think is to keep the recognition passing of the psg completely in the data plane so again we'd like to create an mfn registry today we have an overlap between zero would which could be a control word for pseudovirus or for that net you have to resolve that in the control plane but to the extent that we can if you say here are unique registries for different types of postdoc data then i think we whoever is doing um whoever's or whoever's trying to handle this in the data plane has a better time has an easier time next slide so like i said existing implementations can continue to be used with the caveats that we've mentioned uh pseudowire and that net control words will work as is no changes are to be made to them or if there are changes made like um greg was suggesting you know it is in the context of stuff that they're working on the the one that i think is much more difficult is the gal ach post-stack data continues as is the br1 probably will continue as is and beyond that that particular mfn will be used for beer any new ideas for psd should have a new mfn code point so you know this idea of reusing existing"
  },
  {
    "startTime": "00:50:01",
    "text": "code points and and saying i'll signal it in the control plane to the extent that we already have it we keep keep it but if we can say going forward we won't use it then i think people who write microcode will be happier on the other hand as we were discussing with greg we have a very small space for the mfn so it would be nice to say new code points for mfn are followed by a sub function registry as well and that way we can extend the msn but that that problem does have to be tackled so but but we need to for the starting point we need an mfn registry and and corresponding chord points next slide so here is sort of a proposal this is not in the draft the draft is something that we came up with i should have mentioned this um there are several of us who uh talk together about uh um you know that we need a registry for mfn and and what all should go into it um but um in the offline discussions um you know and and these thoughts that the mfn space is really small um we could have something like you know you have an mfn that's four bits existing elephants yeah they are what they are but new ammo fans you might introduce a subtype um what greg was talking about is the version number um so so something that says um i can extend the mfn space a little bit so i don't have to burn a new top-level mfn bit for every new type of psd you also have a total length of psd field and and after that you can do what you want and that allows people that say i don't know too much about this or i don't care too much about this i want to know where the real packet starts and the total length of the psu will say if"
  },
  {
    "startTime": "00:52:01",
    "text": "you don't want to process the psd just go on to the end and there's your customer packet and forward that as you need to so i this is like i said just a proposal but it captures two important things that we need to tackle one is how do we make the mfn space bigger and two is how do i skip the psd altogether and get to the customer packet and beyond that i think the psd should be self self defining questions i'm in line um okay i actually had a quick question just based on your last slide myself um i i assume that that will be in the next revision of the draft yes yes okay okay very good um let's move on to um to hyu and and then loa uh my question is that um i think the use of this first label is to a wide ambiguity due to the lack of any effective indicators in the label stack but from now if we are designing this uh ancillary data we need uh to define a uh indicator in the label stack if we have that in place then it seems says why we should care about this first neighbor anymore because we know for sure what what follows a label stack so that's my question so um that i actually i try to tackle that in my next presentation but but i i agree with you i think there's this place for things in stack and there's place for things post-stack and i i think we have both levels in our hands and i think what we should come up with is the ideal or you know from what we see now the best possible view going forward so i'm with you"
  },
  {
    "startTime": "00:54:06",
    "text": "uh may i or um actually lo what was next even though we didn't put his hand up he did turn on his microphone oh okay let's see yeah so okay one thing i'm kind of supporting how you on uh that we actually know from the flag field what actually follows but even if we didn't do that why couldn't we just increase the sub tape type to eight bits it would work just fine sure yeah yeah yeah so so this like i said this is currently just a proposal um so what you do is you take you take one mfn field or yeah value value only one and then you have eight bits to actually diversify it yes yes so the pseudo-wire control word has those four bits for that sort of purpose it was actually intended for version fields but they are qualifier bits that are available and were always in the design right and and so i think where we are kind of going is maybe every mfn would have such a qualifier and you know everyone going forward might have eight bits but the ones that have already defined it you know in greg's thing he had four bits for a version number uh as steward just mentioned we have four bits for a qualifier i think going forward we might say every new mfn would have eight bits set aside"
  },
  {
    "startTime": "00:56:01",
    "text": "to expand the functionality so we group more things under the one top level four bit field and then say okay here's how you know which one of those it is in the second eight bit field uh so i you know i i think we're all saying the same thing the one thing we didn't talk about is the total length of psd which i don't think people would disagree with from the point of view of being able to skip the psd and knowing where the end of the psd field is so i know where the packet starts the actual payload yeah i i actually think creatine will be much much easier for people to discuss once there's a concrete proposal on paper that they can all look at and comment on yeah no i agree i will bring that out as soon as like as soon as this is over okay and the whim is next yeah so my my questions relate to the same thing as far as i understand the psd can i it's it's ancillary data but potentially could have multiple contexts uh if i'm understanding it correct and as a result don't yeah and then to indicate which piece is what so very good question um i would like the psd to be self-describing you know in the in stack data you have very limited space you want to try to fit everything into 32-bit chunks and it's not even full-third ruby chunks so what you end up with is you don't use tlb structures there you use the indicator flag structure there in the psd after this first sort of header that says this my mfn type this is my subtype this is the total length then you sort of say okay now you have a tlb structure it could be a tlv it could be next header it could be whatever structure you want but it's self-describing and so you're able to parse it you're"
  },
  {
    "startTime": "00:58:02",
    "text": "able to do multiple functions you know some of them might have a lot of data the in stack in situ oam could go in there a bunch of other things could go in there and so the the psd you know it's a free-for-all thing and so you have the tlv structure or tlv type structure and then of course you have your payload so i i you know i'm leaving it open to that i think we're in agreement yeah no no i think yeah so but i i i'm trying to make a point that we need somehow an an event of some sort uh to indicate also potentially for the order right i mean or because depending on the use case it might matter which part of the psd comes before the other i don't know i mean okay you have a very good point so so this is one of the things that the ipv6 guys also struggle with so the idea is that there is one mfn right that's the first nibble and it says there's psd and that and that's why there's a total length of psd that total length of psd can be broken up into let's say tlv structures i'm not wedded to tlb but let's just say because i like to work in something concrete so i can have multiple tlvs there so i can have something that says this is in situ data the length is you know 30 bytes and now here's the value and then there's something else that says this is i don't know some other psp data the length is 16 bytes and here's the value so i i have all of those now organizing those and putting them in the right order is really important because you're processing these in the data plane and if you run out of time uh you know if you process them sequentially then you'd like the important ones up front that is a second order issue that i don't want to get into but you don't have a new mfn for each of these i don't think that we need to burn"
  },
  {
    "startTime": "01:00:01",
    "text": "a new mfn we have a one top level header that says here's the type of mfn so let's say mfn value nine is this is the new miad generally extensible mfn post track data here's the subtype here's the length and then you have a bunch of new things and to your point when you totally need to put them in some order but that is a second-order question yeah so katie my point is just i there is a few considerations we have to take into account right we don't have to solve it right now but i think it's good to list them somehow and maybe some of them are not important some of them are but i think it's good to list the things we should consider for this and then see what would be the best solution for it somehow right yeah yeah okay yeah yeah okay i've closed the queue because we're starting to eat into the time um for um for greedy's next talk so for greg and stuart if it's really really short uh we can do it now but otherwise i'd like to ask you to wait for the discussion period so uh jeff another question um i get very good feeling that uh it might look uh similar to ipv6 extension headers and that's something that uh we can discuss in um on the list and actually we have advantage because they suffered their pains and got their cuts so we can learn from their experience and see how we can apply it to what what's a task we have at hand thanks yep agreed so just quickly something the working group needs to be under no illusion about is that there will be uh random raw ethernet packets floating around the networks for the foreseeable"
  },
  {
    "startTime": "01:02:02",
    "text": "future there's no way of forbidding them and in any network where that they happen then you can make no assumptions about that first nibble so as a way of organizing stuff this is fine within the scope of the work we're doing but i am really worried if anyone makes a a serious forwarding decision based on one of those on the meaning of one of of kuriti's um uh mf um um without uh you know many other qualifying things that tell them that this is not a regular ethernet packet they happen to pick up i agree i i think the fact that we allowed um you know in the way in the beginning we said there's not going to be a protocol field in mpls and you know you could carry naked packets after the label stack kind of bind our hands a little bit but we need to move forward but i don't see how we can move forward um and abide by the other important principle that we've always had in mpls which is that we don't obsolete any existing lsps right let's do it we really do need to move yeah yeah yeah yeah we'll discuss it at a later time sure okay so thanks uh andy for the next slides um so here this is about the forwarding actions indicators um so next slide wait one second yeah so there was discussions both in and outside the open dt the open design team regarding the isd and the psd and so i thought it would be a good place to bring this together so some of the questions were"
  },
  {
    "startTime": "01:04:00",
    "text": "you know when should some indicators or data be in the isd versus the psd and we've had a little bit of talk about this but maybe not enough so i think we need to do more of that the other is what should be said about the psd in the isc so in the in-stack data what do i say about the post-stack data and one big consideration there is the in-stack data is much closer to hand typically than the post-track data which you have to pass the entire start to get to um the third one is what about extensions i mean you know initial the very first version had seven or eight um indicator fields uh sort of present there was a field that said here's how you extend it but we haven't gone into details about that so what if we need more indicators in the same uh fai block and then another discussion was around what about standard indicators that someone doesn't understand and then what about non-standard indicators sort of user defined or provider defined indicators i think that would be a very nice thing to add but how would you handle it so sort of trying to bring all this together if you go to the next slide let's start with the philosophy of the isd the isd is data that you want to process with some urgency you're willing to live in a more constrained environment you're trying to fit within ideally within a single label including the pcttl fields so you want to encode this very compactly compactly you want to process it pretty quickly and you must respect the bottom of trackpad because you are still looking at what theoretically seems to be a label so the instax data you want to be very careful with"
  },
  {
    "startTime": "01:06:00",
    "text": "passimonious with and you want to process it quickly next slide the post stack data you have you know your label stack is over i mean you've you've hit the bottom of stack label and now you can you can be a lot freer with things so it does not have to be ultra compact you still don't want to carry you know gigabytes of data in there but uh it doesn't have to sort of fit into i look like a label even though i have all this other information you don't have to respect the bottom stack but so it's a lot uh easier to work with um ideally at least i think it should be self-describing so a tlb type approach and you know we can have the discussion you know is it a next header is it a tlb is it something else but that is reasonable we we now have more space to work with so given this we don't have to put too much information in the isd in the in stack data about what's coming after the postdac data and if you put a lot of information there it can also lead to confusion if the in-stack data says oh and by the way expect in-situ om and i'm just picking that as the first thing that comes to mind uh in the i in the psd and the ps3 doesn't have it you know that what am i supposed to do or if it says there isn't any uh institute data and then suddenly when you're passing it you find it so it's probably better not to repeat those things and lead to confusion next next slide so one suggestion is the indicators should only say who should look at the psd it's an optimization just because the psd is so far away or potentially far away and so uh the worst case is that every hop looks at the plc which means you scan the entire label stack you come to the bottom label and say okay now i have the psd i'm going to scan it and"
  },
  {
    "startTime": "01:08:01",
    "text": "see if there's something interesting but ideally you know you could optimize that away by saying i'm going to use two bits zero zero meaning you could go look at the psd but you don't have to zero one saying ah if you if you want to uh you can but if you're the egress you must and in a sense that's kind of a overkill because the egress is going to see it anyway um if there's one zero uh every hop should look at the psd uh and then if there's one one every hub must look at the psd and this goes back to what matthew was saying in in terms of these are the things that i don't want to send to a node that doesn't know how to process it the other ones are you know well maybe zero one about the egress but that's only the egress if you think about the per you know the hop by hop thing and if you have a must if you don't understand this you're gonna drop the packet then don't even route it over knows that potentially won't understand it so this is suggestion that you have these two bits in the isd that tell you who should or may you know may should or must look at the psd but it doesn't tell you anything more than that um because you know it's it's you're going to look at the psd when the time comes if you have cycles to do it etc uh you really want to process the ist because that's what's much more immediate next slide um so there's this whole other thing that we're talking about handling extensions and so those in the first uh version the zero zero version of the draft it said there could be extensions but didn't talk about it in version one uh we started trying to put more into it so the idea was to put an ebit that says if if the e beat is"
  },
  {
    "startTime": "01:10:00",
    "text": "zero that means you're done and ebit is one that means there's more bits and the next one will also have an e bit and so on so you can keep processing indicator flags until the e bit goes back to zero so it's sort of uh it's an inverse of how the bottom of stack bit works and so i decided what if we flip it and then we can reuse this bit for other things so because we have this question of here's a standard data field but you know maybe we have 20 data fields but a particular implementation only understands three of them how would it know when the data is over and the label stack continues as usual um so so um i decided let's invert this and use this bit for more than just extensions so next slide please and and this was a result of lots of different discussions both in the working group and outside the working group so the current thing is that you have uh this what well it's not the current if you if you flip the in ebit you have something that says this is the bottom of indicators so if you flip the current meaning of the ebit as long as it's zero that you have more and when it says one you're done so if you have a very very simple fai label uh with just you know three or four um indicator flags the very first one would have the one set but if you have more you put zero and then you have more bits and then you know if you have even more then you put zero again and then finally you say one you say okay i'm done with the indicator section the flag section so you can see on the on the right that's the flag section so the next thing you have is the standard data corresponding to those flags i have this data so there might be you know entropy label there might be a slice identifier they might be you know whatever other standard data we have but again you might have a problem that someone says i don't i mean where it starts is pretty simple it's where"
  },
  {
    "startTime": "01:12:00",
    "text": "the indicators end where it ends well i don't know because i know only how to process these two bits and so i get 16 bits or 32 bits or whatever and then after that if there's more i have no clue so what do i do and we don't have a tlv structure so how do i manage that so um you can do that essentially by taking this idea further so next slide please yeah i'm just saying that again what if there are 50 standards fields and i only understand five of them how how do i deal with that what if there is user-defined data how does an implementation know where it starts and where it ends so let's reuse this off kind of thing and for all these purposes so the next slide please so this is what it would look like so in parallel you can see the end of stack bits which are going to be all zero there will be some labels in the front some labels at the bottom uh and then the last label which has the end of stack or bottom of stack bit set and then you have this thing that is the bottom of section bit and so in this one fai block you have zero zero zero one that says okay these are indicators then the meaning flips and at zero zero zero one that's a standard data so standard data starts when the indicators end till the standard data bottom of section bit goes back to one and then you have zero zero zero and then uh one that says this is user defined data so if you reuse that bit then what you basically have is 30 bits per label that you can play with for anything and these these uh the end of stack bit is completely has to be preserved yeah just so that your label stack the entire label stack is"
  },
  {
    "startTime": "01:14:00",
    "text": "sacrosanct and then you have this end of section bits that tell you i've got the indicator section i've got a standard data section i've got user-defined data again this is just a proposal and i know andy will say write it down so that people can you know throw things at it but and i totally agree but i wanted to present it here so that people have an idea what's coming up next slide please so so here's just a quick uh view of uh someone who is looking at this the cross hatches that are you know top right to bottom left in orange are things you understand the cross hatches that are top left to bottom right in red are things you don't understand so if you look at the first fai label it has these 11 bits that you should be trying to work with and you understand some of them but not all of them there's some extensions so you say fine i'm going to process what i understand i'm just going to skip the rest i know that when i get to that b bit equals 1 then the flags are over and then i start processing the standard data i only understand a little bit of it but i know if i keep processing until the b bit is one again standard data is over i do understand a little bit of the policy stuff or the user-defined stuff again i know when that is over and so i have come to the end of the fa approach so by reusing that one bit i can define break up my fai block into the flag section the standard data section and the user-defined data section and again this is just an illustration of how this proposal would work so questions comments thank you very much i actually have i actually have the queue closed and the reason is that we have that we have to move on to john's talk but if people have any questions or"
  },
  {
    "startTime": "01:16:01",
    "text": "comments uh please wait and write it down and then you can ask it after john's talk so with that john if you take the mic and i will put up your slides john are you there if um adrian told me that john was having issues so if john if you're still having issues then adrian can you speak i can so i think i will uh all right then um wait sean what is his hand up well john has his hand up john can you put your audio on uh okay there we go i'm sorry i was logged out i was in the middle of logging back in again okay john then you can take it over okay uh next slide okay uh first thing is this this work on network functions is derived from kurdish drafts uh where you basically have a special purpose label and then a bunch of bit flags that identify forwarding actions uh and what adrian and i are trying to do is basically just generalize it and flush it out and so we are using the term network functions rather than forwarding actions uh we have two special purpose labels one is hop by hop and one is end to end and the p nodes only look at the uh hop i hop special purpose levels this was a suggestion from both adrian and stewart and basically it allows both types of network functions to evolve independently without any interference and both are completely extensible and we are not changing non-label fields in"
  },
  {
    "startTime": "01:18:00",
    "text": "the spls uh and then what's going to happen is when you define a network function you're going to use it's going to be defined in an rfc of some sort we defined whether it's hot by hop or end to end uh what bit it's going to use in the network function flags which i'll describe below and whether it has ancillary data if it does have ancillary data what is the ancillary data is it in stack or after stack so that you basically will know you don't need any indicators you will know uh all of the characteristics of the ancillary data just from its definition next slide please um so we have this network function label stock black which is an spl uh network function flags and in stack ancillary data um the spls we already talked about uh the network function flags is basically uh it's what we're gonna it's gonna be basically a registry and whenever we define a new network function we're going to define a new bit which identifies that network function it's in a set of one or more label stack entries and we have a continue bit which indicates that there's another label stack entry with network function flags in it then the ancillary data is 31 bits of data ancillary data for each network function whose network function flag is set and the ancillary data is in the same order as the network function flags and we had said that it was diluted by another spl or label stack entry with bottom and stack or ancillary data with bottom of stack there's actually a couple changes that have been made in conversations with adrian and stewart over the last couple of days one is that there's no reason that the we couldn't have uh two or more label stock entries for a"
  },
  {
    "startTime": "01:20:01",
    "text": "given network function and the other thing is that we probably want to add the continuation bit for the ancillary data so that we will know precisely even though that doesn't understand the ancillary data we'll actually know when the label stock black label stack block ends uh anyway at the bottom there's just a picture showing what it looks like uh next stack please uh and the way it's gonna work is that the network function flags are in order and a given node will understand the network function flags up to a given bit position it doesn't need to support them but it understands what they are and what their ancillary data looks like and so this allows the node that doesn't support a given function to just skip over the ancillary data for that function and then the label stock label stack block is terminated for all the function flags greater than n basically the labels the label stack block goes opaque when a given p router doesn't understand any additional network functions and so what that uh means is there will be basically a given set of network function file a set m whose network function flags are set and understood by that node and so that basically says the size of m is less than or equal to n and then within m there's going to be three sets there's a set x which is network function flags with no without ancillary data network function flags with in stack ancillary data and um network function flags with after stack data and so basically you will have a set of network function flags that are set and then you will have the in stack ancillary data for those network functions in the stack in order and then the after"
  },
  {
    "startTime": "01:22:02",
    "text": "stack data is in the same order uh as the network function flags that were set in the packet and obviously if the if any one of these sets is empty there is no ancillary date of that type and that's it okay kuidi you have a question a couple of comments one is if you have a special purpose label that says this is hop by hop and another that says this is any two i mean uh and uh only to be processed by the end nodes um how am i supposed to know that if i haven't reached that position in the in the label stack i mean i'm sorry please repeat the question one of our dogs is working okay um so let's say that i have various labels um you know maybe they're segment writing labels so there's like five labels and then there's an spl down there that says i have data that should be processed by every hop or you have a similar situation where you have five labels on top but i have data that is you know really interesting end to end i have to come down i mean you know i can do my forwarding just by looking at the top label but i'm going to have to come down to look through the stack and say is this interesting for me now or is this interesting for me uh only if i was an endnote is that how you're seeing this that i have to parse the label stack anyway looking for the for these spls and say oh this is the spl that is applicable to me as a p router or not this one what we said was the uh"
  },
  {
    "startTime": "01:24:01",
    "text": "the hop by hop spl always precedes the end to end spl okay but but you have to go through the label stack looking for the hop by hop yeah spl that's the same as your proposal yeah yeah yeah yeah no i i'm i'm just trying to understand so so um yeah i mean even for the entropy label back in the day i mean you you'd have to go through the label stack looking for the entropy label indicator okay so like i said you know this this is basically an attempt to generalize and fill in the blanks with your proposal yes um i'm i'm trying to see what is different and there are a couple of things that are different one is in my proposal um i don't want anything that is end-to-end to be you know try to fit itself in this label stack format and and keep the label end of you know the end of whatever i said was what we said was if it's related to forwarding it should probably go in the stack if it's not related to forwarding it probably shouldn't go in the stack but we make that decision we make that decision when we define the network function well so the first thing is this whole thing about network function um i object to that simply because if it's related to forwarding i don't want people to think oh i can put in some tutoring computable function in here i just want an action that i do right now and yeah this is more like maybe marketing or something but by saying function you're talking about things that could be heavyweight by saying action it's like something i do now and move on but network actions is good yeah"
  },
  {
    "startTime": "01:26:00",
    "text": "but but the the higher order of it is the the way that i had to find it is that these following actions that are going to be encoded in the label stack and then there's going to be a bunch of other things that you want to do that you'll encode in the post stack data and and so if it is not hop by hop put in the post stack data and if you're putting in the post fact data then you end up with all i'm going to tell you is whether you need to look at the post stack data or not and so i can put things that are hop by hop in the post stack data but post-type data is generally end-to-end uh but anything that i need to do on a hop-by-hop basis the the majority of it i'll try to put in in stack data so it's not like there's instant data that is hop by hop and there's instax data that is end to end it's in stack data that is hop by hop always and then there's post track data some of which is uh hop by hop and some of which is the end to end that was kind of like yeah yeah that's just that's exactly that's completely consistent with what we're proposing right i'm just saying that yeah yeah okay i would like to give other people a chance as well yeah sure so um okay great thanks so take your next thank you uh uh thanks john uh for uh proposing this uh um many of the things uh you know i'm okay with i just want clarification on um the flags and the metadata post tag data sometimes a flag might be present and in the function flags as you call them or forwarding action flags um but the uh the metadata is missing for uh that type length value or whatever we come up with like the data"
  },
  {
    "startTime": "01:28:01",
    "text": "associated with that flag is not in the post-stack data would this can be considered as invalid packet uh in that case or this is something we need to still define i think actually what when we define a particular network function we specify this as an additional part of the behavior yeah you know for some i actually like network actions now i think that's good but for some network actions you know for some reason the ancillary data just didn't get put in but that's okay for another network action throw the packet away okay thank you okay thank you stuart you're next let's do a couple of things yeah yeah yeah you have to give permission for the browser i'm sorry i forgot i'm sorry if i'm here all right all right so um a couple of things first off um if you if this is this indication that's in the stack in patients in the stack um it's inconvenient to put it right at the very top of the stack for example in segment routing then you may consider an indicator for the presence of an indicator uh which may be either a you know a real indicator or the use of a fact that says whether it's worth searching for anything of interest further down in the in the label stack so there are other toys that we've uh that we've got to bear in mind in terms of end to end data um i think karichi sort of said it but i want to be absolutely clear above the top of the of the bottom of stack there has to be some indication that this stuff is below the bottom of stack otherwise you could never find it there be sure that's done that is part of the definition of a particular network action"
  },
  {
    "startTime": "01:30:01",
    "text": "okay all right now i want to just deal with two other one other case which is people were assuming that data that you process hot by hop has to be uh above the bottom of stack i think that's what i heard but there's some types we did not say that at all we when you're defining the network action you specify what is the ancillary data and where is it good because it has to be the general case i think someone said suggested that it wouldn't be maybe it was karite and maybe i know i mean when i what i said was right so here's the case i am worried can can i just answer stuart um there is definitely hop by hub psv yep and there is end-to-end psv yep what i did suggest is so what i did suggest is that the in-stack data is generally hot by hop i mean if you're going to put in the label stack and live by those constraints there's a reason you did that so there's a dish that generally i think probably is the is the get out of jail card here there is some data that i really don't think we would be likely to want to put in the stack for example the iom hop identifier or um some latency based forwarding uh information that took significant data so i think we need to be careful here some data may go in the stack but some hot by hop data may be forced to go after the bottom stack simply because of the size of it that's right and right what happens as i said as i said when we define the function we specify what the data is and where it goes good okay so if i if i if i look at the difference between this proposal and the original fai proposal essentially the fai proposal says everything that's"
  },
  {
    "startTime": "01:32:01",
    "text": "in stack is hop by hop as well there is nothing that is end to end that is in stack everything that's post stack could be hot by hub or could be so if you take those four combinations in stack hub by hub in stack end to end both stack hop by hop post back end to end fai says in stack car by hob no in stack end to end post postdoc hop by hop postdoc end to end what i understand this proposal is saying is you've got all four combinations and i don't see any reason for putting end to end data in the label stack put it after the label stack you know let the label start get be done with when when you get to the egress you know you're ready to handle the post tag so that's the one piece of this that i don't get there may be a case where we want to have end-to-end data in the label stack when we define a network action we will say what is the ancillary data and where does it go as a general approach i i have a i have a general comment that as a principle we should why to continue to complicate the label stack once we have a clear design how we organize accelerated data we can just put them all up to the label stack i understand there are some legacy designs uh with user labels but uh we just keep that as is and we should continue to add more on that because i i i'm saying that because recently i'm doing a lot of research on i actually write uh the the passwords for the different style for header header design and i find all those complications in the labels that will"
  },
  {
    "startTime": "01:34:01",
    "text": "just it doesn't help most of times it just makes things more complicated it doesn't help to improve the performance and also it introduced a lot of constraints and limitations to the design well one of the one of the things you stipulated in the definition of the process for evaluating proposals is that proposals are uh checked with the hardware designers uh for the various vendors that are working on this initiative that's part of the process yeah meanwhile i'm i have the hardware design background i already downloaded right but you're not the only hardware designer yep you're not the only hardware designer that's looking at this stuff yeah i'm just uh express my you know perspective so that's all i i got now for now right okay and lower has a question uh in that there is data that you need to put in stack that you want right there so you can process it pretty urgently so for example a slice identifier you cannot treat a packet correctly if you don't know what slice it belongs to and so you want to see that slice identifier right there so that you can actually do that anything you put a post stack you have to parse the label stack to get there and that that can be an onerous task for every hop to do uh the entropy label i know you were saying a legacy i i don't know that i would consider this legacy but the entropy label is not you have to do it but you can do a much better job load balancing without going to the end of stack and figuring out what's going on there because you have a nice uh hash right in front of you so there are things that you need right there and there are things that you can say after weight or the things that you say i would i don't want to wait but i have to because there's so much work to do here"
  },
  {
    "startTime": "01:36:02",
    "text": "okay so lower is next in the queue greedy okay so i guess one small comment and that is that because you can do something it's not necessary that you do it so if there are data that you normally don't want to put in the stack then you don't do it but there are four alternatives and we should have we should cover all of them right and as i said when we define a function we define where the data goes [Music] okay i don't see any current hands up at the moment um yeah it's something different this is more a working group share position i'm concerned about we have eight base spls left and if we take 25 of those for uh handling the uh the indicators uh then i'm i'm i'm concerned because i'm getting on the low side of available spls lower yeah i mean once we have the two spls then we can uh basically the uh hop by hop and end to end functions are pretty much extensible without any more spls well the what's not extensible is the basis spills we will"
  },
  {
    "startTime": "01:38:02",
    "text": "not keeping it straight is a very strict regime on how we allocate them so one thing is we should look at if we can do it as efficiently uh with just one baseline uh base spl and i don't think it's any way around that so if i can comment um first of all i don't see a reason to carry in-stack data which is end-to-end i mean if there's if it is not urgent for every hop to do put it in the end of put it post stack so having one spl saying i've got data that's in interesting for everyone that's going that's going to process this uh and then having just bits that say there is post stack data for for everyone or this post actor just for the end to end guys or there's no post stack data i think that is a single spl that you need and it cover i mean yes we have four cases but i don't think all four cases are valid in stack data that is end to end is a waste of in-stack data that's that's my view so that i made to to john that i think you know maybe i could encourage people to think about is whether we need physical definitions of these bits or logical definitions of these bits so this is mpls right and mpls gets around a lot of these resource limitations by mapping through the control plane so you could have an lsp wide or even a network-wide set of mappings between"
  },
  {
    "startTime": "01:40:00",
    "text": "the functions and the physical bit that they will occupy in the in the network and that would seem if that would reduce the number that we um that we needed uh also i am sure that if we go we think a bit harder about the encoding we can probably get down to one uh spl for both functions okay and adrian has his hand up yeah thanks i i just wanted to um to wonder about kiriti's point there of the uh for end-to-end uh data because i think end to end is can be blurred a little bit where it's a um a routing operation that has to take place at the final router i you know think of um pop and go type operations um and there it's not quite clear to me whether this is um sort of the end-to-end data that you put after the stack because it's what you do after you've written the label or you it's entering data that you do because you are at the end of the um of the path and you are about to rip the label um yeah there are also i was talking with joel and there's also another case which may be of interest which is that it's it's neither hop by hop nor end to end but it's really the router that pops the uh label at the top of the stack so it's sort of between intermediate points along the path uh i see what you mean end of the tunnel type of end to end rather than end of the whole mpls end-to-end yeah okay um laura so one thought on this"
  },
  {
    "startTime": "01:42:04",
    "text": "mips and maps and if i understand correctly mip could be actually allocated anywhere along the lsp do we have something similar here that's what i was sort of alluding to in my response to adrian sure so it's not it's not necessarily end of tunnel or end of lsp it could be middle of the lsp but you actually want to address it correct and uh i think that there's been previous discussion about that in some of the proposals from huawei yeah maybe but i thought they were a kind of mpls tp in other words i mean it's an area that we can work so from my point of view if everyone i mean when i say hop by hop it doesn't necessarily mean everyone uh along the along the path has to process it it means that i mean if you if you have this simple dichotomy into the end of tunnel and hop by hop um then for the hop i hop things you're saying and that's why i want to have a shoot and a must right if you have uh cycles and and you can go down and look at whether whatever it is um you can process this and you might get there and say there's nothing really much for me to do here uh if you if you know that nobody in the middle is interested or could use this effectively then you say it's end-to-end but but the fact that you say it's hop by hop doesn't mean everyone on the hop uh everyone on the phone that's what we said on slide three that's exactly what we said so then i'm struggling to understand"
  },
  {
    "startTime": "01:44:00",
    "text": "what is you know the fourth case what is the case where you put something in the data in the label in the isd that is really only to be processed by the endnote because you know if it's going to be processed by some guys that's hot by hop and so what i'm basically saying is you've got isd that is end to end you've got potentially rsv that is hot by hop uh you've got uh psd that is end-to-end you've got psc that is hub by hub that first case i see that is as end-to-end don't even worry about it so your ic is hot by hop pst is hub by hop or end to end that's what the current uh forwarding actions talks about adriana adrian sorry yeah okay yeah so uh very quickly uh clarity just reminded me of something that came up long ago in this discussion which is uh whether it should be necessary to distinguish between uh actions that uh or or yeah functions that a router must operate on and if it doesn't understand them then it it cannot forward the packet and functions where the router is allowed to say i don't understand it or i don't want to operate on it and can continue to forward the packet um that's if you like slightly orthogonal to the uh the hot by hop thing but i'm not sure we closed on that uh must versus can ignore yeah i touched on it in my slides but yeah we haven't closed on it yeah i think adrian that we would just that would also be in the definition of the network action uh it doesn't work in the definition i think because if you if you receive it and you don't"
  },
  {
    "startTime": "01:46:00",
    "text": "understand it um you need to know whether or not you can forward it without understanding it and you can't if you haven't implemented the rfc you can't know whether you can forward it without some additional information we we have to be we we have to be able to incrementally deploy which means that there there are routers that are not going to understand all of the network functions that's correct a hat on um we didn't take questions and clarify beyond clarifications for the earlier uh pieces of this we're running out of time i think we need to give people the opportunity if they want to discuss any of the points that we we worked on during the session anyone out there with any other questions or comments yeah i'm not trying to shut john's discussion down uh i i'm just gonna make it clear that people can discuss other things and i'm not seeing any hands go up so i i think we we've reached the uh part of the of the um meeting where i'm closing the queue for further comments and we're going to move on to stuart so stuart can give us a summary of uh of what he's heard and where we stand and what's next going forward right so this is a particularly short short straw so firstly i i i'd like to make an observation from the mpls meeting that where lower introduced a very important point and that's that this is a body of work that turned out to be much deeper and more"
  },
  {
    "startTime": "01:48:00",
    "text": "difficult than we had anticipated when we started um it's my opinion um that we need to work a bit harder to and certainly for longer to bottom out this piece of work rather than just take the first things that come to mind because the more we explore this the more difficult it seems to be hopefully we will have some insights soon that will allow us to to get to the end relatively quickly so the requirements they need to be studied we really do need some uh because they are the foundation of what we do and the decisions we make and um i think there needs to be more input in the odt process on on requirements we need to we need to find a way of giving them more quality time and of course time on the list um the um uh matters of how we encode uh the information in the stack covered uh by both um kiriti and uh by my john i think he's going to need some again focused time maybe more time than we can get from the weekly meeting maybe a breakout group or something but there are several areas actually where i thought it would we could do with some focused uh discussion uh more than the sort of 10 minutes 15 minutes we get in this session and perhaps more than we can get in uh when we mix it with all the status reports and everything on the thursday meeting so i think there are a number of cases here where uh and i would um recommend that the the the we as chairs may be set up some specialist discussion in the old days we would of course had a an interim meeting on a bunch of this but that's not really"
  },
  {
    "startTime": "01:50:02",
    "text": "going to going to happen i think um i think there's something else that we need um to uh to discuss which is the processing model which we was brought mentioned briefly by how you but again is fundamental to some of the decisions we need to make which is that we need to understand what an mpls router looks like for the purposes of doing these and what constraints we're going to introduce now hopefully we can do both that discussion and the detailed design discussion and the uh requirements in particular the requirements without this becoming a proxy fight for these solutions because that is um what always bogs down these sorts of discussions so i think that's my summary of where we are and what we need to do i'm more than happy to hear contra views from my co-chairs or from the working group what's the audio or um no one had any comment yeah there there was a comment from lou in the uh in the chat about possible virtual interim and we also have a comment from turek stewart um do you think the weekly meeting that we're having for the open design team uh can fit into the the the breakout the discussions that you know well i think i think in terms of process it's very reasonable for the breakout discussions to report into the weekly meetings i i am just worried um that um one and a half hours a week is not going to be enough to get our heads around all of this particularly"
  },
  {
    "startTime": "01:52:02",
    "text": "some of these things where your thought model process may be different but some of these things you really need to think about for a bit before you decide whether you agree um or not but i think there's no reason why we can't ha why we can't have groups reporting on the weekly meetings just to give a status update rather than necessarily have to wait until the next free weekly meeting to do the detailed discussion okay i would like to give lou a chance to make a comment blue yeah so if you need more discussion time either schedule more informal meetings or if we want to make it formalize it there's no reason we can't have one or more uh virtual interims well this is just me sort of feeding to my my colleagues in the uh in the other chairs to say where i where i got where my head got to when i looked at the the depth of discussion that we were having so if i can jump in um yes you know we've had several of our weekly meetings postponed for various reasons uh you know i think we could we could fit this into our weekly meetings if we really needed to we could have you know more weekly meetings i think the the the idea that we have our weekly i mean it's an hour and a half and yes we want to do 10 minutes of status and action items and make sure that we are on track but we could easily have an hour in these weekly meetings where we have focused discussion on any particular subject as opposed to try to say every weekly meeting there's 10 minutes for you know 10 different topics so i think we can make progress in the weekly meetings but to steward's point uh it might be effective for some things to take them offline uh but the problem is then you have it offline then you have to bring it back"
  },
  {
    "startTime": "01:54:01",
    "text": "to the main meeting but you know making forward progress on this i think would be a good thing uh but i think we also have to ask ourselves if we're using our weekly meetings in the most difficult way it behooves the chairs just to have a discussion after this to work out how we can get this volume of work done in a sensible time sure okay anything else going once going twice well i'd like to thank everybody for participating um i think this this was a really good session and we'll see you all at iatf 113 andy out thank you andy bye goodbye dave bye bye goodbye were you asking me something i guess not adios"
  }
]
