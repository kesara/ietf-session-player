[
  {
    "startTime": "00:01:03",
    "text": "Good. Alright. Let's get started. Welcome to mask atietf 117. in somewhat Sunny in Cold San Francisco. Most people know this by now. but but but"
  },
  {
    "startTime": "00:02:00",
    "text": "make sure that if you are here in person, you scan the QR code over there on the screen, and that put your name on the blue sheets and allows you to join the queue. If you'd like to speak, you need to be in the queue. if you're remote. You're on mute echo already if you're listening to this. and there's a little button that you can click to join the queue you want to leave the queue, click the same button again. And similarly, when it's your turn to speak, click the button to send some audio and click it again. Otherwise, this session is being recorded. and please take a minute to read and familiarize yourself with the note well. These are the terms by which we participate in the IETF And as it is the 1st session of the week, it's possible that you haven't thought about this in a couple of months. So give it another scan nod to yourself go look it up online, Otherwise, enjoy reading it all over again. One other thing to note is we do participate under a code of conduct here. thank you all for making this a very happy and friendly working group to be a part of. and let's keep that going. These are some helpful links that you can click on later. we have an agenda today. We're gonna start with some housekeeping. We've got Carl with Gorya's backup as a notetaker. Thank you both very much. Then we have a couple of talks about some of our primary extensions that we've recently rechartered to explicitly include. and then we've got some additional individual drafts to talk about. Would anybody like to bash the agenda? Wonderful. Before we get too far into our agenda, we do have one other fun note. which is that our fine friends over at Ocupop have designed for us our very own mask logo. So Came out very nicely, has a little bit of reminiscent of of quick in some of the racing stripes, but otherwise is a very nice little masky shape up there. We've got somebody in the queue."
  },
  {
    "startTime": "00:04:00",
    "text": "would somebody like to make a comment about our mask logo? Is it a bad and that's true. It is a protocol badge. a good point. Do you have stickers? We do have stickers. Yes. jumping several slides ahead. But yeah. So it it it It's mask. We have some mask words that go with it. They go next to it. We can different forms of it. And, yes, indeed, we have stickers. a couple left at registration. We stole most of them. and brought them in here because it seemed like this was the most applicable room for them to sit in. But, yes, so we have both the v mask sideways stickers, and we have the mask little badge sticker with the curved corners. That's all very pretty. So, yeah, come and grab some of our very limited stock up here. the end of the session. We will order more. I expect them to run out, so the next IETF will have some more just in case you don't get them today. Just Don't worry. we're going to have so much fun with our badge. And with that, The first thing on our agenda, is Quickware proxying using HGP. I believe means, Tommy, you are up. Do you wanna share some slides from your phone, or do you want me to share them and pass you control? looks like a yes. That trying out the new Medecco client So we'll see if that actually works. Alright. Good morning, everyone. So today, gonna talk about our We're proposed extension for quick wear, proxying through mask,"
  },
  {
    "startTime": "00:06:00",
    "text": "we've talked about this a number of times before. the draft has not substantively changed. since the last time we talked about it, But For context, the last time we talked about it, we did not yet have a new harder for masks that would kind of allow doing these extensions. And so what I wanna do today Go ahead. is just do a quick recap of what this extension is, why we're doing it, have a discussion quickly about adding encryption to when we're doing forwarding mode, which I think is biggest open thing that needs to be done. And last time, we talked about wanting to have some sort of design team in the group to really dig into this, and I think that's still a good idea. So I just wanna update people on the current state of thinking, but I as a Hint, we're gonna want to have a design group design team to work on that. we'll cover some of the other open issues, and then talk about what we do with this draft. Okay. So as a very Fast recap, here we have the case where we have a client, talking to the mass proxy, And instead of just doing purely vanilla, UDP, proxy, it tells the proxy other information about the inner quick connections that are being proxied. Specifically, it's telling information about the connection IDs as well as other properties that may go with the connection IDs, such as stateless reset. information. And this allows the proxy and the client to collectively do a couple different optimizations, 1, it allows the proxy to reuse, the ports or the sockets that is using upstream to the next hop, because it is going to be able to demultiplex based on the quick connection IDs."
  },
  {
    "startTime": "00:08:01",
    "text": "it also allows something that we call forwarding mode, And where the client and the proxy can instead of re encapsulating all of the end to end quick packets, within quick data grams, going over or h three data grams, going over quick data grams, it can just put them kind of directly on the outside because it's able to demultiplex traffic that is bound for the end target, with traffic that is bound for the proxy. end in the original incarnation of this, we just sent the end to end traffic just on the same ports, but didn't modify it at all. The current draft talks about swapping the outer connection IDs for virtual connection IDs to make sure that they're not the same, and then the discussion we're gonna have later about kind of re encrypting the whole packets means that the packets on both sides of the forwarding context will look completely different even though it's a very, very simple transformation that needs to be done and and you could, you know, hopefully do this all within BPF for some very low level forwarding layer rather than having to re capsulate all the way up into the upper level quick and re encrypt, etcetera. Okay. So there are a couple different capsules that this protocol defines, and, you know, this is a good way to exercise capsules in general. the client can register, connection ID that it has as its local connection ID for a flow that is proxying through, The proxy can say yes. I have kind of registered that one successfully. The client can register or target CIDs as it learns about the destination CIDs from the server that I was talking to at the end. and they can Negotiate these And this is also how they set up the virtual connection IDs or stateless reset tokens that they're gonna use on their link"
  },
  {
    "startTime": "00:10:02",
    "text": "between the client and the proxy for this end to end forwarded connection. Alright. So the main open issue is how we want to add encryption around this forwarding context. So, again, the current draft talks about just popping the CIDs, but not the entire payloads. So if you have an attacker a passive attacker that's watching traffic on both sides of the proxy. they are able to recognize, oh, this is the same packet. that was on both sides of this. Now that's not necessarily a huge problem in all cases. They're just kind of learning what the next hop is But ideally, you know, we aren't gonna give away any more information than we want to to anyone passively observing this, and I think I think we all agreed that There are definitely better privacy and security properties if it's not trivial to correlate these. Now, of course, you could have timing correlation or packet size correlation, but those are things that could hopefully be fixed other ways. So I think the direction that we came out from our last meeting was that, yeah, let's just encrypt all the bytes. prevents the trivial correlation. It I I think there was some discussion on the list recently that I think Ben had brought up about the difference between a passive attacker and an active attacker, in this case, I believe the discussion we're having here is just about preventing the passive attacker from trivially correlating the packets on the on either side. if anyone Dis agrees with that or thinks we should include more in the scope please let us know. And then based on our last our our list, discussion where"
  },
  {
    "startTime": "00:12:00",
    "text": "we were coming over with the different possible directions we could take here, it seems like an AES CTR approach for doing that re encryption seems to be workable, And I think a lot of it just comes down to how do we actually want to instantiate this? What are the IVs reflecting? Are we able to do this as a single pass can we do we have to do this to double pass And this is the type of thing that we would want to ideally discuss with a design team. Christian, Yeah. I'm I I should have raised the issue on the list. But -- Uh-huh. I don't feel comfortable with having these special treatment of bypassing quick and making packets, etcetera. and I very much like the idea of having optimization for the quick and quick, I wish this behavior of forwarding packet in a special way could be negotiated separately. I'm doing quick and quick. I wish that we had the best line in which we are doing quick and quick mostly to save on the number of maybe biweekly or something like that? but that we would just forward it as a straight diagram and that we did not do this premature optimization about trying to not completely redo encryption. can you clarify the parts that you wanted to separate here, the Yeah. Anything that is anything that is related to not doing doing I mean, Basically, I would like the best line to be the same as forwarding a UDP packet. with optimizations such as we can use a single port and things like that."
  },
  {
    "startTime": "00:14:01",
    "text": "I think that the variable but but Part for me, is to have a limited number of UDP ports open in the relay because that makes deployment much easier. But And I lack the part of quick aware, that reduces the usage of the number of open UDP ports in the Relay. But I would I would rather do without any kind of special treatment and special encryption. for the real quick packets. Yes. So the way It currently stands is that the support for being able to do forwarding is negotiated. And both client and proxy need to consent and negotiate to do that, And so it is certainly possible with how the protocol is defined here to simply just share the connection IDs and be able to do the port sharing and do nothing else. So that is entirely supported. Okay. we do know, like, experientially, for cases where we are doing multiple proxy chains, chains of multiple proxies in a row, that not having to do the reencapsulation is definitely beneficial for both reducing the encapsulation overhead and loss of MTU. as well as the CPU usage and, like, required hardware deployment for the proxies themselves. So Certainly not everyone would need it. but it definitely does have benefits in the deployment we have. Well, Alright. Hi. Airbus Rawat No. So I share some of Christians discomfort. on"
  },
  {
    "startTime": "00:16:03",
    "text": "When we when we did a bunch of, like, freelancing and designed the back protection mechanism. we did it. by by demonstrating to ourselves that it could not possibly come that we hoped it could not possibly compromise the the didextic only compromised potentially the the secret server. does not have that property? is like a primary mech security mechanism, which we are proposing to design, like, largely Yes, David. I know you're gonna say, like, it's not the end to end data, but it's, like, the whole point of the proxy is to protect asbestos information. So, like, So I find it quite hard to reason about, like, what what what what this does not. It does not. So while while I do share the the concern of MTU and the CPU, I I think that, like, to say, Oh, we're scoping to passive hackers is, like, substantially premature. We've got some real analysis. and and this e t AACTR thing, like, it may not be okay, but, like, you know, dislike needs real work, and it's not like something which could be, like, back down the weekend. So I say so I think so so to to to like, don't think we should make this decision. This this first point decision you're making earlier, I think that the I think that the -- Which which decision? -- that we are stopping capacity of tigers. I think that the acceptance of the entire mechanism at all should be should be subject to Real Security Analysis. really best. What I mean what I mean by that is 40 motion not go forward. I'm assuming that was rated as acceptable security properties. And by demonstrating, I mean, not be handway. Not be what? What's left? Not be handwave. So -- Sure. Yeah. Yeah. No. No. I misunderstood you're joining analogy you're joining analogy to dddd packet protection mode to the the the secret packet number mode was in fact hand waved. I had a part of that. And so I don't have a susceptible for this situation. So I the point of making is, like, is that, like, if we can't demonstrate that, then this should be removed. not, which is the best we can."
  },
  {
    "startTime": "00:18:01",
    "text": "Yeah. I mean, I I I do So I I would like you know, to have a more in-depth design team kind of go over different properties here. And, you know, the the The base idea for the ASATR stuff is what MT was proposing. So I think you know, we should dig into that more Right. Overall, I do I do think even as it stands with you know, forwarding mode without re encrypting, that is essentially you know, using the proxy here not as kind of an extra security mechanism, but as a NAT that you have a handshake with. So And like that. Alright. you know, at that point, your security properties are you know, roughly the same as what you would have if you didn't go through the proxy. from a lot of different attack. mechanisms. But -- I don't necessarily agree with that. Right. But the question is, what should be in a proposed standard? Right. And, like, I I think there is still value for certain deployments to be able to you know, have that type of scenario where I'm not necessarily trusting this proxy to add a lot of security beyond what my other hops are doing but I still want to be able to do, essentially, like, you know, a path selection and routing through this proxy. I do understand the point you're And I'm disagreeing with you. So So, again, to restate, my view, which others may or not share. is that this motion not exist unless you can do it. You have to demonstrate secure analysis that it provides realsecurity.com. ends. So can you describe, like, So if if if we have beyond the passive attacker, like, which what are the active what what are the other security Like, we wanna Well, I think I think that Benchmark"
  },
  {
    "startTime": "00:20:02",
    "text": "the reference benchmark is doing a Christianset, which is simply double encapsulation. And so -- Sure. -- I just so I think you do quantify precisely with the security losses between us, Okay. So the the difference between So what what are you losing by not? Yes. And, like and and I guess and I guess, like, recaps in. Okay. you know, I I haven't worked through what the what the encapsulation wall says. but like you know, you know, are we really saying we can't afford tenakets, are we saying we can we're saying it kind of because they're different. and there's showing no things you could do, which we meatsweet, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, speed, better than this. But perhaps worse than full encapsulation. that would not we do wanna participate Yep. Yep. That's fair. That's fair. I'm happy with that. Watson Ladd, Akamai. I think there is some history with these kinds of lightweight packet protection, not try and change the length from the tour project. And what they found with AS counter is that you open the door to tagging attacks. the attacker makes where They'd slip. can see. And in quick because quick recovers from from Putin Norris had the filler production The attacker can see which of the flip or unflip one@laterproxy chain. works. And that means that the chain of proxies don't necessarily get the is is it is nxtric properties may want. So -- Because the the individual proxy is not validating that there wasn't a bit flip long. New individual proxy can't. Right. Yes. Yes. And so they ended up trying stuff like lioness and high end the whole history here. Mhmm. Which I think depending on security properties you might want, And I think with a sufficient encapsulation, it's sort of tempting to say Okay. Well, while I have all the And why not use this rhetoric? And the answer is because there's a lot of security issues with doing that, but I think we should look at it inside Mhmm. hey. Should we should we learn from this intro? If that's a security model"
  },
  {
    "startTime": "00:22:01",
    "text": "Good. Good. Goodchen. I mean, Ica made a lot of the points that I was wanting to make, and in a more clear way, An additional point is that I think we have to be very careful 2. have the proxy not make I put this as they go beyond the quick in violence. And it's tempting when we do optimization. to basically make hypotheses about, hey. quickly one does these etcetera? And we see things happening, like, multi pass with answers to where the packet are encrypted. I really, I don't feel comfortable with doing optimizations now I understand that we want to save CPU and MTU But is a history of doing premature optimization, that could bite us just later, and sooner rather than later, in fact. I mean, Understood. I mean, to the point of permitral optimization, like, again, in practical deployments, this we have measured. It doesn't make a, you know, a large difference on the ability to actually scale the this up. So it it was a necessary authorization to do in order to get some practical deployments. That's good. 1st. I I don't know. Because, I mean, if chain relates probably because you do some kind of onion routing And Like, if you're trying to change relay and we will get to for example,"
  },
  {
    "startTime": "00:24:03",
    "text": "Having this optimization may have very well unintended consequences. Yeah. may equivalent. I just I I wanna disagree with Ecala, but because I think having the full encapsulation as the baseline make sense. If you want the secured property of full encapsulation, just do it. don't use this optimization. But this is still gives you some features you may want compared to just an end to end connection. Right? So I think, like, seeing this as an optimization, which should have the same security properties doesn't make sense. like, if you want the dirty than encapsulate. But we should be more clear about this in the draft that this is just not replacement is a different use case. Yeah. David Skinazi, mask enthusiast. I wanna agree with Briya here. I think if you if you look at what Apple has deployed in production to What is it? 100 of millions of users? they have something that work that is this. without the encryption. And that's what allowed them. to ship the right cloud private relay feature as opposed to let's say, a 2 hot mask. because in their case, have their own data saying that it then worked out. for them In other cases, let's say you wanna use mask for tour, which sounds really cool. you don't because the attacks that Watson was talking about, like, are a problem in the Tory use case. not necessarily in the private relay. use case. So the question kind of Where we go there is do we wanna say, well, No. this is not as good as regular connect UDP, so you should use a NAT instead that's, you know, IETF is standard, and we won't let you do this. Or do we say, well,"
  },
  {
    "startTime": "00:26:00",
    "text": "Do we want some kind of middle ground that's nowhere near as good as connect regular connect GPU Security, but maybe good enough for a use case like Apple's private relay. or, you know, Google's looking at building something similar. and we haven't deployed to production yet. We haven't measured. Right now, we're starting with regular connectivity For interest, we're following this draft very closely because we might run into the same process. We might We don't know for sure. But I think the might be a role for this in the wider ecosystem of what MASK can do. Now I mean I mean I mean I mean I mean I mean I mean I mean I mean I mean I mean I mean you know, just come with the like, certainly, I I would like to add encryption it and kinda make it have more of the properties that, you know, Toric can have, and the point that Watson brought up about, you know, the problems with just doing the ASCTR, like, that's I think we should analyze that and understand what the trade off is and the loss is when we do that. So, I mean, since I've been name checked twice, I think I'd like to clarify what session I'm thinking is. which is that the baseline for analysis ought to be be for encapsulation. and the job of analysis is to quantify the gap. between before encapsulation in this thin. until we can adequately do so, we should have to see then once we've done so, we can assess for that gap Yeah. makes sense. That makes sense. Martin Duke, Google, not only not wearing hats, but actually speak on behalf of Ryan Hamilton from Google. Wearing someone else's Yeah. So he he's he's his cons and, like, I think it's a legitimate concern, obviously. Like, By removing the double encapsulation like, like, If you don't have encryption, then there's no authentication to the packet, and it seems like there's some threat models where The people could inject random garbage with the what the virtual connection ID and get the proxy to do things. So I I think that's probably an important thing to include in the analysis that occurs it's suggesting. Thanks. That's a good point. I I do believe, like, you know, if you got a connection ID, you wouldn't"
  },
  {
    "startTime": "00:28:00",
    "text": "recognize you know, to handle it by, you know, either you drop it, etcetera. Also, like, in the cases we're thinking about here, like, this is always for, like, you know, intermediate steps of the proxy, not 66-666 66 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 the end servers. And so, like, the next proxy. So so to be clear so I I I think the threat model is there is a passive attacker, like, hanging out on the client to proxy path. Yep. I observe virtual connection IDs. I just send packets garbage packets with those virtual connection IDs that I'm spamming the target. Mhmm. with with stuff that the proxy will admit. Right. That's right. Because there's no admission control as there is with the mass connection. Mhmm. Yeah. Okay. Thank you. Yep. Yeah. Which is why I do think, like, it makes the difference of, is the next hop. just yet another proxy in the system versus like, the end server that you're allowing to get garbage. Yep. Yep. to Alrighty. I think the next slide was just a brief overview of where things were currently for the ASC tier proposal. I don't know. David, if he wanted to comment to this at all just to explain what it where the current thinking was Yes. So just really quickly. We Multiple people, like, I think initially Martin Thompson came up with one potential design. I had one that I think this one is from Ben Schwartz. long story short because you're working on encrypt like, your plain text here is an encrypted packet you're kinda properties are very different. It's like random data as opposed to your usual plain text. So you can do some things that are kind of simpler, in the quick header protection, So like proposal here is USCCP 1 Block of the first 16 bytes and then use that as a non sticky and AES CTR key stream for the rest of it."
  },
  {
    "startTime": "00:30:01",
    "text": "Clearly, this isn't fully flushed out. many details need to be figured out, like, you know, which keys to use for these things. together. grab them? Are they per connection, ID, or per connection? And this is the kind of thing that's really easy to get wrong. So I think, you know, to accuracy point, have spending some time on the security analysis and the threat model of, like, what are we actually trying to solve makes sense? But then once we get a clear picture of that, I would really much be a proponent of forming a design team. because speaking as one of the editors, I think we could use a lot of help to get this right. Agreed. Alright. So the only other content I had here was talking about some of the other been issues we had that various folks have brought up Eric, did you wanna just quickly talk through some of these income. So outside the encryption 1, there's a few open issues. Yeah. that we thought might be worth bringing up. Sorry. Can you hear me? Thank you. break it off. So this first issue is quick version compatibility. So the gist of it is are capsules for registering connection IDs. include things like connection IDs, that are allowed to be up to 255 bytes. which aligns with the quick invariance. it also includes things like stateless resets. which are not part of the quick in variance. So how do we wanna kinda square these things? We wanna align with quick invariant so that we can see all versions of quick, But at the same time, we wanna be able to handle some version specific properties of quick. are there any thoughts on this one."
  },
  {
    "startTime": "00:32:05",
    "text": "Martin Duke, Google again. Yeah. Thanks. That's, like, guy who's overthought the version thing, thanks for to consider this. Yeah. I mean, like so in in the quick OP draft over in the quick working group, We have a section on version invariance of the design, which I think a similar thing would be appropriate here, which is, like, what what assumptions are we making in excess of r c 8999? because I think, like, while that's a fairly small set of invariance, like, there are there are a lot of assumptions that in practice are probably pretty safe to make about about future versions quick. And then just like documenting where you where you really have to deviate you know, go beyond 8990 8999, It's good. Like, if state was reset format changes, Is that something where you could, like, configure the proxy to just stop doing that? or or, like, if if it is sending these statements if it is assuming that it's 9000 And you're saying these things usually, it's like, what happens? Does it break something, etcetera? So I I think it's actually that would be appropriate, and I think actually pretty straightforward to write. Yeah. Thank you. At at least in this stateless reset case, it's an optional field, so it could always be an not provided. but Yeah. That's that's good feedback. Thank you. I mean, like, I guess, it it's feasible for a proxy to, like, look at the version, and and and, like, figure out what it can do and our efficient Like, to you could actually change the design if you wanted to and have, like, a version A version of wear mode and, like, a not version of wear mode, that that, like, had a stripped down set of capabilities. I mean, that's that's a possibility I've than any analysis of it. But, again, thanks for for working through the space. Thanks. Mike Bishop, Akamai, I will"
  },
  {
    "startTime": "00:34:01",
    "text": "I will echo that that And having it be optional and also if we are going to have version specific capabilities, having a way to plug in Appropriate capabilities for future versions we don't have yet, So I think maybe not just having it be an optional field, but having an identifier of This is a version 1 stateless reset because I'm planning to use that. and I might be able to tell you about a version 6 7 something else Awesome. Thank you. Alright. So the next one here. The tunnel mode is subject to 2 congestion control loops, one between the clients and the proxy. and the other between the client and the target. But in forwarded mode, we lose the congestion control loop between the client and the proxy. And so this kinda starts to beg the question of in certain deployments. Does forwarding mode actually give you some performance improvement. or by foregoing that congestion control loop Are you actually hurting performance? So this probably deserves some kinda consideration in the draft, It seems most relevant when the proxy target RTT is the highest But but Yeah. Are there any more thoughts on this one? I think we're also Alright. And then this last one is connection ID compression, which I think was in the original mask draft And So what if you wanna do forwarding mode? or sorry. What if you don't wanna do forwarding mode? you still wanna reduce encapsulation overhead You don't wanna have to send the full connection ID on every single packets, So this is This becomes increasingly relevant if connection I'd use get really large because the cumulative MTU overhead of capsulating over and over again. becomes more significant,"
  },
  {
    "startTime": "00:36:04",
    "text": "But then if this is something that we wanna do, should this be a separate extension, part of this draft open your thoughts, Hi, Erica Sporla. this is gonna come up again in the next buck. because the overhead of the packaging for the 5, if you wanna use if you wanna use something like mask for something WebRTC. and you'll have media than the overhead of the of of the encapsulation from Square large because the tech decrease more especially your invoice. So I think is something these we looked at, and I think they're like it should not be here. I should be Sorry. In this in this in this working group, but not in stretch. Yeah. I'm not sure I agree with that. but, I think the answer to this question will depend on how much the forwarding mode ManLogistix to get us and and and what the security properties have been. ultimately would be So think we're gonna decide here. I just wanted to ask why should it be in the same draft as is that I mean, she's, like, really 2 separate things. to me, or is there anything that actually is the same in there for makes sense to describe them together? I don't know if anyone or Tommy it was just one of the issues raised on this of, like, oh, you're a quick where My personal opinion is that it's we should and can define it separately. Yeah. Yeah. And that would make it orthogonal, and maybe you could use it together, and maybe not I mean, it is a good point that MT brings up about it matters more or less depending on if you're doing forwarding mode or So Anyway, I think this is the last the issues. So Hey."
  },
  {
    "startTime": "00:38:04",
    "text": "Last time, we had seen pretty favorable about this. I think this time we were more concerns brought Right? I do think in general, it seems like we need to do more you know, serious design on what the re encryption would look like and what the security properties are in the analysis there. more than just, like, a couple emails on the list every now and then if you wanna consider this. So I don't know what the terrorists think about process wise for like, design teams for something that we haven't firmly adopted yet. but it seems like it's something that we want dedicated effort on in order to make progress here or not? So I would ask that we do spin up something since I believe, you know, this topic area is within charter now, so we can just have a design team to get into the nitty gritty and do that security analysis. Yeah. So this is not a working group document. yet. it might become one eventually, but I don't think anything stops you from just forming you know, a group of your friends to work on this before it becomes a working group document at a college and design team. Sure. But it's been pretty easy for us to have I guess I'd ask to, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, like, have, a working group like, driven design team. that think we'll reserve that for working group documents. Mhmm. Right. David, did you have a comment? David's Ganazi process enthusiast. I mean, we can Brad hole for a really long time about whether or not you can have a design team on a non op document, Or we could talk about adoption. Right? Thank you. Alright. So based on the conversations here with the mic, it seems like of the things that is not super clear is what the potential use case for this is in practice and what the value of it is. So in order to sort of"
  },
  {
    "startTime": "00:40:00",
    "text": "get towards an adoption call. We're gonna do 2 show of hands. first of which is just to tease out in the room whether or not the target use case for this particular draft is clear. So I'm gonna start that now. Simply yes or no question is the target use case for this document clear. are 2 use cases, but There Sorry. I've just like, there are multiple use cases here. 2. Okay. So plural. Do do you see Okay. Gonna end it. So it seems fairly clear that at least one of the use cases that's in the document is clear to people, which is great. And then and then Given that now this is explicitly listed as an item in our charter, I'm gonna do a second show of hands to ask if there's interest in adopting the draft as a starting point to address one of these use cases that is clearly taking in the draft. Corey, did you have a question? 20 something to 7. 26 to 7. I I wanna note that Yeah. I wanna note that as as discuss with the mic. And as, you know, I commented in the chat, we we will not publish this absent security analysis that that guarantees that this is safe to do so. We we understand what the implication of using this particular authorization are And that that seems like perfectly reasonable work to do in the working group. working group could remove the forwarding mode 2 if desired. For example yeah. Not Eric. Go ahead. Yeah. I think I think"
  },
  {
    "startTime": "00:42:01",
    "text": "I don't know, Josh or Matthew's document. I think this is what they do to work on it in a working group rather than have a piece of a rum thing. But I think that the process here should be that there should be a walk ins as this call. to retain this once the security analysis is done. the As opposed to being as if the per the burden should be that it it has to be agreement that you went rather than find it out. Bye. I I would argue that kind of whatever the outcome of the design team or whatever on this there should be a consensus call to adopt that brothers. No matter what it is. to keep all removed. Alright. So I'm gonna add now 39 to 1 for you. We can note that. So Seems like they're strongly interested in adopting this. We'll confirm on the list. Thank you. And and then we'll talk about design team process. Great. Thank you for the meeting. Thank you, folks. I think next up, we have David? or Abby. Great. Copy. Do you know how to drive Sure. We can. But you're you're able to do so there, but we can we can do it. Take it away. Alright. Alright. Hello, everyone. I'm Maddie Singh, Google. we're gonna be talking about the mass connectivity to be listener. So I've actually presented the same thing over the last couple of ITFs, but recently, we had the reach out recharter and an opportunity to perhaps adopt this. So Nice. So connect UDP as it stands. So it allows only single 52 poles, which means"
  },
  {
    "startTime": "00:44:03",
    "text": "You you have a connect UDP connection with with the proxy and and the your UDP payloads are forwarded from the proxy to the target. and And the target is specified through the well known paths in the header. So we do have limitations to what we have right now with Connectedip, which is if We want to connect to multiple targets. we create a connection for each to from client to the proxy. So It is possible, and probable, but the targets like, different targets will see different source IP addresses for for the client. because because there's no guarantee that the same that the same instance would The same instance of the web server would would forward the the packets. So it could be different IPators send different ports. So I'll give you an a use case So let's say Bob and Alice, they want to talk to each other. And let's say Alice is behind one of the proxies and Bob is behind a mat. And the matter is address port dependent. And you'll see that, like, connectivity be the way we have it right now. a kind of acts in a similar way to and address for dependent mat. So, yeah, so they this they talk to a server in the middle and the server learns both of their IP addresses and ports. and then the server tells each of them, like, where the other is. So Alice learns Bob Bob is at"
  },
  {
    "startTime": "00:46:01",
    "text": "Address b, port b, Alice learns of Like, Bob learns his It's at AA, and Allison just said b b. However, if Alice tries to connect, to Bob. the Matt will reject the connection further because because it's an address dependent mapping. So that Matt doesn't have an entry for Alice, you connected that same to connect to Bob and also Alice, what you'll notice is Alice is sending from a different IP end port as we discussed before. So even if Bob was informed about The IP address of Alice, Alice, Bob has AA, not a dash, a dash. So this connection would get rejected. Likewise, if Bob tries to do the same thing, it will get rejected because proxy kind of acts in a similar way. So both of them be kind of learns super useful information about each other. And in WebRTC, unfortunately, the only option would be to use to use a server in the middle. to use a turn server And So in the world of stun turns and turn and mats, as long as At least one of the client's behind a less restrictive map WebRTC connections can be directly established peer to peer, can be established without needing transfer in the mill. So So if both are behind the adjustment and that's a relay needs to be used. And like, with Connect UDP, the way we have it right now, it would kind it kinda resembles that. So which is kinda problematic because we already have 2 proxies running. Why do we need a third one in the middle. So"
  },
  {
    "startTime": "00:48:00",
    "text": "proposal to connectivity with listener support. So the same connection, And target multiple targets. So we're kind of resembling a better kind of math. And I wanna give parent to Eric Riscola. His blog was super informative on this, and it really, really helped us kind of understand even our own problem. So we're kind of resembling endpoint independent mapping. So for the same client, The server is kind of using the the the same IP and port to connect to multiple things. and So as long as either one of the 2 is behind, like, less restrictive properties, like here, should be able to connect, and We And you'll see this is what of the examples of these kind of with 22 mats that have, like, address independent mapping, but address and port filtering that connect to each other. And they're able to connect because Eventually, one of them is able to create a hole like the the first packet gets filtered, but 2nd month, and and it works. So Yeah. I just explained this one. Okay. So how does it work? What we're proposing? In the past, we'll we put 2 asterisks to indicate a any any any destination. And, of course, like, So we'll also add a context context ID for connectivity be listened to specify this is connectivity, was more specific. And in the data in in the data ground, as you can see, each Datogram has a and the IP IP version IP address and UDP port, it target"
  },
  {
    "startTime": "00:50:00",
    "text": "where the packet is supposed to go. And yeah. So if this was being sent from the client to the proxy, this the this IP address in port would determine the target port their the package should be forwarded and when being received back to the client, this indicates the source where it's receiving from we have multiple connections, And So that's pretty much it. That's, like, the gist of it. And I'll go over some open issues real quick. So the first one we had is allow the proxy to send the public IPN port to client. Do we want the client to be able to query its own IPN port. normally, like, In WebRTC, it's gonna use a stand server to find its own reflexive IP and stuff. But If we already have, like, a connection to the to our proxy because might as well be able to query it ourselves. Would that be useful? Yeah. Eric. Erica for that. Yeah. Go ahead. Sorry. you should have, like, think I observed the last meeting. We showed Tremfel. We've reinventing every feature of churn. So, really, someone should take a look at turn and map on the features that make sense. rather than remaining freshman schools. I've already done this. This is, like, when you do an allocation in turn, it tells you your server or actually your your your exterior Right. Yes. You should do this. But but but Generally, you should return -- Yeah. -- which really has solved this problem. And on on I think when we get to the next should be in the response. to the to the So so, I mean, like, I would seriously simply adopt the turn strategy here. which is that that do an allocation, which is the the thing in the previous slide -- Mhmm. -- and response is your is the allocated address. Right. Right. Right. Right. and that that's how the answer should"
  },
  {
    "startTime": "00:52:00",
    "text": "So I'm gonna be I'm gonna step back for for the ones over here, but, like, how many other than Mike several the same basic thing, which is you can just steal every single piece of turn. rather than trying to impact makes sense. That makes sense. That makes sense. Thanks. Burns clearly. Also also, yes, we should do this. I THINK More in general, I'm I'm trying to think about how how can we Coming coming at this from the perspective of ipv6 where he did, like, this well basically Internet forklift to, like, try to support end to end connectivity again. Right? Mhmm. I think we can I think we can I think we should think about how do we retain end to end connectivity through proxies. think is is On one hand, it's like really important to have you know, proxies to protect the the user IP address but we also want applications not have to deal with a bunch puts Right. And One thing that I think, for example, on certain operating systems like Android, let let's hope for iOS. It's like, you know, apps are basically, like, fundamental APIs like, you know, connect, get softbank, get peer name, I think One thing that would be great is to Think about how can we implement those through a mass proxy. In this case, for example, you know, one thing that these applications do do is they basically call connect to a to remote address. any call get the call against Sauconning to figure out their local IP address, and many transform they transfer this over and out ofbound channel. Right? They basically say, hey. Here's my IP address. And, of course, with ipv4, this doesn't work. Right? but in my PB6, it does work. today, And so we should make sure And I think, yeah, I I think ideally, we would make it so that whenever you do connect UDP, it just behaves like a UDP socket. has a local IP address in port, which is actually living on the on that on that on that atomos proxy, and that stays constant, And ideally, when you talk to the same endpoint, you have the same one. Right? because you feel within open 2 sockets. Right? like,"
  },
  {
    "startTime": "00:54:02",
    "text": "if you it would be really nice if you had the same IP address and like, for the other post another that's you. So -- Of course. basically trying to think about, okay. Like, how can we, like, emulate end to end? a little bit better. And this is yeah. You have to do this for sure if you wanna do David Sckenazi, mask enthusiast. First answer, Echo's point, yeah, this is definitely reinventing parts of turn. But in case y'all have a notice. We've been reinventing socks and then we've reinvented IPSec. And we're running the Internet over HTTP now, but don't tell anyone. So conceptually, you can do this with turn, but I think we did a good job explaining that If you have regular connect GDP, you end up needing a turn server, and that means that now you have another point on failure on the path that every single data packet is going through. So this Sure. From the protocol perspective, it seems like reinventing the wheel. But from a deployment perspective, it means that things will work better. So so you know, sometimes some work duplication is a good thing. And then to Lorenzo's point, I agree. Like, if you look at Connect 2 d p, conceptually, what it is is it gives you a connected UDP socket. or you can send and receive, and it always goes from the same local port to the same destination. And this gives you a unconnected UDP socket, which is why we ended up calling the Draft Connect TP listener because you can call listen and all those things, and this is an example of feature that would enable some of those calls like its SOC name to actually work. Tommy, Okay. Lorenzo."
  },
  {
    "startTime": "00:56:00",
    "text": "I guess, to be a little bit more concrete, yeah, like, basically, what David said. I think to to to be a little bit more concrete, For example, when you call Connect on a UDP socket, the positive semantics are this that your port will not change after you do that. And, like, this the the local port doesn't change. Right? And you could call disconnect, and then the then a bit will get reset. Right? But maintaining those semantics will be really helpful to, like, not break existing apps so that you can basically, like, forklift that's to run them on this. because again, think about an OS where, like, everything uses SOC APIs. If you just, like, emulate them correctly, then all of the apps will work if not you're sort of in the world So mean, reg regular connectivity I just just connects to a single client and And for that case, it does stay consistent. get the port number. Right? Right? So -- But you can't Right. Yeah. Yeah. which so yeah. So that should just go away. Right? We should just do something like this, but mean, unless you're, like, just doing a, like, a flow thing where you really don't care. brain. yeah, the other thing is, like, when you call send to, But, an unconnected socket, you basically you commit I think it commits port number for you. Yeah. And that won't change on that socket. Right? So we need to, like, kind of like emulate that as well. Makes sense. Yep. So David and I were chatting offline and it appears that maybe it wasn't clear. I think this is fine to do. But I think that what the way it should be done is by copying and pasting turn into this. rather than by rather than by rather than by iterating through and finding problems and fixing them. So that that's my thesis. Not that we shouldn't do this. I agree. Turn is is, like, I think I need clear when I'm ready for ready to turn. It kinda feels pretty clunky and old. it's like worth considering. In fact, that's gonna be relevant in about one slide. Yeah. I think it makes sense. So speaking of copying turn restricting IP addresses. Again, this is something"
  },
  {
    "startTime": "00:58:01",
    "text": "they are it's already done, which is like so we wanted to ask the the working group, oh, do we wanna allow all IPs through, or do we wanna have an allow list? But I believe terminology does it through allow list. So I think let me try to, like, flesh out for people what the context of this is. which is when term was designed, So a a pre standard firewall configuration policy is is is external is outgoing connection tool. Right? That phrase with TCP, UDP has done with, like, Stifel inspection -- Mhmm. -- and with and with timelapse and stuff like that. that's why NASA paid the way to do right. And on on when term was first designed, there was a nervous out of concern that on that if if r. Turn had an incoming connection facility. that it'll be then used to bypass firewall rules. the consequence would be enterprise administrators would block manned on And so terms, specifically designed, not to allow incoming connections. on they were concerned about the eat, the the the knock on the fat. Right. of that. And so Now this that was 4 years ago or whatever, so things may have changed. But the reason for that design decision is that. And so if the IETF wants to make a different decision, say, I actually, we think firewall incoming you know, no one coming can rules are stupid. That's like, totally reasonable for IT has to do. I'm not sure what I think about myself, but that's why Charter's designed the way it was. And so on I'm not aware of any other real reason why why why you should be lending in connections under circumstances. It's not like you're you know, act actually, not make a like, make make, like, an incoming UDP server. Like, out of your and you think on I Well, it's not quite true. There there there are, like, sort of freight limiting kind of concerns we can talk about in the next But that's why it turns out turns the way it is. So I think, like, we should make a conscious decision to not do that not gonna do it. I don't actually know what I think about it. Right. David? David, it's Ganazi. far well enthusiast or not. So To add to what Edgar said, yeah, churn one of its properties was that it was distinguishable on the wire."
  },
  {
    "startTime": "01:00:01",
    "text": "which in a lot of cases was a feature not a bug, But there was really a fear at the time that firewall operators would block it entirely because they would see it as a threat. Let's just say that we haven't really been operating with that mindset in mass. So here, we don't have this problem because this whole thing is designed to look like regular web traffic you don't have the encryption keys. This whole thing being an HTTPS connection, Yeah. Traffic analysis. I know. Yeah. Yeah. So you can you can look at what the IP address is, but you can't look at a pack and go, oh, clearly, this is mask inside the HTTPS connection because it's encrypted. And so This was a feature of turn that may century specific return, and I think we should ask. I personally don't think we need this. and it's something that you could add later as an extension on top. but it's worth by kicker said, having that conversation, but, you know, post any any any any adoption conversation potential. Alex. Hi. Alex from Hopsky Google. I just wanted to say that there is another very popular protocol that lets you do incoming connections. It's called SSH. and it is generally widely accepted even in most corporate environments. So, like, I I don't think that this particular turn feature is one that we need to be worried about. Yeah. You can you can So I think they're they're gonna say there is sort of one more reason, which, as I say, may not be a cryptic volume using, which is on on on know, essentially, the Console West opening up an arbitrary UEP port to any location is that you get a lot of packets. And And so one of the nice things about having basically the trusted vendor filtering is is dash"
  },
  {
    "startTime": "01:02:01",
    "text": "once you basically so again, turn emulates basically basically, turn emulates, basically, net bindings. And so it times out so once you basically used ice to establish the the host worker tech you wanna talk on, then basically turn closes off the incoming reports after, you know, 5 minutes or whatever. And so the consequence is that to bounce off it really rather than get made to you. That's, like, not a huge issue, but it's, like, it's another reason what it's. I I I certainly I I don't think any of this precludes adoption. I think we certainly, like, just make all decisions later on They're trying I'm trying to get some context for why things were designed the way they and and whether and whether those things continue to hold. Couple of observations on that, I guess, One thing is Yeah. You know, automatic time outs are sort of good to emulate NAST. they're really painful to deal with if you're an app. Right? So and they're really expensive to sending packets every now and then really expensive on on sort of 3gppnetworks. So it'd be nice to get away from that. Like, with ipv4, you kinda don't have a choice, but I mean, a lot of carriers today have, you know, submitted time outs for UDP not entries. and that's just a extrude sharingly expensive. other thing for for the allow us to remote IPs is, like, while yes. It's okay to say a network administrator. Oh, yeah. This is fine. Don't worry. The only allowing coming connections from the remote endpoint, it does boil down to, like, trust the app. Right. And so this may not be a very sort of appealing guarantee to a net to network admin. Yes. I I understand. I was like, you know, yeah. churn was done for this reason. But if that's introspectable over the wire, that's a completely different thing. because then you can tell the network admin, oh, yeah. Go by the security year. They'll do a bunch of DPI and ensure that the the Appisonic receiving connections from the endpoint Whereas this is, like, completely opaque as as as David said. Right? So I don't know how, you know, this is basically, yeah, trust the app. Like, the app can tell can tell a proxy that it's only gonna receive from this particular employee, but you have no idea to know if it did. So I know how how how helpful it's gonna be."
  },
  {
    "startTime": "01:04:01",
    "text": "From Meta. My question is not about project is about the implementation So in your diagram, we have one instance of proxy do we consider these proxies and fronted by, like, a layer layer 4, load a parameter, So which is mean we have a multiple proxy instance, when we create a listening socket. that's the mean we should create a listening socket on all proxy instance or not? So just wanted to understand this because TEL have listed issue. So when turn design, we don't consider this like a layer 4 load balancer. So we create a lot of operation issues. So if we want to solve this problem or solve similar problem, then try to solve let's consider the layer 4 load base before approx Go ahead. Jumping in as call 3rd and answer that. So in our implementation of connectivity team. What we ended up doing was that we have ingress IP addresses and egress IP addresses so that the incoming HTTPS connections to your mask proxy, go through an alpha load balancer And so, you know, if it's h two, it'll do the the 5 tuple magic. If it's a h three, it'll go and do connection ID magic. But then all of the outbound traffic. So let's say if users sent a connect request, and we're creating a TCP socket or connect UDP, and we're doing UDP. Those are on a separate address range that is Well, Magicically not through load balancer in practice to another load balancer that's configured differently to make sure that those things route back. So In practice, we need to solve this problem, but I don't think we need solve it in this document because this problem needs to be solved for Connect."
  },
  {
    "startTime": "01:06:02",
    "text": "for connect u for regular connect and regular connect UDP, just as much as for this. Yeah. 3 points. First, I mean, denial doesn't get you deployments. So, I mean, what he got said is is correct. I mean, we have to consider the impact on deployment What would I get or not? Right. The the second point is that There are really 2 scenarios. I would say, basically, there is the ice scenario which is the WebRTC scenario, Mhmm. And there is the server from home scenario in which you somehow export your server at home to a proxy in That's pretty much the load balance of scenario. I think that we might be better off treating the the server the the load balance of scenarios, apparently. As you need, what you want to do is export a server, Then maybe that's not mask. Maybe that's something else. And the reason I set out is for the purpose of able to distinguish these two things, which will probably get a better deployment in the end. And My preference will be to solve the stevel scenario, We start making the h three hypothesis, but we we can do that. Anyway, we won't. And the third point is that if we do consider the eye scenario, Then everything that Because said is relevant because in the ice scenario, the the client is king trying to connect. pretty much knows the IP address of the peer. It doesn't know the top number that the peer is gonna use, but it knows the IP address of the peer."
  },
  {
    "startTime": "01:08:01",
    "text": "So in that case, it's possible to basically do some kind of filter modification that says, I want to make ice work now. which will accept things on IP address without bothering with spot controls. And that's probably the kind of compromise that we have to study. So to clarify, you're saying we should have when we want to use ISB, wanna temporarily Unrestricted. Not very clear on. Yeah. It's well, you you have two way to unrestrict. You have one way to invest the the basic restriction is completely symmetric. Is that, basically, you have to say it works but, for example, it doesn't work for anything else. Mhmm. Yes. Yeah. also way to unrest trick is to say, okay. I am trying to establish an ICE connection with this particular 3 table, not 4 table. saying, hey. I I I want that IP address. Maybe that set of IP address to work. which is different from the whole world. But It boils on to doing what Igor said is to basically look at what on Indeed and do exactly that. Right. k. That's not learns completely a slightly different question. Do we have, you know, is that so so David just mentioned that the that the proxy that that that that that that that the proxy is kind of if I understand correctly, proxy is basically maintaining stable external IP addresses on a per client basis or at least on connection basis. Is that right? Like, when I do connect, that sort of Yeah. Yes. On a private price basis. Right. So I think, But that's just what you chose to write. That just happens to be, like, what the code Now I think we should you chose. Right? Yes. try to think about, you know,"
  },
  {
    "startTime": "01:10:03",
    "text": "apps that are gonna roll apps that are sort of, like, need to go through this this stuff. what can they rely on? Right? I mean, I think I personally I I understand I think I understand Kristen's point. Right? but I would personally strongly believe that we should not do something that's very restrictive. And I think we should say, well, you know, we should actually, like, move the IP address to the proxy, but it should be sort of end to end connectivity capable IP address, unless the app wants its own protections, in which case it should opt into them. But I think given that this is just like the code you happened to write, think we should actually write that down and say sort of a mass proxy implementation should be in the business of providing these these guarantees to clients. If you do connect UDP, don't change the local IP unless that connects to a U. P. thing times out or is is torn down. Right? I think so I I don't know. So as it as a sort of presumably, this is not written anywhere today. I assume. Yeah. Of course. So I think I guess the question would be, like, Sorry. So today, if you do 2 separate regular connect UDP requests, they might end up with different IP. And that's a feature more than a bug. because from a privacy perspective, they could be different browser tabs. But if you do one connect to UDP listener, it is guaranteed to have the same external IPN port. because, like, the protocol doesn't allow you to encode it any other way. So It might not be explicitly written. It's an unwritten assumption that I we should totally write down. But that's definitely for Connecture DP listener. is that. I agree that in some cases, an app might get very confused if it if multiple sockets end up on different IP addresses, that becomes a policy thing that we just say in, you know, the kernel wherever. those will comp on the same IP. But if another app does another connect UDP, it'll get a different one. That that becomes a policy choice on how much privacy versus app compatibility issues we wanna go. But that there's a slider we can turn here. Yeah. Sorry. I'll just go through the last slide real quick. and"
  },
  {
    "startTime": "01:12:00",
    "text": "then we can discuss a little bit. Yeah. so so another thing from 3rd is compressing like, as you saw, like, we had the IP in every diagram, we could he could compress it and copy of a they would turn those for channels. So And that's what it looks like in turn. Yeah. I think that's it. Eric, you can go ahead then I'll Yeah. I mean, the bad news, right, is that you need to do that. Even if you do that, still have the quick packet overhead, which is substantial. and So I was like, yeah. Yes. You should. But, you know, it's still I mean so churn channels were done to save what? I think 36 act tests And if I remember correctly, with a quick short header and the integrity check, you're, like, 20 right then and there. there's probably some and there's a guy some framing garbage. So you gotta you're probably, like, 24 or something, like, even if we compress even if we even if this were, like, 0 length. So So, yeah, it sorry. Yes. You should, but it's it's still not not amazing, unfortunately. Yeah. So I think I I don't know. Now, I mean, things I think we had changed in that, like, you know, audio video conferencing were common now that it used to be. And so, obviously, you can pair up the video pack the audio packets. So so it's certainly worth doing, but I just, like, wanna wanna wanna say that, like, I'm not sure how great an audio like, audio conference on a low bandwidth network of returns is gonna over over over a mask as well. But, yes, you definitely do this. Can you just go back on, sure, on 2 more slides on the the we have this question about explicit one more maybe. But, you know, they split it Yeah. you you were saying what you wanna do on a on a create your message. Right? So just to be more history lesson, the reason turns a separate message is because turn send data indications to send indication or not terry Griffith. And so they didn't wanna accidentally create hope pinholes in the in the turn relay firewall have authentication."
  },
  {
    "startTime": "01:14:01",
    "text": "and the control message are. So you don't need to do that here. In this case, you could just have it as a side effect of ex if excellent in the packet. 0 needs to have a message. And I think that partly aggressive is not not not completely point Lorenzo was making earlier about the pain in the ass of keeping the pinhole alive if you decide to go that way because You know, as a practical matter if you're, like, on a video conference. So ice requires you actually to to send packets every so often anyway to keep the connection alive. So it's like a standardized stack be perfectly fine in this scenario. with with, like, 5 minute timeouts, but any explicit connection open connection reopening. So, now, of course, are nice. It's different, but, like, the bottom line is once you have absorbed this, like, a go through maps anyway, I gotta connectional life, then it will watch just fine if you just have it be a side effect. yeah, we'll just do the last one because I do wanna do a adoption call after. So, that's that's that's request adoption, I guess. Yeah. I I guess just what yeah. Sorry. So so I guess the one thing that to think about is David's point was like, well, if you want if you want to to keep, like, an IP address a constant IP address let's say, for app. Right? So the apps don't get confused by this. sort of has to mean that the the client is somehow in control of the IP address that it wants. Right? Right. Right. And that's something that, you know, I assume that you'd need protocol changes to communicate that to the server. And so while I while I can see how you would say, oh, yeah. Like, here, 2 different apps on my Android device should have 2 different source addresses because whatever IPV6 source address is plentiful, that's great. but that means you need this other pipeline to communicate that. And communicating app identity does have, like, I suppose, privacy implications that we'd have to, like, carefully consider. Right? So I guess one question would be, Again and and I don't think it's great to have apps just find out in the field what any particular server does. I I think it's important to for our compatibility to have service, like, at least played by some agreed upon set of rules or at least the app can say, give me a stable IP address or give me the same one that you gave me before, at least. Right?"
  },
  {
    "startTime": "01:16:00",
    "text": "So that's something where we should really think about. I I don't know if it belongs in this off. I I feel that it might because I don't wanna slow everything down, of course. But, like, I feel that it might because when you say, like, give me a connection give me a a connection that can be used to receive stuff as well. think it's important to say, okay. Like, here's this is gonna work for And, you know, I think it would be And I to be honest, I think it's great that we are thinking about. doing this. to support internal connectivity. So hopefully, we can get something that works well. I think yeah. I agree. I think it's for discussing. So So regarding adopting. done? Are you all Yeah. I think I think we're all done. Oh. Oh. Oh. there's some Yeah. Yeah. Actually, I'm seeing some useful case for your draft here. in the 3gpp for the extension on the ETSSS, talking about the IP quick. that is going to have a proxy it's like a mask of property running on UPS. That is like last hop a router from the 5 gs. So for the m p quick, that the from the the and then to the UPS there. And going through the the HTTP on the UPS. So I'm thinking here if you have your work. from my side well, from the 5 g s side, This is a useful kind of, like, say, from the u e to the UPS, you have empty quick. I don't know. Maybe there's 3 passes or water passes. and the proxy on the UPS and go beyond. So I can see some benefit from your work, but I don't know how make a perfect there. just give you a set of scenario. Okay. Yeah. This is a good car. Thank you. Thank you."
  },
  {
    "startTime": "01:18:00",
    "text": "Hi. Alex from Oshky Google. I wanted to answer some of Lorenzo's concern by pointing out some of the observations that I have between connect UDP and connect IP and connect UDP listener. So if we go and take a look at some of the features that we've been discussing here, And one of the things that we intentionally did in the way that we have designed being Connect IP itself is that there's actually a substantial amount of overlap in this feature set those 2 existing So, for example, in connect IP, do explicitly have a facility for please give me an IP address that I previously allows you to have multiple streams or multiple connections even. that can share an IP address. This particular feature that Abi has been presenting to us today is a feature which overlaps very nicely between the existing feature set of connect VDP and the existing feature set of connect IP. you could accomplish exactly what Abi's draft proposes today using the connect IP machine. with the IP restrictions and the protocols and everything else that we Yeah. So, like, And I'm not saying we should do this, but you could imagine This is a special case framing of a niche connect IP spelling. And if we wanted to go and apply some of the lessons from Connect IP to draft, we could basically go and exactly create the feature sets for want a stable IP address that you've given me before. let the apps manage at themselves and have the identity and etcetera, these sort of questions of non issue. Right? because you also end up having the ability to apply some power on the server side where it says, oh, no. No. No. No. No. No. I've already given out this IP address on this one existing connection from the same device. I'm not gonna give a different unique connection, then you can imagine having the pooling be happening So The way I would suggest people think about this is don't think of this as extension, Think of this as an extension to the mask family of protocols that currently has its primary set or UDP. How do we arrange the capsules that we have? amongst of a different variants of mass protocol feature family. in order to be useful more general. Thanks, Alex. Alright. So other than Yeah. The"
  },
  {
    "startTime": "01:20:01",
    "text": "the features we discussed, I think, those are worth, like, discussing upon, but I think I think everyone raise that there's a need for this. Well, we'll let the working group, but Doctor Cole assessed that. I don't see strong opposition to. Alright. Yeah. So this is another another item in the especially in the charter now. and given the comments and support that seems to be in the room here, I'm gonna do a quick show of hands if there's interest in adopting this as a working group item, and, of course, we'll confirm on the list So the show hand should be up now. pilodaux@newmeasure. Okay. This is be going one direction. The go away, we can note 37 to 2 in favor of adopting it, 38 to 2. Now we'll confirm on the list Thank you. I'll be in the interest of time. Let's move on to the rest of the presentations. Thank you. Thank you. Oh, yeah. Tony. configuring proxies with DVDs. It's actually quite honest time we have 15 minutes. Alright. Hi, everyone. So this is a document that I actually submitted to Under in the area. I'll be talking about it in the interior working group meeting later. this week as well. but it is"
  },
  {
    "startTime": "01:22:03",
    "text": "very much related to mask and the motivating use case that we've had for it is discovering mass proxies as well as discovering properties about them. And last time, Yukahama, we did have a discussion kind of about just the problem space for proxy discovery. And so this is just one proposal in that space. So I'd love to hear people's thoughts on this. Alright. So there are a couple different use cases that this is trying to address. that are all configuration discovery related. So 3 different use cases that I'll walk through are a network provided proxy, and how do we discover if that is present. Think about know, like, you w pad and terrible things like that. as existing practices where we have network provided proxies, but is actually related, you know, earlier. Someone was bringing up at the mic line. ATSSS or cases where yeah, your carrier network may have a proxy that's trying to use for some purpose of course, you know, through various 3gpp mechanisms that could be done. but that doesn't necessarily apply on other networks and perspective is that it would be nice to have an IETF standard across all different number types that would allow us to learn about the presence of a proxy that is on the network. The other case is discovering what proxies are related to a proxy you already know about. So maybe I know about a just a plain old connect proxy, and I wanna discover does this support Connect UDP and Connect IP, does it do other cool things or not? And then there's another use case of do I can I learn something about what the proxy applies to? Like, maybe this is"
  },
  {
    "startTime": "01:24:02",
    "text": "maybe this is an open ended proxy that has been connected to the whole Internet, or maybe it's very specific and here, there's a case for example, like, in the enterprise type use case, we've seen there are now use cases where, like, Cisco and others are deploying, like, remote access solutions with mask, essentially, there's, like, a VPN replacement And in this case, you may want to dynamically know what things are accessible or other properties about this proxy similar to what we do in IQV 2 for learning about split DNS. configurations. Alright. just to get some pictures, on here here's kind of just a diagram of the network provided proxy. I'm talking to some servers. and the network has some proxy that I may or may not want to use How do I know it's there? That is One question we could help answer with this. We also have this case of I am configured with HP proxy maybe you know, I just had some old proxy configuration that just let me put in a proxy name in port, and I'm using HP Connect, and I wanna say does this thing support connect UDP? Does it support connect IP? Does it support connect TCP or, you know, some other variance and other URLs, how would I find those? similarly, how would I discover that, oh, this proxy is actually only good if you want to access these particular internal domains, and, otherwise, it's not gonna let you get to things. So there are existing alternatives in this space, as I alluded to, like, there is W Pad, and there are pack files. if you wanna do DNS to your local network and get a JavaScript file and run that figure out what proxy to use. You certainly can. but -- But these are things that are not actually IETF Standards."
  },
  {
    "startTime": "01:26:01",
    "text": "they require JavaScript parsing and running lots of fun code there, and they have a lot of potential security pitfalls. And, also, they don't work with the current mask proxies or other more URL based proxies. that could be fixed. We could try to extend pack files to not just return host name in port and know about connect UDP and connect IP, but The I don't see that being particularly likely, and that seems, like, not necessarily the place where we want to invest. So so I would like to avoid going down that road. this document is talking about using provisioning domains, and so what is a provisioning domain? So so so so so is one of the reasons why this initial draft was targeted at inter area. So these PVDs came out of both the multiple interfaces, MIF working group, but we also did a lot of work within interior, to define them. So there's RC 7556 that talks about provisioning domains as consistent sets of information, think of just like, oh, it's your devices cell network configuration, your Wi Fi network configuration, a VPN Configuration. and rch8801 Defined discovery of explicit PVDs that are named PVDs, from a network so a network could say, hey. This This particular uplink has this named provisioning domain, And, hey, it supports getting extra information from this JSON dictionary that served up in HTTPS. And so that is one place we can hook into. So it defines think of the PVD as a definition of some JSON dictionary that defines a bunch of configuration about some particular network attachment."
  },
  {
    "startTime": "01:28:00",
    "text": "what is a PVD? As I mentioned, it could be you know, a particular uplink on your home WiFi network. It could be your carrier network configuration. It can be PN. And it can also be a proxy because when I'm going through a mass proxy, that massproxyuplink is my tunnel, it is my provisioning domain. It's the way that I'm accessing hostnames and all the different properties. So it too conceptually is a PVD and has PVD information associated with it. as as as a philosophical statement here. So practically, the document's doing 2 things. There are 2 mechanisms. So one, is if you have this pvd, json blob, it allows you to like, there are a bunch of keys that the original RFC define, and it just adds a key to say, Here's a list of associated proxies that are that go along with this PVD. It's just an array of strings. And the other mechanism is allowing you to fetch this PVD JSON blob from a HP proxy. So, like, you know, just how I actually fetched that thing instead of fetching it from what the network told me about. So pretty simple. So here's an example of the dictionary, let's say, I get this from the network, and it could list out a bunch of URLs of proxies that's associated with. Now, one of the things here is that this is just defining a list of URLs, and it is in this 0 version, having the implicit what the type is. So, like, if you had a SOX proxy, you would do, you know, SOX colon slash slash whatever. and for the other types you would infer it based on the URI template. So since Connect UDP has a particular URI template. If you see the variables that you use for Connected UDP, you'd be like, oh, look. This is a Connected UDP, sir."
  },
  {
    "startTime": "01:30:02",
    "text": "If you don't see it, you assume it's a normal connect. server. So this is one way of doing it. we certainly may want to have it be more explicit. You could have some nested dictionary format where you have a type explicitly saying, oh, this is a connect UDP. This is a connect IP. This is whatever other types we'd need more of a registry or something than that's one point I'd like to get feedback on. So And then for the other piece of the mechanism, PVDs already have their own media type, and when you're on a network, you just fetch them from a particular well known based on the PVD ID. And so this is just applying that media type to say, if I do a get for the PVD media type to the URL of a known proxy If it wants to respond by telling me this blob that tells me other associated proxies or the list of DNS zones that it's scoped to, it can return that to me Otherwise, it won't if it doesn't support this. But this is something that if you had existing connect proxies that wanted to ad support for connected UDP and other things. They could just respond to this get and then tell you, hey. Come use all my other fancy new versions of proxies, and that's how you can bootstrap the up rating there. For example, on split DNS zone, split DNS. PVD has already defined the DNS zones array, And so the proposal here is just reuse that As if you wanna specify specific internal domains that your toxies associated with. Set them otherwise don't. And I think this just leads to the fact that this is a somewhat extensible dictionary where you could add more keys. So if we had other properties in the future where we wanted to say, oh, yeah. You need this authentication or maybe even for the"
  },
  {
    "startTime": "01:32:00",
    "text": "know, the ATSSS cases for you through GBP, they could put other keys in here to describe how you're supposed to use it for them, like, this is one place where you could put that configuration information. Alright. So These are generic slides. So, like, is something that maybe we wanna target it. Interior, since it's really generic about how am I talking to networks about discovering my proxies, It is something that maybe we could Talk about more in HTTP. also, I think it's very relevant for this group to at least get the reviews and opinions of I'd also be curious if anyone wants to do interrupt testing on either the network discovery or kind of the bootstrapping an existing proxy to learn about other capabilities, It'd be interesting. So yeah. Yeah. feedback thoughts, questions. Hi. Mike Bishop, Akamai. Two things I wanted to comment on First off, this is very similar to the draft that Ben Schorr presented the last couple of ATFs Yeah. It's a spirit it's spiritually in the same vein. it's trying to use the underlying PVD stuff. Yeah. Like, Just Maybe these proposals could be merged. because that's been looking for a home Yeah. I think this is moving the right direction, and it's an important problem. I'm really kind of leery of putting this at particularly the root resource with a different media type and trying to switch on that. I really for really to see it at, like, a dot well known URI. But the overall structure, I think it's good Cool. That that's good. And and, like, again, PVDs actually do have a well known already allocated to them. So we could say, like, if you have an old connect proxy. You just fetch it off of the well known maybe that's good enough, and I'm totally happy to go that route. Alright. Who's next in queue?"
  },
  {
    "startTime": "01:34:00",
    "text": "I can't see from here. It's me. Hey, Lucas Pardu. So I think something like this like, config is, like, us the no brainer. We need to do it. otherwise, you just kind of manually configuring things and and outbound signals, and those are quite annoying. I haven't read the latest version at this back, but something that came to mind is some of the difficult is I've had trying to configure my stuff is I'm speaking to a proxy, sometimes they want some form of authentication. Sometimes they don't, and I don't know if that was in scope for the config that you had. which made me wonder then. we have things like unprompted or that you don't wanna put those in. So Maybe just there's nothing in the draft already, considerations. So there's in fact, could be useful but that, you know, doing that work in working groups would help us have those discussions and figure it out Yeah. Absolutely. this doesn't talk about authentication explicitly. However, I mentioned, like, there's just like a blob of configuration. So if you would if if you would like to advertise to the world, you need this authentication, someone could define a key that put in that dictionary, And so that's either in this document, some other and you can just register keys the registry. it's already existing. I want only one of these things. to exist. So please. Yes. Please. Don't Which one? -- in don't do this in interior and have have been go off and do it in privacy pass or what it what -- Yeah. Yeah. Yeah. Yeah. Oh, you mean, 11 configuration mechanism. let's let's not have that happen. Totally agreed. other thing that I The find a little unclear in a lot of these things is is that the trust relationship hasn't really been articulated particularly well. One of the things but I think has happened in the past that has been terrible in this particular area is that they would be an expectation that clients would stumble around the network and"
  },
  {
    "startTime": "01:36:00",
    "text": "and trip over one of these configuration files and then just use Right. And -- Absolutely terrible. -- that is has has not worked out particularly well. and I'd rather not see that happen. So I think a little bit more thinking about how it is that the client is configured think Lucas' point about authentication credentials is a good one. probably don't belong in here. But that means that there's something else that's floating around that that is more than one piece of information that's potentially multiple that says, The identity of the thing that you're talking to the unborn identity of the PVD, in this case, credentials that you might use, and what you might trust that PPD to provide for you. And that is not a simple Trust. not trusts, thing. It it's Nuance. So -- Great. I don't know what to do with that. But having a clear sort of articulation of how you would use one of these things along those is for Yep. Totally agree. And that's something that doesn't go into detail on now, but that's one of the reasons to have a clean break from pack and WPAD and say, like, this is an opportunity to specify better Trust model. David's Ganazi Proxying enthusiasts. This was short on time. plus one to everything MT just said. Let's do this in Ontario and bring in Ben. Yep. Yep. Great. Great. Spend. I know he's been here. Mikulemon. Yeah. So that looks good to me. I have one question and then a comment. question is this is mainly focusing on you already know that there's a proxy. You want additional information. Right? or do you also include the case where you actually want to find the proxy by getting information in your local provisioning domain about the proxy. There's both. So It In the I think, also, the trust model is easier there. Like, if I already trust this proxy for Connect, and I just wanna know, can I put UDP through it? That's not too big of a deal."
  },
  {
    "startTime": "01:38:05",
    "text": "And similarly, if I already say, I would be willing to send you everything under my you know, like corp.example.com, and you wanna tell me that you wanna take less of it Fine. you know, that's also an easy trust relationship. then the other case is when that PVD comes from the, like, the network RA, But then it's like, I didn't know about this before, and then the client has to decide do I want to use this And so there's a lot of different ways we could approach that of, oh, this I was expecting to find something here, or I this is a in a PVD that's already on a approved list of ones that I trust, and, therefore, I can use it. Like, But, yes, this does cover the discovery from Okay. Tableurasa. Okay. That's great. And then about in there, I guess we recharter, and we didn't include this 1. But I also feel, actually, this is the right group to to discuss this because we have the expertise about what we need. Right? We bring it into into area, then we all too there as well or whatever. I don't know. So I'm not sure about this. It's like, We should definitely have a discussion about the correct venue. I I don't feel like it fits within masks specifically because, like, even things like TCP proxying, over HTTP, like, Ben's draft. Like, that went into HDP. That didn't even go here. Like, our charter here is pretty narrow on, like, what's going through the proxy. And this is potent like, you could use this for socks. discovery. And, like, work on stocks has happened in Ontario as well. So It's quite fuzzy. So So our charter has a line in it that says discovery is explicitly not in scope. But we certainly are happy to run the chartering mechanism around as many times as we need since we are So in the interest of time, past our time here. Carl, I saw you join the queue after it was closed. You have something really fast, does All good. Cool. Next up we have Alejandro. We will come back around, and and I think we need Nate with Interior and and some of the other groups to to make sure that we find the right home for this. there's definitely interest in doing this work"
  },
  {
    "startTime": "01:40:02",
    "text": "as it stands right now, we we said we wouldn't en masse. So we need to figure out if we want decide that we do or if we want somebody else to do Click the little slide button. next to the hand. Yeah. We'll go a little snappy if we can. Alright. here to talk about a draft I've been working on for proxying Ethernet over at UTP. Connect Ethernet. There we go. We've already got stuff for layer 4. We've already got stuff for layer 3 in the pipeline. I figured Why not go deeper? So, yeah, Connect Ethernet. don't know if you've all read the draft. I This is Not the greatest response here. So Why do we need connect to Ethernet? because sometimes IP isn't enough. You wanna do stuff with non IP protocols. You wanna bridge Ethernet segments. it's useful to have a layer 2 solution when you need it. and not use it when you don't. preferably. There are other things you could do like, nesting other layer 2 solutions inside of connect Ethernet. but Then you've got"
  },
  {
    "startTime": "01:42:00",
    "text": "more loss of MTU. You've got more things to configure. So I figured it's a useful thing to have in the toolbox to have layer 2 option available. How does it work? yet take the Ethernet frames. You put it in the datagram. It's a lot like Connect IP. and it doesn't have any of the IP routing logics that is required for layer 3 stuff. So it actually is, like, a watered down layer to wire water down connect IP. And I landed one in Google's Keish. Sorry. Flat floor. yesterday. I've been toying with one for month or 2 now, and figured I should land it. I did. I swear there are more slides. It's a 00 draft. There's plenty of work to be done on it. The question is, Is there interest in doing that work? and like like like, Yeah. Erica Scrola, I have no idea if there's interest, but I'm I'm just to be, like, my usual broken record on this. there's been a lot of work on on on tunneling for Ethernet and other other other venues, I seem to remember, reading some some some more things when I was in the ASG. Has somebody, like, reviewed that material to make sure that, like, you're you've doing learned whatever lessons they had to teach. You're really bad. If if not, I would suggest it. I really have no opinion on the on on on the merits, but I'm just, like, there's been a lot of work here so, like, it'd be good to we have to, like, you know, either supposedly said rejection, I think."
  },
  {
    "startTime": "01:44:00",
    "text": "have certainly started I reading through, like, the L2TP -- It's, like, p v 3. Yes. It's, like, just a pile of crap. Yeah. You know? I I'm not sure if it's really good or I have started reading them. I have not finished reading them. Yeah. Yeah. Yeah. Yeah. But, yes, Okay. Yeah. Anyway, I I I I I if if there's I mean, like, why not mask everything? But, like, what what's Exactly. Marcus Seeler, Ericsson, yeah, I think there's definitely interest from us to adopt this. in fact, 3 dpp are for Release Nineteen discussing the potential using ATSSS for Ethernet PDU sessions. So this proposal comes in very, very handy right now. So definitely and I agree with Ecker. We need to do a lot of analysis for this. Oh, yeah. Watson Lad, Akamai. I guess my main reaction to this draft is Why? Just because you can do it doesn't necessarily mean it's a great idea. Is there, like, Is there, like, some pressing me to link up Ethernet segments like you have some ancient sheen that can only talk to locally connected things he wanna expose his Internet now that doesn't really seem like necessarily a great idea. I just had a curiosity. Like, Heath and that generally not be rooted. Right? Like, what does this mean that the mass proxy needs to be on the same Ethernet segment the thing that you wanna talk to by ethernet. Mhmm. Seems kinda difficult to deploy. Right? I mean, not impossible to deploy. I I got that, but kind of, like, reduces the scope I so for example, I've Yeah. I use this thing to bridge a box to my home Ethernet segment"
  },
  {
    "startTime": "01:46:00",
    "text": "Just this weekend. I'm not saying that this is something that everyone needs to be using all the time. but if you do need to do some sort of Ethernet bridging, if you need to do some sort of layer to for something. like like like Then it's useful. me. I could have been just talking about the ATSSS use case, so their desire is just to have a generic solution that can kind of handle all kind of traffic rather than having specific solutions to, like, different kind of traffic because that's like just a mechanism for providing additional connectivity in the mobile network, and so it has to be as generic as possible. Hi, Alex from Oshky Google. again, here to address the Lorenzo's question. So I I think that the deployment question is that this is a technology which is a different than the rest of mask connect family because you're probably not going to be running an in a, like, industrialenterprisegrade Ethernet proxy and then letting people connect to it. I actually see this as much more useful for you are interested in enterprise use cases, things like when you want to have, like, a trusted top of rack route needs to or something like that. So, like, see this more as you want to bridge an Ethernet segment to something that's much more begin, actually, like, have much more encryption on your network rather having some of these legacy protocols that we use for bootstrapping and executing other things I mean, this is obviously also useful for the device might not be able to detail as Your your your mixing your top rack router over your WAN certainly be encrypting your traffic. And, like, I can tell you for certain that Google, we have had lots of pain and suffering doing net food for our edge network and having trusted, VPN like things that can do layer 3 has been a and I'm sure layer 2 will make it even easier. So I think there is actually a lot of use case here, and I'm very excited to see"
  },
  {
    "startTime": "01:48:04",
    "text": "Does that thing? Yeah. My pleasure. haven't haven't read the your document, but Are you talking about multicast and broadcast kind of traffic can needs to be done in this space. There is a spot for it. I haven't dug into it. Mostly, I have been receiving things over the quick tunnel and dropping them on a It's a ton or tap. I always forget interface and letting the kernel deal. So there's probably some more work to be done there. Again, 00. see. Yeah. You're all set. you. So this draft showed up a little bit later than the a right after the recharter was done, and unfortunately, we did not include this extension is one of the ones that the working group would cover. Although, after talking with Martin, our glorious AD, said be willing to potentially do a quick recharter update f people did want to include this as a working group item. So Just like the other drafts, I'm gonna do a quick show of hands see if there's interest in adopting this as a working group item. Under the assumption that we would be able to get the charger done quickly to update it quickly to include this in the list. So Yeah. I'm gonna run the show of hands now. Same exact question as before. interested in adopting this as a working group item. assuming the charter were accurately flexible after the fact. And if anybody is actively not raising their hand and would share with the group any of their thoughts or reasoning about that."
  },
  {
    "startTime": "01:50:00",
    "text": "you're more than welcome to do so. You can also happily anonymously, not raise your hand. So Yeah. This one's less clear. definitely gonna have to confirm the list, but I wonder if anyone who did explicitly not raise their hand, and the show of fans wants to come to them, like, and and and say why. don't think this is ready for adoption or is a good candidate for adoption. like, like, be quite useful. We definitely need some music during the show of hands as well. That would be great. Okay. Watson? Yeah. Watson, I my reaction to draft is I just don't see a use case yet that justifies investment at a time. I'm sure they're out Everybody just haven't heard one yet. Sure. Sure. Lorenzo. I'm not gonna repeat what I said before. I just sort of as a general question, What's the cost of adopting this to the group, like, if it's gonna chew us chew up resources, then they then that we should really consider carefully. Right? You know, if he's gonna take review bandwidth or whatever, if we can do this for free, Sure. But, you know, I that that's sort of that to me would be the main Right? Like, there there's does seem to be concerned about, like, limited applicability But I think there, it's, like, more like, okay. How much is this gonna cost the working group? The good point is one of the reasons why we only included Yeah. to to to very explicit extensions in the charter right now because we didn't want to burn the group with additional scope and, like, dilute our focus. So We'll definitely take that into consideration as we consider adoption call. Yeah. They're nagrin Akamai. on on think it's, like, the concept is interesting. I think I agree on the understanding use cases, and it may be one where rather than re chartering, it may be worth having conversations with some of the other ADs, like routing area to see if there's another place for this."
  },
  {
    "startTime": "01:52:01",
    "text": "Like, there's enough overlap here in the corner cases between things like EVPN and various and the and the x line and other things and not routing area space space that that that with probably wanna at least be coordinating with them closely. we're gonna if we're gonna do something here. coordination would make sense in that particular point. Yeah. Okay. I think in the interest of time, we'll move forward. Eric and I will can talk and him will will what guess, what this maybe do the devotional after the fact. Sorry. Oh, yep. And, Marcus, you are last up for sequence numbers. Slide Alright. Gonna talk about sequence numbers. done it a couple of times. So probably be a quite quick presentation this time. So we have talked about it. We talked about it last the IETF. There are not many updates to this document, but pretty much just added a bit more background because that was pretty much lacking last time. So little more description of what ATSS is, ATSSS is, and some motivation, why why there are use cases in AT and T suggest that require the use of something like sequence numbers. a little bit, but a little bit recap. This extension. We're just extending HTTP Datograms with adding a a small field with a sequence number, is intended to be used with 3gppat triple s. in this specification, of the 8g through plus. They define these data gram modes where you So a HSBC is a way where you"
  },
  {
    "startTime": "01:54:01",
    "text": "You split traffic over multiple accesses. You can do it in various ways. You have various steering modes. can duplicate traffic. You can to bandwidth aggregation and and such. When you do use some of these modes, you might wanna have sequence numbers and we define them as datagram molds in this specification. one datagram mode is without sequence numbers. 1 is with sequence numbers. So The wire format for this is not specified yet. The architecture is specified, so there is a document that can either specify the wire format for this or point to an IETF specification. We would like to would like it would be nice that we point to an IETF specification for this because it's an IETF protocol that we're modifying. So Nowadays that this can be pretty useful for multipath proxy scenarios where proxy payload is either duplicated over multiple paths So you have a redundant steering mode, where you kind of split the trough or You copy the packet. packets. You copy the payload over multiple paths, and then you have to sort dedubicated on the other end. So kind of redundancy mode. And you also have the mode where you do kind of a load balancing. You're splitting the traffic over multiple paths. the and then you wanna sort of have the risk of causing a lot of out of water delivery, and it can make sense to to use some sort of sequence numbering to to assist with getting the packets or the data back in order before forwarding it. So that's the use cases. And Where did this thing end up now? Oh, there we are. So we've had a student working on on this who so we implemented this over a a prototype of this sequence numbering over a mask proxy using multi path quick. And so we have a few very, very early results looking at like doing some reordering for not for the duplication case, but for the"
  },
  {
    "startTime": "01:56:02",
    "text": "for the traffic bandwidth aggregation case, and we just look at some measurement data on that. It's a very it's a very early measurement. that this guy's done, and there will be more refined measurements or refined methodology. But What we have in place here is a very simple so we have a proxy running have quick. We have a very simple round robin scheduler. so we don't do any particularly smart scheduling here. Then we implement a small reordering buffer in the mass proxy with a static size. So you just define the number of packets. And then the end to end traffic is quick that uses the very basic specific the very basic parameters from the RC 9 1002 specification. Namely, we have a packet reordering threshold of 3 and the reordering time threshold of 9eight's of RTD. And we don't have any dynamic sizing of the reordering space. So it's it's it's a very it's kind of the bare minimum you do with quick. and it also runs renoconjection control, which is loss based? So this the emulation setup looks like this. We we then have a We have a client that connects to a multipath proxy using mask. connects to an end end server using quick. these different delays, and then it uses a very basic scheduling approach then. Mhmm. It's a little bit slow. k. So some stuff we saw here, we like, we have a very, very basic buffering scheme here, so we're not looking at delays. And so as we're just looking like static static buffer sizes with packets. We're running at very, very low throughputs here as well. So Just adding one more packet to this to this buffer cue makes a big difference. So what we're looking at here is the impact on Good Put, depending on the size of the buffer. So if we have 0 packets in the buffer. That's, like, the the most extreme. And to the right, we have running everything encoded in streams instead of datagrams. and then we just look at the impact of good put."
  },
  {
    "startTime": "01:58:00",
    "text": "we see that, yeah, it starts leveling out that at a buffer of around 10 packets here. So we see We see that there is for for this type of setup, there's some improvement by by doing some buffering and doing some reordering in the proxy. Mhmm. Furthermore, we're looking at what's the impact on on runter times when doing this. So Basically, we see that having a small Small reordering queues has a very small impact on the end to end round to time that the that you see in the end to end connection. We do see when you start adding more and more packets in this buffer, it it grows a lot. And when you're on stream mode, it just explodes. but that's because when you're running stream mode, you you if you don't have any sort of back pressure in how you're writing data from the outer connection to the inner you will just swamp up a lot of They dine your in in your in your proxy connection and yeah. So you can do smarter things with the Stream mode, of course. we see that yeah. you don't have much impact on the round trip time? Finally, we we we're looking at some congestion window plots here. So If you have a very Yeah. if you have a very small buffer, It's a it's a lot of stuff happening in there, but we see we see a lot of spurious loss events. like Spears loss detection due to to the lot of out of ordering. And and we see that the congestion window is con continuously limited. we see that the outer connection is the limiting factor bigger the buffer we put, the the better the better it becomes. We we see fewer congestion events. We see few fewer spurious loss loss events and Yeah. Better utilization of the link. 6, want me to help you out for a second? for the drafts because there's always for each of the scenarios, there's two graphs here showing either either of the path Right? So the green line is the end to end congestion window."
  },
  {
    "startTime": "02:00:04",
    "text": "blue line is pass 1, and the red line in the other graph is, like, pass 2, basically. So what we see if we only have a buffer of 5 packets is that our end to end connect window a con congestion window is limiting our throughput a lot because we see so many reordering events the congestion window is just, like, very small. When we increase the buffer to 12 packets, it's still the same effect. We see a lot of reordering, but, like, it's just like less reordering, and so we can actually reach the capacity of the link nearly. And then at the at the very bottom at the right, we have this remote as as comparison. that's a maximum community in in terms of throughput, basically. I mean, we have to keep in mind that this is a pretty naive implementation of the end to end quick. We just doing the pure basics there. So there's a lot of congestion events due to miss I mean, treating that out of order packets as loss and then reducing your congesting window and not like, explicitly recovering from that when you detect that or we don't even look at detect that there's spurious and such. So there's a lot of stuff you can do on the end to end. But in the pure basics, yeah, we see that. we we have pretty big impact. working. you go back to the last slide? Can No. Apparently not. So trying. The the stream mode Yeah. Yeah. Yeah. really destroyed that graph for me. because it's so far out of whack. Yes. Yes. Right. I think your claim about not increasing RTT I mean -- Wrong. You do increase it. Right? But but it's 20 20, 30% is is is is the lot. And so what what we're talking about here is is Effectively, ATSSSSSSS is No. No. I don't know how many there are. is is talking about a way to build a network that degrades performance, pretty pretty measurably here. and I'm not sure that I'm entirely happy about that. and and"
  },
  {
    "startTime": "02:02:01",
    "text": "I think just sort of glossing over that point is some not really very honest here. So Sorry. But a I think 20% at 10, which is the the point at which you're you're talking about, is pre pretty significant. Yeah. Oh, if yeah. In the blue line, yeah, it's it's definitely significant We're focusing more on yeah. For for sure. It it has an impact here, and I think Again, this is, like, very early results with a very basic very basic scheduler, like, pure run robin scheduler. for sure, you need you need to do you need to do better than this, that I fully agree. Yes. We are overtime. So, Lars, if we can move through the queue. We're trying to leave time to drain the queue, but we are technically a negative time at this point. So Go. Go. Go. Go. Go. Go. Can I just explain the graph? Very quickly. So, yes, we realized that we didn't display very well. but it was too late to change it. But so the baseline is the 0 is, like, without any buffering. Right? So you have to compare it to the 0. And then, like, have to find the point of time where Like, you you you have the minimum buffer requirements. So for like, the blue part, it's around, like, 4 or 5 packets where you want to configure your buffer. And for the raw orange one where you have, like, a higher throughput link, you would go to, like, probably 10 or something. Yeah. So that's what you have Yes. Exactly. It's the difference between 0 and 10 here that we're looking at. So that The 0 is when yeah, for the orange. Right? So the 0 is the base case where you don't have any You don't do any buffering at all. So Large record. So so I think it it's This is pretty bad, and it's it's even even if you're very low, bandwidth here. Right? Because if you actually use useful bandwidth, you're gonna need a whole bigger buffer you are you're a delay numbers are gonna go up because they're proportional to the re reorder buffer sites. Right? So if you use a gig, for example, instead of a make, would the numbers look like, and I think they would be looking pretty bad. what the the Right? Nope. Nope. Nope. Nope. David's next in the queue."
  },
  {
    "startTime": "02:04:03",
    "text": "we have a queue. The queue is closed. I mean We are over time. the question. Yeah. But take it to the list, please. I understand. David, very briefly, run a quick show of hands, and then we're gonna wrap up with Martin Duke. Very briefly, This is a performance enhancing middle box We've seen them in the past where Back in 95, when you had a box that removed reordering, it actually improved performance because TCP Stacks weren't smart. today are on transport protocols, especially if you're using QUIC quick is the best. Real quick, we'll handle reordering much better then handling delayed like, this delay that you're introducing to fix the reordering. So I think anytime you have a transfer protocol over this that's re from this decade. this will make things worse instead of making things better. So I'm quite concerned about Yeah. I mean, we see here. We're we're running quick here, and depend and it's running with the base parameterization that you have for from rpc 9002, and we we do see the problems. Right? So Sure. You you you can do a lot smarter things on your endpoint. Alright. To wrap up here, just as a data point, we'd like get a show of hands from folks in the room, and we can then use this to decide to take an adoption call to or have further discussion about what we wanna do here. click the raise hand or do not raise hand before you put your laptop away. and then start putting your laptop away, and Martin wants to wrap up with a few words. Yes. Thank you, Eric. I just go now? Yeah. Why don't I just go now? Why you? Thanks. Barton Duke Transport Area Director. Just wanted to tell the community about a unfortunate scheduling conflict in this time slot at dispatch, Matt George from Meta presented something called SADCDN, which has nothing to do contact content delivery networks, is securing ancillary data for communicating with devices in the network. he was very interested in in having the mass community attend that dispatch, but we could not work out that scheduling conflict. So invite you to go to the"
  },
  {
    "startTime": "02:06:02",
    "text": "art area session info sorry. The dispatch session information and either read the draft or watch the YouTube video of the meeting and comment and participate in it. Is there a side meeting too? Excellent. Okay. The side meeting tomorrow at 6. So look at the dispatch stuff and then go to the side meeting. Thank you. So we're Thank you all, and come grab some stickers."
  }
]
