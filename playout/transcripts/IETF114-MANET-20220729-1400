[
  {
    "startTime": "00:00:10",
    "text": "this is julius can we do a quick microphone test hello can you hear me very well and we can see you as well good all right okay we should get going yep all right good day um welcome to the um joint session of babel roll and man a on multicast routing next chart please you've probably all seen this but just to highlight the note well again and uh so you agree to follow the itf processes and policies um and you're aware of the patent policy and you um as a participant you agree to work respectfully with others and please um take if you have any questions or concerns about this you can take that up all right next chart so um the meeting tips uh everybody here should know how to to sign in and track the attendance and um remote people"
  },
  {
    "startTime": "00:02:01",
    "text": "as well make sure your audio and video is off unless you are are speaking and if you're a speaker a headset is recommended but we did the audio test with some people that didn't have that so you're okay next one uh just some pointers to the agenda and any other information that you may need go on to the next chart the resources for this session have all been uploaded the usual places and if you would um we could use some help with the take note-taking when people are uh speaking if you could do that next all right i'm going to pass this over to ronald who's going to talk about the the agenda part here [Music] hello um [Music] yeah we have a joint session uh with a topic multicast and um i'll give a short introduction and then we go into a number of presentations after that we have some time for discussion and we try to reach some form of a conclusion after that and see if there needs to be any follow-up activity to this and what form that may take so after the presentations are done you're all invited to voice opinions point out deficiencies uh whatever you want to do and then we wrap up the uh the multicast part of this session and as a by the way by the way of desert we have a presentation from julius grobach"
  },
  {
    "startTime": "00:04:02",
    "text": "on exciting new features in the babel routing protocol and that's the program for today just ask for anybody any bashing any questions yes is there anybody who wants to bash the agenda going once going twice then we stick with the current agenda um the idea for this session was born in a conversation that donald eastlake had with uh the routing ids and i suspect with overall in particular because he also hinted at this after the money session at itf 113 and i think it's a good idea the routing ids have seen that multicast was discussed in various forms in all three of the working groups but that not much progress was made now whether all of you agree with that i think it's true for monet but i cannot judge for the other groups um but that's also something that can come up in the discussion um today's presentations uh given by participants in all of the three working groups should make clear what the challenges are why this is not multicast as we know it in the uh maybe in the wired network um [Music]"
  },
  {
    "startTime": "00:06:00",
    "text": "and what can be done about it and if there's anything that the three groups have in common that they can work on and then we see well where we go from there all right we'll come to that later so can you share the other um so first up is my own presentation you did okay yeah but i want to stand over there yeah i'll do the odds right there okay good don't let it go to sleep next one just gonna find your page down button that's all oh okay i got it there so um the last time that monet working group was recharged was in 2016. could you move the mic up a bit i'll hold it in my hand is that better and then we ended up with a work item in the in the charter that says that we were going to continue to look at simplified multicast forwarding which is an experimental rfc 6621 and as part of that work we would produce a well-defined"
  },
  {
    "startTime": "00:08:00",
    "text": "forwarding information base for multicast and some background on how that would look like is given in a presentation that is is lined up in a presentation that [Music] justin dean at the time the chair of the uh my neighbor group gave at itf 96 i invite you to go have a look at the slides it's a very good presentation but to be honest nothing much happened since next slide please because monet in the subsequent years was pro was mostly concentrating on the d-lab protocol lots of work happened with d-lab but the multicast work item got neglected a bit so even before that recharge ring there was activity of course 6621 was produced in 2012. it's not really a full protocol description it basically describes mechanisms for duplicate packet detection why that is needed we will see later it also has three different so-called relay set selection algorithms or really set reduction algorithms if you want which are described in appendices and these make use of information that's already available from a unicast routing protocol monet rather than protocol to reduce the number of nodes that are retransmitting packets there was also some other work that has been abandoned the only multicast routing protocol"
  },
  {
    "startTime": "00:10:00",
    "text": "and um it was worked on by brian adamson from naval research lab on elastic multicast routing and um this was a protocol that um tried to have uh multicast group membership awareness in the routers at certain points in the network in mobile networks that were somewhat more stable where there was not that much topology change and there it could be more effective to use that this was presented only once during itf 88 in vancouver i know that nrl continued working on this but um yeah maybe they will at some point bring it back to the itf next slide please so what makes multicast in minnesota particularly challenging the links can be non-transitive so if b hears hears a and c here is b there's no guarantee that the c can also receive from node a nodes often have only one radio interface and they're relaying to get from a to c for instance and then [Music] they're using the same interface over which the packet was received to to send it out again this has some implications for some existing multicast protocols or mechanisms that"
  },
  {
    "startTime": "00:12:00",
    "text": "do not allow to have the incoming interface in the outgoing interface list or that try to do a reverse path forwarding check based on interface and then there's of course the node mobility that leads to frequent topology changes and it's thought that maintaining group membership on all the intermediate nodes causes too much turn because it has to be updated all the time and hence smart flooding approaches are used but this is uh for me an important slide because it shows most general link model um we have a host where transport layer and application layer protocols are running we have a router and we have a radio separate entities possibly connected by ethernet of course you can collapse this of course you can have a single laptop running your routing protocol in software and using wi-fi as your radio but this is the most general model and this should be supported by our solutions and you can see here uh the note in the middle relays node b and if it does that uh for an a packet that started this live somewhere in node a node a is also going to hear the retransmission again next slide please another assumption is that we are working with radio links that are limited in capacity to the point that you can safely run your unicast and multicast money routing protocols in software you"
  },
  {
    "startTime": "00:14:02",
    "text": "don't need big hardware that's the assumption the links are the bottleneck not the processor and it's also as an aside in the d-lab work that we've been doing and that lua for instance has been working on the assumption for flow controllers that the modem or the radio needs to flow control the router and not the other way around next slide please uh we have a question in the queue do you have time to take it yes okay go ahead so uh i caution us to be careful with this assumption in particular all of the solutions that i that are going to be presented today push all packets through user space on a lot of hardware that's going to be prohibitive even with moderate speed links so i'd like us to be a little bit cautious with the assumption that we have plenty of cpu okay thank you for that my radios may be slower than your radios so a question that has come up a couple of times do we actually need multi-hope multicast at the ip layer and uh in some of the previous uh monet sessions at previous itfs particularly rick taylor has commented on this there are solutions out there and one is going to be presented today by donald that take care of multicast below the ip layer and then make it seem to the ip layer whether that is just talking to a well connected well-behaved single link and everything is one hope away and reachable and what happens underwater so to speak is"
  },
  {
    "startTime": "00:16:02",
    "text": "is not visible to the ip layer there's another technique synchronized collaborative broadcast roughly equivalent to so this is something called barrage relay but that's a trademark of a company called trellisware and that that's true of course but what if you have an ip overlay over heterogeneous radio technology or what if you want to federate monet networks that use different technologies next slide please well then you get into things like this here the nodes a and e both have two radios so they have one lag in one of the radio technologies and another lag in the other radio technologies and you can see that this can lead to interesting forwarding complications where things go looking around and again a solution should be able to deal with this next slide please the presentation that justin dean gave at itf 96 which i referred to earlier listed a number of shortcomings of the simplified multicast forwarding which is an experimental rfc but the only thing that we really have in the money working group implementations are often done in user space which can lead to poor performance for instance the linux kernel doesn't really support multicast forwarding and over the same"
  },
  {
    "startTime": "00:18:01",
    "text": "interface and all sorts of this but that's really uh hennig's presentation that's coming next that's going into that uh packets are disseminated to the entire monet there's no knowledge of group membership because that's considered too much turn the relay set selection algorithms and this goes back to the previous slide do not support multiple interfaces well and it's same is true for the duplicate packet detection in smf and i had to look in the code to see how it works but i think it is per interface um there also some some circumstances where it does not very well work very well if you have multiple interfaces um [Music] recently brian adamson posted on the m a mailing list about their the advances that they have been making they they sort of stepped away from uh the itf and the money working group but they have been continuing their work their nrl smf implementation is on github in the u.s naval laboratory repository on github so you can find the code there documentation might be lagging a bit behind however this has been uh outside the visibility of the monet working group for for some time and uh what's that simplified multicast forwarding um"
  },
  {
    "startTime": "00:20:00",
    "text": "next slide please and that's it any questions at this point we have uh uh we have a person thank you um yeah tahoe or jeffrey from juniper okay um cindy is going to present uh beer in babel networks later looking at the properties of monet you talk about it seems that uh beer would be a good fit for this as well especially when you talk about multicast ip layer over heterogeneous hydrogen generous radio types okay thank you this is something that during this week david lombarder and myself have been talking about a lot i hope that during the discussion david will come up to the microphone and give his opinion um but thanks yeah it's something that i personally don't know enough about at the moment i'm trying to wrap my head around a beer but others have looked at it and seemed to think that it might be a solution so we need to need to do some work at least there thank you okay thanks for your attention you're next trying to find your slides"
  },
  {
    "startTime": "00:22:20",
    "text": "okay i hope everybody can hear me [Applause] it's not something we talk about a lot in the ietf uh but we are talking about protocols the control plane but one of the problems of ip multicast is always the data plane is it has always been and i think this is the reason why we don't have that much work for multicast so next slide so i will be talking only about ip multicast routing on linux i don't know enough about bsd and especially about windows so this is linux only at the moment next what we have been doing over the years yeah we have been doing multicast forwarding in user space next raw sockets everybody loves rock circuits at least everybody uses raw sockets as i think i know three smf implementations all of them are using to some kind raw socket next the good thing is it works you can do multicast forwarding with raw sockets but it doesn't play nice with the other complicated stuff of the linux networking code some raw sockets don't like firewalls and ignore them some raw sockets have trouble with policy routing so if you do multi topology routing or if you plan to do some containers make sure to test that raw sockets don't mess up your settings so yes we have a solution so next one time tab interface that's always if someone says raw sockets i normally say"
  },
  {
    "startTime": "00:24:00",
    "text": "use tun tap next the advantage is it's a real interface it's easy to integrate the disadvantage is how to get the traffic into the ton tab interface so we're talking again about how to do some multicast forwarding which makes everything more complicated and it's still user space so it's not that much better and it's more work to do next what we want to do is doing multicast forwarding in kernel space it's a matter of performance especially if we have not that much hardware lifting up everything into user space is really not that great we would like to do it with like unicast traffic just let the corner do its stuff next and yes ip multicast routing it has been part of linux forever it works it's fast it's integrated it plays nice but it doesn't work for our use case it has been done for multicast routing between ethernet segments and so it's not the solution we are normally looking for next so is it has someone looked into the linux multicast routing and the new new shiny stuff we got over the last decade or something like this i must admit i've looked into it not for years and then last last week i started looking to it again so next what what's trouble there are four points that making multicast are difficult for us re-transmission on the same interface selective forwarding local traffic and suppressing duplicates next so re-transmission on the same interface i tested this a week ago it seems to work i don't know when they changed the kernel code but i used a static"
  },
  {
    "startTime": "00:26:01",
    "text": "multicast forwarding daemon and i could send out multicast traffic kernel based on the same interface again earlier kernel versions years ago just said no that's not allowed so it seems at least this problem was solved a long time ago i don't know how many years ago good one thing done next no selective forwarding vertical one one back so yeah depend uh sometimes we don't want to uh we want to deal with incoming multicast differently depending on what was the last node who sent us so to improve the efficiency of the forwarding a little bit we could do this in theory with some clever dynamic firewalling we might need access to something like the ethernet mac address and nobody likes to dynamically load ip tables eb tables enough tables rules all the times but it could be possible next local traffic as said in the last presentation you don't always have a nice router with a host attached but kernel multicast forwarding only deals in interface to interface forwarding it doesn't it does ignore local traffic completely the idea is that the local application should know which interface to use which is bad if you have multiple radio interfaces so but we could change this today there's something called virtual ethernet devices so it's just like a pair of interfaces you put in all local traffic into one end and it comes out of a real interface so you move the problem from local traffic to interface to interface hey that's easy done next"
  },
  {
    "startTime": "00:28:03",
    "text": "suppressing duplicates yeah because of radio transmissions and this non-transitivity we often get the same packet multiple times because it's transmitted from multiple neighbors and we need to filter this out so we need custom code in the kernel and nobody likes to write or even maintain a linux kernel module this is hard work really hard work yeah so what can we do next wait a moment what was about new toys there's something called ebpf for a number of years extended or enhanced berkeley packet filters it's some kind of virtual machine in the linux kernel you can push for some functions you can push code into the kernel and do some custom custom stuff without writing kerner module and there's xdp express data path we don't need to express paths but xdp can be attached to interfaces and do some logic based on an ebpf program for example deciding to drop packets that are incoming or maybe modify them or redirect them to a different interface that sounds interesting so i got an idea i have to admit i did not i could not test this in time but maybe we have something to talk about next so what i would like to do is combine all these things we have a little ethernet in the middle so this resolves the local traffic part ever we have at the end of the ethernet a firewall to make sure what's going on with air traffic before we forward it we use normal ip multicast routing on the outside to go to an outgoing magnet interface and we can use"
  },
  {
    "startTime": "00:30:01",
    "text": "the the ebpf filter to filter incoming mana traffic and if and then if you want either redirect it to the little ethernet pair for forwarding or redirect it there and just modify the ttl field to make sure it's not forwarded but comes out of the same interface or just drop it based on custom code next slide so what's a good thing here we have the ethernet available so not a problem with ip tables that we don't know who sent us the multicast at the last hop we can change the ttl field on the fly and recompute the checksum or with a helper function to make sure that that this packet will be handled locally but not forwarded i've seen implementations of hash functions in ebpf at least for recent kernels which improved what we can do with epf so in theory we could do to complete smf duplicate detection either on sequence numbers or on hashes there in the kernel so this could be a way to completely do the whole forwarding chain inside the linux kernel without writing new kernel code because from my point of view writing a new kernel module just for marnet i don't think this is feasible most likely the module will either be not accepted or will age badly so that's it next slide is just questions so what do you think thank you david davilan potter things um"
  },
  {
    "startTime": "00:32:01",
    "text": "so first there is specific reasons the linux kernel multicast routing api is not suited for magnets um because it's designed to deal with consistent broadcast domains so it was never intended to deal with cases where you have a disjoint uh network like this and the fact that you can now use it for a money because the iif equals oaf restriction was removed doesn't make it a good tool that restriction was there for a purpose in the beginning um because if you have actual broadcast domains the only thing that that will ever achieve is create loops um and um i'm missing considerations here what else will break by transferring this tool that was designed for broadcast networks to this new scenario that it very much was not designed for um that's the one thing um the other uh thing that i'm that we kind of skipped over in in the sequence of discussion here is duplicate detection may sound necessary but it is in in my opinion fundamentally never the correct thing to do so not only will you run into scaling problems as soon as you get larger amount of multicast traffic there is also the fact that there's a reasonable number of protocols which will send the same multicast packet multiple times at some intervals which is just part of normal operation for those protocols and if whatever you set up for duplicate detection doesn't allow that traffic to go through then you're breaking the the upper layer protocol it becomes a question of timers relative to to each other if your duplicate detection is faster in quotation marks than"
  },
  {
    "startTime": "00:34:01",
    "text": "the protocol using it then it works but that's ip forwarding is not supposed to remove duplicates in in general and this also applies to multicast routing um i'm i i very strongly would would argue that the solution should not cannot must not contain duplicate elimination and i think that's it for now i have more comments later so yeah i would agree to most what you said but that's the toolbox we have at the moment and we would like to do multicast in our typically confusing radio environments with mitral radios so and i don't think we really break less things by doing raw sockets so this is just an idea an option to see what we can do yeah we have more tools coming up i think okay uh julius so uh henning i absolutely loved your talk until slide 16 and then i was a little bit well i was uh the point is that if so you're saying we don't want custom code in the kernel which i agree with and then you say let's put ebpf custom code in the kernel there's still custom code in the kernel our problem here is that there is too strong a couple between the control plane and the data plane we don't have a good api for multicast over mesh networks that will serve all control planes independently of the routing protocol now the kernel is not immutable if we have a good idea if we know what we want the kernel to do and if that is something that does not depend on the rooting protocol and can get into the kernel it will no longer be custom code"
  },
  {
    "startTime": "00:36:01",
    "text": "it will be general code and our problem here is that we currently i mean david hinted to the opposite of what i'm going to say but our problem is that we don't have a good idea of what it is that we want the what general forwarding the kernel needs to do for our needs yes it would be nice to have some better user plane in the kernel i definitely agree but i vary that depending on what kind of network we are talking about we need different solutions we will need for example if we have a high data rate wi-fi network we might deploy something very differently than when we have a vhf uhf network that has two different interfaces with two orders of magnitude different capabilities so at the moment we don't really know that well what we need which will will make it difficult to go to uh to propose a new kernel module write it and get it accepted because maybe a few years later we say oh we need something else again i think that indicates that we don't fully understand the problem the notion that we need different algorithm for different networks indicate we don't understand the problem well yet yes donald donald east lake uh future weight technology just a real quick thing that obviously duplicate detection can't just be based on the packet but has to be based on where it entered the mesh and a sequence number applied at that point so that you can if you sometimes you're supposed to have two packets that are binary identical can i quickly say that smf had adds a an extension header an iphone 6 extension header to make the packet unique so i think this blue burger my comment is to the this presentation but maybe also to ronald's i think it'd"
  },
  {
    "startTime": "00:38:01",
    "text": "be really helpful to talk about how uh not only end hosts fit into the solution being discussed but also routers and how you fit into a wider routed network and you know looking at i've been i'm coming at this from like the raw perspective and in there the wireless network is just part of a larger network and one of the things i've been grappling with is how do you integrate your your all your routing information and make it so that the um the unique properties of your manet are like constrained to the man a but you can also pass through your transit routes and on in this discussion in this presentation and i'm willing to bet in the future ones although it'll be interesting to hear in the future ones really interested in how you fit into a routed network as opposed to just the routed monet that connects hosts thanks and if you want to talk about that for what you've presented that'd be useful also thank you yes but that adds a whole other dimension and makes it extra complicated so maybe any um yes i i would say we are the transit routes always for unicast and for multicast get things more complicated and we don't even know how to deal within the radio domain with the multicast we should not forget external networks both just attach networks and transit but if we don't have a date a good data plane to experiment with then we have trouble even finding out what we need so i don't say this is the final solution but this might be a good way to experiment with things and maybe give us a few hints what we could work on for general more general data plane rick"
  },
  {
    "startTime": "00:40:02",
    "text": "presentation henning i i i do like your research it's very interesting a big fan of ebpf and the cool stuff you can do with the linux kernel and it's just a small question i have is it's great that these are tips and tricks that can help us build a data plane in order to prototype and work out some of the protocols i i actually kind of think here in manet we have the bandwidth really to look at what those protocols should be um following on from lou's comment i need a multicast domain that spans some of my fixed infrastructure that may be not just that one laptop connected to the router connected to the radio but that might actually be a small sub-area network i uh there will be backhaul into the fixed infrastructure that heterogeneous network of which some segment is one or more radio systems going back to ronald's original diagram earlier on i think is probably more relevant for the working group than how do we beat linux into submission um don't get me wrong it's great stuff but i just want to pull it back to a bit more of an idea focus sorry talking about duplicate i fundamentally believe radio systems are getting smarter and smarter and smarter and a lot of them are running some kind of embedded real-time operating system anyway they understand what's happening at layer 1 and layer 2. they are doing a lot of duplicate packet elimination anyway based on information they have from the from the radio subsystem and i think it the naive approach of not deduplicating is actually the correct way to go so i'm a i say naive but it's actually the right thing to be doing if l if the lower layer says i've got two packets that are as far as you're concerned are identical what is the ip layer to do the op layer should just forward those it's not the ip layers business to do"
  },
  {
    "startTime": "00:42:00",
    "text": "that deduplication and we've got to be really careful about that layer separation i don't think layer 2 can help us there just as a personal command because you can push everything we do down to layer 2 of course then we need then someone else needs to solve the problem but uh that's not always helpful especially with my radios my quick response and then i'm going to shut up and sit down this has always been the problem with the with the many working group we we live within the ietf we're supposed to be layer 3 ip focused but many problems often exist at layer 2 as well and i'm really interested in what donald's going to tell us about um what's happening in 80 to 11 because for the link there really that shouldn't be in the scope but we all try and solve these many problems in as a general thing thanks helling thanks commenters hi there i'm donald eastlake with future way technologies i was actually chair of the 80211 mesh task group for the first half of its existence next slide so i i'll try to go through these the first slides are pretty quick that you can read them at your leisure but basically eleven is very complex standard got all kinds of stuff in it get your own copy read all four thousand pages if you feel like it uh it's very widely deployed it's got all kinds of things you've probably never heard of and operates in all kinds of different spectrums and different control paradigms and stuff like that it huge number of chipsets per year so it's worth doing the effort to make improvements in them because the cost of the engineering gets spread over a large number security is built into the hardware so it's free to use and you have to get the keying"
  },
  {
    "startTime": "00:44:00",
    "text": "right the working group is a link at the bottom next slide please it's got fragmentation and aggregation multiple levels of aggregation and uh uh mostly talk about the infrastructure mode uh and mesh uh next slide please now skip some of this so this is uh what a data frame looks like in 80 11. 8211 believes in a complex header with extensions rather than layering it's uh it's all layer two in a sense but uh you could still imagine ways of doing this with nested stuff over there on the right the next to the last thing is there's actually some data there's a frame body i don't know and then there's the frame checksum but uh there's space for uh lots of addresses and these are all 48-bit mac addresses and the left hand is the frame control and the bottom shows uh frame control they all have a version type and subtype but what the raining bits are depends there's data type data frames and control flames and management frames and action frames and multi-hop management frames and on and on and on matter of fact the ran out of types and subtypes so there are things with protocol version zero one not because it's really a new protocol because they ran out of types and subtypes next frame the next slide so this is the classic uh infrastructure ess you got a uh it's just called the distribution system in the standard it's very vaguely described so you can instantiate it in many different ways access points stations associated with that extended service set as this whole thing where the stations can all talk to each other as if they were local to each other within the same ssid next slide so the ap is beacon periodically it could be any time but actually it's always 100 milliseconds for normal cases and that includes their capabilities ssid and the stations associated with the access point negotiate pairwise keying and the access point pushes down a group key so the access point can send multicast are broadcast and all the"
  },
  {
    "startTime": "00:46:00",
    "text": "associated stations will be able to receive it there are these four logical addresses the real source of original source final destination and the actual transmitter and receivers address and uh i'll skip over the the uh unicast case but for uh multicast at the bottom there if it's the multicast source is actually the ap itself is sending it or behind the ap then the ab you can just multicast it because it can set the receiver address to be the same as the multicast destination address and all the stations will happily listen to that if you send them multicast from a individual station it gets unicast to the access point which then uh so it has in at the multicast destination but it uses the access points receiver address and then it gets multicast by the access point down to the stations and that means the station does get the multicast that it sent uh back to itself it receives it again but it can tell because it has its own address as the source address in that frame so it doesn't have any problem uh because even though this is something that's a violation of the ethernet axiom that when you send a packet a frame you never get it back but as long you can tell when it'll drop it it's easy enough next slide please so uh how does it get reliability uh unicast stuff it usually uses link level acknowledgment and retransmission but of course things go wrong acts are lost you might re-transmit when you didn't need to and so on and so forth so there's a sequence number and when it's fragmented as a fragment number as well so you can always tell if you got something more than once and of course eight or two eleven is you're talking a single hop and it's there's a goal is a maximum distance of 100 meters and stuff the timing is sort of constrained so you can figure out a reasonable number range and stuff for multicast there's got all kinds of things in there people frequently"
  },
  {
    "startTime": "00:48:00",
    "text": "complain about the unreliability of multicast native 211 but really anything you can think of as a reasonable way to make multicast more reliable uh has probably already been put into the standard now whether it's implemented and widely deployed is a whole other question but uh sometimes people say multicast is always sent at the lowest possible rate that's not true you can tell the access point whatever rate you want to send it at if it's discovery you might want to send it at a pretty low rate but it's for data you could send it at just the what rate you think is necessary for the most remote station or something like that you can have uh unsolicited re-transmissions where the the thing gets transmitted multiple times and you just depend on the duplicate detection and that more likely to get through you can go through and pull every station to see if it received that multicast frame of course this uses up a lot of air time and kind of loses a lot of the advantage of multicast but of course there's a feature where you can send a bunch of multicast frames and then pull the stations for a block of acknowledgements and see which stations missed what and because the receiver address and the destination address are separate you could go through and serially unicast which also eliminates of course a lot of the advantage of multicast and is useless if you're trying to do discovery next slide there's also this ad hoc mode which i think is mostly used these days for tethering like if you tether to an iphone or something it uses that hawk mode and that way all this that all the stations beacon and they uh they just send directly to each other and in some weird mode you might think of it as a one-hop meshes and in in that case you really sort of only need two addresses because in every case the source address and the transmitter address are the same and the receiver address the receiver address and the destination address are the same but the header still has three fields and the third field is this basic service set id which is how the ad hoc network kind of is identified and of course uh it may not be full connectivity it's not very reliable but if you want to send multicast it's easy"
  },
  {
    "startTime": "00:50:00",
    "text": "you just send multicast and everybody can hear you gets it and those that happen not be able to hear you don't next slide so there is this fourth address in the header which is optional so why is that there uh there's been various proprietary uses uh the current starting they're sort of two standardized uses one is the general link feature and the other is mesh the general link basically has the idea you're sending something through a station across an 8 or 2 11 linked through another station and uh so the source transmitter receiver and destination address are all separate and they could all be there it would all typically be different so if you go back one slide for just a sec you can in fact under the in the standard you can do this ad hoc thing and you can make all those radio links be general links and if you did that there could be arbitrary networks behind each of these stations of course the connectivity in the middle would still have this flaky one-hop uh pseudo-mesh thing so uh but if you you could do that of course the alternative is to make these have a network behind the station but make it still appear to be one station by putting a nat in there or something but anyway go forward two slides please uh anyway you can also use general link in the infrastructure white case in which case you have an access point and associated stations and you can have a network behind the station anyway so the initial idea for mesh was it was just going to be used for wireless backhaul people like to limit the charter scope initially so all the mesh points uh mesh stations would be access points might not actually have any stations associated with them so it's somewhat of a pointless restriction but it might look something like this where some access points can only get back to the distribution system through other access points next slide but fairly soon the mesh gut idea got generalized and people decided"
  },
  {
    "startTime": "00:52:01",
    "text": "it really should be look like uh more of a a disc it looks like a link from the outside so the idea here is this this packet uh our frame actually goes through the mesh along the solid line and the dotted lines or other uh radio pairings between mesh stations next slide so in mesh all the stations send beacons periodically and uh there's they included that their mesh profile which is a mesh id it's like the ssid but different they also indicate what protocol what path selection protocol otherwise known as routing protocol they're using the path metric uh cipher suites et cetera et cetera and they appear it's an equal pair of equals between them and negotiate pairwise keying and each station distributes to its peers the group key that it uses if it wants to transmit uh multicast or broadcast and from the outside world that the whole mesh just looks like a layer two link so you generally have six addresses the original source the final destination the mesh source which is where the frame entered the mesh or or where it uh where it originated if it starts inside the mesh mesh destination which is where it exits the mesh or terminates in the mesh and then the actual transmitter and receiver on the particular op next slide so here's a a connection from a station to on an ethernet lan on the left to a mesh station that has this there's a device and a component called a gate which you need to get out of the mesh and then there's a mesh links and over on the right we have a co-located mesh station an access point and a station that's associated with that access point the station at the far right has no idea there's any mesh involved it's just associated to that access point so the a frame in the middle would have all six addresses which are the six addresses shown across the top there next slide so this is just a table of what of all"
  },
  {
    "startTime": "00:54:00",
    "text": "these addresses exist or don't exist for unicast and multicast for frames that are transmitted internal to the mesh as opposed to frames that start outside transit and leave the mesh next slide so what's where these extra addresses go well as i say 801 has this complex header with optional extension so it is a smesh extension it's got mesh flags has a ttl uh four byte sequence number and can have zero one or two additional addresses because in certain cases where the destination is multicast you don't need additional addresses so the secret the source address and the sequence number as a pair is uh cached at the mesh nodes and used for duplicate detection and there's nothing very definitive in the 802.11 mesh standard about how long it needs to be cached for or things like that so unicast as this routing is determined by this past selection protocol the mandatory to implement one is has both reactive uh aodv like features and it also has a proactive part which builds a tree from configured roots so you can always use that tree but you may get more efficient paths with the hybrid with the reactive mode uh next slide so multicast so it's they're sent uh with just with the destination address the multigas that wrestle you don't need separate receiver addresses for the physical receivers or alternatively you can serially unicast by specifying individual receivers to get acknowledgements and re-transmissions on each hub so the receiver discards them if the ttl's got it down obviously or if they're duplicates or if they're not from appear so it basically just floods it with duplicate elimination and that gets your multicast or broadcast frame to all the nodes in the"
  },
  {
    "startTime": "00:56:00",
    "text": "all the mesh stations in your mesh and this has always been in there 8211 has always had multicast that worked in this fashion uh since it's been standardized 11s next slide this is my last slide to the question well okay this is all all layer two and it's all like that and you can have these gates that connect to the outside world uh and uh this duplicate elimination may solve things inside the mesh and the ttl is a sort of extra backup so you can't really have you know looping and stuff like that inside the mesh that would be problematic but what about loops in the external networks but since everything is layer two it just uses a spanning tree and disables uh gateways and such that you don't have loops uh by the typical spanning tree method uh so i i you know i think the the flooding and duplicate elimination has got obviously some some bad uh aspects and sort of a burden and storage of the nodes and so forth but it's a pretty general and powerful technique for getting multicast to actually uh work in in meshes and things like that that's my last slide thank you donald perfect timing uh questions can you go back to the slide sure backup one um can you clarify if this is one spanning tree for all traffic or one spanning tree for uh each source like rooted at that source uh it's for all traffic i believe but it has been quite a few years since i was involved with this but anyway hopefully there weren't too many errors in this and i know running i have worked a little bit with 82211s and in my opinion it was not working well in anything beyond a couple of nodes but even then because this aodv with"
  },
  {
    "startTime": "00:58:02",
    "text": "proactive beaconing didn't scale well 811 ls might be the best mode to use your wi-fi if you want to do layer 3 routing over it because you can just switch off the mesh protocol below it and then you have a fully bridgeable single hop wi-fi ad hoc mode because the original i don't know doesn't work well on newer wi-fi versions so even if we want to use a different protocol 8.211s might be the single link layer we want to look into because everything else on wi-fi doesn't work that well for manage i would like to say that i i am not supporting the uh current path selection protocol in 802.11s originally there were gonna be two of them one got dropped at the last minute and uh i think there are could be better alternatives for the uh for the routing inside um 80-11 mesh julius could you please go one slide back slide 16 please um so here you're saying that you can do a conversion of multicast to unicast right right does that mean that every node knows the membership of every multicast group of that mean that you're spamming the whole mesh with your mouse slamming the whole mesh okay thank you yeah by the way so you don't wouldn't you don't just send general multicast frames for the purpose of discovery in 80211 mesh discovery happens because the first these stations send beacons and then they peer so when you're actually sending data it never worries about getting them to anything but a peer that it already knows about so you can just serially you have that list of peers and you can serially"
  },
  {
    "startTime": "01:00:00",
    "text": "unicast to them uh quite easily and actually should not appear then if they're not appear when you you multicast or there's some other and receiver that receives it they won't be able to decode it anyway because they won't have the group key for the sender sure that's clear thank you okay thank you we need to move on dominic we show you briefly in the queue but uh i was going to ask you to hold your question into the discussion okay i think you're a bit too loud too loud i'm not very sure there's something wrong is it better now yeah uh can you uh have the microphone at a greater distance from your mouse um i use headset here but i'm not very sure there maybe something wrong here but i don't know if you hear me well hello yeah it's better if you talk a little lower it's it's pretty high gain i guess so if you can talk a little something a little quieter we can hear you better okay okay okay is it better now well yeah go ahead oh okay okay hello everyone i'm sandison from zte"
  },
  {
    "startTime": "01:02:01",
    "text": "this presentation is for beer in bevel we have co-author tony from juniper next please at first let's see what's beer here is the acronym of beer index explicit replication here is a new multicast technology it can achieve multicast forwarding without explicit multicast distribution trees building and it doesn't require intermediate nodes to maintain any per flow state pure introduces a layer architecture to decode the multicast packet and multicast the transportation the multicast forwarding in beer doesn't depend on the ip header which has the multicast destination it depends on the new beer header beer forwarding is based on bit stream in the beer header that follows a layer 2 or a tunnel header for example mpls in ipv6 or any internal whose encapsulation header can indicate that beer header follows each beach in the big stream indicates an age router that needs to receive the traffic the beer architecture is defined in fc 8279 and the beer header is defending fc 82 96 and the drop bearing six next please there is the beer layered architecture the multicast for wording is decoupled from the multicast package the multicast package which has the ipv4 or ipv6 multicast destination address is recognized in the ingress router and"
  },
  {
    "startTime": "01:04:00",
    "text": "the egress routers the intermediate nodes forward the packet depend on the their header only the multicast destination address of the package doesn't have been seen in the intermediate nodes the control of the multicast package among the ingress and the egress routers is called multicast flow overlay the ingress router encapsulates the multicast package with beer header and the necessary outer encapsulation for example mpls ethernet or ipv6 the egress router removes removes the beer header and associated outer encapsulation forwards the multicast package to receiver or the next hop router the beer layer is is the core part of beer the node forwards the package according to the beer header only the outer encapsulation as we mentioned can be changed by each node that means the whole i hope that is no multicultural trees in the beer domain the details of beer forwarding and the beer header is described in the fc we mentioned above the routing underlay is extending the routing protocols to build their layer the forwarding table used in the layer is generated by the routing only protocols such as isis ospf or bdp and of course payable and the only protocol is extended to advertise the node's peer information and compute the specific beer for wording table that means bift gift next please"
  },
  {
    "startTime": "01:06:02",
    "text": "from above we know that when we use beer there is no multicast tree signaling and the multicast state in the network beer can work with any routing protocol for secondary beer information used for dipped calculation for example sis or spf btp and babel and the other routing protocol can do it as well beer can work with any l2 or internal encapsulations as we mentioned empires ipv6 and so on if the multicast traffic reach is not high fear forwarding can also be achieved by software so beer is perfect for fable networks next please let's see the beer signaling in apple protocol paper route advertisements for vr router roofback addresses carrier trvs for their information used for beef calculation beer traffic can be tunneled over via incapable nodes by any kind of tunnels because bevel is a distance vector protocol like bdp methods used being brbgp segmenting can also be used here for babel this part will be added in next version next piece for your information there is an open source implementation for beer signaling bevel protocol in the github that's all i appreciate for your listening comments welcomed thank you questions comments jeffrey from juniper um i just want to"
  },
  {
    "startTime": "01:08:01",
    "text": "add that the beer it can achieve efficient broadcast replication without building a tree that's why it's a it's the best multicast protocol i have seen the there is one cache in other scenarios uh where it it requires new we use a new encapsulation a new folding algorithm so in um when you need to to use hardware based forwarding then you either need a new a6 or a programmable chips and that has been uh hindering its deployment to some extent it's a there's a chicken egg problem there but in the bevel environment especially when the data rate is not high you can use software-based forwarding and ascending mission that that is one thing that makes it very attractive there and so um [Music] i i yeah i i i just uh emphasis also emphasized that the fact that it's a efficient replication that does that does not go does not flood the traffic and and yet you don't need to build trees that's that's the uh the key a key concept of it yeah just two quick comments um so i don't have an opinion yet of whether beer is a good or a bad idea i sincerely don't know but what i am ready to claim is that beer does not"
  },
  {
    "startTime": "01:10:00",
    "text": "suffer from the duplicate problem okay so beer does not need duplicate uh detection and as far as i can tell just by reading the specs i haven't checked that formally as far as i can tell it does not suffer from the problems that ronaldo described in his talk at the beginning okay and i think that at least i don't know whether beer is a protocol is suitable for many but the ideas behind beer is that something that definitely we should be looking at uh dublin putter um this is going to be a bit of a longer well comment slash additional notes i first would like to point out a few things about babel's functioning as it would apply to money it's it's important to understand that when we have a situation where a mesh node is forwarding multicast traffic to multiple other mesh nodes ie so this it doesn't matter so this is about the single hop behavior if so multiple mesh nodes in this case means that there's multiple paths for the traffic to progress that traffic in current beer designs is always unicast so you always have the the replication into unicast on the single mesh hop level um whether that is a good thing or a bad thing depends on the actual mesh properties um but you do only send it once so if you have a thousand receivers behind one mesh node then it's only forwarded once to that mesh node and this is not necessarily something about beer that needs to stay this way it's only so if you look at the problems with um using multicast for labels multicast propagation on lower levels in for"
  },
  {
    "startTime": "01:12:00",
    "text": "example mldp the problem was always that you are moving from assigning the labeling and control from the receiver to assigning that function to the sender of the multicast traffic which has historically been well learned been learned to to not work that well however in mesh networks and especially if this ends up using the beer and ipv6 encoding i believe this is a very solvable problem which just needs a bunch of additions to beer so this protocol so in in itself beer will start out with only unicast packets on the lower layer um and if if uh if we want uh to use multicast capabilities of the radios then that will be additional beer work um but it can be done there is another thing i would like to point out in it in a way there is there's a commonality with 11s and even smf to some degree in that the reason that this doesn't need duplicate detection is because it's fundamentally an added layer of encapsulation um if you if you look at it sideways kind of then 11s is also an additional layer of encapsulation because you have this the six address frame um and if you look at adding extension headers with sequence numbers that's a very very simple kind of added encapsulation but still you're you're tacking additional data into the packet that is kind of the one important takeaway for me here the way to avoid all the trying to duplicate things is to add a layer and that layer also tends to allow better uh routing behavior and i think that's"
  },
  {
    "startTime": "01:14:01",
    "text": "taken at this point and we should focus on figuring out what the best encapsulation is rather than trying to make it work without encapsulation i'd like to make a clarification beer ipv6 encapsulation that means the director adopted in their working group is bare insects it's not encapsulated in beer in ipv6 extension header it's just a protocol follow ipv6 header so we needn't to do the check of extension header for bearing 6 we just read the ip protocol or next header field in the package we can know that there is a verb header followed me we need to do the extension header check um yeah sorry i was a bit unclear about that that that is what i meant um i did forget another thing in in the beer pable work um there's one very important thing that is completely missing at this point which is there needs to be some way to dynamically uh or within the mesh assign the actual identifiers for the beer nodes i either the bit position and that is the actual difficulty that that doing beer in monet will need to solve in some way yes only the age routers need to be assigned the bit position for it and the intermediate nodes even to be assigned with a bit operation um we need to speed up a bit the heading uh sword please quick um we would just need deduplication for dense mode flutters multicast customs not for sparse mode that follow a tree if i understand this right beer is just following a joint tree that is made out of the"
  },
  {
    "startTime": "01:16:01",
    "text": "unicast roots and use the explicit bits to keep track which part of the already split traffic is still having to travel to multiple nodes yes the only the topology is carried in the beer forwarding and we cannot we care not about the multicast flow just the topology that is the set of the egress routers yeah um i don't know how to pronounce his name oh it's you or jeffrey from juniper i i want to add one thing that i forgot to say earlier it's related to the earlier point uh point about uh income interface not it cannot be the same as i'll go interface in the traditional multicast folding um with beer as david pointed out is even online interface it's a neighbor based so you you don't we do not have this problem you can receive traffic on an incoming lane and you can go out of the same lane again to a different neighbor hi luberger um i'm new to beer so i'm new to beer so i may have it wrong but i think the really interesting point here is is by adding beer is adding a new forwarding layer or an additional forwarding layer and that separates out sort of the ip semantics from the forwarding semantics which i think is really good for solving the router to router problem that i asked about before so i think david talked about the question for the group is what encapsulation uh mechanisms should be thinking about i want to generalize that to say what layering mechanism we should think about"
  },
  {
    "startTime": "01:18:03",
    "text": "thanks we now move on to pascal's presentation about multicasting role for 15 minutes you know can you show me your thing hello cool um did you give me the amp or will you move the slides start talking we'll get we'll figure it out but if you transfer it to me then i will move them well we can start already so so ripple is a uh world it's the working group that defines the ripple routine protocol and uh ripple is a distance vector that's optimized for a mesh that is using one or several routes to reach the outside so most of the traffic is supposed to be from that route or to that route and this is designed to operate in a constrained network low power llc network so we we did extensive optimizations to limit the knowledge of topology and the routes and address that that you need to have inside the network and for that uh basically what we are doing is we are uh routing mostly from the perspective of the root so think about a distance vector but instead of doing any to any you will do root 20 and for that the first thing that happens is you you build a tree which is not really a tree it's a directly a cyclic graph that is rooted at the root and that basically points the destination of that geodag is the root so that gives you a loopless path for any node for the default routing if you"
  },
  {
    "startTime": "01:20:01",
    "text": "just want to do collection that's enough and and you're dead if you want to be able to route down this geodac towards the devices then you will have to establish the watts path and for that you have two modes one is what we call storing mode and the other one is non-storing mode so in non-storing mode basically the each node advertises its potential parrots so since it's a deodorant it's not just one parent it's multiple parents so advertise its parents to the roots so each note says i'm here and my potential parents have those guys and with this the root is capable of rebuilding the whole structure of the geoduck in memory and then use that for source routing so that's that's the non-storing mode in storing mode you will use this duo dag and basically tell your potential parents about your addresses and recursively the potential parents will tell their own addresses plus all their children to to the to the grandparents etc so so you you end up knowing every route downwards and using only the default route upwards so that that's the very basic of of ripple so it is anisotropic it has a sense of up and down which was inherited by rift basically to extend uh the model to multiple roots and basically the top of fabric and left is is like a root but you have many of them um what else we have uh we have extended ripple for a neodv model and for a centralized routing model so a lot of what you've seen in donald's slides you know the the tree that that's possibility or iodv that's a possibility we have we have pretty much the same thing um so that's the basic of it and uh we have different modes of operation in different instances i need to talk about that a little so if you basically want to make different optimization or or"
  },
  {
    "startTime": "01:22:00",
    "text": "build different dags then ripple allows you to to build multiple of those geodex and each one will that the node participates to will translate into a different verb so we need to signal in the packet which verb which routing table you're using which corresponds to the ripple instance that installed that route so we have the hub by hub option so it's not there by operating here but we have a hub by hub option in the packets to signal which ripple instance we are using so it's an alternative like of source destination routing to go to a particular route if if you have multiple if your monthly home you can build one instance per exit point and then you route along that instance and you will exit the the expected place in the network so the one the mode of operation uh one is uh non-starting mode mode operation two historic mode model profession three mode three is storing mode with multicast what it means is um inside the geodec there is what we call the preferred parent tree and we use that tree as the multicast tree basically so the leaves inject their multicast addresses as they would inject any cast address or unicast addresses it's just that the parent instead of keeping the freshest one using what we call the past seconds um that's how we do mobility in ripple uh instead we we just keep them all and let the lifetime expire and as we keep them all then we basically unicast copy typically but we could also broadcast copy a packet going down the tree to every every child that's interested so compared to what was said before it's not a flood right we still register the multicast addresses they are injected uh and aggregated as they go up the tree us in traditional"
  },
  {
    "startTime": "01:24:01",
    "text": "space and uh they are the packets are then routed uh basically down that path so you really have to do the two traditional modes where uh either you you send a multicast packet all the way to the root and then it will go down the tree in which case you don't have to have this duplicate elimination prime or you can optimize and say let me pass it to when it's when it's sourced anywhere in the tree you can always pass it to everybody but the one that passed it to you which which is an optimization but then you need to be able to not pass it back to the node that passed it to you the first place so so the the two models the two folding models are available uh if you don't want to have to care about where you receive this packet or if you already received it then basically yes you can leverage the tree and and pass the packet to the root and let the the packet go down down that tree um next slide please oh no it's me now yes it's me you've got control okay so um now that that was the the mob screen report now the role has has done another piece of work which is completely independent and and completely um that doesn't need any form of of geodac installed or anything so you have a big crash and you need to to flood some information then meeple can be your friend so what it does think again of a very large network with many many nodes and and the problem that you want to the thing you want to avoid is every node trying to relay this packet so you basically want in another fashion to to create islands where one will stand and the rest will receive and when you're at the border of that island then someone will stand again and that will propagate that way and so there is an algorithm which is three core rfc 6206 which is used by ripple anyway to"
  },
  {
    "startTime": "01:26:01",
    "text": "and um which is there leveraged as the main as the base of the multicast operation basically what it does is um if there is an information that you want to synchronize on every node a certain knowledge also then packet someone sends it and and everyone runs a timer and in a certain portion of timer you just listen and the second portion of the timer you have a random piece where you still listen and then you send but you only send if you have not received more than a certain constant number of packets so if enough packets of this same knowledge were transmitted around you then basically you you assume that everyone around you had that packet and you don't need to resend on the other hand if you did not receive enough copies of this thing then you will retransmit it now the efficiency is is what it is right you have no guarantee that everyone will get it it's a little bit problematic at the edge of the network um because you might receive many copies from the inside of the network and there might be path nodes beyond you on the edge of the network and just because you received enough from one side doesn't mean that everybody on the other side got it so there are a few corner cases with it uh it's not quite efficient but it's it's much better than flooding in a very very dense radio environment next slide please oops it's still me sorry okay and then we've got uh extension work for meepo but i won't spend time on that one um the new work that we have started uh at six lupine actually six low end and raw is based on the fact that most of the time we don't use the storing mode and so we don't have this tree so we have also designed something which leverage the"
  },
  {
    "startTime": "01:28:01",
    "text": "non-storing mode in non-storing mode there is a source route by the root and so what we'll do in that case is we'll exploit the source route basically the the nodes use the extensions that we've made to ipv6 network discovery to register unicast address now we are also enabling the registration of multicast address which is maybe of interest for you guys actually because the first thing before you you distribute uh traffic is to know who the listeners are and and mld is a poor model that is not necessarily the one you want you might want actually the devices to register the addresses that that they listen to and that's the model we use in iot because low power devices might not be listening to multicast queries from from dmld routers so we want the devices to be able to sleep and tell the routers hey i'm interested in that multicast flow if there is something that comes on that flow well you know i i want it so uh when i wake up i will come and see if you've got one so basically the the sleep proxy model so so the the sixth version is always to avoid having to do multicast and having the design the the devices register the unicast and now any cast and multicast addresses they care about and to make that work now the root will do ingress replication so basically the root will tunnel to every edge router and the edge routers will distribute of our unicast or multicast they are two to the listeners um since we talked about beer i will speak a little bit more we have two variations of the beer idea uh the working group now for the lack of interest this this work is pretty much stalled doesn't mean it's abandoned but it means that we we did not get strength and interest and and consumers for the those work this piece of work so one is constraint cast and"
  },
  {
    "startTime": "01:30:01",
    "text": "constraint cast uses bloom filters so it's a bit like beer i see it as beer family but it's not exactly beer and with the bloom filter what you can do is is encode in a bit map not the bit of the destination or something like beer but more a few bits which basically represent the azure use for an address that you care about so blooms are used for finding if something is there basically and if you have a match i'm not sure uh it's there but if you don't have a match you're sure it's not there what it does is for each address for instance that that you you have in the network it will compute a three four bit position using a function hash functions and then to know everybody who's there you basically or all those bits so now you've got the map of everybody use here now if you want to see if somebody is here you take your ash's address and you you see if all the bits of this ash are present in the in the aggregate big map if it is then there's a chance the guy is not there if it's not then you're sure he is not there so we can effectively leverage that for routing and the way c s you could do it for for deciding the social path or to just find the destinations beer classical beer as bits for the destination so the bit would say go that way [Music] brte actually will signal bits for the hops and so you can specify which route you're going to take by following the bits the bits are not the destination the bits are the hops c cast has bloom for the hops but it could have i think it would have been optimized to to basically just bloom filter the destinations and uh so basically what you would do in your case i don't think you're going to use this but if you were to consider it you would probably look at all"
  },
  {
    "startTime": "01:32:02",
    "text": "and uh compute you know have the bits for them and when when you have something to distribute you basically distribute it to the uh the aggregate bloom filter of all this destination and when you want to forward that's what is done in this draft you just match the aggregate of your next stop to see if all the bits that you want for to asset and if they are then you fall to him um i'm not sure my expectation went that great but think about using bloom filter as opposed to to just exact bits in beer the advantage of that is that you're not limited drastically by the exact size of your bitmap like like effectively if you store more stuff in your bloom filter then then it's it's normal capacity then you will have more false positives but you will still rot you would just rot down the graph a little bit too much some copies and then you realize that that effectively some of the bits were coming from the left some from the right so the mesh does not exist further down but that avoids this hard limitation of what size did you use for your bitmap oh i have one more node now i'm screwed i'm almost done okay so i'm almost done so the other thing we have is effectively beer for repo so then again um we have this tree right starting at the root and so what we care about in repo is is compression right we don't want to have to to have a lot of state and a lot of on big advertisements and what is very cool with beer knowing that we have the same promise everybody to assign bits it's not so right we have same question the bits must be assigned but say the bits are assigned and we have see it as a tree even if it's a diode um when instead of advertising your address and all the address of your children to your parent in storing mode"
  },
  {
    "startTime": "01:34:00",
    "text": "what you could do is send a single bitmap for you and your children with all the bits that represent you and your children set so basically when you do that the parent receives the bids for one child for another child for another child what you will do is it will or the different bitmaps that he gets for all his children and that odd aggregate bitmap that's what he will pass to his own parent and as you go up the tree to the root then at the end all the bits should be set for for every destination and the root knows that this bit is via this particular children so every node will keep the bitmap it got from its children and now a packet that you want to forward you will basically set the bits that you want to reach and and it will be ended with by each hop to all his children and if one children matches that mean you know the the the one of the bits that that you care for is effectively said then you forward to that children to the chat so the cool thing is instead of maintaining uh in your database one and three for every descendant for every ip address of every destiny and down the tree you just keep one bitmap for every direct child and and you forward along the bitmap and that's pretty much it that that's that's all i had for you so i guess i'm okay thank you i really would want to go directly into the discussion part otherwise we will have no time for julius's presentation on the end so if you have questions for a past call specifically please take them to the mailing list or mailing lists yeah so we have the the general discussion part right now and i've given 15 minutes for that allowing 10 minutes for julian's"
  },
  {
    "startTime": "01:36:00",
    "text": "anybody there we got everything if we got everything in maybe we should go to julian's presentation then uh we've got about 20 just over 20 minutes left 24. all right why don't you bring up julius's [Music] do you want to do julius first in the discussion at the end or yeah okay that's fine we didn't have anybody jumping up for that oh okay sorry we we had some online people well let's do julian sits and then we'll do the the discussion at the end okay as you wish okay they're not true for the confusion so okay well the slides are being put up i'm julius croblocheck and uh so i had nothing to say about i had nothing interesting to say about multicast so i asked the chairs for the opportunity to to show the monet group whether what we have been doing recently in the babel group and well it was worth trying i was expecting the chance to say no that's off topic and to my great surprise they said yes so thank you very much to the chairs next please yeah do you want control by the way i'm fine so most of you hopefully have heard about babel for those who haven't dabbled is a traditional rooting protocol which originally was designed for hybrid or heterogeneous networks so i was seeing at the time people struggling with putting uh mesh networking protocols and networks that were mostly wired so that had a wired backbone with some meshy bits at the edges and that did not necessarily work very well when"
  },
  {
    "startTime": "01:38:01",
    "text": "most of the network was traditionally structured and so i tried to design a protocol that is a traditional routing protocol that but that happens to deal well with the meshes next please so babel became an its standard track protocol in january 2021 about two years later than i expected that will be familiar to everyone here i think and uh since then we've done a number of useful extensions and a number of useless extensions that we've abandoned and i would like to quickly mention four of them their authentication source specific routing v4 via v6 and rtt sensitive metrics and i would like to point out that all of those have two independent implementations that they interoperate to the extent possible with the base protocol and the important point we've been trying to design protocol agnostic extensions they are implemented in babel but there is nothing in principle that would prevent them from being generalized to other protocols and my goal here is to have people steal our ideas thanks please so mac authentication we've done a minimalistic and easy to implement authentication protocol we have another authentication protocol for when you need more features and what is original in this protocol is that it is provably invulnerable to replace so most of the authentication protocols if you look for example at ospf they do not deal with replay in the general case then just rely on properties at the rooting protocol so that the replay attacks are not useful and that that makes reasoning about the security properties uselessly complicated here we are invulnerable to replay and it was designed to be implementable on plastic home routers it doesn't require real-time clocks it doesn't require persistent storage and it does not depend on features of the"
  },
  {
    "startTime": "01:40:02",
    "text": "bevel protocol it is completely general next please source specific routing it's sometimes called asdr for source address dependent routing is an extension that allows routing packets depending on their source and it allows a cheap form of network multi-homing so you have your network is connected to two isps and you want packets to be directed to one isp or the other isp depending on their source address or in other words the source node controls which edge router is reached by using by setting the source address of the packet this requires kernel support but the kernel support is in since linux 311 and for best performance it requires health changes but it does work without host changes and again it's something so that's something that would be very easy to implement in something like osrb2 next please okay that's the latest one the one i'm currently excited about it's v4 via v6 we call it v4 via v6 routing and the goal of that is to allow routing ipv4 through ipv6 only nodes so here on the right you have a bunch of double stack nodes and some of those nodes need to be sending ipv ipv4 traffic but in the middle of your network your backbone consists of ipv6 only nodes well v4 via v6 allows sending the v4 traffic through the v6 nodes the go being here to reduce the amount of administrative overhead and there is no translation there is no tunneling there is no overhead so usually i always try to work out what are the trade-offs and in the case of v4 via v6 i cannot see any trade-offs it's to me it looks just like magic um it's so we've enabled by it by default"
  },
  {
    "startTime": "01:42:01",
    "text": "expecting our user base to complain it's been deployed for a couple of months nobody seems to be complaining we've had some comments saying it's pretty cool to have more roots but other than that everything seems to work it does require kernel changes the kernel changes for ip were done in linux 5.2 and turkey hail and jorgensen uh implemented the changes for icmp and linux 5.13 so the implementation will disable it if your kernel is too old and again that's something that's completely protocol agnostic it has some very nice features and can be generalized to other roots and protocols next please and finally that's something that i'm feeling very ill at ease with ronald has been pushing me to push it forward so it's an extension that's extremely useful it allows computing automatically metrics uh by looking at roots rtts and at the same time it does not suffer with major stability issues which is if you do rtt naively the problem is that i think that we've i've been i'm very at ease with it we've done a lot of experimentation it's works surprisingly well and the problem is that we don't understand why it works and so that makes writing down the draft very difficult uh so the draft has been adopted but it's been in a state in which i don't manage to finish it for a long time it's widely deployed in production because it is extremely useful and um the fact that the draft is not ready yet didn't prevent a completely independent implementation again by turkey hail and jergensen in bird it is not quite protocol agnostic it would need some significant tweaks to be made to work well with a protocol that"
  },
  {
    "startTime": "01:44:00",
    "text": "has different dynamics from babel next please well okay so uh we have implementations of at least four useful extensions that are deployed in production and that are mostly protocol agnostic you should consider stealing the ideas behind them for your favorite routine protocol i promise we won't get offended to the upper contrary we'll take it as a compliment thank you for your attention thank you julius one quick question from annie henning sorry forgot to activate the microphone uh for soft specific routing does it now work with version four in the kernel i remember when i stole the idea years ago for my oldest r version two it was only version six in the kernel no it's version six only and the implementation that simulates it with policy routing has been removed from the implementation nobody um in order to do multi-homing cheat multi-homing with ipv4 people just not okay so nobody seemed to be interested and we we haven't pushed it because the users were not interested yeah version 4 version 4 destination with version 6 next top if i read your description correctly that's a different extension that's what the e4 v6 does let's go okay that's it thank you all right so now so now we have the general discussion [Music]"
  },
  {
    "startTime": "01:46:01",
    "text": "so people that were online and in the queue now's your time uh dublin potter again um this actually a little bit ties into the the babel presentation but also beer for multicasting and mayonnaise the hardest problem that i i see which i've already noted is assigning the the identifiers for using beer and i would like to note two things about solving that um so either the mesh becomes its own beer domain which is a perfectly fine thing to do even if other parts of the network also use beer there's no problem with having the edge of the mesh just be a transition between two different beer domains which allows limiting the scope of the assignment of identifiers for beer to inside the mesh but also if the signaling mechanisms for this can be designed in a suitable protocol agnostic way then there's no problem with having this work inside of babel to assign identifiers inside of the mesh and then transition into isis or ospf or bgp at the boundary of the mesh and just continue in the same kind of signaling whether that's actually desirable and or whether people are actually going to implement it for bgp isis or spf is a different question but both of those are fundamentally viable approaches we have talked quite a bit about uh that we need something in the forwarding plane dear talked about it because it needs some uh bits and must send it somewhere i talked about this"
  },
  {
    "startTime": "01:48:01",
    "text": "and someone mentioned mpls has someone experienced how well mpls works in marned environments because does wi-fi do most wi-fi chips supported well because at least some of the more esoteric radios that like to do marnet thing uh tend to be a little bit conservative what they accept as over the layer two uh jeffrey here i my tool onsite tool does not allow me to raise my hand or something i couldn't find it so i'll just mpos is it was it it's probably mentioned in the context of beer following mgos however beer does not require mpos at all it can work with mpos it can work with any layer 2 header or tunnel header so you can use beer without mpls at all now also going back to the question of rounding beer in a man 8 network itself not at the ip layer originally i was thinking it's it works very well and then i realized that in my network it's i assume it's mostly a radio network and quite often you'll want to reach multiple destinations over the same radio and in that case beer itself may not be a very good fit because beer folding is labor-based it's you can only send it one by one but if you don't consider that part uh then the beer itself the the architecture even though it currently is based on the ip layer uh it's for the it's over ipa"
  },
  {
    "startTime": "01:50:00",
    "text": "routing underneath but the beer encapsulation and beer folding algorithm connect is actually not limited to to ip to layer three you can do it at layer two all you need to do is map the layer two station to to a bit in the b string everything will still work well that's very nice about it julius yeah i'd like to come back to the point that david made earlier so david made two two points that i fully agree with so he said that the protocol that work well for multicast or protocol that use extra encapsulation and that's basically the alternative to encapsulation is to have duplicate suppression and if you have duplicate suppression you're doing two things that are very evil one is that you break protocols that resend the exact same packet so there is one protocol that does that and that you're using all the time that's dhcp v4 so duplicate suppression needs to handle especially dcp v4 which is a horrible layer violation and um and the other thing it does is that it puts in potentially unbounded amounts of states in the forward and plane if i'm correct that's essentially what mpl does so it looks like we have two things one which we definitely dislike that's duplicate suppression the other one which is not very elegant which is to encapsulate all of our packets this is the beer isn't done in 802.11s and so on and i'm wondering whether anyone that's not i'm not expecting an answer now but does anyone have any ideas is there a"
  },
  {
    "startTime": "01:52:00",
    "text": "third possibility that allows to exclude both of those places if we find a third possibility then we could have a nice diagram with a triangle we'd call it lampertur's triangle and david would be famous so i'd like to encourage everyone to think about is there a third possibility okay look go ahead so a couple of comments first on mpls you know mpls is a data plane it's also a control plane or has lots of control plane protocols associated with it from a data plane perspective it has a nice property of being these stackable labels so you know maybe there's a way to use or abuse the data plane for the layering that we talked about earlier but i would i wouldn't try to say that any of the mpls control protocols are at all appropriate for men a's and i don't think anyone suggested that i didn't hear that and you know if someone suggested it i would agree with the comment that it's not a good idea um so that's on mpls the other comment was actually in response to the the prior uh to the third leg of the triangle to the lampeter triangle is one option is is to uh leveraged ethernet header and there's a lot of radios out there like wi-fi that have an ethernet header and maybe we can use and abuse the addressing that's going on there by and allow for not carrying extra bits on the wire or not adding extra headers so i'd like to just add that in as that third leg turn i was already pointing out on the on the mailing list that we did have a lot more um in-depth uh starting evaluation of using beer beer or beer-like technologies in role specifically where uh it the goal was not only to do multicast with it but also as an actually more efficient way to steer the traffic hop by hop through the network so that you don't have to have the this expensive routing state in"
  },
  {
    "startTime": "01:54:01",
    "text": "a road network and i think the way i'm intonating that may already show you that there may be good differences to other use cases where you have more energy and where you love to have routing and you would for example rather [Music] rely on them so one of the technologies that we've done in the beer working group also which is the north 48 is brte and that is basically allowing you to hop by hop steer the packet through the network um with um for a steering solution probably the most compact encoding um and that was exactly the the brte um thing was uh what what what we thought role would uh very much benefit from as opposed to relying on hop by hop using the igp routing information so now obviously that requires you to have a topology information on uh the the router that sends it um so that you can calculate uh that path hop by hop there um like we've done in mpls networks with the rsvpt and eros so pretty much same thing just a very much more compact um encoded and there probably wouldn't be something you want to do with barbell and unless you start disseminating topology information sufficiently well like we do it in isis or ospf i would assume normally you don't have that information so yeah i i'm rambling a lot of hopefully funny details but i think it shows that the solution environment is is a lot wider and it shows also that the different um worlds that we have here with barbell roll and many may not necessarily need one and the same option out of all these multicast things that we have in the end rick rick um very quick comment about putting topology information out into mayonnaise the churn for most many use cases is so high that you just absorb all your"
  },
  {
    "startTime": "01:56:01",
    "text": "bandwidth keeping the topology consistent so let's not drift off into that just a quick comment about duplication of packets or deduplication of packets there are two reasons for having duplicate packets in your in your system one is because it's meant to be there dhcp v4 is a classic example you know the application there is saying actually i need duplicate packets the other reason is because your multicast system can't remove them or accidentally create them and i think there needs to be a real separation of these two things um generic deduplication of packets within a manet is not something we want to pursue smf due to the way it works creates duplicates by accident and therefore must clean them up other systems may not create duplicates i just want to make sure there's some clarity there before we get fixated on deduplication and and lou's point about using the frames using the lower layer frames for some sort of identity is a good plan but layer two dependent yeah i'm slightly confused that earlier thank david lampotter again um but i i have something other to well ask here um with beer being suggested in role already um i don't have the history on on why that fizzled out or anything um if there's any and oh apparently it fizzled out didn't do the pandemic if there's any actual technical reasons we should totally dig them up and not repeat the same mistakes thank you so so my my takeaway uh is that beer is definitely something um that we should look into for monet maybe also for uh for role where it was already [Music] on the to-do list"
  },
  {
    "startTime": "01:58:00",
    "text": "um really something really important uh i i closed the queue because we're out of time uh actually um so but do do please continue this discussion on the mailing list and the mailing lists i would say i mean people don't like cross-posting but to keep this crowd together we we cannot escape that uh i think for the moment and uh overall any final words of wisdom from you um sure uh so uh yes let's continue this question i would hope that that um there are commonalities uh we all understand that uh lens and mesh networks and uh networks and all that stuff are different and some have different needs but what i would like to what i would really love to see is some type of of of more sharing right instead of going back and saying oh we learned about stuff let's keep working and roll or dominate you know whatever something else to try and keep the discussion going uh maybe that means we meet more often like this because i think this will be very productive maybe it means we on purpose think about any common building blocks that could be used uh for different things and we work on that in some place um you know one of the working groups whether the system working groups maybe we spin up on your effort you know whatever it is but if we can figure out uh those building blocks then maybe we can we can make more progress than just you know going off and then coming back every other atf to share what we did and um it's great for learning but you know i would really like to uh given the interest that we take"
  },
  {
    "startTime": "02:00:01",
    "text": "advantage of this and keep uh building on it but thank you everyone for participating thank you sounds like maybe an interim would be an idea but i will i will discuss this with the other chairs thank you all for your contributions and enjoy the rest of your itf and see you in london hopefully any words from you just thank you take your slides down"
  }
]
