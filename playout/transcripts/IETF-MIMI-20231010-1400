[
  {
    "startTime": "00:00:58",
    "text": "right hello everybody uh can you hear me all right yes we can hear you thanks Alyssa to new laptops I just wanted to check if the microphone was working well all right so we're at the schedule time but I think we should allow uh oh and I see at least we've got I think both the presenters but we should allow a few more minutes for people to trickle in before we get started properly um in the meantime I'm going to send out our usual call for a note taker which as always we need for this session I can volunteer to take notes Watson thank you Watson very much appreciated that'll uh save us some time a little later"
  },
  {
    "startTime": "00:03:35",
    "text": "all right so let's get started thanks everybody uh for joining us so uh right so today's another Mimi interim session and um this time in keeping with our sort of alternating uh topics we're going to be focused once again on the user Discovery question all right so first off as usual we would ask at everyone uh note well the not well which isf's policies for governing meetings including"
  },
  {
    "startTime": "00:04:00",
    "text": "intellectual property and respect for all your fellow participants so if you haven't before please go take a look at all of uh these documents on the data tracker uh next we already have a notetaker thank you very much again to Watson um and now last uh yeah let's talk about today's agenda so obviously we're going to do the chair slides we're going to do a uh a quick recap of the discussion on Discovery that we've had so far which has been focused on requir ments um just to set some basic sort of definitions and ideas in common that we can all bear in mind as we go through uh today's presentations um which are focused on you know particular solution proposals um and then we'll get into those uh first gues and FEI and then Jonathan um and then uh I suspect between those presentations and the mic line for them that'll take up all the time um but if there's any time left over we we can just use it for sort of open discussion on the question of discovery okay so before we move on um any uh agenda amendments or bashes to anybody would like to bring up Rowan go ahead hi um I just wanted to uh to mention that um that Andrew Morgan had sent some comments uh about the content format draft and um we had a short conversation about that and I finally got around uh to um to recover all of my notes from that and write them up and that was I just sent that out um so I don't want that on the agenda that but I just encourage people to go take a look at that on the list and to make comments um those are still some outstanding um issues that' be good to close before the before the the next uh draft deadline"
  },
  {
    "startTime": "00:06:11",
    "text": "great we love to see actual activity on the list okay so with that I'm going to move on to the next agenda item let's see stop that okay um so this will be quick again I just want to re uh recap on some definitions we've settled on so far and sort of a formulation of the problem um as we came to it in the last interim session when we talked about Discovery as well as some discussion on the list that happened since um the interim in question which was back on September 13th uh okay so first off a problem statement of Discovery so uh a service specific identifier or SSI identifies a unique user within a single service provider and encoded into that um SSI is the service provider which means the sort of an SSI on its own can be resolved um an SII service independent identifier identifies a unique user but uh not in relation to any particular uh specific service and it does not encode within itself the you necessary information to resolve what service a user might be on um the uh consensus seems to be that we have to work with SSI as they already exist in deployed systems which concretely means um e164 phone numbers and email addresses although not addresses that are necessarily at the domain of any uh messaging service provider so you you don't get to assume that it's at whatsapp.com or at mycloud.com or something like that um so that constraints our design space we don't get to sort of invent new formats for siis uh so user Discovery then is um the process of resolving an SII"
  },
  {
    "startTime": "00:08:00",
    "text": "for some user into one or possibly several ssis for that user okay so with so that's about I think as far as we got as agreeing on things thus far um and the open questions that we have about discovery which uh we should bear in mind as we go through the solution proposals today um are so which actors ought to be trusted authorities for these mappings of siis to ssis so we've talked a bunch about this notion of certificate authorities in this space and whether or not the service providers would be ca or would be the exclusive CA in this ecosystem um then um in the discussion on the list we we interrogated does this process sorry does this discovery scheme need to scale uh to tens hundreds or thousands of service providers um excuse me uh then privacy uh how much what is the Privacy risks of this discovery system um what might queries reveal about the social graph and to Who Um can rate limiting be usefully deployed to prevent uh scraping of databases or um if we have a small number of providers each with potentially billions of users is rate limiting futile because they they have a legitimate need for a huge volume of transactions of lookups rather and finally um an SII May map to multiple ssis if it user has accounts and multiple service providers so should a requester learn all of them and how would that work um would a requestor uh which could be either a client or you know messaging provider um does it hit one service with an SII and get back yeah with an SII and get back all the ssis or does it have to go query each other service provider that it knows about um independently or do we punt the problem to a user of an application to have out of band figured out what service provider um the other person"
  },
  {
    "startTime": "00:10:01",
    "text": "that they want to talk to is on okay um so that's all I had on the open questions and uh sort of Discovery problem statement uh before we move on to our first solution presentation is there anything else anybody would like to bring up or okay um no news is good news in that case we can move on to the first presentation on the agenda which I believe is femi or is that or Gs are you presenting let's see how that goes I'll do the presentation J is and then I'll all right hang on let's see I'll kick my slides off quite sure how sharing my slides work sorry oh here we go okay and hopefully you'll get buttons in me Echo that let you drive it too yeah seem have if not if not we have a version of your slides loaded and I can drive them for you I think I got the right ones okay there we go okay all yours all right um so I'm not going to go over all the requirements that we went over last time but I didn't quite get to the end of them so uh I do want to cover this last set of requirements uh so these are these are really like the the the nonfunctional business requirements um that I think are super"
  },
  {
    "startTime": "00:12:03",
    "text": "important When selecting a solution here um so first of all we think that no single entity should be financially responsible for resolving all um Discovery queries uh so that kind of in our in my opinion rules out um sort of a single Central uh database and look up Service uh and then secondly sort of related to that the costs for each entity should be proportional to the number of participating users that they kind of own and so I think that that makes the costs part the costs are proportional to the the gains and um makes the discovery service kind of economically viable uh and then the last one is just a quick uh sort of performance bound that each uh Discovery service should should meet uh so where basically we're not expecting uh you know very high QPS here we're we're expecting on the order of each client clearing curing approximately once uh once a day and there will be some heavy caching going on um so yeah I just wanted to set up those assumptions uh Tim uh did you did you want to say something yeah I just wanted to follow up on that um supposition that the PPS"
  },
  {
    "startTime": "00:14:02",
    "text": "would be like once a day per user that would be a function of how often a user is like initiating a new conversation with somebody right um well yeah and how often you want to make sure that your key material is fresh and your yeah your account is fresh yeah okay makes sense thank you yeah okay so um I'm going to skip that slide we we looked at three possible solutions one is a client fanner I'm not I'm not going to go into these um uh in too much detail going to focus on the one that we uh we ended up uh being our recommended solution uh but yeah we we think that the the client fan out where each client just queries the key distribution Services of all possible um uh all possible uh message message services that their recipient could be on uh it's super expensive in terms of client bandwidth uh and it also leaks private information to services that you might not be sending a message to you uh the second one is the centralized Hub uh as I already mentioned uh it doesn't really meet the economic uh requirements that we weet um and also is um kind of politically complicated as well like who do who do you trust to to be the to message liy H Hub you need a Consortium agreement or something or a contract between"
  },
  {
    "startTime": "00:16:01",
    "text": "them um or somebody who's going to agree to do it to to perform that service um so it creates political complication so we we we think this preferred the preferred option is uh what we're calling a Federated resolver service where uh basically each uh each and I'm going to go into the details of it on the next slide but uh each service runs their own resolver on the server side and that is able to Fan out I and either cach the um the mappings or uh query them in in real time um and it uses a uh privacy P private information retrieval protocol to avoid leaking the um the the social graph the queried uh numbers to the uh services that are not actually going to be sending messages Jonathan did you have a question yeah can you hear me yeah okay uh a clarifying question because I think this is sort of the root of some of the disagreements so I want to get it could you go back to the prior slide yeah in your proposal you are not you are assuming that each of these messaging service providers is directly participating in the resolution process in the discovery process there is no intermediate Discovery provider is that correct um no separation no separ of a provider of Discovery distinct from the provider of messaging is that correct correct yeah"
  },
  {
    "startTime": "00:18:01",
    "text": "yeah okay all right I although I guess they could be I mean the the resolver service could be not owned by the by the sending messaging service in this diagram right okay and and maybe it's related to my next question in in this picture when you say client is this like my mobile phone or does client like a different messaging service the client is the mobile phone sorry for not being clear about that yeah oh I see so this is all so I see interesting okay so you're proposing like the WhatsApp mobile app would be modified to directly talk through this KDs resolver to iMessage Facebook Messenger whatever that's what this picture is um it's not really talking through the kdas resolver what happens is it first WhatsApp would first reach out to its server side KDs resolver or some other KDs resolver the resolver would say Hey you can find keys and deliver messages on Services one and two but not service three uh and it would just send that only that kind of bit mask back to the client and then the client would say okay uh give me that give me the keys for this user uh and then send the message to the user um or that could be done server side as well but either way works but it'll be more clear in the next slide um okay I I'll I'll wait"
  },
  {
    "startTime": "00:20:00",
    "text": "uh I think Alissa had a question as well let's see unmuting sorry um yeah so I just wanted to raise this question from Conrad uh because that's in the chat um it also came up on the list I think there's been a little bit of confusion between um the conflation of the key distribution with the um finding out the uh SII to SSI mapping um because there's keys that you need for MLS or whatever you're G to use to encrypt the messages um and then there's this this mapping question which is not necessarily the same so could you just talk a little bit about that so we can kind of level set on when you're talking about key distribution what does that cover something separate Ming Keys yeah sorry I haven't really updated these slides um since we we kind of settled on the SSI or since I understood the SSI SII terminology but um B basically it doesn't really matter what these Services one two and three do like could be key distribution message sending whatever uh the K the resolver just sends you back the mapping the s s i to s i mapping Okay so so the message key distribution could be entirely separate from what you're showing here yeah yeah yeah okay in fact if we have updated this diagram so like basically um yeah if you go no can you see my mouse or no I I can't see your mouth okay so basically everything up to uh the the fifth horizontal"
  },
  {
    "startTime": "00:22:02",
    "text": "arrow is the SSI SSI to SII mapping and uh and after that it's using that mapping to get keys and send a message um so so the sequence SE sequence diagram is first of all um the server for platform one which is the client uh server side and these these first two steps are optional but the the platform can uh C request and cache what I'm calling the Name Records which is the [Music] mappings uh so so each each uh platform publishes it's very similar to DNS right each platform publishes their own um uh mappings for for all other participating platforms to retrieve either uh out of band or in real time and then um when the client uh that means the mobile device um mo mobile app wants to get the the mapping it it sends a p query private information retrieval query uh to their own front end um that means the server side so WhatsApp client sends a message to Whatsapp backend the whatsa back then um"
  },
  {
    "startTime": "00:24:00",
    "text": "uh either either sends a query to their own uh name cached name server or directly to the platform to name server and they get back basically this mapping uh from that so it's pretty simple up until that point um and then uh to to address some of the very uh long discussion we had on the the mailing list in between which is great um we then use that bit mask to reach out to the key distribution Service uh and again like this is a separate part of the protocol to answer your question Alisa but for for getting Keys we we uh Reach Out out to the key distribution service of the platform that we now know has a user with that SSI uh yeah uh yeah and um and returns a key bundle and that key bundle is signed by either the provider themselves uh it's not just the key bundle it's a mapping between the key bundle and the si uh that's signed by the um either by the the the platform receiving platform themselves or a third party certificate Authority um and I I strongly uh I'm of the strong opinion that we should not be defining what those casa uh any requirements for those Casa in this"
  },
  {
    "startTime": "00:26:02",
    "text": "specification I think that should be a separate specification uh you get the key bundle and you send the message uh I see there's a bunch of questions so Tim actually I answered my own question after reading your slide more carefully so let's go on to Jonathan thanks yeah hey so um just trying to understand make sure you understand this and I think for me really important to understand what these entities are like I mean ignore the arrows like I almost don't care like let's I don't even think we're on the same page about what these entities are so I'm trying to understand in your model what these entities are and what their relationships are so let me ask this question so platform one client is like the WhatsApp mobile app and Platform One FR end that's like the servers run by WhatsApp right yeah okay where I start to get confused is Platform One name server so is that I thought I heard you say it it could be could be the same as Platform One it could be a different independent provider of these Services of Performing these PR queries is that right or or or how or in this design is this coupled to being owned by Platform One by WhatsApp for example um it could be an independent yeah it could be an an independent entity um and it could also not exist at all it could be that Platform One frontend reaches out directly in real time to the authoritative name server uh and I I think that will probably be the most common model is that there won't be any Platform One name server um because if you imagine like"
  },
  {
    "startTime": "00:28:05",
    "text": "let's suppose platform two is WhatsApp and platform one is a much smaller provider uh you don't want and this goes back to the requirement I said at the beginning uh you don't want Platform One to have to retrieve synchronize and cache the entire data base of of WhatsApp when it only has 10 million users right so WhatsApp has I don't know three billion users I don't know what the number is but so so we don't want to force any entity to cash not only WhatsApp but every other large [Music] provider in the in the system right okay does that make sense yeah yeah it does um I think it's good too because this picture at least is much closer to the GLaDOS picture so I'm trying to understand what's different and whether or not your proposal was like fundamentally in opposition to the idea of a discovery Pro provider being distinct from the application provider and what I'm seeing in this and previously it was but in this it's not so so that mean here what you're saying is sometimes it is sometimes it isn't the same as the application provider is that right yeah yeah okay thank you and and the the KDs and C is that clear hopefully what that what those are key key distribution service um Alisa so uh so just one more question on this and then I have a separate question which is that um what it sounds like is that the the first your first two errow there that Exchange is um it's basically optional for a"
  },
  {
    "startTime": "00:30:01",
    "text": "platform that wants to cach the records of a certain other platform so a given platform might take this step for some interoperating other services and not for others or not at all um it's it's totally optional and it's on a it's decided on a pairwise platform basis I can cash ex to have the records cached yeah it's not just platform one but also platform two has to agree because of rap lenting Etc yeah okay so then my other point of clarification is the first Five Arrows here consist of the discovery phase and then yeah from then on we're just talking about generic Mimi whatever that means um like once the once the um the requesting platform has the the identity the the SSI for the other service that is interoperating with from then on we just bootstrap a communication in the same way as if you never went through this discovery process like if the if platform one client came into its interaction already knowing what the SSI was for the user on the other end um you would just proceed with the bottom half of this um this diagram according to however however we decide that Mei Works in other words there's nothing time these two halves together or am I missing something no you're right um but if we my understanding was we wanted to do in this subgroup we wanted to do Discovery and identity and the sixth and seventh arrows are important for you know establishing Trust in identity because you have somebody's vouching for the"
  },
  {
    "startTime": "00:32:02",
    "text": "mapping um between the key and the and the identity okay so this is your proposal for how to do that okay I got it thank you yeah my very sinful proposal yeah um yeah uh Eric I I do have another couple of slides by the way but um so um sorry I had I with a little earlier so I may have missed it when you said this but I guess I'm not quite sure I'm following sorry you're you're really quiet um oh okay uh that's better I think okay um so H I guess I'm not quite following what role p is playing here which is to say that um as I as I as as as I as I read this diagram platform one is very quickly going to learn who the user is talking to as soon as the user requests the keys and the only person that PR is can steal that information from is platform one so I don't quite understand what PR is doing here um yeah I think that might be a missing Point here is that the the request for the keys is um is tunneled through Platform One but I guess I don't I guess maybe maybe I'm just confused about what we're trying to do which is like we're trying to conceal from platform one that his user is talking to a specific person on platform two that's part of the design design constraint um we're also trying to I think the main point is trying to con conceal from platform two if platform 2 is not a platform that you're about to send a message to no okay that that that I'm on board"
  },
  {
    "startTime": "00:34:01",
    "text": "with but then but then but then what is the pr doing because this is only going to platform one's name server that's the part I don't understand like if it was going to platform two i' totally get that but like it's only like yeah I think that's a mistake in the in the oh okay good and we're on the same page thank you I think the point is if the if the name records are cached by Platform One [Music] then uh then Platform One also needs to uh well sorry if they're not cached if they're not cashed then then PR yeah so I think let me see if I can restate the design requirement um uh which is that the the if um the pair of the pair of platforms will actually be used for the conversation become aware if who's talking but platforms are not involved in the conversation and do not have a a record for the user do not become aware if who's talking is that is that a fair Des exactly perfect I I'm on board with that and I think I understand how you're trying to do it thank you right yeah yeah I think we need to update the the diagram it's not not very clear from that yeah just uh just one more thing on that um just to just for clarification the so that means that this the initial P query you don't need the initial the initial query to use P um if the name records are cached was that when you were saying there was an error on the slide I think so I have to think it through but yeah I think that's right okay yes just a quick thought yeah so in some the model we are looking at is on your device you have multiple phone numbers or service um independent identifiers you have"
  },
  {
    "startTime": "00:36:00",
    "text": "multiple services that you use whats have you can have messages different services so from the perspective of your client you really don't want a single um name server to learn your social graph completely so in a sense it could make sense to use Pi for that state yeah yeah I guess that yeah that applies to a a cached name server and a and a destination name server that doesn't know your that you're not going to send a message to you does that make sense um anyway we'll we'll make sure it's clear clearer uh uh Watson hello Watson lad so I have a question about where where does key transparency fit into this is that something we'll put in with the public key bundles coming from the platform 2 KDs well I think get that would be an indep a separate service so um yeah I mean the this I should have numbered the steps but uh s steps six and seven are the key distribution part but if you want to have a kind of independent Ledger somewhere else that you check against that assertion that would be yet another qu that you make to a different s does that make"
  },
  {
    "startTime": "00:38:07",
    "text": "sense so it's not none of this includes a a CT like service that um like WhatsApp has just launched I don't know if you saw that uh okay say again thanks Bears things up okay great uh Tim thanks so I'm curious how this works in the setting where there are multiple ssis for an SII my reading of this sequence diagram is that effectively Platform One front supposing Platform One run front end had multiple cash records for the SII mapping to different ssis across different service providers does Platform One front end get to choose on behalf of the client which um other platform it's going to select uh that's the next slide um okay and yeah and I'm also curious because I saw there's the mention on your side about like default service and preferred service and that seems like a consideration that like is higher level than an individual SII to SSI mapping so I'm curious like how does a client ever express that and where is it stored because it feels like it doesn't belong in an individual service providers um SII to SSI mapping but I'll let you present this slide um yeah so I think the I think it does uh I mean I'm not sure how to deal with I'm not sure we thought through how to deal with conflicts where two different name servers claim this that"
  },
  {
    "startTime": "00:40:01",
    "text": "they're both the preferred service but I think we're assuming that they're all kind of honest and in that case basically there would be a bit um on the name on the mapping that says that this service is the preferred service for this user um right and then and that would have to be you you don't want anyone to be able to uh hijack that pre preferred service bit because it could be a an attack Vector as well uh and so we want the proposal is that that bit uh is is signed with the private key uh with the with the user's private key and then you verify it uh on the sender side before you decide to select that one yeah um so yeah um Conrad yeah maybe we should break H this discussion and continue with the discovery part but I have a questions on the identity part and you noted that the identity might be bound to the SII by the CA and so I'm wondering how that works um and this is also kind of I'm thinking with the with the mechanics that you just described where you're looking at a signature by the client over who is the default provider but if you get the signature only by actually like what what key are we talking about and don't you get that key only after isn't that that would be a provider specific key no and so so which provider's key would it be and so yeah I'm I'm and and also you know if a phone"
  },
  {
    "startTime": "00:42:01",
    "text": "number or an SII changes um then I'm just kind of curious about the whole mechanics of of of binding of how the providers bind the how the how the SII is bound to the SSI cryptographically and what the how if if one of them changes how does that work um and how do clients manage that but maybe we should Discovery first like feel free to you know not answer I can I can do a quick answer that you you you seem to be saying there's a bit of a chicken and an egg problem but I don't think there is because this this this selection happens at the point where you know there's a set of services that that have an SII for this SSI so you've got the full set of mappings and you just want to know which one of those is the user's preferred one and so you could go and get the keys for all of them and then verify which one is the the preferred one and I don't think there's a chicken and egg problem there um sure okay fair enough it's it's only your trust in the bit in the preferred service bit that's at stake here and not not your trust in the mapping at this point and the mapping is asserted by the service provider as CA model right or or a third party CA like whatever um basically whatever response you get to in Arrow seven return public key"
  },
  {
    "startTime": "00:44:01",
    "text": "bundle M that is the kind of identity assertion yeah I also be interested in in how like how does it work if an SII changes and then you know do you have to repick up all the assertions you have to do the all the the whole recovery or if an SSI changes vers how the Bing system works that's where the requirement I set out at the beginning like how often do you want to refresh this before you send a message uh you know obviously you can't do it before every message uh probably uh so I think it's a trade-off between how uh between the cost of doing this query and and how how fresh the the nothing is but basically you have to reperform the query there's not going to be any push push mechanism available okay yeah right thanks can you go ahead to the next slide because I think I'm not quite sure I'm following so is the concern here that I have an account with um the the recipient um H um has an account with service a and service B and he actually prefer to receive message on a but B asserts that he would like to re receive message on B um yes and also like kind of worse than that is uh meatbag a has an account with with SSI um one with a service"
  },
  {
    "startTime": "00:46:00",
    "text": "a meatbag B has an account with ssi1 with service B and meatbag B is an attacker who asserts that the pre preferred service of meatbag a is service B so like basically they get you to send a message to an attacker could get you to send a message to them when you think you're sending a message to uh somebody else we' got it in our in our proposal you can look at the the steps I it's kind of okay okay I can take a look but I feel like you've lost me because I just inherently inherently speaking like we have like we have like a E64 number and that corresponds to like the is is is the you know is is the original number is is is the SII right and oh yeah yeah but we're not only talking about phone numbers here right we're we're also talking about arbitrary strings that don't have proof of possession attached to them like a phone number is different because only one meatbag can own a phone number well but even but I guess even with the phone number the problem is the problem exists because we have two Services Each of which are certain that they own that they have a a user that phone number um like so I type in I type in your phone number and you are somehow and and the attacker is somehow persuaded you know WhatsApp to assert that it has a user that phone number there's like no way to distinguish those cases like without the external C right like if you and I if if if you persuaded if you actually have a have a phone an account with Google that corresponds to your phone number but WhatsApp is screwed up and they've given somebody else an account with your phone number like those are those are those are those are symmetrical positions"
  },
  {
    "startTime": "00:48:02",
    "text": "um yeah I mean I guess uh if there is proper authentication it be quite difficult to give your phone number as an account in WhatsApp right well but I mean but I guess I'm trying to understand is the hypothesis that the attacker had the attacker actually is willing to represent a phone number they don't own or is this they're not if they aren't this problem is very easy if they are I don't see how to solve it without like a central search CI right um because there like no sense in which there's no sense in which whatsapp's assertions are superior to Google's assertions yeah uh I have to think about that one more you you might be right maybe maybe this is not necessary I so to be clear I do think we need a mechanism to a correctness mechanism which ensures that user representations about which service they wish to receive on are correct um and that means that as Watson was suggesting like that if I change if I if I go if if I have a WhatsApp account and an iMessage account and I and I and I tell iMessage I want that to be my default like I want to rece an iMessage that shouldn't require WhatsApp to do anything to make iMessage Superior right um but I think that has to rely on me controlling both accounts and so I think there's a between like you know as long as I'm as long as what'sapp is so like I mean to give a concrete example imagine you imagine the record you post was just a signed assertion that I want to receive on or that I will receive on on this account that's got a time stamp well what'sapp shouldn't generate a new one new time stampless I press the button again on WhatsApp but I think that's different from what'sapp is trying to steal it I don't I don't how to solve that yeah I think what what we were thinking is the the way to solve it is uh the only we way to solve that"
  },
  {
    "startTime": "00:50:00",
    "text": "is I have to tell you I have to tell you out of band receiver has to tell the sender out of band that they have a WhatsApp and an iMessage account and if you get if you get a if you get a uh a message or if you are told that I have a account it's a lie right um Jonathan yeah so I'm I'm gonna I'll repeat my request I guess which is we are our our biggest areas of Disconnect between these two proposals and the problems in this working group in general are not about the lines in these sequence diagrams but what these entities are and what their cardinalities are and we and so and that so that's why I'm my questions are always going to be about that because we're just not on the same page yet I'm trying to get us there in this picture you've introduced two new entities a service UI and a resolver I don't know what those are who who are those can you give me an map it to an example is resolver WhatsApp back those two names were not in your previous diagram yeah yeah sorry are these new components of the same actors and what are their card ities please yeah sorry we're a bit sloppy here um yeah so the um service UI is means whatsa back end and the resolver is the uh let's let's go back to the previous diagram sorry um so the"
  },
  {
    "startTime": "00:52:00",
    "text": "um service UI means Platform One front end it's it's basically like everything owned by WhatsApp where the sender would um sorry the recipient would register their their account and their preference okay and then um the resolver is uh actually sorry it's platform to uh name name server right uh service UI is is platform to name server so it's like it's where I register my preference okay yeah and then uh the resolver is either Platform One front end or Platform One name server depending on whether you have a name an independent name server okay where it would be helpful to try and be you know put it in those terms but I think there's a cardinality problem and I think it's similar to the issue eer was talking about which is I think we have a requirement that I as a consumer can have multiple messaging applications I I certainly do I don't know about you I like one of everything pretty much on my phone um and by the way they all you all do mobile number verification with all of them so the number of providers that I work with that use my mobile number as the SII is also a cardinality of greater than one so I think we're also solving for that case so when you want to register a preference between a set of providers and I am a consumer of multiple providers to which one do I register that preference um well we like I said at the beginning we we we assume"
  },
  {
    "startTime": "00:54:00",
    "text": "that the registering party is dealing with is handling the uniqueness of their preference so I'm not as a as Jonathan I'm not gonna set a preferred service bit on more than one service provider so I think that's an important requirement I I I don't think that works and and it doesn't work for the same reason it it didn't work in like the mobile number reporting use case like if you look at that too which is like hey I want to change it's always the receiving provider that does the work and you don't have to depend on the original and let me put it in concrete terms like let's say I used WhatsApp for a while and I said it as my preferred provider and then I I lost my phone I got rid of it I forgot my password and I even forgot I ever used WhatsApp then I go and I get Facebook messenger and I love that and I said it as my preferred provider I literally don't even I don't have the password I don't have any I don't have any way yeah to go and remove that from that previous provider so I don't think you can assume that a a user an end consumer is accountable for ensuring that this piece of information exists in one and only one place at all points in time I I do not think we can make that assumption yeah I also don't think we should have a we we should spin up a central service just to deal with this I mean we have to think about it more but I think I mean you could you could attach a time stamp and take the latest time stamp and to resolve that problem um Harry yeah Jos I was just gonna say what you exactly just said which is like the way to solve this problem is that every time you register as a preferred provider you timestamp that Reg registration and then you as part of this thing you collect all the list and then you L the greatest time stamp and as long as you trust the services not to"
  },
  {
    "startTime": "00:56:01",
    "text": "like generate fake timestamps that are newer which not supposed to do this will totally work so I think that that problem I think is entirely soluable okay yeah so we should add that to the to the design thanks great Point all right um we have some more slides about the p p uh of the queries um I don't know do should we go through those real quick as well um yeah I think that would be helpful given that we spoke about earlier yeah so Fe take it away I'll trve just tell me when to move the slides I can't hear you Fe I don't know if others can can you hear me now yeah okay thank you so the approach we are proposing to hide the user social graph in particular in many of these Discovery scenarios a user will hold a sensitive um SSI or Si and will not want the server to learn exactly what those SSI is so p is a basic primitive cryto primitive that we can use to preserve user privacy in all of those scenarios so but for this uh deck we just going to see how we propose the use of Pi to prevent the leakage of the user social graph the scenario we have in mind is a user can do Point look up by looking up a specific SFI or the user might do e in bash just"
  },
  {
    "startTime": "00:58:04",
    "text": "plug your phone overnight and download all the key materials that I I would need to communicate uh end to endend encrypted way with all my contact so those are the two type of scenario we are looking at so Pi is a very well developed area of study it hasn't been widely applicable in the past but there are more recent development that we think make it a very good Fe to solving this problem next slide so I think I I should I won't go so I probably won't don't need to go over the because I went through all the time but I can just talk about it very briefly so the p scheme that we are really targeting for this are those that based on additive or fully homomorphic encryption scheme basically we can encrypt a value and perform basic arithmetic operations on them while still keeping the result encrypted next slide so for those that are not familiar with PR problem the problem is simplifi as follows we have a database h on the left side and we have a user with an index four in this case that means I want the record at index 4 and I would like to ret this record without the database learning that I'm interested in the letter D in this particular case so how does the us query query that in a private reserving way which is the type of problem we are"
  },
  {
    "startTime": "01:00:02",
    "text": "addresses so basically the user will represent our query as a b string that is zero everywhere except at the index of Interest where the datat is set to one and then encrypt all the bits individually and then forward the encrypted bit to the server the server does prse multiplication of each of the encrypted bits with the respective database record as you can see the result is still encrypted it doesn't know which of the result contains a value that the user is interested in and at the end it sums up or the intermediate result sends it back to the user and the user is able to decre crypy to obtain the record of Interest next slide please so the scheme we are proposing is based on latices which we can use for all the type of lookups that we are interested in basically it turns any of the standard ltis based PR into a keyword based PR basically the standard P expect that the user knows the index of the record to retrieve but for this um Mimi use case we know the SSI or the SII so those are keywords that we will use to privately query the data so it's a very good Feit for it so it does that by kind of doing an offline process where the database is kind of prep preprocess combined as a linear combination of his record he also needs the client to store"
  },
  {
    "startTime": "01:02:03",
    "text": "some metadata locally in order to run query more efficiently um there are recent advances in pi which is called recursion instead like the example I show remember the query we send is linear in the size of the database so we sent an inced value for each record in the database but with compression we can send two dimensional recursion we can send square root of hand Cipher Tex which is much more efficient we can even go into higher Dimension to a cubic rout and even reduce the size of the safex that we need to send an additional technique that is used is compression and OB lious expansion which is basically we can compress the query in such a way that we only send a single Cipher text to the server as a query which is really very efficient and then the server get gets it the Ser that is sent to the server is like an encrypted polom and the server is able to obliviously expand that polomia into the SE that he will use to process the query he has great performance that that makes it really practical next slide please um I have a quick question on that slide sure how does the client know the full list of uh Records in the database I think you said that the client has to yes yeah there's a there's an client initialization an offline stage where he needs to download some metadata about"
  },
  {
    "startTime": "01:04:02",
    "text": "the database that it will use in subsequent queries yes it's also on the next slide yeah okay thanks so just a little bit more we have an index based database we can convert it into a SP or keywords based database depending on the size of the database it needs to be broken up into smaller shuns which we call shards and for the for our experiment on this we tried for a million um record database we think that is a good size for to give reasonable performance so for each Shard we also need to do partitioning and en uh encoding of the database to make query much more efficient so all the metadata that is required for this like the shart key the partition arh key and the partition boundaries the client will need to download them at an offline phas prior to running queries so at query time the client will interested in uh the the value at uh value seven in in our data base the client will encrypt a polom just a single Cipher Tech as we see in this query and it falls it to the server the server does pay out like as before and returns a response which is exactly the record that the user is interested in next slide oh think there's one more there's a slide on the number almost yeah yeah I think this is the most important one for this group"
  },
  {
    "startTime": "01:06:02",
    "text": "yes so this is the result of our experiment we look at 10 billion records each record of 128 bytes in size for a total of 1.2 terabyte database and we split it into 10K Shar each with a million record each so the number on the right are the performance number for A Single Shard in in the database so the 40 megabyte is the public story that is required on the device this is an offline thing it's a onetime process the user doesn't need to do this download every time the upload band wids is the cost of the query that the client send to the server the download B download band per query is 21 kiloby uh the time it takes the client to compute the query is just .1 second and for the server to compute the respon using just a single thread is just about one second next think that's it all right m Jonathan hi um I thought I heard something I want to make sure understand that there's some need to transfer data ahead of the query can you can you say more about that again because I'll repeat my my comment from previous the main foundational complication in this whole thing is who these entities are what their business relationships and Trust relationships are and what their cardinalities are so the most these are"
  },
  {
    "startTime": "01:08:02",
    "text": "really important considerations like who's needs to have this information and how many of them are there so can you say a little more about what is this information that has to be sent ahead of time yeah so for the client to be able to query a database using these techniques right he need some airpad data for example he needs a hash key to determine which of the Shar of the database he needs to the query should be directed to so the client downloads all these L data one time it's an offline process when you say CL in your model is client like between providers so WhatsApp is going to download these Shard keys from Facebook Messenger is that what you're saying no no client is just the phone the user's phone I I okay now I'm really confused I thought I heard J say J mention in the previous deck the Cent it was not the phone in his response so that's not what he said so now I'm now I don't understand again that's not what J said J said it was the back end like WhatsApp servers would be doing this no that the that was the caching of the name records this is a different part of the protocol so that this this caching part was not one of my sorry this um pre pre-query step is not part of my diagram all right is there a picture somewhere where that shows who between which components this information is"
  },
  {
    "startTime": "01:10:00",
    "text": "transferred uh I don't think we have that in our deck though um yeah well the slides that just cover previously with the sequence diagrams this one yeah where which arrow is the preach it's not in that diagram but it would be between uh Arrow 2 and arrow three right F that would be right yes and it's between which two boxes so because the download is offline in the sense that it's not time critical so we we did not show you like so what like it that is not no one no one is bothered that it takes 0.1 seconds versus 0.5 seconds in real time I'll repeat again and maybe you don't agree with this so we should talk about it I think a really critical problem for us to solve in this working group are who are these entities what is their cardinalities and what is the level of trust we have between them so it really matters like if this proposal only works because the WhatsApp UI has to talk to every single messaging provider in the system and download something like I don't think that's going to work and we can talk about why I don't think it's going to work but it's certainly very relevant to the protocol so I do think it's really important even if it's not in real time that's what I'm saying I think it's important even if it's not in real time so it would be can you just elaborate on which which components in this picture that download would be between so the download will be between the platform one client"
  },
  {
    "startTime": "01:12:00",
    "text": "and platform uh 2 KDs okay and that's okay got it um even though I thought the P I guess where I was confused and I'll let of those come in here I thought we were talking like your proposal was a way to formulate the P query which is shown here as Arrow four so I don't think that's right for me like the K the KDs query happens after you've already done the P query I think it's between the uh authoritative name server two platform two and the platform one Cent right oh yeah yeah I thought it was referring to the download right yeah but but the P query is on the name server records not the keys oh yeah for this yeah um I think I think we shouldn't try to resolve this question now I think we should take Jonathan's question and fles out the answer in our in our document and um and then we can get back to the mailing list with that it is an important question I agree is that J I think it's super helpful because it um you know yeah what what are and because the trust relationships matter yeah yeah yeah definitely and also the"
  },
  {
    "startTime": "01:14:00",
    "text": "the costs it's important to understand the costs uh like that query is not small so [Music] um uh yeah okay uh Eric so I think back to I think this question trying to ask is back to the threat Sor you're really quiet again sorry okay I this question Jonathan is trying to ask is back to the threat Mall which is are we trying to conceal from what are we trying to conceal from who and there's one model we're trying to conceal from platform one which user the client is interested in and there's another model we're trying to conceal and of course from platform two there another model we're only trying to conceal from platform two uh which user the client is interested in and in this diagram you have like an end NP between platform one and I mean so I think that as we discussing that arrow is supposed to go all the way to the right but um you know platform two this Arrow number four um um but um if we're fine with Platform One learning what query the user making then all the pr mechanics can go between Platform One and platform two and the user client does not to be involved at all right um and that actually I think is an important consideration um for probably for the reason Jonathan said which is if there this is a system with 50 servers and I have to do a 14 megabyte download for each of them that's a lot of data right even if it's only one time um and um and so like I think we really need to get I think like I I I'm I'm excited about this PR stuff um I really am but I think but I think we need to figure out exactly what the threat model is and we know what where the end points of the pr apparatus have to be um um um and I think also I think if we can convince ourselves that we don't need to protect the user from his own provider then this"
  },
  {
    "startTime": "01:16:01",
    "text": "plausible because um those the cost mechanics of the pr are much more easily born by the provider than by the and I think I think you're right we don't need to protect the user from platform one frontend but but if Platform One well if the name server is a secondary name server that is not Platform One then we do is not owned by platform one yeah but yeah we'll flesh this out and um we'll we'll put it in the documentation great um I think we should move on to the next one um appreciate the presentation from both of you thanks a lot um I do think yeah the having the written threat model and and a bunch of the clarifications that we talked about today in an updated draft or um uh message to the list from you guys would be super helpful I also think like just the process of doing the threat modeling we're going to have to be more specific about who all the actors are and what the trust relationships are between them and so that would I think get to some of the discussion that we were having earlier and then the only other thing I would just say um because this is a new topic for the working group I think I feel like we are many steps removed from like being able to analyze like which Pi are and the different flavors and the cost benefit I mean the cost benefit is kind of wrapped up in the architecture a little bit but um you know some of that for for this group um I think we're at both an earlier phase and also like that might not necessarily be um our domain of expertise uh as as the locus here and so we might you know want to bring in some other people in um cfrg and other parts of the ITF that um who can help us kind of sort through that when we get get to it but it's a little bit early on our end so I just want you to note that like it's not that people aren't responding but that um many people here"
  },
  {
    "startTime": "01:18:01",
    "text": "might not really have it in their wheelhouse to be able to compare different P schemes and evaluate their their um pros and cons so um we can take that for for a later time with that I think we should turn to Jonathan thank you thank you all right we gonna okay great I'm just going to show the slides outstanding okay great um cool let's go to the next can everyone hear me we can hear you okay all um so I I continue to believe that a lot of the disconnect actually lies in our different views on these basically this slide actually the requirements and assumptions which largely about the cardinalities the actors their cardinalities and their level of trust this is why I keep harping on this question I think if you come to the same point of agreement on that you your protocol choices sort of narrow down and and fall to what a lot of what I think is in here um so so here's the core parts of it um so the first one is that I do believe there is a separation between the application provider and the discovery provider those are different entities they can be the same but I think they will often not be the same and that has to do with trust and that's because in my model there's a lot of these application providers application providers like the guys doing messaging services the WhatsApp the Facebook Messenger but more importantly and I spent a lot of time on this in the requirements document I'm interested in"
  },
  {
    "startTime": "01:20:01",
    "text": "solving for cases where these include like business SAS providers and large Enterprises where you can get into the categories where your messaging providers people are implementing the core Mimi Protocols are in the in the hundreds probably I don't know about thousands but you know it's in the hundreds so once it's in the hundreds it no longer in my view becomes feasible for for those people to act as the discovery providers and also you just don't trust them and there's enough use cases where you don't trust many of them and therefore I believe there's a requirement and that's the Assumption in this protocol that there can be and often will be a separate Discovery provider once you to say that the question is all right well how many Discovery providers are there are there one are there more are there like a a dozen or are there thousands and in this proposal it makes the assumption that there is more than one it's probably like less than 10 it's not large number but it's greater than one and they will largely be driven on geopolitical boundaries so you know I can imagine there's like a you know in the US there's two you know in Europe there's one you know these kind of things it's a small cardinality and they have high trust and they in fact exist only because we need a thirdparty trusted entity to mediate against the partially untrusted messaging providers those are the like that's the core requirement like if you don't agree with all that then Mo most of this rest of this protocol seems like way Overkill uh so I see people are in the queue so uh let's let's go at it yeah I don't agree with all that um in particular I don't I think the geopolitical thing is just like a non-starter um you know um for like any number of logistical reasons so um um the situation requires like each jurisdiction standing at their own thing like we're never G to get sorry no no no I you're I apologize no I'm not I'm not over reading that I'm the better way to"
  },
  {
    "startTime": "01:22:01",
    "text": "delete SL bullet one and say I believe there will be a number of Discovery providers greater than one and there's a there's a few reasons for that what's that yeah so why um okay so this is this is good so like it gets back there is a geopolitical aspect to it which is like I thought about the just one case in fact the original version of the protocol had it just one and the problem is it requires like everyone to agree that I'm going to upload my Pi personal identifying information right my email addresses and phone numbers and mappings to their service providers to some entity and and the belief that that we would be able to align on a singular entity we being like the internet align on a single entity that everyone will trust um for that seem minimal especially in light of like a lot of this gdpr regulations where they don't want storage of this pii to ha have to be outside of uh boundaries made me think that you know we're going to end up in a situation there we're going to have more than one and that's the the the way in which I think about geopolitical well I think I think this partly gets back to this question that we were discussing last time which is what is the Privacy situation or security situation around data right namely is this data inherently public or is this dat inherently private um and is and um if it is inherently public then like it matters a lot less where it's uploaded to right I I'm afraid I don't agree with that and at least I don't think that's what gdpr says either like I don't think gdpr talks about whether the data is public or private when when you talk about personal identifiable information it's information that's about a person of human nature and in this case it is that an email address a mobile phone number count as Pi and it's storing information which is who is their provider um we have others like Alyssa who are far deeper experts on"
  },
  {
    "startTime": "01:24:01",
    "text": "gdpr than I am but like that my read is that it is not about the public or private nature of the data it's just about whether the data is about a person sorry I'm thinking at public or private in a technical sense not a not a social sense what I mean to say is is it a problem for me to have a copy of this database namely like so again there's going B like this stman that like that like I last time which is like data is posted on cloud anybody can download it and and you know the whole thing if you want um and um and and I think that the the um um if you think that is a if we're trying to prevent that then we actually have to ask we're doing to prevent it and we're not trying to prevent it we should Adit we're not trying to prevent it and like it's a whole different closet designs right and the um and um you know and I guess to my thesis is actually can't be prevented in any meaningful way so um um um so um because like rate liing is not gonna work and I I'm having to go some detail if you want but um um but like so then maybe that's not maybe for gdpr it's not required pretending to prevent it it's actually required than actually preventing it but um um but like um you know I I do think uh um uh I do I guess I guess I think we start what we're trying to accomplish here um if what we're trying to accomplish here is Access Control in this information then that is something then the question is what is the access requirement trying to trying to enforce yeah yeah got it so I I think we're again what this document is assuming and this is not well spelled out in the slide so I apologize for that but what I think it's assuming is that it is not acceptable to store the data in a singular place that there are going to be requirements that limit where the data can be stored so that's assumption number one so that means like for me like storing all in Cloud flare I I this assumes that that's not okay the second assumption that I'm making is yeah that this data is at least somewhat sensitive at least it's sensitive in its aggregate meaning information like oh isn't that funny I just learned exactly how many"
  },
  {
    "startTime": "01:26:00",
    "text": "users each messaging provider on the planet has um that like a normal SAS provider like my exact count of my customer base is considered sensitive information so something that information is not something I want anyone to be able to get and so the system of course some amount of access to this data as a whole is necessary for the protocol at work work so you're trying to what this is trying to do is limit it says I don't I want to protect the data and Aggregate and just give access to query response because the aggregate data does actually have privacy properties too that's the Assumption okay I mean so like yeah it's not helpful to do here but I guess like I me I do think when you engage with this problem that scraping is essentially hard to hard right um namely like so I think just like to say what I said on the list there today right is like any any pable provider of moderate size is actually going to be querying the almost entire database at the end of the day um um we almost um at least at least of cardinality some the entire dat base right if you operate 100 100 million users um and each of those has you know has 100 adjacencies you have to quer 10 billion records basically right and now you may know that there H overlap and nobody else knows that right and so like the bottom line is any plausible fighter actually have access the entire day of the day um in Oracle form um and so um like like unless you told me how to prevent that I think like the problem like like then sit is actually like then like the mechanics are trying to like conceal it from the big providers is actually not very helpful okay well again in the model I was proposing here uh that that was I was trying to solve that through rate limiting again we can we can have an argum this this is what they're supposed to do right my point is if I have 100 million users and I have and each and I want to build the dcy table for all of them then I have to query for all their docies and that means I to do 10 billion plus or minus queries right and so that"
  },
  {
    "startTime": "01:28:01",
    "text": "means that even that within the rate limits I'm gonna actually be querying for essentially the entire database but even if I have Oracle access so if you have perfect information the the rate limits it's just legitimate legitimate operations to in query for basically the entire database and so at that point why not just give them the entire database maybe maybe I'm not understanding you but I'm thinking of the following use case so so we have a huge provider like WhatsApp that has like a billion records say yeah and a small provider called like I want a copy of this database and I'm a bad guy.com sets up a bad bad and they and they have 10 users so let's that I that I agree with that I agree with um what I'm saying is like you're not gonna be able to stop Apple from building a list of all Google of all WhatsApp users I think that's very likely yes that I agree I age that probably any moderately sized provider say 10 to 100 million users right well yeah yeah well got like three of them so I'm not overly worried okay okay good okay but but so so okay but I agree with you I think we can stop I think we can stop like you personally for speak the entire day base that I think we can do okay great that's what and that's what's partly is is try to Sol thank you so um a couple of things one is that I really think it would be helpful to distinguish between the the properties of the databases and the properties of the accesses to the databases and honestly I find the gdpr the data localization mandates all of this stuff is like it's totally a sideshow because it relates to like the governance around the databases themselves we have like lots of distributed services on the internet the way that each operator of each service manages their gdpr compliance is like up to them we don't talk about it in the ITF it's not very helpful from a protocol perspective as a normal matter and I think that's very true here whereas like this question about who gets to know what about each access to each database that's what we"
  },
  {
    "startTime": "01:30:00",
    "text": "really need to come to agreement on um and we talked about it a little bit in the Google Presentation I think we made some progress on that which is like everybody I think agrees that um you know if Alice is on service a and Bob is on service B then service a gets to know that Alice wants to contact some generic understanding of Bob's identity and Bob himself gets to know that Al and service gets to know that Alice is contacting Bob and then there's a bunch of other services that we do not want to have know that Alice is is trying to sort out Bob's identity so like that part is interesting and we need to understand the identities in the in the um you know all the protocol Machinery but this like where do the databases live and who who controls where the databases live I don't think is is very useful for us um I also want to come back to this question which you sort of pointed that can can I ask a question response Alissa so does does that mean like so it for me it's a reason why let's like I don't think a model wherein there's one Discovery provider that has all of the data is viable now maybe it's not viable for other reasons but if if unless someone thinks that's the solution then then I'm happy to never talk about gdpr again um do you think that I guess I want to I want to come at it from the other end because I feel that there's there's a there's a strong assumption in some of the other proposals that um that the applications providers will be one type of Discovery provider like applica like some applications providers will also be providing Discovery services and like if you agree with that then we don't have one we have numerous so we don't need to we don't need to talk about whether we have one or not because we already are assuming we're going to have multiple okay I'm good I'm good think so that's where I that's where I was getting to so then my but my question for you is I think kind of the reverse of what you asked Giles which is if um if you also"
  },
  {
    "startTime": "01:32:03",
    "text": "feel that it's important to accommodate Discovery services that are operated by entities outside of application providers so do we have independent Discovery services and application provider Discovery services or do we only have the ones that are run by the application providers it is my belief that they we have to support both models okay good to know thanks Jonathan if I could fast follow on that just real quick could you expand on why you think we need Discovery providers who are not application providers yes yes because of the trust problem because I'm worried about this you know this use case I just described which is a lot of smaller messaging providers and those can be small consumer apps but more importantly they can be Enterprises they can be UK you know bit UK ccas cpass providers um and so once you start and this is all my requirements document it's why I went to so much trouble to outline this because I I think it's it's something that's not something we're all align on so I do think there's a world in which the cardinality of those is in is in the hundreds and once you have something with a cardinality of hundreds and they include Enterprises I think you will have malicious players and so a big problem I was trying to solve for is how do you derive trustable mappings when you have some providers who you don't trust and the one and one of the ways you do that is you separate them so you say okay well I'm going to solve it by having a separate Discovery provider and that discover de prider actually validates the mapping thems because they don't trust the messaging provider to do"
  },
  {
    "startTime": "01:34:06",
    "text": "it this is sort of covered in the slides that are to come well are you still first in Q or no okay Watson hello so I think I maybe not following the part where you're saying because we have all these providers we need to separate out the discovery I mean I think really that's a that that's not a problem statement that's a solution and the problem is to get the property Alyssa outlined if Alice wants to talk to Bob the only people who learn anything are Alice's service provider and Bob service provider and Alice's service provider knows that Alice wants to talk to someone service provider B and service provider B knows that Alice wants to talk to Bob and you know that's sort of the minimum amount of information you need if you want to do things like offline status and deliver when Bob comes back because that's inherent to the nature of the communication so if we are getting that property why do we even need to have the discussion about limiting the discovery provid I mean it seems to me like actually this is saying no the Discovery providers are are not being are are have too much power here you can't make everyone want and then the validation so I think the previous previous uh case toss it out to the ca so said super under the rug to I'm glad that you're not doing that um but that seems sort of that that question of how do you validate the mappings seems not we don't have to validate the mappings you you sign them by by some key it's not really connected to how you find them in the first place"
  },
  {
    "startTime": "01:36:00",
    "text": "I think that's sort of at the root of my confusion with what you're talking about yeah so so to me the problem is you know public key crypto doesn't magically solve this the problem I'm worried about which is how do you trust the that a like put it put it let's go back to your your your framework a said like what I care about is like only provider B should see that a user and provider a wants to talk to a user and provider B this makes an assumption that the user actually is a customer of Provider B so again the the use case I'm worried about preventing is malicious provider that claims a particular phone number is a user of their services when that user is in fact not a user of those services and that malicious provider in your model would therefore be able to see anytime user someone else wanted to talk to user B they would they would see a a query and that gives them access to information so let me let me give give a concrete use case so let's say I'm a bad guy messaging provider and my objective is to like find out whether there are people talking to a known Target so I want to go after the CEO of some big company Tim Tim let's pick on Tim cook so I want to I want to attack Tim Cook by learning more about his social graph so I set up a fake messaging provider I claim I find out Tim Cook's phone number I claim that I own it now I am going to in many protocol designs get queries to discover this phone number and and I can reply yes it's me I I you know that I am a provider for that phone number um and then at the very least get connection requests and other things and other traffic I don't want them to see that that that that malicious attack can see that is the core attack I'm worried"
  },
  {
    "startTime": "01:38:00",
    "text": "about preventing I guess I also respond to that I'm next in the que I don't see how you solve that without having some kind of like allow list or standard criteria for participating in the interrupt system ah great so so that's good leading to the slides which explain my solution so you know I did have another that was a response to uh previous commentar uh to Watson sorry and um but my other comment was I agree that we need multiple mapping resolvers um but not because of gdpr I think that this D the data that we're talking about here is there is an account with a phone with phone number X and that data is already public as we've said a few times so that's not I don't think that's a good reason for for multiple providers but the reason is that like as has already been said we number one there are multiple service providers but also I do agree that we probably need at least the possibility of a discovery provider who is not one of the service providers and I think it would be naive to assume that we have um like only large players who can run a discovery service provider and uh you know that that the total size of our system is going to be limited to tens or even hundreds of of uh"
  },
  {
    "startTime": "01:40:02",
    "text": "providers I think we should design it to be arbitrarily large y because you never know how it's going to be used in the future and you're limiting it otherwise yeah if we're on the same page about like there being more than one provider and that the messaging provider might be the app provider they might not be the app provider like if no one here thinks that cardinality of one is a solution I'm happy to never talk about gdpr again I think it's one reason why you can't have just one so but we have Richard who sheded his M nose so he's here to argue for one Discovery provider no no no that that was shaking my head agreeing with you there there is no worlding this is no this is yes is how you agree yes thank you Richard you ever tried shaking your head saying yes it's it's challenging the ambiguous head nod I don't know keep so so I in to go a little further on the point I I um I raised before um I I think you and I agree on cardinality and we agree on the shape of the trust problem so I agree there's going to be bazillions of these providers once you get Enterprises in on the game and I agree there's going to be Shady providers that you don't know how to trust and they're going to need some other trust anchor I think where we depart is how that reflects in the distri the system for Distributing the information um so I think I'm pretty much on the same page Watson is um and I wrote up a all scheme on this to the mailing list after the last inter room we're like if you separate the authentication from the distribution of the information you can distribute the information however you want um as long as you ultimately you verify the information you get back however you got it this this is actually how the web works right like you don't care how you got your DNS information you trust whatever resolver you walk up to on the street and then when you finally make an HTTP or quick connection I guess uh to"
  },
  {
    "startTime": "01:42:02",
    "text": "to the web server like you check its certificate and you verify that that you that some trusted party uh vetted their identity so like I don't think it's you the shape might be slightly different here but I think that overall principle that there are some authorities who vet the the mappings um you know some of those authorities are probably going to be the big providers who are trusted to vet their own mappings and some of them will be third parties who um who do the vetting on top of the you know on behalf of the Shady providers um but I think we can we can put that to an identity problem and not necessarily an information distribution problem okay I'm not sure how that doesn't agree with my proposal so may maybe maybe that that's a good time to get into what I'm catching on in this slide is uh mapping resolvers because what you care about the things that need to be um well it separates your information flows from your trust boundaries right because you can store information wherever you know if you're if your if your database needs to be you know EU local um sure great but um but you could still have some you know know kazak Authority who's vetted your stuff um or some some you know some us some global scale Authority um so yeah I think it's it's that the idea that we need I think it's that's where I was thinking is this this I what what I'm questioning is like the need for um people involved in the distribution chain who are not uh the Prov provider them the application providers right so like if I'm trying to talk to someone who claims to be from Shady Enterprise um you know assuming we have"
  },
  {
    "startTime": "01:44:00",
    "text": "some P nonsense to to protect my what I'm asking for like I can get identity from Shady Enterprise as you know if it's if it's vetted by someone else but I can physically get it from them if it comes with proof yeah yeah right so it's really that provider thing and the mechanics of the inst information distrib they don't need to be tied to this this trusty question perhaps but then it becomes a scale problem right so again my the Assumption here is that there's if there's just a dozen Discovery providers like hardcoding them to know where to go to find this is you know is is not a problem when when I have to know about every messaging provider and you know Fork my query to all of them to get to find out what they think and then again validate the mapping that they return like that just seems harder so since you already have have a a central for a bunch of pro messaging providers they'll rely on a discovery provider that's different this is all the smaller and partially trusted guys why not have them distribute the data that they're authoritative for what's the benefit of juicing complexity to have that distribute it that Discovery providers sign the mapping give it back to the messaging provider and then have the messaging providers have this massive fan out between them like just it was solving that more nuts and bolts problem that's that's why right all right why don't we jump back to the slides um just again I think it's useful at least for folks to understand what I'm proposing if you don't agree with it um next slide all right so I think we've sort of beaten this the foundational model is there's multiple Discovery providers there's lots of app providers there's tons of users nothing in this system ever has the users talk to the Discovery providers users talk to app providers um only in this model next slide I think we're this is the one thing I actually do think we agree on so next"
  },
  {
    "startTime": "01:46:00",
    "text": "slide um so uh the just to explain the the simple version when it turns out um that my app provider talks to a GL Pro um Discovery provider GL glass provider so here's like the basic protocol the simple version of the protocol there's sort of a few different pieces to it is a simple query response it's like really dumb it's not complicated consumer says Hey I want to talk to this guy with this phone number sends their app provider their app provider has the right of first refusal it has the right to say okay no no this is this is already a Facebook Messenger user or Whatsapp user I think that's an important requirement we can't remove from the app provider their ability to manage messaging between their own users so this is another reason why I I tend to think any solution that has the consumers talking directly to other providers is a complete nonstarter um but in this but the app so the app provider gets to say okay great oh they want to talk to this number I don't know what this is not one of my users all right let me check so app provider a here which say WhatsApp and step three goes to their glass provider and says hey what's you know what do I do with this phone number and it turns out that that phone number happens to be in this case uh C own cached or known by the gladus provider perhaps because that gladus provider supports another app provider that has that number and it just turns and mapping so the GLaDOS protocol is worried about the on thewire between the app provider and the GLaDOS provider eer so I'm gonna stipulate for the moment that the um that the that the app provider should get to control um uh in the priority of answers um though I'm not sure I believe that but why does it have to be reified on the wire like this why does it have to what be reified on the wire like this so let me give you"
  },
  {
    "startTime": "01:48:00",
    "text": "a let me let me let me give you a uh so so imagine so so imagine the sort of the naive fan out version which the client talks to every single app provider and says do you know about this and imagine that secured with PS you don't have to worry about blah blah blah um um and then the and then the client picks the top result so s which the client controlled by the app provider those this the same thing as that has the same has the same priority list you describe here um why why you why do you assume it has to be reified in the protocol really rather than be a client policy um I guess I think there's a trust question and it's wrapped up in the same discussion we've had over and over meaning like will will iMessage be willing to service queries from a applic you know from from WhatsApp from a user it can't even authenticate like these are have to be all unauthenticated queries and I just think that's unlik that's that may be true but that's a different statement from the one you made earlier which was about right second okay I'll get to the second the second reason is the like like the sort of what I almost call like the fundamental theorem of Mimi the fundamental theorem of Mimi is we're designing a weird protocol where the people who were to implement this protocol don't really want to implement this protocol and the only reason really doing it is because the EU is making them do it uh so in that model you want to maximize the acceptability of the protocol and to me like a like I'm making an assumption that we're not going to change the way the system works for these providers today like you do exactly what you're doing don't the only thing that changes is the flow for when they want to talk to someone outside that's the only thing we're asking you to change and we're not even asking you to change like you know introduce new trust Rel like this to me it's about minimizing disruptiveness of architectural change to those providers that that's more the reason I'm I'm"
  },
  {
    "startTime": "01:50:00",
    "text": "suggesting that okay that so so I think that I'm more persuaded by um I just think that want want policy enforcement they control the software do anything they want right fair enough yeah yeah yeah they could you're right they could yeah okay um okay thanks all right let's keep trucking there now get to the interesting stuff next slide so all right here's going to be so B there's three pieces to this protocol piece number one was the one we just looked at which is a simple query client server query protocol that's like so boring whatever um the second part is more interesting so and I think uh someone had asked this question like I forget who was or maybe it was it was GES was like Hey like how do you solve this problem where you have untrusted application providers but then you somehow magically trust the discovery provider this is the proposal so again let's let's look at a use case here okay so let's say the user is using Whatsapp the application provider is the WhatsApp backend so user is a mobile device AP is the application provider whatsapp's backend and there's a global provider the dis the gladus provider GP let's assume the use case of a new user signs up for WhatsApp so they download the app from the app store they access the app and there's a normal onboarding flow that every one of these applications today provides which you know asks the user to enter their email or phone number the user goes in the mobile phone types in their phone number so that's the SII that basically gets sent from the user's mobile device to the AP today the application provider would go and verify that number by asking toio to send an SMS or whomever your preferred SMS provider is it would include a code the user would you know we entered the code back and what have you so what this proposal is suggesting is let's in Essence introduce that a new entity the GP to sort of do that where the application provider would say to the the GP hey U you know create a new"
  },
  {
    "startTime": "01:52:00",
    "text": "they'll create a new user ID and that creates it locally and then it'll over the wire now the AP talks to the GP and says hey create a mapping between this user ID that that's a think of it as a random number and the SSI which is the which is the phone number right um the GP has got to trust that this is valid that's the hard part and and it does it by having the GP perform that mile number fication it actually sends the SMS with the code the code is entered by the user into their mobile app the AP passes the validation code back to the GP the GP Compares them and it says okay this makes sense I've now gotten verification that this user ID is in fact associated with this phone number and then it stores the mapping and considers it registered and it's sort of really similar to how it's done today between many of these APS who who depend on the likes of twio and nexmo and others to do this mobile number verification but now the GP stores the mapping and it it's and if you trust the GP to do this properly the mapping can be trusted even if the AP is not so again if the if the AP was a malicious provider claiming let's go back to my the use case that was all bent out of shape about let's say the AP was like I'm aad guy.com and they you know managed to have Tim Cook's Mobile phone number you know they would initiate this flow create a unique ID ask the GP to create a mapping the GP would send a text to Tim Cook's phone I don't know you know I don't know what this is and it gets ignored mapping mapping deleted now I'm sure you know we can debate about the trustworthiness of mobile number verification to uh trust these uh you know user identity verifications it's widely used on the internet this doesn't change that either Believe it or you don't but it it puts it in the hands of the GP to trust the mapping and it does to the degree you believe in mobile number verification it does prevent the attack that I have been all wound up"
  },
  {
    "startTime": "01:54:00",
    "text": "about um I'm going to pause there and see if there's questions on this one I'm sure there are oh Watson so it seems that this mapping that's being verified it's just the mapping of the SII to provide there's no place where you're adding in the the users's public key to bootstrap that they relationship yes yes that's right this this this design makes an assumption that there's a separation in the protocol layer between the discovery process and the sort of identity uh soort of the public key distribution process now you might you can imagine in this case the GP the um uh you know the either the AP or the GP could actually provide the public key but you're right in this design Watson it it considers the keying public key distribution and distribution as a separate problem this is strictly trying to solve the discovery problem right but then you need to go have the user do a separate validation that their phone number can be connected to the public key if you separate them out yeah that doesn't seem very fair feedback like like I mean you might argue hey you say hey Jonathan you dum dum like you missed the obvious thing why don't you have the GP issue a certificate while you're at it it probably good feedback actually it's a good idea I mean that yeah so I Fe I'm just like echoing Richard Barnes here but I feel like you're really like conflating two things one is authenticating the the ownership of the number and then this discovery thing and like like we already have like a work example of this which is like you"
  },
  {
    "startTime": "01:56:00",
    "text": "issue a credential and like I don't really understand why we're gluing this together and like and and um and I think like not like I'm just like not really following why why why these two two cont together and two things being what EA yeah validating that the that the the given entity has the right to identifier um and then disseminating that information um and um as chares points out like really what you want to do is validate that the that the identifier map to the person not to the provider and and this complains those as well [Music] um yeah so what what you're doing with the validation process there is mapping the identifier to the person which I call a a meat bag and but the problem that we're trying to solve is mapping the identifier to a server a service provider right which which does in this sorry this does that well not really this allows the GP to know definitively that the SII is associated with ap this app provider that's what this flow does I'm not sure I'm following that because when I when I respond with the validation code I'm proving that a i the the Giles owns the phone number I'm not proving that I have an account with ap X or maybe maybe I'm Miss Missing well because because you you got Gil the user entered the code and in such a way that it was obtained by AP which means you were using their"
  },
  {
    "startTime": "01:58:02",
    "text": "application how if if you were using a if you never were a user of AP AP would be unable to obtain the validation code in this flow the AP does not get the validation code from the GP the only way AP can learn the validation code the the short you know the six-digit code sent in the SMS is if the user provided it to the AP if if I may let me try to motivate I think this actually a bad design not just a a necessary design which is that um that the the GP in this case is going to actually allow some providers to just assert identities for streamline to what just simply assert identities when WhatsApp shows up and they say we own this number the GP should just that I agree um and when um and as you say when like Jonathan rosenberg's like you know thing shows up they should not just accept that right and yeah um and uh but like but if if we if we start from that premise then like it's much more natural to to separate out the the the to have all these people is have have the thing that causes the GP to accept your assertion is certificate and um and then the GP has some set of CA at trusts and the um and so WhatsApp is one of those Cas and Jonathan Rosenberg is not so you have to go make a deal with some CA to sign your sign your thing but none of this gets glued into the gpce mechanics which just takes a thing takes a signed object um and so this reduces it to a previously unsolved problem which is like how do you know them how do I verify the ownership of a phone number how do you generate a certificate a phone number that's like we've proven this problem UNS solvable over and over again no but but the ca does the ca does exactly the validation you're discussing but what I'm saying is why are you making the GP a like you just made the GP a CA for no reason and"
  },
  {
    "startTime": "02:00:00",
    "text": "it's actually and and the mechanics of running a CA are actually very different from the mechanics of running a global Ry service and so why would you want to sit this together okay especially especially given especially given that like that that like right now all all the providers actually arec is anyway and we can we live that way for a while right um I I think we're we're agreeing that we need that functionality and I understand what your proposing now think it makes sense but I think we're just saying separate out GP and CA functionality yeah I I yeah I think I understand I do understand your comment on that echer that you and you are correct this could be alternatively solved by having gpca produce a certificate and then through some other means we are basically Distributing these certificates so um and I combine them just for redu reduction of complexity of players but I think it's it's you know it is a valid design to have them separated I don't dispute that I think L is going to tell me we're out of time yeah get the most exciting part of this the bloom filter routing protocol it seems like we could spend an infinite amount of time taking my Discovery um and we will have more time in Prague so that's good but um I do think we made progress on the requirements though today like I feel like we made some incremental uh uh moves there in terms of getting agreement on the cardinality and the um the social graph privacy so that's good um we have another interim next week where we're going to I think be going back to the design team on on the other track um but then the draft deadline is only a couple days after that it's in basically two weeks from now so it would be really great to get update to these drafts kind of reflecting the discussion thus far and providing the clarifications discussed and also like maybe starting to think about um whether we're actually all kind of talking about"
  },
  {
    "startTime": "02:02:01",
    "text": "the same solution with slightly different properties or if these actually are like completely different um you know protocol entities and and interactions I feel like there's a little bit of convergence going on so if folks can think about um how you update your drafts that way and um please use the list for individual issue discussion as well all right we're gonna call it thanks everybody"
  }
]
