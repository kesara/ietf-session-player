[
  {
    "startTime": "00:01:08",
    "text": "that\u0027s how this would be here [Music] [Music] does anybody have a projection adapter which takes HDMI from the cable and give some VGA HDMI to VGA "
  },
  {
    "startTime": "00:06:17",
    "text": "about this guy\u0027s I don\u0027t have that HDMI [Music] [Music] "
  },
  {
    "startTime": "00:09:39",
    "text": "yeah okay everybody I\u0027m sorry for the delay here a some technical difficulties here and so this is a that a Roth here that the work group and next slide yeah this is the note well a if you\u0027re not familiar with that get familiar with it please the quest oh we have can we get a jabber scribe and a minute taker he volunteers he\u0027s presenting yeah can\u0027t you do that at the same time "
  },
  {
    "startTime": "00:13:18",
    "text": "okay so status update the first one is that device flow so this say was they updated just recently so the plan is to run it one more time with the workgroup last call and then they hopefully will ship it a so that\u0027s the plan for this one yes right oh yes okay yeah we will discuss that too right the discovery a draft say Mike we\u0027ll talk about that in a second to em and that chart chart request here so do you know what the status on this one is under it so as to authorize authorization framework jwd secured authorization request called char this is Stephen hosed me the status is so this this actually got through is she before I was ad and I and I have to figure out why like it\u0027s still stalled um I think what so my understanding what happened is that um is that there are a bunch of comments and they got cleared by B um and they and they got cleared by fake clear by fixing the doctor document and then I finally women look to the document to see like how the changes were they were substantial and they were substantial and so I talked to NAT sorry talking to John this morning and he said that there\u0027s a well we were in a third working group so as long as you agree they even went to the working group then I\u0027ll just review them for craziness and assuming that they\u0027re not crazy all advance the document so is there any second I chair do you as chairs do you guys represent that the changes between like you know the thing that was approved in the current document or the working group well I need to double check because I I don\u0027t know from the top of my head okay no problem so I\u0027ll assume it is and I\u0027ll check with you later and I\u0027ll just review the changes myself for like is there anything like insane in there and as I\u0027m not reviewing the entire document it\u0027s like obviously not as she approved it yeah we can we can check it right after this meeting because that\u0027s great thank you yeah well then we should move forward the other 114 days probably a still like within the margin is that 34 days I\u0027ll get that\u0027s it yeah okay so the rest of them a will be presented today with the exception of that token exchange so that token exchange is a we\u0027re currently in a working on the write up for that so a hopefully we\u0027ll ship it a very soon to to occur for one more document to review so that\u0027s that\u0027s a that\u0027s the update so "
  },
  {
    "startTime": "00:16:23",
    "text": "next for next year we have already prepared another our security workshop here you see the sign up page monitors on our next slide this is as you recall we have done the previous workshop specifically to reach out to some of the researchers who investigate sort of implementation and sort of formal method analysis they can to apply them to our protocol so I think this is really useful effort but I also encourage folks in this community to participate and to share on what they are doing now so that research has actually become a way of what items they should be looking at and what status the documents have so it least in the past workshops I thought them extremely useful to find out some or to get a pry a broad overview on what these different techniques are that people apply to analyze protocols things which is why we try to organize another one the date has been chosen as the week before the next IETF meeting in in the next IDF meetings in London this one this workshop is in Trento in Italy supposedly a nice place here you can also find the link in the scope is like with the other workshops so we are trying to see or receive position papers related to OS of MIDI connect and OS related topics such as for example the IOT stuff that uses OS and so on so anything in that category would be great and implementation if experience is is welcome but also if you did some analysis or had gained some other security-related expertise please submit a position paper we will remind you to provide something also at the beginning of next year okay so here\u0027s our agenda for today a bit late but I think we went through that chairs update and Brian so for is yours oh wait you go alright mutual TLS profile for a lot - a lot - what we do here so we\u0027re gonna talk about the mutual TLS profile for get "
  },
  {
    "startTime": "00:19:25",
    "text": "into it next slide you know I\u0027ll hear me alright is that better okay so sorry there\u0027s better alright so what is it what is the mutual TLS profile for auth - it\u0027s sort of two main things one is defining a mutual TLS client authentication mode - the authorization server and there\u0027s two distinct methods or modes of this one is a PKI based where you validate the trust chain and certificate presented by the client and check the the subject of the certificate and the other is what we\u0027re now calling a self-signed certificate based mode where basically you disable trust chain validation on the a s and just use the mutual TLS to establish proof of possession of the corresponding private key to the certificate and then you have the actual full certificate configured as a credential for the client and just compare those two after the fact and the other other part of the draft is defining a mutual TLS sender constrained access tokens for protected resource access which another way of saying that is just certificate bound access token so actually binding oo-oo thaks s tokens to certificates so they can\u0027t be used by anybody else next slide please why are we doing this a couple things one is that a mutual TLS client authentication which is obviously provides better security characteristics than the shared secret method we have in OAuth normally it\u0027s something that\u0027s been done by a number of different implementations in practice but we\u0027ve never for years now we\u0027ve never written it down as an actual standard and there\u0027s been some pressure from some other communities to to have it written down so they can references it as an actual standard in a common interoperable way of doing it mutual TLS sender constrained resource access binds access tokens to the client certificate this is so they can\u0027t be played or replay by any other entity without the corresponding proof of possession of the private key there are banks now that that need these four server-to-server type api cases mostly being driven out by new regulations around open banking and and so forth this spec is in its draft form is currently referenced by fappy the open ID foundation financial api working group in their readwrite security profile as one suitable holder a key mechanism necessary for financial level transactions with OAuth and it\u0027s also referenced in the I left out the UK part here but the UK open banking API security profile which is largely derivative of fappy but a little bit different but the idea being that there are their banking use cases that want to deploy this in the near future and need a better than bear type solution for access tokens as well as client authentication and this the standard provides that building on top of mutual TLS which is you know widely available and functional in a while today next "
  },
  {
    "startTime": "00:22:28",
    "text": "please so the first part how mutual to us client authentication works basically the TLS connection from the client the token endpoint or any other direct connection to the authorization server is established with mutuality less authentication in the request the client includes the con ID it should be request parameter as it would in normally but it\u0027s required in this profile and the S uses that to lookup the client lookup the client configuration and verify that the client certificate presented is the right one for the corresponding client there\u0027s some metadata provided in support of the PKI method which there\u0027s a new authentication method name so we have the token endpoint authentication methods as you can list for a server support and client authentication methods we\u0027re defining a new one here TLS client off to refer to the PKI method and then there\u0027s a new client metadata parameter that specifies the expected subject to sting which name of the client certificate this is how when presenting this mutual TLS over this method the client presents the certificate the TLS layer verifies the search chain and then looks for the expected subject II end in the cert would now be a good time life sorry so a quick question so when we\u0027ve deployed on similar methods in in eduroam right one of the things that you actually run into if you do PK I base this you have sort of just just looking at the subject the end may not been sufficient for doing good access control you might actually want to have a combination of subject and issuer because you may want to do constraints based on you know you don\u0027t want sort of somebody else to stamp on you stomp on your name right and if you know public PKI is gonna allow that if you just do subject yeah so I would suggest that you think a little bit about what you actually want to achieve now this may be enough for the people who want to implement stuff like this so it probably should be optional or something but if I were to deploy something like this I would definitely want something more constrained in my PKI method than just subject distinguish so the I mean in the deployment you\u0027re always free to constrain the set of you know access routes trust routes that you have which is one option in a any previous version of this draft we also had a parameter that allowed you to constrain down based on an issuer DN so a constrained issuer for the client there was some feedback from implementers that getting sufficient access to that to actually deploy it was difficult and my following "
  },
  {
    "startTime": "00:25:28",
    "text": "up from the implement or feedback the reason I\u0027d originally introduced it is we had a similar type piece of functionality as a product feature in our server and while it I agree with you that it\u0027s a potentially common and desirable additional constraint to put around it the idea at least the thinking was that it wasn\u0027t necessarily appropriate to be something that the client asserted about itself in client registration metadata but more something that the server could implement additional constraints as it sees necessary but not something that that should live in the standard itself so possibly I\u0027m at least I would suggest that getting some sort of security considerations text in there it says here\u0027s some of the stuff that you can get wrong when you do certificate validation and don\u0027t assume that you know your subject use that your subject name is you know unique or can be only be issued by a single issuer in your trust okay so yeah in in that that is what is in the current draft we can look at some additional considerations there\u0027s already some considerations there but not particularly around that so it\u0027s worth mentioning and then there\u0027s some some metadata provided in support of the other method the other mode which is the self signed certificate mode there\u0027s an authentication method name for this as well and then it doesn\u0027t define anything new but references back to the jws uri or JW KS client registration parameters from RFC 75 91 that already exists these are ways to specify a set of public keys for individual client and so the self signed certificate mode just makes use of these existing client registration possibilities to specify public keys and just references those next please the other side of it how the actual sender constrain access works is on issuance of an access token the authorization server associated a hash of the certificate with the access token itself basically binding the access token to that certificate on TLS connections from the client to the resource server mutual TLS is needed there and then the protected resource matches the certificate it received from the client against the hash of the certificate in the access token and those need to match otherwise it\u0027s a it\u0027s an error that\u0027s the the binding between the two in order to facilitate communicating that information we added a new JWT confirmation method which is the x.509 "
  },
  {
    "startTime": "00:28:28",
    "text": "certificate 256 thumbprint confirmation method so this is a new confirmation method on RFC 7800 which is just the the shot 2p6 hash of the certificate included in the CNF clam and then parallel of that there\u0027s a new confirmation method for token introspection which is exactly the same data as the JWT confirmation method but it\u0027s returned in the introspection response and checked by the protected resource in the same way so either way it\u0027s the job of the protected to get the certificate presented by the client and compared to the hash of the certificate in the access token maybe one important detail about this is by using the hash of the access token the the actual binding of the I\u0027m sorry by using the house or the certificate in the access token the actual binding of this certificate of the actor to the token doesn\u0027t vary based on the client authentication method so that regardless of the mode that was used on the authorization server the presentation and validation method is the same at the resource server and then there\u0027s just examples down here at the bottom of the JW confirmation method it took an introspection unsurprisingly they look very similar except for a little bit of the ceremony around one versus the other yeah Justin Justin richer so uh just just to be clear here the certificate that\u0027s being hashed is the one that\u0027s presented to the token endpoint right yes so this is unable to be used with anything that doesn\u0027t call the token end point specifically implicit flow or derivatives thereof that\u0027s correct okay so implicit clients are just can\u0027t use certificate bound tokens is that al is that it that is a current limitation yes is that something that we\u0027re planning to try to patch or do we want implicit to die or what we don\u0027t think implicit makes sense for this use case because that would be a client certificate in the end users browser right which isn\u0027t John Bradley so the the experience of mutual TLS for users in the browser is known to be suboptimal to put it highly optimistically encouraging people to get users to provision soft certificates into their browsers to be able to do this would be a nightmare we believe that token binding and the fetch extensions in the browser are going to provide a much more manageable way for doing proof of possession and tokens through implicit flow so it needs to be addressed but not using certificates because we beated our heads against this problem for a decade which "
  },
  {
    "startTime": "00:31:30",
    "text": "it\u0027s not gonna happen thank you that is a perfectly reasonable approach I would just like to ensure this draft very clearly cuts that out as this part is not our problem I it\u0027s implied now I think adding some explicit wording to that end would be useful so just a little just a quick question I got the previous like is it hash fingerprint of this subject is the whole whole thing the whole thing as they\u0027re encoded yes calm leave one question um there is a coming back to your question regarding the scoping the the DTN of the sort or the certificate of an issue oh we\u0027ve got some text within the security considerations about x.509 certificate spoofing have you taken a look under that yeah it\u0027s just a question yeah because I think that that\u0027s that\u0027s somehow the text you are looking for so yeah okay I mean yeah I forgotten that\u0027s in there it may not be everything you want but it\u0027s a start so if you have some take a look and let us know if if there could be better or more thanks for reminding me Torsten all right so just a little bit of history on the document I presented draft two in Prague and I maybe had a little bit premature call for a working group house call at that point but it led to some excellent discussion and some I think really worthwhile changes at the draft since then so there\u0027s been three drafts published since then and we made a few changes which all summarized here went from kind of leaving the trust model completely wide open and saying you just have to do something two defining clearly defining these two methods of client authentication the PKI method in the self-signed certificate method it\u0027s kind of one of the other and I think it\u0027s a nice improvement to nail down what they are I wanted to leave it open to allow for either but really these are the only two kind of reasonable possibilities so it\u0027s it\u0027s much tighter now there was introduction of a s metadata and client registration parameters which can be used to both request support for mutual TLS sender constraint access tokens and publish your support thereof let\u0027s see clarified that that this the client authentication is an exclusive to the token endpoint and it can be used for other endpoints such as that require client authentication such as revocation and introspection endpoints some of that I think was just legacy a little copy-paste that in the original world of OAuth the only place the client could directly authenticates who was the token endpoint so a lot of the wording sort of carried over for that but since that time we\u0027ve had introspection defined we\u0027ve had revocation defined and so it makes sense just broaden its really just wording but that was always the always "
  },
  {
    "startTime": "00:34:31",
    "text": "the intent it just didn\u0027t read that way we did remove the client TLS auth route dn client metadata field this was the one that was at one point intended to allow for the constraint of the issuer on a particular client but like I said it it sort of fell in the wrong place allowing the client itself to specify this didn\u0027t make necessarily make sense and it introduced a lot of support requirements that might have been difficult for certain implementations to to accommodate so it didn\u0027t didn\u0027t feel entirely appropriate it doesn\u0027t mean that a particular a s implementation couldn\u0027t do something like this to to further constrain their trust but it didn\u0027t make sense in the in the context of standardized client metadata and then based on some feedback the about just reading through the doc reorganized it to try to more clearly distinguish between the different moving parts specifically distinguish between the client authentication method and certificate bound access tokens they\u0027re very similar but they\u0027re they\u0027re distinct in the document so split them out better and then more clearly delineate between the two client authentication methods the changes since Prague and there have been so I actually built I didn\u0027t build I paid someone to build a bike shed in my yard over the summer and contrary to everything you hear in the ITF the the picking of the colors was pretty easy I chose some colors I showed them to my wife she told me they were wrong and told me what colors to choose and that\u0027s what we went with its really pretty straightforward but the only commentary that there\u0027s been some commentary on the latest draft one implementer said it looks good another one came back and I had a bunch of editorial stuff but the only sort of substantive comment was around the name of the client and server metadata parameter used to indicate support for bound access tokens that is it was described as unnatural the current name is mutual TLS sender constraint access tokens he proposed certificate bound access tokens as being a little bit more natural that sounds nice but you could also go with mutual TLS certificate constrained access tokens Mitchell TLS certificate bound access tokens M TLS certificate bound access tokens M TLS bound access tokens TLS client bound access tokens etc etc etc there\u0027s a lot of potential options here I\u0027m not sure that one is demonstratively demonstrably better than the other and opinions are like you know fill in the well-known saying if you like but it was raised I\u0027d really like to get to some I don\u0027t know I guess if there\u0027s there\u0027s really strong opinions please bring them to the list and maybe we can drive to skin some consensus but this stuff is meant to be machine readable humans will look at it and I\u0027d "
  },
  {
    "startTime": "00:37:31",
    "text": "sort of like to just leave it as is even if it\u0027s not ideal this is Justin and that is a very handsome medium gray thank you I\u0027ll tell my what tell your wife but no I actually did want to expand the scope of the bike shed discussion to the client authentication parameters yes just because they both have client off in them and that bothers me because none of the other client odd methods have client auth in the name and so yeah that that\u0027s like saying that\u0027s bike shed gray instead of gray so anyway if if that is if that type of discussion is on the table I\u0027d like to I\u0027d like to visit that it\u0027s a syntactic change its arbitrary I\u0027m totally with you on that point but if we can chop those I would be happier so I will I will say that because of the referencing in by some like open banking using this right they are already making use of at least one of those modes in their documents so changing it now would have ripple effects that I think for the sake of just changing the name like that I would prefer to avoid that\u0027s that\u0027s a fair consideration to have so okay and they\u0027re like they\u0027re supposed to go live in January which is which has its own issues but but for the sake of just changing a name based on aesthetics I I\u0027d prefer to avoid it so yeah so I\u0027m I\u0027m leaving at this if you have super strong opinions please raise them otherwise I think I think leaving it is just probably the the best course of action right now and so next steps will be in London early next year London right there and so I guess I\u0027m tentatively saying perhaps we\u0027re really ready for working group last call this time and so you don\u0027t have to hear me do the same spiel again thank you Brian Brian a question so how do you see this document being different from the dough combining document the words and the title and the document identifier to be a if I can be really frank I\u0027ve referred to this document at times as sort of like a poor man\u0027s token binding it provides many of the same benefits at least with respect to binding the access token that you would get from token bonding but in a way that is deployable now because the mutual TLS functionality that it relies on exists and can be deployed I have I have working prototypes all this either in product or extensions and product in the "
  },
  {
    "startTime": "00:40:31",
    "text": "lab I would have a microphone if it on uh I could write no gag um I wanted to add because I would have phrased it differently and I think we should clarify that in the document to explain the relationship ah I would have actually said the token binding is about this the raw use of raw public keys and this document is the use of certificates however unfortunately as this slide shows you have also a self signed certificate mode India which makes it awfully similar to to the DOE compiling and so like where did that came from like did the banking guys ask for a self signed certificate what did days mostly ask for client certificates what I\u0027ve seen them doing they\u0027re looking for more traditional client certificates in a in a PKI type mode and they have to the best of my knowledge their own sort of PKI for their deployment of it the the self sign mode sort of opportunistic in that we didn\u0027t want to force a single trust model on there and that it\u0027s it\u0027s useful it provides the ability to do some of this binding that is innocent similar to tow combining but using existing deployable technologies you don\u0027t need to justify just a question of like clarifying in the document to explain the reader since we have different documents on what does this compare to others and so on John so the this document also deals with client authentication which doesn\u0027t really apply to token binding because it\u0027s truck sort of trust on first use so yeah so there is a component of this that you can\u0027t do with token binding because it\u0027s using the mutual TLS certificates the the other thing is that this introduces a level of certificate and key management that really isn\u0027t scalable to mobile devices and and uh and web browsers etc this is really more you know if you have a server to server sort of environment this you can do now but it isn\u0027t scalable to every device on the planet without having another you know key management overlay so this is sort of for certain use cases this is not a bad compromise but for the broader broader use cases token binding is going to work better token binding also has other privacy protections that are known to not exist with mutual TLS and that\u0027s one of the reasons why we did token binding that if you the server has a "
  },
  {
    "startTime": "00:43:32",
    "text": "certificate it\u0027s gonna present the same certificate everywhere so these are you know generally targeted towards server to server implementations the privacy of the server it\u0027s known it\u0027s got a client ID it\u0027s not really a secret so correlation isn\u0027t an issue once you start getting down to user devices then correlation becomes more of a privacy issue this is Dawson um we come back to to the first slide where you said what this is all about and why we do that you stated that this is going to replace shared secret for authentication and I think that\u0027s the main the main reason why we have to sell certificates in there right it\u0027s a very very reasonable way to replace shared secret for authenticating clients and you don\u0027t need a PKI for that it\u0027s a it\u0027s a lightweight wave right introducing public private communication that\u0027s that\u0027s the main reason why we included the cell science stuff because everyone is got is going is getting afraid if we if we mention certificate based authentication because everyone has in it had the P key I typically required with that but that\u0027s not needed for client authentication right because you have a pre-established trust relationship between the the provider of the client and the authorization server so that\u0027s the main reason there is no tight bind binding between the subsets and and the undertow combining so it had a question first on is i in this also a certificate version of this does the server become aware of the client certificate out-of-band or does it become aware of it on first used like into the monday out-of-band either through dynamic registration or manual registration of client so i guess as ad i\u0027d like to request that you do make clear on somewhere in between these two documents where the applicability situation for each of these is so that when you know people read them at the isg and also when people consume those RFC\u0027s they can understand when they see one technology first the other that\u0027d be very helpful okay their card amazon you know as much as i like mutual TLS client authentication i just want to point out that in the major cloud provider vendors their load balancers that do TLS termination none of them support mutual TLS client off for passing it down so anybody deploying this would have to you know run their own load balancer and stuff it\u0027s going to be a barrier for people to deploy it in scale for a bank or something like that they\u0027re probably not gonna be sitting behind it but you\u0027re gonna get that changed amazon Justin to follow up on dicks comment one of the things a bit of perspective to "
  },
  {
    "startTime": "00:46:33",
    "text": "keep in mind for this work is that in a lot of spaces the financial industry in in particular they\u0027re already doing mutual TLS and then nothing else on top of that so from their perspective it\u0027s how do we add ooofff to mutual TLS and not how do we add mutual TLS to OAuth so where today\u0027s systems are you present the right certificate and therefore you can do whatever you want because you got a certificate you\u0027re in the door we don\u0027t care adding ooofff to that allows them to have constrained in time limited tokens and you know scopes and all of this other kind of stuff that oweth just kind of brings to the party while still having the the strong sender constraints that a mutual TLS gives you so while you\u0027re absolutely right it really doesn\u0027t make sense in a lot of cases where you have you know large scale load balancers and stuff like that I don\u0027t think that\u0027s me crackling yeah it does make sense in cases where you\u0027re already doing em TLS and you want to add other stuff to it more OAuth II stuff so I think that\u0027s the perspective that people need to keep in mind for this which is again as John was saying a different perspective from the people who would be looking at token binding as a solution by and large I got a I guess stupid question about the subject deals again I looked at the text it\u0027s sort of okay actually but if you\u0027re doing I mean it\u0027s better than nothing I mean but if you let\u0027s say you\u0027re doing what John sorry for Justin describes the banks are doing aren\u0027t you doing I have an STS somewhere in your architecture and issuing those certificates so dynamically and wouldn\u0027t subject the M be changing all the time do you really want that in metadata is that what they\u0027re really doing don\u0027t think so yes I cut the line afterlife is because we need to move on all right we can just curiosity on my part we can talk about it later sorry we cut the line already because otherwise we cannot run completely out of time but please post your comment to the list nevertheless I think you got very good feedback I see a little bit of clarification also that comments Justin raised life will double check the document who is going to review the document and Rick give us a few names just in will come on summarize in in we work with it with document all certain incorporating these clarifications and then we are going to issue a working class call unless there\u0027s some major issues that problem so expect the "
  },
  {
    "startTime": "00:49:35",
    "text": "working class call it I would say beginning of December okay all right all right so the related but different topic so off to toe combining usual intro slide so get to the next one just studying a little bit of context here we adopted this document shortly after Berlin which is shown here and really the the idea is providing an oauth2 based proof of possession mechanism based on token binding work that\u0027s happening in another working group here that can defeat replay of lost or stolen tokens really all the tokens primarily access tokens but also Refresh tokens authorization codes and and some of the other tokens that are are used within the context of OAuth that turns out there\u0027s a lot of them next so just a real quick refresher for what we had in draft 4 which was prior to the most recent set of changes to combining of access tokens was defined using referred token bonding ID as well as a representation in jadibooti access tokens how to actually include that using similar to the last draft a confirmation method type which was a the hash of the token binding ID inside of a RFC 7800 confirmation method we also talked about token binding refresh tokens using the provided token binding ID very similar to what you do to buying cookies and then there were two modes to allow for token binding of authorization codes built on top of pixie one for native app clients and one for web server clients they\u0027re just different in the nature of how they interact so they\u0027re two different ways of doing that next dependency status included Dallas here because that was when the token binding working group got officially formed and you can see John up there and lathe sharing that first meeting the three main token binding working group documents negotiation the protocol and HTTP are all very close to RFC publication I did say something similar in Prague and oh yeah so I was gonna say things move so fast in the IETF that this status has changed since I submitted these slides of the chairs and today they have moved from submitted to IESA ESG publication to i ATF wide last call at least two of them and the third one I think is either out or close behind it so we are actually moving forward here current status of this document is draft 5 was published on October 26 with changes in editions that "
  },
  {
    "startTime": "00:52:36",
    "text": "were were discussed in Prague on the mailing list too but largely agreed upon in the presentation in Prague and you scroll up just a little bit or change the and just for those of you sort of following along at home the open ID connect token bound authentication draft o 2 which is very closely related to this and also itself defines the structure of the confirmation method to carry the token binding ID that was updated with similar similar changes what was in here which is mostly just around some description of the the phasing and and security characteristics next so that the actual changes in draft 5 we went and clearly specified that an authorization server should not token bind refresh tokens to a client that doesn\u0027t support bound refresh tokens and that support can be indicated by a client metadata parameter that was already defined or of course via static or just normal registration and configuration of a client and then added some security considerations on on what it means not to have bound refresh tokens mixed into that was a little bit of implementation detail but it\u0027s potentially infeasible for some clients that are implemented as distributed web based clients on different nodes to actually do token binding in in an in a reasonable way and noted that refresh tokens are already indirectly bound to the clients credentials so most refresh tokens are are in effect already bound to whatever the client is using for authentication of the token endpoint so both explain sort of why it might be difficult to buy and refresh tokens as well as why the the protections you would get are already in place adjusted the language a little bit around boarding authorizations in the phasing and to combining section to be just a little bit more general and not only about downgrades or some really specific discussion about detecting downgrade attacks when in when in case they might actually be just miss configurations or other potential issues the the suggested outcome is actually the same but the language is just a little more generalized and removed a reference and usage of to the the oauth2 protected resource metadata draft which was an individual draft that is is no longer active no longer going concern so we pulled that out of there a few more changes in draft 5 so added added or described how you would do token binding for a jot authorization grants and job client authentication brought this up the last one you know for some people it might be sort of self-evident how this would happen but I wanted to be explicit about it in the draft and really it boils down to the jot itself must contain the same confirmation claim with the token binding hash member and it should "
  },
  {
    "startTime": "00:55:37",
    "text": "identify the provided binding being used by the client on the connection to the authorization server to find a new client assertion type clearly delineating that this is not a bear client authentication assertion but a token bound one and then defined also new authentication method values scrolled for me just a bit so these are parallel to the the the two that exist now for JA client authentication but with token bound and I\u0027m the the private key variant for asymmetric versions and the client secret took a mountain JWT for the the one using the client secret and then also defined a new grant type to again explicitly say that this is a token bound jock for for authorization grant versus the the bearer version so that\u0027s it for that so next slide and looking ahead the London um the token binding documents are going to progress to RFC status and I think it\u0027s for real this time I think that\u0027ll happen before we\u0027re in London still looking to get implementation experience and feedback here I will go so far as to say I\u0027ve been working a little bit on the client side of doing some of this in the early stages and it\u0027s kind of a pain in the ass so I think it\u0027ll be good as things get standardized and and maybe API is in support develop hopefully that\u0027ll that\u0027ll get easier but my sense is this stuff is is still pretty early relative to what\u0027s available in terms of implementation so sometimes necessary here to get some feedback and then yeah get get us all back together and do this again in London for IETF 101 and with that I think thank you questions or comments question any reviewers mic might be good implementation experience to share the workshop good pictures there that\u0027s one yes it\u0027s hard to get away from the family for for that amount of time okay all right thank you good afternoon I\u0027m Mike Jones from Microsoft and I intend to give you a "
  },
  {
    "startTime": "00:58:37",
    "text": "very brief update on where we are with the authorization server metadata document next slide so our current draft is those seven that incorporated clarifications which Eric requested about some defaults and statements about when you must use TLS which we\u0027d forgotten to include so all good stuff we requested publication we got back the usual reviews from upstairs sector and Jen art two of the three said good to go another requested an RFC number update which is correct and then actually had a very interesting interaction with mark Nottingham in his role as designated expert for registering the well-known value and he pointed out a few ways in which the context that most of us who are familiar with the space already understood about when and why you would use this where it wasn\u0027t actually in the document and so that\u0027s you know you get fresh eyes on something and that\u0027s always good so there\u0027s a few things which I plan to add with the co-editors just clarifying the context of like when you use an issuer versus the well-known path and all good so within a couple of days I plan to get o it out that mainly includes the clarifications which mark usefully suggested and at that point I think we\u0027ll be ready for the telecheck assuming eric concurs yeah that seems fine um just FYI we\u0027re now looking pretty far out and they tell us how to agenda so I think it\u0027s probably gonna better than a half before it shows up but I\u0027m guessing about a month and a half okay that\u0027s fine but that\u0027s just yeah well we\u0027ll just stay on it okay thank you thank you I\u0027m the Shepherd and it looks like I have you did okay that\u0027s all my slides on this I just wanted you all to know that we are in process of pulling us through the dog beat it\u0027s on a village it yeah I believe everything\u0027s fine next presentation please yep so this is largely another "
  },
  {
    "startTime": "01:01:41",
    "text": "status update but this one has a call for action at the end as you know Kathleen and others requested that a best current practices document be written for the use of the JSON web token and several of us put together a first draft next slide please there we go your own Scheffer decart and i with some input from many of the rest of you wrote the first draft we updated the 0-0 individual draft a1 to include some things about how to better identify conflicts a decision was made in Prague to adopt this as a working group draft and we did so forthwith next slide however since ITF 99 four months ago there\u0027s been exactly zero discussion of the draft as far as I can tell despite the deck asking for reviewers and you know we\u0027re all busy doing other important things but if we care about this in the end we do have to give it some bandwidth I\u0027m not proposing an interpretation of what the silence means I\u0027m just pointing out there has been total silence for four months next what I won\u0027t do here is repeat my presentation from last time where we talked about what we\u0027re trying to achieve how we\u0027re trying to achieve it the structure of the document etc all of that\u0027s in the record from ITF 99 and if you\u0027d like to refresh yourselves on why and what and how that\u0027s already recorded next this is my last slide about the jot BCP this is the call for action I think to progress this we need some people to put eyes on it and put pen to paper about what they saw and I\u0027m hoping we can find victims or volunteers depending upon your nomenclature to do so and Bryan\u0027s at the microphone yeah Ryan Campbell with with ping I so I did there was there has been some stuff on the list including I asked about whether and if other ways of disambiguating was considered or useful which sort of I don\u0027t have a strong preference but it "
  },
  {
    "startTime": "01:04:41",
    "text": "there was at least a request to add was a more consideration or more clarify where in fact on if you had a nested jot where you would need to look for the type that was or the the type for disambiguation and so I don\u0027t think that\u0027s happened and I did I do remember that could you refresh that note to the list I may have been searching for the wrong things I will try to find it and look for it and then I it\u0027s it\u0027s not easily addressed but I had a question about whether and if the the document should cover use of compression in jots which sort of didn\u0027t end up anywhere but I guess it\u0027s not entirely fair to say there\u0027s been been no discussion on it there has been okay I was just time boxing it from July to here I think it\u0027s all been since then okay but then then I stand corrected but yeah they\u0027re more is probably useful I think I\u0027ll try to dig those up I think it\u0027s obvious to ask for reviewers I saw Phil\u0027s hand going up unless you\u0027re stretching which you actually do but someone else like maybe someone with I think it\u0027s a little heavier there are discussions in aspects of it of ways that you can get the crypto implementation wrong so you know if we could get I don\u0027t know a gym shot or a John Bradley or somebody as victims that would be fine but they obviously have to volunteer maybe we could ask doing decide meeting that\u0027s true in sag if you could go to the mic and ask for volunteers you know a rich salt sir there\u0027s a lot of people in that room that could do a good job yep I think John is volunteering you John looks hurt yeah thanks John and summarize like the JWT is a mechanism that is as usefulness beyond evil or so that would be good too to be yeah like that I try to throw it at Jeff Hodges but I have other things for him to do okay I would I would try it in a sack group but yeah thank you that\u0027s that\u0027s all I had to say okay thank you guys you had no slides right "
  },
  {
    "startTime": "01:08:07",
    "text": "yeah that\u0027s work okay so is William online I can\u0027t see the he\u0027s probably sleeping so we went over the device flow at the last meeting and got some feedback which we\u0027ve now incorporated into the draft so if we go through here looking at the changes it\u0027s not large sections so there was the big discussion at the last IETF was around including the code as part of the the verification URI so we split that out so there\u0027s now a verification URI complete that includes the the user code which is separate from the other components we\u0027ve added that in the examples added some explanation and some wonderful ASCII art that\u0027s Williams version of an ASCII art QR code which he was very proud of you know you do what you can so we added some stuff about polling intervals another section on session spying and that\u0027s pretty much it John yeah one question uh I saw net that you had some some comments and one of them was a question about the type of devices that we envision and I I wonder whether we or what all of your comments have been addressed you think so or you look at it okay that\u0027s pretty much it for that draft so the authors would like to so we\u0027ve already been through one last call if we can do with another short last call and catch anything remaining things that Knapp might have or or others yeah that that\u0027s the plan so if not you can take a look and yeah okay so I guess we could "
  },
  {
    "startTime": "01:11:14",
    "text": "probably issue working group class call already next week I would be perfectly fine with that we\u0027d be great if we knew that someone could also and reviewed that is someone a few who hasn\u0027t had a chance to look at the document yet who could take a quick look at it okay so that\u0027s it for that draft and just so that everybody knows the other draft that William and I were working on is now actually an RFC yay app off BCP as done which means that we now have to start the next version because the darn operating system vendors have updated things I guess that\u0027s that\u0027s life in the world of BCPs we have a new draft that we\u0027ve been working on started about a year and a half ago since then we\u0027ve added Carl McGinnis as one of the authors from octa so we have oh cool okay don\u0027t hold it upside down so one of the problems that we have with OAuth is that in general the authorization server has no freaking idea what application it\u0027s is actually making the is the client really the client that you that it claims to be so especially for native applications given that they don\u0027t actually have client secrets knowing that you\u0027re talking to the right application is a significant problem I I believe Google has seen instances of fake applications a lot of times people design API is badly and given that there is if you can get somebody to log in with a few log in with a fake client you can abuse the API to get at other people\u0027s information and stuff bad things like I think snapchat had it oopsie which was particularly bad for them and and others so we started looking at rather than EMM s which sort of take a top-down approach how do we start looking at managing applications from the bottom up so having applications pass attestation z\u0027 and statements about what what their operating environment is to the token endpoint to the authorization endpoint as as a hint and further from the authorization server to the identity "
  },
  {
    "startTime": "01:14:15",
    "text": "provider so that if you\u0027re talking to if you have an app that\u0027s going to a SAS provider you may have device posture information that gets presented to the SAS provider who then passes that along to wherever it\u0027s doing federated identity from so that the identity provider has some ability to say hmmm wait a minute that device doesn\u0027t have a screen lock or I don\u0027t like that particular application instance to talk to that third party API so try to move some of the decision-making closer to the people that are actually have a handle on it getting SAS providers to make those policy decisions well we have skin for pushing policy down to the SAS providers it\u0027s not an easy fit to make them responsible for for making all of those decisions so in this model the Kent\u0027s get passed up all the way to the identity provider but the actual confirmation of whether or not the application is the app it says it is and the other things that can be directly attested need to happen on the direct communication to the token endpoint so policy decisions are made and then enforced at the sass provider so that\u0027s essentially what we\u0027re up to in this this app so we\u0027re adding a couple of parameters and dictionaries for the JSON object so we have you know device vendor device os whether or not it has screen lock root privileges these are all things that the app already has access to so it\u0027s not new privileges for the app but things that if you configure if you can determine whether or not it\u0027s your app then the app itself can say whether or not there\u0027s a screen lock etc you don\u0027t necessarily need to rely on an EMM for that so the first step is are you the app I think you are and if you are my app and you\u0027re running in a non rooted environment then perhaps I can trust some of the other things that you say about yourself Tony has the look on his face like he had bad fish Shawn uh how do you so I maybe it\u0027s in a document somewhere but you\u0027re making a number of assumptions here so specifically with the diagram that you had shown below where you pass along these parameters who creates those parameters or this set of parameters and and how do you protect them from not getting modified by by the app that claims whatever it does how do you so they\u0027re passed on a direct "
  },
  {
    "startTime": "01:17:15",
    "text": "connection so the ultimate verification happens to the token endpoint so that\u0027s a direct TLS connection to the token endpoint from the application and for certain kinds of attestation types we want to use the token binding so that you so that you can\u0027t have it have the attestations replayed so that if you scroll down a little bit then we see sort of the attestation information and it it by this example doesn\u0027t show any sort of signature around it is that right so the attestation z\u0027 have signatures okay so you don\u0027t necessarily need to wrap the whole thing in a signature given that it\u0027s going over an authenticated direct TLS connection but that\u0027s um you know right now it\u0027s an Indian it\u0027s not a working group document so that\u0027s where we want to progress it to so that we can start getting other people\u0027s feedback so it\u0027s unclear that we need an extra level of signature around it given that the individual attestations are signed probably by the operating system and it\u0027s going over an authenticated connection so one of the tricks and one of the things that\u0027s been holding us up is token binding which is sort of the obvious thing that you can use as a nonce challenge to these various attestations produced by the operating system so that you know that the because the private key of the token binding is never disclosed outside of the device you know that only the device that contains the private key was able to generate that attestation do we have any any comments or questions probably more questions sure Wendy seltzer and just looking at the the document curious so that not to see any privacy considerations and the consideration might well be this is used in an enterprise context when users have no privacy expectations but yeah some of us yeah indicators might be things over which users might expect some privacy that\u0027s stuff that we should probably look at but all of this is information that the apps already have about themselves what we\u0027re doing is standardizing how that gets passed along we\u0027re not actually giving apps any more information these are all existing api\u0027s on the devices yes they were um as it relates to the these little signed bundles you said you know the attestation is signed by the but no outer signature how it\u0027s used is by the app by the application is signed by any "
  },
  {
    "startTime": "01:20:17",
    "text": "trusted Authority so what prevents one application from sort of stealing a little attestation out of memory from another one and using it itself if no I think there\u0027s nothing that over all signs that says yes this I don\u0027t know I was just trying to that was where I was going with the concern about this it\u0027s signed by the operating system but now it\u0027s just kind of a free-floating thing that anyone\u0027s lying well it depends on the API that those attestation czar are provided over so different there\u0027s on Android there\u0027s something called safety net there\u0027s a new in Android oh there\u0027s a new Android attestation type and those specifically say what the city what\u0027s the public key of the app that requested this so it binds the requesting apps identity into that and Microsoft has some new attestation stuff that they were telling me about last week protestations on iOS are probably the weakest at the moment well there is one but it sucks but I just I didn\u0027t want this to be a new kind of bearer token debate you know that this little app has this sign that says station well I can steal it use it right so the in general the application that asks for the attestation has its identity in that and there\u0027s a nonce that can be sought that generally goes in that gets signed over so one of the ways that we want to prevent those tokens from being reused is by using the token binding ID which again binds it to that particular device it\u0027s the me sounds like we so yes you yes Tony you could send a challenge to the device and have that but again you can man in the middle of the challenge because of other things so there are advantages to sending a challenge in having it signed versus using the token binding ID may want to do both but right at the moment o auth doesn\u0027t provide a challenge from the token endpoint so these are things that we\u0027ll have to you know this is the first couple of drafts so these are things that we can get some implementation experience for this is still fairly early days I think the implementation experience would be would be interesting right and we have managed to get octa to actually participate in an IETF working group Carl maybe online so try to broaden our participation event awesome the new author so we would like to call for working group adoption on that one let me see on how many of "
  },
  {
    "startTime": "01:23:17",
    "text": "you have read the document raise your hand if you rate if you read that document or the earlier version well what\u0027s that waving at us Brian or what okay um I think we would have to find some some people to but just to get a sense of what like a sense of the room on whether you find in general the topic despite on what the current status is do you find it useful to have sort of an attestation mechanism for ours is that something you find use worthwhile to spend some time on in the future raise your hand if you do three four five six seven yeah we may we may not quite be they all ready for pushing the button to RC publication I think there\u0027s there\u0027s at least some interest who is who is heavily or who is objecting against looking at this at all but you raised are you have a question yes Tony nedelin that\u0027s good we also over in token binding there Gary has written at the station proposal for token binding and I believe it\u0027s got some parallel nough stew which I haven\u0027t read John\u0027s latest so I can\u0027t say for sure but it sure looks like it that there\u0027s some parallelism between the two so in in principle they parts of it could be similar but this allows so this allows the information to be passed from from the a s up to the authorization at the authentication server it allows for additional parameter a dictionary to provide it pass additional parameters so this is more the application space as opposed to the TLS layer where where the token binding attestations might live so um what\u0027s the status of the dough combining at their station document it\u0027s not been accepted yet okay they still same situation here people haven\u0027t read it right yeah because I think like I looked at it and because I was curious and it essentially just defined a field to carry an attestation it\u0027s like contains even less content and then yes undocumented John what do you expect the what do you "
  },
  {
    "startTime": "01:26:20",
    "text": "expect to happen with the attestation when it\u0027s received depends on what the attestation is but you know the are you just saying it\u0027s gonna be unspecified and in this particular right we\u0027re not we\u0027re not constraining what you know what the a s is necessarily going to do with that but if you had an attestation about what the developer key and the app ID of the app that\u0027s claiming to be a particular client ID then the a s would then have the ability to say mmm wait a minute that\u0027s not the developer key that belongs to that client ID or some such policy decisions so the first step is figuring out whether or not the app is lying to you about its identity and then after that potentially some of this other information might be useful but you know the app developer probably has some relationship with the AAS so we don\u0027t want to be overly specific but you know having a per M standard parameter to pass this information along is I think a good good part of it we also have to look at you know if the i authenticate server makes a policy decision based on some of the information it can always lie because the app can lie on the redirect to the authentication server unless we\u0027re also doing something with token binding attestations so there also has to be a of feeding that Paulette those policies decisions back down to the SAS provider Lucy so Lucy Lynch I have not read the document but but I\u0027m listening to your explanations here I\u0027m having a hard time pulling apart the reliability of the individual at access stations as they\u0027re passed and then the idea of profiling multiple access attestations into some kind of policy that you then apply there\u0027s a gap in how that works absences signature around the stuff as a package that I don\u0027t understand can you talk a little bit about why it is that you would take these as individual pieces and allow some external AAS to assemble and enforce a policy without more assurance than that well more assurance from who is that is the problem so the operating system generally tends or the lower levels something is creating these attestations the application is going to bundle them together and send them over a TIA an "
  },
  {
    "startTime": "01:29:21",
    "text": "authenticated TLS connection does adding an extra layer of signature around that necessarily add anything that\u0027s something that\u0027s open to debate it would allow you to know that all of the required elements had come from the same source at the same time no it wouldn\u0027t but what it would give you is because because so any typically what the idea is that these attestation is you have some application with a lower privilege and then the the layer below which has higher privilege like the operating system or something even more not a software component with more privilege within a task and would then provide some information about what is happening underneath so what it believes is having any so in that sense the TLS if the tls diamond starts that let\u0027s say at the application or at the operating system or at the browser then if another layer below like let\u0027s say the hypervisor or trustzone or whatever provides that attestation then from that point of view the endpoints would be different so they are an additional layer of sick of signing would provide additional information of course it\u0027s the same party sciences that also uses that yes yes done then then that would not provide any additional right if it\u0027s I guess so I think again it\u0027s who you know it\u0027s generally the wettest theme for comfortable right and how how does it even have a key to sign etc so you know the I mean it\u0027s it\u0027s something that we can look at there may be a reason you know to sign it for sign the bundle in the front channel but again signing the bundle in the front channel you then have a bunch of key management issues and is the question is are we really getting any real value out of that extra signature and I think I think what Lucy is hinting to is uh she would like to understand the framework the architecture peda like where does the information come from and and does that piece provide any additional guarantees besides actually the entity that is potentially lying providing the information by itself obviously that wouldn\u0027t provided a lot of additional information so there are lots of implementation specific issues that need to be considered and a lot of those implementation specific details relate to the individual attestation mechanisms yes all we need will probably wind up with you know an appendix of you know how you do it on on windows is going to be different from the two different formats which have on Android which have slightly different and we did semantics so it\u0027s not right no no it\u0027s just this "
  },
  {
    "startTime": "01:32:23",
    "text": "is still relatively early we haven\u0027t dug into you know all of the issues in all of the different attestation formats and you know as as you know you know by the time we\u0027re finished there will be other gas station formats etc and ways to manage the keys doors that yeah this is Causton I\u0027m having a hard time to understand how this this is gonna work would it be possible to somehow outlined the overall architecture I mean are you saying there is no over architecture it\u0027s working differently on every operating well there\u0027s an overall architecture yes the details look differently I think what we haven\u0027t yet seen yes right down or a sort of a description of the overall architecture that Lucy has been asking for and I think we need to get the end yeah that would be great and another question the details of the attestation tend to be operating system and even perhaps chip specific yet that\u0027s okay that\u0027s understood and I think the analogy to the in native apps PCP is reasonable another question are there existing prototypes or implementations of that whole combination at the station on the operating system level and oh of implementation it uses this postures to to make informed also authentication decisions we\u0027ve talked about building it but to this point without without token binding it\u0027s hard to get the guarantees for remote address stations so mmm I don\u0027t think we need to have so combining for this I think it depends on whether or not you want to be able to trust the attestations I personally think it boils down to the architecture on the trust model yeah I think right it would be nice to have some hands-on experience with this because in doing that like there will be another hackathon at the next IDF meeting would be fun to put something together like on an Android device just for the to see how it works now I believe well and let\u0027s see who\u0027s in the room I believe that there is one vendor who happens to have a control a mobile platform that is doing something like this but isn\u0027t talking about it so there is some implementation experience but we need to get them comfortable with actually disclosing what\u0027s going on not Tony stop talking about me no um I don\u0027t know who that would be but my main question is sorry this is Dave Robin "
  },
  {
    "startTime": "01:35:23",
    "text": "again um regardless of whether it\u0027s in ur signed or outer signed or all those other discussions we\u0027ve had that I just realized I\u0027m not sure what the signature is you have an attestation that is signed by the operating system yeah how does the AAS I know what with what keying material with what agreement how does you\u0027ve got a signature well again what how does the AAS decide whether he likes the signature or not well that\u0027s going to be attestation specific so writers but if you have a Microsoft provides keys for the root of their attestations yes are there if there\u0027s some magic key in an OS that says yes I am iOS 10 dot whatever and I am signing this or I\u0027m Android version whatever how can it possibly say I\u0027ve not been rooted well that\u0027s rooted one has access to that private key and it just makes it up no no it no it doesn\u0027t have access to a key of a trusted root private key specific to the piece of hardware but the a s doesn\u0027t know that you are us and they ask to have a relationship with a version of an operating system or with a specific piece of hardware now that so again it\u0027s the only the only keys that are protected or known to the a s would be what how do i if never talked to this device before so so it we need to go to specific examples of attestation so let\u0027s talk about safety net which is on most Android devices right so that requires secure boot and various Google Google certification programs what I can\u0027t remember the name of you have to have Play services and so on and so forth so there is a process that happens on the Android phone which involves some split key signing that goes off to Google servers which check the phone which then okay create look at the at the signing key of the individual application and various other other things and produce an attestation now is it a perfect attestation no that\u0027s why they\u0027ve just introduced Android attestation which involves even more TPM hardware etc so the actual access tations depends on the operating system you have everything from total crap on iOS to two different versions of of things on Android and I don\u0027t know how many versions of attestations on on Windows and in Android - - by the way not DBM so again we\u0027re gonna have to the "
  },
  {
    "startTime": "01:38:23",
    "text": "actual amount of trust that you have and what information you get signed by who is going to have operating system dependencies and we\u0027re going to have large appendices to try and explain what you make of these things so in you know if you look at at phyto attestations some of those issues are also discussed over there for the various app types of attestations that you might get from hardware platforms we don\u0027t have all the answers we\u0027re trying to start the discussion okay um thanks John it seems that we sort of got through our material faster and we fought and cutting the line and with the initial presentation actually wasn\u0027t necessary I don\u0027t like the gentleman who I bumped off the queue is actually still here you see or did he leave already behind you know maybe gone already frustrated sorry about that so are there any other questions we have another session with a couple of presentations in the second round but you guys have any comments any any ideas anything yeah Oh Gucci "
  }
]