[
  {
    "startTime": "00:00:02",
    "text": "hi. I just want to introduce myself. My name is. From, to here. So Hey, Alvin. Nice to meet you right now. Thanks for joining. Okay. It's, 1 pm. Welcome to IC Energy. This is the IRTF research group on information centric networking. My co chair is, Dave Foran. He's, joining online. And my name is. And, yeah, the usual note well. So, we are in the IRTF, and we are largely following the, I IETF intellectual property rights, disclosure rules. So in essence, that means if you contribute something or you hear something that has IPR relevance. You are expected to inform us in a short time Oh, okay. So we are being recorded. Please mute mute mute your microphones if you're in the room. And please scan the QR code and use the online tool if you want to ask questions. So I you have to anyway use your online online tool and use the queuing function there. If you want to ask questions, quick reminder. So this is internet research. We are not doing stem nets, So, we are largely concerned with, topics that might become useful for future sanitizations. So this is about finding out, It's like future directions and, especially doing experiments on those technologies and those ideas. And so when we publish overseas, it's most often about, experimental specifications. So about some systems that could be implemented could be tried out."
  },
  {
    "startTime": "00:02:00",
    "text": "But not about standards. Okay. So, yeah, we joined the main list. We still need a note taker for today. So some people came late. They are naturally The candidates for for this job So we cannot we cannot run the meeting, without a note and, and I can't do it because I've thrown the slides, and Dave also needs to help me with that. So, it's we need somebody in the room, It's really, really easy job. a So And, Colin can also not, be taking notes. He has other things to do. It's helpful if it's somebody in the room obvious Lake, rather than a remote person. Yep. Thanks so much. I appreciate it. Thank you. So your call is taking notes, you very much. Thank you, York. Yep. Alright. So, this is the agenda for today. So maybe quick explanations. So, we decided to, focus today's meeting on a discussion about, kind of distributed computing, in particular about, transactions in see in So this has to do with couple of topics, you know, like,"
  },
  {
    "startTime": "00:04:01",
    "text": "remote procedure calls, coordination in the dispute system. And also, maybe things like restful communication for future web systems. 1. And, so these all these presentations here will kind of all discuss these topics and, So we have, I think some material that is really good for, for discussion. So we hope we can have some, really interactive discussion on these things. And, so let's let's try to do this today. So we have 90 minutes, and first of all, let's check a little bit our status. So thanks everybody for working so hard on, getting these ROC published. So we have, 4 hours seats published, recently. And so Like, that's supposed to be, 6. Time and coding ones. So that is, basically, so I would see 9510 a more compact, time and coding for, for CCNX time value and coding. And then we have this group of 3, ROCs that, have to do with, say, tools and say management, support for ICN. So both the trace route and the ping specification, they, rely on a capability called path steering also useful for other purposes, but, so in, in this ping and threshold equation, you can see how you can use past hearing for, collecting information about an information center network and and its elements. So, yeah, a great outcome, And these are really nice, specifications. We should quickly point out that these, are somewhat agnostic to the underlying protocol details"
  },
  {
    "startTime": "00:06:01",
    "text": "and have encodings for both, CCNX and Indiana. So they they you don't have to choose your, your protocol poison in order to use these tools. Yep. Exactly. And, so we have, if couple of active drafts that we, also want to complete, especially, the first one, flick So that's a really important specification, in for ICN systems. So that's a based about, and and manifest technology for file like, collections. And, So it's, it's kind of really useful in a, in a couple of, application scenarios. And, so we will hear later from Mark. So one idea, how these things could be used. So we also have the reflexive forwarding draft that we, adopted recently. And so Dave, he she, and I am currently working on an update, so on a new submission that will hopefully come up shortly after the ATF. So if you want, if you're new to this, this is a specification about, tracked client server like communication scenarios where you contact the server and the server wants to get back to you to fetch more data an ICN native way. So without disclosing, you know, prefix, for example, And, so we use this for different scenarios. So for, remote procedure calls, but also for IoT calling home scenarios. There is an implementation for our NDN. That one of my students did. So that would be good if that could also,"
  },
  {
    "startTime": "00:08:03",
    "text": "get more review and, more comments, on the main list. So the flow balance draft, Dave, that got refreshed at Thailand last year. Do Yeah. It's sort of like sitting there. What one of the you want to conundrums we've had with how to do congestion control? For ICN protocols, is that There are opportunities given that we do stateful forwarding of doing smarter congestion control. Than just active queue management. And part of the ability to exploit that is actually to know how much data to expect back when you issue an interest. Thanks. And the the underlying problem is that the early work back in the first 3 or 4 years simply did interest counting. You know, if you had 4 interest this outstanding that meant you had a certain amount of data coming but the problem is is that the dynamic range of data that you might get back in response to a single interest could go from a few bytes to, in, like, in the case of MDN, 64 kilobytes, So this is an attempt, to change the equation here such that, you're actually counting bytes on the wire. As opposed to simply counting messages. And if we want to exploit the flow balance property of our ICN protocols it's it's gonna be needed in order to get the best performance out of your congestion control. Thanks. Okay. Thank you. And, Then we also have the, the microservice architecture, and draft. There has been presented, I think, last time. And, So we are currently discussing with the authors, how to move on with it. It would be"
  },
  {
    "startTime": "00:10:01",
    "text": "and our view good to, I have a bit more like a concrete specification, and a bit more than just like, high level architecture. So we're trying to move this into this direction. Okay. Any Activities, I should talk about. No. Okay. Right. So let's let's, start the program. So I will do the first presentation. And I'll just do it from from here if you allow me. Okay. Let me, introduce the topic a little bit. So transactions in ICN So There has been quite a bit of work, on ICN and distributed computing, right, So quite often, we are dealing with problems that we have in group of nodes perhaps or, So pay off notes, maybe that are evolving a common state. And in the data oriented system, you could, think about. So what's the best way of doing this? So you could see this as a shared namespace, when, like an object tree it was, like, named data object that calculates, you can address, individually, in ICN, typically, these are immutables or where you kind of have to think about how to convey state changes. And, So what we typically do is we, manage these the state evolution by publishing new named data objects. And They have been protocols, such as piecing, SBS that try to do this, in a certain way. So often for, like, a group of of notes, And, So In this way, computing, of course, there is, like, one interaction that is often particularly interesting and that is not always easy to achieve in a data oriented, system. So,"
  },
  {
    "startTime": "00:12:04",
    "text": "So you can have a robot, the asset properties I don't explain this now in detail, but typically these are easier to achieve, in a client server. Settings. So you know, things like change on your bank account or something. And, Of course, we also know some disability system, maybe blockchain like systems, and so on that try to do something, in this direction. And so the question is, yeah, what is a good way in an information centric system to, achieve these interactions. And so When you do these things, so I I thought about that there could be like different ways to realize transactions. So you could maybe see ICN a bit like a maybe IP or TCP IP replacement, the second network layer. And you assume you have, like, client server communication between two notes, or maybe in a group setting, like, peer to peer connections between pairs of notes. And then you implement transaction semantics on top of ICN, and like, a use use ICN as a messaging service. You would also do this in different way. So you could, record state changes in shared data structures and them share the structure in a, in a, in a group So that would, like, what I mentioned before, we had shared namespace and then, potentially, additional, like, let your functionality that and manages those state changes. And the question is, how centralized decentralized would this be? Of course, you have to think a bit how you achieve certain, asset properties. So especially, atomicity. And So when you for the first approach, when you use transaction"
  },
  {
    "startTime": "00:14:01",
    "text": "as like messaging over ICN, milded the, like, maybe default approach could be used client server communication between 2 notes. And, then There could be 2 different approaches. So you could have a really traditional layering. So you just use ICNNDN like systems, it's a messaging layout. And then maybe you assign prefixes to for example, client and servers. If you want, and then send messages back and forth. And then you implement reliability, transactions, and then on top of it. There is also another variant that I called, like, I see a native communication. So you could use I see an interest data as a request response abstraction And then, you mapped the transaction communication, and state evolution more directly to ICN. So this could be maybe it seemed like, cross layer or layer, combination approach. You kind of, yeah, try to leverage ICN properties. And, So today, we talk I think we talk about, like, these 2 variants. So this this won't I just talked about. So use interest data as a request responsive section, So, for example, based on systems like rice and effects of forwarding, And then Mark is going to talk about another idea doing this, based on manifests And, Let me introduce the motivation for for this a little bit. So at Jeff Burke and Lisha Chang, and I, we had a bit of a discussion and, we we wrote up some ideas on a system that we call, secure web objects. So this is essentially trying to move the web into a more data oriented system"
  },
  {
    "startTime": "00:16:01",
    "text": "And, if you remember, so the original black idea was, a hypermedia system was, document composibility and, application of interoperability. So the original web idea was just was just a fabric that allowed you to connect all kinds of different information systems. We also really head to a genius. And, it's it came more from a information management, background. And so you have different types of link semantics, and a different, 2 different types of applications. So not only static object access, of course. And so your eyes were used to, kind of link all this together with a universal identification on on naming concept. Independent of server notion or, our location. Today, the system looks a bit different. Right? So so the kind of e commerce, push, in the early web and the security architecture that we inherited now is using TLS a lot for several education and also for bootstrapping secure communication between clients and service we have, we have names, but, typically for servers only, So DNS names. And, so on top of that, we So for any, say, serious application today, is using an elaborate distribution of application, not logic rendering, user interface, functions. So there are these cult interesting frameworks. So, like, react, view, node js, and so on. So this so this could be seen as leading to a system that is, like, a, like, a virtual secure pipe in process and service, and bit like like what we call single server applications. So it it, it reminds, you a bit of these old, mini tel or BTX and systems that we, used in the past."
  },
  {
    "startTime": "00:18:01",
    "text": "And So we when we discussed this idea, We said, okay. Maybe Let's, take a step back and, so Can we provide a system where the data of the application is, better supported by the network system itself. So, like, a data oriented approach. And, So can we, enable web applications to create an exchange web objects was out maybe relying on channel based, security. And, we just have, like, a set of, uniquely identifiable web objects, that can be secured independently or, losing, like, ICN, like, mechanisms, And, so what would it take to build a web like infrastructure for, based on that. So we call this secure web objects. So application data units So all kinds of web contents. With the usual ICN properties And, then, of course, we would have a different trust system. So beyond the web PKI. So maybe, using the ICN intrinsic piece and, and certificates. So this part of the motivation came from the idea of providing a system that worked well in say typical infrastructure well connected environments, but all so in, like, local only environments. So there's like, we had a local first, Software presentation at the last, IETF. So, in that sense, we wanted to provide something that can do this, but also the, like, mainstream web. So this would probably have to go a little bit beyond, say named data objects"
  },
  {
    "startTime": "00:20:01",
    "text": "So, yeah, probably we would have to do about some other features. Like, maybe a bit more metadata to called computing in the network, so transformation, dynamic creation, provenance, implication and, you know, things like, you know, group access control and key distribution. If you wanted to build such a system. So, but we think we have to support different types of, interactions with maybe different protocols. So surely the web includes things like WebRTC. And this is something that has been investigated quite well in ICM. So I did a nice paper by, Joanna and her team called, robust. So Like, on real time system that could actually be used, with ICN today. So we kind of know how to do this. Of course, there's always, like, room for I work, maybe some supporting things like, low latency streaming in in Labsculate scenarios better. We would need a concept for linking and aggregating objects. So, for static, objects that could be based on a technology like flick but we will also need something that works well for dynamic content. Then there is, of course, opportunity to, put applications together and, and coordinate them and synchronize state. So, So we have things like The sink, could be the question it could be is, is this ready for web scale deployment, what else do we need? And then there is something like higher layer consensus, so how to map cementics to an eventual consistency service. So there are"
  },
  {
    "startTime": "00:22:00",
    "text": "things like CRTs, that, have been investigated or are currently also for building applications, was in in the end, for example, But, then you the web. Of course, you still have like, like, transactions. So you still have, scenarios where you absolutely want to change state in the system. So your home banking, an example. So not everything is just about accessing information objects. So some, some interactions are really about changing state and, doing this in a durable, consistent, way And, So if you think this from a, like, client server perspective, that's what I'm talking about here and now. So what you need is a robust request response scheme in ICN. So we have discussed this previously when we talked about rise and the the restful I see an idea and flexible forwarding. You cannot, we don't think you can do this with just interest data. So like this, like, one round trip. So quite often when you do requests, you have input parameters, you May. Want to authenticate the clients before you commit computation resources, and so on. So this seems to call for more like a session concept. And, So, typically also one transaction does not come alone, so you often have a series of transactions or So we were thinking about how to set up a session context, with these properties. And in this, restful ICN paper that, Dave and I put together, in 22. We described, this idea. And so we were using reflexive forwarding"
  },
  {
    "startTime": "00:24:00",
    "text": "tool, connect to a server. Enable this over to fetch parameters and so on. And then when we combined this, was an early idea from Park called CTNX key exchange. So that basically does something similar like TLS 1.3 security context, set up And, in the original key exchange, the idea was to set up something like, like a tunnel, basically. So we we in in our proposal, we wanted to use this for just, just, like, agreeing on doing the key negotiation, and then have the subsequent communication just work like normal name data object exchange. So, Like, let's just interest data with, signed objects, for example, And So we think this is, in, a potentially Good at good way of doing this because it would, allow you to have, like, a Session like, system that you can use for, implementing transactions. But you would still operate in an ICN native way. So for example, you could have systems where many many say clients ask for the same object, you could use symmetric encryption, and then to share the those request results for up. And, when you implement this with reflexive forwarding, So this is a bit, like, a, recap of the, the consequences of doing that So we, we utilize Forward Estate, that is established by an sent from a consumer to a producer And so that the effective forwarding would then, allow the say, producer to get back to the consumer and fetch additional data. So, the the internet draft,"
  },
  {
    "startTime": "00:26:01",
    "text": "specifies this, in more detail, So what one consequence or 11, say, aspect of the of this approach is that you need additional forwarder behavior. So, all forwarders would need to be able to, recognize these reflects a forwarding interest and then also set up the current the state for the reflective interest in then the, say, other direction. So this is, of course, something needs to be considered and and discussed, But, So that's, that's, say, our proposal of, of doing this and, we would looking forward to discussing this more. So whether people think this is viable good idea or it's a totally wrong direction. And that's a bit the purpose of, the meeting today. And, So maybe I, I'll, I'll skip this because we talked about this already. And, I have, Dave here in in the queue. Dave, do you have a comment? Oh, I thought you might wanna wait till the end. I just wanted mentioned that those of us who have been around for Probably 3 generations of mapping just applications in a distributed system onto the network protocols we have There's lots of experience that is not Really easy. And and and possibly a really bad idea to try and make multi way handshakes, out of individual two way handshakes. I mean, even classic transport connection establishment, uses a three way handshake. Anything that tries to establish permissioned sessions like SIP rounds up. With with with, multi way handshakes with 2 way handshakes in opposite directions. And the state machine for that"
  },
  {
    "startTime": "00:28:01",
    "text": "I think it took 10 years to even start to get convinced that that was even close to correct. Then if you look at authentication protocols, none of them, None of them work. As two way handshakes. Right? Everybody has tried to eliminate and cut down the number of, round trips for establishing secure sessions of any sort, whether you use it just to get a data later or to have a channel that's secure, has discovered that there that attempts to do this, wind up with broken authentication protocols. And we have the history is littered with these. So I guess I'm I'm trying to put some thrust behind the idea that if we wanna do anything like transactions or secure multi interaction operations using ICN. It's it it's not a good idea to just try and build that individual 2 way handshakes. Thanks. Yeah. Thank you, Dave. Yeah, and also, So we discussed this a little bit at any income, 2 weeks ago, And so the idea here is not to, you know, map any particular protocol, like HTTP or something, the idea is really to to solve, this problem of how to securely, set up a, a a session for these types of interactions. And there's a comment. And, Patricia Zhang, I just want to, comment on What did they just mention? I think specifically in MDN, authentication stack, is down Not at the time, when you carry out the transaction. For the rather It is at the time"
  },
  {
    "startTime": "00:30:00",
    "text": "when each entity joins the system. After that, just the secure data exchanges. Transaction or not the transaction. You do not do any further log in equivalent. Security stuff anymore. I want to clarify that. So so I actually disagree with that. Particularly if you consider I know. That's why I'm saying that I just want to percent. My view. Particularly, can send her if you can send you If you consider authorization, Authorization is after authentication, therefore, in the process of carrying out each operation and then trust a schema, make a decision. But that's a part of the transaction. There's no additional steps press The But I believe I believe there are. Policy is executed when the that they have, Casas, when you receive a command, then the policy will dictate whether it's command is or is not executed. That's it. So we'll we'll talk more about this. Kathy is not here, but that wasn't her software works. Yeah. So, I mean, this is, a different perspective, of, of doing this. So here, the assumption is that, You cannot fully rely on this, say, pre authentication, by, say, distributing, keys and maybe have something trust, trust schema. So here, the idea is that you really talk to a server, and so server may be doesn't actually have to know your, say, network layer key energy, because there may be other ways to authenticate you. So username, password, and and so on."
  },
  {
    "startTime": "00:32:00",
    "text": "And, but it's, it's a, I think it's a fair discussion to, think about, So how could we realistically built, systems, with ICN in the future. So can we assume that we just have, See, a system where everybody has a key and everybody can verify this piece and so on. And and Of course, ideally, that would be the case. But there's even if that's the case, they could We think would still be, say, application layer semantics, that would require an additional step And, I think that that's, it's a good discussion. So Mark has a Mark's in the queue. Yeah. I I was just going to, comment that, saying a protocol does or does not, you know, do authentication you know, real time or ahead of time or whatever, I think there there needs to be like a specific example given where one can trace what assumptions are being made. And You know, you might have kicked some other can down the road, or there might be caveats about what it does or doesn't do. So, I I would say, like, you know, if if Lisha has a specific reference for something, that we could then look at and compare with. That would be, you know, a concrete thing. To to look at Okay. reply is coming? The Well, if your you've mentioned my name. So tomorrow, we actually have a presentation at the dinner gym meeting. Where the students will present the very specific example. How this, workspace works. That started with authentication, And after that, then you have to secure object the exchanges. Yeah. You know, in our data use, for workspace, that's the experience that people Students in my class tried this out, they just filled one. It's so different. No more log in every time you get it connected. Once you're bootstrapped into a system,"
  },
  {
    "startTime": "00:34:03",
    "text": "your credential doesn't get lost, simply because you, you went offline and then come online again. Alright. So let, let, let me wrap this up. So So the question is really how to realize those transaction and So what you now discussed is also how should the authentication happen? So I think this, system that Alicia just alluded to, as some interesting properties, but I think it'd be good to, you know, develop this further to a, like, a web like infrastructure and try to solve, we apply, like, use cases. So Again, so this is not about mapping existing protocols like HTTP or anything. Actually about, so what do we need to do to, run and establish these, transactions. And and and So is this I see a native approach here, So we realized, okay, it's hard to do this with basic interest data. And then that's why we came up with this, combination of reflexive forwarding, key exchange, and then these transaction semantics. The downside is, as mentioned that you need, forward extensions and so that that would raised the question, How do we generally want to go about with extensions what what other things may may might be needed. Okay. Are there any other comments, or questions? Right. I think we had a fair bit of discussion. So then hand it over to Mark, to present a different approach. Hello? Yeah. me one second. Give Yeah. Yeah. You gonna drive the deck I can hand it over to you. Just a moment. That that that's fine. We we we we can do it this way."
  },
  {
    "startTime": "00:36:05",
    "text": "So these are some initial ideas on what we're calling a transaction manifest as a way of encap slating this idea of data consistency in an ICN specific for math. Next slide, please. So, you know, often one thinks of ICN as, you know, a sub or a pre published, you know, not for transactional consistency but know, you do have things that can offer transactional consistency, especially you know, distributors, leisure technology, especially you know, permission DLTs where you can have you know, a small number of bookkeepers or orderers or whatever you wanna call them. Maintaining consistency for a large number of nodes. So, we're gonna talk about this transaction manifest concept And, this this presentation is entirely skimming over the fact that you still need client to, I called them bookkeeper, protocol and a bookkeeper, the bookkeeper protocol, which would, you know, take care of how do you submit a transaction how does the transaction get approved or rejected and how can you do bookkeeper to book Keeper. You know, consistency that that's not mentioned here. This is just about the data object. Next, please. So flick is another type of manifest that describes how to encode a single object into a manifest that you can then reconstruct a transaction manifest is not that. A transaction manifest is is saying what's what the state that I is what use and what's the state that I'm writing, So you can you can construct the, causality of changes. So different kind different things. Next, please. So, you know, briefly,"
  },
  {
    "startTime": "00:38:01",
    "text": "the transaction manifest, you know, needs to say, what are my preconditions? You know, what if you think of it as like a database, What rose did I lock or what rose did I read? For me to make a decision about what I'm going to write back out. It's it's a way of saying, you know, what state has to be consistent on my input. And then what state am I trying to write out consistently on my output? You know, like, if I'm doing it unconditional, right, There'd be no preconditions. If I'm doing a transaction, we'll write But there is no pre existing row just use the database analogy, then there need to be a special token that says you know, I tried reading this name, it doesn't exist. So I'm basing this right on the non existence of this previous element, element, next, please. So not all preconditions need to be in the transaction. So, for example, if I'm doing, an employee badge, I might take Any photo of the employee as a valid photo if I think it matches them. But I have to be transaction oriented on their access level. So the the transaction manifest might have a precondition about Bob's access level. But but you know, we just picked a photo of Bob and and we embedded in the badge and we say this is where I got the photo from. That's not really a transactional piece of data. So, next, please. So as I mentioned, you know, there needs to be a protocol by which you're submitting these objects to Something to actually do the transaction and say, you know, all your preconditions were the current state of those preconditions and there's no conflicts on your post conditions. So We're going to accept your transaction."
  },
  {
    "startTime": "00:40:01",
    "text": "So, you know, things like hyperledger do this already. And, So one, you know, one difference is you know, the the transaction manifests essentially are creating partial orders. In the in the data. Because they're they're just based on my specific preconditions and and my post conditions, And as long as you ensure that at the time that they're accepted, that they're correct, then the whole system can proceed without a global synchronization, So that that that'd be one difference from perhaps other ways that this has been done before in ICF. And then it's the bookkeeper's jobs to make sure that the preconditions are correct post conditions are non conflicting. And, you know, this is essentially like creating the right ahead log that's used in many databases, so, you know, we're writing a log entry and doing that and making sure that it works before committing it. Nested transactions could happen. Yeah. Okay. So but there's a later slide on that. So, yeah, next. So this is just my kind of initial thoughts on you know, how repos and caches would interact with transactions my thoughts would be that a repository Shouldn't reply with a post condition unless it has all the preconditions available. So I shouldn't be able to read an updated object unless All the preconditions are also available. And and a repository should be able to respond with the transaction manifest that wrote the post condition. To, you know, be able to provide the causality chain for objects. Those are just my kind of initial thoughts about what a repository should do. For transactional data"
  },
  {
    "startTime": "00:42:03",
    "text": "Yeah. Whereas the cash should just cash and do whatever you know, it's asked to do, and applications should use non cashable discovery, you know, if if they need to. Get to consistent state of something. Next please. Naming, That's always the fun part ICN. So, you know, obviously, you can have user of specific naming where Alice kind of says here are my transactions for a database. You know, that might get kinda messy. Or within a database, you can have you know, transactions written by each user. I mean, there's probably a lot of other part. Yeah. Uh-uh-uh uh-uh there's a lot other options for this. What you probably can't do is write the transactions based on the post conditions because You might have multiple post conditions, and then what would you name it? So And next, we're getting towards the end here. Distributed transactions. So what happens if a user names train, you know, names objects that belong to different bookkeeper. Sets of bookkeepers. For example, there's an order database and a parts database. And when you place an order, it has to reserve parts from the parts database. And those were separate synchronization so, of course, you do nested transactions or hierarchical bookkeepers And, again, this is getting into there needs to be the bookkeeper to book keep a protocol about how they talk using these objects. Which, is clearly not done here just kind of a little thought provoking. Stuff. And so that's a question by Dave. Wanna take it down? Oh, sure. Oh, sure. It's just a real quick one. With the minute you have these kinds of multi bookkeeper systems."
  },
  {
    "startTime": "00:44:01",
    "text": "Yeah. You're into the world of having to deal With, LiveLocks and deadlocks. Yep. And, In classic systems, this is unfortunately enforced by asset style total orders. Right? The question is, can we can we actually do this without enforcing a total order? Yeah. So so The the Because it's name based you know, you you so the the the initial transaction that goes in is a essentially naming the Rose in this in the child database That it's preconditioned on. So Maybe? You I I don't wanna claim mad know, I in distributed transactions. So And you're the the you know, so partial orders have been used in in the database world. But I'm not Super up on that. Literature. So definitely, you know, that needs to be looked at. Yeah. I haven't seen it from multiple uncoordinated databases, though. Yeah. Have different that have different route. Properties, right? Navy. Navy. Navy. I don't follow that field. It's it it it definitely an interesting topic. Thanks. Right. Yeah. I mean, it it'd be it'd be interesting to see if if such a thing Could work. The Yeah. This is, you know, the the the, you know, the the the transaction manifest doesn't require a a read ahead lock So"
  },
  {
    "startTime": "00:46:04",
    "text": "Yeah. So so, you know, all these things are, you know, this is still walkless. So Transactions can fail if there's multiple updates. And clearly, there's unfairness because you know, the the user who is trying to do this over some you know, awful, you know, 4 g link is gonna lose out to the guy who's, like, you know, writing the database on his gigabit fiber. Okay. Okay. If you make that proviso, that you can actually cause a live lock or a starvation. Right. Yeah. Yeah. Then then I'll withdraw my comment. Actually do that without total waters. Yeah. And, now I don't know I I don't think that those are desirable properties. So know, when I said we one needs to develop the bookkeeper to bookkeeper protocol. You know, one needs to decide How am I going to address unfairness? How am I gonna address you know, lack of progress by some nodes. Okay. Yeah. Great question. Thank you. 10. So, yeah, that's shorthand for next slide. Right. So so clearly one would need to sketch out, you know, the client to bookkeeper protocol and the bookkeeper to bookkeeper, you know, both within and between consensus groups analyze that because it's going to be a complex distributed system. And then prototype, assuming it doesn't do something too stupid. So alright. Any more discussion I probably whizzed through that, but Thank you, Mark. Any comments here in the room? Online,"
  },
  {
    "startTime": "00:48:12",
    "text": "I don't see any. Okay. Thanks, Mark. Let's move on. It's Mark again. So I let Mark introduce, this topic. Oh, So I just I passed, like, control to you. You you can advance this license. Oh, okay. Okay. Great. So at the, Indian community meeting during 1 the presentations I mentioned, hey, there's this thing called vanadium that does a distributed access control. And so, I thought it'd be interesting to just you know, introduce this in a little more detail, you know, not a vanadium expert. So this is based on my, you know, just readings of their material I I I haven't had time to really delve into their software to see how it truly, truly works. So but there's there were a lot of topics that you looked interesting for, the ICM community. So vanadium claims that it's a secure distributed RPC system. So basically all the exchanges are based around RPC calls. It's not a con end, system, you know, in the way that we think about ICM. It has distributed naming and discovery it you can use symmetrical authentication and encryption and it can also do private name discovery, if you want to use identity based encryption. Which obviously has performance. Constraints. This was developed at Google"
  },
  {
    "startTime": "00:50:00",
    "text": "their is I believe that there is some IP around it because some of the software I've seen a, grant in the software, I believe all their software is like MIT or you know, a a permissive license. So Vanadium, basically, they they broke it into 2 They have a security part And then they have an object naming and and networking part. So in the security part you principles. So a principle is a publicprivate key pair. And then there are blessings and caveats. So a blessing is essentially the co signing of a certificate, for a purpose. And that purpose is generally an authorization step. Like, you know, Bob can read some other name or of You know, Bob is authorized to to read but he can only do it between 6 PM and 9 PM. And, anyway, it's it's an RPC them. So, those sorts of things are implementable. They also have 3rd party, caveats which have to be discharged before the authorization is considered complete. And they use these for relocations and auditing. So when there's a third party caveat, you have to essentially make another RPC call to get a discharge for that item. So they use these for example, relocation, and they also use it for auditing. So for example, I have to send out a notification to the auditing process saying, hey, I'm doing the thing. And when it says, okay. I've logged that, and I can present that to the RPC server, the RPC server will then go and do the thing for me."
  },
  {
    "startTime": "00:52:02",
    "text": "For communications, they use what they call a mount table. And this is a lot like a posix mount table. So this describes about how to locate RPC name spaces, and it provides, some amount of relative naming. So I'll get into the detail So that a little bit, So how I see an is Vanadium. So the security part pretty ICanish. You know, they they do prefix matching So know, like, if you have a namespace, Alice, you know, there there's a certificate To some principle Alice, and she would be considered authoritative the Alice name space, and she can then start creating things like her home TV or her house guests and add people into that. So she could Bless Bob, to use the name Alice Houseguest Bob and and Bob could then have read to her TV, for example, They do prefix match So it, you know, if if Bob You know, is blessed with Alice Houseguest Bob He actually matches Alice. So, and he matches house guests. And they have a way of just saying, no. It's exact match by using the special terminator So it's a kind of interesting way of essentially creating name spaces and groups for doing security assignments doing the prefix matching. So some examples, these are taken directly from the the vanadium github. You can have a principal Alice"
  },
  {
    "startTime": "00:54:00",
    "text": "you know, using the namespace Alice and she can Bless The TV principle to use the name Alice devices home TV. So if someone queries for that, it would be authorized to say, Yes. I can handle an RPC call. For that. You can then put caveats on those so Alice can say Bob if Bob is using the namespace Alice HouseguestBob, you know, he can do that. As long as the server is matching Alice, devices, home TV. So server is kind of the link into the Object naming. So all these things with colons have been Principal names, and and certificate names. Whereas Server is getting into the object namespace that you would then resolve. So You know, the fun part roots of trust, you know, uh-uh, PKIs are great, but they always come down to how do you know that you should trust this key to do something. So vanadium kinda skirts that whole issue. They they Did at some point run their own identity service that could map an OAuth 22 into vanadium objects. So you could get a user blessing and an app blessing based on the o off. And and your application could then go off and, you know, if it trusted this dev.v.i0 principle to bless other names, you know, you could then have a a a a fully running service that had a root of trust. But in general, if if"
  },
  {
    "startTime": "00:56:03",
    "text": "someone wants to write an app, they have to either make their own root of trust or you know, figure out how to do it on their own. They also ran a discharge service for 3rd party caveats that could be used for relocation. And and they chose a relocation service rather than short lived authorizations. For their use. So object naming. So now this is the weird thing about Vanading They didn't they didn't have this whole other namespace. Which is basically the RPC name space. So you have the colon names which were for principles and certificates, And then you have, this object namespace, which is how you actually resolve an RPC server and make requests. So Yeah, they called these mount tables, and they say it works a bit like recursive DNS. So when, you know, if client 1, mounts the nsone.v.i0port 8101 Mount table, It can then resolve the names a, b, and c. Under that, and those point to new mount tables. And so, you know, I can I can resolve, you know, a slash y and a slash z by going through these recursive walks of mount tables? And even within the same application, All clients don't need to mount the same mount table, so you know, like client 2 might only be able to resolve the names why and z because it only can mount that second mount table. So, this is a bit clunky, I think."
  },
  {
    "startTime": "00:58:04",
    "text": "You can also name servers in this. Right? So there could be a slash srv, which resolves to server 1. And a slash a slash s r v, which resolves to server 2. And and you're essentially calling a get function or some other RPC function. You know, on these mountain tables, They they also do it a little bit like a query string. So that's probably a bad analogy. But, you know, if there if there's extra name components left over, like you asked for, ASRV Fubar get you know, you've basically resolved a server after SRV. So server 2 would be called the food bar get as as an argument. And they also permit cycles. Okay. So right. So that's that first name component is essentially an endpoint. And and that could be a DNS name and IP address name, a MAC address that they use for, like, Bluetooth So they they are they are embedding the, you know, some locator in the first name component. And and and and that's kinda serving a dual purpose of being a locator and kind of a root of trust. For that mount table. Okay. So wrapping it up. So Vanadium is is so so it's a permissioned RPC service. The name in quote encodes The object name encodes an endpoint And a suffix, and and so, you know, everything is done by RPC services. The endpoint doesn't need to resolve to a single mount table server you know, like, if you're using DNS names, you could always pick an appropriate server"
  },
  {
    "startTime": "01:00:05",
    "text": "And, you know, it could be any server that that possesses a blessing to rate as that name. Authentication is done via pair wise key exchanges. And it could be a private key exchange, meaning, like, the server's identity or the client's identity is not known ahead of time if you're using IBE and, it has the authorizations and blessings and caveats that use the hierarchical prefix prefix matched names. So What does this mean for ICN? So I I think the security piece is interesting. You know, the the the the blessings and caveats. Are are, you know, the blessings at least are a little bit like the coast signings of PSI. But they, integrate specific authorizations into them. And and you can, you know, via the caveats you know, have all sorts of different restrictions or third party discharges that you have to resolve to to do something. You know, and and you're always proving that you have the private key for something before you get to do it. And the the their identity service, you know, they had an interesting way of mapping an OAuth 2 authentication, so mapping those tokens into their PKI and blessing scheme, whereas the RPC piece would need I I was kind and call it a bit of finessing. It it would need it would need an overhaul to make that piece you know, fit into the ICM structure. But maybe one could think about, you know, you know, can you incorporate a root of trust as part of the name and, you know, would that make sense in some context rather than have the the"
  },
  {
    "startTime": "01:02:00",
    "text": "initial piece b the routable piece, you know, could it be some sort of root trust piece? And I think in in in a subsequent discussion, you know, this session, we're gonna talk about you know, global and scoped name spaces and things like that. So maybe we could talk about you know, what are you gonna believe? Are you gonna believe DNS or routing or, a public key or, you know, how how do you really get to What you trust. So that that's my Worldwind Tour of, Vanadium and kind of how it might map to ICM you know, maybe, we could get 1 of the Vanadium authors to talk or chime in at some point to you know, get a more authoritative Break down on it. Okay. Great. Thanks, Mark. So, is this coming from, like, the, what's called meta home networking work or What what is it intended for? Right. Yeah. So I think that they intended it for, like, mobile to mobile applications, applications, and, they they do have some sample occasions. They have They have a a distributed database peer to peer database. They called, like, sync based That they wrote over the vanadium core and then they have a couple applications Based on sync base, But but I suspect that this was all done, you know, basically for Android and, you know, mobile applications. Okay. Good. That's all guessing. Kind of Dave. So,"
  },
  {
    "startTime": "01:04:00",
    "text": "Something would be interesting to do is to try and do an apples to apples comparison of The security piece of this to trust scheme is an NDN. Because it seems there are 2 things going on here. One is that the Indian trust scheme is sort of our bias toward a centralized management of of of the entire schema as a as a data structure. And this seems to be much more granular in terms of how you can incrementally, evolve the trust schema as principles, are added and removed from the system And as objects, that need to authorizations to be accessed, get added and removed from the system. Com. Plus, I mean, there's some additional capabilities in terms of caveats and discharges that are not currently in the, the Indian trust schema. Architecture. But but but It seems like you could do everything you can do with Indian trust schemes with this. Or am I missing something? I suspect you could you know, but, yeah, and and and like you said, the the I mean, this is This is much more free form. And and, I mean, I've I've always been a fan of the SDSI co signing. And and and tried you know, once or twice to figure out how we could do cosigned objects in CCN, but that never really Got anywhere. Even if you use Dan Boenay's multi signature schemes, I know they're a bit expensive, but Yeah. So, well, I mean, the SDSI is is is just really basic you know, I I sign an I sign an object that was already signed by someone else to give it"
  },
  {
    "startTime": "01:06:00",
    "text": "some additional property. So, yeah, it's not multiple concurrence pictures that it's It's, More like signature wrapping. Yeah. But yeah, I I, yeah, I I think I think that would be interesting is to you know, well, I mean, since they have this sync based application, and I think that they have like a chat application built on top of sync base. You know, it would be interesting to see, you know, how does that map to, like, you know, the NDN, you know, when the NDN syncs and 1 of the in the NDA, you know, chat I mean, you know, the current Indian chance are are are CRDP apps, but it would be interesting to kinda, you know, map those and see what's what and know, maybe there's interesting features that could be takeaways. Okay. Cool. Thanks, Mark. Okay. Sure. So, we had a plan to discuss global versus scope name spaces. Do you have anything extra, or, is this the discussion already? No. I I didn't have any, like, slides or anything prepared for that. You know, just thought, you know, There there's It it might it might be good to kind of you know, talk about, you know, again, you know, it comes down to How do you know that the key that you're looking at is the key that you should be looking at. For For believing that something should be done or should not be done? And,"
  },
  {
    "startTime": "01:08:04",
    "text": "you know, I I think that's probably, you know, the hardest part. Like, like, you know, like IPFS just totally punts. That Right. You know, the the, you know, when you read their process, you know, that they say you know, out of band. Figure out the CID that you want. Right. You I just totally ignored that. know, You know, that there's a little bit of trust you know, with IPFS and DApps. You know, based on, like, Ethereum, But you know, like, CCNX uses public key scoped names, so in the interest, you can put a public key publisher ID, and say, I only want this name if it was signed by this key. But, again, you need to figure out What key you want to use for that, you know, whether that's like Dane or you're getting it from DNS or you're getting it from the app that's baked into the app or getting it from, you know, Who knows where? Yep, Dave. So, Not to be snarky, but we need to remember that auto configuring security as an oxymora. So there has to be some kind of, quote, out of band or leap of faith operate ships Right. That that you can use to bootstrap Whether there's some trust root, that you're gonna believe to leverage everything else that you do. Right? And Yep. trying to make that happen, the some discovery process or some auto configuration, I think, is basically doomed to failure. Right? Because it's a It's there's ultimately there's always a leap of faith operation"
  },
  {
    "startTime": "01:10:00",
    "text": "that something outside the system has to point to something and say, Yeah. That's it. But one of the things when you mentioned scope name spaces versus nonscoked or global name spaces. Something was done many years ago that may be worth looking at again. Was this RPC system done for the OSF distributed computing environment? And what they did for name spaces is that namespaces started out They were all scoped. And when you generated a new scope namespace, it got it effectively a UUI Ding. Which was a pub which was sort of a public name for the trust root Public Key. For that scope namespace. Right? Now there's nothing in the system that allowed you to get that decide whether to believe that key based on only having that new UID. But assuming somebody made that assertion. You could bootstrap a lot of things, and the I think the key innovation there, actually done, by Butler Lambstead in and company at when they were at Deck CERC was there was an explicit operation that could attach your local namespace to a more global namespace. So your trust root could become a named directory or sub, tree part of a larger namespace. And that operation could be bootstrapped through an authorization procedure of the owning namespace. And the nice property there is that you could grow things from the bottom up. And ultimately, you know, if if somebody decided that the that the root of DNS was very earthcentric. And the aliens showed up and said, gee, We really want the roots of the Milky Way galaxy. Okay. We'd have no way to deal with that because"
  },
  {
    "startTime": "01:12:02",
    "text": "all the authoritative pointers are from parent to child. Whereas in that system, all the authority pointers were from child to parent. And the downward traversal was simply an op w was simply a, an optimization operation. So you didn't have to you know, flood to glow up, to, to search the hole galactic namespace. So those things may be worth looking at again rather than sort of being stuck in this, do we have a scope local namespace or do you use a global namespace? There could be a way to evolve into progressively more global name spaces out of local name spaces if we actually have The effectively a name for the trust root. That is the that is by design next impossible to collide with the name of a different trust group. Yeah. The the the vanadium just to, you know, so so, I mean, one one thing that Their mount tables do allow is You know, the the the they they they call this, you know, it's a relative naming scheme. So you know, if you say a is earth, and and You know, What the client one is pointing to is like Milky Way, Right? You know, people who used to access the earth could then be Move to the Milky Way and resolve you know, slash Earth So there were naming systems that used relative naming. And they all basically fell apart on the issue of of I compare 2 names. Are these the same thing? Yep. Yep. Yep. Right. That computation is actually not I don't know whether it's mathematically impossible, but it's computationally infeasible. Well, So, you know, the operation of of is this name The same thing as this other name"
  },
  {
    "startTime": "01:14:02",
    "text": "That's actually a fairly frequent question you need to answer. The relative naming systems can't answer that question. So so in the way that we structured flick manifests, Yeah. You can always write a new Root manifest that points to a previous manifest. And you can give that root a new name. And and and and they're the operation of saying, are these two things the same, is very simple because Right. But that's because you brought it's still hierarchical and you're growing from the top down. Yes. Right. The assertion that some sub manifest as part of this larger manifest is an assertion by the larger manifest. Yeah. The the the that you wouldn't be able to tell unless you had some way of retrieving all parent manifests for it. Yeah. So the the the in the interesting inversion here that may be worth looking at through all these years. Is growing things from the bottom up with the authoritative pointers being the child to parent pointers. Uh-huh. Right. Right. So orphans have enough state to computationally find their parent if the system gets disconnected. 2. Alright. Any other comment, on this or any idea Question, Great. Okay. Thanks very much, Mark for, bringing to us and, looking into, vanadium. Yeah. Let let's that discussion going. I think it's, actually quite interesting. Okay. Must a moment. So, That concludes the meeting today. Just, quickly,"
  },
  {
    "startTime": "01:16:04",
    "text": "upcoming events. So you may have seen on the mail list so that ICMP this year solicits, ICN submissions so for people in China, this is a CCFB class, conference. And, so it's gonna be in October, end of October in, Sallra in, Belgium, and the deadline for paper submissions is May 24th. And there are explicit ICNish things in the call for papers. Yep. And it The program committee has an area chair for ICN. So there'll be somebody specifically watching to make sure that the ICM papers get the right kind of reviews. Correct. And, in addition, so, yeah, we'd we'd like to get more input, from you, about future IC Energy meetings. So So one option that we thought could be, So do something as an interim just after the ICP deadline. That's when people typically have good ideas and, some things to talk about. So, at least one of us will also be in Vancouver So that could be another opportunity. And adoption is, of course, to chill a bit and see what what happens on the main list. So we we'd like to hear, your opinion So, either now or on the list So please let us know what what you think. If you have something, please share your thoughts Okay. See me in the hallway and, let's make a good plan for from next meeting. Everybody for for coming. And this concludes the meeting today. I'm sorry I couldn't make it to Brisbane. But hello to everybody. Sorry I missed you."
  },
  {
    "startTime": "01:18:00",
    "text": "Yeah. I'll be in Vancouver. However, so, let's let's let's hope we can actually have some in person time there. Yeah. Thanks for joining online. Dave and Mark and everybody else. Bye bye. I promised"
  }
]
