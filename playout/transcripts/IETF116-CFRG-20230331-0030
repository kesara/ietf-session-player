[
  {
    "startTime": "00:00:16",
    "text": "Hello everyone. This is session? And we'll start delays because we have quite a this agenda. So we'll start with the slides. So the chairs are And the secretary is Chris. So let just remind you about as a important things So the session has been recorded. We have two minute acres. Resort and Here a note some reminders about privacy something. The mask policy? Saf is part of our. So is this a a research organization? It conducts research. It's not a and it's due. So we have our agenda slides uploaded data tracker And we've got quite a busy busy agenda. We'll start with a chess update then we'll careful proposal from the chair about one item for our future. Then will have four updates active items and then some talks about"
  },
  {
    "startTime": "00:02:01",
    "text": "some possible future work. Last military division, No. Then we'll start with share update. So we haven't got any new November. But we've got seven documents that have passed Three of them are already in the rf queue. Cash draft is the and two as draft dependent on it are also in the queue. And we have four documents that are being approaching. Public publication I do paragraph rough draft. Signatures and frost. So we hope them for being to to occur on the queue in the nearest future. And you have twelve active say drops? One of them is already in research group last. That's it's lot editors and additional set of parameter sets from for elements. We hope to kind search group last call for signature key in the future the near future. And all other drops are also quite active. And so if you have any questions about as a document status or our current work? documents aims. Or G. Please pick up. Gordon? Hi. Colin Perkins."
  },
  {
    "startTime": "00:04:04",
    "text": "The... If you go back to the previous slide, the B draft is is done. It's just waiting for to do the right up and push the button. I'll take that'll happens straight after to the meeting. Frost aid, I didn't expect any great difficulties. I part way through the review. But but I I my queue for straight after this meeting. So a apologies I didn't get to before. Thank you so much, Colin. Thank you Questions? From the room. Nope. Then we'll start with the first presentation, nick sullivan? Okay. Hello, Hello. Okay. Hello everybody. So we've been working at the Cfr g for quite a long time now. And we have a lot of experience with the types of documents that come through this research group. It's a unique research group within the Rt. And has some, I guess, unique requirements for for writing these. And one thing that we haven't done yet is provide a comprehensive document for advice for authors to help write effective specifications. And so in this presentation, I'm going to talk through a proposal. This is not yet to draft, but a draft that. We're considering writing. To help authors of these drafts to produce solid documents that are useful as specifications for crypto traffic mechanisms. Next slide, please."
  },
  {
    "startTime": "00:06:02",
    "text": "So there's a lot of text here, but I can just This is a short talk I'll walk it through. But effectively, what we want this draft to do is to help make sure the quality of these drafts are high. So in in particular, minimizing ambiguity in this interpretations, ensuring that we have consistent and correct implementations that are derived from these specifications We want to facilitate review and analysis by whether formal analysis or other analysis by crypto photographers and we want to enable the specifications that come from this group to enable standardization within other groups and inside protocols. And b inter un and high assurance. Next slide, please. So when writing a document, I'm I'm just gonna go over some of the aspects we wanna cover? In the the document. So if you're gonna write out crypto graphics specification, especially here in the Cf Cfr g, there are multiple audiences and this is something that we have explicitly spelled out as part of the group, but would be very useful and is useful will as part of the review cycle. So three the three main audiences for crypto specifications are implement. These are folks who are gonna be coding and implementing these primitives or protocols, researchers, these are the folks who are writing papers. Either to analyze these protocols, analyze these mechanisms are come up with new ones who are looking to have a high amount of trust and what comes out of these specifications, make sure that they match the academic literature. And the last is protocol designers. So this is what's traditionally been the biggest audience for Cfr g is the It who have"
  },
  {
    "startTime": "00:08:02",
    "text": "taken the output of Cf g documents and reference them and incorporated them into various protocols. And internet protocols in particular. Next slide, please. And so in terms of presentation, we have some recommendations, some advice here that are pretty broad, but the three main stamp here on simplicity, precision and consistency. So this document is meant to give advice to authors on how to make sure their documents are have the minimal amount of complexity inside of them so that they can be understood. That what while still being precise and not having. And We also strive for consistency not only within the document, but across documents produced by the script. Next slide, please. That one Another aspect here is the output of one of these documents is going to in a lot of cases b software or it's gonna be used for software not only just analysis and development of new primitives and protocols, but also it's it's inside of the Off, it's gonna be useful to to be inter. So This is a research group in Ir. So there are some general advice that we should provide for collaboration and compromise and developing these documents. Sometimes it hasn't been clear about what recommendations authors have at certain stages of the. So hopefully this clarification will help. Documents move quickly while efficiently reaching their goal through this process. Next slide please."
  },
  {
    "startTime": "00:10:02",
    "text": "This is one example of the specificity that we're gonna get into in this document is mathematical operations. So providing specific advice almost all crypto geographies based on mathematics. So there's there's a couple different points that we hope to drill into in terms of recommendations for representing mathematical operations in an Ro format. Next slide please. As with most documents that come through this process. Security is is critical in paramount. So some general advice here for security definitions and threat models. How what is to be expected in a crypto specification. There's a lot of points here. And all these slides on the data tracker. You wanna dig in further. Next slide, please. So in in summary, with this this document, I'm not asking it to be adopted at this point. It hasn't been written, but This is this is something for which I I want to share with the group ahead of time. To see if there are anybody else who's interested in collaborating on this. Or has strong objections to the idea of putting forward. An individual draft with the hope to be adopted to provide a foundation for for authors for writing crypto specifications with the hope of resulting in high insurance crypto traffic implementations and a strong ability to be analyzed by the academic community and to be used throughout the. And so with that, I open it to questions and I see we have rich on the line."
  },
  {
    "startTime": "00:12:01",
    "text": "Wasn't all. Rich all like like I know I'm not a photographer. But I may myself with the thinking I can write well, So I'm glad to help with that aspect of it. And also, I know some other people within, like, group group at aka who would really love to help with us. So yeah. And fully support, it's great idea. Thank you. Paints splunk. Just to say a lot of this, I don't think needs a draft. You could probably get something up quicker on like a wiki page or something speaking from a dispatch point of view. If you've got new newcomers now, donate some of these basics, you could accelerate some parts of this, put that on a page, and then the more detailed stuff like notation, by means per. Okay. Thank you. Yeah. That was the original idea was to use a wiki page, but it started to get so comprehensive we wanted to to get through. And have more oversight from the broader group on this text. Scott. Scott Flu. I'd also like to be willing to help out One concern I have is what I've seen in in a lot of the ...literature written by con is they go they assume mathematics that the average implement just does not know and as best especially how to do it safely that certainly needs to be addressed. Thank you. That's a good point. Joe so. I think this a great idea. I'm happy to review contribute text whatever. Okay. Thank you. Gilmore, ac adding my voice to the course of yes for this, and I'm willing to help the mention of test vectors in particular and if that could include explicit wire formats? Instead of just the mathematical representations ensuring to to standardizing on an explicit wire format that is a really critical thing. You want get this adopted otherwise,"
  },
  {
    "startTime": "00:14:01",
    "text": "the downstream adopters h over the wire format forever. So... Yep. Yeah. This is great. Great work needs to be done happy to contribute. Great. Thank you. Do we wanna cut the queue at this point? Hi. Colin Perkins. So everyone who's in. So colin. I mean, I I also think this is a fantastic aid there and I would very much support it going forward. To two things from from my point of view or someone who is very definitely not photographer. But he has had to review a bunch of these drafts. It would be useful if it could highlight things to consider when reviewing. This type of document. And it would be useful if what what one of the things that surprised me when coming coming to reviewing these types of documents for the first time was that there was no obvious way of going from the pseudo code to the test vectors. And in most cases, if if I hunt around, I can find an that the spec has some some code in it and there's a make fail that derive them all so I have some reasonable confidence that this is generally correct. But that proven in that process is often not clearly scrape in spec. And it would be useful if it was. If we could provide some guidance how to do this in a way that enabled. Yeah. That's that's definitely a very good point and something that we've seen in a lot of these is ability or by non experts. Chris. Chris would yeah. And a response to I think what you're saying, Scott, there's where work papers typically have make kind of simplifying assumptions about how particular crypto traffic things work we have a prime order group and, you know, primary groups are easy and they fall from the sky and then look folks will never get them wrong. Those sorts of things seem like very good opportunities for this group to sort of try to specify more clearly. So in in in situations where we do find that, you know, something is perhaps more complicated and it appears to be at surface."
  },
  {
    "startTime": "00:16:04",
    "text": "See g should potentially try to embark upon specifying them to make them more clear for implement And I think we're doing a good job at that where we're slowly, like, building from the bottom up with things that are frankly kind of boring, like, p warner groups and ash functions and stuff like that. Like, thought we solved this many years ago, but But now we're getting to really more interesting stuff like multi party mutation, which is in zero. So this problem only gonna get worse over time. But it it seems like a good opportunity for this Year G detail like. Really kind bridge the gap between, like, what what's assumed simple in papers and what's actually hard to do in practice. That's not a common specifically on this draft, but on the scope of what Cfr does. Okay. Thanks, Chris. And I also love this draft. And just just as a note. The idea for this draft was kind of inspired by Chris's W talk two It ups ago. So thank you, Chris. Sparking this idea. You've yeah. You love. So I'm very much in favor of such a draft or a weak agent doesn't really matter to me. And there's two points that has to make is about test is not just having to is about having them be comprehensive and cover things if we think are going to be corner cases, The other thing is that you have to be very simple and very clear because lot the people that are going to implement are not sitting in this room and learn maybe haven't even read their Bruce myers books. So just two days ago. I got an email from some... Is trying to implement twenty and instead. You didn't include a decryption function in an encryption function. Says... Well, it's a stream light thing. It's like a comfortable so was the same function, both in clips and decrypt, and they just can't get just mind wrapped around it. So have to be very explicit in because the audience is not the people in this room, but people who probably have never even been through an Meeting."
  },
  {
    "startTime": "00:18:04",
    "text": "And we wanted to look at the cha draft as an example of some of these principles. And so thanks for pointing out. A problem somebody had with it. Hey, Siobhan. I have also in favor. I do think that either in A wiki or in this draft it would be good to put down examples of Rf that we do think do this well? Yes. Because I think that's really great. Research for folks writing new ones to be like, okay. What, you know, what happened in the past and how can we kind of being inspired from that. Yes. Thank you. That's in the in the plan. Strongly agree. Hi. Floyd school, I'll be the on eight million person say. I'm strong and favor of this draft one thing I was gonna say is the the aim to have it so that the drafts work for kind of three different groups of people for implement researchers protocol designers. I think it's really hard to write one draft that does that particularly if where trying to cover, like what a Prime order degree is at every time. So I think maybe using mist draft as an opportunity to think about you tell who a Cfr draft is full? Might be quite useful. Yes. And it that also support to the point of focusing on re usability and referencing cross documents and having a a cohesive library. Of the of these things. So thanks again. Seems we have strong support. Keep your eyes out for an individual draft and mail studied. Alright. Who's next? Safety button. Hello. So thank you so much. As next presentation, thirty. Keep for signature games It's about our hawk. Please Listen"
  },
  {
    "startTime": "00:20:12",
    "text": "We cannot hear it be honest. Chris quickly chris, please. Hi, coming Hello. Yes Now we hear you. Okay. Great. Sorry. Very sorry. So please start. Yes. So I'm everything's allow me a bit of time to talk about this. This is just a quick note that myself Tom k and Chris here have completed analysis of the draft key winding and uploaded it too. And it's available there for anyone to go check out which we definitely encourage. Looks like please. So to summarize what we've done, so we looking at security proofs for variations and signature schemes as described. In are draft to currently on version three. This schemes are based on Ec and and I think we'll of the main contributions of the papers were we look at I have a bit of a discussion of the various choices that are possible for security models. And we consider possible configurations of the teams and how they can potentially be implemented and how some of those implementation choices. Can potentially impact security available on ep now for to check out. Next slide"
  },
  {
    "startTime": "00:22:00",
    "text": "So begin with just Who hasn't seen q writing It's a very of simple idea but with a lot of subtle once you get into the details, But the basic idea is you take a keep aaron we'll assume it's in electric to curve keep air. So the security p in public an instance of an discrete algorithm problem. And you just imagine for taking another scalar b and multiplying it by key. So we have a few sort of key properties of this, which are just with that. If you just have this point capital b, then you don't actually know anything about the original point capital a. To sign messages, you need the product of a and b? But just capital enough to verify signatures So this kind of provides a way of decoupling the points a and b except that we probably fill need the these original key to sign. Next slide. So these are tend to be used in various anonymity that networks, so these are used in tour. The practice itself is mostly concerned with Ai usage in a great limited version of the privacy pass protocol. The idea that you have two users who are, you know, exchanging some signed material and they're may be possibly being mediated by some server in between who you need to have some for care and anonymity production from. Looks like So the interface for key binding schemes are we have, you know, key generation to generate what we call the identity And then this is extended with a blind public key operation, which takes a key and then a blinding key which is typically just gonna be some two hundred and fifty six bit value to obtain a blinded version of the public key. We then signed with respect to a given blinded key"
  },
  {
    "startTime": "00:24:01",
    "text": "and we also verify verified with respect to a blinded public key. Optional, you can also include an underlying operation to undo that blending operation. And the correctness property here is kind of what you need to have it all work out, which is that if you sign under a particular blinding key, and blind the public key under that same alignment key, your signature should verify. Looks like. So the the... One of the interesting things is how the security models pop up here. So the first security property will concerned with us which mostly bears resemblance standard and affordability in that we give the adversary and identity public key And then the adversary make sign increase but the adversaries left make sign inquiries with respect to a blinding key of their choice and gets back signature with respect to that message and live queue that they submitted. And then in the the it gets to submit. A tu that consists of message a signature and a blinding key. And then the adversary wins if when you run the verification procedure with that message and that signature, and the identity key blinded with respect to that blank key, it accepts. You also have to consider a freshness condition, and this is where we actually get some options. For blinding that you he that you don't have with regular signature schemes. So so the sort of basic affordability definition would just be that the message has never been submitted as part of a sign query? But we can also extend that and consider well, what if the adversary maintains the same message, but then somehow it's able to modify the signature to work for a different blanket key. So a stronger security property than is something that we might call like, blinding key binding un And there the the fresh condition would be that if the method... If that particular tu over the message of the mind was never a exciting query,"
  },
  {
    "startTime": "00:26:02",
    "text": "then this is considered a valid forge. And then finally, we can add on top of that the sort of traditional concept of strong affordability where the adversary just modi the signature somehow. There the first condition would be that the signature sure was not the result of a that query to the sino oracle. Looks like So other than affordability, the other main security it's un, and this is where we're trying to sort of model the and anonymity properties of the blending process. So for this model of, the adversary is able to create the a blind public and gets back a blinded public key. Blanket with a random binding key. And then the adversary can also request signatures for any blaming public public q dates scene. And eventually, they are given a sort of real random challenge where they're either given a new public key or there given me blinded public key that was either blinded with the same publicly you that they've been using the whole time. Or with an entirely new public key that has never been used before. And they're trying to determine which was used for the challenge blinded public. You can also modify this security model if your team doesn't support. The underlying operation by actually allowing the alignment key to be adversary controlled. Looks like So to actually construct this, we have based on Tc and e two five five one nine, and it's you know, largely what you expected some sort of modified to the specifics of the scheme. So for, just hatch your vitamin key to achieve the scalar multiply through by the key similarly for E two five five nine with Shopify five twelve. Notably, we don't clamp the scalar for E two five five zero nine as we do in"
  },
  {
    "startTime": "00:28:02",
    "text": "key generation and that's because client scalar can potentially impact the un property and then you appropriately modify your signing procedure to make sure that you're using the the product of these secret values. And using the blinded public key instead of the public key in any situation where you use the policy. Looks like So in the end, our actual results like what are our security groups, we show a proof of for Ed two five five one nine. Previous groups were sort of too specific and this is kind of a more generic proof. We also show a tight proof of the blinding keep binding strong and portability of the E two five five one nine. There is a a couple of previous... There's a type proof that showed playing on. And a non type proof that showed planning keep binding portability this is kind of the the nicest possible proof, which is great. We also show it un proof. For East and an proof. For Uc in for plain them affordability deal it to curb group model. We also have some and I to check out. Thank you. Thank you so much. We have time for some quick questions. Nope Thank you so much. It? Please is a update on? Okay. Are you driving slides or should I help? You? Or I I can do those things. Alright. So"
  },
  {
    "startTime": "00:30:03",
    "text": "yeah. This is an update on the Vid draft for verifiable distributed aggregation functions. And also a presentation on the paper that we brought. For the security analysis of the Vid vw primitives that we were describing in the draft. So this is Joint work with Mike, Davis and. And I would like to thank Chris for lending me his slides for this presentation. So... Yeah. A little bit of background. On what... This is embedded. So in the P working group of the, There's currently being standardized a protocol for distributed aggregation of measurements. And that means we want to have functionalities where we can aggregate measurements across many many clients. And only reveal the Results. So this is a sort of party computation setting. Where we don't want to learn any individual measurements, but only the aggregates across many lines. And applications of that, there are many you can think of. So one for example, would be Covid exposure notifications where this is currently being used in the Apple Google notification in the. Us to measure the effect effectiveness of the contract tracing apps. Similarly you could think of threat detection or perform to telemetry so on in browsers or add conversion measurements. So this has... Has a lot of use cases. And that's why these standardization efforts. And the is basically split in two parts. So one is vw, verifiable distributed aggregation functions. Are being developed here in the Cr. And then that distributed aggregation protocol. Which is this wrap around if you want. That specifies how to run it over H and how to how the different partners communicate and so on. And that's being developed in the At P. Alright. Here is a high level overview of what a v vw is. As I said, we have many clients think billions."
  },
  {
    "startTime": "00:32:04",
    "text": "And then just a couple of. So we might be fixing that two to just two, but think of the single single or single digit. Of aggregate. And the white works that the client they have the low measurements? They secret could share them between the ag, and that's what we call it input chair. And then send that out and the now can perform an Protocol to validate that what the client sent them actually is some valid measurement. And whatever well it means, depends on the particular protocol. And after this validation phase, which we also call a refinement phase. The can locally all of the shares that you got from all the clients and send the results to a collector who can combine the two aggregate the shares and gets the final result. One thing to note here is that this only allows for a particular set of protocols. Namely ones where we can compute on each client separately, And then only once we have done all the computation on the clients, we do the aggregation across clients. So this what we wrote here as this the functionality needs to be something like f of g of measurement one, g measurement two and so on. So this is not all of. This is just a very useful particular subset npc protocols. And the nice feature that this gives us is that all of the computation very parallel. So we don't need to think about how to charge clients across different ag instances and so on. Because basically we can just split up the clients and process them in parallel. Just by design of the protocol. And then how does this fit in into the higher level that protocol? So that one basically assigns roles to the ag. So here we now don't have that all are equal. But we have a leader who manages most of the communication with the clients."
  },
  {
    "startTime": "00:34:01",
    "text": "And then we have a couple of helper service. And, of course, in order to satisfy this assumption that are not all, we need some encryption that goes through the leader to the helper. But... Yeah. So Da use Hp for that. Http for transport and... Yeah, all sorts of business logic also of how to how to send out keys and so on. I'm not going to go too much into the details of that. But the big question for the talk is, how do we formally define security for V? So what are the security goals first? And this is taken from from the draft. So there are two things we want to guarantee. One is, of course, privacy. That's the main reason we don't want to just measure in the clear. We want to ensure that every client's individual measurement is not revealed. Besides what was revealed through the sum to the output. And the second property of one is robustness. So we don't want a client to poison the results, for example by adding random randomized or by adding some invalid measurement. And Yeah. So in our paper, we basically took us stab at formal these two properties. And we base that on version three of the draft. So right now, we at version five. So our results actually influenced how the the security considerations are written in the draft and I will also go into that in a little bit. So one issue, for example that we want solve is how the basically distribute a so called verification key is needed to verify the client's result. Are correct. This was not really specified before and through our security analysis we now have a clear picture of how this needs to be done. And yeah, we also tweaked one of our Red vw protocols as a result and also improve the round complexity of of the second one, which is will true dot double."
  },
  {
    "startTime": "00:36:04",
    "text": "Alright. So you don't have to care about this form the finish definition here. This is just how it's written in the paper. But informally, we define for the robustness we define a security game that is basically played between a set of corrupt clients, and honest ag. Very importantly here, we don't assume robustness against this dishonest. We assume that the they are interested in giving exact results, and we don't care so it's one of the is malicious and tries those spoil the results then we don't care because that's what not what we're protecting against. So... Yeah. In this game, the adversary wins if collusion of this on its lines can create a result. That does not correspond to an aggregate of a valid set of input chairs. And similarly for privacy here, we do care if malicious? So here the adversary controls a subset of the clients, and subset of the as well as the collector who gets the final result. So basically, we assume just one honest a. And in that setting, we basically the game is is built in a way that we create two sets of measurements for the on lines. That sum up to the same result. Then we flip a coin and choose one of these measurements as the input to the protocol. And the adversary has to choose which one was was actually in. Right? And it's it can decide that with better than equal probability, than the adversary wants again. Okay. So what is the impact of our paper? Basically, we did revise the security considerations in the draft as a result. One thing that I already mentions what's this verification key. So here we now specify that we must commit to it before and shares are being generated. Otherwise, clients could do some some cheating on this."
  },
  {
    "startTime": "00:38:01",
    "text": "Also for privacy, the clients must choose a run around unknowns. And for the aggregation parameters, we have now got some constraints on how they can be combined how a single report from the same client can be recruited reused in multiple queries. Yeah. One quick side note on the formal. So as you seen we've used the game based definition here. Which is somewhat unusual for Protocols. So usually, in multi part computation, you use something that's called the simulation paradigm. Where you define ideal functionality? That defines what you want to compute. And then you prove that you can take the actual views of the parties and simulate something take take the input and of the functionality similar something that looks like the actual you in in the protocol. The reason we didn't do that here is that we have for our two security properties, we have various just dissimilar assumptions. So one is the the a corruption model where for robustness, we assume that both are honest, words for privacy, we cannot assume that. And the second reason is that we want different concrete security bounds. So for robustness, we are maybe willing to take higher probability of error or higher probability of a client getting away with chi. Whereas privacy, we want a really strong security bond. So one open question would be whether this can also be formulated in the simulation paradigm, with still producing the usable definition and security proofs. Alright. And future work. So the things that we've been looking into is can we actually have an automated way of proving secure these kinds of protocols. So Chris gave a talk to the usable form methods research group here at Iot. And"
  },
  {
    "startTime": "00:40:00",
    "text": "Yeah. Basically what we would like to have is not having to write another paper for every protocol we come up with, but having some kind of way to Yeah, automatically proof secure of the protocols. And that was it. Thank you very much. Thank you so much. Welcome quick comment. I'm quite happy that definitions are game based because we have people panels that are good. And game based groups. So at least, we can just start reviewing the security assumptions, security models on early stages or if ask us to ask someone from Panel to but if I the models? Will be quite good. And we have. And any comments questions from the room or from the Nope. So thank you very much Philip. Great. Thank you. Then tobias, the the bare signature scheme, Want to this slides yeah. Thank you. And I just can't Winter. Mh. Okay. Next slide Yeah. So this is just a bit of a recap of a current drive which is known as the video signature game, which... And And several terms as appearing based smart message they can game that supports a electric to disclosure and enter proofs. Next slide. So the the first phase, which as the signing phase allows a signer to assign"
  },
  {
    "startTime": "00:42:02",
    "text": "multiple or of messages and include what's known as a heater and our draft, and the hit value is something that the the intermediate party must always disclose. Whereas is the messages selected to disclosed by the? Next. The next phase is the printing phase, which should last approve it to take a subset of the messages that were signed by the signer. And derive a proof knowledge. Zero knowledge proof of knowledge of the signature and integrity over proof of integrity over the revealed messages and the hit value. Next slide? And then to verify I can validate that back to the sun public k. And learn nothing other than that the probe has a signature on the subsidiary the and also for the revealed He value. Next slide, please So some updates to this drive we've recently published draft. Three, and we... One of the issues we're Aiming mean to resolve was how we computed random scale and the proving. Phase of this protocol. And we were using expand message from He to Sc. However, we were had that was imposing a limit us in the context of our draft of a hundred and seventy signed messages that we felt was insufficient. So we considered a couple of different options. One was arbitrarily calling a or cooling a P once and then using the output to compute the in random generated generators in random scale as required for the proving protocol. Ultimately, the the approach that we landed on, with the london in the middle, which is using the safe spring a loop. We found it to be the fastest option and introduce new dependency. Next slide. The other update since Our last draft is prior to draft three. We didn't have any proof fixtures."
  },
  {
    "startTime": "00:44:01",
    "text": "Or chief victor in our protocol. Next slide. We now do. Next slide. And the the issue here was about how we would generate these fixtures in a way that would allow implement to verify not only that they can verify these fixtures that they can rec. The exact vectors. So we had to embark on describing process around how to mock generation of the random scalar. That wouldn't be abused in production implementations, because obviously, the scale and the proving phase being random and production implementations is is crucial to the security. However, being able to make them deter for the purposes of testing. Is is desirable to improve confidence and implementation correctness. So we invested and with... There is now a section in the draft that describes how we do that in the context of those two factors. And the solution as effectively, a single P with using sustainable output and using the single seed from those random of scalar. For the victor. Next slide, please? And the... This is really just talking to how we use that setting that even the process that we defined for this mocking phase as provided the seed that is used. And the t if it was if this implementation for generating the random scale was actually used in and in a production or or a live implementation. Provided the seed is truly random, so sourced from an R. The security holds. These new fixtures have now been cross validated by multiple independent implementations. As well. Next slide. Some other updates that we've made to the draft."
  },
  {
    "startTime": "00:46:01",
    "text": "We removed the total number of messages required from the input. Required from the proof verify Api which has simplified that interface. Slightly effectively, we can juice that from other parameters that are supplied. To that operation. We switched using Sea spring instead of a a P throughout the draft. There's also a new academic paper on vi that will be presented in this year's encrypt. That looks at the construction we've been documenting in our draft and has managed to offer some further simplification and performance improvements. And on the back of that, we've already made some changes. Through then this anticipation of that paper being successful in your and we intend to as a working group adopt more of those post post this Meeting. Next slide. So a couple of questions that we kind of requesting feedback from from the wider group. It comes to test cases, we have a quite an exhaustive list of of test cases. That include things like bed public keys, manipulate manipulator signatures, you know, signatures weird messages aren't actually signed by the signer modified heaters and the likes. We've put these in the appendix but we have had some feedback from implementations that it does make the document quite large. And trying to understand whether or not, we should shift them to a separate document, ignore them. Pursue a subset. So that is I krishna I see someone? If you want as the feedback now or do you wanna do it all at in? Now It's okay? This is Daniel Gilmore. If you've already done the work of en meridian a test, the negative cases."
  },
  {
    "startTime": "00:48:02",
    "text": "Please do not just destroy them and walk away. They do make the draft much larger, and I don't think there's a problem with having a separate draft just the negative use cases separately. If we don't wanna scare off implement. But having a zoo of ways it can go wrong is a great thing to produce. So please please publish them somewhere. Even if not on this. Okay. Thank you. Finish your I I can do my question at again. Okay. Mike Mike? You want to go now. Okay. Ama, just a clarification on the dependency with the hash you are you using hashtag to fill function or just a spam message? And and and which part... Sorry. For random colors. And in terms of our usage of that and the part random gay. I think my c editor might be online the sill who might be able to speak to. That we're known Draft zero three we have changed our usage. Just wondering if my Yeah. Can you hear me? Yep. Great. So for generating random scalar. So just for the test factor who are using just message. But in the draft, as a whole, we have a dependency on curve, and we do also use have to customer function. Does for generating status. If that makes sense. Okay. Thank you. Mike. Mh. On this negative test cases question,"
  },
  {
    "startTime": "00:50:00",
    "text": "Nick Sullivan, does your drafts have an opinion, like been your your how to write a crypto standard drop. Does it have an opinion on negative test cases? No can you get but something worth considering? I think they do make it larger and there's opportunity to put test vectors whether positive or negative in other places than inside the draft canonical places. But Yeah. No. I don't have Alright. What? Where still Trans. I'm in favor of preserving the test vectors if they start to become two on will in the current draft in favor of moving into a separate document I think they're really good and let's definitely not. Hide them away from implement implement should be aware of these these rough edge cases. Thanks. Yeah. Just to elaborate on that further as well what we found was sometimes for some of the negative test cases, we would include a reason of why the case should fail. Like this has a publicly key that is not that of the original signer. Or this message was manipulated and those sorts of things. And so sometimes implementations would say, yay. The the case failed as is expected, but I'm I'm unsure not I failed for the right reason. And so perhaps the sub proposal was making that reason somewhat more informational and nature and how it's described or sitting the expectation correctly. So that you know, difficult to fail negative cases that that is understood by implementations at least. Next slide? So met to Map scale, so part of our draft uses this procedure where we take messages"
  },
  {
    "startTime": "00:52:04",
    "text": "and we have to I've ultimately met them to scale as a part of the signing process. Currently in the cypher suites, we have essentially one mapping, which is which is the hash to scale up operation. However, some usages of Bb can be combined with things like range proofs where you and instead taken into value and you appropriately map it and then you can do a pretty good operation on it, like less than or greater than. And the question is really where that definition should be as cypher suites for example, the concept of a cypher suite is is an now draft for cypher sweet didn't define the mapping processes arguably. It could be vulnerable to bad mapping methods that could be implemented and future. So should we use the cypher suite layer to essentially define the only mapped to Sky methods that are permitted for their cy suite and require applications to effectively Well, define new cypher suites if you wanna use new mapping methods or whether or not this should impact. Be allowed at mapping. Right? I don't have the put open in time. Chris, don't punt to the application And just in the name of interoperability, like, define it in the specification, so people agree how this is done it seems like everyone will have a better day. Cool. Thank you. Last one. And the last one here is point encoding. So we the site current type switch we're using is to defined around the B twelve thirty one two. And the compact encoding will compressed in encoding that we're using as effectively a method that is defined by the z cash community. However, that that point compression is curved specific. And"
  },
  {
    "startTime": "00:54:03",
    "text": "effectively, we would prefer to use a compressor format because of the test of the resulting signatures and proofs. So the question is is there a no method of expressing this sort of point compression we should be looking at. We have found one draft that we think. Could be useful in that regard any other ideas and how we could express that. Thank you. Times If you want, we can ask you the panel, we can So thank you so much. An next presentation. It's last about the active work items. On bo? Properties of andrea. Now it'll try to week customers. We granted here and here well, so please start. Great. Yeah. I can response. But everyone, I'm going to give an update on properties of a chart and speak a little to a about some new next steps. Since the last night have in November, the trust was adopted by uc cfo gene. And a lot of from the community heather there was a lot of involvement. Thanks everyone for that. This point. Encouraging So speaking about the traffic health some new projects added were edit and well, the most important thing is had overall consistency of a child was robert improved since spam. But here on to speaker parts"
  },
  {
    "startTime": "00:56:01",
    "text": "some next steps. And how at this point, untapped is rather theoretical. It might be useful by like, crypto photographers, I right just want to use some established and common language when writing by documents. It seems like it doesn't help those people who fun to find an appropriate Agency choice program there high level functional application. So think about that, I came up with swapped free step plan. And the first tab is about how to issue. And the first step is to add some examples, of functional applications for each property. How the property can contribute to a high level application, and which problems it might cell using such a, like about you have You Resilient At t and functional application is that you can use it on smart cups. It is the first step. Next step is to hide like invest mapping. From functional applications to properties. So had... If you have some requirements and functional applications, you can look it up in that's vocabulary. And easily understand to which properties you need from your at to fulfill that climate. Like you want to use your Ae security on smart cards then you need resistance are resilience. I a I have intentionally missed step zero. We have the first"
  },
  {
    "startTime": "00:58:00",
    "text": "do some theoretical folk and the stand for a functional application actually is how define how we functional application. How deep become in details and, we speak about functional requirements and implications. To, like, demonstrate at it isn't a really it isn't very easy problem. Just as short example, you have functional application like, you're an implement. You want to store... You can start of all plain text in a secure, memory fan treat. It is use situation. So... And do you ask Is it possible to do something with fact. And we could talking do like, ask answer you've had to use should use release on on verified plan text secure at. But actually, maybe we've but prompt of her a lot of flavors and various like, Integrity, there two kinds of repeat valid. So which file actually you need as an implement. And Here's the problem how to address such travel difficult to from far to point of view functional applications. A lot of answers to them. To them, but they might be very difficult. So in the next episode of a typed in the next lesson, the main aim is to answer this questions to find an understanding how to functional applications and requirements and help the step line of a plan. So if you have an opinion on the questions path or you want to see some functional requirements and the applications be covered in the tough will be happy to hear from you and chat little that."
  },
  {
    "startTime": "01:00:00",
    "text": "So also, they're going to add some new properties and since it is a tough about purposes and improved existing fund and Oh. Make of a attempts Thank you I would be happy to answer any questions. Thank very ram much andre. We have some time for comments questions of this question. No. Thank you. Then the following presentation, eu? Don't, please? For the slide just tell us. Next slide. Please Go. Okay. Thank you very much. Good morning, everyone. My name is Eu, and I would like to talk about the update of the algorithm raw. Next slide, please So I have Alright. I think three updates today. The first one is the security operation by third party. So we asked two institutions Your institute of Technology Mont address and Universal to run to evaluate the security of the algorithm. And they overwrite intel five are attacks confirmed that the secure against these F And so the Ii team address for the differential attack linear attack and for attack. And you most of rent one, I I adding the three attacks by the I and recovery attack. Yes. Next slide, please. The second update is the new security Ring about the key committing security?"
  },
  {
    "startTime": "01:02:03",
    "text": "Which is the property that sci can only be with the same key that is used to en encrypt dot plain. So For example, if the context is encrypted with key k one and generate the Soft and tug, then these this can be decrypt with k one. And if you try to decrypt with differently, k, then it cannot get the any output from the Cipher. And guys provides one hundred twenty a bit security key security. And next slide, please. And the third update is the full variation. So in November, I show the result on twelfth generation into core processor. And this time, how I did preparation on thought generation core and also rise, nine series. And performance compared with a to fifty six Is I shown in this graph. So on C nine, our can perform more than two hundred twenty gigabit thousand, while a is around sixty it's and on rise. Okay. So it's around two and ten and what As are on to one hundred ten twenty. Yes. And difference between the these two on As is because of the support of the instruction set on the core I know series the right in ninth series. And next slide, please. And the finally, we"
  },
  {
    "startTime": "01:04:02",
    "text": "published the implementation as the open source and no. It's available on github. So please feel free to use the implementation and embedded it to in your application, Both or any any anything And if you have any feedback, I'm more than very welcome to receive and Yes. That's all. Thank you very much. If you have any questions with comments. And Moreover if you have any from your side to the eighty property draft, so please help us because We want to drop today as complete as possible. Yes. And any questions or comments commands to you? No questions come. Thank you so much, You. Thank you. A following presentation, go some. Rsa bios signature raised public metadata. Ten? You want us to further the site or your request request? Okay. Got. I think that you can control the slides. Which one is it I see. So please start. Yep. Yes. So, hey. My name is Ga, and I'm presenting on partially blind Rs signatures. Based on a graph where you should put out. This is a joint work Scott Henri. Christopher Wood, and Kevin you, the names are an alphabetical order. So basically, I'll go over some motivation for blind signatures for partially brand signatures."
  },
  {
    "startTime": "01:06:01",
    "text": "As well as for our signatures, then I'll quickly go over with our supply signatures give a little bit of background on them. Then we'll talk about partially our signature which are basically blind hours signatures with public metadata, and which is basically the meat of the stock. Quickly go over to benchmarks for our implementations and basically the current is a document implementation, and basically, where do we go from here. So blind signature are pretty motivated at this point. They're used in privacy pass. They're used under the hood and Vpn by Google One. In icloud private relay, they can be used to avoid we did capture solving. For private click measurement for tar denial service defenses, and the list goes on. Partially buying signatures, basically, I'm gonna use it interchangeably, but plan signatures with public metadata. They also have a fair of motivation, a recent draft on will oblivious random functions. They have an oblivious variant. So it's not sure think of time signatures with the a partially blind period as well. These signatures can be basically thought of as signatures for specific settings. For example, these settings could be geographic locations like if I want a signature with Japan as as as japan and public metadata. I also wanted them to only be kept verified with Japan and public data not for some other country. One can think you can have, you know, for You can have different piece of different metadata. But the issue with that is that you have to sometimes have to fix the choices public ahead of time and key management scalability concern, can. We were bad in production. In production services. Yeah. So but by the... For blind r,"
  },
  {
    "startTime": "01:08:04",
    "text": "signatures, recently I adopted a document for this. And the reason was that it's a simple one round scheme. And it's a stateless server issuance for the signatures. And also they have... They're probably be verifiable and have widely supported implementation for that in different libraries. So it's actually for us to think of a public medi support for the standard as well. Alright. So I'll quickly go over both by na signatures are. They basically work as follows. You have a client server. This server has a public a secret key. The client has let's a message that wants to get blind signed. It asks the for the public key from server. The server basically... Sorry. Didn't client will use the publicly key and the message. input Pass it to a blind protocol and produce a blended message. With it will send back to the server. The server will then use blinded message and the secret key to produce a final signature. Sorry. Should we do the blind signature and send it back to the client. The client will then use the finalize for the. Using the public key, the message, the blinded signature and the invoice generated earlier and produce final signature here. Couple thing to note here is that in the final protocol, a public verification is run as a sub to make sure the signature is correct. The signature Again. It's publicly verifiable because it only needs the public key. To verify it. Moreover, the input message not directly blinded. It for as first past you some... And sorry. It's encoded it first and the standard proposed Ps and go for that."
  },
  {
    "startTime": "01:10:10",
    "text": "Alright. So how do we enable partially buying signatures? We basically make sure that we use the same public metadata in all stages of the of the protocol b signing finalizing as well verifying. Exact changes are that before you are Before you blind your input message, we the input message with pub metadata it and then pass it to the B encoding function. Secondly, we we also augment the public key, which which is basically, we take the public yet multiplied with a function of the public metadata. The function here is we are using H user implementation. The technical challenge is that H needs to be equal prime to five n if ns sdr mod is advised the function. In order for the server to generate the correct signing key, And in order to do that, we we in order to solve that challenge, we basically put the restriction on how Model generated and we only use Rc models which are product two prime. How that helps how that helps us to do that? Is in the draft, and it's little I got lower in ten minutes. Alright. So we we we we vetted our protocol in multiple ways. We have one more and affordability proves for the protocol, which is basically that if I ask this server to produce give me n signatures on random data, I cannot forge n plus one signature. We have an un eligibility proof for the same metadata, which means that"
  },
  {
    "startTime": "01:12:01",
    "text": "if I have two messages, I get under the same public metadata and I get them signed by the server. And this server produces two blinded signatures. And then I run the find last protocol and convert those binder signatures to final signatures server will not be able to tell which of the final signatures were link to which line signature under the same public metadata. We also took care of domain separation. In our protocols, we we've ensured the different R modules and the same public metadata would lead to different public keys. Augmented public the keys. We also made sure that hash functions in the input message and the hash functions used. During public augmentation it domain separated using standard techniques, like putting like tags in the input in the input to the hash functions. Moreover, we are aware that as public keys are non standard sizes, that could be non sizes. Because of the H here. We... We we put caveats mitigation techniques or denial service attacks in the draft. Finally some benchmarks for some implementations. We have... So the left column has the has the numbers for the standard blind are. The signature scheme and the right column has the numbers for partial bind, the video schemes. You can see there's an overhead, but we hope you see this improve as go it becomes more optimized. We have to implementations right now and have like them. Below. And I tang Christopher good for providing second implementation go. And finally, for current status, we have implementations right now. One is in this one go. It solves the need for privacy. This basically this drop also these for need privacy password this type of token, and this"
  },
  {
    "startTime": "01:14:03",
    "text": "our signature and other real world applications. We have a draft out. We have an academic paper with security proof should be put out soon. And basically, I, what's to interest in good adopting this document. And thank you. Thank you so much. Any comments questions now? If not could you Hi. David. Crypto ent tool that's terrifying. I I'm also at Google, but different parts of Google. So when we talk to each other, it's through the Where actually we just met for the first time here. I just wanted to say we're interested in using this for our Ip protection service in Chrome that we're working on this year. And we'd love to see this progressive the Etf and get the amazing level of review from this group. So I personally supported an adoption. Thank you. Scott? Scott, please? Okay. Thanks for presuming ga. I also work at people. With David in both scouts, sometimes the intermediary I posted a draft that uses this protocol for a privacy pass variant that in incorporates public metadata. And I'm a strong support of adopting this draft in the C g. And can you work on it. Thank you. Sorry I think there is quite an in the draft. So please could please bring it to the list. And call production. Okay. Thank you. Thank you guys. So next presentation, Morris. Plasma, be related protocol."
  },
  {
    "startTime": "01:16:18",
    "text": "Hello? You want to control it or do one test Yeah. Have have some innovations. Actually, Yes. We can come to control the sites. One moment. Wanna Could it please request once again. Yep. Think requested. you Now your screen has been shared. Alright. Perfect Yes The slides please please. Yeah. Hello, everyone. My name is Limited Mu. And they will present to you might don't work with a Car and to some plasma. A framework for private and lightweight statistics against Malicious Hundred. So we will focus on the problem of private heavy And this a vid related protocol the problem of essentially focus on computing the most popular client submissions. Without revealing its individual information. The prominent work of popular addresses this problem. Using using two servers that I to not with each other? And the fifth of Popular protect the correctness of the protocol against My clients? And also the privacy of the clients. So in this I think, we can see that we have multi clients and some of them"
  },
  {
    "startTime": "01:18:02",
    "text": "might try to behave malicious. And up popular addresses that by running some Text. And rejecting everything that's not one informed. Unfortunately, they will have a Malicious server The server will be able to add to introduce some to the protocol. And the honest server will not be able to detect this. Although they all client's data will still be will still be protected the output of the protocol will not be correct. Issue you with Plasma by introducing a felt server? And our model with both correctness and privacy against both clients and the server. So instead of using Can text, we protect against my list clients using a... A new primitive called verify verifiable point functions or V vps? That essentially instead of running this expensive text, it only relies on some lightweight and similar key. Finally, to defend against some we haven't introduced a fed server in the protocol instead of using test two. And we... The two owner servers are able to detect the activity. So let's quickly see how Dps work distribute point functions because there the backbone of both our protocol, and also the protocol of Popular. So we have a client on here. Yep. Client down here. And essentially this is a a binary, where is everywhere zero. Except for a specific path that's once. Now all the list of this binary three, essentially are all the is the domain of all the possible bits things that the client can have? And this one them here, represent this client's private. They want to that above it. It's a subs. Of this private input. Now what the client is doing, and that's an interesting part about Dps. Is that they create two keys."
  },
  {
    "startTime": "01:20:03",
    "text": "Instead of... And instead of cigarettes setting the whole binary three, They just tickets it say they just sent to keys and some greater information. To the servers and the server can use the keys and the information which a not showing here. To expand and generate these the secret cell trace. So as you can see, here... In on Blue, you... We have additive secret of one and everywhere else will have cigarettes of zero. Now we will repeat this process for multiple clients. Its client sends their keys, the service expand them, and then they are gonna get everything together And at the end of the protocol. They just made the data, and what they get back is the final get statistics. So it's still good to be through because Melissa's client vote and by downloading, I mean that they can introduce more than one pass or more than one leaves that have non zero values. And vote for multiple points? And because these shares, the service hub do not have any easy way of the detect. My client can also do a... Disproportionate at voting attack. Meaning that they can create some shares that when they add up, they neither zero nor one. Again, the servers did not have any easy way of the detecting that. We defend against the list attacks by using five Dps and quickly about a few things about hour notation, So here we have the two keys that I mentioned before that client sends to the servers. We have a private point a. And we also have a public vector x. So the vector essentially all the the domain, but its clients simple can be can be within this domain essentially. And a is the private a private point that exists someone in this domain. So x is public publicly known to the service."
  },
  {
    "startTime": "01:22:01",
    "text": "And they private it to the client only. Now the client is is these two keys, and the two servers can evaluate own the public domain the key. So seven zero is val with q said seven one is evaluating on key one. I get this capital y and capital z, which are essentially some vectors. And the form of these vectors is this one, where we have a single set of zero everywhere, except for a specific point where we have a single cell of one. And the correctness of The essentially guarantees that if we add adopt these vectors, will get a one hot vector where we it will be zero except for a specific point that it will be one. And that point since it'll will be eighth point which is the client's everything. Now verify build. When we have the this evaluation, Apart from this single cell vector, we will also get two blocks p zero t one. And if this proof, that means that there third vectors y and z are well formed, which means that essentially, there... If we add them up together, they are everywhere zero except for a pacific point. Now this does not guarantees guarantee that the non zero point will be one. But at least it's guarantees as that we have say just one non zero point. Which will solve a double bolt attack. Now to also take at this point is one, What we can do is that we can sum up all these the elements of this vector together. And? In fact that they are equal to the house of one minus the addition of all these elements. Now with both properties together. Who can tackle my malicious clients and we defend against the double voting attack. By the way will? And we defend against the this disproportionate voting mail impact,"
  },
  {
    "startTime": "01:24:00",
    "text": "by these houses that They just mentioned. Next, let let's see what the Melissa server can do. So if will have on client, and they just saturday the? Emily Melissa server can can easily introduce some errors to the computation. This means that they can just add something to the result. And because it's this local to them, the honest server doesn't have any way. Of figuring that out. And at the end, when they reveal their, the results, the only server will not be able to detect this. I will not be able to detect that melissa has added something there. And previous work are well vulnerable to this problem. Or rather to this attack. So we all of this by introducing a third server. And we rely on replicate secret setting. So the two on servers are able to detect that the third server exactly malicious. Finally, we the use client by the verification site that uses a medical place. And essentially, this allows us to very quickly verify if we have some clients, and easily find them and remove them from the protocol. So down here, see. I have the the clients. It it's on... Like, locally to to the server. So these are the client's data And we build, trees. And then the service take the medical routes. And since these are different, then we take the left and the right. Since the left are, then we don't have to... We don't have to go down essentially. On this list. And we can just take it recur the right sub please. Until we find the client the clients and then remove them from the protocol. And when nice thing about this is that"
  },
  {
    "startTime": "01:26:00",
    "text": "if we don't have any clients at all, this is just one has that we're taking. But from the presence of Clients, please... Both communication, the time depends depend on if we have manage clients or not. But this take essentially depends to the total number of clients. About experiments? We compared with poplar for up to one million lines. For sizes of thirty two up two to fifty six please. And we observed the three to six times speed up. And finally, due to our That's consistency take we see significant communications communication benefits over the popular but this is for all clients. That's all. I'll be have to answer questions. Let me just thank you very much for the presentation. We have two the questions three questions. Let's it. Hi. Philip Shop Google. Great talk. So I like the verifiable Dp about and the fact that you can do that in a single round. So what I presented before, the double protocol in our paper. I think yours is basically a better version of that. If we just take it in the in the two server setting, So I think this Yeah. What fit very well with the with a V dev draft. I have a question on the verification slide could you go back to that? The one way you show the the vector that has a Yeah. single non zero. Yeah. So with this hash at the end, what happens if the service don't evaluate on the point that is that is one. So if we only have zeros, does it still work?"
  },
  {
    "startTime": "01:28:01",
    "text": "So the client does submit everywhere serious you mean? No. The client submit one, but it happens to be not a heavy hit. We don't explore the top of the of the the part of the tree whether there's a one. Oh, I see what you're saying. Makes sense. I answer the question? Yeah. Yeah. So mike is here. Yeah. Jumping. I philip. Can you hear me? Yes. Yes. Yeah. So this is the V gdpr. So here, we only consider like, just leaf level comparison for the verify verifiable will incrementally be we consider like, heavy it, we have to consider that the root and the I mean, I mean, each parent, and then and their children have the same values. So that's a more local check. So that's taken care like, you can check that the children have the same value, which is coming from the bad parent. And you can repeat that check. And that's also look. That also can be done. If you shouldn't Got it. Okay. So that's not for the heavy you're not doing this check here, but you're doing this parents and the actually, Like, due to time constraints pandemic could. Talk about b p, which is the for. So essentially, this way this verify pay is from another paper. This not got we introduced. So up to here this is from a paper from But what we introduced on top of that is the verifiable incremental Dp. That also uses the tricks that popular is using to be able to do that"
  },
  {
    "startTime": "01:30:00",
    "text": "for this level, and they don't have to do this, like, multiple times. So since we you uncover state from the previous level, then be from that to go to the next level, and we just use a trick tat extension when we have about just actually find the. Yeah. That we'll when we have a patent here, we'd take that trip these two leaves have the same synthetic as Okay. I I think I get it now. Thanks. Okay. Team, please? Team, your next queue? Yeah. Sorry. I'm just waiting for my mic to come on. Yeah. Hi. Tim Gag, Internet Security research group. In particular in one of the editors of of the da draft in Dbm. So I'm interested specifically in the dimension of your your scheme where there's an x for ag server. That provides more resilience against like, one, you know, one defect ag. So The way you put it was the adding the after solves a problem. Think it's more I to save it, like, it picks a different trade off. Here's the thing. Yeah. Obviously, you get more resilient against the defective ag. But on the other hand, If it one more server involved, it's much more expensive to run and much more complicated to coordinate the communication. Right? So I don't bring this up like, just just to criticize, but rather because currently the, we have, like, committed as of the the Session back on Sunday. Or sorry. That was Monday Japan time. We've committed to taking a change to da that we're that protocol to exactly two ag. Right, which I think would rule out that part of plasma. So the other part of Plasma, that's, like, a faster T etf is still very you compelling. So... Alright. The reason I bring this up is that... Yeah. Our reasoning is that, you know, In this space of trade offs, we're like optimizing... We're choosing out to optimize for operational simplicity and performance of the protocol."
  },
  {
    "startTime": "01:32:03",
    "text": "What I'm curious about like, not for the room really is that, like, are there people out there who are considering deploying da through to point something like Poplar who are concerned about the sort of like, one defective server attack that this Mitigate. Because if you are, please let us know in the P working group so that we can you know reconsider a change that we're about to make to out. And I had another observation which I forgot. So I guess it couldn't matter. Thanks. Before you go to your next one, thanks. Thank you so much for the comment. Yeah. Well that's totally correct. And what we are actually doing is that we're because we have three servers. We run three sessions total. So for the client there's also some more communication that they have percent. But apart from that, we have a trick to essentially, the third server can replicate the locally what the other service are doing to try to optimize this a bit. And even the presence of these and also like the more session that we run compared to popular we saw some some of some performance essentially advantages Chris. Chris. Yeah. Think Tim said exactly what I kinda wanted to say at the mic However, I just wanna to pile on that it's not necessary that whatever decision you happen to make with respect to V vw, Like, maybe you do pull this into v and you introduce a new a particular type of error that requires or does allow you know, a a a a three party non including, like solution. Doesn't mean we have to actually implement that and support that in doubt. It could be the case that and we restrict ourselves to exactly two ag that are not including. And then if someone wanted, a different protocol that did require three different non including parties. We could go off and separate... Or specify that separately. So I don't know if we need to answer this right now."
  },
  {
    "startTime": "01:34:00",
    "text": "At the in the adapt world. And because I don't think we need to answer it right now in the adapt world, I think it's reasonable to venue you, perhaps investigating how we might merges into the existing v dev work. On the basis of the benefits that you described in your presentation. I guess that's more of a a a common attempt. That to you. Okay, sir. Thanks. Thank you. We can continue to cash and the list. Yeah. The? And that final presentation for today, my, game combine? This mike. Hello. Mike ellsworth. Hopefully, this will be quick. This is a lot less deep than the talks we've just had. Hopefully, it's this is a quick pass too. Next? So the basic point here is Post quantum, hybrid cams are starting to show up in all sorts of places. There's lots of protocols that want to take a new thing and combine it with an old thing. Here's a couple examples that have design draft, the the lapse P q composite cams for Cms and s mime. Opened Dg p draft. I've got the Ip ips sack one in brackets because it's not really strictly a one shot. Hybrid chem, but it's... I mean, it is a hybrid cam. I'm sure there will be more. I'm sure this is not gonna be the exhaustive list of things that need to do hybrid cams. So I'm proposing that Cfr g should standardize a like known safe super strong, good combine. If you wanna combine Chem. This is a really strong way to do it. Next, So the goals of the draft, like, trying to target a similar goal to Hp ninety one hundred eighty in"
  },
  {
    "startTime": "01:36:01",
    "text": "specifying a really strong construction. If you use it, it's known good there may, of course, be ways to simplify it, there maybe be cases that don't need construction not strong. And that's fine. So the Tls has hybrid design draft and the open open Vg p draft are both opting to use a simpler combine and they're... Specifying we've got stronger assumptions on our input cams than the general case and therefore we can get away with a simpler combine. But our goal here is to say there are hard cases. In particular Cms S mime is a hard case we still support rsa cam it's static long term keys. You may well have servers acting as decryption oracle for those long term rsa keys you know, that's the hard case, Let's specify a combine or that you know, handles it properly. Also point out from a Whole chat yesterday, Paul Hoffman made a suggestion that this draft here in Cfr Act is a bit of a living document and try and creating appendix that categorize weaker or more special purpose combine, and maybe we could try to make some sort of table of security assumptions that they made about their input cams and why that allows their their combined to be here in that context. Maybe this draft could be the place to collect that. Next. So that brings us here. I'm writing the hybrid combine draft for lamps. Aaron is riding a hybrid draft for open Pg, we need this document to exist. We need a strong reference to to motivate why we're combining our times the way we are. Speaking for Aaron and myself, I think I do not speak for S, but speaking for Aaron in myself, we don't feel qualified to write this draft, but we needed it to exist screens to exist now. So we went ahead and wrote it. And we're we're operating in this mode right the draft we have people to yell us on list, take their feedback, make it better. Conquer the world. And we're already at around three of this iterative process. I think"
  },
  {
    "startTime": "01:38:01",
    "text": "we've gotten now is a much stronger combine than what we had in London. So process working. Yeah Next. So here's the. Here's the actual crypto. In the current form what we're proposing is actually a slight improvement or a slight strengthening of the nest p eight hundred six c r two multiple input k. So this... The the construction at the top essentially is fifty six C r two, the improvement is that the k i's are actually a hash contamination of the each shared secret with its corresponding cipher for text. That's the bit that I think is being simplified out in in various other drafts that you don't necessarily need that inner hash. That comes down to the details of whether your input shared secrets are fixed length that comes out to whether your input Ke are in Cc, if not, I think you need that extra hash in general, but if you have strong assumptions, but you're gonna be using, you might be able to drop it. We're also proposing here in instant based These are all shaw three based, which is open point of question, do we want s two based for performance reasons? But here we're specifying foreign citations, which are all shot three based. And then, yeah, the fixed info allows it to be fully compliant with with the nest Kd and you know, if you have protocol doing separation information, here's just want to to slip it in. So that's really... That's really all I've got. That's it. Please please can yell us on the mailing list. If you yell useful enough, I will make you a c author. So, yeah, is this useful work for C g to take? Thank you, and we have some time because it please but quinn,"
  },
  {
    "startTime": "01:40:02",
    "text": "I think is remote. I'm sorry. Me. I was having trouble coming off a mute. Can you hear me? Yes Oh, there we go. So I was gonna ask you why s three as supposed to show too. Is there a reason? Other than it's shiny and cool? And possibly not faster. I think so there was discussion with that on list. Aaron and Stab have been taking the questions about that. Maybe you ask that in chat, I think aaron at least was online. That's question. I mean Okay. It's I think In one version of the draft, we did have an two h f construction and then after some debate we took it out and now I'm I'm sort of the wrong person to justify why. So I'm not attempt to do that on a record. Thank you. Richard Barnes? Answer this question. It's... The reason why we opted s three is because of the construction that allows us a simpler proof to define it a P that can be keyed by any input. S would require probably some more complex construction, like the one proposed by an. And this is why we propose to have only chat three candidates into at least the Cfo draft. Then if someone wants to dedicate from that, and wants to have their own implementation using Chat because they can prove that they're security model is strong enough. That's probably that's probably the the way to go. My opinion."
  },
  {
    "startTime": "01:42:03",
    "text": "Thank you. Douglas. Douglas Villa. Just want to say that we'll take a look at trying to prove security these, and I guess try to differentiate under what conditions on the different, like, hash functions and Pdfs yield security with that combine versus the Tls combine Thank you Quinn. Do you mean the the city sub I is a a cipher. That what it means? Correct. Is that what it means in in the draft? Yes. Yeah. So ss is the shared secret and the Ct is at corresponding cipher text. Yes. Potentially, some some cam or cams in the future they not Generate the sas secret from the cipher text and the s text, you know, potentially for some camp can be very large. So I don't think put in the set text in the next step for the pdf is a needed thing to do and potentially create some performance prop bloom. Yeah. So again, this was this was added I think by s side of this change in order to proven Cc, like, that chosen site for text attacks, more proof is more tight. If you include the... I don't know the details but it is in our security consideration. Yeah. The for the security of say to... We need to look and to pacific Camp to see how the transform happens"
  },
  {
    "startTime": "01:44:01",
    "text": "and the proof is go there and Pdf is the the later step because in the camp, normally, it has a pdf in there to generate secret already inside the camp. Not r a cam. Kd is external to R rsa cam. So that wasn't the what the one saying the security is different thing foot for for Key dev over here. Basically, you want to generate more keys than the one key coming out from cam And so I'm just saying that Ct could potentially have some problem for the performance reason And also what is eight over here? Each is a hash function. So you have a regarding in the saturation there, we have kd and h both defined. So in the first negotiations, they're both s three, but the second associations Kd f is a K mac, and h is still shot three. No. Because okay. So we don't list here the edge, but we'll list the Pdf So that's what why I'm asking. Sorry? On the slide, we list the Q instances But we did not list what it is. What option for edge? It's right after it. What's older right after that. Okay. Sorry. May I just So for the two questions, why are we using S three as while we rely on the random all properties of ke. And it's not because of Shiny and cool and new And for the second question, if cipher text has to be present in the combine. So we are also heavily relying on the cyber tech to be present because we are building up from a work of And Peter. That include the side text to"
  },
  {
    "startTime": "01:46:03",
    "text": "mitigate the encapsulation oracle. And they say if you do that, then the complete construction Cc two at least one in ingredient canvas cci. So this is the reason why we include the cipher there Thank you. Yeah. I I I I know, I said the camera weather though, not has the Cc security to enough, it depends on the the details of the cam. Pdf is This is also outside okay. So it's got a different Yes. But the idea is to have ke that a camp combine that takes camps that might that might take an ingredient in cam that is not Cc to secure. Yeah. Oh, okay. So if you mind it with another one, like, the ones from the peak houston standardization that panel. Okay. Then, you know, it then... Okay. It sixty two. Okay. Yeah. If if if you have one one input camera which is in Cc a two and one which is not you want to combine our overall to be ins cc to preserve that property from a single of the inputs. If the the non Cc Nancy security came Ct and you personalized like this it has some some benefit but it has... Has has security approved look into this to see if we actually have Cc security from from this construction from the non Cc security So... Yeah. It's If us we want to to then"
  },
  {
    "startTime": "01:48:02",
    "text": "more security and that seems okay, but I'm not quite sure if that would achieve Cc security, I haven't seen approved for that. From non Cc. For Hi. Rosa I'd like to speak in favor of this work and and getting it done as quickly as possible because we're kind of at a place in time where we have an opportunity for a lot of crypto libraries to help a few primitives that are used by all of the protocols. And we have to... We need a construction where if if we have one good input we get the best of the properties that went into it even in the face of age and crypto algorithms where maybe we thought it has Cc two, and then later somebody proves it didn't. Or somebody registers in in. Some algorithms that are not as strong as we would personally like what they're gonna get used. So let's get the best we can. I of the Thank you Okay Can get more Just wanted to say that I would love to have the G's eyes on this please do adopt this from the Open Bg working group. We are probably gonna reach out, hopefully. And if we do, I'm quite sure that the P stuff will be in, and we're gonna need guidance like what it's been proposed this trash. Thank you. Scott. Just a quick knit. There I don't believe that we can always say that the output size is is limited to fifty six or five twelve bits. There may be some cases which actually generate several symmetric keys from the same cam input, it may be wise to replace such s three was a shake"
  },
  {
    "startTime": "01:50:05",
    "text": "this is being addressed with the Can you have construction that is came back, yet allow unlimited as well the chat reconstruction have the counter that can be increased in rehash. To generate as much as you material as necessary. Thank you. Please bring... Take it to the list. Think that people will need to discuss it. And maybe Will discuss the adoption of this document on the list. Thank you so much. And now it's the Ao b. And as business and do have at least one One question one item. From the hawkins? Then, please? Yeah. Thanks, Dan Har I gonna get in a queue, but just mention me. So I have a draft and Cfr g on doing some extensions to Hp specifically for adding compact output to the nest curves and also a deter cypher for key wrapping. Watson recently on the list proposed adding another featured H we're doing Hvac and a Cbc. I don't know. Whether the group thinks that that's a good idea or not, but if they do, would probably make sense to add that to my draft and just do a well altogether. I know that we're adding a whole bunch of new features to something that already has too many features, which is probably not good, but if there is a strong desire for H and a, Cbc then please speak up on the on the list. Thank you. Yes, Scott. I've been going over the I've been going over the partially blind Rsa"
  },
  {
    "startTime": "01:52:03",
    "text": "signatures, and I think I see a crypto graphical weakness. If the hash of the metadata happens to be a a large prime times smooth number It sounds like anyone should be able to to generate a signature for that metadata get the get get signed by by any metadata. Without the the signer being able to validate that. That sounds like maybe one percent of maybe one percent of all metadata can be forged. And your replies or comments commence? I'll put that on loose. Yes. Yes. Yes. Thank. Thanks so much. Any other comments questions, proposals? You have some time left. Surprisingly. Hi. Floyd. So this is just a... Well, I'm sure most people know that p equip is in the next session. I have a draft there on terminology for post quantum hybrids. I wanted to flag it to Cf because when we proposed this at sec dispatch One fourteen, room was kind of split between dispatching it Cf or dispatching it to a new group that didn't exist yet which is now p whip. So if people are interested, please come. If you like, arguing about mathematical terminology, which I'm sure isn't something which applies anyone in this room, then yeah, come along or have a chat we'll speak about on my list. Thanks. Thank you. And then we'll finish our meeting. Thank you everyone. For coming. Have nice."
  }
]
