[
  {
    "startTime": "00:00:07",
    "text": "but they're not sure. It's 9 I think we can get going. Right. Right. Right. Let's Yeah. Good morning, Gav. Everyone, we have a big room only a few people I would really appreciate it if you come closer even if you're planning to leave halfway through, it's still better to have us Nearby, Yeah. Alright. Yeah. Starting with the note 12, it's Friday. I've seen it before. still, the Northwell applies. And so does the code of contact conduct, Please be respectful of one another. Ex slide. You have them. Right? Yeah. Yeah. Yes. Our agenda for today A few words on document status, And then Justin will lead the discussion about the resource server draft. which is the one major document that We have outstanding. And then any other business, next. So"
  },
  {
    "startTime": "00:02:01",
    "text": "Our core protocol is right now in Roman's Kio Roman. Good morning, everyone. I haven't even had a chance to log in Hi. off in the queue. Thanks. Yeah. I have seen the publication of it was very exciting, kinda when it popped up. So wow. Like, it's been so much kinda work to do that, to set everyone's expectations, I have a couple of other very large documents kind of ahead of it. So I I don't know whether I'll be able to even get you in August. Best case, it would be very kind of late this with some other things kind of happening. So, again, I'm very excited. I'm not ignoring it. I see it. got some big documents ahead of it. Thank you, Roman. The ARRIS protocol Tiaras Part of the protocol is still in the working group. We will discuss the some of the remaining issues. There is a large number of issues opened just in a shows me only 3 of them most significant. we'll be talking about them. and plan for working group plus call. Any comments? Alright? Just in your next. so it controls. Yep. I got them. Alright. Hello, everybody. So Since we last met, We've gone through 2 revisions of the core. And as was mentioned, it is now sent off to ISG for review, so it's in Roman's hands. We haven't had any new revisions of the RS draft"
  },
  {
    "startTime": "00:04:02",
    "text": "but there's been a little bit of work in the background starting to look at how we can actually finish that So that's what I'm gonna go through. So as per usual, we the diffs are in the slides, and you can look through the issues if you want to the main changes on the draft were a lot of editorial cleanup. So a a lot of stuff fixing the ID nets, fixing the the Ayanna registration, requirements for designated experts and all of other stuff. Although considering what I've just gone through with, it signatures. We've probably gonna tweak that a little bit after Romans review. We're a team. We're a team. We absolutely are a team. And and as I've as I've mentioned on some lists recently. Every single time I do an RFCI learn something new about Ayanna that I didn't know before. Yeah. Roman says me too. Alright. And a lot of it was a a lot of the editorial stuff was clarification of things like user facing parameters. Yaron had some good issues about know, ASCII characters and processing of, you know, not ASCII and stuff. like that. So that's all clarified in that. The biggest one, though, is the the token management API endpoint. Now previously, we had had this kind of a to to kind of a a weird but optimized part of the protocol. where in order to call the token management API endpoint, you Applied the token that you were managing to the request as an access token. It was not passed in this part of the call. But this could be very strange because if you were doing say a token value rotation, your token could have been expired. And so your AS would have had to know that This token is expired, but it's actually okay because it's calling this particular endpoint. So"
  },
  {
    "startTime": "00:06:00",
    "text": "actually let it through because I'm about to renew it. and all of this stuff like that. We got feedback from a couple of different implementers saying that was really weird with how they had implemented things because a lot of people are implementing sort of the gap management stuff by reusing RS Processing. So there's a there's a middle layer that does the token processing, and then it hands it over to the AS for the actual AS functions, which makes a lot of sense and is actually the entire reason that we built it this way is to allow for that kind of reuse. So we took a step back here, and took a look at the hook and management API and said, you know what? we're going to make this in parallel with the grant continuation endpoint. and it's going to have its own token management access token for managing tokens? That's a mouthful. But it basically is analogous to the continuation access token for do for calling the continuation endpoint. it's always bound to the client key. It is never a bearer token, so we were able to get away from some of the problems with Baratokens when you're doing these high security functions. And that's really that was really the main change. So instead of passing in the token that you're managing, you're calling a resource in the HTTP sense. So it's got a URI and it's got the access token bound to it. And from that resource, the AS figures out which token you're talking about and pulls whatever action that it needs to on that token, whether it's rotating the value, refreshing the the expiration, revoking it, All of the functions of token management are now are now are now handled that way. This should make it easier for clients, and it will definitely make it easier for authorization servers to implement piece. This is, of course, an optional part of the protocol. You don't have to offer token management to clients when you issue an access token. And in a lot of cases, people aren't"
  },
  {
    "startTime": "00:08:01",
    "text": "offering token management, which is why this only really came up at during the last call. It was kind of a slightly dusty corner. So those changes are in. They were they were brought up on the list. There was a GitHub issue discussion and pull request that's all merged in. and that's all part of the draft that is now forward And that's it for core. I wanna stop for a sec to see if there are any quite or comments on core before we move on. Alright. I am really excited that Cora is is moving forward. It's been a lot of work getting here. I think that we've done a lot of good stuff with this, and I'm excited to see that go for Now on to the RS draft. Those of you that were here from the from the beginning of the working group may remember that a long time ago, we factored out a bunch of stuff from CORE that was specifically facing the relationship between the resource servers and the authorization servers. this is things like how you map to a structured token like a JWT, how you declare token formats because only the IRS cares about that. client doesn't care about that. and how you do token introspection, token validation, and those kinds of 6 So all of that is in the RS draft. What we've done in the last in the last few months is we have now extended the discussion of a the app direct token model, Excuse me. That is in the RS draft. And This is not a token format like Jot, But this is basically saying that when you get a gap token, These are the kinds of things that it represents. So there's the party that approved it, the resource owner. There's the client it was issued to. There is the resource servers that it is applicable app. Now all of these have places to be expressed within the Gannap protocol itself. But"
  },
  {
    "startTime": "00:10:02",
    "text": "we felt it was also important at this level to be able to say every we should have sort of a core set of things that you expect to have in a token when you're building out a system that you wanna be interoperable at this level. even if you're expressing them in different ways. So the goal with this draft is to have mappings to jot, mapping to introspection, and definitions of introspection all inside of this. Our goal with the RS draft is to process, the remaining issues. And in a minute, we're gonna go through a couple of those issues with major topics today. and That's that's pretty much this presentation. So we're gonna jump to the issue tracker in a sec. the core is in. ietf, review, AD review, whatever the right term is. What's that? Publication requested. Thank you. And Fabian and I, Fabian couldn't join us today, unfortunately, had a he had a family conflict. And Fabian and I think that we can get the RS draft at least 2 working group last call ahead of IETF Eighteen. It's a much simpler document. It's already had a bunch of work done to it, and we think that For most of the issues in the tracker, there's a there's a pretty clear direction on on where we can go and bring those changes back to the group. There's a couple couple pieces that we wanted to talk today, though, and probably have a little bit more discussion on the tracker and on the list. So that's what I had, and I think that we can go to the tracker unless there are more questions. I apologize. The question to call before we move on For the token management tokens, do we have a clear cryptographic separation Twin the token management tokens and regular Regular access tokens."
  },
  {
    "startTime": "00:12:04",
    "text": "Yeah. So they have the same restrictions to them that the continuation acts token does, so they're not allowed to be used to access other resource servers. They're not allowed to be used to access the continuation end points or or anything else. I don't know if you would call that a crypt graphics separation. So so cryptographic separation is typically something that's inside the token. You can have a type or you can have some other field to distinguish between different types of tokens. So Alright. So that's actually a key part of the token model that I was just talking about that's actually in the RS draft because that is something that the client doesn't actually need to know about. because the client gets these tokens a different in different parts of the protocol, So for the client, they're they're pretty well separated. It's the AS and RS that need to enforce this separation. And so that's part of the token model. So we already have a section in the RS draft that talks about the continuation access token as a particular class of token. and we need to add text for the token management tokens. Okay. It's kind of funny for the security of the AS to depend on security guarantees. the other draft that So it's -- -- for now. It's fundamentally, it's it's an implementation detail, and we already have discussion And I think a security considerations section about separating those those tokens. Okay. But it it it is already a requirement in the core draft. The RS draft is just gonna go into more detail about how exactly you would wanna do that. which is the right place to discuss that to discuss that. because, again, that part's not client facing. I will show. Okay. Yes. Okay."
  },
  {
    "startTime": "00:14:04",
    "text": "All the slots for us, so you need to on something. On shred Okay. Alright. Yeah. So Yes. I do. I'm sorry. since you're sharing. Yeah. Oh, yeah. Mac Oh, is it a permissions thing? Okay. Yeah. Alright. So you can follow along at home with the with the GitHub issue tracker. That's all that we're pulling up right now. We will get there. We will get there. But It is the ietafghannapdashwg, GitHub organization, and this is the GNAAP resource servers we're gonna be looking into. yeah, link is in the notes. Thanks. I apologize. Yeah. Okay. try again. Okay. Alright. Excellent. Alright. So As Yaron said earlier, we've got 17 open issues. A lot of these are sort of you know, general clarity issues that Fabian and I and I read through and it's pretty clear, like, we just need to know, go expand the introduction or go clarify this point or something like that. We just haven't done the editorial you know, work to to crank through these."
  },
  {
    "startTime": "00:16:03",
    "text": "There are a couple of There are a couple of ones here that I think do deserve Excuse me, wider wider discussion in the west. So The first of these is number 52 RS revoking access check ins. So this was a originally, a comment from Andre on a on a on a different issue. And the Question is, should we allow the RS to manage tokens. So the RS is being presented and access token, And the argument here is that the RS could discover that something is fishy about that, and it should have a way to signal the AS that, hey. Something weird happened, and I don't trust this access token value. Now the general sentiment of the of the discussion that's already on the tracker. This is all going back over a year now. The general sentiment of the thread on the tracker is that we don't wanna give the RS sort of, you know, direct access to manage the token, so we don't wanna give it the same just hand at the client's token management endpoint. in the same way. However, however, Having an ability for the RS to signal the AS that, hey, something might be fishy with this and you might wanna do something with it. That does seem like it would be a useful feature to the overall security of the system. Right? So there's there's a lot of text to to read through on thread, a lot a lot a bunch of comments there. My Current stance as an editor is that this is kind of a late breaking feature that seems like"
  },
  {
    "startTime": "00:18:00",
    "text": "this would be nice to have if we could. and there's not really a strong pull from it, for it from implementers. So to me, this is something that would clearly get pinned into extension, of some type sort of a new function that would be exposed to resource servers by an extension to an app RS and not something that we would try to add to the draft especially this late in the process. that is My take on it, but we would like to hear what what folks think about this feature if there's any feedback There's not feedback. We're just going to Close it without action. personal opinion, No. as a chair. No. It's not too late in the process. personal opinion, I totally agree with you the is a nice to have extension kind of thing. Outoscope for now. It's still, like, microphone? You know, if can can we still get to it with the extensibility later? Yeah. Yeah. We we definitely could. that is something that Fabian and I need to really work on on the RS draft. We did a lot of work to be about the extensibility points in the core draft. We haven't done that with the IRS draft yet. So that is something that if we if we do table this as as no action, then we would wanna make sure that there's there's kind of a clear and natural place where this type of function would fit in. To me, it feels like this is something that's kind of parallel to offering introspection. Right? because that's getting the status of a token. This would be something that would be affecting the status of a token. So it's sort of"
  },
  {
    "startTime": "00:20:03",
    "text": "right only introspection? I don't know. Actual actually, I'm not sure you even need to would be nice if we had an extension point for the but not necessarily, in my opinion, because I think the workflow for a revocation coming from the IRS side is different, and it could be implemented totally on the on the application level with whatever tools you have. Okay? Alright. Thank you. We'll confirm this on the list, but it seems like we will probably close this one with with no action to the text. Alright. Where's the one with symmetric keys? Oh, number 47, please. So this is another one that goes back a while, and it's around referencing text that's been that's been updated a little bit, but is still there. So the AS is allowed to issue an act issue a key along side and access token, basically assign a key that the client can use This key is passed by value in most cases. And so the question is on introspection, ultimately, How do we handle keys like this and getting that information to the resource server, in particular when it's a symmetric key. So asymmetric keys, It's pretty simple. You send the public key and It's not really a big deal. symmetric keys, every other place in the protocol, you're not allowed to send a symmetric by value. You're only allowed to send by reference. So"
  },
  {
    "startTime": "00:22:03",
    "text": "introspection should be able to return a key reference. No problem. The question here is should we specifically restrict sending symmetric keys by value in an introspection response. To me, speaking as an individual. To me, this restriction makes a lot of sense because you're basically you're telling You're telling implementers that if you're going to use symmetric crypto, you don't get a free key distribution mechanism that kind of you know, kicks out all of the security from underneath you. because all of yeah. The main The main controls around security is symmetric crypto around key distribution. Right? Whoever has the key can use the key. That's the whole point. And this still would allow introspection to return a key identifier or other derivation handle type of thing if you have some proprietary derivation thing, like, you know, is for AWS. They've got their own their own process for that. You could still return that type of information as a key identifier, but you would not be allowed to return the symmetric key value in the response. that's kind of where I personally think we should go. We don't have explicit text about this. the introspection section needs to get beefed up a fair amount anyway. But this this was a restriction we were thinking of putting it in here. So any thoughts, comments, or feedback on that one?"
  },
  {
    "startTime": "00:24:00",
    "text": "Okay. We will confirm on the list. And if there's no objection, that's that's the direction we are the editors are gonna plan to take. with that one. And please, everybody, feel free to chime in on the GitHub issues, read through the the history of the comments. Some of these go back a couple of years old now, but you know, we're finally finally getting to shake all the dust out here. And, finally, I believe it is number 56, the top one. If this is the one that has the graph. Yes. It is. Okay. So, yeah, this is this is based on Florian's thesis work yeah. They've they put, like, flowcharts and or you know, sequence diagrams and everything like that. Wow. Yeah. There's a lot of analysis here. The What it what it boils down to, and I'm going to try to summarize this. What this largely boils down to is that an attacker if they're able to convince somebody to use their own AS. then they could basically issue their own Access token, to get the attackers resources associated with the victims, client in session. Say again? Yeah. It's one of those one of those attacks that there's a lot of preconditions to it, but it's still, it's important to to to look into those. But, basically, It's it's a kind of an esoteric token substitution attack where the attacker hands, their own token to an unsuspecting user"
  },
  {
    "startTime": "00:26:01",
    "text": "And then the user goes and use that at a real at a RealRS, And then then that the RS is none the wiser because it's an actual It's a valid token. that was originally issued from a from a real AS. Some. Some. This only really works with baro tokens. Because if you're doing keybound tokens, then the attacker can't do the key substitution to the client in the same way. the it's it only works if the attacker is able to convince the client to talk to the wrong AS in the first place, which is valid in a lot of cold boot scenarios. less common because for the most part, the binding between rs and AS is relatively fixed from the client perspective in practice, But Could happen. And this it doesn't matter whether you're doing introspection or not. in this case because the token itself is is an actual issue token from the Real AS So there's no there an introspection doesn't save you here. because it's a it's a valid token that's being that's actually being passed through. So I'm not sure. What we can do about this attack, having read through this again this morning. I'm not sure what we can do about this attack beyond warn people Because ultimately -- -- proposing a solution? They're proposing a solution that you basically pass along a pointer"
  },
  {
    "startTime": "00:28:01",
    "text": "to the AS with the access token, So the client says, I got this token from this AS. and therefore, you know, that that's where that's where the rs does the introspection. and does the validation. one of the problems with that is that if you are set up in a multi AS environment, and you start to actually depend on that at the r s level, Then the attackers AS, would be able to answer that introspection call. and, therefore, would actually be able to do whatever they want with the RS, because the RS would would believe whatever the attackers, AS, came back with. which is kind of worse. So I don't think that their mitigation actually mitigates anything It complicates the protocol and requires the client to pass information additional information that could itself be substituted Granted that's another attack service you would have to crack. but it could it could in fact be substituted or or proxy. So there's a lot of text there. I'm now looking people to necessarily digest this all right now. My instinct is that we need to add security considerations, and describe this flow It's based on Florian's work that we had already incorporated us couple of considerations and discussions in the main core document, you know, sort of describing what the problems were that his formal model found and how to to avoid those problems. we can do the same thing here. And a lot of it boils down to the IRS needs to know which AS it's supposed to talk to. which which kinda does anyway. But it also"
  },
  {
    "startTime": "00:30:00",
    "text": "emphasizes the importance of a tight binding between the AS and RS from the client's perspective. And so if the client if the client is getting that information from a source other than the RS, then the client has to trust that source. We have similar AS mix up attacks in OAuth. that are largely that largely amount to don't do that. much worse in OAuth because of the prevalence of client grits and baritokens everywhere. Here, a lot of the sharp edges are mitigated by key binding all all of the requests, the token request, and all the client requests. So it's it's less of a less of a wide open problem. but the underlying pattern is still there and in enough things, things if enough things go wrong, you can find yourself in this weird state that you would not back to be. So it's when it to me, this reads like one of those It is technically a problem. I'm not sure exactly how we would reach it in the 9, quite honestly, quite honestly, but I think it's worth at the very least, calling out in a discussion, and, and seeing the best way to to address that. There's a lot of text in in this thread please read it. Fabian and I have not discussed what exactly we're gonna do with this yet. But That that was that was the last big one. Any thoughts on this attack? Has anybody had a chance to actually read this. some -- Dave. curious. I'm I'm hello? Just It's even on. It is. Okay. These are the jokes folks. This is Dave Robin. I'm curious, and I'm not an expert on an app. I'm just here to learn. But you mentioned the aura. How does the"
  },
  {
    "startTime": "00:32:00",
    "text": "client know which AS is served by the IRS. I mean, I just watched the the Aaron and Michael Mike Jones put together their thing for over and know off about WWW to authenticate, giving you the hint. It's the equivalent of the ACE hint, saying, here's who to go talk to. or you read my well known and you can find out who to go talk to. So in Ganapt, how how how how is there some equivalent way that I, as a client, can go to an RS and find out your AS so I can talk to the right person not based on some other knowledge of where my AAS is, and then therefore, avoid this idea of talking to an evil AS. Yes. So the w w w authenticate response is built into gap core. It is -- Okay. -- it is optional for an RS to implement. because not all APIs are necessarily going to have that level of discovery. But the equivalent function is there. Okay. doesn't that if if if that were more mandatory, to pay attention to then wouldn't our This idea of I wanna talk to the right AS. That's Yeah. So the -- the fundamental problem here. I don't wanna be redirected somewhere else. Yeah. It's it's fundamentally a discovery problem at the root of it, much like all of the all of the mix up attacks in -- Right. -- you know, off are are discovery problems because it's mixing the authorization and token endpoint from 2 different spaces. Right? So, yes, if you're doing dynamic discovery, that'll do that. The the pushback from having this be the mandatory way for the client to do this is that when it does require an extra round trip for the client to make this association. 2, it's hard to define sort of it's hard to define the realm that the that the RS It's covers. Like, if I'm making this call at this path with a post and I'm doing a get to a different path Do I just go to the same AS? Do I use the same token? It's gonna be API specific is what it amounts to. So we have a mechanism for when you do want it to be dynamic."
  },
  {
    "startTime": "00:34:03",
    "text": "In a lot of cases, though, it's gonna be static. You're building a Facebook client you know, going to the OAuth world. You're building a Facebook client. You plug in Here's Facebook's graph API. Here's Facebook's AS. You just you build that in and open ID connect. It's and, you know, metadata just server metadata discovery thing. It's just it's just kinda baked in. Here's your token endpoint. Here's your user info endpoint. They're they're knit together. So there's a lot of secure and and manual ways to do it. Gannap has a secure automated way to do it, which does avoid this entire problem. Oh, so. I just it's dear to my heart because I folks I work with, a lot of them really love the the ace hint idea -- Yes. -- and a lot of them say, no. Don't make me process Hint. I've already know where the AS is. don't make me mandatorily must look at the hint and then go, oh, there's the AS over there. I thought it was over here. So there's a big debate Yeah. There. Yeah. No. That is that is pretty much the same feedback that that we've gotten in this space. Thanks. Hi. Roman Carnegie Mellon University got a no hat And so in listening to kind of this back and forth on how we potentially mitigate correct me if I'm on the bridge, you may be perhaps misunderstanding. So there's some optional stuff that we don't wanna do because it's more round trips that would mitigate this. But if we gave some guidance to the implementers, kind of, of the API they're building on top of this, they could do more things. Yeah. So the guidance would be basically in documentation or discovery or however people find out about how to connect to your service. which would one of the options would possibly be this the the optional dub dub dub authenticate response. you know, make sure there is a deterministic mapping to the proper AS. And then this this whole problem problem, goes away as best as I understand it."
  },
  {
    "startTime": "00:36:02",
    "text": "could we just document what you just said as the security consideration and So like, call that our resolution to that. That's kind of what I'm leaning towards. Like, I haven't had a chance to talk this through with Fabian yet. to to clear it. But, again, this this was one of the last big remaining discussion areas that that we had on the RS draft. So I wanted to make sure it was surfaced here and we will we'll we'll bring up all all three of these on the list as we go through as well. I Okay. To to me, I haven't gone through formal analysis and found something is an indication that maybe we're we're missing something like In principle, something deeper in the protocol. I would suggest that before we come up with a guidance and all sorts of ways to to to watch over this issue. we we should go back to the people who did the analysis and see if there are alternative solutions you don't So you disagree with the current proposal That's fine. Let's see if if there are alternatives that do not involve the the implementers. you know you know, reading guidance, Yeah. I agree. And if you go down through thread, there's actually a fair amount of back and forth to that nature. already in GitHub. Alright? And, yeah, and that's all That's all I had. So Fabian and I think that we can get RS"
  },
  {
    "startTime": "00:38:00",
    "text": "ready for working group last call ahead of 118. And as long as So I'm just curious if that's doable. We we might be able to actually put that through. the process. Do you think we should have an interim ahead of that? Or What do you think would be the best process here? Yeah. And specifically for for this issue, I mean, running an interim and see if we can specifically get the The guys who reported this. Yeah. Yeah. in on it. Alright. That makes sense. Yeah. Does it make sense to run this at the all security workshop. We could. That's coming up at the end of end of August. It's soon. Yeah. It's very soon. Very soon. Yeah. I will be in attendance at -- I thought so. Right? Yeah. So -- And I was wondering if you could conference section I mean, if we can find out if they're gonna be there. Oh. Oh. Oh. Oh. Oh. Oh. Oh. because if they are, right, then, you know, we can just run it there -- Yeah. -- instead of an IETF session. That makes sense. Yeah. Alright. We'll see. I don't -- I I don't know if I can make it. No. I haven't I don't know yet. but but Yeah. Yeah. Yeah. Yeah. So, again, kinda Roman, ED had on kinda process, we would, of course, never use the OAuth. Got a workshop successful kind of as it is to substitute the standards kind of process kind of in the IT for hours you have drafts. Completely understand that. In this case, it would be let's let's it would more be, like, authors getting together with somebody reporting an issue to have a discussion. Right? No more than that. we're on the same page. Yes. Yep. Yep. -- for the record. And, again, I think it goes with kinda loud saying, you know, kudos to the to the folks kind of a a Gugart for this really kind of amazing kind of"
  },
  {
    "startTime": "00:40:01",
    "text": "analysis they brought to the IETF. So kind of thank you if you're online or It will go on record saying thank you many, many times. Right? Absolutely. and they really deserve, like, high bandwidth Yep. Yep. Right. Right. Right. Right. Yeah. Absolutely. Like, I would I would love to sit down with those sequence diagrams with them to make sure I'm not missing something. in this in this stack. If you read through the thread, you'll you'll see that they're their model their initial model was a little bit off. from the assumptions that they were making. And so that's you know, some clarification we need to make in in the RS draft to say, like, this is what this is a property we expect versus don't expect, that kind of thing. But Yeah. If the researchers are gonna be at OSW, which I'm not sure do I'm not sure if we have the name of that specific researcher. apart from their GitHub profile, but I will I will check into that, and I will I'll check with Daniel Feth. about about a about it. attending OSW? So Okay. Alright? Alright. Thank you. What? That gets us to the end of the agenda. and the AOB. So in the interest of time. I'll give you 5 seconds run to the mic if you have something to say. Yeah. total. Alright. Now we can all go over to our oath and play tourist. Alright. Thank you. Thank you. Thank you. work is false. If you're gonna go to OAuth, it's now Golden Gate 78."
  },
  {
    "startTime": "00:42:28",
    "text": "Yes."
  }
]
