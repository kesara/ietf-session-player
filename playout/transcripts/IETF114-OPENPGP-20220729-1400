[
  {
    "startTime": "00:00:15",
    "text": "okay we're on time i guess should we search okay good morning welcome to the open pcp working group at uh itf114 uh i guess we'll get started uh we have some remote people we have local people i'm stephen farrell this is daniel kahn gilmore okay um you're driving the slides that's the contact he thinks this is the note well i guess you've probably seen that during the week if you haven't then noted well um and you didn't notice we also are all wearing masks today so please do so uh if you're presenting here you don't have to but otherwise please do next slide so this is our agenda um we did a working group last call not probably it won't be the last one um we have a bunch of issues to talk about that that we'd like to get through and if we can reach some kind of resolution in the in the room uh whether here or virtually for those issues that'll be great and then confirm them on the list later so that's most of the meeting today uh and then talk about next steps for the draft then daniel who i don't see in the room just yet has a presentation um and aaron i think is remote is that correct i think erin is remote yeah and so these are these presentations are about things that might happen if we can actually get this draft out the door uh and so we're we're hoping that we can get the drought out the door because we"
  },
  {
    "startTime": "00:02:00",
    "text": "won't be able to recharge her until we do that right so anybody like to bash the agenda looks like not no comments great we have terrorists taking minutes so thanks tara um and we can keep an eye on everyone's chairs okay so like i said we had a working group last call um on draft six just really to see where we're at um because the we had a design team as we discussed last time that was working really hard i think uh in order to try and get the documented shape um if you go to that link you'll find the working group last call issues all the label wglc and what we'd like to do is again go through those here with this highly energetic early morning crowd and see if we can kind of reach any resolution on those and if we can great and we'll confirm it on the list so yeah so the hope is that people can can speak to these issues as they come up uh if you're remote and you're on you know in jabber or zulip or whatever and you want someone to say something to the mic just you know put it in there and say mike so i think we'll just get started um with uh issue 132 which is about padding so i think what we do is maybe we just flick through the issues just quickly then go back to the top sounds good just some of them might kind of tease somebody up to go and click a link yep so so the reminders here this is about whether the padding package should have uh all zero content random content or some other uh scheme uh question about what do we tell implementations to do if they receive aead packets and try to decrypt them and get a failure issue about whether we include gcm in this draft or not question about whether we use hkdf to bind keys to the modes in aead"
  },
  {
    "startTime": "00:04:04",
    "text": "i'm going to look at what we do with where do the certificate-wide parameters like algorithm preferences and things where do they live in an open pgp certificate are they in the direct p6 as the draft currently says um the whether we continue to disallow the revocation key sub packet for v5 keys or whether we want to roll that back um are we okay with the changes to the iana registry right we've the ayanna register the draft currently says that we're moving everything pretty much from almost everything from rfc required to specification required which is a looser requirement to register things in the registries um do we believe that the text on argon 2 is clear do we have sufficient guidance there is there anything that can be cleaned up and how should we handle uh problematic keys that we've been seeing in the wild there's been some reports about some fairly popular keys that don't conform to any of the specifications including rfc 4880 and should do we need to update the text to handle it better do we need to modify the spec for v5 keys to not have to worry about this kind of failure in the future and then the last question i think is about how we want to you know if we can get through these we get a new draft out how do we want to scope the process going forward do we want to say okay when the new draft is out if it handles all these things the way the working group agrees can we just look at the the changes going forward the diffs you know so that we can minimize the overall level of churn that that um that happens on the next phase hopefully the next phase of the working group last call so that's the that's the queue of issues that we're looking at i'm going to pop back to the first one um so we have some time to discuss each one uh but hopefully that gives you a flavor of the types of stuff that we're that we're asking for"
  },
  {
    "startTime": "00:06:00",
    "text": "um if you pull the slides from the data tracker the meeting agenda you get links there to go to each of the issues and we'll pull up the issues here as well during discussion so heading back to issue 132 about padding we have this padding packet um uh and the question for the group is what should the content of the padding packet be uh we've had different people with different perspectives on this uh on the list we've had a couple different variants in the in as this evolved through uh through git the status quo is that the padding packet should be uh full of random octets um and there's a little bit of guidance about where to get the random octets but there's been discussion on the list about whether we should revert this and we have a couple different merge requests that actually offer different ways uh to handle it so i wonder whether anybody wants to speak to this um either in the chat or um or here at the mic if you nobody's been in the queue yet to get in the queue if you're in the room please use the uh meet echo light thing and click that ray's hand so quinn is remote the mic is low so okay sorry about that uh can you hear him is this better quinn i see php in the queue for padding he's here local well basically if you can i think the simplest way of disposing on any item is if you can find a security reason if you put zeros in well you've got some known plain text and that gives an attacker some leverage that they otherwise wouldn't have if you put random in then you have created a covert channel"
  },
  {
    "startTime": "00:08:01",
    "text": "that can and will be exploited so i don't think that so a rigid construction based on something that is to do with either the the that is to do with uh something generated from the key but through a different kdf or whatever seems to be need to be the best solution because then you don't give chosen plain gnome plain text and you don't give a covert channel thanks phil does anybody else want to speak to some of the trade-offs there sorry about this and i believe this was brought up on the mailing list as well and people were a bit worried about the resources it would take to do this new hkdf or whatever to to get this random data yeah and i think that for this issue i think we had two merge requests right yeah do you want to do this screen share or uh sure let me see if i can figure out how to do that again uh i will unshare screen share this so i think for this one we had two merge requests one basically was saying here's this deterministic construction uh and i think the other one says i forget what you ended up saying last one of them says it should be it must be all zeros and the other one says it should be this determin it should be a uh so 204 is all zeros 203 is deterministic along those lines yeah i was meaning deterministic not a hard yeah yeah um but then there is the the 203 there are two variants of deterministic one of which was always the same deterministic data but i think that goes back to phil your your known plain text argument yes you only need to change the data really slightly to take away the"
  },
  {
    "startTime": "00:10:03",
    "text": "uh you know to take away the leverage yeah and i think the other point that came up in this discussion was with the deterministic one you could ask implementations to try and verify that it was done correctly or not bother um so that was the other kind of flavor of this right so the receiving implementation needs to know what to do and i guess we have this question of what what would a receiving implementation do when receiving one of these things that's supposed to be deterministic but isn't um like should it reject the packet stream uh do we what are we what kind of brittleness are we willing to incorporate in order to defend against this particular covert channel so i guess our idea here was that we'd let people talk to these issues to till the you know they're happy and then probably try and get a sense of the participants kind of opinions via a poll so i guess i should try and figure out how a polling tool works um i think for this one probably the easiest thing to ask is should we have zero uh i think the random padding is nobody's that keen on random right which is what the current draft says i mean i think i think obviously some people were or wouldn't admit it into the current draft but just from the discussion i mean if somebody wants to speak to the keeping the thing as is that would be good but maybe maybe the question that you raise is a better one to put as a poll right sorry justice says he's keen on random okay um well maybe the question that you pointed out is is a better one to add to the poll which would be um oh i see aaron in the queue erin do you want to speak um yeah i also think that um like there are many many ways on open pgp to put in some side channel like to put in some"
  },
  {
    "startTime": "00:12:02",
    "text": "cover data just adding a packet that is an unknown version or an experimental and and therefore adding random i don't think is that much of adding like it's not adding that much to the copper channel in openphp so it seems like one one question is do we want uh receiving implementations to reject padding packets that are considered to be malformed right because that actually would govern whether what like are we are we making a requirement about what what goes in it or not and we can make recommendations about what to put in it but there is this there is this underlying question of if we make a recommendation and it's not followed um are we going to expect the receiving side to reject it does that is that a reasonable question or is that is that queuing up too many too many polls yeah so perhaps i just started a poll with should we leave it as the draft has it now as random random is recommended i think random is currently recommended and there's a step there's a separate discussion about what you know this kind of randomness is probably the least important randomness of of of all of the kinds of random there's a section about how how do you generate randomness in open pgp and it calls this out as a as a distinct flavor from like key generation randomness okay so i think what i'll do um daniel's in the queue here justice is also just justice was saying that the design team member is often expressed opinions in the tracker he feels like repeating them doesn't add anything new what should we do please please do repeat opinions justice and send audio or text as you prefer um because i think we'd like to have the discussion until it's on the record for everyone and and we can try and resolve it yeah so i don't actually have uh an issue with random data in the um panning"
  },
  {
    "startTime": "00:14:02",
    "text": "packet the only issue i have with the current text is that it suggests that the random data protects against um higher level compression uh disguising the let's say padding or sorry uh negating the padding so in my opinion it doesn't because the compression will compress the non-random padding anyway and will reveal information about the length it has so i'm fine with leaving it random but just removing that uh text but yeah okay so so have a tougher question yeah okay so what i'm going to do is i want to try one of these polls because you know some of these issues are things where people have opinions but don't necessarily feel hugely strongly so i'm going to ask do we keep the draft 006 random padding scheme and so i'll start the session if you think we should keep it please click the raise hand button if you think we should change this then please click the do not raise hand button and we have 36 people in the room so nine hands being raised or not eight eight and one okay it's not changing so um just for the record there for the audio record there we got eight hands raised and one hand not raised which i think indicates that we probably should go back to confirm on the list that we it seems like keeping the the current scheme is what people want okay okay okay so pkg is gonna i'm gonna put that in the notes um in the issue yeah let me"
  },
  {
    "startTime": "00:16:02",
    "text": "just copy the specific poll on eight to one um so uh let's move on to the next uh the next issue here how do i get rid of this i think i dismissed it no i don't know it's up there uh okay so the next issue here um still up there oh wow this is this uh the switching between the slides and the okay i found the button i'm done okay great so that's that's our okay so this one i think well yeah actually i think i actually understand this one that's that's that's helpful so this one here when we're using aad algorithms and you decrypt the issue is what's how to handle that we have some chunking so that these decrypt failures don't necessarily apply to an overall message and currently i think the text in a few places says that if you get an aea decryption error um there's a should fail kind of statements and i think the suggestion for this issue was to change those to must fail instead of should so again we'd like to get a sense of i don't think we have a marriage request for this order uh we do okay so that there's a merge request for this one you can if you click through the links you'll find the suggested change so do we want to offer i just realized there was one person who was sort of odd odd person out whose hand was do not keep and do we want to on the last poll do we want to ask that person if they want to okay okay your and your but your opinion"
  },
  {
    "startTime": "00:18:00",
    "text": "was that we you would be okay with keeping it if we remove the justification got it okay okay that was that was danny hogan's record um yeah that was a good thought okay so for this one um there was some discussion i think mostly it was kind of in the in the affirmative like saying that that change would be a good one i think so would anybody like to speak to this rather remotely or locally if not i think we'll just do another poll say make the change or don't make the change just give people a second what's the merge request number for that one do you know uh yeah that uh oh it's actually not linked sorry it's actually not linked i'll pull it up okay 206. and i can put that on the screen if i would help people should i do that well i think this one's kind of straightforward enough just a poll i suspect okay so i started poll saying should we make this change uh to change the kind of showed statements about how yeah the encryption failure is into most segments if you think we should make the change please click the raise hand button if you think we should not please click the other one that's looking pretty clear nobody wants to speak to it everybody seems to be in agreement"
  },
  {
    "startTime": "00:20:01",
    "text": "okay so that's 15 people raised their hands zero people did not raise their hands so i guess that's not sure if i like this how do we get rid of the thing you go back to this yeah sorry and then do that yeah reopen the voting mode and then the red button ah okay okay great thank you next one uh yeah um sorry we're we're at the presentation here it's still displaying there there we go okay okay gcm so this one had a bunch of discussion uh i think good points are raised on both for inclusion and non-inclusion i won't really try and summarize it but the issue here is whether the current draft includes gcm is one of the aad methods that's defined the issue is that somebody's basically saying we should not include gcm because we have another aad mechanism with ocb we actually have two we have ocb and eax sorry we have two others yeah so um and again there are arguments for and against inclusion of gcm and i think another salient point is that currently with the specification required iana rules if we do not include gcm somebody else can come along and add it next week as soon as we're done um so it seems like the opinions are kind of all over the place but let's let's give people a chance to speak to should we include gcm in this specification now or not and yes i know that we've talked about this on the main list i know we talked about some of the tracker there's kun"
  },
  {
    "startTime": "00:22:03",
    "text": "quinn go ahead i think you have to enable your own audio quinn uh if you've got ocb it's a much stronger incr construction now yes somebody can add it to the ion or add gcm to the iona registry but if i'm going to implement pgp i'm going to implement the algorithms in the draft and i'm not going to accept expect to be able to send mail in a scheme that is not in the draft so not putting it sorry if gcm is not in the rfc it will have a material impact on adoption and it will encourage people to use ocb which is a stronger construct which we all should be using so uh thanks for the reminder for the clarification ocb in the draft is flagged as must implement and eax is not flagged as must implement and gcm uh is also flagged as is is not mandatory to implement yeah i hear what you're saying about the presence in the in the in the draft but there is a there is a notable distinction between the modes and there is an advertising mechanism that where you can indicate what you what what aed algorithms uh you support with what other ciphers so you won't accidentally encrypt using gcm uh to somebody who doesn't support it and everybody has to support ocb anyway so that that's that's the that's the the baseline part of the interop that the current draft tries to do whether"
  },
  {
    "startTime": "00:24:01",
    "text": "whether that's right or not or whether that's useful so but it sounds to me like you're speaking against including gcm well i i think you can make a case i mean gcm is a stream cycle why turn a block cypher into a stream site yeah quentin do you want to go ahead quinn you have to turn on your own audio here i'm not sure if that's if that's not working for you or if you want to put your what you're saying in the chat we can relay it to the mic as well enabling your audio is the the it's a button in the um it's the microphone button upper left are you hitting me now yes we are thank you thank you i'm sorry about that um so right now gcm is not a mandatory to implement or mandatory to however if there are people who want to use tcm then you know i i i don't want to tell them um so make them to be non-compliant to uh that they uh they need to um you know really really does that we should we should do that that's something that we should do um"
  },
  {
    "startTime": "00:26:02",
    "text": "tcm but um it's still good in um in some cases um so so that's why i think um it's okay to to make tcm is not a mandatory one but thank you quinn do you want to talk to what you think the reasons are people might want to use it uh so uh"
  },
  {
    "startTime": "00:28:03",
    "text": "great thanks guys so yeah that's that yeah you're clearly asking for essentially the status quo with the draft which is to keep it as an option uh paul paul speaking as an individual um i don't think it matters very much where tcm is fine pirates in this rfc and another one the people that are going to use it are most likely the people that need to be fips compliant and they have no other choice at this point so um those will need to implement these things anyway whether they're in a separate document or in this rfc so i don't think it matters where it is but but as as the people who want fibs have no other choice at the moment they will they will do this anyway so um so so i i did yeah i don't think it's much of an issue where it is defined so but i i would personally recommend just doing it uh with the group so that we don't get somebody else by their own uh writing specification for gsm thanks paul hi jonathan hamill canadian center for cyber security so i i'm in favor of including gcm um while we don't have requirements for using uh fips validation it is our guidance because because it does provide implementation validation it's not just a policy it provides a security benefit that the implementations can actually be tested by an independent lab and and that's why i would like to see it included daniel howkins uh with openpgp.js maintainer hats on uh all acknowledge that our requirements are uh somewhat peculiar but the reason we want to use gcm is because it's in web crypto it's the only aad mode in in the web crypto api at the moment which is you know natively implemented in browsers and um gives much better performance so yeah we'll most likely"
  },
  {
    "startTime": "00:30:00",
    "text": "implement it uh whether it's included or not indeed not for fips compliance reasons but yeah for for performance reasons and uh we can either do that under a private algorithm id or you know in a separate document or in this document but yeah most likely we'll be implementing it anyway or ori steele um from transmute i agree with everything he just said i probably would get support for it if they were to implement it anyway but i think for the the reason stated you know regarding um fips and the expectation um that i think users will have that there will be at least one sort of fips algorithm that would be available um i think it should be included thank you so ben cadek from remote uh ben kadek uh so i feel pretty similarly to paul and that you know this is gonna happen and you know having the working group do it sort of lets us retain a little bit of control i don't have a particularly strong preference at all but i have a slight preference that like the working group would specify gcm but in a separate document but if we keep it in this document i can certainly live with that i know that there are definitely going to be some cases where people need to use gcm because of the fips requirements and so having us use our expertise to make sure it gets well specified and there aren't any gotchas with it seems preferred to having some random person write it up uh in a hurry when they need it but again whether that's in this document or a separate document in the working group i don't really care okay thanks ben and the queue seems to have drained on this one okay so how about i'll do a poll saying keep where the question is keep gcm as"
  },
  {
    "startTime": "00:32:01",
    "text": "an option as per drop six yeah and so if you raise your hand you're arguing to keep it in the draft and if your hand is down you're arguing to that it should not be in the draft whether that means it should not ever come in which is going to be difficult to do or whether the working group should work on it or something else if you feel that way you can say do not raise hands so i figured this one would actually go all one way or would be 50 50 but uh this is the better option okay we seem to have stabilized with the 14 hands raised asking to keep gcm as an option as per that six 15 hands raised now and no hands not raised so that's i think that indicates preference that again we'll confirm on the list yep and i'm noting that in issue 135 as well great thank you uh so yeah we can ask what the zero people if they want to stand up and explain why they are already there okay okay so uh so issue 136 is uh a little bit uh trickier uh so uh the way that we have aead specified in draft o6 uh uses an hk uses hkdf as a key derivation function which pulls in a chunk of metadata uh including the choice of mode so that your key can't accidentally be reused across modes if if someone is tampering with the um with the construction that you have uh there's some concern that key reuse across different modes uh uh could lead to some kinds of problems"
  },
  {
    "startTime": "00:34:02",
    "text": "i believe there are maybe other arguments for why to use the hkdf as well uh but there the the issue raised on the list was hkdf isn't is an unnecessary additional construction to include here and maybe it would be simpler if we were to remove it this is again it's issue 136. um so i'm wondering whether folks would be up for speaking to this again i know that we have had discussion on the list about it i know we've had discussion in the data in the issue tracker about it but uh we would like to have that discussion here in the room if we can anyway so um now's a good time to to state your your opinions and preferences here yeah so the most uh specific issue uh that i know of why this was brought up was there was a paper where gcm ciphertexts could be converted into um for example ascfb ciphertexts and then if you have a decryption oracle for cfp which has happened in the world then you also have a decryption oracle for gcm which basically means that the the security of the gcm mode then gets reduced to the security of cfb which is bad um so i mean in general i think um not being able to convert uh keys and ciphertext between different modes is good but yeah so that was the most um specific issue that i know of so if we're keeping gcm then i think we should definitely keep this as well thank you daniel uh juices i see you in"
  },
  {
    "startTime": "00:36:00",
    "text": "the queue so i want to stress that this is not only about gcm this is about preventing downgrade or cross-grade attacks and openpgb has suffered from across a downgrade attack in the past so this is just a good belt and suspenders approach and i'm for keeping it you're there you says do you want to mention the other reason i think you that you've advocated for yes so the other kind of feature we snuck in there is that we have assault in the site d version to it and the idea is that if you get an encrypted message and you don't have the sender certificate that you can reuse the asymmetric key material and just change the saw to derive a new message a new per message key from the from the session key [Music] so that makes it uh like a reply it makes reply functionality when the keys are not available uh a possibility yes that's correct [Music] anybody else want to speak to uh the how they what they feel about the hkdf in this [Music] in this context i guess no i guess nobody else is but i think the argument against essentially was that this is a change and change before you know change is not necessarily always good that's i think the argument was against you but i don't see anybody else in the queue uh should we do a poll on this as well so it's going to say keep hkdf as per draft six and first question okay"
  },
  {
    "startTime": "00:38:00",
    "text": "that seem okay folks in the room okay with with that being the poll text keep hkdf as per draft oh six this is hkdf uh in a for aead i mean there are other places where hkdf shows up just uh okay so our last the poll will be key page kdf for binding modes as per draft six and you can raise your hand if you think we should and do not raise your hand if we should kind of revert that change and again do not raise your hand means actively clicking do not raise hand you can't just sit there it's always confusing exactly to seems we seem to be attracting one more opinion every time we do this that's great oh two more okay so that seems stable and pretty clear we get 17 hands raised to keep hkdf for binding as per draft six and zero hands not raised and we'll close that hole and go to the next one all right and i'm putting that in the issue tracker as well thanks folks uh issue 137 questions about where certificate-wide parameters live so certificate-wide parameters meaning things like your algorithm preferences uh things like the revocation life the expiration lifetime of your primary key which is by default the expiration of your entire certificate um the current draft o6 says those parameters for v5 keys specifically those things should live in sub-packets of a direct key signature on the primary key in v4 the tradition has been that those things could live either in a direct key signature on the primary key or in the user id sub the self signatures over user id sub"
  },
  {
    "startTime": "00:40:01",
    "text": "packets so the current draft says for v5 keys don't look for those things in the user id self sigs just look in the direct key this makes it a little bit more predictable i think was the rationale coming from the design team um and real and a little bit simpler uh to consider what's happening um but it is a change from v4 uh and uh so it makes v5 certificates look slightly different it does not actually the draft does not change v4 certificates if you're going to implement v4 and v5 you will have to have the complexity for dealing with v4 certificates anyway so the question is do we want to allow these parameters oh and then i guess the other wrinkle to this is there's some amount of concern that by putting these parameters in the primary uh in in a direct key signature on the primary key it might facilitate you uh certificates that have no user id because now you just you've got the parameters they're all there and you can just go ahead and leave leave the user ids out and as from from several generations of the draft the user id has been moved from must have one to zero or more user id so there's some concern that this demo this uh provides some pressure against user ids or pressure towards user id list certificates so uh so those are the concerns that are sort of bundled into this question um i wonder whether anybody wants to speak for either for the text that's currently in the draft for v5 certificates or against it um i see ben in the queue so i'm not actually speaking for or against at the moment but uh asking a question in that in the v4 setup where you can have preferences at a per uid level do we have any reason to believe that someone was using this for some complicated setup where they have you know multi-uid key"
  },
  {
    "startTime": "00:42:01",
    "text": "but they have like different implementations on their mail reading setups for the mailboxes that receive those different uids and somehow they wanted to express diversion preferences based on the different implementations uh that could process things specific to that uid as opposed to you know i have this key it's in multiple locations uh or maybe it's only in one location and i just can handle what the key has like do we think people use that flexibility in that way i mean it is explicitly contemplated in rfc 4880 that this is you know it says like if you look this key up by user id atlas then use the preferences from user that are bound to user id atlas but if you look it up by bob then use it for user you then then use the preferences found on on bob's self sig i have not heard anyone say that they are using it like for themselves i don't know that anybody's done a survey of keys to see whether some you know how many of them have different preferences per user id and i also don't know whether anyone's done any testing to see whether implementations that are sending actually respect that because the how do you know whether you're accessing the key via alice or bob maybe you've done some binding that says when i send to alice use this fingerprint or something like that and then from the openpgp implementation it just sees you passing the fingerprint and doesn't know that you're looking for it in terms of alice so i don't know that we have that much data about whether it's been used there certainly has been nobody stepping up to say if you rip this out i'm going to be sad because i have two user ids that i expect to have divergent implement you know divergent parameters and and i want to see those things present so i i i don't think we have much data but we definitely don't have anybody standing up publicly and saying i'm using this that has not you know nobody has mentioned that on the list okay i guess that puts me slightly leaning towards uh keeping it just in the direct keysig and"
  },
  {
    "startTime": "00:44:01",
    "text": "so i think i think i can imagine uses for your id less keys as well but that's not quite the question being asked yeah so i think on the list in the discussion verner was kind of opposed to this change because he he wanted it always to be a user id is that correct uh right but we could mandate a user id without this change also but that would mean one one additional uh signature in a certificate because you'd have to have the direct key sig for the parameters and then the user id binding stake okay so i mean i think the question about this is like what are you thinking about for you know v7 or v8 because it sort of signals a direction you're planning on taking like you mentioned you know if you have to support v4 and v5 you're going to have to account for this anyway but in future states where you're supporting v8 and v7 after you know years of this change this could be a lot simpler and i am also in favor of not requiring you user ids so that's that's my thoughts thanks yeah i was also gonna say regarding uh user id less keys it can also be seen as an advantage that this allows that there are some use cases for not having a user id for example if it doesn't have anything to do with email or if let's say you don't want to publish the user id in some contexts uh on on wkd or something like that or if you have a catch-all address where you want to serve some key for many different email addresses and you don't know in advance which ones you want to serve it for so and you don't want to keep the private key on the server so you can't generate a user id on the fly then i think it's useful to be able to serve"
  },
  {
    "startTime": "00:46:01",
    "text": "a user id less key so i think that this change allowing that is a good thing thanks daniel useless i think you're up so i also like user id less certificates um but i want to say to ben's question if someone has such a use case they are better off having two distinct certificates and the complexity that comes with having having the preferences on user id bindings is huge and the behavior of implementations is basically unpredictable and it also complicates stuff like simply adding uh adding a user id because adding a user id now potentially changes the preferences of this certificate so you better find the current binding that you think is the most recent one or so and use that as a template and the the fact that simply a simple operation like adding a user id potentially changes the behavior of your certificate or the preferences is insane okay i think we seem to have drained the queue and this is all the last of the poll again and this time it's essentially as was on the slide uh it's certificate right parameters live in a direct key sig for v5 and should we keep that as per draft six so i'll start the session if you think we should keep it please raise your hand if you think we should revert that change please do not raise your hand"
  },
  {
    "startTime": "00:48:07",
    "text": "we've lost some people from last time yeah it's a more complicated question being on the fence on is probably more reasonable on this one so we have a software it seems to stabilize that eight hands raised and zero hands not raised which is an indication but i guess again we'll confirm on the list and if somebody does turn up with some use case as ben kind of indicated then we might have to revisit but for now we have an opinion that's good okay noting that in the issue tracker as well um okay uh so issue 138 um in so in rfc 4880 we have a sub packet that indicates that um the that the key holder is willing to accept revocations from a third party this is the revocation key sub-packet it contains a fingerprint of the authorized revoker in the draft we say that the that this sub packet is invalid for a v5 certificate um and we describe an alternate mechanism for doing a sort of delegated revocation which is just to make a revocation signature and send it encrypted to uh to the person that you're willing to have be able to revoke your key uh that mechanism is is available obviously to anyone with v4 keys as well um it's not a novel mechanism but it's the first time that's been described explicitly in the draft the question here is whether we want to keep this revocation sub-packet can you continue forbidding the stratification key sub-packet for v5 keys some of the reasons arguing for the removal"
  },
  {
    "startTime": "00:50:00",
    "text": "are that given that it's just a fingerprint you might not even have a copy of the key and you might see a revocation and not know whether it belongs or not so there's an issue there's a logistical issue and secondly the implementation support for the revocation key sub-packet may not be as universal and robust so relying on it seems a little bit dangerous compared to relying on an actual revocation signature so i think those are but the concern here of course is that it's still valid for v4 so your implementation that does v4 and v5 will have to do both um and some people say that this is actually a concretely useful thing to have and they they want to have it available for v5 and they're not comfortable with the escrowed keys so hopefully people can ask clarifying questions if you got them or speak in favor of the removal for v5 or speak in opposition to it uh that's a good chance if i if i mangled that explanation of the of the um of the problem i hope people will correct me as well uh ben hi ben k duck so i can imagine a scenario where the escrow revocation signature has like a setup that is more risky than the revocation key sub-packet and that would be if the receiver of the escrow has some system that like does automatic processing on messages it receives and would like automatically decrypt it to put it into some other internal store and maybe that other internal store also automatically update some things so you could get into a scenario where the the mere fact that this revocation signature exists cause it causes it to get uploaded prematurely um"
  },
  {
    "startTime": "00:52:01",
    "text": "when it wasn't intended to be it was just like i have some data it's associated to this key let me publish that type thing uh and like this is seems pretty unlikely to me um and i'm not super concerned about it but it is an additional risk of this proposed mechanism that you know i don't know if we've talked about before i don't remember thanks i think that's that's a that's a valid point there um the original removal here was uh was accompanied by a proposal for a replacement for the revocation key sub packet that actually included the revoking primary key the the the the key material of the revoking of the delegated revoker and that was seen as uh either too complicated or out of charter or too distracting um which is why we're in this in this uh removal phase um that's where that's why this is it the proposal is where it is here um that would solve the logistical problem um and it also potentially solves the uh i guess a linkage problem use this you want to speak to it so uh i'm in favor of removing that because it just acknowledges the fact that virtually no implementation supports designated revokers and i think that's due to the fact that it requires non-local reasoning about uh multiple certificates can you talk to how you look when you say uh you know you're maintaining the interop test suite can you can you speak to the support i mean you said it's that few implementations support it can you describe like the test that i don't think we have a test for that sadly um we should have one um but we we didn't implement it because it"
  },
  {
    "startTime": "00:54:00",
    "text": "it uh it was very complicated so uh i i doubt many uh implementations out there supported maybe daniel can shine some light on his implementations thank you yeah so we also don't support it um personally i'm not opposed to the idea of including the revocation key in the in in the subpacket directly that would make it much easier to check the revocation signature if there is one at the cost of a slightly increased key size but i think that's reasonable so i mean yeah we can argue again about whether it's in charter but i think if we're removing it here which i think is reasonable then i also think that adding a replacement is reasonable but um i'm also fine with just removing it and without a replacement other than having um a revocation certificate which is already a mechanism that exists and is used and we already support it also in before so i think that's reasonable also uh ben kadek again uh thanks everybody for the extra discussion i think that has sort of solidified my thinking that um in favor of removing the verification key sub packet for the v5 keys that's just like acknowledging the deployed reality that you can't rely on it to work uh seems like something that's really appropriate for us to do in the biz document and so i i would like to see it that way i'm okay doing that even if we don't have a replacement mechanism specifically i would also be okay as"
  },
  {
    "startTime": "00:56:02",
    "text": "daniel is with uh having this mechanism for like the actual full verification key in in the key because like the the size issue is on the issue if you if you actually use it and so if you don't use it you're not affected but i'm also okay just uh removing this and and not providing a replacement right away thanks ben i think the queue may be drained on this one looks like it shall we do it for okay so same as before it's the question of the slide so the revocation key so packet is disallowed for v5 keys in draft six should we keep that if you think we should keep it as draft six please raise your hand if you think we should not then please do not raise your hands and that seems to have stabilized and then as then it moves so okay so that seems to stabilize that uh 10 hands are raised to keep the scheme in drought six and zero hands are not raised so that's good input so the next one is kind of a slightly less slightly easier one to get your head around so this is iana so in 48.80 there's a whole bunch of viana considerations and registries and registries that's that's to require ietf consensus for change and the suggestion in most cases is not not absolutely everywhere but in most cases the the draft six basically changes those to specification required and for those of you who aren't who are not iana nerds um that the impact there is we're moving from a situation where you have to get a"
  },
  {
    "startTime": "00:58:00",
    "text": "document through the ietf process to do things like add support for another algorithm and we're moving to a scenario where somebody can just say oh i have a i've written a paper and i published it and can essentially ask an expert to be designated by the isg should the algorithm get a code point in the iana tables so that's where the draft says we're going that's where we're coming from and the two exceptions there that remain rfc required are uh packet type and packet version so the places where the versions show up are still requiring rfc and the and something a new packet type is also so i think it requires ietf consensus igf consensus sorry because an independent stream rfc doesn't have that so so yeah there's a couple of exceptions but but the the basic movement is towards uh allowing specification required which is kind of loosening up things a lot of other groups have done this over the years but it's worth checking because for example it means that you know a vanity cypher code point could could end up their national algorithms would connect can end up there which may be good or bad so the question is do people have opinions and should can we confirm that that change is kind of a good idea we should also note that this will require having a designated expert there are already uh there's already one registry that requires like the expert who does not exist okay so this puts even more weight on that non-existent role yeah digital community so yes actually uh designated expert is needed and i think it's it would be very useful to keep the instructions of the designated expert what kind of you know specifications are do we we probably want to have some kind of stable reference you know published you know some other standards or organization paper not just on some webpage somewhere so you usually and usually dressing experts have quite are quite free to actually you know"
  },
  {
    "startTime": "01:00:00",
    "text": "interpret the instructions they are given so we don't have written very specific instructions just say that okay destiny the expert requires a stable reference and he decides what is stable enough for him his point of view so just while you're there do you do you have a an example of some specification that does that well that you can remember no okay i think most of the most of the rfcs are you know for for those are obviously the time for example expert i think they actually just say that they're expert there's actually no specification required but i have always as an expert required to have a specification before i actually go forward and say okay you have to have a three p three gpp for example specification is is okay some webpage i will say okay i don't know if i would want to allocate you know numbers based on that ah pancada i actually got to make basically the same point the term made about we should have some guidance to the experts uh but i do have an example of a case that i think does this pretty well i'm actually the sort of ghost editor for the cozy uh drafts that are in all 48 at the moment because jim is no longer here to to do the authority himself and so we have some text in there about um the expert is designated an expert as a reason because we should trust our expertise and give them leeway but also guidance about the proposed mechanisms or algorithms need to like actually be appropriate for the requirements of the registry that we're trying to use like if it's supposed to be a signature algorithm it has to actually provide the signature functionality um and i think there's also some some guidance there that it needs to meet the community requirements for security so like if somebody wanted to prove so null security and a null sequencer algorithm essentially if it doesn't meet the requirements of the community if there's also some pointers to like cfrg is a good resource in there um and in addition to sort of answering the"
  },
  {
    "startTime": "01:02:02",
    "text": "question that you asked of tarot i wanted to also say that in general i do support this i think in other areas like uh tls and i think ipsec is actually in the process of doing this as well you know opening up the registries to make it a lower burden is good for the ecosystem i guess i also wanted to mention a counter example in the sense of the expert is not given very much leeway and i believe the quick registries the policy is basically a shell issue policy and expert is there to like apply some back pressure if somebody is asking for a lot of code points or something like that or if they're asking for a specific code point that might be problematic but the the guidance to the expert is basically you've got to approve this can you can you send to the list a pointer to the specific draft that you think has good text the cozy draft that you mentioned uh sure or in the chat yeah just just so we have a note that we can use to update it yeah i'll drop in the chat for sure and i will try to remember to send an email as well okay thank you ben so i'm a editor maintainer of a registry that was recently opened up in in this way and i think it is a positive uh thing uh that's happening like you mentioned it's sort of trend in the space but the guidance to those maintainers is critical and if you don't give good guidance to them you open huge political cans of worms for them and they're likely to resign so you ought to just yeah just make sure you give them good guidance and i also think it's important to support the sort of mental shift that goes along with this kind of process as a community"
  },
  {
    "startTime": "01:04:02",
    "text": "um because if it's happening it should be supported by the community um so have have a designated expert give them good solid advice um and then cheer for them while they handle the onslaught of registrations are you can can you point to guidance that you have found useful in that position sure i can i'll i'll send it to the list but i may have to get connected offline yeah that would be very that'd be very helpful thank you did you actually experience an onslaught uh yes but for a registry that i i don't want to bring up here to experience any challenges great uh and uh roman has post and then have posted some more about that closely stuff in the chats so i think we've trained the queue on this one so i'll ask the question like this so if you're happy with these changes but we should also give guidance to the designated experts then please raise your hand if you'd rather we don't make that change then please do not raise your hand and that one seems to have stabilized with 11 hands raised for keeping that kind of keeping these changes but giving some guidance to the de and zero hands not raised thank you okay"
  },
  {
    "startTime": "01:06:02",
    "text": "all right so i created this issue yesterday just in response to uh there was some list discussion about argon 2. um and i i think the issue essentially is is that is the text sufficiently clear um so if people have opinions or or have been watching this thread on the mailing list then please do speak to it i'm not sure we'll do a poll on this one i think it's the case of we'll probably just have to go and check but uh yeah and one of the you know one of the ways that we can determine quantitatively if it is um if it is clear is whether we have functioning interop as well i mean use this as the as the sorry to keep poking at you as the maintainer of the interop test suite but uh can you can you report back on how things like whether whether argon 2 um has been tested this is something that might be in the in the lineup so sadly we don't have a test for argon 2 yet but we have two interoperating implementations one of which i believe is canoe pg maybe nib can can talk talk about that uh glue pg my branch support argon 2 because the uh leaf decrypt 1.10 already have argument to support okay so so i think this situation is that we have we seem to have i think miebe did say that it's supported and it's and then justice is saying that it interoperates so that that you know seems to say that the text is not horrible um"
  },
  {
    "startTime": "01:08:03",
    "text": "uh but i think so i don't think this one would have a poll on i think this is one where we should go back and check essentially because argon 2 does have a bunch of parameters clearly one person on the list at least has found that confusing or something so um i think the resolution of this one is we just need to go back and check and see is there something that needs improving yeah anybody else want to speak to argon 2 here and again i'd encourage if people can just have a look at that text and see that i think it's clear that would help i think yeah sorry so i thought there were there was maybe an issue that some people did not want argon to are we not talking about that or yeah so that was i think the person who found the text unclear also [Music] was arguing somewhat against it but i that seems to be a fairly niche opinion as far as i can see but again if people want to start if people want to suggest removing argon 2 then go ahead and do that but i didn't i didn't see a lot of people suggesting that her and it i mean to be honest you know i mean argon 2 seems to be a much better way of kind of string the key so it's also i mean it's the it's the winner of the password hashing uh competition so that was why it was selected um yeah okay so i think the resolution for that one is is again people want to talk to it now that's fine but the resolution there doesn't need a poll as um we need to look at our text just to convince ourselves it's clear and fix if not yeah and if a third implementation could become interoperable or if we could get proof on the test suite that uh that these things are capable of being interoperable then that would be um that would be useful too useful evidence for clarity all right getting through this folks this is good um so second last one yeah we're on the second to last um so thanks everybody"
  },
  {
    "startTime": "01:10:01",
    "text": "for bearing with uh so we've had some reports on the list recently about open pgp certificates that are um fairly widespread and do not follow either rfc 4880 or the current this draft um the crypto refresh because of some changes in some of the metadata that they have um we have two potential uh things that we could do as a community of specifiers one thing is we could adjust the text in the revision to explain a little bit better about what how this metadata should be prepared and to describe what what an implementation should do if it discovers that the metadata has been ill prepared so that's just like documentation cleanup and another thing which we actually have a merge request for is to strip out those pieces of metadata that are are apparently ambiguous from v5 keys so that they simply wouldn't be present in those structures so you couldn't make those mistakes um it might still be worth adding documentation about how to deal with v4 that have those pieces of metadata but so this is these are this is the github key apparently github's key itself has a weird behavior and we've also seen some keys generated by open pgp php that have similar but slightly subtly different misbehaviors around this metadata so what do we want to do about these keys do we want to try to change the draft you want to remove the stuff from v5 do you want to make give clear guidance about whether to ignore if these fields are not set so just describe it as metadata is it not just a checksum or something uh it's a checksum and is there one other piece or is it just is it just the checksum that we're talking about but it's it's not a free form metadata it's not free from table here so there's a there's a there's a checksum"
  },
  {
    "startTime": "01:12:01",
    "text": "that indicates uh you know what's yeah um what has been signed here so yeah i think it's a checksum so okay so this is supposed to be a checksum but the uh something but not include things that are not the checksum oh okay yeah use this you're in the queue so i'm aware of two issues um first there is the the hash digest prefix in the signature packet and the question came up that came up initially was what should implementations do if the 16-bit prefix is wrong and that i think happens with the php implementation and the github key and github p2p implementation has a different problem where they produce malformed multi-precision integers so everybody's exhausted with all this yeah yeah we're close folks so for the first issue i have some one fairly orthogonal argument for removing it entirely which is that if you have a crypto api which lets you hash and sign in one operation then it's it's nice to be able to use that without needing to get the intermediate hash um which uh web crypto does so again it's fairly specific but um i i think that's useful and also if um implementations are not um checking it anyway while some implementations are not then it's it's perhaps not very useful"
  },
  {
    "startTime": "01:14:01",
    "text": "to put it there anyway uh we do check it in fact so i i'm also not opposed to just having some text that says you should check it or something um but if i check it you mean reject the signature if it doesn't match without bothering with the cryptographic outcome yes so would you want i mean do you want that to say you must check it like uh you must reject the signature if it doesn't match i mean one of the problems right now is that we have this we have we have uh heisen sigs right where yeah some implementations uh accept them and some don't so again the only real reason i see for not well two reasons i see for not checking it is one you have such an api where you can hash and verify in one step or well there are keys out there in the wild that that are broken so you ignore the bytes for that reason so i mean both of those would to me speak for either removing it or saying that you you should or must check it and reject the signature if it's invalid um yeah i personally i would slightly prefer just removing it entirely but yeah if we keep it then i think we should check it okay all right again agree with everything he just said it's becoming a bit of a theme yeah if it's there it should be checked if it doesn't match it should be rejected i'm in favor of removing it i'm not sure exactly the impact on the keys in the wild based on that statement but sometimes you make things that you are broken you have to make new ones i i think if we were going to remove it it would only be applied to v5 keys right right we wouldn't remove it from b4 we can't we can't remove it from b4"
  },
  {
    "startTime": "01:16:01",
    "text": "uses so my theory that this is or was once an optimization right you could skip the uh heavy lifting of doing the other metric operation when you can determine from the hash prefix that the signal didn't didn't check out but i want to highlight that we have a bit of a heuristic based on that where we use it to reorder certificates um that are somehow mangled in transport by a key server also and here we can use the the hash badges prefix to see if we can find the correct location for a misplaced signature even if we don't have the full context like the the issuing um the issuing key so i i kind of prefer to keep it or that kind of reordering to include the robustness but i i would be okay with making the check mandatory so if we're going to do a poll it seems like we've got at least two separate issues here and we've spoken mainly to the first one um so maybe we want to try to do a poll to resolve this first one but about the about the two about the checksum in the signatures um what what uh i'm trying to think how we want to pull this right so one of them is i guess should we remove the checksum from v5 and we've heard uses argue against it and daniel i think you were mildly for removing it and then the other question is should we make it mandatory to"
  },
  {
    "startTime": "01:18:00",
    "text": "retrospectively as well for v4 signatures as well and then v5 if we keep it should make it mandatory to reject the signature if it doesn't uh if the checksum doesn't match okay and yeah okay so so two poles one is do we run a remember for e5 and second pole is should we make it mandatory to reject a signature knowing that implementations out there don't currently do that but some implementations don't do that right okay all right yes we asked the question what's your question uh uh the uh signature checksum uh is that fair signature checksum anybody want to propose a different name the question i'm gonna ask is should we remove the signature checks from these five signatures yep okay so should we remove this signature problematic metadata field from p5 signatures if you think we should please raise your hand if you think we should not please do not okay so i'm seeing two people who are in the uh in the do not raise hand and i wonder whether anybody wants to speak to those uh to to why they would prefer to not remove it and just for the record there we had seven people expressing opinion five raised their hands for removal two raised two did not raise their hands um i assume that uh uh aaron you want to speak"
  },
  {
    "startTime": "01:20:02",
    "text": "okay so um i think that it it provides debug information too so like at times it can be very useful to have these two bytes even if we don't check it on a regular basis to understand whether implementation is broken or not or whether the data that has been signed is different like at times you can understand where's the bug okay so the the the three arguments for keeping it that i've heard are uh one it allows you to reject signatures faster uh two it allows you to to um this debugging argument it gives you some extra hints about where the problem might be in the emitting implementation and then three uses this point about being able to reorder certificates more efficiently without doing the heavy lifting of the crypto piece i see use this out of the queue now uh okay so i mean that's input it's a bit that's a kind of rough yeah uh consensus if consensus so we'll again we verify the list and see where we go and then the second poll we wanted was should we should we mandate that implementations must reject a signature that has the wrong checksum in it okay so i think what i'm gonna i've typed is should we state that implementations must reject signatures v4 or v5 with incorrect signature checksums okay so you can see the question"
  },
  {
    "startTime": "01:22:02",
    "text": "and we know that there are implementations that won't do it okay so so for this one we have so currently nine hands raised saying that we should add that must and one do not raise hands so if the person who did not raise their hand would like to speak to that please do so aaron yeah i mean same as before it's the thing is depends what's the use of it i would definitely be in favor but should a must might be at times too hard especially if you know that there are some implementations out there that are broken so um okay yeah yep that's fine we'll take it to the list okay um and then so so then we what we haven't discussed yet is this um uh malformed mpis uh in certificates like the github certificate right so the mpi specification is very clear uh but not necessarily always followed apparently apparently it's not as clear as it could be um it says that the it's indeed it indicates length by bits for some reason and in this situation we have certificates that are uh it's supposed to indicate the the largest bit that is set to one but in this situation we're looking at certificates which contain mpis or make"
  },
  {
    "startTime": "01:24:01",
    "text": "signatures that contain mpis is it signatures or certificates that we're only seeing this in anybody aaron are you still in the queue from last time sorry we're seeing this mostly oh there you go use this so i i've seen it in the signature that github creates for merge signatures but also in the binding signature of the github certificate itself so it's in the signature um okay so so the question is what do we do uh if the if the mpi and the signature is uh uh is malformed in that it indicates it has a larger uh it's basically counting bits by by full bite i believe um so it seems like we should we ought to have some guidance so that we can point an implementation to what they should do about it it seems to me i mean in terms of just leaving it at nothing doesn't seem very useful to me uh i don't know what sort of guidance people would want one is you could tell people to reject a signature another one is you could tell people to clean up the signature uh if the mpi has this particular alternate form um cory so um i'm not sure exactly of the internals but unless there's a way to warn in a softer but very annoying way regarding this i think the signature should be rejected that would mean rejecting all of the signatures that github makes on merge commits yeah so i mean is there a security i don't think there's a security issue here though is there"
  },
  {
    "startTime": "01:26:02",
    "text": "i mean there were there were some there were some odd lengths keys that bleichenbecker attacks work slightly better on if if you had like a 10 25 bit key or something or 2049 but i don't think that has a relevance in this yeah exactly so i then then you're you're up or weird yeah i think daniel beat me to actually getting in the queue uh but i hit unmuted so my understanding here is that for these problematic signatures you can modify the cipher text so as to or will modify the metadata really so as to make it a valid signature um and i believe that that would not really be something that can constitute an attack if you can just fix it yourself i i think that's right what is your conclusion from that though ben are you saying that we should give people guidance that they should fix it uh probably i mean it doesn't really seem like it's it's not like a cryptographic failure on the signer's fault it's just a implementation failure to respect properly and because the cryptography still checks out i think the practical uh like in favor of better interoperability would be to just fix it and maybe complain loudly if you have the ability to do that but uh saying you should reject this just feels like breakage for the sake of breakage"
  },
  {
    "startTime": "01:28:03",
    "text": "i think if we want to say that implementations uh should or must reject it we could do that for v5 signatures and keys but for v4 i also don't think we can for full disclosure open very old versions of openpgp.js also used to produce malformed mpis in some cases particularly if there were leading zero bytes so it was a slightly different issue than this one but uh still i don't think we can be super strict for mpis and v4 signatures but for v5 we could if we want to use this europe so my concern is that if you have a system that is composed out of multiple components and they use different uh implementations and they behave differently you may be able to confuse the system as a whole where one of the implementations would say it's a valid signature and the other one may think it's an invalid signature and that may be able to create problems so i think you know uh the issue that some github or somebody getter signatures that are wrong is not really issue in that case because i think they can fix their you know signature generation faster than we can get the implementation to check these you know signatures well those they they have old signatures that are that are there yes that the old signatures are are there that's that's true but"
  },
  {
    "startTime": "01:30:00",
    "text": "actually as i said uh i don't know if there's actually any way of you know like somebody was saying it would be really nice to get warning and that's actually one of the things that's been saying that we could actually fix it in in before we actually keep it so we could actually have an implementation actually reacting the signature and then checking that if it's actually oh it's a signature that is if we fix it it actually works that would actually allow you know user interface or or programs to actually way of you know having a separate method of or or the other thing is to that's just reacted on all four for version five but actually the most important thing of course would be to get you know the people who are doing this to fix them so if unless you start reacting them i don't think this hub is going to be is this still generating those signatures i believe it is but i i haven't tested it today so i i think because they don't see any reason to change until somebody actually starts breaking things and i think we should it would be better to have you know not to have this kind of corner cases because they usually have as as was pointed out if you have an implementation that actually checks this another one that doesn't and it might be happening very low level in in the you know you know crypto library your crypto library might be saying oh no no this is not an mp probably nbn's because it doesn't have a first bit uh you know one and and then you might not be able to have to react it in that that might cause you know you know this kind of issues that some you know one part that was supposed to do something based on this and toss it because it's well it's signature other one doesn't because it's invalid signature so i'll share some sort of similar practical experience from handling um ac dsa signatures for the second p26 k1 curve there's upper and lower s representations and the bitcoin ethereum communities have decided to normalize to lower s yet open ssl and other libraries"
  },
  {
    "startTime": "01:32:01",
    "text": "produce both upper and lower s some implementations will fail to verify the signature some won't and in practice the way i've defended our our source from this is to manually lower the signature to low res before emitting anything you know outside of our library so for the for the libraries that are handling this they could decide i'm every time i see this thing that's a problem i'm gonna fix it for myself but it's everyone has to decide to do that and it's like mess in the code you know so i think for five it should it should error and for four you should you should leave it as is uses so the idea came up to just issue a warning i don't believe that there are libraries out there that have a suitable interface to create warnings and even if they did it's not clear what an application should do with the warning if they display that to the user i i don't think that that would help actually also i'm not sure if you should make an exception for v4 it was it was wrong for v4 before that's nothing new let me add one additional wrinkle here which i believe openptp allows you to make signatures over signatures and that means that fixing a signature by twiddling the bits in the mpi header will change the uh bitwise by wise representation of the signature which means that that will in turn invalidate any outer signature that is made over the uh over a signature itself so for example um and if we're talking about mpis generally twiddling the bits in uh the mpi of say"
  },
  {
    "startTime": "01:34:02",
    "text": "a public key will actually change the fingerprint of a certificate which is not insignificant so if we're doing guidance we need to think about the guidance about mbis for signatures maybe distinctly from the guidance for mpis in public key material otherwise you have two separate fingerprints for the same public key it's a mess yeah i think if you're fixing this it's at a very low level in your code right okay um i don't know if we're ready to kind of do a poll on this i think maybe we'd be getting him could we get a volunteer to do a produce a merge request i don't think we have one right now no that would be great right actually so yeah so would somebody be willing to try and write uh merge requests to to propose something that seems reasonable to you because based on this discussion yeah we've we've had we've had a lot of different perspectives coming in here and it's hard to see what the right outcome is maybe if we had um i see a hand raised can i fantastic thank you diane okay so i think that's probably where we should move on from that one i think the very last one and then we have some presentations for for amusement um so so i think we've made good progress we've confirmed on the list the question to people is uh we've got to have six let's imagine that draft seven or eight or something includes the resolution of all these issues that we have so far we'll probably want to do another working group last call at some point uh do we want to raise the bar for that for future kind of work uh to basically ask people to only really be looking at the diffs from let's say seven to eight or eight to nine you know if so if somebody finds some uh some new facts or or comes with some new information then we'd have to look at"
  },
  {
    "startTime": "01:36:00",
    "text": "things but should we raise the bar to try and get ourselves done um by essentially encouraging people to only look at the diffs beyond you know from seven to eight or whatever draft actually resolves these issues paul uh paolo does a.d um speaking to a former ad stefan uh is can you do that as a process i think not right like we do work a group last call it goes over the entire document yeah but it's an expectation matter so and yes it has been done in https for example but if someone does it anyway against your expectation what are you going to do with that information like are you going to then say do you actively ignore it on the list because no no we think you do you deal with it but it's ok it's a question of you know if we if the if the working group and i think so http did this a few times um they basically agreed that they would they wanted to get stuff out so they were they were asking people to look at the divs if people look at other things you've got to deal with it but i think we can do it if people want to do it so um nobody's in the queue that may indicate a lack of enthusiasm or it may indicate fatigue after an hour and a half of yeah sorry for these things okay so uh for this one i'll i'll bring it up on the mailing list oh okay thank you ben sorry you you called so passionately for people to be in the queue uh ben kadek so yeah i think it's it's probably worthwhile doing this uh and to sort of paul's question you could certainly frame this as saying we did a working class call on this previous version and we believe you after whatever evidence that it has consensus and so bear in mind is reviewing that we have a presumption that this other stuff already has consensus and so focus your review on these changes uh would be most fruitful but as stephen"
  },
  {
    "startTime": "01:38:01",
    "text": "says of course if somebody does come up with a real issue even on text that has been reviewed already if you do need to handle it you don't just ignore it okay so yeah we're we're all tired of issues so uh what i'll do is i'll um i'll raise this on the list when we think we've got a next draft house and we'll see how people think about it then so there's no poll for this one i think that was yeah that was our last steps yep so um we have uh so we are not chartered to do work beyond this crypto refresh uh but there has been interest expressed uh on the mailing list and and here at ihf 114 about potential for rechartering we are not going to discuss rechartering right now but we have two proposed presentations about some material that might feed into a rechartering um so if folks have other things that they want to raise about the crypto refresh beyond the issues that we've just gone through now is a good time to raise them if you don't then we want to give the remainder of the time to uh some discussion about these uh potential issues that would come up after a recharger does that sound right yeah and i guess what we neglected to say is that we'll obviously take the minutes to the list of these resolutions from the issues and then we'll we'll depend on our kind editor to uh make changes and get a draft seven yeah uh we'll talk to paul about when that's possible and i guess nobody in queue if nobody's in qn i guess daniel is up thank you [Music] i'll just hold it"
  },
  {
    "startTime": "01:40:01",
    "text": "yes uh thank you steven um and yeah so just to reiterate this uh this presentation is explicitly out of scope for the crypto refresh it's more so meant to uh provide some ideas and make some motivation to get this crypto refresh out the door and uh get to working on new stuff uh of course that only works if there's actually interest in these ideas uh otherwise well uh i hope there will be um so yeah next slide please so um first for and for an overview of the status quo in openpgp we have acemeter keys which are typically long lived and managed in a key ring and we have symmetric keys which are either session keys or derived from a a passphrase or a password that you can encrypt messages and keys with next like this and asymmetric cryptography uh in general is um at least the the algorithms that we have in openpgp currently are more vulnerable to quantum computers and are also slower whereas symmetric cryptography typically is is less vulnerable at least if you use sufficiently large keys and is also faster or at least the the performance for a given security level is is better next slide please so um this leads us to the conclusion that there are sort of a missing"
  },
  {
    "startTime": "01:42:01",
    "text": "middle or a missing type of keys if you want to encrypt stuff with a symmetric key if you don't need asymmetric cryptography so it would be really nice if you could uh store a symmetric key in a long-term key ring to use to to symmetrically encrypt stuff but maybe also to symmetrically sign stuff uh using an hmac or a cmac if it's just for yourself or local storage next slide please so yeah for the use cases of symmetric encryption that we see that we have in mind for this uh is yeah so if you have some symmetric file encryption or you have some file storage that you want to uh store files symmetrically encrypted for backup or long term storage or on a usb stick or whatever or if you want to symmetrically re-encrypt the the messages the emails that you got for example um for long-term archival you can decrypt them asymmetrically as they come in and grip them symmetrically and store them like that so that yeah it's it's smaller it's faster and then if you want to retrieve them in the future decryption will be faster and in general will be more secure again as against quantum computers and in in this way it lets us prepare let's say um for quantum computers even if they aren't here yet um but at least then we don't have a giant body"
  },
  {
    "startTime": "01:44:02",
    "text": "of um rsa encrypted and ec easy dh encrypted messages lying around let's say and then finally for drafts before you're sending an email it would be nice to be able to symmetrically encrypt them again it's it's faster you you're not sending it yet so you don't need asymmetric encryption you can store them on the server if you want to continue editing the draft somewhere else later and yeah next slide please and then for the use cases of symmetric signatures or macs so if you have a symmetric key um that you want to store and that's only for symmetric usage then you might also want symmetra key binding signatures just to be able to store information about the key you know expiry and everything else that we have similarly you might want to store some signature about file to make sure that it's authentic it hasn't been tampered with or if you put it on a usb stick and retrieve it later to check that it's still the same file um might be useful for that or if you want to store the signature verification result let's say you get an email you you check using rsa or ecdsa or eddsa that the email was signed and you you don't want to have to do that every time that you retrieve the email later from archival so you you store the verification result using a symmetric signature let's say next slide please"
  },
  {
    "startTime": "01:46:01",
    "text": "so our proposed solution to this is admittedly a little bit hacky our idea is to define two new public key algorithm ideas ids namely aad and hmac so the reason we are proposing that is because the the semantics of uh public key cryptography in openpgp today match much more closely what we want to achieve in the sense that you encrypt a message with some key that you refer to by a fingerprint for example or you sign a message with a key whereas for symmetric cryptography and open php today you you encrypt a message with a password and you derive a key from that there's no way to refer to a long term key let's say um so in that sense it's much more convenient to be able to stick a public key algorithm id in a key packet a signature packet and a public key encrypted session key packet despite of course the the name not matching uh what what it actually is so there's one idea um of course it's not necessary to do so but to to fix the mismatch we could retcon the name uh of well the the algorithm uh registry perhaps and also maybe the the public key encryptization key packet and the symmetric key encrypted attention key packet which by the way the latter i would"
  },
  {
    "startTime": "01:48:00",
    "text": "argue is already misnamed because it's more password encrypted session key packet but okay so we could rename those perhaps to uh persistent key encrypted session key packet or and derived key encrypted session packet or personal key and shared key or something like that or we could leave it as this and just live with the hackiness of having symmetric algorithms in the public key algorithm um registry um [Music] next slide please so i've just thought of some guidance for us to give the designated experts not to do this or what fair enough so despite that guidance we do have experimental implementations uh in a fork uh and a branch of openphp.js and go crypto respectively so this is not meant to uh be used already but yeah just to see how it would work and uh we have a draft specification um again it it still very much up for debate another way to do this would be to define a private public key algorithm we could use algorithms 100 101 which is what actually the experimental implementations do or i mean i think there would be some value in having this be interoperable if you want to export your archive of email and import it somewhere else it's it's useful if other implementations also support it so then i would somewhat argue for"
  },
  {
    "startTime": "01:50:01",
    "text": "uh you know actually defining an algorithm id but you might also argue this solution is way too hacky we should define new packets with better names for this or or something like that next slide please so yeah the questions for the working group i have is first of all is there interest in this if so should we add it to the next charter and if so do you think this is a reasonable solution or is this way too hacky and if you think it's a reasonable solution please do read the draft and let me know if you have any comments thank you thanks again and are there any questions of course yeah so we have a little time okay right that's a quick question the you mentioned signature verifications is that in the draft or is that what's here it's in there yes so there is an algorithm id for hmac in the draft now so you can symmetrically sign using hmac and then also verify the symmetric signatures using the long term symmetric key right so but you i thought you mentioned some some idea about having storing a persistent verification result right so no that's not in the draft no there is no uh specific mechanism for how to encode that or how to store that because there is a there is a thing going through lamps from the stefan santos on about signature verification tokens that might be good looking at if that's actually interesting okay thank you okay so thank you um aaron i can give you control of the slides and okay so if i click it forward no no you you should see the okay okay so today"
  },
  {
    "startTime": "01:52:01",
    "text": "i wanted to present uh how like like an idea we've had to do automatically email forwarding and this means that with the user being offline we can forward the email to another open bgp user um with clearly uh setting up this protocol beforehand um so this is the outline it's gonna be i'm gonna try to keep it short especially the mathematical part of it but yeah so this is the concept of automatic email forwarding i think we're all familiar with it uh and the problem is so often that openpgp in order to do that you just gotta share the key so you're gonna take your key and send it to the forward d so that they can read the ciphertext in this case instead what we do is we delegate the authority of transforming the ciphertext to to a male cervical proxy that can directly deliver a transform cipher text to charts that will be able to read the email while we're on holidays or something like that um so the idea is basically the following alice is the original sender does not know the fact that there's a forwarding ongoing and she basically sends an encrypted open pgp message to bob as as all the papers we've read so far and uh but pop has basically um created a proxy transformation parameter this kbc uploaded it to the proxy and the proxy can use this per this transformation parameter to transform the ciphertext into a message for chars charles must have received as well dc the private key that will use them to decrypt the message coming from the proxy here is what happens behind the boxes so mathematically speaking the concept is actually not too complicated because in ecdh is just a multiplication on to the"
  },
  {
    "startTime": "01:54:01",
    "text": "elliptic curve field we have uh prepared a proof in the paper that this is actually a safe operation and any attacker that does not that is not charged colluding with the proxy is pretty much left with an ecdh instance um in the interest of time i will skip the exact details of the math if you can find it in the paper um the the schema is um is composable so this means that in fact you can you can basically set up a chain of forwardings so you can set up multiple forwardings for bob and daniel could also set up his own forwarding to frank so the idea is the fact that these chain can be built theoretically infinitely long now uh the problem with the open pgp implementation is the fact that we can't use vanilla open pgp because chars requires a transform modification in their implementation so it is transparent onto the sender side that is probably the most important because we can't go and get someone else to update their open pgp implementation but it is not transparent onto charts implementation so when you accept to be a forward d you need to accept a special key that says you are um you are receiving forwarded email and this is uh the reason because this happens is because there's in the key derivation function there is a binding to the to bob's key and if we do not know bob's fingerprint we cannot decrypt this key we cannot decrypt this message we cannot obtain the same shared secret uh diving a little bit into the open pgp changes that they think are more relevant"
  },
  {
    "startTime": "01:56:00",
    "text": "what basically happens is the fact that into this para parameter uh in the in the hash we do not have um we do have the the fingerprint of pop's key in order to there are two ways to work these around that i thought that we thought of and they are to add the fingerprint to the esk so basically to say hey this message was originally intended for this fingerprint but this makes the message distinguishable so you someone observing the message on the wire might be able to tell that this message is a forward message and second um these allow this basically it says for each message you gotta acknowledge that that message is forwarded well instead if you add this information to the forward d key uh this becomes a little bit more trans like you once you accept the forwarding key and add it to your key ring your implementation should tell you this key is actually bob's key and you will receive only email encrypted to bob that it has been forwarded for you since this key as we've seen before is generated uh here we can see it's generated from bob so bob knows the secret of this key uh it is better and you're receiving this key from someone else we thought it would be better to have a key that you know the fact that it can only be used for messages and no one can send you message encrypted directly to this key so these are the reasons that has pushed us to uh sorry to put it into the forwarding key this this extra information now as i said before the thresh model is basically that we assume that bob is always honest and never leaks the public key or there's already probably private key because this would clearly break any open bgp protocol but as as soon as uh the server and the"
  },
  {
    "startTime": "01:58:03",
    "text": "forward d party cop like collude corporate they can recompute bob's private key with a simple operation um this key since an open is an open pgp key uh it's meant only for encryption and in the rfc should be specified that this key must be used only for uh but it should only have the encryption flag so that it cannot be used for authentications or signing and yeah so basically this is it and we've we've wrote this paper that you can find under this address you can then you can also download it from the slides and uh we've wrote this paper that allows you to set up this forwarding scheme and i um i would like to ask the community whether there is an interest into standardizing this kind of procedure that was already briefly discussed at the open pgp summit and whether i mean if there's interest i guess i volunteer to write an rsc for this um in particular we've used curve259 in our analysis because it's a pretty solid curve and well regarded in the community great thanks aaron i think we're pretty much out of time um and i you know so as and when we get to the point of rechartering i think it's these kind of ideas because it would be for upper discussion i guess yep sounds right thank you for the presentation and thank you and with that uh thanks for all your patience with us this morning um as we worked through those issues i think it was fairly productive we take it to the list and i think we're set for this meeting yep thank you everyone thanks"
  },
  {
    "startTime": "02:00:20",
    "text": "um uh yes"
  }
]
