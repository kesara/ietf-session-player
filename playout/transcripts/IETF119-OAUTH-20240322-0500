[
  {
    "startTime": "00:00:20",
    "text": "Hi, Alice. Are you are you able to take some notes today. Mike, or should I ask someone else? You're not sure? Okay. Yaron, can you can can you help me out? Okay? It tech team, Okay. We have to start anyway. So Why is the slight not Oh, it actually is. Okay. Let's get started. So this is the last session of hours and the last session of the IDF meeting here in Brisbane, What can everyone, also, our online participants referred, I believe, is not online because of the very inconvenient time zone difference for him. So this is the slide deck, the chair slide deck, The one that we showed in a last two meetings as well. So you've seen the note well several times now twice at the hours meeting. So I don't need to repeat that again. Also, the meeting tips and Please scan the QR code So we have an accurate representation or recording of the participants in this room and also for going to the microphone I mentioned is our intention to schedule, a virtual in inter meeting to talk about the federated credential management API, act a doodle poll will follow. So we find this suitable time slot. Also, remind for the over security workshop,"
  },
  {
    "startTime": "00:02:03",
    "text": "skip over this action that we went through all of this. And this is our agenda for today. But before I do that, I want to say Happy birthday to Kelly. West Kelly, you know? Oh, over there? Happy birthday. I hope you had, you came a long way to Australia to celebrate your 1st day with us, fantastic. That's a commitment Okay. So the First presentation is the Trust device flow. And I will hand over to Peter. Hi, everybody. Peter Castleman. I did not take this picture. I asked, an a generative AI to create a of Australian Wildlife This was the one that I think is appropriate. Right. Let's see if the clicker works. That's not it. Do I do something? need to Are you Okay. I'll do it. You know, Okay. Next slide. Next slide, please. Okay. So very quickly, I've got 10 minutes, so we'll go quick. I'll talk just as a reminder, what this BCP is about, what have we done since Prague and then really what do we need next? And that is where I'm gonna ask people for help with reviewing the document. Okay. Next. Okay. So why are we here? Next slide. So the reason we started this work was because of the challenges with, cross device flows where we really rely on the"
  },
  {
    "startTime": "00:04:04",
    "text": "customer or the end user to, authenticate the channel. And so the kind of attacks that we've seen is, you know, typically, you present somebody with a QR code or some sort of a code that you want them to enter on their mobile device to to authorize or to authenticate and what attackers are doing is they're taking that They'll initiate these sessions. They take those, What what happened? My assistant. the slide that we're on. So which slide do you know? This is Thanks. And then then, take those QR codes, that change the context using social engineering techniques, convince the user that they should scan, that they should authenticate, should authorize and really trick the user, and they can do this because the channel between the device on which the code is originally displayed, and the one where it is being scanned is unauthenticated. Okay. Next slide, please. Okay. So what did we add to the draft? One of the things that we added was a section. I think we got some feedback to say, well, This is a lot of great info, but it's not quite clear what how should I use this document? So we added a section to provide actionable guidance to implement us on how to use the document, and I'll talk more about that. Also, Daniel, added the section on formal analysis and to to refer to all the known, or completed research project, that is applicable or that, helps us better understand this cross device flows. And we also added, a reference to the open ID for verifiable presentations. Next slide, please. Okay. So the"
  },
  {
    "startTime": "00:06:02",
    "text": "best practices section or the how to use this draft section. Essentially, I think really sort of a 55 things that we call out. The first one is the need to do a risk assessment Right? So we decide whether the, there is a sufficient risk that you need to address or that you understand the risks in your system and whether you are a k an unauthenticated channel or not, know, if you're gonna if you have to do cross device flows, with a with a non authenticated channel, don't, you have to use the mitigations that we have defined here. Also, we provide guidance on protocol selection Not all cross device flows have been created equally. And some of them, are far more secure or far less likely to be compromised than others. And then know, implement the appropriate mitigations that we, that we have. And then finally, I think one of the key things, right, one of things that does help with, this unauthenticated channel is the proximity checks. That is if I if there is only one thing we would recommend, is figure out a way to establish proximity so that it is harder, to move these or to, to compromise these unauthenticated channels. Next slide. Also, I think we sort of call out the different protocols to which this applies. So device authorization ground side, we do see Bob, open ID for VP and v Next slide, please. And then the formal method section, This is research from, folks across the world. And essentially calling out what that research is as well as which mitigations, it corresponds to So, you know, establishing trusted device relationships,"
  },
  {
    "startTime": "00:08:02",
    "text": "the value of user education or and or the combination of those things. The And next step Next slide. Okay. So what next? I think, you know, we feel like we sort of have all the content, And the question now is really, next slide. We need reviewers. Right? So there's fifty odd pages. Of guidance and mitigations and descriptions of different attacks. And we would like some feedback on the document. We feel like we've added everything that we can at this point given, what we know. Cool, Peter. great. That's So I wonder, whether we should just go ahead and issue working group last call because that would give us reviewers and then we'll see, like, if everyone is super happy the content already, we move forward. Otherwise, which is more likely, would have to spend another document or you have to spend another document version. Yeah. I'm that I I think the reason for getting feedback is find out how we make the document better. So I have no problem with, like, if we get if it's the the purpose is, you know, if it's great and it's done, it's done. But, yes, The purpose is to get feedback. So do we have, A couple of folks in the group to review that document. Monty, Dean. Let's see. Roy. Roy. Did you raise your hand as well? What was your name? 5. Rolf. Excellent. Ralf. Yeah. So you have those, Mike, I didn't look at the Perfect. I didn't look at the other side of the room. Brian, did you raise your hand?"
  },
  {
    "startTime": "00:10:00",
    "text": "It really. You you you see the the the subtle way and how I do that. So now he and, we'll say, oh, I can do it. feels guilty Right after your vacation, you said Okay. 0. Richard, what about you? That you that don't see, you know, your mask doesn't help. I just still recognize you. Any it's always a good opportunity for people who are new to the OS Group to actually, establish some experience, I see some smiles in the face, oh, you raise That's your hand. x Excellent. Thank you, Angelie. Could perfect. So we have actually a couple of reviewers so I'm I'm I'm very positive. That's the document Of course, refund of and I will, Uh-uh, one. leave you at this Okay. And, so just one question. There's one small update, just Eratas, some typos that we're fixing. So, we release that and then do the working group last call, or how do you wanna do it? Well, if you if you have time to do it, we we would, start with the working group last call next week. I think Yeah. But if if not, I It's a typo. It's not, yeah, I wouldn't, us type Like, if that's the only problem, then We're really good. Thank you, everyone. Yep. Thanks. Thanks for that work on the document. Sexton Okay. Okay. So now I lost think the next one is this one. Is that correct Dean? You going to talk about this?"
  },
  {
    "startTime": "00:12:01",
    "text": "Yep. Good I I Yeah. I was supposed next. Okay. Sorry. Let me let me check to be I may have messed up the order Give me a second You're right. It's Aaron. Sorry. In the it 2.1, Aaron? Yep. Great. Alright. Thanks. This is a photo from last time I was Brisbane, but I am sadly not there today. Okay, for this, I wanna give a quick update on OAuth 2.1 go ahead and go to the next slide. So this has been a, Long and slow moving, process, but we're slowly chipping away at things. There's been a handful of changes since the last revision, which actually didn't then do an update. Last IETF, so it was since the July meeting. This is kind of a highlight of the last couple of, significant changes to the draft Mostly just organization and and things. But the Aaron, the nutticker wants to ask you Do you mean ITF117, or do you mean 118? I do mean 1 in 17 because update I did not this in 118. Yeah. So mostly this is a is a just For edits for clarity and things like that. Hopefully, this makes the document read better. The, there's a link down at the bottom to, a list of more of the issues that have been actually, closed out, closed out, in this updates, but this was kind of a highlights. I think the biggest highlight here is, Adding, while moving the scope definition up into the introduction,"
  },
  {
    "startTime": "00:14:00",
    "text": "something I realized Actually, it helps clear up a lot of things because otherwise scope is kind of mentioned pretty late in the draft. And then, we had the definition of that form encoded syntax, added back into it based on the comments from a several people on the GitHub repo. Next slide. Right? This is one issue that I, wanted to call out for a quick bit of discussion here. This was from Philip Percy is at least in the chat. This was actually A comment from a thread that was about that form encoded syntax. And I Hold out this snippet of of Philip's comment, to point out that The current the oauth 2 draft has some behavior in it that is often misunderstood and implemented incorrectly in pretty wide range of implementations, I. Particularly around the encoding of the characters in the client ID and secret in when used in basic HTTP basic auth. And I thought the suggestion now that bottom of this was an interesting one of, limiting the characters, there can be used in client ID and client secret to just alphanumeric characters, to avoid the encoding issue. This has apparently been a source of a lot of implementation mistakes in the past and interoperability mistakes that are have just been a problem as long as this has this draft has been around. So I wanted to quickly quickly discuss this before, Moving on. So anybody has any thoughts on this, I'd love to get some, oh, good Phillips here to to talk about it. Go ahead."
  },
  {
    "startTime": "00:16:02",
    "text": "Thank you. Hi, everyone, and, good afternoon to those that are present. Good morning or, good night to everybody who's remote. Very quickly. I'd like to point out that because there are interrupt issues with this. There is no world where any party that interacts with the old ecosystem can do a strict implementation of this. So for 1, a client cannot strictly follow the RFC because will not be interoperate. It will not be able to interoperate with the big dogs, Google being one of them, but there are more than just Google. The other side being that the authorization server We'll never be able to strictly require encoding to follow the RFC. Simply because many clients just don't do this. And, this gives way to authorization server implement this to just test with common clients and figure out, hey, we're good. Not realizing that they don't actually encode everything properly. So, those are my little rant. Please continue with the discussion. You're on shift. There's There's more and more people who built some minimal structure into secret values to enable discovery of such values in code end in log files. So just a little bit beyond just alphanumerics would be useful. George Fletcher. I guess I'm a little bit confused or concerned about if we do restrict it to alphanumerics only"
  },
  {
    "startTime": "00:18:03",
    "text": "how that works from a migration perspective. I cannot imagine somebody with 100 of 1000 of deployed client IDs. Basically being getting all their partners to update their clinities and client secrets, to meet the new requirements. So I, I don't know. I just some concerns there about how you would moved to being 2 to one compliant in this context, Justin Richard. And, One of the things that confuses me about this a little bit is that, if we were to put this advice, then Google would still not be compliant. So That is most likely correct, ma'am. It says right here that they're using dashes. So if we tell them don't use dashes, they're gonna ignore that just as much as the requirement to encode dashes. So I don't quite understand the impetus way. That said, People 100% get this wrong all the time. Like, tons and tons and tons of times. It's one of those things that It doesn't bite you until it does. Because a lot of systems issue out from numeric client IDs. Some systems don't. Some systems are very liberal about what they accept. You encode it or don't encode it, it kinda doesn't care. And if you're doing things in the, What was it? The, the off header, syntax, the basic header. Then can kind of get away with things in a little bit different way there too. So It's super, super messy out there. And If the big players are already demonstrating that they don't care about complying with this little bit. Then maybe the correct advice is to actually"
  },
  {
    "startTime": "00:20:00",
    "text": "Admit reality, relax the restriction, and put in warnings. But Mike's isn't or is it So, yeah, So, Mike Jones, two comments. One just a data point. I know for certain that my former employees. Employers client IDs are full of special characters. I think they're unlikely to change those. Secondly, We kinda committed to people in OAuth 2.1 not to change anything just to have a faithful transcription of what Descartes would call a lot to the good parts. So I am against making a normative change. The fact that people implement the spec wrong is orthogonal to what the spec says, unfortunately. Prime. Yeah. Unfortunately, we're talking about just the encoding underneath, authorization How to write? Mhmm. Correct. Correct. Yeah. It's a yeah. It is definitely a problem, but I guess I wanted the second one. Yaron said there's a growing number of that are like prefixing their secrets so that tooling can find them in source code and things, and there's almost certainly used. Some kind of special character to denote the first part of that."
  },
  {
    "startTime": "00:22:00",
    "text": "There's also, Extension stuff. Classes of, but don't actually affect this particular piece. They don't use the basic auth header, but classes of extensions of off that use, URLs or URLs as client ID values. So it would be potentially restricted by that. I I'm really sympathetic to the desire here, but I worry about the implications of making this kind of change. So perhaps as someone said, Stronger guidance. Suggestion would be useful, but I I don't know that We're in a position to really make this kind of change Unfortunately, David. David? Something didn't work. Mycha Hi. Yeah. Just, yeah, Michael Fraser. I just wanted point out the tsunami, our our implementation for Brazil's open ID connect Federation, the client ID forms the URI. Which is the base to acts the well known acts the issuer for, realign parties. In Federation. So this would explicitly mess with that. And that's in use in multiple ecosystems now. So I would caution against it at least the client ID. The client ID was black, Michael. So it's URI for the is to base your eye for the federation Philip."
  },
  {
    "startTime": "00:24:02",
    "text": "Thank you for a very useful discussion. The one that I got away from it, that I didn't realize before, was especially the prefixing of secrets so that tooling can can protected, which usually is done by a prefix and an underscore. I believe GitHub does this very well. To detect secrets, and they require that from their partners so that they can talk their logs and their, the, the code. And this leads me to the the portion that we didn't talk about this. That we didn't talk about. It is on the slide, though. The most interoperable client implementation to this day, that at least I have that works with pretty much everyone. Is to encode everything except some characters. And it was exactly at the point where I started encoding these specific set of characters, that everybody who was using my libraries with Google, started blaming me for breaking their stuff. So maybe that would be a a suggestion to consider. We don't need to drag out the here. We have limited time, so I welcome everybody to join in on GitHub or the tracker. Continue this. Mike Jones. I'm gonna double down on what Michael Frazier said. It's certainly the case in open ID federation that client IDs or HTTPS URLs. The same can be true of some of the open ID for verifiable. Credential specs. So you need to keep the full character set. Okay. So, Aaron, what what is your takeaway? Sounds like there's pretty strong, Strong agreement to not add a restriction of the character set of the valid characters for"
  },
  {
    "startTime": "00:26:00",
    "text": "the field, I think there's probably some more discussion to be had around how we deal with to, whether to Just describe the situation or men or remove the encoding entirely, that or whatever whatever the possible choices are. I think those need to be discussed still. So yeah, I will say let's continue this on the GitHub thread 128 is a link on the slide or on the mailing list. And Try to resolve that there. K. Okay. So really quick to wrap things up. There's a couple of changes that I am planning on doing. Still, for the next draft, these are just, just, just, just, just, just, just, just, just, just, just, just, just, just, just, that's that's I Long, long projects, with a lot of small parts. There's a link to the Gitnam thread with with even more issues that are still open. Feedback is very welcome on those issues. Full requests are very welcome. To help, resolve some of these. Next slide, kinda want I wanted to kinda give a rough timeline of how I plan to move this forward, the, We have previously been waiting security BCP to to move forward. That is now in in progress as of, last month. So That's fantastic. The browser Browser BCP, which is also going to be I mentioned referenced in this, is now also that's gonna be getting working on your last call next week. So that's fantastic. We do still want to ask for a preliminary review from the HTTP working group for this because there's a lot of little HTTP details that need to get"
  },
  {
    "startTime": "00:28:01",
    "text": "teased out in here. As far as the rest of the year, the next 3 months, I'm planning to do a sprint on the open issues that are currently there, but I would Absolutely. Love help. As Honas has mentioned before, this is a working group Draft, which means it is not just one author's ideas. So your help is very welcome. PRs are very welcome. And I will publish at least one new draft by July the July meeting and I'm sure there's that's not going to resolve all the open issues by then. So I've Just blocked out the next chunk of the year for actually wrapping up the open issues. With the goal of getting this working group last call by the November meeting. It is still quite a chunk of work, so please feel free to dive into any part of this that is interesting or relevant to you. Erin, would it help to schedule a virtual intramation specifically on this topic to this cussed and and Maybe, finalize the open issues in, like, let's say, June, July, what tune ideally because then there's time also for updating the document in time for the summer IETF meeting. Well, is that unnecessary? No. I think that would be great. I think there's a couple of issues that, probably could could just could warrant some discussion, this we talked about just now is a good example. There's a few of those. A lot of the issues are more just tasks that need to get done. So those don't need a discussion. They just need some volunteers and text. But, yeah, I do think probably an interim in June wouldn't hurt. Okay. Yeah. Mike and and, Iran, maybe after the meeting minutes is scheduled she has scheduled a, intermeeting in in June, k. Thank you, Aaron."
  },
  {
    "startTime": "00:30:01",
    "text": "That is it. Thank you So next step is the SEDAR profile for RAV somebody's a little taller than I am. Sarah, you should be online too. Aren't you? Hi. I'm here. Yes. Okay. Awesome. Great. Try it. If it works, maybe? Yes. So, Okay. I'm Dean Sachs, from Amazon, Thank you. Need to swallow the mic. Dean Sachs from Amazon, I've got Sarah Chichetti online with me as well. And we are here to talk about an individual draft. For, extending OAuth RAR with Cedar. So first, just a little background. About cedar. What is it? It's an open source language. It's domain specific for authorization. It was released, in 20 D3. And it has evaluation engines both available in Rust and go that are, Preferably correct using formal methods. Sarah, do you wanna talk a little bit about that before we move on? It I think that's a fine summary if people have questions happy to take them Okay. Sarah is, is much more familiar with works with her on a much more regular basis, or sorry, cedar than I do. So she is the, the the person to, speak to about Cedar specifically before you could, if we had, Go ahead of your information. Usama. Hi, Usama from T. So I'm very interested in the format So can you say a bit more about what did you prove what were the challenges there and so on? Can you give us some details or highlights about that. And where can I find the reports on things? Yeah. The the repo is on GitHub@cedardashpolicy. We should have put a QR code in there. Sorry."
  },
  {
    "startTime": "00:32:04",
    "text": "And the intent of writing it in both lean and Rust was that the lean can prove certain aspects of the language So things like, it is default and I, and forbid will always override allow. Those sorts of things are proven with formal methods and then test it against the rest code so that we know that they are always Yeah. Maybe you can post a a link into the chat window so, those who are interested can catch up. I think it's sounds extremely interesting, maybe relevant to some of, coding efforts that people are doing in this group. Yeah. Most certainly. Alright. So, moving on, so our motivation for why we wanted to stand OAuthorar with Cedar was because, Cedar in in, allows, or the use case is really identical to RAR. The the client is accessing effective resource. We want fine grained access control on that resource. And the AS is going to facilitate that. And in in this case, what we're looking to do is facilitating it by blessing a cedar policy set. And so Cedar Policy said has a very, standardized language that the client can communicate, the client communicates to the AS and then, eventually communicates to the RS via the OAuth token. And the reason for this is because as we look at OAuthrar. What we see is a big bucket of JSON strings. And client and AS have to agree on what those strings are, etcetera. And that's fine. And it works in many cases. I got a lot feedback this week about open banking and how well that works for open banking. We do not want to replace that. Rather we would like to extend that by off offering a different language that we can profile with to enable people who choose to use Cedar. In both the AS and RS, to use Cedar to to"
  },
  {
    "startTime": "00:34:01",
    "text": "to communicate what that authorization request is. And we can use standard cedar libraries through the policy evaluation locally. This reduces latency. It increases our flexibility. And again, it this is not replacing JSON. It is something different that we might use in place of JSON for those places where it makes sense. Sarah, do you have anything to add? I just wanna clarify that this isn't an extension. It is a profile. So it is, it is intended to restrict the amount of, to to to make more restrictions on compliance. Good call. Thank you. So, Sarah has written the, individual draft. It is posted in the OAuthworking group in data tracker you're on. I'll get to you in one moment, please. We do have a number of open questions though, that really we wanted answered by coming here to IETF 119. And you can see some of these open questions up here regarding whether an AS should be allowed to respond to a non cedar formatted request. So say it's traditional OAuthRAR using JSON can can the AS for respond with a cedar format or vice versa. And some more guidance around our choice of how we represent the type I got some good feedback from Brian yesterday over lunch about that. I still need to share back with with Sarah. And and additionally, This is the first profile on RAR. Should we, extend this profile to other domain specific languages, or should we let those other domain specific languages go and build their own profiles. But, Yaron, why don't you come up and and ask your question? Then we'll take questions from there. So, obviously, it doesn't doesn't need to work for open banking, but I think it would be useful if you added, a section on applicability least the as"
  },
  {
    "startTime": "00:36:01",
    "text": "a high level for people reading the draft. Which areas this is likely to be applicable Okay. Great feedback. Thank you. And regarding the open banking, we, again, I did get a lot of feedback this week in open banking. One of my takeaways from this week, even though it was not in the meeting, was to come back with in in the next update with non open banking oriented examples. Ralph, thank you very much for the feedback. I appreciate George. Joke Fletcher, I guess to the first question, I'm not so sure it should be symmetric. So if someone want so, like, one of the possibilities here is I'm gonna take that cedar policy. I'd embed it in my access token. Which then allows the Right? If I want to use that internal to my AS, Correct. internal to my services, It shouldn't be restricted that the inbound request must come in with Cedric. I see those 2 completely separate things. Right? I could say I want to do a transaction and it's got Jason formatted set of additional scoping things. Right? But internally, my policy says, I wanna use Cedar for all of my policy So I'm gonna take that raw input, turn it into what kinds of policies the requested resource needs to execute Right. Put it back, shove it in the token, and then let it go. So I I I'm I don't know that it needs to be symmetric. Okay. So reading that back then. Standard OAuth and then the access token just embeds that cedar cedar policy in it to the RS. And because that is is, opaque, to the client. It doesn't matter. RSN AS have agreed on this as a format to use for their authorization language. Thank you. Ralph? Yeah. Hi, Ralph Bragg. So In terms of the applicability of this for a whole lot of different sectors increasingly, we're seeing"
  },
  {
    "startTime": "00:38:00",
    "text": "you know, things like ISO 20 0222, which standardize format for financial, messaging and financial services. I can't see wholesale changes or, you know, these ecosystems or even bizz or ISO saying, no, we're gonna restructure all that work for ISO 2022 for financial services into a cedar type format. But, saying that I agree with George. Most of these ecosystems around the world, the actual access token is a pay the, the relying party. And most, in most cases, the authorization server and the resource server are owned by the same domain. There's a lot of value internally. In making that access token as useful as possible for the corresponding you know, resource server. In fact, in all of these ecosystems, the access token is opaque. To the resource server when we do when we're working with, you know, and FIs, we do say, like, you know, putting as much the the the the the the information as you can in the AT where it's appropriate to make allow your resource efficiently without having to call other policy information, information points. So No. Actually, I, I agree with George. I think it should be a yes in terms of you're able to, you know, to do that, but you've got to think about some of the sort of knock on considerations things like, where access token introspection for the, relying party as opposed to access token introspection for a resource server. Might come into play. So in some scenarios where a resource server does want to know what was in that authorization details and they are allowed to have it, you might need to have you know, you know, and that might add some complexity where different people need a different presentation of that authorization details and the format depending on who they are and how they've introspected that token. So if I if I if I hear what you're saying, It's, the the resource server may need the the policy not in a cedar language. It may need it other way around resource server will need it in the seeder language to make their lives easier, but the the relying part if, like, do an introspect"
  },
  {
    "startTime": "00:40:02",
    "text": "might want the authorization details in the language that they sent it into, which allows to whatever the standard is for AS to, RP, you know, you know, model, be that somebody else's spec or an open banking spec or an ISO 2022 spec. Okay. Great. Thank you. Brian, did you raise your hand? A few things. Just to the title on a go on record here that the whole idea of Rara was, like, here's a bucket you can put stuff. You indicate that what that stuff is by the type in it. So adjusting Whatever this is to, use that mechanism of of profiling would be. More appropriate than, I think, I forget what it's called. You have sort of a secondary thing. It kinda just Yeah. It's like compile error on top of a rare doesn't actually extend it. The way that it was wanting to be So if I if I remember the conversation correctly, we should probably set the type as something like, cedarpolicy.com/ open No. banking. Sorry, Ralph. No. Not open banking. Right. Right. Yeah. Yeah. I'm I'm I know cedarpolicy.com. That's We'll stop. This is a senior policy. it. Got it. Okay. And then And so that type is saying this is a cedar policy. You can find the policy at whatever you define as the thing that holds the policy. And that's that's the extent of And that that the fund type defines what it is. I mean, can you you wanna say that in better words? Yeah. Different word. Maybe different words. I don't know. No. Yeah. So The idea behind tight in RAR was that this is what the rest of the object is shaped like. And and that's pretty much it. Right? It it it really is an object type type of thing. So we really set out to give people, like, here's a bucket to put whatever JSON you want in it."
  },
  {
    "startTime": "00:42:04",
    "text": "And so if there is some type of, secondary restraint or profiling that you wanna do beyond that, you can define a field that applies behavior to it. And it can be your own, like, cedar policy profile type or something like that. That's that's totally fine. Type, though, isn't for that. Right. Type is to say Within this JSON object, you will find this field of this JSON type with this semantic thing applied to Yep. Yeah. Exactly. Exactly. So to to me, I think that that's just syntactic massaging of what you guys mean here. Yep. But that that was, as Brian put it, I think. That was the intent of RAR. And if this is a profile of that, then that's that's where we gotta go. Okay? Perfect. Yeah. Yeah. And to Justin's point, it is just some tactic Yeah. Yeah. Let's do this. Fixing it just to make it look fit together the way it was. Less syntactically valid is the question of whether this makes sense. And I The as I understand it, the policy language is a policy language for evaluating access control and policy. All the benefits you listed, I think, in the previous slide were about what the AS and the RS could do by evaluating policy. You could do all that now without a profile of RAR. You can put cedar policy and your access tokens. However your deployment wants it and get it done. The real intent A rar was to give this rich bucket, to the client to express what it's requesting authorization of then It might be to my own lack of imagination or ignorance. But the policy language doesn't"
  },
  {
    "startTime": "00:44:01",
    "text": "feel like something you want to be exposing for the client to craft its own policy. And send to the authorization server for the end user to approve that. That policy, I platter to the access. So it it feels very much like These policy languages are things that are implemented behind the scenes, behind the the resource server in its own access control policy, but not something that's exposed to the client or the outside world. So I don't know how else to say that. It does. It's fair. It it is fair. And I I wanted to maybe move forward to the next. He was on the next slide. One of one of the the features of Cedar is this idea of partial evaluation. That, it's sort of requesting the resource. You can designate it. It is unknown, and and this is already reported in RAR, right? And so you could basically say, give me access to to photos. And get back a policy that is much what that means in the context of this user, and in this particular request. And so that's a place where that this may be more utilitarian. But it's something we need to to spend a little bit more time working through. Just just for my own edification, then what a a client, then call some cedar policy server to do this partial evaluation to get you back. Call the AS with a a acedar policy that doesn't specify anything more than Give me the bucket of give me a bucket of photos. And the AS responds. Well, eventually the access token would have a fully fully defined cedar policy that has all of the, constraints upon, which you are going to authorize that user's request. Okay. one? Sarah, do you have anything to add to that Right. So the idea is that the the client may not know what it has access too. And so it can say I have Alice in front of me. What can she access and get a get a token back, in raw format that indicates that"
  },
  {
    "startTime": "00:46:03",
    "text": "Basically, it's more narrowly scope than everything. But that's, that's, computed by the AS. Then communicate to the RS. So I'm I'm still not clear on the need then for the client to to communicate that with cedar policy to the which is where I'm kind of hung up on the applicability of the use case. All the examples fall back to the AS and RS communicating or evaluating policy. Where RAVR is exposing that detail to the, to the client itself. That's kind of key point of it, so Got It just feels like there's this disconnect. Feels it. like we've we've moved it one step farther away from the AS and RS than it needs to be. It's what I'm hearing. With profiling the wrong Building block provided by OAuth in order to enable working with with cedar in the context of the excuse me, AS and RS, where those things could be accomplished just by agreement between those two parties and encoding the the policy somehow and the access token. You don't need RAR to be able to embed that in the bar structure of requesting response between the client that it's maybe just It's working at the wrong layer, maybe. Okay. I think So we did consider profiling, Scott, would you Do you think we should just profile Jot instead of RAR? I'm not sure I have a fully formed opinion to say us, but it it feels like something that would be more like an access token profile that you would convey how you would put in a jot, how you would convey an introspection, and kinda cover both of those things. And then have a field that conveys that information. So, yes, sort of, but maybe with a little bit broader scope, yeah, that's feels like a more natural approach to me, but I, I have to again admit, I don't fully understand and the domain or the the goal, so I may be missing something Got it. Yes. Something more about the access token and enabling the data Okay. flow between."
  },
  {
    "startTime": "00:48:01",
    "text": "AS and RS. Keep Alright. This is a good good healthy feedback. your remarks short because we are a little out of time already. You. I'll just keep it a brief. So if you took this from a, a flow point of view, the relying party is gonna have place something to the customer that's machine readable for that customer you're then proposing to translate that into a ceded policy, which gets sent to the the bank in a raw format, which the bank then has to reverse back into key value pairs that they can sort of then display to the customer that the customer understands so they can actually cent. At the authorization server to the information that they're they're sharing. So you're talking about having you know, translating something that's least in adjacent authorization the examples, yeah, there are payment examples in Rah, but they're very easy for you, me, and Tom Dick and Harry to understand what's actually being asked for if it pretty much got dumped on screen in front of a, you know, in, by NAS. This model here, there's a lot of work to take something that's relatively machine readable translated, then reverse translate it to present it back back out. Right? Back it out again. So to Brian's point, yeah, an access token format profile would be far more sensible, and I think would be a really good idea for the ASAP standard to be able to then utilize that at their RS, but pushing this firstly out to you know, UI UX and AES's from a translation point of view for presentation to a them up, but also on the relying party to essentially do the same thing when they're trying to codify this in a way that consumer would understand to then have to translate it again. Just feels like a sort of a recipe for a lot of mistranslations to go wrong. And, just, I I'm getting I'm seeing a lot of nods in the room as as you're saying that as well. So as about profiling, the the access token, that that that so thank you. Peter, take care. Peter Castleman, There was another there was one question I think about whether this draft should be extensible to other policy languages. I think the answer should be no."
  },
  {
    "startTime": "00:50:02",
    "text": "At if we have additional policy languages that we wanna use, I think that that those should be their own, documents. And then another question just how you think about you know, you thinking about bringing cedar into the IETF as well as, standardizing the policy language outside, just your thoughts on, how you think about that relative to the standardization that you're doing Yeah. So that's a a great question, and and one of the questions we had was, if we do normally refer to Cedar in a future in a in a doc. How do we do that when it is not, it is not standardized through an STO today. So, that that is an open question that we have. I do not know what the right answer and look to the chairs for help with that or other folks in in the room who may have more experience with that to, to help with guidance there. Yeah. From the top of my head, I can't answer that. It's probably a to be done, to be investigated. Okay. Okay. Dima, Yes. Do you mind here? And it's coming from experience, and I think I mentioned before that Have us tryna strongly agree with the comments that Klein doesn't doesn't necessarily need to know what policy engine is run by authorization. Can the you use mic? Yeah. Client doesn't necessarily need to know what policy engine is run on bioauthorization or resource it feels like we're forcing that. There is some potential utility in sharing that information with closed ecosystems. From your own examples. And that we're having a spec there are other ways to share the policy details between, external authorization, the external policy engines that you can be used. You don't have to share the policy itself and the policy language different participants of the flow I think what would help is probably maybe the y."
  },
  {
    "startTime": "00:52:03",
    "text": "Yep. This spec, maybe in the beginning of the spec, what are you trying to solve exactly? There might be other ways that we can help Okay. Thank you very much for your feedback. Last call. Just, sort of trying to understand if the authorizations that were should always be the policy server because these are slightly different things, right, because We expect an authorization, so we'll provide a sort of a finding time kind of organization. Whereas the policies over as a distributing policies that are maybe, longer left. Right? And so with your and I agree with Brian that, you know, maybe the, you know, the client and the AS don't need to be involved in getting the policy. And so would this actually be a separate protocol between a resource server and something new on the policy server. That, the conditions of the policy, to the resource. I would say, no because you could, of course, run the cedar Sierra Policy Engine on both the AS and the RS, if you wish. But, of course, his unit will know a tool from the Austin working group. There is a lot of work on externalizing authorization. And so I don't think that is something that is specified here or even should be specified here. But I think as we get further further down the line on this work, we can take a look at that. And and maybe make some some recommendations, in the doc. Okay. We, thanks. Terribly out of time, but, you triggered a good discussion. And I guess you have enough content to update the document. I I suspect that we will debate this issue again. Looks like there's a lot of interest in this Alright. all. Thank you Yeah. Thank you. Thanks to both of you for contributing is, This document. Alright. So I'm presenting a little bit for"
  },
  {
    "startTime": "00:54:02",
    "text": "Aaron Peter, we've been working on this, and spec. I'm going to try and make up some time. First thing, there is a bunch of context slides in here. I'm going to run through them quickly. So if this is the first time you're hearing about this, feel free to find me afterwards and we can talk about it in more detail. Effectively many mobile apps today when you bounce out to the web, create all sorts of extra, friction and, user experience challenges that, product owners don't like. And, lots of people are avoiding the best practice guidance that's in, 8rc8250 for native apps, which is basically do your authentication and your authorization in a web view in the context outside of your mobile app. Largely you know, that's there largely because of 3rd party gaps but we use OAuth in many, many first party contexts. And so people are working around this with proprietary mechanisms or doing things like using password than they can do MFA. So this is sort of an attempt to the spec is Uh-oh. Trading, There go. So, this is just a quick view of we Blay Olavka. The authorization code works, for web apps And And, so, basically, what we're trying to do is keep a very similar flow in this first party apps where the client makes a request to the authorization server then the implementation specific stuff for authorization authentication consent all those things happen in the middle, the authorization. The client gets back a code, and then it goes to the token endpoint."
  },
  {
    "startTime": "00:56:01",
    "text": "Is sort of the the expectation here so that we can make the the interactions there in the middle be specific to the authorization server, but allow for native experiences. So, you know, reuse a lot as much as the web flow. Allow for the user authentication to proprietary as in the web flows, to the AS And, maybe there's some ways we could do some you know, more reusable, extensions like Fido, that work is not yet in the spec. So to do this, we established a new endpoint called the authorization challenge endpoint It pretty much takes all the parameters that you would get from any other normal authorization requests, par, you can post the data there's you'll stuff for sort of enhancing client authentication and those kinds of things. We wanna support sort of all the extensions that exist for OAuth. And, the expectation is that out of making this post, to the authorization challenge endpoint, you may either get an error, which takes you through a challenge response protocol defined by the AS or you'll get an authorization code, which you take directly to the token endpoint. Ala Standard OA. So no changes to the token endpoint. And, it it Why do we have a new endpoint? Well, RAR is very specific. I mean, not RAR Par is very specific about what you get back when you talk to it, that isn't really compatible. Basically, you get back at URI. Go open your web browser and and load this URI, which is not what we want in this particular case. The authorization endpoint is heavily expected to be"
  },
  {
    "startTime": "00:58:01",
    "text": "executed in a web context. So posting to the authorization endpoint and getting back non HTML is not expected by the majority of authorization servers. So we didn't want to try and overload that the existing authorization endpoint. This the the point here is that, you know, just step up still works. Basically, you can you know, the token endpoint gives you an error. You can go back through this process. And, you know, you can start a new authorization flow. You can just started it natively. Okay. Thanks. So this is changes since 118. We basically updated the authorization code binding with depop. Thanks to Brian. Remove the, the basically a hash binding mechanism, would There is this concept in the spec that basically says if the authorization server determines that you can't complete this natively and you must do it in the web that, you know, we can give you an error that says go to the web to finish. And if You're doing that then you either have to start completely over in the web environment or you could have initiated the original authorization request with Pixie so that when you get that back, you can effectively be 2.1 compliant. When you bounce to the web, and you can sort of continue the authorization from wherever you had gotten to So that's what that, work was there. Clarified the request. Don't have to be forming coded once you're sort of in challenge response environment. And then finally, binding the"
  },
  {
    "startTime": "01:00:02",
    "text": "parameter that we call the auth session to a device. So that you couldn't sort of like steal the ah session and replay from somewhere else and get in the middle of somebody else's authorization experience. We did send a message to the list about, Hey, we've got car, and we've got this new thing, and, it turns out that the open ID for one of the open ID verifiable related specs talks about a direct post response mode, which is kind of weird this thing. You know, should we try and create a post request framework and then build all the stuff on top of it. And basically, there were crickets in regards to the email that Aaron sent out. So we pretty much have punted on that idea. And then here basically is we feel like the spec is in a good enough place to ask for adoption by the work group, And, we have had some ideas about how, you know, how we could find the sort of, like, a secondary extension that could show how to use pass keys as an authentication method within this framework. Good. Thanks. Thanks, Judge. Let me let me do a poll on asking on who has read the document, just to get a sense of, where we are. You. The draft. Have you read the draft? Hold on a second. Bullets. Like, any it was like there are only 2, Yeah."
  },
  {
    "startTime": "01:02:17",
    "text": "Not moving so much anymore. Uh-huh. Can't. Yeah. I think, I think what we What would be good? Maybe we can recruit a few more reviewers un ideally now. And then, do we call for adoption on a mailing list to see where things are, we had that presentation at the last IETF meeting on this one. For good discussion, And so Yeah. Okay. That do we do we have a few hands Yaron, you want to Okay. And you want to receive receipt a again? Where's the result now? It was, five people have read the document and That 20. wasn't it. Actually, before I say yes, I will review it. Other implementations Oh, is this a subset of an existing fido implementation, which sort of alluding to I don't know specific, specific implementations, I I well, you can figure that out, that would be good to know. Oh, but it's obviously not finished yet. So Right. Mean, it's like it drafted 01. I mean, it was not affecting up a lot of implementations. So yes. So It's probably too it's probably too early. But Do you want to raise your hand to review the documents so you have yaron, doing a review And who else do I have Ralph? I see Right here."
  },
  {
    "startTime": "01:04:03",
    "text": "Who who was saying? That Sorry, Philip. I'm raising my hand. Oh, okay. Thank you, Philip. Rife, did you say yes? Did I okay. Rove. That's excellent. Cool. Okay. Some, 3 new reviewers. So that's that's good. And, also add a note, the action item to then, start a call for adoption to see what comes out of it k. K. Good. Okay. Alright. Can we make a time? I yeah. We did. Thank you. Thank you. Thank you. Brian, do you have a question? Because it No. Not not necessarily. Like, it's there's no hard and fast line here. Like, it varies a little bit in document, like, also considering a little bit that, it's Friday, the last session, I see few online participants, so I'm I'm a little bit reluctant to Do you like, pull the trigger here, today? Like, this That's why I'm not also doing, a show of hands for call for adoption in the room because looking also into your face. Some of half of the room is has faded away already, like, touching from your face expression. You're staring at me as I would be an alien Oh, there there's some the oh, right. Now what what are you saying? That's true. Yeah. There was a question, like, Brian, what was precisely a question? Are you saying, like, I'm I'm why, pilaf chair, are you not, making a call for adoption now right now in the room"
  },
  {
    "startTime": "01:06:01",
    "text": "beloved chair. how you referred to yourself. So, like, No. Without being negative, it felt like there was not a lot of reviewers and not a lot of energy around reviewing so that a a call for adoption felt. On on warranted, this point. Mhmm. least given the energy but I do understand it's Or at here, Friday. Yeah. So that's why I I basically punted for this meeting and and put it on the mailing list and get some additional reviews in, to see what's what's list, Additional reviews are good. But putting on mailing the is is is The call for adoption. So you're posting a call for auction. You think it's not a good idea to as a group. So, like, that the outcome from that call, maybe like, actually, no. We don't we don't want it. Or I it's too early because we need some more work or Like, are you in general? Like, it this topic in general looks like, like, our series of, recommendation for specific, environments So like, like, we did for native apps, we did for, the device flow. We did for the browser based apps and so on. Does it look like in in that category. So it wasn't like we are their purse it's a it's not a topic that, is totally out of the ordinary here. It's it's really different than those. Actually, those were codifying existing mechanisms to try to fit into Those types of environments and explain it. This is a whole new protocol. Geared at It's a whole new protocol that's on law. of top the To facilitate these patterns we've seen with native's ops that Alright. Yeah. It's like, so So you think that the bar should be higher here? So maybe it seemed early. I don't know. Okay. That, that seems unpopular. So but it's that's good feedback. So I was just I guess I was just reacting to your we'll get a couple reviews, and then we'll start the call for adoption. That seemed"
  },
  {
    "startTime": "01:08:01",
    "text": "Like, they don't logically Premature. Okay. From one another was resolved. But if you wanna You done? No. No. I'm I'm No. It's it's obviously receptive to to feedback. Like, what the group wants? Like, where you guys you guys So you for you the record Roland Rowan wants to talk. I read Satya version. Of the draft. And, and most of the issues addressed. There were things about asked for our address, so it's not like I'm not involved. I just I have I haven't had a chance to read the updates. It feels Rush to me, but comes. Yeah. Hi. Just a quick quick one. So I don't wanna keep on bringing open banking, but these data sharing ecosystems are sweeping the world. And one of the biggest challenges we've got, and Dean can talk to this as well, is that every single vendor, every single bank, every single group is really, really short sort of expertise and guidance and standards for how to actually go and do this. And everybody fights and everyone struggled for, you know, working with the various different vendor products that have all implemented this in very similar or, you know, different commotion, you know, hope hokey pokey type type ways. This this sort of need for our 1st party application integration with authorization server isn't going anywhere. And so anything we can do to, and even if anything, it's getting more and more and more pressing and, obviously, you're having the same and over and over and over again with you know, different banks or different teams or different whatever. So if there was a standard that would help facilitate this across industry and, you know, to facilitate adoption to uplift sort of just basic understanding from a wider group of people be great. So, yeah, I'm all up for helping review, but you know, there's, 4 markets going live in the Middle East for Open Banking. That's know, I don't know how many 50,000 new banks, it'll have to do first party app integration. So, yeah, if anything we can do to move this along, we can grant Rowan May. I think that solving this problem is very important,"
  },
  {
    "startTime": "01:10:01",
    "text": "this draft will be super useful. I read it. I skimmed it yesterday. I think it's on the right track. But I'll I saw a lot of things where it's like, not sure about that. I would like to see This go a little bit further, you know, like, a little bit more implementation, some tests and things like that before we call for adoption. Thanks. Okay. Would love the feedback and issues. Of the things that you had work questioning, that would be great. Right? Just file them in the GitHub, issues repository. Yeah. And none of them were like, He's doing that wrong. It was like, oh, I'm gonna need to, like, sit back and think about that. No. Super helpful. So Feedback is fantastic. Okay. So it sounds like there was Yeah. That's a little bit of persistence for us to do a working group last call. So we'll have to review us, see some more reviews And then we, and then hopefully hear back from you on implementation aspects and and have another presentation in the group. So now, I thought that we took got some time back, but now that's not true anymore. Okay. Aaron, can you carp out a few minutes from your presentation. Is that We're going to Yeah. this is a 90 minute session today. Right? Not 2 hours. That's true Is that correct? we've Okay. So Okay. Great. Yeah. I'll I'll I'll try to shave some some time off. Okay. So this is a, Update on a draft I presented last meeting. Global token verification, next slide. Again, there's a lot of background information in the previous, meetings presentation and recording. So I'm gonna kinda skip through most of that, but the short version is that"
  },
  {
    "startTime": "01:12:02",
    "text": "In a typical OAuth app architecture. We have a client authorization server. The client's gonna go get tokens from the authorization server. To do operations at an API. In many scenarios These are referred to as apps and the apps back end, just in in deployments. Go to next slide. What this draft is doing is adding a new endpoint to the authorization server of that for that that API, which can revoke tokens based on an external signal from something else. That could be a security monitoring tool or could be an identity provider in this case, identity provider would be something that the user used to sign in to the authorization server. So auth doesn't define how these are signs in. It could be a password, or it could be redirecting through another identity provider using Open ID or Samuel or whatever. So the point is that this is a new endpoint at the authorization server that can revoke revoke any tokens issued to the client from some external signal. Next slide. Goal with this is to give people a very for interoperability. This is really quite a lightweight endpoint. There's not a lot of actual, mechanics in this in this spec, and that's very intentional. The goal is to be very precise There is one outcome expected from this Endpoint, And there is one input, input, there, and there is no no negotiation and no wiggle room here. Next slide. I'm not gonna go through all this, but I did do a survey of existing token verification and logout standards. And I went into this more detail in the previous presentation so you can refer that if you're curious. Essentially, there is no existing standard that covers the exact outcomes"
  },
  {
    "startTime": "01:14:00",
    "text": "that this draft is trying to achieve, The the shortcomings are either that the revocation is client initiated, which is not not what we're talking about here, or that it's either something like only talking about not really tied to refresh tokens or more of hints or suggestions or requires more infrastructure to actually set up order to receive those signals. Next slide. So this is the I've This is essentially the spec. It is, the endpoint takes as an input, a subject identifier from security event tokens, which is now RFC, which is uh-uh big become an RFC since the last meeting, So imagine, like, a security monitoring tool would have its own credentials into this, this authorization server, authentication is required, but it's out of scope. This is similar to how token introspection handles authentication of the introspection request, The outcome of the of the request is that refresh tokens that are issued must be revoked. If the server is able to re revoke access token, so it should also be revoked. And that server must reauthenticate the user before issuing any new tokens. Next slide. This is just an example of what the payload actually looks like, the idea of how lightweight. It actually is. So there's an authentication in some form. And then the sub ID I with a format and then whatever is the identifier. Next slide, it's just another version of it. From this is, again, from security event Next slide. I expect this one to be relatively common as well. Issuer subject where this would be, like, if the user went through SSO, then we would have an issue or a subject identifier for that user from that issue. Next slide. The response is just, HTTP status code, no body,"
  },
  {
    "startTime": "01:16:00",
    "text": "just saying, yes. Got it or no. Couldn't couldn't find the user or something else was wrong or whatever. Next slide. So since the last meeting, there were some good points brought up. I tried to address all of those in the draft. Mainly things like, was a concern about enumeration of user accounts. So there's a mention of that in there. As well as a scope of the authentication of that request. Some other things details here and there. I act I actually also added a reference to the status list draft as a way to handle revoking access tokens. And I mentioned the differences between the existing logout specs in this draft now as well. Next slide. As implementations go, there are implementations in progress now. So at Okta, we have an in progress implementation, and I can't unfortunately named the others, at the moment, but there are 3 that are planned or on the road map already, and then 3 more that have expressed interest in this, but don't have the bandwidth on their current road map, but are gonna revisit this in a a several months. So that's some, that's some good progress already, I think. Hopefully, I'll be able to name some of these at the next meeting. We will see. Next slide. So as far as next steps, I'm pretty happy with the the state of mechanics of it, pretty happy seeing, the the progress on the implementations. I was wondering if people think this is a good candidate for adoption by the working group at this Atul, you want to save, quick some quickly something? While I'm running the call to just see on who did Read the document, yeah. Sure. So just a question to Aaron, whether this can actually be specified as a profile of SSF rather than defining its own"
  },
  {
    "startTime": "01:18:03",
    "text": "sort of metadata in terms of, you know, the global replication and client and things like that because I think What you're doing is is very interesting because it's, you know, it kind of gives you a more definitive, sort of semantics around some of the events defined in SSF, but is running if if you could just specify that as a profile of SSR using this remove the vent or something like that. That, that would be, also interesting. Yeah. The main concern with that is that, kinda mentioned this in the in the differences from the existing existing standards. SSF was great, and I think there's a lot of the more more interesting and subtle aspects of this that are far more appropriate for SSF. This signal is really meant to be a a a command with a clear, unambiguous outcome rather than a event about something that has happened. That someone might take an action on. And that's kind of where the SSF, tends to treat things. I will add that it is expected that, signals from SSF would be an input into the actual engine that would cause this command to be run, but this is really meant to be, again, lightweight, easy to adopt without having to to understand the rest of the context of SSF, imagine people implementing it on an authorization server that they don't even considered to be an authorization server because it's really just the apps back end API. So rather than having them have to set up an SSF stack understand those concepts. This is really meant to be just very precise, No. Really go log on everything right now. Yeah. No. I I agree with you, and I think, what just what is Can you, like, move that to the, mailing list?"
  },
  {
    "startTime": "01:20:02",
    "text": "I I think, like, I don't know if you've all seen the outcome of the the the poll which was, the feedback was only two people read the document. I think it would be good to get some more people to look at the document. Also, they cast it on the list or, like, the ones that you have lined up for implementation work. I think if they could also sort of chime in and and, indicate on why they why they think it's this is really useful work. Okay. Okay. Alright. Everyone excited for the last presentation of the last session of the week. Yeah. Thank you for that energy. Yeah. I think you are between the, your presentation is between the I looked. It doesn't start until, 4:45. I've I've got 25 minutes. So, like, settle in, folks. No. This is gonna be real quick. So, thanks for the chairs for giving me a minutes, even though he didn't get it drafted. Let's go to the next slide. I meant to make those two slides, but it's one slide. We were all familiar with this, like, normal job life cycle. You got a job. It's got an issue or a URL, and it used some discovery thing to look up metadata that gives you the JW case set that you're gonna to verify this thing. You trust that JW case set because you downloaded it from the Discover URL off from Isurion. Right. Hangs together. Ultimately ends up rooted in the web PKI. Right? Because you you did the HTTPS and you've verified the searching. Right? Keep that in mind for later. This pattern, you know, works great in a bunch of situations, right, especially, like, up on ID connect where everything's is, like, live and and you know, if if the if the, open ID providers down, then nothing works anyway. So So it works well in a lot of cases. Starting to see some things like verifiable credential issuance some of these, there's some"
  },
  {
    "startTime": "01:22:03",
    "text": "cases where folks are, signing containers with things related to ID tokens. Where the the the verification, situation separated from signing by a little bit more. So with a verifiable credential, for example, make it a credential and use it a couple hours later, a couple days later, where the, this discovery endpoint may not be available. It may be down. Maybe the key's been rotated in the meantime since your verifiable credential is issued. And the the JW case set, the the key that was used to sign this JWT is no longer in the GWK set. So, the idea we have here in the next slide, I think. Is to create these signed j JW case sets, just create a standard, like, format and that is the obvious way you would do this. You'll make another job that covers the key set. You stick an X Five C in there that roots the web PKI just like the HTTPS thing you, would do. So the trust structure remains exactly the same. And then you have if you have this artifacts, like, you can reason about whether this job that you care about is valid irrespective of whether this HTTP endpoint is up. So if you're a messaging provider and you're, passing these verifiable credentials around to authenticate to do end to end security, you can also have these signed JV case. It's much like an intermediate certificate for the open ID provider and pass those around alongside your your your verifiable credentials, and you know, nobody has to go bother the open ID provider to see what their keys are. Oh, there are some folks, you know, folks at Docker are doing some similar container registries. They wanna assemble, some kind of pickle a bunch of sign stuff together and time stamp it so that you can, in the future, you can kind of rewind your clock and say, at this time, this stuff was validly signed by the SIP and ID provider. So that's that's the idea here. Like I said, the sign in case that it's exactly as you'd back is just a jot with the JWK set inside of it and search, in the header."
  },
  {
    "startTime": "01:24:01",
    "text": "Next slide, please. So I post this to mailing list, Mike Jones. Helpfully pointed out that someone had already invented this, for purposes of federation, Only difference is that in federation, there's this whole hierarchy of you know, issuers authorizing issuers. And here, what we really care is that, you know, in cases like OpenID Connect, we care about the issuer being, the having a specific domain name or having a specific URL as we do. You know, in with the these, HTTPS web PKI sort of examples. And so the only difference between what we've written down here and stuff that's written down for federation is this X Five C thing. Where we have this reusable, redistributable, present, proof of authority. That the issuer, you know, actually owns the domain name that's in that issuer identifier. So it's it's, you know, it's issue our identifier in the in the, you know, full OS generalities, it required to be a domain name or URL. So we've got a little bit of a scope limitation but it maps to a lot of use cases. It has to open ID connect. And some of the STJPC stuff. And so it seemed like a useful thing to consider. So I I think well, this is super, super early stuff. It's it's in a GitHub repo. I haven't even gotten internet draft out, so not not asking who's read the draft, not asking who's, for adoption at this point, but just wanted to kinda put this out there and see if this is a thing that that folks would be open to, that folks you know, thought of, you know, with people issuing JOTS or open ID providers might be open to, see if there's, worth doing more work on. Yeah. Right. So I had two questions. This is Roe Williams. That's there's an all a lot of overlap. What it skits doing, to crane nutrise, things for with a timestamp and a policy. But the, thing that kinda sparks here is how do you do revocation in this model? If you declare the server down. Isn't this just for any permission for everyone? Yeah. I mean, there's there's sort of nothing new under the sun. Right? Like, this is in in the sense that this is making an intermediate certificate for an open ID provider or, you know, the JWT issue."
  },
  {
    "startTime": "01:26:00",
    "text": "You could you you could continue to use the HTTP based JV case at fetch as a revocation mechanism just like you would say OCSP. The difference would be that you can have the primary authentication and the revocation you know you know, you know, do the go ahead and do the primary authentication. And, you know, if the revocation information is offline, you handle it just like you handle an OCSP outage. But I I agree. Revocation is is a question here. It can also be managed with with the lifetime with these these GWK sets as well. I Justin Richard, I this is probably just me missing something, but What is the difference between this proposed structure and just using a certificate that is embedded in a jock set that just has the key values of that certificate. Oh, yeah. Good actually there there's point. Like, is there security property that's different? I section in the document that discusses this alternative design because I think in, sd.orsd.bc. There's some discussion of, like, just putting an 5c in the in the VC. Right. Yeah. I think the idea here was to not perturb the design of the jots that we have out there. Right? So the here, the the model of, you know, the sequence of keys that are involved and, you know, the the trust chain is the same as in the case where you're doing online discovery. Okay. And I I'm probably forgetting something. That's that's of it that the Okay. He has the same model. So so the X Five C is effectively the CA. Of and not that The thing it's not So, similarly, what we were putting in the X Five C is the search chain, a equivalent search chain, what you would present in HTTPS. Okay. Alright. I think I followed. Thank you. Yeah. Sure. Who's up next? - Mike Jones. I read the draft. Thank you. I obviously agree with large"
  },
  {
    "startTime": "01:28:00",
    "text": "parts of it. I'm gonna start by making Well, an observation and then a naming comment. People have been using sign JWK sets for at least 8 years. It's obvious how to do it. I'm gratified that you did it essentially the same way as, Open ID Federation does. We can argue about whether issued at or not before is the right claim. So just tell me what the right answer. And that's not the only place that to make brands, constantly. I think you want to highlight, possibly, in the title of the draft, that what this really invents and it's really doing is providing A way to validate A Jot Issuer using A Peacock certificate, to But without using TLS. Yeah. Yeah. Absolutely. What what this this is in a sense, an instance of a very you you can imagine this very generic transform between, I trust this thing because I download it from HTTPS. And I trust this thing because I signed it with an extra web PPI search. That's right. Yeah. Yeah. It was possible that there's, like, a a good, you know, security area general draft to be written in that I thought we've already done the specific instance here. Yeah. If you have some better naming suggestions, I'm I'm all ears. Because that that is you're correct. Like, replacing the HTTPS with an object this is the court of the Indiana? Yeah. I'll I'll think about naming. I mean, people loved sign genuine case, so I'm not surprised that You know, that's a positive. What you really wanna get people's eyes on is the mechanism for"
  },
  {
    "startTime": "01:30:00",
    "text": "validating the issuer with the certificate Yeah. Yeah. Thank you. Hi. Rowan May. So first of all, I I was, like, thinking about writing a draft like for a little bit, and I'm glad that Richard beat me to it. I read the draft. And, in response to the question about revocation, That certificate could contain a, serial distribution point extension, which would have a URL, which you would be expected to go and check. So just like you would do in the TLS case, you could also Do the do that follow that normal certificate revocation logic. To for the intermediate cert So nothing new there. It's all good. But I think the most important thing, like, we kind of were dancing around was why do you want on leak. The web PKI, from the identity Root, Of trust. And I mean, it's basically because The web UI For operational and business reasons, has never really allowed broad Delegation of the web PKI to down to certificate authorities that that mint you know, individual user certificates. And What? What what is collectively done in the OAF working group. Is to provide a way to, you know to provide authorization and meet you, and meet credentials, often at the individual user individual, role or computer level, And this gives a nice"
  },
  {
    "startTime": "01:32:01",
    "text": "clean interface between the web PKI authorization and then the your stuff goes here. So think it's really I useful. I Want to point out that we've ran out of time. Yep. We we another 13 minutes, the reception starts. But federal law prevents us from prohibiting the this this comments these comments have been helpful, so I appreciate them. To I'm just not even gonna wrap up, or you wanna let the you. Yeah. On, Ant and Ralph, I think we have to move that to the mailing list because I I don't want to Sir, push the limits to what we what we do here. And is that okay? And and Ralph? Sorry about that. I know you queued up and and everyone was talking along. But thanks a lot. For attending all these 3 OS working group sessions. And I'm looking for to see you again at the upcoming interim meetings and, we take it from there. Thank you. Brian, that looks really You spit coffee over the phone? And thanks also to the remote participants. Of."
  }
]
