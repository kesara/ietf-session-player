[
  {
    "startTime": "00:00:30",
    "text": "we need to get lost so we\u0027re still missing our primary note taker so I didn\u0027t went out to fetch so we\u0027re giving people couple of more minutes to come in join us yeah so we\u0027re two minutes over what do you think no no you have some explaining to do I actually thought of it you know before the meeting started I mean arrangements - oh it\u0027s okay I think a beer that\u0027s an excellent question I was blaming the screamer no well oh my menu bar is all wonky yes oh it\u0027s not just night shift its flux "
  },
  {
    "startTime": "00:03:54",
    "text": "super right so shall we welcome everybody and say that sure we have a note-taker we\u0027ll see if the next one gets here let\u0027s just maybe you can do the thing blue sheets yeah it\u0027s already back here yeah they stole the plane one lucious who\u0027s not signed blue sheets raise your hand okay okay look that way Chris those people need the first all the pen all right so Dave stole the boards and you stole the pen we have a lot of thieves of this both clipboards each clipboard had a pen when they would left here that\u0027s all I\u0027m saying all right let\u0027s go so fellows turban yes fiber insulin yeah good morning and welcome not to this stuff session at the ITF 101 for those who are new to this working group I mean this work you will be working on an abstract API where application does entail which transport to use rather get the transporter services by telling them what they want to do so this is not well I think most of us know about it if you not please have a look and also read about the web pages yeah so this is media hydrogen sharper and co-chairing the steps working group with our own phone hello so I think there will be it will be at two and a half hour long session and we\u0027re hoping and very exciting and involve discussions and presentations are on so this is an ad this is the agenda how doesn\u0027t look like anybody want to change anything yeah yeah sure in the interest of time to leave more room for the tap stuff that\u0027s gonna happen with Victor Jeff\u0027s probably gonna cut my talk down just slightly just yeah I miss finding yourself do you just need to hang out since you\u0027re up at the front yeah it\u0027s easy we don\u0027t have to reschedule anything you know I\u0027ll just move on yeah that\u0027s true that\u0027s true we just haven\u0027t changed so you know so "
  },
  {
    "startTime": "00:07:07",
    "text": "it was actually more than formal it is yes so okay so a little bit of update on what\u0027s going on the working group first are our second and third documents have been published so we\u0027ve got three RFC\u0027s out now which I frankly I\u0027m a little bit surprised we\u0027ve gotten this far but I continue to feel better about this group every meeting we get so you guys have stepped up and you know taking something all the way through our receiver acquires really like some follow-through and dedication so thank you very much to the authors for getting the news out the door is that this actually was was hard I mean if it does of you who were here it was there\u0027s some not a laborious analysis that required so Thanks so as we talked about in last couple meetings we have revised the Charter there are two there\u0027s a few knits which you can see on the data tracker but the two most important bits are one we have a new and entry on our scope of work about looking at transport security protocols the new text is here that we\u0027re going to analyze compare and contrast properties and dependencies of selected IETF transport security protocols and other relevant security protocols as agreed upon by the working group participants define a set of security related transport services provided by such protocols engage with security area to solicit feedback and reviews on all relevant documents so you know anything that crosses from the transport tribe to another tribe like the security tribe is always a little thorny in getting agreement and so this took a few rounds of through IHG review but actually once we got the wording right everybody was in supportive of it so so I think this is more good work the other thing that we did which is when we first charted the group we were going to we set the bar kind of low we said we\u0027re going to produce basically informational documents and I think that everybody\u0027s confidence is higher and I think that the focus is really things are converging to the point that we felt comfortable proposing that the final output of the working group is going to be a set of proposed standards so I think that\u0027s good too that taps will be a standard not that we can force anybody implement it but we\u0027ll make a standard we updated the schedule so the security document we\u0027d like to get done by next ITF the min set document which is I think is probably going to be influenced by the security document so that\u0027s sort of folded in after binds to partition okay thank you thank you for money I knew that there was a relationship there thank you for pointing that okay well baby in the interest of not trying to walk and chew gum we\u0027re going to focus "
  },
  {
    "startTime": "00:10:08",
    "text": "on one thing one milestone at a meeting and then the remainder of the documents are in in 2019 and then we figure out what happens next so so that\u0027s it for the chairs comments just to bring the agenda back up here so you can see it that\u0027s I don\u0027t think that\u0027s my fault let\u0027s just agree okay so first Chris is going to because he has to leave soon is going to come and talk about the security protocols and you sent me just PDF right yeah okay see we can make that work all right morning everyone my name is Chris wood I\u0027m from Apple I\u0027m gonna give you an update on the secure drop that we\u0027ve been working on for a while now with Tommy follow the kallenberg and Kairos slide please so the point of this document is pretty straightforward similar to the transport services the RFC\u0027s that we\u0027ve already put out we want to look at the services that are provided by Transport security protocols the interface is that these protocols have them to provide in which we would like to incorporate in the new taps architecture so the I guess outline of the document follows this these three simple points here we go through and surveys a bunch of existing transport security protocols both within the ITF and outside of the ITF extract what we deemed the mandatory features and optionally the optional features as well and then identify these common interfaces such that if you were to integrate or implement these protocols within the context of a taps architecture they could just kind of slide in and applications can make use of them so they need to know if they\u0027re using TLS for something specific they just need to know how to do transport security things next slide please so the scope is kind of important here for any security or any survey draft so although the Charter text says that we\u0027re going to be looking strictly at ITF protocols the document itself considers those both in the ITF and outside the ITF in particular because there\u0027s a lot of innovation that kind of happens with security protocols outside of the ITF and there are many things that don\u0027t have RFC\u0027s that should be looked at if we\u0027re going to kind of help the new generic API that could be used by any and all applications in the future and additionally in whitson scope work like I said we\u0027re gonna be analyzing these new transport security protocols potentially in collaboration with the security area to make sure that we identify what we deem or what we deem is say a mandatory future or a necessary interface is actually a mandatory and necessary interface because those are the main experts there we\u0027re gonna make sure we get that information correct "
  },
  {
    "startTime": "00:13:09",
    "text": "what\u0027s out of scope is absolutely any kind of recommendation for which protocol or algorithm to use or I can say you must use you know cha-cha follow your AES GCM whatever or TLS 1.3 instead of quick or you know pick your poison I guess but we\u0027re also not going to be building any new protocols because that\u0027s the job and responsibility of those that are not in the transport area so if you do happen to find any text that resembles anything of those two points in the draft please call it out and we will promptly remove it next slide please so a little bit of history here back in Chicago I believe was the first time took an action item to start looking at the security properties of existing transport security protocols and the ITF 99 we produced the zero zero version which included just a base set things like TLS minimal T which is a non IDF protocol courtesy P also non IDF protocol PCP crypt and IP to DSP the next site EF we rubbed it and add more things in particular SRTP based on D to us and wire guard also not IETF vertical and recently we just added Google quick and there are many meaning outstanding issues to keep adding more and more verticals we\u0027re trying to be as it\u0027s my goal to be as I guess to get maximum coverage with all the verticals that are in existence and that does not make us fall out of alignment with the Charter text so expect at the next ITF where we hope to be done there will be more protocols here and hopefully they will be representative of what the Internet at large uses for Transport Security next slide please so the methodology within the draft is I guess fairly straightforward we try to decouple the relevant bits of the transport security protocols that we\u0027re looking at in particular we try to focus on what we consider to be the handshake parts of a protocol and the record or framing parts of a protocol this is important because some don\u0027t have both for example ESB doesn\u0027t have a handshake it\u0027s just pretty much a record protocol with some framing give it a key and you encrypt datagrams and it goes the other side and some protocols just don\u0027t have any kind of framing built in them whatsoever I mentioned noise here which is not technically protocol it\u0027s a protocol framework but that\u0027s purely about building you know key exchange handshake protocols has nothing to do or talks nothing about how you actually encode messages and send in to the other side so we want to make sure we distinguish between the two additionally we\u0027re trying to focus strictly on the interface of these protocols as specified and hopefully soon as implemented because there is a bit of a delta there and practice quite often we don\u0027t care necessarily about what the "
  },
  {
    "startTime": "00:16:09",
    "text": "implementation details we just want to make sure that we get the interface correct and this is analogous to the endeavour and the goals of the transport services or the transport services RFC eighty or ninety five next slide please so when looking at these different protocols we don\u0027t really we\u0027re not restricting them to any player in the stack so for example like USB and wire guard far away at the bottom right about the internet layer and then things like DT OS TLS and quic can exist up at the session layer and we might even creep up as far as you know looking at application layer TLS if we feel so advantageous because that\u0027s yet another transport security protocol but don\u0027t quote me on that I may change my mind so the point here being we\u0027re not trying to focus on one particular layer because the interface at are for each of these particular protocols is fairly common regardless or yeah I guess regardless of its position in this stack I slide please and before I guess I go into some of the features it\u0027s worth kind of commenting on how the I would envision the security protocol sort of fit into the taps architecture which everyone will go into much more detail later on in general the goal is to kind of abstract away the the specific security protocol on use inside this steps architecture black box here and then at various points during the applications use of the tap system use different interfaces to either configure or dynamically you know tune or I guess update the protocol in action so for example if you dress protocol or the security protocol calls out to the application to validate certificate from a peer you would do that kind of during the online connection setup phase and then you use a different set of interfaces when the connection is actually established you need to read my data or you want to get actually metadata properties from the security protocol configuration and the API that the API that we\u0027re striving for would map to the specific implementation API that\u0027s inside the taps architecture for example the security API that exists at a player would map to how you would drive TLS you know internally so for example if you were to set a private key and within the taps layer it just would set a private key for TLS a specific specific use if you were to set a specific algorithm that you might want to use for you know encryption or whatever that would set a specific cipher suite in TLS internally so applications are it kind of like ideally unaware of which specific protocols and use they just know that I have these specific security properties here\u0027s how I configure them here\u0027s how I here\u0027s what I have to do you know during connection establishment and here\u0027s what I can do when the connection is established and what I can do when I want to tear it down so next slide please so in looking at all these different protocols these are the relevant handshake features that came out "
  },
  {
    "startTime": "00:19:10",
    "text": "obviously if we\u0027re gonna be doing any kind of authentication the handshake must support the ability to kind of inject the private key or at least provide an interface to a private key so if it the private key stored in the hardware you know HSM or an enclave or something like that it\u0027s necessary for the specific invitation be able to access that private key to perform a digital signature or something it\u0027s absolutely mandatory that the handshake work I\u0027ll be able to authenticate the peer or the remote in this case so that you know who you\u0027re speaking to and it must be able to validate the source of a connection so for example many DTLS implementations or DLT on spec it I think it strictly or I think it lissa as an optional thing to do if it\u0027s under heavy load a DTR server can provide cookie back to the client and the client must I got my cookie back there\u0027s a way of validating that the packet came from you know some particular specific source and it\u0027s not being spoofed and flooded with you know just garbage and shake or client hello packets so the TLS you don\u0027t worry about this because you\u0027re built on top of TCP and you kind of have that implicitly you know supply for you but you know because many protocols add this feature in after the fact we consider it to be a mandatory thing that the handshake should provide optionally we would like to support mutual authentication that\u0027s not something that every single protocol does but it\u0027s quite common so for example TLS obviously provides client and server authentication application layer feature negotiation it\u0027s also something that\u0027s quite common so TLS provides the alp an extension to negotiate which application layer protocol will run on top of TLS whether it be h2 or quick or whatever being able to add extensions to the handshake protocol is also pretty common although not mandatory so some things like wire guard or absolutely not extensible in any way shape or form but TLS so you can just extend it for days and do whatever you want provided that you know no one yells at you when you present your extension it the Mike I fir back to the earlier meeting this week and being able to kind of cache previously negotiated session and state material was also quite common but again not essential to the operation of the handshake protocol it\u0027s just kind of an optimization that really helps move things along and managing that stay is also pretty important like if you want to be able to flush it on demand you should be able to do that and so on thank you we\u0027ve joined and that\u0027s me the whole time realize it I didn\u0027t see it from the record side because the the purpose of the record protocol is quite simple the features that we must support are obviously very small for example you should be able to import or you know given a key encryption datagrams and send them in I kind of said "
  },
  {
    "startTime": "00:22:12",
    "text": "together you should be able to encrypt on authenticate any kind of Datagram or segment here I guess one outstanding issue attacks we could address this kind of unifying the terms that were kind of I\u0027m throwing around here is a record segment whatever Datagram it\u0027d be used to we should agree on what these terms should be additionally optionally it\u0027s the connection of milk mobility feature so some I guess more recent record like wire format for example provide the ability to specify a connection identifier which allows you know the entire session to move about if you have and that remaining or for typical change not all a record verticals have this particular wire format and so it\u0027s not mandatory but it is a nice thing to have and many you know many protocols do offer this sort of thing so onto the interface is necessary to drive these certain features and as I was pointing back earlier in the you know the taps architecture slide there\u0027s kind of two there\u0027s really three distinct phases in which you interact with the protocol there\u0027s the configurations stage at during the pre connection setup time there\u0027s the active kind of interfaces that you must work with during the connections phase and then there\u0027s the interface that you can invoke and use once the connection is established so during configuration this is the time when you know you actually tell the security protocol here\u0027s everything you might need to do to or might need to use in order to set up a connection so if you\u0027re a server for example you might need to specify a private key otherwise you can\u0027t do anything and talk to anyone you may need to provide what you\u0027re supported algorithms are and a delegate though I call back essentially to be invoked if you want to authenticate or do any kind of peer validation and you might also want to like specify parameters for the session cache if one such exists now all this is not necessarily something that applications would need to do particular authentication delegation session cache management and support algorithms in in practice it would be nice if those were things that are just handled by the system by default you know you have a good set of agreed-upon algorithms that you know the system considers safe there is a the tap system itself manages the session cash in the application is absolutely nothing to do with it and you know validating a peer or something that\u0027s kind of deferred to you know the system itself now there are cases where applications may want to override your validation like if they\u0027re doing certificate pinning and maybe that\u0027s not easy to do so in this case you might need to interface with it but absolutely things like private keys and identities those are not things that are you know the system can just guess which ones it wants to use at random pull something out of the keychain hat and then use it you need to be specific here for the handshake handshake bits if you\u0027re called the api\u0027s at the taps layer would go down to the api\u0027s at the security "
  },
  {
    "startTime": "00:25:12",
    "text": "protocol which drive the handshake bit of the protocol and then drive the record bit of vertigo need to obviously be able to send and receive handshake messages I think that\u0027s fairly obvious you feel they validate the identity of the peer perform the source address validation these features that I was mentioning earlier additionally providing an interface for key updates is quite useful so for example when the connection is established you get an update that you have a new key available and then tell us or the application that\u0027s built on top with us might extract that pre shared key and use it for other purposes quick for example it does exactly this and you know the pre sure key export interface goes along with that key update interface so thank you so fairly straightforward the record interface again because it\u0027s quite simple the interface is also pretty lightweight it should be able to import a PSK and then use it to encrypt application data or do you clip the application data depending on what you\u0027re doing it would be nice if you know so this is not something at all I guess record protocol implementations support but it would be nice if the record protocol itself kept track of what the maximum number of bytes I can encrypt with this key is and then tell you the application when the key is expired you can no longer use it because certain cipher suites do have a bound on the number of data you can encrypt and a bound on the maximum number or back size of a message you can encrypt so ideally the record protocol kind of manage that for you in that book is not burdened with the you know keeping making sure that it\u0027s doing things safely so having you know this sort of interface helps and being able to have an interface to support trans more mobility by specifying a connection identifier whether you\u0027re it\u0027s one that you receive from your peer or one that you generate on your own is of course useful for the optional feature of transport or ability I I broke it oh okay so I include you to go look at the draft it\u0027s it\u0027s survey so there\u0027s a lot of information there and there\u0027s certainly room for improvement in particular there are several outstanding issues we\u0027d like to kind of unify the document structures the point raised by Kyle there are some instances where we don\u0027t follow the same convention and how we describe certain features and certain interfaces of a protocol and how we kind of pull things together at the end so I don\u0027t know maybe you guys plan to work on that in the end or I don\u0027t want to volunteer for anything but okay all right we\u0027d also like to expand the security considerations in particular this is where all the output from the interaction with the security community would go working with them to make sure that we get the text right about what we should and should not say about usage of these security protocols and whatnot because right now it\u0027s kind of light another thing that I kind of alluded to earlier is and this is sort of a made a "
  },
  {
    "startTime": "00:28:12",
    "text": "bigger task is to identify the Delta between protocol implementations and there you know standardized you know what the standards say because that will help us kind of identify any missing gaps that may be missing from the interface and we may want to include four you know I guess being more or getting greater coverage and getting things more correct so next steps are you still waiting until the end okay so next ups because this is now in the Charter that we\u0027d like to call for working group adoption of this particular draft and continue just hammering out and adding these new protocols as needed there\u0027s a bunch of issues here so if you feel so inclined to tackle one boat requests are absolutely welcome and I don\u0027t know if I have a link to the repository but I can certainly circulate once the list and everyone can submit their poll requests there and then in tandem commence the reviews at the security area because we want to get that ball rolling depending on how long it may or may not take and I think that\u0027s in so Kyle Kyle Rose is this on yes okay like I can\u0027t hear it very well yeah it\u0027s not on you tap it yeah it\u0027s on okay yeah very low okay so in the process of working on this document I think there\u0027s one thing that\u0027s been making me a little bit uneasy and I in conversations with Aaron I got kind of the same the same feeling from him it\u0027s about scope and scope creep and I feel like so one of the things that you said early on in the presentation was well we\u0027re gonna cover everything right and it\u0027s like well I mean are we gonna cover every security protocol that like you know some shmo like put together when they were 23 year old brought their team over further here at Akamai and you know that\u0027s but anyway right it\u0027s just so like I think I think I\u0027m wondering if as devil\u0027s advocate a better approach might be to just make sure that we choose enough protocols to analyze where recover the set of the basically where we where we can determine what the set of features that each of these protocols might have and then maybe and then maybe from that derive a set of shim interfaces that are required as a as an interface to taps itself right so essentially if if some let\u0027s say some some security protocol is lacks an automatic mechanism for key rotation after a certain number of records have been encrypted right you could you can imagine a shim layer between that and the rest of taps that says all right at this point we are going to force a renegotiation or something like that to to cover that requirement sure so I\u0027m just there like two questions kind of "
  },
  {
    "startTime": "00:31:13",
    "text": "you know connected there and I\u0027m not sure what the right way to go is but I think that if we try to go for everything we\u0027re never gonna get this done yeah very good point I think in looking at the implementations that will kind of help us really confirm or deny whether or not we got the selection correct that is to say if we started looking implementations of like Tila stacks that are not our own and we find out that there\u0027s there\u0027s these massive features that like just are not in the standard but everyone does like that will kind of that that\u0027s a good indication that there is a gap in the protocols that we selected and maybe it was provided by a different protocol that was not DLS but it\u0027s there it needs to be covered so I I think there are the outstanding issues that are on the github tracker to add a bunch of these new protocols are there\u0027s quite a number of them and we could certainly just say okay for now let\u0027s just stick to the ones we have maybe look at some of when tations to see if anything pops up and if it does maybe then increase the scope a little bit but again I\u0027m not quite sure that that\u0027s the right approach I mean people who worked on these surveys in the past I of course open to suggestions I know that we need to be sensitive to the time especially if we want to get this done by next idea so I write well I mean you can you could go as far up in the stack as you want right you were saying application level protocols what does like envoy qualify as a security protocol not really it\u0027s like a communication framework it uses some protocols it\u0027s sort of taps like in a sense but where you know where do you stop and it seems like it seems like what you want is to is to choose a set of protocols from which you can from which you can then kind of distill out what are the important features that a that the tap Slayer is going to need and which protocols can be kind of retrofitted to have all of those if they don\u0027t have them natively I agree I also agree that like like separating the handshake and record protocols might make sense because in a sense right TLS and DTLS are the same protocol at the handshake layer right but it\u0027s at the record layer where they differ and that might make a difference to which transport you choose when you\u0027re deciding well you know when you\u0027re deciding between say you know messages that don\u0027t require reliability and the stream but it\u0027s but does the is the handshake really different or the security property is really different not I mean a little bit but I asked what you said and of course we yeah in theory him principle I agree with what you\u0027re saying I just it you know yeah acting on is it\u0027s not clear to me yeah hi I\u0027m Brian Trammell in favor of adoption the question about scope I "
  },
  {
    "startTime": "00:34:13",
    "text": "think that we could go we and by we I mean you I guess document could go relatively quickly through that list of open issues and do a relatively quick judgment call as to whether you\u0027re not you\u0027re gonna get something into the set of sort of interface characteristics by adding a protocol right so so looking back at 80 95 it has a gigantic glaring omission it doesn\u0027t talk at all about quick um but adding quick wouldn\u0027t actually bring anything because quick doesn\u0027t add any new on transfer protocol features that you know aren\u0027t already in this set of trends or protocols that we\u0027ve looked at so I think and go relatively quickly through that you can even have in the document saying scope you know we chose these as representative we looked at a bunch of other ones very quickly here are some references to them they don\u0027t add anything to the to what we have here I had two questions one is a buzz word troll question from Twitter sharam post quantum Krypto - I don\u0027t think that I don\u0027t think that\u0027ll change anything no in terms of okay good um is it deployed on the Internet is that what you\u0027re yeah deploy it on the Internet yeah that\u0027s the great great yeah well I mean that so these things can change quickly great I mean one or two events will thrive that will still be here okay I mean Chrome\u0027s doing it keep it here a while comes determines the post cost question I noticed there\u0027s a split between sort of handshake phase handshake layer record layer this very TLS terminology is is something that exists in the other protocols are you applying TLS terminology to the other particles no in the crypto sub document for example we kind of rephrased everything and we refer to the handshake is the control protocol the record protocol is the record protocol okay I mean record protocol is kind of accepted yeah algae in the space okay but handshake and record that\u0027s fine but but I just wanna make sure that that\u0027s not injecting sort of a TLS ism into how you frame thinking about other protocols yeah don\u0027t separate that way it seems a very natural way to separate it\u0027s like you got to get the key material and you got to do something later and it\u0027s fine to call in handshaking record but um okay so that satisfies me yes um let\u0027s let\u0027s do it cool Aaron yeah so first great document thank you for pulling this together I\u0027m Erin Faulk occupying also co-chair the working group not sure if I\u0027m wearing my sure hat but as a as a a reader of the document I thought that it was it\u0027s good on the issue of which protocols to include on the scope I think this is an area where we want to get input from the security area um you know transport shouldn\u0027t be saying what the important security protocols are in the internet they might have opinions that you know or you know I already said we don\u0027t appreciate in this room so maybe I don\u0027t know if it\u0027s the security Directorate but let\u0027s make sure that that communication happens early on so that it doesn\u0027t end up becoming a delay for the document when they absolutely there\u0027s a surprise the other thing is can you go to that your your picture that had the all the different security "
  },
  {
    "startTime": "00:37:13",
    "text": "protocols on it another one before that\u0027s this one so I\u0027m trying to take that picture and now go to the next slide and I\u0027m trying to squeeze all those protocols somewhere into this picture and so it looks to me like what you\u0027re doing is you\u0027re moving the API however high up you need to go so that all the security protocols fall inside it is that true or is this actually not as clean as you drive so in practice we would likely go up as up this high essentially we want to include at least these protocols whether or not we push it up even higher is open for debate and likely will not my comment about going up higher and you know looking at things higher up the stack was strictly to kind of tease out any other features that we might be missing the goal of what we\u0027re trying to do here is allow people to write applications that sit on top of this thing right yeah I mean I think of it as on top of this thing because I\u0027m a protocols guy but I think people who actually write code thing but is elaborates it\u0027s off to the side and so they may not have as clean a separation but I think that if we\u0027re not going to have it but like sort of a you know a vertical layering and saying we\u0027re gonna give you an API and you do all your stuff above it and you call whatever you need from the network down below I think that that may eliminate some things from the list because there might be some things where you actually you know it is an application and it needs to be tightly involved in this right I\u0027m sort of going on company\u0027ll here but it seems to me like like work to a little bit we\u0027re when it was TLS okay it\u0027s easy to see they\u0027ve got the shim that sits on top of the transport protocols but now we\u0027re kind of working our way up yeah this is definitely another area to scope that\u0027s kind of fuzzy like this this line is quite large as so I\u0027m no longer confident were gonna finish by the next idea but I don\u0027t think we should ask the thing sorry quality Apple to the point of what protocols are in scope and level here I think we should limit it essentially to the type of things we have that are like TLS or DTLS even if they\u0027re not considered to be truly transport protocols generally they are essentially just providing a pseudo transport layer with extra functionality involved in them but the applications relationship with reading writing on them is essentially the relationship of an application to a transport do you think you could come up with a test that you can apply to a security protocol to see whether it\u0027s in or out of the set that\u0027s what I was in my email comments that\u0027s what I was trying to get to okay that would be good we could even essentially just define that in the document saying that the we are considering security protocols that behave like transports when the application uses them let\u0027s take that down the notes but Texas effectively but that\u0027s alright I think implicitly we\u0027re thinking of that in the back of our heads but it\u0027s not spelled out yeah well to agree we don\u0027t need to be exhaustive well I think we should be definitely willing to take any non idea protocols and put them in an appendix especially if they are not adding anything to the surface just tremendous the the updated "
  },
  {
    "startTime": "00:40:15",
    "text": "- term says like it\u0027s a limited set of ID protocol as well so who might be possible as a mighty protocol going to the appendix as well so when you are setting up the test you need to also come up with like it\u0027s not about only then non idea protocol it might be including idea protocols yep according to the text in the shuttle yep the one other point I wanted to bring up is how quick has a very interesting discussion earlier this week regarding the relationship of TLS and the security layering to the quic protocol unclear exactly how all of that is going to land we do have analysis of the current IETF quick as of like what the documents say today in this document if that\u0027s in flux I\u0027m not sure how we should reflect that in the document yeah I think an easy way to deal with this as we get it as far as we can and then we let the document rest I don\u0027t think there\u0027s there\u0027s huge value in pushing it through as an RFC as soon as possible I just want only get the work done so we can move on and make sure that the API stuff incorporates what we know and we can go back and revise it later I don\u0027t see that\u0027s great also I think the stream zero problem was I don\u0027t recall correctly what the text was or what was said in the meeting but my understanding was that they would hope to have this kind of resolve why the next idea so you know maybe the two are aligned in this textbook on you know solidify itself and we can just kind of stick with it whether it be we now layer on top of G to us or we stick with what we\u0027re doing so regarding quick I mean the the crypto protocol for Crick is still TLS right so that is covered yes the handshake is the same the record layer is not the same but sorry all we need to say that this architect exits right that which were not really change we don\u0027t need to go into further details about quick yeah I don\u0027t recall exactly what it says but we will probably need to wear it Smith it a little bit out of time for the signal oh yeah and you\u0027re gonna be short that I thought so you worried there was all the discussions all right thank you Chris yep thanks okay okay next on the agenda Michael Watts all Michael do you need me to show your PowerPoint or can I show the PDF oh I think I\u0027ve got are they the same cuz I\u0027ve got the PowerPoint queued up all right that\u0027s a I think minimally mejia minimal time presentation with a minimum number of slides for a minimal document next slide please Thanks last couple seconds yeah okay so "
  },
  {
    "startTime": "00:43:20",
    "text": "two updates happened to this document since since the last meeting and I would classify all of them as editorial so this was the first one was addressing the comments we got at the last idea and with a few emails later for instance one comment was that we should not talk about falling back to TCP and UDP but we got them you know as members of a set so this is just in you know a text change really it doesn\u0027t talk about fallback to TCP or UDP anymore it says implementation over it\u0027s a kind of intelligent search and replace operations right because it\u0027s not exactly everywhere exactly like that but doesn\u0027t say falling back removed references to burst burst occurs they were in there that did say that post office requires a system on both sides to function because that was my understanding of it at that time and the replaced flow with taps connection which again is on the next slide changed into something else but I was for this update and frame with message so the point was here to try to avoid introducing new terminology that have been introduced to essentially convey that there is a higher-level notion of a connection in taps that may actually be a stream of transport or a connection and section three and four were made in line with the categorization that\u0027s already used in the appendix and this RCA 303 and we changed the style of Section four to be shorter less the interface like II and updated the reference and then came some comments from Miriah asking to replace well to get rid of some some extra terminology so there is no more the tap system and the taps connection this is now really replaced with transport system and connection I think the document doesn\u0027t actually use any new terminology anymore now just refers to the you know the uses words off of the protocols that it is based upon and section three and four finally managed to relieve merge together into one section C and then there were a few editorial knits and that was it what next so what question going back to the discussion that we had my misstatement about that min said earlier is there anything in the document now that talks about that might link to a separate discussion about security protocols no so there is text saying that there is some text in the appendix deriving things related to security that that are there you know in the protocols authentication and so on then there is text saying that in the min set that is being proposed here this is all excluded because there\u0027s a companion document talking about security as reference is that so I don\u0027t think in the in the security document there\u0027s any discussion of what a minimum taps implementation needs to support do we okay so do we think that there that a minimum taps implementation must secure support some security protocols in order to be "
  },
  {
    "startTime": "00:46:20",
    "text": "called taps if we\u0027re going to say that if we believe that we should say it somewhere this document is one place to say it or we could say in the security document then and then put a statement in here that says we address the minimum security requirements inside the document but it seems to me that if we believe that you if you\u0027re going to do taps you have toward some security protocols we have to say it somewhere Brian Trammell meeting the mic I think we do need to say that it\u0027s an implementation requirement given sort of a pattern of the rest of the documents we were kind of putting security on the side afterward and then we\u0027re gonna tell people don\u0027t put security on the side like we did in these documents but the most logical so the so draft is it drop water drop Holly but yeah so Chris\u0027s document that Chris just presented seems to basically be um eighty ninety five plus men set for security and I think that we should do it that way right so there\u0027s this recommendation on security should be there min said should have a reference to the security documentation to us yeah so yeah so I think we\u0027re fine I don\u0027t think we need to but I think let me separate specifically the reference should say the minimum requirements for a tap system are specified in this other document yes I wrote a minimum security requirements it doesn\u0027t say a dozen all those yes sir just to clarify Kyle Rose just to clarify you can imagine I just want to know what what is what the thinking here is you can imagine a a system using taps that has sufficient security built into it right that it only needs a it only needs a way to get packets across the Internet is that intended to be supported here or is there or are there going to be minimum security quiet requirements on every transport that will essentially require say double encryption or something like that I don\u0027t think I don\u0027t think I should be answering that I mean I\u0027m just having stronger opinions about these things so that they general maybe Tommy is giving me this book so maybe I\u0027m not being clear so yeah because there\u0027s a way of you know to derive what is supposed to be the minimum in the minimum set and that applies to things there but then secure the stuff is pointed at the other document so I think should be done decided yes for the usage document we have a separate so this is actually not a question towards the mean set but rather security draft for the usage documents we have a separation now with sorry for them we have a separation between min set and usage document for the let\u0027s say non security features do "
  },
  {
    "startTime": "00:49:22",
    "text": "we need the same separation for the security features will just be just docked the one document covering both yeah that was the thing that I was trying to explore and what I got from the people who\u0027ve been working on the other document was that that one document could cover both I don\u0027t see a lot of value in having two documents I mean if it\u0027s two different sets of people then it might make sense but I that\u0027s my that\u0027s my personal opinion I think we should just clarify this I have no opinions for either one mm-hmm Tommy Polly Apple yeah I think looking at the security set what we\u0027ve distilled of what Chris presented is I think a lot smaller than the set of all of the transport features that were analyzed it\u0027s it\u0027s already more minimal as I think it requires fewer stages of distillation had we encountered the same thing with the transport features between UDP TCP sctv etc and they had all come together more neatly then we wouldn\u0027t have needed all the documents you could even I have a separate question so the decision tree in the diagram what\u0027s the plan for that one oh it\u0027s it\u0027s the plans to stay as an example it\u0027s just how you know to give an idea of what you can do with these things or how you would make to have a decision in the beginning I think just putting a list there doesn\u0027t help anybody really to understand how we choose the course I can if it doesn\u0027t say example then I include the example estimate that\u0027s the meaning I just wanted to go back to the previous um the conversation to reiterate I think that one of the reasons we did the sort of three stage documents is that we didn\u0027t quite know what the process was going to be for making these decisions when we started so it\u0027s like let\u0027s do all the homework and one of the things that has come out of this process is we understand how to do the process now great and we understand how to say okay well you know from from the large to the small so I really think the security thing can be faster I share Erin\u0027s skepticism that\u0027ll be done before Montreal but maybe right after yeah okay sounds like we\u0027re having an agreement so I think that so I guess my conclusion from the status is sounds like you\u0027re done should we last call this document please okay can I can i yeah yeah it\u0027s a toy yeah with the decision tree is mentioned as an example if it isn\u0027t and your phrasing of the point to the security documents okay let\u0027s let\u0027s take a home in the room who in this room thinks the min set document is ready for last call who in this room thinks this document is not ready for last call who hasn\u0027t read the document what okay so so I think well we\u0027ll do a worker "
  },
  {
    "startTime": "00:52:23",
    "text": "group last call that might cause people haven\u0027t looked at in a while to look at it and thank you Michael thank you well no I I thought we had adopted that and I\u0027m am I mistaken well it seems like that\u0027s kind of an important call for working group adoption well yeah well that\u0027s why we needed it in the Charter now it\u0027s in the Charter now we can adopt it okay let\u0027s take a hum so hum for people who think that we should adopt the Security document in this working group okay come from a people who think we should not adopt the Security document come from people who have no idea what we\u0027re talking about not what I expected okay excellent all right Tom can you make sure that gets into the minutes thank you okay I\u0027m running one yeah yeah right well we\u0027ll take it both we\u0027ll take it to the mailing list as well thank you for right okay are we on time let\u0027s see it says thirty five forty five minutes and we are about five minutes late okay so did you need me to show your keynote slides or is a PowerPoint okay okay and let\u0027s see if I can oh but guess what that\u0027s what I\u0027ve got let\u0027s see what happens when I fire it up sideshow yeah all right hello everyone I\u0027m told thank you I\u0027m Tori Pauley and this is going to be the first of a trilogy so we have three new documents that have been published and these are all aimed at the milestones coming after min set and coming after the trans persecutory survey trying to synthesize all the things that we\u0027ve learned from the surveys and min sets etc and unify the approaches to how we go on from there so again as we said there are three documents this is the first one it\u0027s just about the architecture fairly high-level aimed at introducing everyone to these concepts so to recap from last time there\u0027s a lot of discussion about what are we going to do about what was milestone 3 at that point so that last milestone is all about how do we define mechanisms to allow a transport system to be actually deployed to be defined to be used by applications and as of last time there were several documents which were all in this area describing various aspects of it so we had the meet document which described the whole neat system we had the post office document which was the bright new vision of how we go on beyond sockets I had the document on guidelines for how "
  },
  {
    "startTime": "00:55:24",
    "text": "we do racing of various levels inside an implementation between racing endpoints paths etc happy eyeballs on steroids we had the other taps happy eyeballs document which went into just how you\u0027re racing the protocols especially for SCTP and the experience done there and we also have these socket intents about how applications can specify the the Preferences and types of properties they want from their transport to end up selecting the correct transferring the correct path so these are all very related they all cover different parts and we all had useful things to bring to the table so how do we reconcile these and combine the efforts so we sat down and thought long and hard about it and we roped in all of the authors from those documents to try to get together and hammer out something so the proposal and this was taken to the list back in January I think was to distill the work from these into three new drafts one being the architecture draft this is to explain the whole approach what are the basic concepts I think of the audience here as essentially the IETF community and coming to this with new eyes essentially what are we trying to approach here there is the interface or API document which explains in detail how the applications that we\u0027ll be using transport services actually use this system what is the abstract non language specific API into this and so the audience there mainly is developers who want to write apps to use transport level services and then there\u0027s the implementation document which I think covers all the things that had been lacking in the previous descriptions to explain really in detail how do you actually implement a system such that you take this interface and you apply it into you know real code that is actually taking the protocols and looking at how do we apply these various interface aspects to each protocol and to each approach as we are doing racing of protocols etc so that\u0027s what we decided to do so the architecture draft mainly has two parts in it it\u0027s relatively short compared to the others it has a design principle section which covers the constraints on the approach what are the guidelines we\u0027ve given ourselves when working on this to make sure that we\u0027re coming up with something that makes sense that\u0027s reasonable and also future proof and this is based on the surveys that have been previously done it\u0027s based on the men set and it expresses essentially that history there and what we\u0027re trying to do and then the second section is more just like a list laundry list of concepts and terminology that define the framework that we\u0027re working in that define concepts that hopefully can be used both in the API documents and the interface document and potentially may seep into implementations "
  },
  {
    "startTime": "00:58:24",
    "text": "as a development and so the API concepts are things that our concepts that we expect to be exposed to the applications and then there are concepts that we believe at least at this point are more specific to implementations and not really driven towards applications but contained within a tap system itself so for the rest of this I just kind of wanted to go over what our principles and concepts are so we can all have an introduction to them if you have any thoughts clarifying questions come up now if we have general discussion we can leave that to the end because we\u0027re going to do three presentations here of the whole sweep so if the first principle is that we want common api\u0027s for common features between protocols this is pretty simple I think this is very much in the spirit of what taps has been about the whole time so when we have a common operation across multiple protocols we should be using that same API for these common operations something as simple as what I need to send data over my transport it should be the same send call whether or not it is TCP or TLS the goal is to write your code once and reuse across multiple protocols that doesn\u0027t necessarily imply anything about are these things switching out underneath me but I want to just write my basic code for how I use my transport a single time and maybe it automatically switches over to some new protocols maybe I recompile with new options but it\u0027s the same code and this common set must at least include the minimal set defined in min set so that\u0027s principle one principle two is that we do need to provide access to specialized features and the way we do that needs to be carefully done so if you have a non generic protocol option it does need to have need to have some way to be set otherwise a lot of applications will not find this very useful if they can\u0027t set their UDP checksum specific option we want this to be not less useful than sockets or older interfaces however the protocol specific features do need to be exposed in a way that they do not limit protocol selection or protocol flexibility going forward one way of doing this is to say if you need a protocol specific option if you use that protocol protocol X use the options specific to that protocol but do not prescribe on the entire connection you must use Datagram checksums I\u0027m only saying if you use UDP you need this feature certain specific features however like I could say I need security on this I need to make sure this is at least using AES blah blah blah those may end up limiting protocol selection because there are important ramifications that come from degrading your security third principle is just talking about the scope for the API and implementations going forward so the API must include at least min set so we have "
  },
  {
    "startTime": "01:01:25",
    "text": "to be able to do basic TCP and UDP operations here however not all implementations must implement all of the protocol features so you could imagine there could be some IOT devices that don\u0027t want to actually implement TCP or TLS because they\u0027re really lightweight but the API that they provide if we want to be common everywhere should still Express oh you could ask for TCP and it would just not give it to you and they would fail the API should also hold back and avoid referencing any specific protocols we wanna make sure it remains general and protocol agnostic going forward and the implementation is the thing that\u0027s responsible for defining the mappings of the API on to specific protocols which we imagine it can be extended over time we can have future definitions of how you map quick version 100 into this API and of course there are no new protocols being defined in this effort collectively and there\u0027s also no requirement to use a tap system on both sides this is just a one side API to make sure that we can take advantage of the existing set of protocols so getting into concepts here is a basic overall architecture diagram I think this may come up a couple more times and some of the other slides essentially we have at the top a application and a series of categories of API is that it\u0027s working with it has several phases it has a pre establishment phase in which it has to do the setup it has the establishment phase which says I want to actually activate this object whether it\u0027s a listener or a connection it can do data transfer which is a clearly the goal of a lot of our transport networking it can terminate things and then there\u0027s also the phase of receiving events from the transport system up into the application so that essentially defines the phases of the API level down below there is the implementation which has concepts such as gathering all the candidate paths endpoints racing them having cache state in involving system policy in this whole decision-making process and building a protocol stacks so that\u0027s kind of the high-level view should be fairly straightforward it Maps well onto things that we\u0027re all familiar with like TCP UDP systems alright so just running through a couple of the concepts here these are the main highlights from the document first we have the basic objects that we imagine need to be interacted with first there is a pre connection this is a interesting term that was come up in our various debates about terminology it\u0027s essentially the properties and parameters that can be specified to define what a connection or a listener can be it\u0027s the endpoints and properties that the application wants but it doesn\u0027t actually do anything on "
  },
  {
    "startTime": "01:04:26",
    "text": "its own a connection is the name that we\u0027re using for the basic object that can be created from those properties and is an active object that can be used to send and receive messages between a local and remote endpoint and this is we\u0027re using the term connection but it can still of course apply to things like UDP that on a protocol level are connectionless but this represents the active state that the application is aware of to send receive messages a listener is the passive receiving object that allows you to receive incoming connections so then the concepts for the pre establishment phase we\u0027ve already mentioned briefly there are local and remote endpoints this is these represent the things that I can define my identity and also define the identity of the things I can talk to there are path selection properties which is a whole set of properties that define which paths so which interfaces which addresses etc the application wants to be able to interact with there our protocol selection properties and these are the properties of what services I need my transport to offer such that we can select the correct transfer protocol for you and finally there are the protocol specific properties which are the ones I mentioned earlier saying oh and if you use protocol X make sure you configure in this way because I know my server only is expecting that particular bit these do not alter the protocol selection so doing the establishment phase pretty simple if you have a active connection you can initiate it and if you have a listener you can listen on it we do imagine that as we are expanding this we are going to include a couple more actions for things that are doing multicast and other styles of connections but we\u0027re starting with the limited set that everyone could agree on for movie concepts for data transfer of course their send and receive basic concepts the broader one over that is that we are communicating in sending and receiving messages messages are units of data that can be sent to receive and they are in order to themselves the boundaries may or may not be understood by the underlying protocols but having this concept is very important to decorate the messages so we can essentially say here are the properties of this particular piece of data such that when we have protocols like setp or quic that may have a more ability to do interesting things with those pieces of data we\u0027re able to take advantage of those but it does still map well into a system that\u0027s using just raw streams like TCP as far as events we have things like connection becoming ready which means that\u0027s essentially it\u0027s connected you can read and write on it now things like it\u0027s failed it\u0027s now a the connection "
  },
  {
    "startTime": "01:07:27",
    "text": "has ended you can have events that your message has been sent and a message has been received and these can deliver errors or deliver the actual data that you\u0027ve received and then their events like paths properties change to let the application know if it needs to that some properties of the system that\u0027s working on have modified underneath it this is especially relevant if you have something in which I need to change the quality of the streaming I\u0027m doing because I\u0027m now on a different interface than it was before sometimes the applications will need to be involved in this and finally we have concepts for terminating connections you can close which is the generic graceful teardown of a connection and it may involve communicating to the remote end point that we are done with this it may not and we also believe that it is important to have the concept of an abort which is more immediate teardown and involves not sending any outstanding data it\u0027s get rid of this quickly so that covers the API concepts as far as the implementation concepts we are defining here the steps of candidate gathering which is all about filtering out the protocols and paths and endpoints that are allowed based on the application preferences and the system policy and this is elaborated much more in detail in the implementation draft we have steps of candidate racing which means that fundamentally when we\u0027re bringing up connections they are happy eyeballs based they are flexible in what they\u0027re trying they\u0027re trying multiple things we also have the concept of connection groups this is for things that are being multiplexed whether it\u0027s SCTP streams quick streams hb2 etc these are connections that have similar properties and allow the underlying tap system to turn them into multiplex connections and that\u0027s essentially it that covers the architecture if there are any clarifying questions now please come up or we can just go into the details of the interface and implementation yeah prefer to try to hold all the questions until it sure clarifying quick contrived questions all right control thank you very much Tommy Don goes right here hi I\u0027m Brian Trammell it\u0027s actually weird sitting next to Aaron and not trying to do a a presentation in 6 minutes and 20 seconds so I\u0027ll try to slow down a bit so you\u0027ve already seen this because I stole it from Tommy this is the architecture diagram the point of this interface document does it essentially take the architecture that we worked out in that document and the principles the architectural principles from that document and to sort of project them "
  },
  {
    "startTime": "01:10:27",
    "text": "into an abstract interface that you could actually implement in any given language in order to meet the transport services architecture so we had some design principles these are derived from but functionally separate from the design principles from the architecture we wanted to find a single interface so this meets our requirement of write once run over multiple stacks to be used in a variety of application design patterns so we\u0027re not simply interested in client-server or sort of single threaded hey I\u0027m going to do this hello world type stuff we want to do sort of everything that people do with networks for naval applications written to the single API to make use of multiple transport protocols in terms of features providing one explicit support for security properties I\u0027m sort of we\u0027re catching up with the security document and saying security is actually a whether you turn it on and off its part turn it on or not it\u0027s part of the transport layer um for asynchronous connection transmission and reception the requirement for a synchronicity comes from the fact that you actually do a lot of the cool stuff in terms of connection racing or a path property pass election any of the things that you want to do in order to make taps work doesn\u0027t really work if you\u0027re doing it single threaded in terms of first I\u0027m going to go do a get a tour info and then I\u0027m going to go do a socket and then I\u0027m going to go do a connect um support for multi streaming and multi path transport protocols so we put this in here because it actually wasn\u0027t quite yet captured in the architecture but a lot of the interesting developments in the transport layer right now are in this space in sort of like you know so quick and be quick and P TCP an atomic transmission of data um this is also interesting for being able to take a chunk of something that you want to send over a transport and say all of these bytes somehow belong together please make sure they get there on the other side this is necessary when you\u0027re building applications on top of these multi streaming and multipath transport protocols there was a lot of discussion in on previous taps meetings about how exactly this works and we think we have a way to make it work we\u0027ll talk about that in a moment so when we take that in the architecture diagram and and push it through those principles we end up in the interface diagram that looks like this so these up here are the phases and then we have sort of the pre establishment involves sort of figuring out what the properties are the endpoints you\u0027re going to connect to and resolving those taking the parameters for selecting a connection binding that to a pre connection and then taking that pre connection in turning into a connection um so in points and here I have actually references to the document for those of you who haven\u0027t read it yet you can actually just go through this presentation you don\u0027t really have to read the document and when you do read the document you want to check to see where I got things wrong in my slides that\u0027s the that\u0027s the the section reference so we want to be able to "
  },
  {
    "startTime": "01:13:28",
    "text": "specify a remote local endpoints at a variety of resolutions you might actually have application logic that says you need to connect to this IP address you generally will be doing things in terms of their main names but in sort of in other environments you have other ways to specify things right there here is under control of the transport services system not application control so this is a departure from bsd sockets in it now there\u0027s sort of a a explicit phase for resolution get outer info followed by an explicit phase for doing something with this drug sock adder and we don\u0027t want to do that anymore because you can\u0027t do a lot of the cool stuff we want to do in taps if that\u0027s your pattern this is um bound to the pre connection because the pre connection has properties that may um do some pre path selection right so for example if you\u0027re doing resolution with the dns um the answer you get depends on the resolver and the source address that you present it so you need to actually do multiple resolutions depending on the selected protocol stack depending on the provisioning domain depending on other properties that interface there is an open issue that we need to address here um when you put this under the control of the transport services stack some applications may actually want control of when the resolution happens because um DNS queries can leak interest about some things and you might not you might actually want to say okay well I want to check over here first and only if that fails I want to check over there because I\u0027m less I trust this network more we don\u0027t have a an answer for that yet we have a space of answers but we need to sort of pick one yes of course otherwise we can just go home so crackers parameters section 5 - um here we have sort of properties that you can use to select both protocol stacks and paths and these are essentially used to select or prefer or eliminate candidates while you\u0027re trying to do connection establishment oh these are the old slides um ok good they\u0027re mostly correct these properties are partially there\u0027s a missing partially right there um for michael derive from min set you know whether or not the protocol stack provides reliable data transfer preservation of ordering whether or not it provides the ability to select um reliability on a per message basis like PR SCP whether it provides your RPGs such an establishment multiplexing or multi-streaming whether you can get retransmission and ICMP notification as in SCTP control over the checksum coverage for doing partial checksumming or checksum disabling for UDP and UDP light a capacity profile which we can talk about in the discussion and then "
  },
  {
    "startTime": "01:16:28",
    "text": "sort of paths only interface type information there\u0027s only one like I can I can actually give you URL to throw up because basically I\u0027d just say hey we have issues please go to get up and I\u0027ll tell you that when we get there um so the we have these four column pass election properties separate from that our protocol properties if you have suggestions on the terminology we are very open to them these are um protocol properties allow us to configure in query information about a running protocol stack after it has been selected in a transport independent way so here we have relative niceness this is a post sockets concept license is essentially one over priority we have the transmission scheduler for the group we\u0027ll talk about groups in a second the connection aboard timeout notification thresholds checksum coverage minimum and maximum sizes for how we deal with with framing um the idea here is to have for the min set a set of protocol properties which we don\u0027t need to know anything about the transport protocol to set the architectures requirement to be able to reach down into the protocol when you really really need to is provided by sort of specific protocol properties and these are essentially names based by the protocol so you would set a specific protocol property on TCP and of TCP mint happens to get selected you would configure TCP with that property otherwise it wouldn\u0027t get selected we could have been know that I\u0027m staring at this I\u0027m wondering why the product the properties itself are discussed in the API document and not in the implementation document so the point of putting it in the API document is to say these are the things which he was an application developer will have control over in the in the minimal state great it\u0027s the abstract part yeah but it depends on what the application actually implements at the end right or is it is it are we assuming that these are the mandatory ones we are not assuming that yet right so these are the ones these are the ones that would be common but not necessarily mandatory okay I\u0027m gonna give one short comment to each of you and then we\u0027re gonna defer the rest until the open discussion part Tommy just to various comment the implementation that I think is much more focused on things that are hidden from the application right so these are knobs that the application may or may not have to interact with they\u0027re totally optional knobs but they are still knobs Cairo\u0027s yeah I\u0027m thinking that this is this is like essentially a set of suggestions of things that you could implement using say our cascading style sheets wait yeah yeah this is this is the this is the CSS thing right okay I "
  },
  {
    "startTime": "01:19:30",
    "text": "think we should clarify that optional to use for an application programmer but not optional to offer so I think that\u0027s the sort of notice that we really want yeah so here here right now we haven\u0027t actually said must should we haven\u0027t put normative language on these we need to do that in a future revision I think what we\u0027re asking today is is this the correct approach not is this the correct list of things I mean we need to we need to go on the details of that and we need to actually back that up with stuff in the implementation document that these are zeros your arrest so I\u0027m going to defer the rest of this discussion until the open discussion part because we have a lot of material to get through so I\u0027m sorry please sit down try to remember your comments we\u0027ll come back to the later yeah as you see we have a we may need to revisit the organization the document because I just jump from section five two to section nine one back to section five three so this is what\u0027s in the security parameter section of the document right now actually looking at Chris\u0027s present station this morning the security parameter section does need to be updated to follow the minimal set that comes out of that document but here we have again generic security properties that allow you to - it\u0027s exactly the same thing right like so you have a transport independent way here and then you can configure in query security features in a protocol independent way this identity private key the group\u0027s algorithm cipher suites you want to use on configuration the session cache pushing pre-shared keys into a session and then um callbacks for trust verification identity challenges right so these are standard things that are partially derived from that work but we need to sync it up there are a few more things that need to go in here huh what yeah for example um so now you know following the the structure of the architecture document we go through the different parts of sort of usage of this API in terms of their phase great so phase the pre connection phase the pre establishment phase is all involving a pre connection so this takes some endpoints and some parameters and one of the purposes of giving this to a pre connection is so that the system can prepare cache information pull information out of the cache before it actually does um the the establishment right so this allows the system sort of in the background to start preparing for the fact that you\u0027re going to ask for connection on this um you can also group connections for establishment we\u0027ll get into that in a second and recognizing that this can get a little bit clunky um you know for many applications you might want to let them just say hey I have some parameters give me one connection I\u0027m only ever going to need one connection um there we can have sort of convenience calls in the implementation of the API that says ok I\u0027m going to pre connect then I\u0027m going to connect at the same time because one of the one of the goals here is that we want an API that doesn\u0027t look um you know much more Byzantine than what people are used to right now um so once you have a pre connection you can establish it there "
  },
  {
    "startTime": "01:22:31",
    "text": "are three ways to do this um sort of active passive and either active North passive or both active and passive at the same time and each of these has and of associated with it when this when the connection is done so if I want to initiate then I get a ready event if I do a listen then the pre connection becomes a listener and I get a bunch of connection received events and if I\u0027m doing a rendezvous then basically there\u0027s additional information about how that relay is going to happen if there\u0027s now traversal it needs to happen and then once that channel is established you get a rendezvous done event event um these once these are created before these events fire these are still real actual connections and you can do everything that you want to do with a connection with these connections you won\u0027t receive any data on them because there\u0027s no way for the data to get to you but you can start throwing stuff into the buffer and you can start in queueing receive requests um the details of zero RTT are still an open issue there\u0027s a big long thread in github among the authors we have not figured out exactly where we want to push that ugliness but the ugliness is essential the way that we represent multi streaming protocols in an environment where you may or may not have access to a multi streaming protocol is with a connection group this is a neat concept that we\u0027ve kind of slammed some post sockets into so we have a sort of a unified way of dealing with this but it\u0027s it\u0027s inspired by the neat approach you can take connections and you can entangle them into groups once a connection group but connection is entangled into a group all of the protocol properties of that connection move together that represents the fact that these on logical connections may just be streams in a multi streaming transport protocol they may have one sort of like lower layer connection among all the connections in the group or they may be implemented as multiple flows if you don\u0027t have a multi streaming protocol available to you the way that you create a entangled connection so the group itself is not created explicitly it\u0027s created in implicitly by creating new pre connections that are cloned from existing pre connections so you can take a pre connection and you clone it every initiation you do off of that pre off of the entangled set of pre connections will be part of the same group you can take an existing connection and you can clone it on the other side if there is a if the underlying multi-streaming transport protocol supports notification that a new stream is available on that shows up as a connection received event so as far as the application on the listener side is concerned it\u0027s just a new connection that popped up there are details and how you would handle this when you have a single stream initiated by the initiator in a client-server architecture where then the server would initiate new streams that\u0027s an open issue and we need "
  },
  {
    "startTime": "01:25:32",
    "text": "to handle that as well sending data pretty easy there\u0027s a thing called connection dot send um not super exotic um various sender side framing so if you\u0027re in an in a environment that basically allows you to deal with arbitrary application a sort of data types you can hand that data type in to send as opposed to doing the serialization inside the application and take the serialization and move it down into the API so you have a the ability the application has the ability to say please frame my data like this um this is um kind of a convenience function but it could be used for example to frame data differently in case different protocols are used because there is a requirement for different framing and different protocols on the on the other side from the server ok how many more I got yeah oh I\u0027ll finish off um the person behavior can be controlled by um license and parameters so again we have lifetime how long if I\u0027m partially reliable how long should I wait until I give up on this niceness is again inverse priority whether or not it needs to be ordered with respect to the last send on the same connection a well known as item potent and can be used for zero RTT and then checksum coverage immediate acknowledgement and then sort of this instantaneous capacity profile which we\u0027ll talk about in the discussion later pretty much any time you do a thing with this API at my yield and event um here that would be sent a as far as I know this made it to the other side depending on what the fee the underlying protocol can give you as far as how much send information about how far it got sent usually this is it got put down to the kernel so it\u0027s it\u0027s not TCP X no actually so if we if we if we have TCP ACK notification or a a protocol that gives us that notification we probably want a another event here for delivered but that\u0027s not there yet um discussion gory or not right so this these are all you you can see that there\u0027s a common theme if there are open issues this is your zero document we have along the author group we have a pretty good agreement that this is the right approach for this we want feedback on whether or not we\u0027re barking completely up the wrong tree but like all of the little details we want to do under working group change control receiving amazingly this is called um actually connection not receive so um the application essentially registers that it is ready to receive data by calling receive and then it gets a receive event this is a way to allow sort of application pushback to you know for essentially flow control um this message is going to contain an octet array as well as some reference to some "
  },
  {
    "startTime": "01:28:33",
    "text": "transport metadata so if the underlying stack gives you the ability for example to see the ecn status of this packet you could actually get that out of the metadata how about how we generalize and make specific that metadata is an open issue okay thank you very much the there\u0027s a detail here on that we actually worked quite hard on in that this API gives you atomic reads um when the underlying transport protocol gives you message framing and boundary preservation like SCTP um then that atomic read information comes down from it you do you do a send on one side it gets put into a frame thing on the transport protocol out of the transport protocol framed ud frame it and everything is fine when you\u0027re running over something like TCP yep what are you running over something like TCP you um need to have some knowledge of the application protocol running underneath it in order to D fraim it turns out almost every application protocol that runs over TCP has its own framing mechanism because it needs it right this is a an indication that this is actually a missing transport protocol or missing transport layer feature that we\u0027re adding back here so just like the cinder side framing the cinder site D framing allows you to push that down closing you can close connections you can also report them one of them is orderly one of them is not um when you take all of this stuff together you get this so you have the parameters you can run them at five different levels of yeah my timer is done any questions no questions may have already seen some of those thank you Brian okay Anna yes okay hello everyone so I\u0027m Ana bernstrom and I\u0027m here to present the third document in this document suit implementing interfaces for transport services and as already introduced by the previous two speakers this document complements architecture and the API draft so it provides guidelines on how you can implement this type of tap system so in relation to the architecture that we already have seen this document deals with this part the implementation how you can do the gathering of candidates racing how to use policy and catch States and how to done implement pre establishment actions establishment data transfer and termination so the first part is the "
  },
  {
    "startTime": "01:31:35",
    "text": "application the implementation needs to support the basic objects that are defined in architecture so the pre connection is implemented as a bundle of the different properties and the objects that it contains an important part for the implementation is that when this pre connection is turned into a connection or a listener these paths selection and protocol selection properties becomes immutable so the implementation needs to ensure that they do not change after this point so moving on to the first phase the pre establishment so as you already heard in this phase the application provides its endpoints and it can give the preferences regarding the the protocol and the paths that it prefers to use so the implementation then stores these objects and properties as part of its pre connection object and you also have a lot of these port protocol and path selection properties so for the ones that are not specified by the application the implementation needs to use the default values that is part of the API one part for the implementation is also that during this pree establishment face you can also do early failure detection so if the application gives you path or protocol selection properties that you cannot support because you know as an implementation what protocols you have and if they are not supported than providing an early failure notification can be beneficial here because then you can save resources and similarly if you request properties that are not compatible with each other that implementation can generate an error so an important part in the pre establishment is that you get all these properties and preferences from their application and the implementation needs to take these together with other inputs so you have some dynamic system policy where you as an implementation can gather information from previous connections or you can gather information from other sources external to you and you may also have some default implementation policies so a key thing for the implementation and one of the main benefits of having the tap system is that we dynamically can make these decisions to give an optimal transport performance so any of the in the implementation you also have to ensure that the constraints that are given by any of these input parameters all have to be satisfied so you cannot select the protocol that doesn\u0027t follow the requirements from the application or that violates your system policy for instance so for implementing the connection establishment as you already saw in the architecture overview there are two main steps to this part so it\u0027s the candidate gathering where you "
  },
  {
    "startTime": "01:34:36",
    "text": "identified on which possible paths and protocols an endpoint can you use and this is also where you use this system policy component in that step and then you have the racing of these components when you try them out and see which ones you can actually establish and you provide them one of them back to the application so this is quite a large part of the description of the current implementation tation draft and this comes a lot from Thomas draft on that topic that was also presented in the previous meeting that we had but for the candidate gathering you can describe the candidates by the in a compact notation by the the endpoint the path and the protocol and you can done also structure this available candidates as a three as a tree so if you have a in this case you have the endpoint and you have any path available you can then split that up depending on which which path you selects for instance you have Wi-Fi and you have LTE and then you may also have for Wi-Fi use one end point ipv4 address but you may have for the other LT you may have both ipv4 and ipv6 endpoints so you can structure all your choices as the tree and this is kind of how you can represent and have all the the candidates that are possible to use and when you construct this tree the order in which your branch is quite important so Brian was already talking about this that it\u0027s important that you do the DNS resolution for instance on the right path so that you don\u0027t get candidates here that or doesn\u0027t make sense you use actually and sorry and also his you also don need to sort the branches so this is kind of how you give the preferences for the different protocols and the different paths and this is again BAM based on your own on your system policy so once you have gathered all your possible candidates then you have the racing of those candidates and you have different approaches that you could apply here you could write race and multiple candidates in parallel immediately this is not that you should you have a clarifying question so I am trying to understand if the previous slide and this slide occur in two different like time phases or not because like it seems to me like you can\u0027t tell that LTE one nine two zero two one is like you can\u0027t tell that and without doing a blocking operation that\u0027s oh I\u0027m trying to understand if you first gather and then you all you have to do a DNS lookup right so you I if you gather so yeah I think it\u0027s conceptually there are separate issues but implementation wise that happen in in parallel every time "
  },
  {
    "startTime": "01:37:38",
    "text": "you information okay Cohen Perkins what one of the open issues we have with this draft is how to resolve all that sort of discussion happy eyeballs the the ice net reversal and figure out they of the right phasing true yes and we have that kind of as a separate part also in document at the moment that needs to be integrated so I think I have that on the only later slide you\u0027re about halfway through your time okay yes then we have the candidate racing and you can do it in in different ways depending on if you want to have a delay between the candidates you want to wait until a failover happens and the racing completes once you have one candidate that succeeds or if all of them fail and one aspect here of course when you have a tap system is that the success here is different depending on what protocol you use so if you have TCP for instance it\u0027s quite natural to think that you succeed once your handshake succeeds if you have UDP there is no handshake so as soon as you have a route to the endpoint you can say that you succeed the multiplex connections are a bit special here because here you may already have a connection set up and you just use a new stream of that connection so you actually can succeed immediately and this also has some implications on what happens at the other side because you may have a reliable taps connection but you actually don\u0027t yet any connection received event on the other side generated by the establishment it that just happens once you start to send data in this case another just to clarify bit I mean for UDP one of the open issues we have is to integrate this or things like stun which actually give you much ability tests we are aware that there are there are details missing at this point so that was the active part of opening air connections we also have the listening side so here dope implementation then needs to register the listener object and depending on what path and protocol preferences has been specified you may be listening over multiple paths you may be listening for multiple protocols and you can actually get different protocol stacks back as an application depending on what happens underneath in the tap system data transfer I think you Brian already talked quite a bit about this that depending on what protocol you have sending or the message is different if you have a protocol that has a natural message framing and a message just gets mapped to that if you have TCP done depending on if you have a framer or you will send a sequence or byte bytes there is some discussion about how to support all the different sand parameters again what that means what "
  },
  {
    "startTime": "01:40:40",
    "text": "these sand crater parameters means depends on the underlying protocol you have in some of them you may not have support for it and in others you can do something useful with them 0tt data is an important case Brian already talked about that as well from an implementation standpoint this is something that you have to integrate with the racing so you have to have the the data provided by the application and then you have to provide it into each of the the candidates when you race it so that you can include it for the protocols where it makes sense on the receiving side again Brian talked quite a bit about that part as well and it\u0027s also dependent on the protocol that you have so if you have a TCP you may not have the the framing depending on what has been passed down by the application and you also have some hints there that the application provides to you so that you know how to deal with the incoming incoming data if it\u0027s if you don\u0027t have a notion of a message then you need to get the amount of data to deliver specified by the application termination the clothes and their board functions the important part there from the implementation standpoints perhaps is that you don\u0027t have any half close connection so the protocols that support that does not get propagated up to the application again when you have the multi-streaming protocols and you multiplex several taps connections onto the same underlying transport connection you also get some special behavior because here closing a connection is just closing a stream and depending on the underlying protocol you may not then get the finished event on the other side so you you have to be aware that you get a little bit different behaviors depending on what you have underneath in the protocol sorry so there is no there is no functionality for T in the API you just have a close and the board in the current version of the API as it is right now just a clarifying comment on that Tommy I think the point here is that a close in this is being interpreted as a termination of the full connection we\u0027re still discussing half-closed being able to be sent but I believe that would be more property of the sending of a message and saying that now this message is the end of the underlying connection please send a fin with it that\u0027s a sending parameter not a termination parameter yes and there are also a number of other issues that are covered in the draft so some discussion on how to implement the maintenance activity is how what you need to do when the protocol properties changes or when the path changes there is some more "
  },
  {
    "startTime": "01:43:42",
    "text": "discussion on cache State in relation to the system policy so you may have state cache both by the protocols so for instance when you perform happy eyeball you may learn about what protocols work and not and you my cache information for TFO and things like that you can also have the performance caches which is knowledge about your different paths round-trip times available bandwidth and so on and this information may also come from external sources there is a section in the graph discussing also protocol specific considerations or how these actions map to the different protocols and some specifics to think about and this is the list of the protocols that are currently discussed as column was already commented we have the round of an environment discovery this is currently a separate section that needs to be integrated with integrated with the rest of the document and I think there\u0027s also quite a bit of information missing there in general I think we started from the architecture so this was the first thing we did nailed down to get the agreement there and then we have the API and then we started also to have the implementation to see that things match but there are still of course a lot of open issues also in in this draft ok great thank you so before people get up to the microphone I\u0027d like to ask the three speakers to come up here to the front just so you\u0027re not clogging up the microphone elsewhere and and I see as well because there\u0027s you know hopefully there\u0027ll be some dialogue but I but I think the most important thing that I want to get out of this discussion is a decision whether or not to adopt these drafts as working group items so let me start by just taking a home of the room those people who are comfortable making these documents they\u0027re - here\u0027s your documents obviously not done but making them taps working group documents today I\u0027m going to ask whether you are in favor of it whether you\u0027re opposed to it or whether you need more information so let\u0027s say who\u0027s in favor of adopting these documents today great and who\u0027s opposed and who needs more information all right you guys consider no wait wait now now we\u0027ve got about a half an hour we can talk about sorry we\u0027re dying and there was celebration in the streets so yeah so now we have a technical discussion yeah cuz they\u0027re questioning me that\u0027s so cute somebody get a picture of that Kyle rose so the the section on "
  },
  {
    "startTime": "01:46:45",
    "text": "rendezvous under the sections on rendezvous so I feel like there\u0027s an intent for rendezvous to be very general paging dr. Perkins dr. Perkins to the pink box I feel like there\u0027s an intent for rendezvous to be very general and I think that we\u0027re gonna want that because it\u0027s not just ENS not even just multicast DNS but you can imagine service discovery via a database where you have say stable names for a service that might move around between IPS or between data centers so I don\u0027t want to belabor the point but we we know that and we need help Michael Jackson two comments regarding the center motive one is you had some time to live for partial reliability of their other notions of partial mobility so make sure you can cover that and the other one is you had atomic sense so I agree there is a need to provide an ascend call information where message begins and where message stops it\u0027s but it could be limiting if you say you do it with atomic sense which limits you to say which limits the size of the messages you can send to the size you can buffer inside your stack I only had 20 minutes so I didn\u0027t read the whole document um there is a notion of a partial send and a partial receive so if for example the if you\u0027re receiving something and the transport layer framing or the underlying application layer D framer basically says I cannot find the end of frame before your maximum buffer size you\u0027ll get back essentially a an atomic receive Orono a partial receive so it\u0027s a yeah here\u0027s the here are some bytes from this message and they start at this offset and I will provide ya when it\u0027s it when it\u0027s finished great yes and you can and you can basically use you can use that to have to put streams like a stream looks like just one very long message great yes and it is the same thing for the send so one of the discussions that we had early on and if people have feedback on the naming here to be good initially when we were talking about the data transmission fundamental concept for while we had content as the thing which was essentially the the piece of data that you can send at a time which was related potentially to a larger overall message we\u0027ve changed the wording to be more message centric but that means on a given send you may actually send a message multiple times that you send the first part of your message and the next part of the next part and you could essentially stream that message in and there are properties of that message which are separate from the fact that I\u0027m sending it in separate chunks because you definitely need to be able to stream gigabytes and gigabytes of data that you can\u0027t all have in memory at once okay yeah I mean on the "
  },
  {
    "startTime": "01:49:50",
    "text": "rendezvous side I think the the initial goal is that we support happy eyeballs and things like ice and once we have figured that out which is hard enough in itself we then make sure and try and generalize it to anything else people care about yeah and as for the rest if I think it\u0027s fairly clear there are a bunch of terminology issues and perhaps suboptimal names and we if anyone has suggested better naming so try and clarify some of this we are very open suede this I mean it\u0027s hard and specifically on the rendezvous stuff because I believe we have in scope some of the basic parts of that if as you\u0027re looking at various use cases here you see things about certain rendezvous models that the current architecture would prohibit or limit in the future please bring those up sooner because we want to make sure that it\u0027s not a constraint that we have added rather than just something that needs to be expanded upon in the future yes yes and just follow up on that we are aware that we will need application that will help know some of these want to provide the right hooks and the right information so when they go that is it hello yeah this is dad exam also co-chairing but maybe coach hat off here from the floor it\u0027s about the policy thing so the architecture graph says it has a system policy and API doesn\u0027t say almost anything about the policy how do you set up the policy and the implementation drive size we have system policy you have network policy and her application policy so how do we do what is it thinking about architecture drop to include or rename the system policy to something else or API to include more about how do you need stall policies so there there is some inconsistency in the naming between the architecture and the implementation so that that we are aware of but I also unlike information as for the API um the API draft is really about well the focus of the API draft now is really about the interface that\u0027s provided to the application developer there is missing language about the interface that is provided to an administrator or a user so that\u0027s basically just an oversight right so we\u0027re basically saying these are the these are the knobs that you have as an app developer the app developer is generally not going to be setting the system policy right it may have its own application policy yeah that application policy is essentially um represented by the set of you know prefer avoid require so on on the different parameters rate so those have to be projected through business and policy so yeah we should add something about that and add the add information about an administrative interface and "
  },
  {
    "startTime": "01:52:51",
    "text": "what that looks like because and it should probably look the same right so that you can sort of configure things in the same terms but there are also different time scales on these things right so I mean the the port that you say is set in the application preferences can be changing and influenced by what you\u0027re sending or what you\u0027re in the specific instance and the dynamic policies are also dynamically learned by the system and then the default system policies or more long term and they can also be updated but on a different time scale so basically I have those three impossible between different policies regarding the fact that the architecture defines the system policy actually puts that in the implementation concepts of things that are not necessarily going to be exposed to the API and the classic example I have of system policy is on a mobile phone a way to disable cellular data for a given app or even the carrier pushing down that policy that is not something that may be ever expressed in any API that anyone could interact with the part of policy for an application to interact with that I believe would be the path selection properties and so we can maybe specify hey you can set your default path for the selection properties for my process but there will always be a category of things that are invisible to the app that come from some other part of the system that maybe the user interacting with the UI and I don\u0027t think that\u0027s in scope for us to specify we just need to interact with it yeah III get that under system policy thing but I do believe like application need to say some some sometimes some something about the policy that system might need to listen or the network or the server actually install some policy from a particular app so I think the only thing I\u0027m asking is like clarification and how do you do prioritization basically when you have multiple policies active on a packet level or a connection level or a system level so just a clarification on those things yeah so I mean at the moment we only have specified that you have the constraints you have to follow for all the policy inputs you have right so if you can\u0027t satisfy them then you cannot establish a connection but then of course it\u0027s in practice more complicated because you may have trade-offs between different things when it\u0027s not a strict requirement and I mean some of that I think is implementation-dependent and some of it we can maybe specify some organized on yeah sure yeah just make sure like these things are up in the architecture and API the comments as well so a few things first those things are invisible to the applications I\u0027m not sure I might be better to say they\u0027re read-only to the application yes because so there probably should be a way to find out hey I\u0027m not allowed to use LGG so don\u0027t try which means you still need an API for that you need to read API for finding out what the default policy is on um and then the "
  },
  {
    "startTime": "01:55:53",
    "text": "second thing is I feel like this is maybe a little bit of a couple but it is actual discussion the one event I was thinking I didn\u0027t see if something equivalent like the TCP low water where you know I want an event where you know am I ready am I ready to be it okay for me to send now in a way that won\u0027t fill my pipe right and that\u0027s a very interesting point it would definitely was brought up in the discussion I believe we\u0027re trying to actually avoid that because the TCP low watermark is very much a property of how you interact with the socket right it\u0027s not a property yes and so I think that\u0027s actually the point of this the this the callback to sending a message is not when it has been act it\u0027s actually when it has been is actually consumed by the buffer and so if I call send with the message and I don\u0027t get the callback quickly I know that essentially there is back pressure that the TCP send buffer cannot consume this data yet and so well we\u0027ve used we actually have some of these similar models in public api\u0027s ready and we recommend that people if they want to limit their own buffering that you should not include other-- send until you\u0027ve received that call back so I think the one thing that we should add probably is a way to tune the size that is being theirs willing to be out in an outstanding queue within TCP which will essentially control how quickly their send callbacks will come or general point is just to think one thing that would make me more confident its API is if I could is if basically you\u0027re getting your on dog food but just say could you implement quick on top of this UDP or give them a tie so if you have a match like our mcat congestion control things like that so so I\u0027ll say that we have a a plan and hopefully funding and even a person to do an implementation that essentially does quicken TCP sort of user space versus kernel space racing and all of this as a sort of a proof of concept and and you know reference II implementation for research purposes and go so that\u0027s we take well we put users base quick and kernels base tcp underneath this api yes you can also do that okay I\u0027ll get another student and so from our angle at Apple we are we essentially use this internally we for our own prototypes in which we would be doing quick interrupt we\u0027ve been using both inside and then also making sure that the UDP surface of this is what you would need to implement quick so we\u0027re interested in both aspects so in terms of services like you know applications "
  },
  {
    "startTime": "01:58:53",
    "text": "wanting lower latency or higher throughput and you know there\u0027s a wide spectrum of like the choir MERS you could define both precisely on imprecisely so in terms of those is there anything in this API that is planned because that\u0027s one problem with the sockets API today to do the application can\u0027t really provide intent it can basically and we usually end up like compromising and stand up yeah so what we have right now is the capacity profile which can specify in which the application can specify whether it wants to optimize for like low latency or high bandwidth for example we also have the concept of intense that the application can say ok this is going to be a big transfer and this is going to be like a small transfer any application has a the application wants to specify this as accurately as possible because otherwise the transport system is going to optimize for the wrong thing right and so we\u0027re trying to figure out which exact properties we are putting in the proposed standard API int which we are leaving up as like a great sizable extension of that so all of that right now is all that stuff right now in the interface document is in Appendix A I think so we we all of the things that we sort of took in from the three proposals and put together that we did not come to consensus on this belongs in this document went into the appendix and that was most of the socket intense stuff and a couple of other things that came from I\u0027m not sure if they came from inside or not but they came from somewhere and I like and this doesn\u0027t look actually like it\u0027s gonna be useful um so I think those are elements that we have not finalized on the semantics for and the correct way of doing it we believe that they are useful so I think if maybe we could take a look at the appendix open issue say like which ones of these we think are the most important how can we phrase them correctly once we get consensus then we believe we can bring them in to all three documents sure great I think that we have a real value add here because that\u0027s what\u0027s missing in the API the other thing I wanted to say is yes the abstraction is great but from the perspective of the application you know if it requests certain services and you pick you know your paths and protocols in dynamically that it loses consistency like if a repeat connection and the pinging a different protocol that\u0027s not it may not really help with performance metrics and such so some sort of consistency guarantee answer in terms of hey if we pick one path it gets consistently picked would be useful to specify right I think when we get into discussions of like a specific deployment like it\u0027s very important to know what does my server actually support what are the contracts there and I think the preferences and allowances do need to take that into account right I you could imagine saying I want to prohibit this protocol on this path because I know it\u0027s going to have certain problems or will not work or "
  },
  {
    "startTime": "02:01:53",
    "text": "essentially really bias it towards one or the other if my server only like this only gets really interesting when I have a server that starts to deploy both TLS and quick and I need to be able to be flexible between them so as that deployment strategy evolves I think we\u0027re going to try to fine-tune the model of setting that I think my question is slightly different so I\u0027m saying that if you if you went through all the policy and you\u0027re racing to figure out what supported versus not and you end up with protocol X yeah the application would prefer that in that session that you continue picking X consistent you know yeah so there it is important to make those if we don\u0027t make that guarantee then your matrix right there\u0027s a there\u0027s a chunk of the architecture that we didn\u0027t talk about at all which is essentially sort of the the security state cache and the transport state cache right so the system any-any implementation the system is necessarily going to have to learn about paths and um this that\u0027s where the stickiness lives I think we could we can definitely recommend um sort of parameters without stickiness but the architecture basically has this this idea that there\u0027s a we call it an association cache in in Poe sockets because Association isn\u0027t overloaded at all um but the the idea is that there\u0027s enough information there and you pretty much have to implement enough important to make this work you need to have that cache and then the stickiness is just a novel in that cache and we should we should but you\u0027re right we should recommend that there\u0027s a certain amount of stickiness there in terms of the parameters yeah one very brief note on that is that in happy eyeballs we essentially already do that in which we can be sticky to addresses we\u0027ve already done and so you can Majan doing the same thing for protocols so gory fair has just one of the off the team but I\u0027m on the policies and how all that interacts because the election and what we do there\u0027s probably multiple on what we have as inputs here because some of these things are actually asking for things from the services which are predictable and if you asked for this you will get this in this environment and other ones are optimization and tuning and I think we have to kind of discuss how that all fits together and I\u0027m also concerned a little bit that if we do absolutely everything then we end up with a really really big spec and I\u0027m worried whether people do it so okay we\u0027re gonna have to score this a little bit yeah Tim Jones form a similar comment to gorira is to for example with the system configuration where you\u0027re putting all these things from there\u0027s a potentially a bottomless pit of things you could use and one of the things that seems of interest to me v6 point of view is the provisioning domain work over an inter area and one particular when you\u0027re multihomed but again comes back to some of the things others have said that might be a dynamic thing where the PVD information changes periodically with Ras and you then have to adapt to that you may need to resolve the addresses etc so having some scoping on that and understanding having an idea of where you think strategically we should be pulling these ideas from would be interesting to hear "
  },
  {
    "startTime": "02:04:53",
    "text": "so it it sounds to me I\u0027m gonna it may be Aaron might say the same thing it sounds to me like there\u0027s a collection of other things that people would like to see in these documents about sort of like actually running this system right so that might be a fourth doc that we don\u0027t have yet it might go into the implementation talk and then come back out I don\u0027t know it\u0027s it\u0027s not really clear to me where this work but there that does seem to be a hole that that we need to we need to consider I agree I think that we won\u0027t be able to write that doc until people yeah so I set this question email I didn\u0027t get an answer and I think it might be interesting enough to raise in this group which is you know like a year or two ago there was a woman here who was doing like some very high-performance TCP stuff and she was really concerned about like setting socket options for her tcp and wondering whether taps was going to allow to do that or were you going to still permit TCP connections that we\u0027re using sockets and that sort of thing and I\u0027m wondering do you have a thought about sort of cohabitating with applications that have more needs for more granularity in the API than what taps is going to expose so I think part of that is the protocol specific properties so that if you speak a particular protocol you can set additional information on that but it will only be applied if that is the protocol selected so to implement that or is that going to be a straight pass to is the taps library maintained are going to have to track all the protocols that are inside it no because that won\u0027t work obviously so um we just but this is this is sort of tied to an issue that we kind of just realized that we had when we were looking over this here in London is there\u0027s a sort of a general right this is the what specified in the interface document is sort of the low performance version the interface right it\u0027s the you know we do everything one at a time right so um batch tayo we probably need to be able to to have some sort of way to get out of the way for batch sends we might need to get out of the way for um memory-mapped i/o and direct NIC access these are things that we know we need to put cut outs in the API for so we won\u0027t keep people from doing them but we don\u0027t know how to do that yet so okay so you\u0027re actually my question but you\u0027re doing it indirectly right in the in the world where simple things should be easy and complex things should be possible you focused our attention on the simple things yes easy part I\u0027m asking our complex things going to have to go through taps or can they bypass taps and go in there and it sounds like you\u0027re saying it should all go through taps my gut on this would be that it should all go through taps that is why we have the design principle in there at the very beginning like we need to support specific protocols because we need to address these use cases we cannot have a worse set of things than this existing standards from my own "
  },
  {
    "startTime": "02:07:54",
    "text": "perspective like in our own implementation of this we\u0027re not always going over sockets because sometimes we have ways of doing things more efficiently than a socket option would have so if you all you do is directly exposed to the socket option through and you allow someone to call set sock opt you are now essentially exposed the fact that there isn\u0027t a single underlying socket there that does become quite problematic if you are doing something like now I\u0027m doing some multi streaming thing on top of quick there is no F D there is no any of this underneath that so I the only person I think we\u0027re taking is have a one-to-one mapping of all the existing socket options that we believe are important and it essentially replaces the socket option directory and individual implementations we\u0027ll have to manage those sure would be good document said that somewhere because I was looking at explicitly for that kind of situation at that so both of the questions and answers try to be really precise about these properties we now have a real zoo of protocol selection properties path selection properties than specific protocol properties generic protocol properties and then they can be specified by the application as required preferred or not and then later when the connection existing application can query which of them were actually satisfied and so this is right as I said it\u0027s a zoo and I would propose we just make one pair one section in the API draft where we sort ease out really neatly and like and then this is also also going to be about terminology because there has been some confusion and then we have to fix on which ones go in the draft and which ones go in the extension and appendix we just have to make sure we don\u0027t constrain ourselves for the future I just wanted to put unfelt easel I just want to put it a little bit more into a perspective that I think that AB system should have both it should have some let\u0027s say mall as Auto mode that as an application you specify it in as easy as possible way and say well I\u0027m doing the following stuff please give me an appropriate transport and allow the implementer of the tap system to make smart choices there based on various inputs based on configuration based also probably on third-party interests on the other hand if the application exactly knows I need a TCP socket and I need the following tuning for me within the TCP protocol so not the socket options as it was exposed by the bsd api but as the protocol parameters for tcp are then the application should be able to to do this but I think this are two different modes and an application can even mix and match with these modes so for example if it\u0027s a cert it does the control connection where it doesn\u0027t care it can use the full auto mode but then for a specific connection where it exactly knows how to "
  },
  {
    "startTime": "02:10:54",
    "text": "tune TCP for this connection can then specify the appropriate parameters so I think we have should support those in the spectrum and well one of the next things for this documents will be how exactly to specify what I\u0027m going to do and this is exactly with the kind of parameter discussion yeah I totally agree I think one of the nice things here is that is really not diverging from what sockets already does I mean when I look at socket applications today they\u0027re lost that just call socket connect send receive and there are lots that have tons of socket options so this is not unprecedented okay so we\u0027ve had done I think quite a good detailed discussion here obviously this API is being built based on our best guess that\u0027s what the API should look like and based on our experiences with these protocols a very set of protocols and I think one of the things that would be useful to get input from from the working group is are there any protocols which don\u0027t fit with this API so anything we\u0027ve gotten about any styles of protocols which we forgotten about well I was sure I heard somebody say the word multicast earlier today yes multicast I think we\u0027ve I think that\u0027s explicitly out of scope in the agenda I was having a conversation with market back there and we mentioned ICN protocols I don\u0027t know whether these things should be in scope or not if there\u0027s anything else we\u0027ve forgotten and I don\u0027t know if now is the right time to have the discussion if there are styles of protocols we\u0027ve gotten we should have the conversation about yeah it\u0027s not the right time to have the discussion because we don\u0027t have any other discussion but I think it\u0027s I think it\u0027s a good topic for the list and I think that in taking these documents my opinion my personal opinion is that taking these documents in is working group items should not be affected by that question like there may be additional documents we want to add later so just a quick show hands is there anybody heard anything in the discussion that causes them to change their mind from supporting adopting these documents because I heard a very strong consensus at the beginning of the discussion and I didn\u0027t hear anything at the microphone that sounded like an objection so I\u0027m gonna assume that we\u0027re going to adopt these as working of documents we\u0027ll take it to the list and just confirm that and and thank you to the authors I think they\u0027re really impressive it\u0027s a real step forward for the working group and good job one sort of logistic question the authors put together a github organization called taps API um we can send a link to this to the list for people who file issues on it what do we want to bring that under working group control it\u0027s got one repo in it which is our drafts repo if they\u0027re all adopted okay does anybody "
  },
  {
    "startTime": "02:13:54",
    "text": "have an objection to that yeah okay Fernando you\u0027re next can you get in the queue up there is okay Fernando I\u0027m getting your slides up good oh good which is good because I don\u0027t think there\u0027s any AV people in the room so what Green okay we can see you and we can hear you so go perfect so I\u0027m Fernanda gold and I will be presenting our idea on the problem statement regarding ipv6 address usage as a very small background this is a document that we had originally targeted six men and when we presented this document at sixth when we were suggested that taps would probably be a better venue for it next slide so some words about the ipv6 obvious usage problem statement obviously a pv6 provides increase address and flexibility we have like plenty of fallacies and also we have addresses of the different properties like scope stability etc and there are a number of things that are related with them with the properties of the addresses first of all that the implications of these properties are not always well-known implications in terms of security privacy interoperability etc and there are also exists limitations that are related to the API is that you know applications normally use to actually benefit from this increase addressing flexibility a next slide all right so what this document is about as I mentioned before our document was originally target at six months so that that\u0027s why it focuses on one ipv6 only so far one of the first goals of the document is to discuss the implications of different ipv6 address properties for example if you take a look at temporary addresses what are the implications on security and privacy but also on interoperability because for example in some implementations when these addresses become invalid if he had a long lead the Sippi correction well the TCP connection will be teared up okay so these are some of the of the properties that we want to "
  },
  {
    "startTime": "02:16:54",
    "text": "analyze by providing analysis of all these properties so that at the time in which you want to make a decision on which others to use or you know what the implications are the second goal is to provide a probe a problem statement regarding ipv6 service issues usage this is related with the limitations that we have you know the current IP is and you know the third one is to possibly trigger work in this area next slide we read beyond society yeah next slide what\u0027s the title of the slide that you wanna have on the screen Fernanda I yeah the last one that I had seen was the the one of the goals so I guess that\u0027s the yeah I think that\u0027s the right one so some comments when it comes to you know the limitations of the api\u0027s for example when you think about our going connections there\u0027s a lot of things that you cannot really specify for example you might want for some specific application to have a new address created for your application whatever that is you might want to employ different addresses for different users you might want to have an address be employed just for a single connection and then be thrown away essentially well there\u0027s no way there\u0027s no currently in a way to actually select or decide on these things next slide yeah and the implications on incoming connections is that you know typically when you look at the sockets API oceans that an application has is to either buy the while Carreras meaning that you will accept incoming connections on all of the addresses or another thing that you might do is to for example buying specific addresses but if you decide to find specific addresses well first it essentially becomes very non portable okay and also the application you need to understand you need to be able to you know to analyze how to identify and know the properties of each of the addresses that you have on your system so you know quite likely what you respect is you know to be able to specify some decide properties on the kind of addresses that you want and you know have the API deal with them but obviously that\u0027s a gap in there because that\u0027s something that you "
  },
  {
    "startTime": "02:19:54",
    "text": "you know you currently cannot do it\u0027s like so essentially our question to the working group is you know whether you know this is a staff this is a document that you know the working group is interested in and if that\u0027s the case whether the working group would like to adopt it does a working group item okay discussion so gory fire Fairhurst here thank you if not all for going through that and I see two things in the document as I read it I see something about use of ipv6 addresses and the policies and the implications of using these and I also see the need for a new API if those concerns need us to react and I\u0027m interested in what six months they thought about the the security and the use of privacy addresses on the whole framework because that piece seems very alien to transport to me but the second part designing a new API might be really interesting if the first of all is clear maybe it should be two documents perhaps I don\u0027t know do you have any feedback on what happened in six melon how enthusiastic they were about the whole you essentially I presented that he once or twice and like the response that I think I got was like it didn\u0027t really belong the six-month and it would be long as well like Tufts if you ask me myself I think that for example the analysis of the properties of fathers is from my perspective it actually might you know fall into let\u0027s say six men or in area that\u0027s my personal thought I guess certainly the API is you know something that is that more clearly falls within tubs so uh literally one of the six months years so in six men we\u0027ve defined all these mechanisms for generating these six addresses of different properties and you have you know temporary privacy addresses and different lifetimes and all that we have specified one document that on source address selection which has lots of policy tables and and you know some ways for applications to make preferences who which type of address they\u0027d like but we\u0027re very much a bottoms-up we made this available we really have no idea how it should be used so I don\u0027t think you know this is why we wanted to drop this to the people who could actually make use of these things we don\u0027t want to the only thing we have is we have addresses with "
  },
  {
    "startTime": "02:22:56",
    "text": "different properties in different lifetimes and that\u0027s kind of where our competency ends Tommy Polly Apple thank you for another for presenting this well I agree that there do seem to be two separate concerns here I think the aspect of the privacy and security properties or when should you use one or the other feels like it belongs in another document that likely is not in taps I don\u0027t know exactly where that belongs maybe it\u0027s in terrier I don\u0027t know however the mechanism for actually selecting these I think really sounds like one of the path selection properties that we\u0027ve been describing in the architecture in the API and in the implementation so especially I think for the case of a server you know do I want to be only receiving connections on my one stable public address do I want to only receive them on the temporary don\u0027t receive them on all of them when I\u0027m creating outbound connections based on the properties of these connections what source address do I want to bias towards because those are effectively different paths when we\u0027re thinking of MPT CP it can essentially treat every source address as a different path that it has so I think that\u0027s really all very relevant and the right place to specify that would be in the interface that we were just describing so rather than adopting this draft as the tabs working group item because I think it includes other things than this what would you say about essentially let\u0027s write up a pull request on to the taps API that we were just talking about to incorporate that item as one of the path selection properties and describe the correct way for applications to specify the parameters around which local addresses they are willing to select for me that\u0027s that\u0027s fine the only thing you know I agree that there are parts of this document but the thing is that the analysis of the you know iris properties is kind of like necessary to be able to do the other part because obviously the time in which you you want the application to select you know some kind of properties those properties are going to map into specific kinds of viruses with alice\u0027s of you know specific properties so that\u0027s some what I wonder is where we will keep the analysis I mean I agree that the API part I could belong in a different document but it yes in some place or another you should have a discussion or how you map some properties the application is requiring to which addresses and you know the logic that map\u0027s one thing to the other well if the document essentially or is something that it explains what are the "
  },
  {
    "startTime": "02:25:58",
    "text": "properties of the different kinds of Alice\u0027s will be useful to be able to reference that document as guidance it also we would need to think what should the tap system do by default let\u0027s say maybe it has a different default for listeners than it does for outbound connections I I don\u0027t know is that use ipv6 ops is that in terrier what I don\u0027t think it\u0027s us because we don\u0027t have the expertise you know that inter says the right things right so I don\u0027t know but I agree with what you said I think it\u0027s good to have it and good to get it reviewed by people who who understand the what said turning hat I think I see some potential input to the implementations draft there as well because that\u0027s about default addresses and also the sorting of potential endpoint addresses but also local addresses and and I also see a potential relation to the security parameters that we specify in the API Draft so maybe it can also like have an influence on those or vice versa so quarry first coming back again after having a few moments to think is it possible that you can revise the traffic just to be clearer on the separation between the things you would seen an API on the problem space even if it\u0027s just the same document apero grass around would would really help me figure out and who perhaps should look at this because I don\u0027t really know which group should look at it or not if you have an API section yeah I buy it that this could be the right place perhaps but only if the other section already had somebody looking at it by the way when it comes to the API is so far what the document contains is essentially like problem promise statement so it says well this is the problem that we have with the API but so far the document is not proposing any ap and I don\u0027t think you probably need to do that but that wasn\u0027t what I was asking him what I was asking was talk about the API implications in a separate bit to the address selection and which addresses you use with applications okay last comment yeah Jim Jones I think well this should be included as part of the standard work you\u0027re not pulled out of something ipv6 specific but 67 24 it does say prefer temporary address is outbound so it\u0027s a kind of a big clue in there that if you\u0027re your default should be to do that but whether there are then hints on the path selection to change that and pvd\u0027s might change that sure but that\u0027s all part of the general architecture not something it\u0027s v6 was it so I think we have a reviewer okay so that\u0027s a that\u0027s it for the agenda thank you very much to Tom Jones for taking notes in the ether pad if anybody said anything at the microphone that is expecting somebody else to do work you should make sure that the ether pad captures it so there is a record of that that discussion it\u0027s "
  },
  {
    "startTime": "02:28:59",
    "text": "all available right now and thanks for buddy for coming Thank You Fernando and we\u0027ll see you in Montreal blue sheets has anybody not signed the blue sheets okay follows I had time twice early enough Chicago style "
  }
]