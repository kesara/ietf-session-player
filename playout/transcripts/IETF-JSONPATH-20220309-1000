[
  {
    "startTime": "00:00:05",
    "text": "i'm kind of used to being the the slide shepard as it were okay so so um uh stefan sent email when sorry go on i sent email back to him um should we does anybody have his number to text him or anything like that to make sure he got it um and and just to be clear this is the email that glenn sent yesterday at about um just before 4 pm glenn time 7 54 a.m my time it begins here's my input on the agenda items proposed by tim and stephanie okay yeah i've got it i've got it ready so i can just swap out and share it whenever um whenever we're ready for it um do we want to give it another minute or two before we start well i definitely would like to have stuff on here yeah yep a lot of worries do the window shuffling so"
  },
  {
    "startTime": "00:02:25",
    "text": "so hmm well at five past let's start up even if we don't have stefan but sounds good uh he may show up later"
  },
  {
    "startTime": "00:04:11",
    "text": "and casting just out of my curiosity are you going to vienna i was planning to but then austria decided to liberate all the the there is restrictions they had and now they have twice the the incidence of germany which is rising right now so no i'm not coming okay i need to to take out my registration you actually can find out who is registered online and and uh yeah who's registered remote uh so i'm sorry about that and and by the way um austria is not a nato country so we have to assume that russia is going to attack it anytime soon so maybe we should not be traveling i i think i think it's a bit early on that one oh we are in the recorded part of the meeting sorry about that yeah yeah records once we start so yes i i i turned my uh news on you know 1 45 a.m and the first three things i see here new variant oh so i turned it off again okay let's go yep uh one second and i'll i'll start driving i'm gonna i'll do the the boiler plate uh as soon as i can operate my computer uh so uh for the recording this is the json path working group interim meeting for march 2020 uh no well this 2022 i am very sorry you can tell i've only had two copies this morning um it's a little bit jarring uh this is"
  },
  {
    "startTime": "00:06:02",
    "text": "the note well i think we're all familiar with the note well i have to tell you about the note well please note well um there's only a handful of us so um i think we'll be okay for notes i can just do the usual of looking through the vod later uh i'm grabbing what notes i can and and forwarding those to the list uh we'll keep an eye out on chat uh for anybody that might uh chime in blue sheets is automatic because we're using meat echo uh and then i don't think we have any agenda bashing anything that uh you all want to bring up oh there's stefan oh just in the nick of time time yeah perfect time yes very good excellent so uh i guess so this is our agenda uh tim you said you wanted to do a bit of a brief summary of the current draft status so um unlike last time i did not go through the whole draft and and uh you know have opinions about which parts needed work and which parts did not but um i have been tracking it you know better than i had before and you know uh i think that the list of issues we have before us um probably exceeds i mean in in in in glen's email and and so on the list of issues before us probably exceeds what we really need to do to to finish a draft really um i think that uh uh we are within um i would say one ietf at you know really of of having a draft that we can take forward and and it's not even that big a stretch so with some work today and maybe one more interim um after vienna um i think we should uh really uh assume that we can take a draft"
  },
  {
    "startTime": "00:08:01",
    "text": "forward to the isg does anybody disagree but i definitely agree yeah cool okay that's really all i wanted to say about that um okay shall we go through glenn's email now yes okay bear with me a second and i will not that should all be that should be there okay right okay so um we've got things labeled tasks which are actual it's actually i think very important you know not a lot of disagreement work that needs to be done can i can i just draw you back to the previous questions though because i'm new to ietf so i don't really understand the criteria of sending the spectrum of the iesg oh um i you know qualitatively i i i'll defer on the and the formalities but we simply have to achieve declare consensus that there is a draft that we think represents the consensus of the working group and um we think there are no no you know vital outstanding issues then we we do a working group last call uh do we do an iatf last call yep um so do we essentially have a feature freeze before this submission uh eventually what we'll do is we'll get to the point where we run out of things to include into the document we'll go we'll we'll ask the chairs will ask uh people in the working group if there's for we'll we'll do a working group last call uh and if there's no objections to us submitting it it will go through the rest of the uh the rfc document grinder"
  },
  {
    "startTime": "00:10:01",
    "text": "for which uh it'll go through isg and several other reviews uh where people will uh from various parts the ietf will review it and then it'll move on to the final step of the chain which will be auth 48 and the rfc editor okay i guess another way of asking the question is after we've submitted it are we free to make minor changes or is it kind of frozen it is kind of frozen but there may be feedback given by the various reviewers along the way they may uh review the document and say this is ready but i need you to there's some suggestions on what to change in which case the editors will make those changes and then uh it it'll get reviewed again and they'll go okay yeah i'm happy with it [Music] a lot of reviews that happen it can go to various directorates you know i see francesca joined us hi francesca um and uh when you when you get ready to do this you you get a document shepard which would normally be your id um and then they decide to direct need to review this for example security directorate operations director at art heart and so on um at some point there's an ietf last call too i forget the exact sequence where you just send an email to the costume would you like to correct yes so the the sequence is that the working group decides that the draft is ready and submits it to the isg now the working group usually wants to have consensus on the document that's uh criteria one but the criteria two is uh is the document in a shape where it will just die in in the review processes that follow it so we also have to make sure that that it's simply good enough to survive the next steps and the next step is an av review where the the"
  },
  {
    "startTime": "00:12:00",
    "text": "responsible area director looks at the document and sends us some comments so we get to fix those then we have an ietf last call where people come in with comments we might be able to fix them right away or we might wait for the isg bennett process which is the next step so the the isg members can provide their reviews and these reviews have discusses and comments discussions are things we we need to fix and comments are things we are so we are suggested uh to fix um and that usually takes one or two iterations and at some point we have fulfilled the discussions and we we have addressed the comments uh so the the area director again is the last uh person on on the list uh who who ascertains all these things and uh finally presses the approved and i don't want to drag this out just one last question what state does our reg xp have to be in does that have to be similarly complete well actually the isg will will probably ask us to make sure that is the case formally speaking uh we might go through the whole thing and then the since this will be a normative reference uh the document will will uh at the end get stuck in the rfc editor queue because it cannot be published without normative references having been published so that's the formal thing but in in practice the isg is not going to be happy to review a document with an open uh normative reference so it should be at the same stage the two documents should be at the same state yeah you really have to go forward together and i you know i certainly would not be happy with submitting either without the"
  },
  {
    "startTime": "00:14:01",
    "text": "other yeah thank you actually that's not true i'd be okay with submitting iregas but that's what i just wanted to say yes but it seems unlikely i think we'll probably end up doing both at the same time yeah so francesca mentioned in in the chat that the the last call comments should be fixed before the isg evaluation and that's certainly a good thing to do you don't want to have the same comment with three different solutions suggested by three different uh ideas you want to have also okay well let's move on hello everybody about this hello everybody i finally managed to to come in i'm now struggling to switch on the comments here in uh oh it's on the left it's in the left margin it's very small it shows two little balloons talking to each other it's two little balloons so there's there's a row there that shows the number of participants which is seven and beside it two little balloons and that's the that's the chat ah chat pedal i i see okay yes thank you okay so let's let's dive in on this yep um so in these tasks that need to be done so who's that francesca asks what what"
  },
  {
    "startTime": "00:16:00",
    "text": "documents are are we talking about so francesca we have two drafts one is draft itf jsonpath base and um unless you've been watching closely you're probably not fully up on this um the question was should we include regex functionalities in jsonpath filter expressions and the answer was that uh no we shouldn't do that unless we define what we mean by by regex and so we have another draft running in parallel uh draft iregx i think it's still a borman draft at this point um that uh that uh provides a small subset of regexp uh that we believe should be portable across the vast majority of popular implementations and then we would refer to that normatively from the jsonpath based draft so so so we expect to bring forward two drafts they're both pretty short does that address your issue got it okay got it okay kirsten um there's a list of things that are tasks um you're closest to the document i think or glenn which ones are our big things that we should worry about uh let me find the list once again it's on the screen on glenn sharing it james is sharing it i've put a link to the mailing list archive for this email in the chat uh if you want actual links because you don't think the screen is clickable ah there we are um i have no idea what editor everyone is um writing examples is a good thing that that's probably about a day of work to make sure these uh look uh good uh i'm not sure we actually have anything left to do on string normalization"
  },
  {
    "startTime": "00:18:01",
    "text": "okay let me just check the we probably should go through the issues we can do that um edit table one is actually an issue that you created carsten no my former self [Laughter] yeah uh examples again examples appendix that's another thing and uh we haven't finished the security consideration so we i think we need to have a good look at that but i think that's another half day or so or is there anything in here that unless we find somebody to assign responsibility to it won't get done and would be blocked well that that's true for all of them but i think we we have the people in the call who will take that responsibility okay okay yeah i mean i'll be happy to look at the examples um if uh if the suggested approach the examples would be to do in-line examples in chunks and then roll them all up into an appendix if anybody would like something greater than that then we might need more work yeah i think the appendix should have a slightly larger example um i think the inline examples well there are two ways to do these inline examples one is to to have a single json document that we just introduced and referred to in all the inline examples the the other way is to keep those in that example simple enough that you can imagine how to apply them without having such a json document um so we need to decide that and then for the appendix we might have more json documents but we don't want to"
  },
  {
    "startTime": "00:20:00",
    "text": "litter the the main part of the document with lots of example documents because these get speak quickly yeah and just to calibrate my expectation um my mind tends to gravitate towards towards strange edge cases because those are the most confusing but looking here or straightforward examples that just you know elucidate the text well we had that discussion in a different draft i forget which one the href draft and we decided that we wanted to keep the main document clear of weird edge cases i mean unless they they really are illustrating the the the works um then of course you can put there so if if you are describing something and are not not saying what what an empty string is uh causing that of course has to be in the main document but if you have just have a weird edge case that you want to explain put them into an appendix we call the appendix this small print because it's really the things that an implementer needs to read but maybe that most people who are using jsonpath do not need to read okay i tend to be in favor of more examples rather than less because in practice people will cut copy and paste them into their code and uh if we provide good ones then that would just be better for everybody's life yeah okay i'll um got an example then if you sign those two to me just have to make sure that we still have the knowledge of text and don't rely on inferring everything from the examples um and so we do need a uh a security considerations section um maybe we could invest like just a couple of minutes here in discussing what should go in there now clearly"
  },
  {
    "startTime": "00:22:01",
    "text": "um you know for the iregx you know the big thing you have to worry about is denial of service attacks um so that's something should be mentioned i'm having a little i'm you know i've written a lot of security consideration sections and i'm sort of scratching the bottom of the barrel here trying to think of what should go in ours any ideas will people well basically there are the security considerations of jsonpathx itself which is things like like parser issues dos possibilities and so on and there are security considerations with people using jsonpath in a security relevant context and uh creating security problems by by having the wrong expectations about what jsonpath actually can do for them and the second part of course is much harder to describe because we don't know all the applications jsonpath will will be put to so we can only give give a very rough indication of what the security considerations there might be for the first part the security considerations of jsonpath itself uh i think we should try to make sure we we capture all of them and of course we can point to to the ira gaps document for the regex security considerations i mean my my feeling is at some level that all that jason path can do is to extract if you want to say a piece of information from a document and it doesn't work at all if you don't have access to the whole document so in terms of information security um you could claim that jsonpath does not introduce any new vulnerabilities and i think that's correct well again you create dos"
  },
  {
    "startTime": "00:24:02",
    "text": "vulnerabilities if the runtime performance is unpredictable so that's one thing and the other thing is that you create security uh vulnerabilities if people think they can use paths in certain ways but jsonpuffs doesn't give them the guarantees they think they have and so typically normalization is one of the places if you're using jsonpath for for a negative list for what used to be called a blacklist uh then um you have a problem because there may be ways of of uh designing your json to pass this to to pass this negative uh list just because it's it's not designed as uh we catch everything uh kind of approach so that's i think what we need to write up and and that's pretty much it and i think i think there's also some value in covering information exposure as a sort of hand wavy uh concept and what i mean by that is is that if you allow users to allow for human input external input of a json path uh an attacker could craft a query that would expose more data than what the implementation had inferred and by implementation it could be a deployment or it could be a json path implementation itself acting with under a bug or something i'm being very hand-wavy here i i i get it but it's not just denial of service it's also information exposure i think we need to be clear about although the last one is really hard to define yeah i'm not convinced james i'm having trouble uh seeing a scenario here"
  },
  {
    "startTime": "00:26:00",
    "text": "okay there there was a request to reference uh other json documents somehow we didn't discuss that very deeply but if we uh consider this maybe there are some security considerations with exactly that mechanism but it should that's correct but as you said so far we haven't put that in either glenn's got a good one um is um yes the you know in anything else that represents json that deals with json you have to have something in there that shouts don't use evol and so we should probably don't use it okay yeah that's a good point yeah okay very good yeah i think i think that's enough let's let's move on into the issues with the recording of this meeting somebody should be able to write the security considerations in an afternoon i'm mute let me just add something i guess for any implementation language um you wouldn't want the implementer to naively delegate to the underlying libraries on the assumption that the edge cases are all covered you know they have they have to conform to the spec it's not just javascript in other words maybe in in five years we will all look at our web applications and look for json path injection like we do for sql injection today and that of course shouldn't happen"
  },
  {
    "startTime": "00:28:06",
    "text": "the difference is that you know if it doesn't pass to work at all you already have to have access to the whole document but nonetheless that's probably a good thing to capture okay moving on to these issues that we see on the screen glenn you wrote there are two that number 25 looks at least decided is that from that list yes this is looking back at that list that was security items i think we've covered that okay 69 and 136 i was just warning that uh uh you know what whoever takes it on it's gonna be a bit of a memory test uh getting the appropriate level so it might need a bit of iteration in the pr and that's in the pr so that's fine sorry for what are 69 and 163 that's right i'm sorry uh it's on the end of the issue urls inline examples is 136. oh okay okay okay so can we just assign these uh to various peoples so uh i'm happy to take 136 and 69. i've already assigned these uh to you glenn uh i've been doing that in the background yeah so who's got one four eight one one seven and twenty-five did you just say 25 yes okay brilliant how about 117. that will be very short so i can do that as well okay okay excellent i just have to stop assigning myself to these tickets and 148"
  },
  {
    "startTime": "00:30:01",
    "text": "created it and it's a little bit vague it's the edit table one yeah and i think this is the really quick thing to do so yeah okay thank you carsten excellent okay okay let's move into some real issues here um normalized and singular paths number one five five we had a lot of discussion on that um sorry for the layout but the previous one the first one is 150 should list selectors allow filter selectors and we've already covered that just to be clear for anybody that hasn't been following pr was merged yesterday pl 165 was merged yesterday okay nobody anybody disagree i i i agree thank you yeah that's normal this is not entirely clear cut but we need to make a decision and i'm happy with the decision so this selectors can contain all other selectors including itself so we have a list so we need to have a list of selectors being included in list selectors yeah and the that list is now present in the draft in the latest channel okay but it doesn't include for instance"
  },
  {
    "startTime": "00:32:00",
    "text": "recursive descent yeah so we have quoted member name element index slice index and filter expression yeah when i say latest trap i mean the head on the git repository yeah 165 what's that i can't see it in the last draft coded member name element index slice index and we we want to edit filter selectors yeah i'll put a link in the chat to the document i'm referring to which is as of yesterday latest yeah you're talking about section 359 filter selector h358 five ayah okay so i wouldn't mind swapping the sections it was reflections in the per request a boolean expression okay yeah okay i wanted to do that once um 165 had landed or been closed sorry not 165 164 okay because of the conflicts yeah so maybe just make a separate issue that uh says rearrange sections in 3.5 and also i would i would love to have"
  },
  {
    "startTime": "00:34:01",
    "text": "the uh the actual abn f that says question mark as boolean expression be defined by by filter selector so you can just say we we have the for each selector we have uh av f rule for the innards of that selector and we have an abn rule that adds the brackets and the spaces around that so we have list selector and and list well okay we don't have the the the guts but we have one one level further in and i think that that's a good way to make sure there's only one place where we actually define what a filter expression yes i would prefer this also filter expression yes so what do you want to change kirsten just uh factor the abn f if you look at the abn f1 from 358 and from 359 both have this question mark as boolean expert and i would just like to give that thing a name and i right now i don't have an i have a name for the whole selector but i don't have a name for for the innards of that selector we probably have to invent a name for that so the airbnf becomes consistent yeah that would be an improvement but i think that's something we can we can trust to editorial judgment yeah yeah i'll do that as part of the rearrangement then okay so filter expression might be a good name for it yeah yeah then we would be calling all the things between the brackets expression and i'm not sure i like them"
  },
  {
    "startTime": "00:36:04",
    "text": "capturing notes here okay i believe that leads to normalization and normalized paths um oh let me just look at that latest draft let's see on that wrong one okay yeah i think the the main outstanding thing from the issue from issue uh 155 was to um uh bring out a production for singular path and the definition for singular path and to use this in the rest of the spec where appropriate that was my question so normalized path is actually defined by its syntax and we say that we define that syntax in such a way that we achieve a certain property which is we we only select zero one nodes but the definition of the normalized path is by its syntax the singular path is actually defined by by its semantics which is that you get the zero one nodes so um we we can now look at jsonpath and see what is the set of adjacent path queries that have that property and we will come up with something that looks a lot like normalized path plus"
  },
  {
    "startTime": "00:38:00",
    "text": "a few other cases um but i'm not sure that that this is uh that we need to to do this exercise but maybe we do to make sure that that in a [Music] expression uh you actually only have one node to look at so what else would be in there besides what we have now i expression where you have a relative path at the moment um you cannot use every relative path because relative paths might uh return more than one node so right now relative path is defined very restrictive very restrictively and essentially what we are trying to to capture here is the concept of the the the envelope in which a relative path needs to be to be useful for a comparison and we call that singular path okay uh so in in the end we may not even have to add that concept to the document but i would be in favor favor of adding that to the document uh so so people understand better what we are trying to do here wouldn't it be possible to to name distinct selectors that will return singular path that's pretty much going to be the effect of putting this in the avnf yes right now red path is is the closest we have for that"
  },
  {
    "startTime": "00:40:00",
    "text": "uh i forget what rail path actually is so my um intention my approach in that pr was to take the current um relative path sorry the uh i've got the wrong draft now but just was yeah okay so it was to take the is it gone yeah so we've got path equals relative path or json path and relative path uh has the constraint that we've been talking about so it's singular but json path is wide open and can be more plural if you like so i was trying to restrict the abn s so that only singular json paths were allowed is everybody comfortable with that the restriction to singular path in in filters is heavily discussed recently and how should we deal with that circumstances is it how shall we react simply a state we want to have singular path in with relative path in filters or start to discuss how to deal with uh return node sets and how to compare values with node sets right it's it's it's very very hard to get a solution yeah yeah i think this is uh this is demonstrated in the discussion in pr 164 which happened in the last few hours"
  },
  {
    "startTime": "00:42:02",
    "text": "someone suggested um broadening it and allowing plural paths and some of the ramifications of that start to come out i think it's pretty unpleasant but i detected the consensus at least amongst the editors that would go for singular pass i think correct me if i'm wrong yeah i agree with that but we have to be careful where we actually need that property so for instance an exist expression does not need a singular path and i would actually even argue that the regex expression doesn't need a singular path of course we have to define what it means to to match a plural path to a regular expression but uh i think that that's pretty obviously a one-off uh thing but yeah we need to discuss this the comparable definitely needs a singular path okay that's that's good that's progress um how shall we discuss those do you want to do it here and now or separately i'm surprised about the regex that seems weird to me if i want to max a regular i want to match it against a string yes but if the path gives you multiple strings you can say you not allowed or you could give it a meaning if you tend to allow with the existence tests multiple results so i made an example in the chat uh this would be valid then"
  },
  {
    "startTime": "00:44:00",
    "text": "uh any the current uh note has any descendant named x okay but we could not write then uh that in a comparison yeah that goes into the the we need uh exists all on that so we are either looking for at least one uh dot x that that is equal to seven or we are saying we want all dot x is equal to perception and that becomes pretty hairy in a comparison expression i think it becomes less hairy in a regular expression and it becomes the obvious exist expression because if the thing exists it doesn't make a big difference whether you have one or two of them yeah i think um i think the exist cases is clearer because uh the uh the existence test is against a set of nodes or values which have been computed and therefore exist uh whereas the regex is a bit more tricky i think no the same is true there but for me the the regex is a difficult one because i don't know whether to end the requirement or so we've got two is it should they both match or should either of them match and for me because that's a toss-up and i think it's a toss-up in the reader's mind unless they remember what the details of the spec so if you if we keep it singular to a"
  },
  {
    "startTime": "00:46:00",
    "text": "singular path under regex then we rule out that issue and make it easier to remember that's correct i find that quite convincing okay so we go for singular paths for for both comparison and regex and allow general paths for the exist uh general path also means uh i i remember that we once discussed something like nested filters i remember that doesn't pause so should we allow with existence tests all filters is that is that any better yeah but what what is the double dots there the descendant selector but doesn't that have to have a name it's the"
  },
  {
    "startTime": "00:48:02",
    "text": "go down the tree yeah recursive descent without defending it descendant uh uh select i i think it's called i will check yes descendant selector this is the name the double door so you you want to add selector tool yeah okay okay that's uh something you could do yes potentially looking at your third step looking at three parts section three five seven but yet in fact the question is do we restrict the selectors we can use with existence tests or all selectors allowed inclusive filter selectors again so yeah that's interesting because this has a different runtime performance behavior than anything else we have okay i see a descendant selector does not allow uh filter filters okay i'm i'm fine with this i forgot well we could put it in i mean just as we did that for this selector we could put it in in descendant selector we just have to make sure that we know what we are doing"
  },
  {
    "startTime": "00:50:02",
    "text": "what's the stat is this stuff is this something that is actually loose in the wild has been implemented that way either we we can formulate it in plane we want to ask for any descendant which complies with a special filter down the tree is this something that's already implemented i i haven't seen that because i'm a little bit negative about adding new things that people have not so far found the need to implement i'm also very reluctant reluctant about this yeah we would need to look at the the the test from christian bulma i'm fine with the descendant selector as it is now okay phew thank you but if i remove one of the dots or both dots the problem persists with having uh filters inside of filters for pure existence tests"
  },
  {
    "startTime": "00:52:04",
    "text": "yeah so we could define another subset of path that doesn't have a filter uh selector in it so that would be the path that you would use inside of filter expressions but uh yeah [Music] i would apply the the memory test again what the what the user is going to be able to remember here and i would have thought was using the same rule for existence expressions as for regex's as for comparisons will be the easiest rule to remember rather than special casing existence unless it gives some major uh use case advantage which i don't think it does and once again if it's part of uh the existing idioms or not yeah which i'm pretty sure it's not actually so well i would i would need a couple of minutes to come up with an example of why why you want to use an existence test with a path that is not singular but i'm i'm pretty sure that's a normal thing you would expect to be looking for um and what does it mean if it's not singular are you saying any any match or or sorry any exist or exists yeah exists means it exists okay so existing yeah okay fair enough yeah so the the i think we we can phrase the the issue as do we want to be able to freely combine things here uh so we have to define the"
  },
  {
    "startTime": "00:54:00",
    "text": "the semantics for every combination uh do we find a way to restrict things so the semantics always stay simple and singular paths seem to be a way of doing that restriction so we can get simple semantics for comparison but then we have to look at uh other things like like nested uh filters which are not scaring me at all but uh which of course require um implementing something that you wouldn't be implementing otherwise yeah i don't think nested filters are a problem for the implementers particularly but i think it's it's more of a consistency issue between these various types of filter expression i think we need some real world examples for for this i will try to construct some yeah can i can i suggest that um carsten you have a look uh at producing those examples in pl 164 as a counter example 164 and we'll argue out there and get to a point where you approve 164 pr 164 as a way of progressing this i haven't looked at 164 in detail yet so yeah okay that'd be goodness but sure ah that's the singular path one yep"
  },
  {
    "startTime": "00:56:00",
    "text": "yeah but singular paths are not necessarily related to nested filter expressions are they no no not not necessarily but if we allow more selectors with pure existence tests we need to specify which one additionally except from dot selector and index selector currently we have a relative path restricted to dot selector or index selector right and with existence tests we would then put some other selectors inside of this list right and we need to specify which one we can exclude the filter selector so we don't have filters inside of filters yes we can do that that's a simple way to do that don't agree with that we should do that but it's good to know that we can do that i also need to think about filters inside of filters in case of real world examples and i cannot decide this at the moment"
  },
  {
    "startTime": "00:58:03",
    "text": "yeah i don't have an opinion um is the one thing i would really you know ask to to keep in mind is let's not extend jsonpath okay you know let's let's let's let's not extend right let's try and do what our charter says which is to find the interoperable subset of you know what the state of the art is considered to be now you know i'm happy to have the uh the the normalized path that actually met an application need i had in the previous life so i know that actually has a use i am puzzled to be honest about singular so okay well the difference here is that normalize path is something we don't actually use in our grammar it's just another production that we export and then say this is a subset of jsonpath that can be used as a normalized path while singular path is something we would use within our grammar for instance that's something that you can have in a comparison expression right but implementations who will return normalized paths are think fully about a specification specification of them yeah i think we agree on that sorry i dropped out my internet went down briefly so just recap what we've got what we've got [Music]"
  },
  {
    "startTime": "01:00:00",
    "text": "so the question the question sorry no i don't even know i think i can crystallize the question anymore i give up so i think i took the action to look at examples where nested filters would be useful and i think that that's the first step and maybe i can also find out whether christian bergman has done a test for those and from that we can decide whether we need to to open up relative path or whether we can survive with a single singular path production okay thank you okay i just see one one danger um when we start adding um attributes like like singular uh to the productions in our grammar then we can have an explosion of of a combinatorial explosion of of rules or we can do something like like what ecmascript does where they essentially have hidden a little bit of an attribute grammar or two-level grammar in their grammar notation but i think i would like to avoid that and stick with abn f if possible so i think at some level we are leaving this to the editors"
  },
  {
    "startTime": "01:02:05",
    "text": "yeah i think we we need to have a consistent proposal because this there are so many things that that are interdependent here that you have to look at the whole proposal okay it seems to me that the understanding is somewhat shared if you guys will please wrestle with us and convince us that you've got the right answer okay so let's move on um function notation now that's not in the current draft right i see the problem with supporting some functions returning number numeric values then we can't do that without arithmetic operators if we have a length function we want to calculate length minus two plus five right arithmetic uh and and i i can't see the demand for for arithmetic operators in jsonpath so the approach i"
  },
  {
    "startTime": "01:04:01",
    "text": "called uh putting the index directly to the at sign is very uh uh useful i think but general general functions uh so here comes in to my mind extension points and i must confess i i it's not clear for me what what exactly are extension points and how we can use them within the json path i think that that's a very important point so we have talked about ad index which um is is a weird thing because it uh violates our processing model that that we have a particular node we are looking at and now we are looking at the parent relationship um of that node or if we are talking talking about member value we are talking about looking at the member name so that's one issue we can discuss this but i don't want to discuss this now um but it's another example besides length where it would be nice to have a way to put names uh into the um jspath query so we have that name as the place where we can put in additional"
  },
  {
    "startTime": "01:06:00",
    "text": "operations without having to to change the grammar each time we do that so if you ask me i would do regular expressions by using something that's called matches and not by equals student but that's not existing practice so so let's let's ignore that uh but uh i think that that's just another example of how we could be using a name um as as an extension point in in the grammar i if i can summarize i i think what i'm hearing is that whereas nobody has a burning example of a function that they want to put in right now that it's a very very natural and idiomatic extension mechanism for things that might be put in later so there might be a benefit to putting it into the um grammar now um which you know give implementers and people with bright ideas a signal um uh you know there's probably but you also need to do a use it or lose it so we have to have at least one thing in jsonpath that uses the extension mechanism or people will simply not implement it so length is the one example where i think it's pretty obvious um that that we could do that so something like like at length uh i i agree with the stefan's assertion that it's not that useful without arithmetic but i think uh being able to say i i want uh to have entries that have at least two elements i think that that's a pretty normal thing to to do in a query um so i i certainly can come up with an example of length that doesn't need arithmetic"
  },
  {
    "startTime": "01:08:02",
    "text": "in general i'm not a fan of putting things in now because you might need them later i just don't think that's there's a famous essay but you're not going to need it yagni um which which talk talks about this at great lengths but that one software that works for software it doesn't work for protocols in protocols you always have to plan for the unplanned uh so you you don't put something in but you put in a way that the unplanned can actually attach to your protocol and the protocol can grow because otherwise people will do weird things i mean jason doesn't have comments so people are adding members that are essentially comments and which maybe is a feature not a bug we can discuss that but uh um i think we we know that there will be a need for extension points that that's absolutely obvious and um the question is can we put something in and maybe even solve this this pesky length thing while we're at it and also follow the the user.lucid guideline there are some a few a few implementations that allow functions at the end of a query but uh this from my point of view is just some kind of post processing with with the results this is not a json path thing that's any other application that will get a list of normalized path can do that separately but i would like to"
  },
  {
    "startTime": "01:10:00",
    "text": "do a regular expression analysis with names of uh with with indexes so there is no way in chasing paths to query the name of a member or the index of an array element if we have this we can exclude in a filter give me elements this and that but not element named temp so we we we need somehow an access to the index of the current element i think it's a demand that is rising arising uh very often i think so it's it does not qualify for a function why not because with each func function you need to specify what kind of parameters does this function accept so index function of the current element but if we allow this we we can also give any other path to this function and what shall we do with the result so this operator approach"
  },
  {
    "startTime": "01:12:00",
    "text": "at index would would be more advantageous i think my point of view steph stefan do you accept though that it kind of breaks the processing model uh what what do i accept the processing model okay so you would apply the the index operator uh when you are on on a particular node and the index operator looks into the vicinity of that node to find out what what the index of of that node was so you're kind of ascending through the tree again of course another way of modeling this would be that whenever you have a node you keep some some context for that node as an attribute of that node so you know what the index was you use to get there um so maybe it's not such a strong violation of the processing model but it's definitely outside what we have been discussing uh so far but i was not trying not to do the the index thing at the moment but stick with length as an example for something where we could use this extension point obviously i have a i'm having a hard time to write an example because we don't have a syntax for that so percent hash mark ampersand is my proposed syntax for the moment i know we will change that and so this is an example where we are looking for all perpetrators that already have more than two convictions and uh i think that that's a pretty"
  },
  {
    "startTime": "01:14:01",
    "text": "normal query you would uh put in somewhere and um yeah from you you you have this path add that conviction and this path is not singular um so you would look at the the uh size of that uh node set and if that size is is greater than 2 then this comparison would return true can i can i just step back a moment and ask about extension this extension point idea is the idea that it would be exploited in other rfcs or could it be exploited by an implementation without needing an rfc well there is a bcp about that um i mean you wouldn't rule out the former but i would think that what would happen is that somebody who wanted to bring in you know predicates based on ml models and stuff like that you know that's where you would put it it provides yeah but one point making is um uh how strict are we in the syntax checking essentially but the syntax shot should be stable it should be clear that there is an extension point in use and which extension point is in use um but uh your question actually uh immediately uh makes me point to rfc 6648 i think everybody must have read that document because it summarizes 20 years of experience with a particular"
  },
  {
    "startTime": "01:16:00",
    "text": "way of using extension points that didn't work out very well at all um so we have to be careful about that namespace um but yeah stefan that's just uh one one uh character we could uh use for for the extension point so this is also uh we can choose one of those characters you probably are proposing and this would characterizing then an extent extension point which not necessarily would be a function but maybe it's one well it is a function because it has as input the the current notes app okay it's implemented as a function but it has it it does not have it doesn't use right it doesn't use parentheses so what i like about that length is that it doesn't use parenthesis but we cannot use the dot because it already means something different so using something like a hash mark here is certainly um one way of doing the syntax so though with this we would get the the the name or the key of a the index offer if we extend the processing model to allow it yes so that's the syntax we are still discussing the semantics but the syntax would be the one that resides here hmm okay i need to read this"
  },
  {
    "startTime": "01:18:00",
    "text": "rfc6648i i think so tim you may know that under x-dash that was its original name and unfortunately no longer is in the title of that oh there it is so what what happens to interoperation with this kind of extension point model we can kiss it goodbye no presumably there is a sorry carson go ahead the the fact that the extension is being used is rather obvious from a simple part of the query so you can look at a query and extract the set of extension names that have been used in the query i think that's one important property because many extension points don't have that property and that that that means you you have to have metadata about the thing uh to know what extensions are being used and and here we have a very clear path from the query to the setup extensions that are uh being used so that that's a good thing the the next question is yeah how interesting go ahead but what if two implementations clash uh on an extension point so they both choose the same function name different semantics don't do that well how can we we need to curate that namespace and again look at rc6648 for the namespace issues that come up here because of course you do want to"
  },
  {
    "startTime": "01:20:00",
    "text": "provide a way for implementation specific extensions to use the extension mechanism but then what the next thing that happens is that there are some of these that are so popular that the implementation specific part of the namespace uh migrates over into general use so that's a problem for which i'm not aware of any easy answers um so i think we we have to choose the the thing that has the least pain here uh but any kind of extension mechanism is going to have that problem okay yeah i you know just listening to this discussion is not making me happy about this idea you know i i you know i like the idea of having length i like the idea of having index because that's sort of a big hole in json path at the moment um but inventing a general purpose function notation with a new syntax character and so on is a big step it's a big reach and jason path is pretty popular you know without that right so i'm not gonna lie down on the road if you guys uh you know i'll get excited about this yeah i i share tim's concerns yeah i agree with those concerns i just think that having an extension point is so so incredibly mandatory that that overrules that okay but isn't it possible to take the current spec and to extend it compatibly by adding an extension point in a later spec yeah actually that's where the interrupt issues come from right because if two"
  },
  {
    "startTime": "01:22:00",
    "text": "different implementations go and extend it in their own different ways then you have all kinds of problems where if you just design an extension a way of generalizing extensions then that in theory goes away i mean you can go nuts and you can say okay we're going to have a registry of extensions you know absolutely extensions or we're going to use yeah sorry what's that that's not nuts that's the way to do it yeah but that wasn't my point my point was could we not defer the spec work to add extension points to jsonpath to a later rfc and add it when it's needed would that not be yeah it's going to be too late why because people will pick this up invent their own extension points then we lose the capability to look at the json path query and and get a precise set of the extension point points that extend tension mechanisms that have been used so if we agree on the hashmark syntax then we can just look for the hashmarks and then we have a list of the extensions that need to be supported to to run this query we then also have to to curate that namespace so that's the hard part of the problem but the easy part is things become easy if you at least have a common syntax and not everybody who wants to extend things invents their own syntax for that yeah okay so to play that back to you uh it's now or never for this extension point mechanism yeah we always can do it and and contain future damage but we cannot contain damage that has already yeah the reason i'm i'm having trouble warming up to this is you know json path is out there lots of people use it it works um but the reason this rfc exists is to define the interoperable subset so"
  },
  {
    "startTime": "01:24:02",
    "text": "that you know if you use this then if somebody breaks on it it's their problem not yours you know to oversimplify and that's what's motivating at least in my mind this work so it's you know having a built-in escape hatch for a way to be non-interoperable it bothers me i i see it from the alternative approach whereas if we provide a commonality for extensions it means that uh future implementations can ignore extensions in a consistent way and and implementers can decide we're not implementing these these various extensions before for our particular uh deep whatever um and so where there's a high degree of future proofiness against that i mean you know the madness you want to avoid is what happened to sql right where whenever given a choice of things to do they took both um and you know and put them in and you end up with something that is entirely non-interoperable um i hear what you're saying i'm going to shut up now yeah this doesn't eliminate the problem the the the kind of problem that you're describing with sql but it at least provides a sinkhole for uh people willing to extend it and for implementations willing to implement those extensions sql never provided that uh in expect it was a bit too rigid and then people went off piste we could rename it sinkhole point instead of extension point i like that oh i think it's a bit early for the bike shed on that one carson so clearly this is something that would be to be added to the existing draft"
  },
  {
    "startTime": "01:26:01",
    "text": "uh right right up here somebody okay yes it's not in there right now so we we have to write the syntax we have to come up with our policy for uh curating that namespace and i'm arguing that we need to put in at least one or two mechanisms that actually use the extension point so people are motivated to implement it um there will also be a bit of work around ayana considerations for a new registry right carsten yeah that's the policy part yeah okay so those are two separate arguments and i'm not sure they follow from each other i think it would be perfectly okay to put in the extension mechanism and not use it leave it for others the stuff that we put in goes into the language yeah why would you want to do that i think if we uh discuss about functions and and and index or name key access by several approaches i think a general approach via this extension point would be a way to go what about if we have such an extension boil point would it be make would it make sense to to include special extensions in to this spec so if you want to access a member name or array index call them index"
  },
  {
    "startTime": "01:28:02",
    "text": "for instance or is this against the policy of extension points i think that's exactly what carson was proposing is let's define the mechanism and actually use it in one or two places and index is a perfectly sensible choice of where to use it yeah except that index requires changing the processing model so that's not not the the poster child here for for using the extension mechanism okay i i think it is it has a charm so at the moment it's not in the spec if it's going to go in the spec we need to see a crisp proposal for putting it in the spec and if we can build consensus around that then we put it in the spec hmm yeah okay i agree yep yeah i think i'm i'm reaching the limit of the numbers i can assign to myself but i certainly can do that such an extension point is always the last element of a json path relative for absolute is this correct i'm not sure it right"
  },
  {
    "startTime": "01:30:01",
    "text": "it cannot occur in the middle of a pass i think right now i don't see a strong reason to exclude that but that would certainly be a start so we would essentially have an extension selector and that syntactically looks like a normal dot selector but it uses a hash mark instead of a dot and it can return a note set so you can continue uh adding other selectors to the end of it or it returns something in this case okay it's definitely there's definitely some language you'll have to clear up around um ensuring that it returns something that is valid for where its position is it's an experiment at least i think we have a strong voice suggesting it's worth a try so let's try yes okay let's move on then um object and array indices finding this should come up um so i guess the fair summary of the question is that it's a it's a thing that you can't do now and uh people get are surprised when they discover they can't do it um on the other hand uh you know okay people we've survived so far without it um yeah yeah that's exactly what we just discussed right under the name of index yep"
  },
  {
    "startTime": "01:32:03",
    "text": "i personally think the case is plausible but not that not that compelling so i i'd leave it out but i'm not passionate well i might put a simple form of it into the extension selector proposal and then we can always delete it if we don't like it okay yeah my remaining problem is what is the index of the root and apart from that i think that's it can be described relatively we look forward to reading your pr yes definitely okay all right that's a good idea let's move on so uh at sign optional no no okay good no next i like that yeah oh the function showed up here again yeah i think so we've had a lot of discussion about this should we make a note yeah there's been quite a bit of discussion we can't just although we can we can gain consensus and say that i think that that needs to be cleared up on the mailing list oh sorry on the get up issue i think we can declare consensus on that okay see if anybody screams okay"
  },
  {
    "startTime": "01:34:00",
    "text": "okay what's the issue on related standards this one's new to me well someone is pointing to another document and says we should relate ourselves uh to that and my my take on this would be if it is likely that somebody will come to this document with the other document in their mind and try to find out how this is the same or different from that document then this is useful it is useful to have text during the relationship like we have our appendix a for xboth assuming that people who are still in the xml to json migration we'll know experts and we'll try to find out what's going on with jason pass that's useful so that that's i think the the position on this um i wasn't even aware about this jason path expression but i'm sure that there is a community out there that is and if we have somebody who could write a meaningful paragraph about that then it might be worth writing that paragraph and that would incur also having the reference but having the reference without that paragraph doesn't make sense at all okay if we have another standard we it's in it's it's actually in the sql iso standard good lord well it's the kitchen thing standard so why would it not there is a reason that that sql is among the list of programming programming languages in the monthly programming language contests you have you it's steering equivalent you can do everything in it what you ever want to do i sometimes worried that the"
  },
  {
    "startTime": "01:36:00",
    "text": "sql standard would it would attain sentience and i am but i'm a bit nervous about making even a non-normative reference to a spec behind a paywall yeah yeah i'm in fact i suspect my instinct is we would probably get shouted at for doing that in no no we are not referencing any anything normatively out of that so yeah so i i usually circumvent this problem a little bit by adding two references one one to the actual thing the actual specification and one reference to a more accessible reference that of course doesn't need to be complete there so that can be used to diffuse this payroll are argument but i think it's not a strong argument anyway because the whole thing is about writing a paragraph making it simpler for people already coming there uh to to understand what jsonpath is about and so the really question is can isg vet that paragraph and uh who's going to write the paragraph i mean i i don't really yeah somebody who knows your json path so let's find that person okay so there's our finding is if in fact somebody writes a paragraph with useful content for somebody coming from that direction then it's probably okay to reference it non-normatively yeah can we throw that back to the razor of the issue what is that yes yes i think that's the action is to request that anybody i presume that they raised it because they're involved in [Music] as it goes through its um finalization"
  },
  {
    "startTime": "01:38:02",
    "text": "because they'd also have to check that the statements made even if they're non-normative are true so everybody has to buy a copy of this thing no usually glenn for uh restricted documents one's either behind paywalls or um i know that there's another uh there's a specification in another part of the ietf where it's uh classified or top secret or something one of the ref normative references is that there's usually an arrangement made with a small subset of uh the iesg or co of people qualified or they or in the case of iso they usually provide a draft version to a handful of people at an ad hoc basis so now there's this that you won't have to be shelling out 98 swiss francs for for this okay 98 would be great i think we we should not uh reference the implementations of json paths despite the fact that they call themselves de facto standard or something like that so we can discuss other related standards but but not uh implementations i think yeah some implementations actually come with the specifications so for instance in the irax document there is a reference to re2 and re2 is is a well specified regular expression syntax it's it's not the formal standard but it's worth pointing to that uh so we have a reference to that but"
  },
  {
    "startTime": "01:40:01",
    "text": "otherwise yeah i agree implementations are not that interesting as long as the standard is based on an uh existing implementation this is okay but jsonpath is not built on any implementation i'm aware of okay okay i think i think we know we're doing here um let's move along um output of normalized paths what is that i don't even know what that means this means that an implementation uh currently an implementation is allowed to return a node set or a collection of paths normalized paths to those nodes or both but it's entirely optional i think the request here is to make the output of normalized paths mandatory for every every implementation i i can remember there was once a comment where the output as uh from queries as uh normalized path is also the input for new queries so it uh in this context the there was a demand to put the abnf of these normalized paths uh to the other uh selectors but i agree that's not necessary it we we can leave it where it is as uh yeah i agree"
  },
  {
    "startTime": "01:42:02",
    "text": "yeah we should have the the syntax there so people who just want to operate on these normal normalized paths should be able to find the syntax in in the document but since it's a subset of of jason pass i don't think we have to do anything else yeah okay now we come back to an issue we've already taken up singular path um and that was where we're going to go and fight over 164 on that and try not to extend json path but i think we've already discussed this one yep okay equality comparisons of structured values um where did we get to on that we don't do it that's right okay so can we close that we should elaborate as to why this needs to be closed it looks like there's been a lot of effort put into this maybe it's not such a big effort because if we restrict it to equality we only need to do a memorize comparison of arrays and objects that's it well recursively at arbitrary depth of course right yes of course recursively normalize the member names yes yes yes and so we we don't do it"
  },
  {
    "startTime": "01:44:00",
    "text": "it's okay so jamie what do you think we need to do just i was just more making a point of commenting on that uh pull request elaborating why that's all yeah i think we just need to write that in in several regular meetings the the issue of operating on structured objects came up and we had consensus that that would not be a part of of json path base okay it was a misunderstanding from my side i i thought it was a agreement to try to put them in okay but i i'm fine with it to leave i think the correct polite terminology is this failed to achieve consensus support okay so who writes that i can write it yeah that would be great because the thing that comes from a chair is kind of a normative statement and is that still issue uh well let me make sure i get this one on my screen is there the link there one four five that's the pull request yep yeah okay i'll leave it open in the tab we just probably closed this one off um so we're if we have an expression like let me put this in the chat uh question mark uh at dot foo equals equals dollar bar and those select um structured types then we're just going to say false even if they happen to be from a human point of view equal"
  },
  {
    "startTime": "01:46:06",
    "text": "i think that's correct yeah okay i feel a bit uncomfortable with that but maybe i've i've forgotten the kind of worms that we didn't open up today yeah what makes me uncomfortable of course is that when we do our json path category at some point later on then we may want that expression to have a different meaning and that's always bad if extending something means that existing things get a different meaning and there there's no way to recognize this as a syntax error or something because we don't know what is going to hide behind the the at dot foo and dollar dot bar so yeah i agree i'm a little bit uncomfortable with that too yeah i mean i mean the argument is simple it could get out of control it could be half a megabyte of densely structured stuff you know normalization issues come up and uh anyway i'll write something if they end up if a howling mob comes screaming at us we can take it up again but for the moment we are failing to achieve consensus yeah but we still have to solve the problems that that brought up yeah maybe just acknowledge this um anomaly that we introduce into the spec by preventing this there are two different things here one is do we actually have syntax and features to manipulate these structures objects and i think that's where we have consensus that that we don't want to do that the other question is what is the meaning of this expression and"
  },
  {
    "startTime": "01:48:00",
    "text": "yeah that's not so clear-cut this is exactly what i uh what i made in the pull respect where we can do something like yeah that means that we actually have a syntax now we don't have a syntax for putting in arrays and we would need to add that to make this expression possible ah okay i i yes i i see this is what you mean with with syntax okay we need the abn f syntax for objects and for for for erasers okay so uh for now we we skip that so we also [Music] uh must not support glenn's comparison yeah and uh probably the way forward with that is just to point out the string normalization issues associated with influencing that in general and that will put most people off i think well that that occurs with uh atoms as well if you just have two strings and compare them then you"
  },
  {
    "startTime": "01:50:02",
    "text": "yeah what does our draft say about that now does it specify unicode code points i think so let me check that it's not trying to change jason so it takes the definition of a string from jason which section is that but it should be in three five nine because that's where the comparison is introduced and three five nine is a little bit short on that the whole set of notes in three five nine actually need to be expanded uh into uh reasonable normative statements these are not nodes these are really defining things so that that's maybe one of the tasks we still have ahead of ourselves yeah i think the semantics section is a bit thin as well yeah oh that's something that i care about a lot i i i want to slam the door on normal forms and so on there is a difference between normalization there is difference between normalization and normalized comparison and i think the the industry consensus has been a normalization bad normalized comparison good sorry what do you mean by normalized comparison that's the the cop out that people have invented because you you can't get normalization right it means you define"
  },
  {
    "startTime": "01:52:00",
    "text": "a comparison operator that essentially is defined in a similar way you would define a comparison operator if you had normalization but you don't require the normalization to actually take place uh yeah i i disagree i you know i what i want to see in specs is comparison shall be on unicode code points and only unicode code points and nothing other than unicode that's certainly what we have decided to do in pass as far as i know okay good i think the draft doesn't say that yet so we should fix that okay okay we're getting short on time here can we get so stefan had a few things he added on here i think we got to addressing objects in our indices making at optional functions oh it looks like a no i rolled that into my list oh yes yeah everything everything's been covered i think tim so excellent so i think we can move on to what we're planning on doing for our next meeting yes um when should we put one in so let me see so ietf is in two weeks time and we don't have a schedule we don't have a session for it which is why we're today um i would propose that we do something in uh late april or early may i'm fine with that how are people schedules any big vacations or trips coming up we should stay away from yeah i'm i'm away in early may okay should we try for late april then yep it might be a bit tricky for me most uh public holidays here or around that time but we'll make something work so i i would say week 17 hit on that i'm gonna have to get the calendar out"
  },
  {
    "startTime": "01:54:01",
    "text": "for that carsten yeah which what's the day date of that april 25th week of april 25th yep everything but the wednesday is fine by me yeah i prefer earlier in the week because it's running up to my holiday in may otherwise okay i'll put a doodle poll out for the monday tuesday and the thursday and we'll see which options people come back with and usually 2 am time okay i'm used to it just what you need a good night's sleep isn't it well it's it's actually i have i'm meeting a friend at a pub in the afternoon and i'm going to a concert in the evening so i think i'm going to be really tired by the end of this day okay are we done i think we're done and the action for me very useful meeting yeah yeah that was great thank you everyone okay thanks everybody thank you bye-bye thank you you"
  }
]
