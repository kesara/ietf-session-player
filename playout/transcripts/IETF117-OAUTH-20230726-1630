[
  {
    "startTime": "00:00:19",
    "text": "Okay. Yeah. Okay. Okay. this Okay. Good morning, everyone. Welcome to the second session of OAuth. this is the not well. Again, a reminder, this covers everything that we do at the IDF. If you're not familiar with this, please get familiar with this. It's important. So So these are the tips on how to use the tools. we went through those. Hopefully, you're already familiar with them. I'm not gonna repeat those. So before we start, and some not pleasant news. Some of you might I've noticed that the tutorial is not here. And many of you know know Victoria's identity guru on icon in in the IETF and and with with with this and with this work group, is not feeling well, unfortunately. he he's battling cancer"
  },
  {
    "startTime": "00:02:00",
    "text": "We miss him here. We we hope to see him in the future And or thoughts and prayers is with him And Stay strong, Victoria. Stay stay strong, my friend. So Where is him? So I'll leave it here for a second and if anybody has any thoughts on wanna share anything Feel free to do that. Okay. k. Right there, Brian. I I don't know how to add much to that, but is Guru and an icon, but he's also a a teacher and someone who's tremendously generous with his time. to people and considering teacher and a friend to Thanks, Brian. k. Okay. So quick update on the IV program. we had that discussion yesterday started And at the IUD open, meeting. We'll gonna continue that discussion at the SAG meeting tomorrow. So Colin Dick and and myself will be kind of presenting this again and maybe taking a different angle at it. and see how how it goes. So please make sure to join the SAG meeting tomorrow at 3:30."
  },
  {
    "startTime": "00:04:03",
    "text": "reminder, the OAuth Security workshop is is open, and it's gonna be in London So If you're interested, Yes. I just Okay. Today's agenda Deck will be talking about Jot embedded tokens And then George will be talking about transaction tokens. Peter will be talking about cross domain identity and Aaron will wrap it up for 1st party native apps. And remind you that we still have Friday m, which is dedicated to verify the credentials, so make sure to attend that that meeting. Any comment about that agenda here. Okay. tech. You want me to drive from here? can. Okay. Okay. Morning, everybody. Decart, Dickart, Dickart, at Hi, Mike. How are you, Mike? Oh, excellent. How's everybody else? Everybody awake? Everyone's got coffee? hope so. This this isn't gonna be a session if you just tune out, and I'll participate. This is participatory session. So what problems are we trying to solve with embedded tow that. It's So some of those are know, how I got involved is, like, You might have claims from a number of different issuers, AROUND THE USER AS IDENTITY CLAIMED you're gonna wanna put them all together and bind them together into another token. use case from Where is yeah. Italy? Yeah. Giuseppe, right, is where, you know, there's a token that includes some other took into that context because they're within this one token"
  },
  {
    "startTime": "00:06:04",
    "text": "And then there's a number of use case is where you're trying to have a chain of tokens along and they're trying to say, okay, you know, It's a problem that many people building more complicated, infrastructure where, you know, a token comes in to one service, And then way down. There's a number of other services that are trying to understand the context of what happened at the beginning. And so You know, there's work happening in a couple of areas around how do you move that. through. Does anybody NOT THINK THESE ARE PROBLEMS TO SOLVE Anybody? Anybody? Mueller? Okay? Next 5, So we went through some of those use cases. Specifically, And this particular draft is starting to get referenced by other drafts which is fairly strong indication that people are wanting something around us. Next slide. So I'm gonna go get my water. I'll be back. So if you have made the mistake of asking if I wanted to present at this meeting. And so I sat back and looked and thought, you know, What are all the really nails sitting back architecture, what are the approaches to solve this? Right? There's, you know, some things going on. And I realized that we don't necessarily need to standardize how tokens are embedded in other tokens. you know, we could let people make up their own claims, and say what was inside of that claim. You know? so they could make up another claim. That claim could"
  },
  {
    "startTime": "00:08:01",
    "text": "have just a token. Right? So it's just a string value. It could be an array of strings. It could be an array of objects, or it could just be an Right? But they would be able to define their own go into more detail into that. Or we can have a general mechanism around how tokens are embedded in other tokens. And so you could start off with. It's just THAT THERE'S In the dock, it's there's tokens and it's an array. of objects, And then that type could either be What I have is 2a is It's a generic type of saying, at a high level, the kind of token it is, and then there's potentially other planes within that object to give you more context Or that type could be sort of more of a specific of this is this particular kind of token, you know, claim that's in there and provides more context as opposed to a more generic high level. Okay. So I'll go into more detail on the next slides. So there's the 2As on the generic type. where you know, you've got a type and then you have a token or you could have references to a token if it was like, the type was you know, this is an ID took in reference, and then there'd be some reference things. You know, we're an access token. or reference. any Questions on this, you don't have to go to the mic. You just put your hand up and tell me, and I'll repeat Is everyone yes. That's all. of the AOC. that being addressed I'm I'm polling up at a more mental discussion as opposed to the specifics of that. But So the question was, What could somebody do with the token that's embedded?"
  },
  {
    "startTime": "00:10:01",
    "text": "And My answer is the token type would say what you could go and do with right, that Or we could decide that there's some signaling This is why there's sort of 2aand2b. So a generic type could say, what can I do with the token potentially? generically, Right? And that so it's an access token without saying what kind of access token or help might be used, or If we go to 2b, Right? You can go and get specific of it. This particular kind of took Right? So this would be an example where the type is you know, specified as being the Italian type for access. And so you know exactly what you can do about it, because it's all defined by the type. Was that Makes sense? Go to the mic. Go to the mic. Okay. Hi. So I understand that you know, there are claims within the embedded token that sort of talk about how that token could be used or what that some qualification of that access token but there seems to be an awful lot of trust that you're placing on the recipient of the embedded token that they cannot somehow abuse that you know, the token and represent themselves at as the party that was issued the token. the first place. Right. I think that's an important detail to talk about. but but but But WHAT I'M WORKING TO DESCRIBE IS ACTUALLY AT A HIGHER LEVEL AROUND how do we How do we do these things? Okay. So I I think something like that is gonna be per my description here, right,"
  },
  {
    "startTime": "00:12:01",
    "text": "it's either specified sort of directly by the type by being very specific as a type of being saying, what are you allowed to do and what might happen? and whether people should do it. Right? And and and And, actually, per your question, I think that's sort of a security concerns that if you're embedding a token, right, that people could abuse it. Right? And so if you're embedding it, but that's an architectural decision. That's an -- Right. -- decision on the implementation of how they decided what they do with it and and sort of THAT'S A LOWER LEVEL DETAIL ABOUT I'm embedding token, what could happen. Yes. So I I I think the one of the considerations here is kind of how do I find my token inside of whatever bag of tokens. If I'm part of an architect, sure that has multiple of these things used. Right? That's number 1. Right? How can I find my stuff. Right? And the other thing is How do I ensure that nobody in the middle throws it away? That could be a yeah. Yeah. So, I mean, the once once I'm in an architecture like this, participating as an entity, then I'm going to some entity here is kinda wanna kinda get at its own part of know, that's the reason you have a a generic bag of right, then you you connect them in one place. Right? k? And there's an advantage to it. Yeah. Yes. Exactly. Right? So I am in in the code, know, I'm I'm looking in the tokens list, and I'm trying to find you know, here here's stuff relevant for me. Right? and I think that's probably the only consideration you have to think about. Right? because you're not if you're in this architecture is going to be I I is gonna be fairly tied to the business process that you're not there there's no general are very few general processing rules here. Right? Am I Yes. But this is why I'm bringing this up for discussion -- Right. group. And that's, I guess, that's the possible discussion. Right? Yeah."
  },
  {
    "startTime": "00:14:00",
    "text": "they're they're could be things that, like, if you're You've rephrased what I'm asking. Right. The what are the generic what are the generic consideration. Is is there scary things or not? Right. Or is there anything just be Pacific, I I would come down. I guess I would argue that it it you know, keep it as simple as possible. because the only thing you're gonna wanna do, I think, in this situation miss to find your thing. Mhmm. Well, I'll deal with it. potentially. Yeah. So Yeah. I was gonna go to the Alright. I sort of gave my choices out of order. I did 28 and 2 b because those are more aligned doc is, And then the next one is one, which is, like, we don't even spec a container, And we just say, TO PEOPLE Just DEFINE THEIR OWN TOP LEVEL tokan, And so, you know, per these comments, like, you just look at the top like, why I'd look in If you're looking for some specific claims, Right? You can just look at them at the top level, and yeah, but there there is one made it a little bit too simple because there's one more generic consideration That's some middle thing. doesn't strip out. these things. Right? So if you're if you're doing that, There's the risk that somebody somebody's implementation tries to be very strict goes, I I don't recognize this claim. I'm gonna drop it on the phone. something like that. to pass it in when you're passing it through. If you you can't take that out because then it's not signed more. No. If you absolutely, if you wanna preserve this Yeah. Hold on. But they're you you could take anything out. Right? I mean -- Yes. But the the the use of a generic my mic. Yeah. My understanding of the spec, and Mike, correct me if I'm wrong, is that you're supposed to just ignore anything you don't understand. not supposed to Alright. If if everybody does that, then this is gonna be good enough. Yeah. Yeah. Well, it could be. I mean so the"
  },
  {
    "startTime": "00:16:01",
    "text": "potential pros to HAVING SOME MEKINISM IS THAT LIBERIES THEN have understanding around what's there, right, that they can generically process and validate embedded token, Maybe. Right? I don't know. A lot of -- Because I was wondering whether you have some form of use some form of content type or something to indicate, like, register a specific tokens, like, in here you have the the type. I don't know if that type is sort of It it's probably one way here, you see ID token, But it's like, we have this content type mechanisms also in in other places. Wamediotype, to just indicate to give enough information to pasta token And then to find out, like, what to expect in there. Like, in general, because otherwise, it could be anything. Right? Like, here, you went a little bit overboard by having to type literally a URL, I I don't know if that's that's what you want to go with it and just leave it, like, completely augment it. -- 3 options to accomplish similar things. Yep. Mhmm. And so the point of the Sussion here is to get feedback on The pros and cons aren't 3 different approaches. So I'm not recommending one approach, I'm trying to get feedback around Well, one is Is there even value in specking a container and stuff? because that's what the spec would be. And if option 1, Yep. You're my handy. Yeah. Yeah. If that's good enough because people can just define their own high level URI, and see what it does, and they could drive it. They could either standardize that or just use it and receiver looks at that. Mike, Mike Jones."
  },
  {
    "startTime": "00:18:04",
    "text": "I think option 1's good enough. If you go with option 2, I just wanted to point out -- 2a or 2b. Option 1, just let people use their own claims. I I understand what your program you're you're making a comment against to someone, whether it's to a or b or are just post. either either. I think you know, the ability of generic processors to syntactically validate things is okay, but it's like knowing something's a jot doesn't tell you the validation rules for it. for what claims have to be present and whatnot. I was just gonna say that if we go with the thing that uses type values. So our token change spec already defines a bunch of type values that I could reuse. Yeah. your own. So regardless of this solution, we we pick at the end. I think it's appointed to say that we are conflating the name and the type. Well, the name is what the application thinks This is versus the And you might have 4 tokens that look very similar and have very different semantics for the application versus the the type, which Maybe standardized, maybe by the Italian government, whatever. And he notes what a standard that a standard library can do with this token. So we can still only have one field and call it type, but it's really 2 different things. I'll elaborate that on Owen. plastic."
  },
  {
    "startTime": "00:20:02",
    "text": "Again, one is what it looks like from the applications point of view. what role it hold for the application. this is Like, my 3rd sibling as a person, Right. And the type is what So there may be different libraries or different ways to to handle when well known tokens, and that would be a type. Right. And so that is more like 2a, right, where it's a generic more of a generic type of, like, it's this kind of token But the specifics are POTENTIALLY OTHER Yeah. You're you're still using the word type to to bundle the 2 things together. I'm using -- That's fine. Yep. Yep. The typing is There's slightly different meanings of what the word type means in these different pieces. Yes. And, personally, I I actually prefer the URI option because it gives you cleaner name spacing. So Right. To be -- To be clear, I just didn't making up strings to put into things. as opposed to, like, the two aide could still be a URI. but that It's kinda saying it's an ID token. It doesn't necessarily provide any context around why is this ID token in there? Or what does it mean? Or Yeah. But the the benefit of having a URI is that you're commit you you're preventing name collisions. It's very specific of exactly what 5, 000, 000, at, but Okay. So you're And then if you go to 1,"
  },
  {
    "startTime": "00:22:02",
    "text": "WHICH WORKS THE SAME WAY, BUT NOW YOU DON'T HAVE A Rapper. it's like, okay. You've I mean, you've removed a layer of just -- Yeah. -- removed -- I don't have a preference. Okay. direction that maybe we don't need that layer. Maybe. Who's up next? Lipari or, like, Oren, let let's go ahead. or steel. sorry if this is gonna make things more complicated for a second. But is the Distributed and aggregated claims, concepts, Are they related to this, because they have a bucket structure What's the what the show can you show the container 1 So it's it's not this. Actually, the the one with a delegate mother It's like, is it Are they del distributed and aggregated claims an open ID connect Or aren't they sort of, like, a version of this, not I'm just confused why that wasn't is or Yeah. So so we did look into that, actually. And the goal of that is completely different from what we're suggesting here. Right. Lately. That that, again, was a very kinda claim that had specific meaning. which is really option 1. Right? And so the question is, should we have a generic way of putting tokens inside of tokens. Right? Where the open ID, 1 was oh, these are claims inside of an ID token, right, very much more specific. Right? Okay. Any But he else Yeah. I I think Mike had a good argument for why option 1 is good, but still kind of spec it out. Right? it have a have a draft that actually says how you do this. And it might be already in the know, you know,"
  },
  {
    "startTime": "00:24:03",
    "text": "in the base spec that that's how this is a normal extension. Right? it could actually help people to understand. because you you obviously asked the question why isn't this already in that ring. and others will too. So it might actually help to answer that question in the form of address. Okay. Yeah. That's Right. I suppose to just not do anything. Yeah. Yeah. Uh-huh. Describe And, essentially, it's kind of a best practice because it's not really normative, but it's a spec around suggestion. Here's here's some guidance around how to do it. it's a great idea because that could That kind of text around what the tool brought up around, like, okay, be careful. Like, somebody might get this and do things with it that we can have text around that. Okay. Yeah. But but you still have a normative text around how to interact with the AS to get that information to embed and and get the the embedded one. Right? So that's still in the document. Right? We could define some specific I mean, we could define some specific high level claims too. Absolutely. That that's what I'm saying. Yeah. -- guidance for other people about how to do something like that. Yeah. Okay. Okay. Okay. Brian. Ryan? isn't option 1 sort of just clarifying sort of, like, what passport or STIRR have already done. Is that more or less, like, Like, they didn't name space. define around that. it with the URI, but they're basically saying, hey. In our context, this claim carries one of their embedded token is. So it's already kind of happening. Yeah. Once again, the fact that it's a URI namespace is just, you know, somebody could define food or Yeah. Well and what I'm saying is they they have. Yeah. -- misunderstanding. Yeah. And so they've they've taken approach 1. so I think they're for saying that document could wouldn't be best practices so much as just Right. Well, what that seems heavy, but"
  },
  {
    "startTime": "00:26:03",
    "text": "Yeah. Yeah. Describe how you might go about doing that in your own application. Yeah. Well, I don't know. if he had said without going to the mic, because there's a number of concrete use cases now that we were looking to specify. And so we could specify those using option 1. Mhmm. Right? And so now you got some specific examples. and then you could have some general commentary about you know, what you should do if you're gonna define a new one you're some best practices. Sorry. But you were actually talking about some kind of wire protocol to request and receive -- Right. -- these. Right? Yeah. Yeah. Which is a whole whole separate issue. Yeah. But it's part of -- But but that would be part if if Yes. No. It's really it's really It's a Linux. It's related. Yes. Related. But it's -- Yep. yes. Yes. Yes. Yep. At this stage, it's in the same document. Right? It's in the same document. And sorry. We're, all over the place, but it's it's also it has a bunch of, like, non like like, it's extending the token requests, but it's doing it in, like, nonstandard ways. kind of, like, broken. Okay. We we can -- Which is but Can't look into that. Yeah. We should probably I don't wanna get into that necessarily if it seems like the scope of what you're talking about here is just token formatting, structure, not necessarily the it's a broader pick it's a broader because once you have the format, then potentially, you might need to describe how did that get in there. Potentially. Right. And so some of the things on the table do require, how did that get into there, and so they require some other protocol, so the question is, like, what should those just be their own little dock, BECAUSE THEY'RE FOCUS ON Just THAT. as well. Right? that it's like, Here's yeah. So are are you saying that these should be completely different documents. I'm not sort of I I don't know. I'm I'm looking at examples like, sir. Like, they don't they just put a claim in there, and they have their own k. Way of"
  },
  {
    "startTime": "00:28:03",
    "text": "interacting that that has absolutely nothing to do with an authorization server or not. So -- k. Maybe. Okay. What -- What's on some might. Right? Yeah. Sure. But but are you saying it should be a separate document? I I guess what I'm saying is a little more meta than that. It it doesn't feel probably, but I'm not sure if those documents even need to exist or they are already separate documents that are solving But it's it's, like, of course, like, absent the document providing any guidance and the mechanism, of course, they had to come something themselves. It's like previously, like, before we had the standardized JWT. Of course, people would you you're doing something on their own But then we make recommendations. Okay. My point's a little lost, but I'll stop. No. It's a good point because you you brought up an important point, which there's more to what we were looking to spec with slides just how to what it the syntax of an embedded token some of the embedded tokens, you're also specifying how did it go about getting in there, which is what STIR did. And that then starts to become a little more confusing around sort of general language about how should you embed tokens? Yeah. I guess so. I feel like that token structure and format, how they're actually embedded should be distinct from any kind of protocol interaction to request and received these. I guess, potentially. Right? But the guy that the person that's implementing it, now they have to read 2 things to do something Yeah. Sure. Or the person that's implementing embedded tokens that already has their application specific way of obtaining those tokens doesn't want to read an OAuthwire protocol that has absolutely nothing to do point they're trying to accomplish. k. Yeah. -- see the are are you on both sides? But it feels like overloading and mixing concerns."
  },
  {
    "startTime": "00:30:03",
    "text": "around a question that's not even answered yet. There's 2 different things. sorry. You could either consider them from a From a document point of view having documents is sort of cleaner. then there's a plus where anybody implemented need to do both anyway, and so having one document sorta talking about. Here's if you have this kind of problem, here's the protocol part, and here's how you embedded token is all in one doc for you to read to understand how to do Yeah. I I understand that. Yeah. Yeah. I yeah. I I don't know what the right answer is. Okay. Fair enough. Yeah. But Brought up a useful point, which is like there's this other chunk of stuff that was in that is in the current drought. which is protocol related, Mhmm. and not do you just embed a token? Or cool? Yes. Yeah. Correct. Yeah. Yeah. Yeah. And and if there's something to be fixed there, we'll we'll we'll fix it. Right? Peter. Peter Castleman, So think given that there's valid use cases, whether this is a BCP or a a standard document. I think having clear guidance for for people who need to solve for those use cases is super useful. Because if not, they will solve it on their own. and they will it won't take long for people to do things that is dangerous, inappropriate, you know, access tokens getting embedded in other systems, that kind of thing. They're probably doing something bad. There's probably some people doing something bad now because there wasn't any guidance on it. And and Yeah. And so I think having that -- George is nodding his head like he's seen Or -- I think we we we we've all we we've all been there. Right? So I think to be supportive of having that guidance, that document, whether it's 1 or 2 documents, right, that You can decide how you wanna break that, I think. But I'm I'd be supportive of having guidance Okay. at while you're up there, Do you have a a view REN 1 versus to AB."
  },
  {
    "startTime": "00:32:01",
    "text": "I I I don't have a strong preference either way. I think the thing that whatever gives people I would almost say the more you can constrain it for people, the better. the more flexibility you're gonna give folks, the more guidance you're gonna have to give later. So think about what the minimum set of processing rules is that you want to Now what's the set of good things you want people to do? and maybe use that as a as a way to decide. Okay. Thank you. David, I'm speaking about the the 2 a b. I wanted to follow-up on the name and type think think think you show one type But, obviously, if I have 2 tokens of the same type, I need some way of differentiating I need a name in addition to the type. So That was yeah. Right. That was the other the other argument on 2a or either one of them. You have a type there, very specific type, but I've got 2 of these things. No. It's an array. In the array. It no. It's an array. But how do I know which one is there obviously needs to be a name or something usage Agree. How because I got 2 of the same type. So Clearly, you need an an identifier here that's -- Maybe. -- which one. It's penzarns, not gonna be the first or the second, that would be bad. Well, as an example, right, The embedded tokens I'm just making shit up so I don't know if that would ever happen. Right? but what could be embedded would be search from or token from, say, 2 different countries saying that you're a citizen of those 2 countries. Right? So they're both equivalent. Right? Right? Right? That's true. might -- Well, their their name in that case could be the same. I'm just saying there needs to be a usage identifier not just to type. So citizenship would be the name. The type is a type describes the structure. Right? And so I'd be fine with 2 things called citizenship. but there still needs to be something in addition to type but that's not actually why I came to the mic."
  },
  {
    "startTime": "00:34:02",
    "text": "So -- Right. Well, because if you go back -- Potentially, you could have a type that's a This is a citizenship. token. Right? Yeah. It should be. Because it's different from the type type is more structural in terms on how you think that's -- I know. I know. I know. I know. Yeah. Right. Like, So going back now, since we're -- Oh, that's hard. Right? Go back to 1. Go back to your your number one option. This is effectively This this the thing in red is the name because you have 2 of them. Obviously, you're gonna have 2 different left hand sides. So it it tells you why it's here, what its purpose is. and type is none of your damn business. There's no indication of typing. Go look at the job itself to figure out what type it is. So I'm kind of in supportive of this. However, I have a meta question. Why are we focusing on embedding tokens and guidance for tokens. When this is already in the base back, this is nothing but a custom claim custom data. So why are we caring about tokens? Because I have people that want to embed ICS' in here to say when this what periods and repeated this access token. So let's talk about embedding ICS. It's a thing. why why are we concerned about embedding tokens As opposed to any other thing that you don't understand that I'm investing. This is why we're having this Right? Yes. So is it is it because there's dangerous stuff that can be done with bad practice with tokens, and we have to care about tokens, and we don't care about little ICS I'm throwing in there. That's the question I'm asking. Okay. Right? Like -- Okay. Is there a value of having a container for full the container, the 2 a and 2 b, are basically giving us semantic tagged to this custom plate. Right. is saying this custom claim that you have here don't know what it is. But if you wrap it in something called tokens, then I know it's a set of tokens. Right. And is that valuable? Is that valuable? I don't know. That's the question. Yeah. I I don't know that it really is. I don't know. I I don't know. Right? Right. The the the the earlier drafts did it, and I sat by and it's, like, can we really need to wrap it as their value? And that's why"
  },
  {
    "startTime": "00:36:04",
    "text": "to emphasize all that. If I don't understand these tokens anyway, then it's just a semantic tag that says, the way, this thing's a token. a wrapper. That's all it does to me. Yep. Yep. Yep. it's okay. Yeah. Yep. And that's a good argument for 1. I think my for one. Yes. Yep. But my point was that since point was -- -- a good argument for -- For for both you and and Giuseppe is here, and both of you have read the base spec. Right? Obviously, you needed to help. You needed help answering this. Crest Gen. Right? which means that others will probably do. And that's an argument for for actually writing down guidance on how to Oh, I'm I'm I'm fully aligned with writing guidance is a great idea. Yeah. I've only gotten feedback that writing guidance is a good idea a number of people. Does anybody think writing guidance is a bad idea and we shouldn't do anything Anybody Anybody? Okay. Okay. Brian, you had a comment. Let let's let's and finish with this. Yes. Yes. I've and we haven't heard anything contrary. I don't think it's a bad idea, but if it's bad guidance, We shouldn't get in trouble. Well, I mean so we need to be a little careful what we do. Yeah. but that's the whole reason for the discussion there, Brian. Right? So just -- So, Ryan, I'm gonna interpret that as a review volunteer? Thank you. Yeah. Yeah. Thank you. Next? I have received it. I think the protocol stuff should be pulled and or fax, But black 2 I think option 1 would be the preferred here. Just maybe another meta point. But as type is type is terribly, terribly overloaded. Hard to understand. It's clear that We have no common understanding of it here. Mike Recommended the ERIs from token exchange, which are hard to understand and get confused I wrote some of them. I don't understand them. We have typing of tokens and media types. that are used in type headers or jots that frankly a lot of people don't understand myself included, they get overloaded against that. Like, it's it's really bad."
  },
  {
    "startTime": "00:38:04",
    "text": "it's really hard to do. So assigning type another set of semana's and expecting common processing from it. Okay. it's it's like it's it's not gonna work out very well. So something more like one, I think, where all that stuff is defined by the context of use. Whoever's doing this defines claim and says what it is. What all things are -- Yeah. -- is an array as frame. Well, however the yeah. And all the things you need to know to use it are find there, I think, is is much more pragmatic realistic and usable. And the idea of defining a generic container that's typed and library support for it. We're there's a layer where that sounds really great, but I I don't think it would work out well at all in practice. Okay. That'd be my my vote for 1 with a lot of fast talking words. Okay. Awesome. Thank you. Great feedback, guys. I would say this has been great feedback. Yeah. So wrap it off. Take take yeah. Taking taking the feedback, it seems like there's strong preference for just going that there should be a document And we should take approach 1 on the document as opposed to to a or b I forget which one is in the document now. So next slide, if yet maybe put this slide in. So type thing what the changes were, but we're gonna, like, radically, change it, And so I don't think we're ready for adoption. Let let's talk about this a bit more. us that this problem should be solved. We should have a document. Yeah. And I think that takeaway for the authors is to rework it for approach 1. anyone have concerns with that? And look into the the Yeah. And the protocol -- -- change the protocol thing. Yeah. Whether whether the protocols and protocol -- Yeah. -- like things are in there or whether this is just focused on How do you embed tokens? but but but but we'll we'll We've gotten some great feedback here around what go forward. So Thank you."
  },
  {
    "startTime": "00:40:03",
    "text": "Thank you everybody. Yeah. Great discussion. Yeah. was a good thing to have in person. It's supposed to email list. Yeah. Thanks, Dick. Appreciate it. k. Awesome. George. Do you do you wanna control or do you wanna drive me I you can try it. Okay. Alright. So transaction tokens, thanks to Atul for doing pretty much all the work. So transaction tokens are something that I started thinking about a while ago and you go to the next slide. And largely, it it's around the contact There's probably 2 drivers for it. One of them is that Generally, the authorization domain that you have between your external client and your internal implementation, your internal back end, is different from the opposition with domain within the back end. So so if you are trying to, like, take an OAuth token that you gave to mobile app, and use it as your authorization mechanism inside. You run it in into a whole bunch of products. So this was a way of how can you basically create a transition for something internal that can cover the the the the the the life of that transaction In the vast majority of cases, these transactions are relatively short lived. And you'll see some other sort of benefits here, but set the stage microservices, from a back end perspective are not asset. Right? And so trying to deal with rollbacks gets really complicated. So if you take a in in authorize it like an OAuth token from the client and every micro service is going back to the IDP, especially if that token is paid paid because you didn't want the client to know anything about it, and you're going back to the IDP, the the chain could break in the middle."
  },
  {
    "startTime": "00:42:00",
    "text": "And it's unlikely that you actually want that transaction to fail once you've started it. There probably are a few really small edge cases like you know, person is purchasing a $100,000,000, you know, ad campaign or something of that nature. maybe you do wanna check along the way before you do the final sort of, like, transfer. But vast majority of our cases, if you start the transaction, you want Complete. Next slide. So the other sort of key element here is it in the vast majority of implementation And once you see it inside your internal network, the trust model is server to server. machine to machine trust, and anything about the transaction just gets added as parameter. And so the attack surface of a compromise of your internal service is much greater then if you combine the context of the transaction, into the token that's happening internal to your network. So that's kind of the the, you know, an attack surface. Benefit you know, do you reduce the attack surface with a transaction token? Next slide. So So, basically, this is sort of a covering that's you know, some more detail on that exact concept here, we you know, can limit that basically, we can get transaction to complete, we can limit the attack surface as long as we can sort of maintain the the immutable aspects of the transaction itself. or the context of the transaction as it passes through downstream systems. And then the final thing here is that At least when I started working on this, the environment we were in was incredibly high load. And so know, the latency impact of going back to the to some service to validate the token is"
  },
  {
    "startTime": "00:44:00",
    "text": "not viable. So there's benefit in basically separating the kind of a token you use internally from the kind of a token that you use externally because then if tokens are compromised, you can't use them in the other domain. Right? You can use them. If you compromise an OP token, assuming it's not center constrained, you you can use that at the external side, but you couldn't use that internally or vice versa. You AFTER SOMETHING ETERNALLY right, and use it at the external endpoint. So so you sort of produce the service there, and then you get that benefit of once you've started the transaction, every service in the in the chain can process it. locally. And Depending on how you structure the data in the token, you can actually do some level of coarse grain to find a grain. authorization in the application that's receiving the transaction. So what are they Oh, this is the newer one, but it doesn't matter. So we changed that from being an into a short lived, signed JWT, the key point is that know, if it's a new choking tape, it's probably it could be a jot. slightly signed, but not only change we made. technically an OAuth token. That was the Do you wanna as well oh, okay. Okay. That's fine. That's the only change in me. Okay. So the But that just calling that out here for that. Context. If you're you know, So just to give some explicit examples If you're receiving inbound mail, Right? you kind of want to bind the email address to which the inbound mail is sent. into some sort of into this transaction token so that all aspects of the of the internal system can effectively that pulls it for the mic and and yeah. Okay. all aspects of services that are processing that"
  },
  {
    "startTime": "00:46:01",
    "text": "that request for the inbound mail can only do so in the context of the email address to which it was assigned Right? So if you make that immutable into the transaction token, then the downstream services can't replace it. And if someone were to compromise some service in the middle, they can't basically know, just add a different email address into the request and basically shove it in a different direction. An an attacker in the middle would have to sort of sit there and wait for the appropriate transaction token to come along that has the email address they care about before they potentially do something. different different different different different with it So we have the next slide is a little bit about what what one could look like, you know, it's looks a bit like a job other than the subject identifier This is out of the the shared signals for the subject ID isn't that the structure, it's I could pull it. my class. Here's the mic. So the subject identifiers are no longer in the shared signals draft. they're now an IETF almost an RFC. Like, it's it's -- Okay. Undown. -- published as well. Okay. The sek token Yeah. Yeah. Yeah. Yeah. So so that that sort of changed there. And then There's sort of this authorization context I think it's important to note that the authorization context know, should you know, can contain context about the transaction itself. So if you wanted to sick things in there like a device identifier or some other thing about the client that made the external request. You could do so. You can also have authorization specific data know, whether we need to structure it as flat or whether we need separate our authorization details separately. I think there's a bunch of interesting questions there. It's possible that some of that authorization details walls,"
  },
  {
    "startTime": "00:48:00",
    "text": "is needed at a leaf at a leaf node or or, you know, leaf microservice, and other services shouldn't see it. So then does it need to be There's a whole bunch of open questions here. This is sort of, like, just trying to get. some ideas down on paper to get a a conversation started. but this is you know, this kind of a thing could then just be passed from one service to the next service It doesn't alleviate the need for that you're basically your machine to machine trust whether that's MTLS or or some other sort of mechanism you're using. You know, it's 50. There's Athens.i0. You know? But this then becomes a a key element that you wouldn't be able to invoke the next downstream service without one of these. and that way you can chain the piece. A side benefit, maybe maybe all of your systems, do this super well, but I have seen many a back end where understanding the set of services transaction goes through to in order to complete is kind of undefined So having something like a transaction ID in here that everybody can log because this thing's required to complete the transaction. actually starts to give you some of that flow you know, the the service flow kind of data, which your cyber people will be super excited about. if you don't have it. Alright. Lots of questions, Justin. So I can actually wait till you're done with the slide because I think pretty much covers -- Okay. So So my question is about the the ACC section is that intended to be namespace or or fixed claims or Wild West or what What's the intent with that object? Great question. I I think that there's probably some set of claims that our potentially generic that you"
  },
  {
    "startTime": "00:50:02",
    "text": "could, you know, be fixed and a lot of extensibility Atul and I have been talking and and other peep and Peter, right, about if they're like, should like, transaction contact information, like, let's say, user agent or device fingerprint something of that nature be separated from, let's say, know, transaction details or authorization details when originally looked at this when you would as you'll see in the next couple of slides where you go get 1 -- Mhmm. -- the concept was you could ask you could basically pass in a RAR structure, and it would get embedded into the transaction token We haven't really got quite that far yet in the spec. Alright. Thank you. That sounds. Yeah. Yeah. Tobias. So just to understand this transaction token is the for, like, a boundary service, like, an API gateway would take an external, like, token and then call an internal sort of service to create one of these that then as carried through the internal service call or like, where does this isn't an external token in a sense. Right? This isn't something that I'd like a boundary client would have. Yes. So this would be this is at least initially intended to be you know, internal to one trust domain. Right. So, yes, you could do it at gateway. That's a very sort of normal place to put it, but Like, in my inbound mail case, it's not really the gateway. That's the inbound mail service. Right? It may be the actual mail application itself. Sure. right, that starts it, but but you know, as close to the edge as possible as when you would wanna make the transition. Right. So it's it's it's basically the boundary of the trust domain would get generated and then carry through. as well. This Yes. Okay. That's the concept. Thanks. So I wonder how how close this is to the sec sec set the tokens. You were using the sub ID. from Secavaltz. from. Yeah. Yes. But you're looking at the structure,"
  },
  {
    "startTime": "00:52:00",
    "text": "you could probably look at the set token format and kind of treat that as a and essentially a that's an this is an application of the security took and foremost. Or it could be I mean, yeah, it's fairly close. I mean, do you have a transaction ID or specified in there and you know, you have an acceptable events, right, which has the extensibility for you your your your context. Right? actually that far. Okay. It's not -- Yeah. -- Cool. Cool. Yeah. I think that's a great suggestion, and we should have thought about this because I'm using sets in other specs that I'm working on. So Yeah. Yeah. It it does look like a set. So I don't think there's any additional work there. It's yeah, what we call it. Yeah. No. That that's great. Alright. Let's go to the next This is just sort of a a little bit of a comparison and, you know, to leap in a tool point, if we move to sec tokens, it might change again. the the key probably point here really is that this kind of a token is sort of short lived, and there is no sort of associated access token or refresh token or any of those kinds of things ATACHED TO IT. IT'S you know, meant to be something the purpose of the transaction Yeah. Hi, Descartes. maybe I wasn't really paying enough attention to what you're talking about, but My understanding is these tokens are more of like a access authorization statement. token and an event. that you're talking about. Right. And so that would that is was not the intent of succubank, which is Here's a piece of knowledge you can do something with it or not. around something that happened Right? It's it's intended to be I did something letting you know that. And so I think moving it into suck events would be"
  },
  {
    "startTime": "00:54:01",
    "text": "distorting what Secabents was credit. So but there may be good pieces of the way the the you know, the JWT is structured for a second event that -- Sure. -- that is applicable in this space. Right? So -- No no no agreement on that. But to call it a security event, I think, would be a abuse of what security events were. because it's not a security event. Got it. From what I understand, unless I'm missing -- No. I yeah. It's not. Not technically a security event in the context that segments are defunding. security events. Okay. Yes. Yes. There are 2 clarification question, Christina. you looking to standardize only the format of a token or also how obtaining this transaction token based on extraordinarily incoming thing. Is it the first question? Yes. There is there is a protocol element here which is, like, on the next slide. Oh, okay. Okay. is Okay. Yeah. coming? a second question was, And I'm sure if you explained, but what Well, I was a motivation to have an object for the subject identifier. because in different context, I've heard a lot of questions, like, why Jot's subject claims a string and not an object? can we have multiple subjects? and it's surprising that it hasn't been defined, but it hasn't been. So either of it, maybe it is beneficial to leverage draft to to find it, but like, why now and what's in medication? So So I think this was just I mean, the a the the subject value itself is a little bit cleaner in this kind. Like, if in one context, it could be an email address and another it could be a UUID. In another context, it could be, you know, some external reference or or whatever. that in that context, right, having having a format and a"
  },
  {
    "startTime": "00:56:02",
    "text": "and a value is slightly cleaner than just basically, overloading the string that is sub. Yeah. Whether there are use cases where the inbound request has multiple principles, is an interesting question. I haven't run into any of those personally. That doesn't mean they don't this. So I think that's know, a a potential feedback, but in the majority of cases is where you're even in a machine to machine kind of scenario, you potentially don't really you know, the the the identifier of the entity making the request which is sort of what this is intended to represent is still singular. Right. Things that that helps. I think If we go the path of defining subject, as an object, I could see Bing not misused, but already, you know, reused in other context. So probably be aware of that. Okay. Thank you. Yeah. Just wanted to answer or, you know, comment on question. that that Although, I think we're not saying that this work should we move to the 2nd events group or anything like that? It's just we are leveraging the set we could be leveraging the set spec Although the intent of that spec didn't cover things like this, which is not event driven. but I don't see any reason why we should not be doing we should not be referring to the SET spec as sort of you know, these transaction tokens could become sets, essentially. As a format? Yeah. As a format. Okay. Alright. Just to get to Christine, is there anybody else in the queue? I can't see. 9. Okay. Brian? Just one follow-up."
  },
  {
    "startTime": "00:58:04",
    "text": "second what Dick said. I think even referencing or trying to use a second event as a format is terribly confusing and overloaded things that are already confusing. Yeah. So the I okay. I would suggest not doing that. The the subway Christina, I think, maybe I'm wrong here, the sub ID is defined in soon to be RFC as an object. So that's NOT BEING TO FINE HERE. IT'S ABOUT TO BE OUT THERE SUMMER. AND THIS IS Just USING IT. conceptually speaking, isn't that It's out of. Yeah. It's in our side. It's in the queue. Okay. But it it really came about to provide sort of context of what kind of subject this is to right. and this is the value of it. And in order to facilitate sort of understanding more of the context of the subject across domains. So it almost feels to me, like, a regular old sub or APPLICATION SPECIFIC WAY OF IDENTIFYING THE PRINCIPLE IS MORE APPROPRIATE IN THIS INTERNAL tax, then than using the second vent stuff. And I I feel like similarity to second events WAS NOTIC BECAUSE OF THAT, RATHER THAN ACTUAL SIMILARITY, THE SECOVENCE IN TERMS OF the context of use. Yep. Yep. No. No. That very valid points. I think I I do think it's possible. The the one thing I do like about it is It is like like I said, it's possible that the that entity that's starting the request, does not necessarily have access to what would your canonical internal identifier for a user, And so being able to basically say, hey. This is an email address. and here is and the and then the string is an email address. can be useful for downstream systems that then need to go, oh, I need to, at this point, I need to go look it up. That's fair. It can be useful. But all this stuff is kinda application specific about who has access to what and how our subjects represented and It's a nasty world to try to defined structure on that."
  },
  {
    "startTime": "01:00:03",
    "text": "Potentially, but I think that by giving the the aspect sort of you know, a format and a string. There's at least a little more very a little more extensibility for an application to define it well within their system and their use cases than just a pure strain. But -- Yeah. -- it's it's valid it's valid feedback. That's a fair point. Yeah. I I Tobias, I I just wanna make an observation. There's been some some interesting engineering blogs in the past that talk to one of the values of these sorts of models. It's not just about the fact that the the external token of the client is kind of inappropriate for sorts of reasons as you highlighted. But one of the other main benefits that I think is probably important to highlight in this work is rationalizing when you have an API service that might be using several different authorization games. Right? You might be using cookies, you might be using API keys, access tokens, everything at the boundary. and this is actually a way to rationalize what could be a really complicated external authorization model into a consistent transaction. so I just think is like a value proposition for this model. That's a really important thing to sort of call out is What is one? is, you know, could be could be many different models. Yeah. No. It's a really great point. You you simplified the internal the the the life of the internal developer because they only have to worry about one thing. and you can abstract the complexity of a bazillion other stuff on the out at the edge. Absolutely. Absolutely. Absolutely. Absolutely. Absolutely. So I think Yeah. We're at time. So -- Doing a -- Let me Let me just say this was the piece to Christina's point about about sort of protocols, right, the ability of the API gateway to go some server It's it's basically a profile of the token exchange to basically say, here's the data. I want issue me a transaction token. Right? So the the downstream services know that, hey. They're their trusted authorization server to Justin's point on one of our last calls."
  },
  {
    "startTime": "01:02:02",
    "text": "you know, it it function as an op as, like, an authorization server with one purpose right, to issue these kinds of tokens, allowing the the internal network, the internal services, to be able to trust the signature of this transaction token as it comes through. It also allows for some level of meta authorization policy to be issued, like, is this particular know, API service allowed to request a transaction token with these constructs in it. Right? And so you can put some authorization metadata there or some authorization some meta authorization see there as well. None of that's in the draft yet. Right. So, you know, Does know, we've got, like, the very first bit of a draft You know? So, obviously, lots of feedback appreciated And the next two I'm not gonna go over this but there's 2 more sort of concepts in here that I think is are more questions Go to the next one, One of them is sort of like, should you be able to nest these transaction tokens in some way And is that a self sign by some microservice, or do you have to go back to the token service to get it embedded or not, I think this is a know, is this valuable? Is this not valuable? This is, I think, an important question. and then the to to the work that Justin's been doing about Wednesday and chaining. And, you know, if if you want to have sort of, like, assigned mechanism a a proof of chain Right? And you're trying to do that in this kind of an environment, then these things could get really big. So at some point, should you be able to, you know, sort of, like, collapse them. Or in if you saw Justin's environment when you're starting to cross domain, boundaries. Right? Should you be able to collapse what had been an internal one it some other representation that then goes to the next know, the next trust domain boundary and"
  },
  {
    "startTime": "01:04:00",
    "text": "Peter, I think, is gonna talk about, you know, sort of crossing trust domain boundaries next. So there's probably overlap in how these things interact with each other, but this was sort of I won, you know, we we wanted to get sort of like an initial draft and this concept, you know, more structurally presented than we have in the past. and then, you know, get feedback as, you know, do we take this forward? Is this, you know, worth, like, standardization? Is it another best practice document where do we go from here? So thanks. Yeah. Thanks. Justin, you are now Good. Yeah. I'll be quick. Justin Richard. So I'm very much in favor of us doing something something with transaction tokens. I do want to encourage the working group to not conflate sort of the utility of like, sort of a nice internal token like this with sort of a larger structure of carrying a bunch of these through the system, especially the chaining and all of that other stuff. the more use cases that I've been looking into recently, I'm more and more convinced that that a token is actually not necessarily the right structure for this. you know, the I I think that in this working group, we have a tendency to think with the tools that we have. And I think that that we need to be careful to not overfit the stuff that we're doing to this. The transaction tokens, I think, is great. People have been doing this stuff for years. Let's -- Mhmm. -- let's figure out something something to do this with this. And this, I think, then becomes a piece of a larger puzzle to solve these these other systems like the cross domain stuff that Peter's gonna talk about. stuff that we're gonna be discussing in Lindsay and -- Yeah. -- and all that other stuff. so so so Awesome. Just context. Thank you. Thank you, guys. Awesome. Okay. Peter."
  },
  {
    "startTime": "01:06:01",
    "text": "wanna drive? Or Let me see. K. Do I have control? Yeah. I I do. think so. k. Thanks, everybody, for being here this morning again. always privileged. And I'm gonna talk a little bit about identity training across cross domains. So this is a A couple of folks that have been Oh, Thank you. There's a couple of folks of us that have been sort of thinking about this in parallel with the transaction tokens that we just talked about as well. course customary, DALLIE Generated San Francisco picture, because I didn't bring my camera. And I think we're gonna talk a little bit about identity training, why we need it, sort of a proposed approach then we'll talk a little bit about what's in the draft and what we're gonna be or what we should do next. k. First thing. Oh, format error. Okay. So, also, You may recognize some of these pictures of on just Credit Justin for letting me borrow some of his whimsy graphics. So typically, what we were just talking about, the transaction token in this environment allows us to have some sort of information about You know, when we get to the, you know, 2nd, 3rd, 4th service down the line, we get to find you know, we need to still know who was the resource owner, what authorizations that they grant. We also wanna know what other entities were involved."
  },
  {
    "startTime": "01:08:02",
    "text": "and also what other authorizations they might have. And so However, things get a little bit more interesting because these transactions are not always confined to a single trust domain. Trust domain can be between organizations that can be with in organizations. For example, your engineering department and finance department may actually operate separate domains for reasons of compliance and trust. but this can also span across multiple organizations as well. And so the question then becomes, right, So if we have the situation where we have all these multiple services, we still need to be able to answer the same questions when we get into a different domain We still want to know who the original resource owner was, what authorization they granted, what other entities were involved and also what authorization they they have along the way. And so to do that across trust domains, that's kind of what we're looking at. here. Right? And, also, I think in this world, we're sort of assuming there's another author server involved as well. So These are at least there's compatibility at that level. Right? have 2 domains that are using o holes, o holes, o holes, So some some of the concepts And, again, I wanna thank so to several people that sort of contribute to this as well, Brian, I think you and I have spoken about some of this a while back And so essentially, it's sort of a 3 step process as we think about it. Right? So first, the really, if you're in domain 1, you know, the client and domain 1, exchange the token, to get an authorization grant so that they can access the authorization server in trustiment to you. they then use this authorization prompt to get an access token, and then they present their access token to the resource server. Right? So that's a fairly straight"
  },
  {
    "startTime": "01:10:03",
    "text": "for forward process, and it involves 2 existing standards that we already have. So we've got token exchange from the first one. and then reusing the a surgeon framework. So if we go back to our pictures, it sort of looks like this. Right? There's client. Look back and talk more about but that client can be take it can be one of the resource servers. It can be the authorization server. but, essentially, first, it obtains this authorization grant. then they present it to the authorization server in the second domain. And once we obtain that, you can access through. And In the first model, that client can be a resource server. So the resource server becomes a client and acts in this way And then there were cases that people that we talked about specifically, I think, Kelly sort of pointed out that there are scenarios where the trust is only between the authorization server. So the resource server in the main 1. you would not necessarily want them to directly interact with an authorization server implementing And and so in that case, essentially, the authorization server sort of talks to itself, gives itself some self an authorization grant. get the access token from authorization server 2. returns it to the resource server and presents the access token. So that's kind of the the outline. So quickly, just what what's in the draft. Right? So I think we there's a description of profile of these two things. we decided to go with a generic description. And then in the appendix, we had the 2 sort of use cases, 1 resource server acting as client. And the second one where the authorization server access clients. So both of those are described."
  },
  {
    "startTime": "01:12:01",
    "text": "Yeah. A little bit about the token exchange profile piece I think we wanted to sort of continue to have the token type at diagnostic, I think we've got some feedback maybe we wanna restrict that instead. You know, I think that's very open to any comments, feedback on that. And then both the resource and audience parameters there being required. surgeon flow profile, I think, this one, Again, just I don't think there's anything just sort of being specific about the ground type and the insertion and so on. that you have to I think in the original, it sort of says, have to define if you're gonna profile this assertion flow, have to provide some additional details. So we've put that in Another thing that's kind of interesting is this idea of claims transcript So one of the things that happened when you cross the trust domains is that first thing is that the subject identifier may be different in the different domain. And so somebody has to map it, and somebody has to maintain that mapping. And so we we sort of, again, if folks have thoughts on this or guidance or if there are other solutions out there, it'd be good to know about. that's one of the things that we would would sort of outline is, you know, you wanna you know, you need to maintain that that that mapping and when you're doing these when you're crossing these trust domains, you you may wanna include that. and and move that forward. The sort of a form of selective disclosure may be in there as well. So the authorization server may actually want to remove some some claims or, you know, maybe even sort of add some things as well. And then similarly, scoping. Right? So there's really sort of changing identifier, selective disclosure, and then also down controlling scope downscoping. so that you can have least access"
  },
  {
    "startTime": "01:14:01",
    "text": "Okay. Terms off well, I think In terms of sort of next steps, right, there's already a bunch of open issues again, I really wanna thank Brian for giving us a sort of a a bunch of really good feedback already And think some of the open issues. Right? One question is do we want to limit formats specifically to jaw tokens, you know, what should we do about transcribing claims there's some specific Do we need to define that, or or do we what should we do about that? And there's also the case of The Authorization server in domain 1, acting as the client, is a question about whether there should be an additional profile for token exchange between the resource server and Domain 1 and the authorization server into 91. At the moment, we don't think we need that, but it's sort of a it's one of the open issues that we haven't addressed. And then I think sort of a a bunch of other comments, I think, where we were either unclear or used bad formatting or or bad practices that that needs to get cleaned up. So some work left on that, but Also, folks have more comments, very very happy to hear about those. So that's kind of did I skip 1? So, yeah, I think for next steps, I if there's any general feedback on the approach that we're taking, also in terms of interest in this working group, right, pursue this as a problem that is this something that problem that other folks have. Is it useful? to pursue this work? And then also is this something that we should pursue in this working group? I think and and just sort of as an early indicator, on on this. think that's everything that I have. Thanks, Rafa. Okay. Thanks, Peter. name, but he has any thoughts about this. at least at"
  },
  {
    "startTime": "01:16:02",
    "text": "at the level of the problem that we're trying to solve here. So I heard from Justin his seems to be in February doing something like this, addressing that space, but other ideas, other thoughts, Alright. Ori Steele. the there there's a part of the cross trust domain interaction model that you have that looks really, really similar to a lot of the conversations that the skip folks have been having regarding Federated Transparency service interactions. So I'm I don't wanna get into all the details around transparency service Federation. because it's a long topic, but There are a lot of folks that are interested in collaboration around these sort of I'm My transparency service controls my tran my trust domain, your transparency controls yours, but transparent statements for mine are an input to yours because software supply chains are know, tightly integrated systems where often often many organizations need to control their boundary, but they also have dependencies across organizational boundaries, and there's traceability and security issues also follow as that happens. So maybe a longer conversation at some point with the skid folks might be helpful. Okay. Thanks, Ori. That I I didn't think about that as an application. Thank you. Anybody else? Brian. For better or worse, I'm partly responsible for the assertion series of grant drafts as well as token exchange. And I've this kind of thing is a recurring problem recurring apps. We've seen it a lot for many, many, many years. I have always envisioned the assertion graphs as the cross domain mechanism"
  },
  {
    "startTime": "01:18:04",
    "text": "and the token exchange as being more of the local exchange to facilitate getting the right thing to go cross domain. It's always been kinda things that are problematic or unnatural or just don't quite work in the context of token exchange. So I think there is probably value in writing down something like this to try to clarify how how it was more or less intended to be used. some of the pieces that you're building on have their problems and aren't perfect. And apologies for that. But this this kinda clarity and clarification, I I think is is worthwhile. is Brian. Alright. k. Anybody thinks it bad idea should not be working on this? Okay. Okay. You got Okay. good feedback. I think let's build on this, Ryan. Yeah. Brilliant. Thanks, everyone. And, yep, feel free to reach out if you have more comments or take it up on the list as well. Awesome. Thanks, Peter. Okay. Aaron. the short one. Okay. Here we go. Hi. Aaron Brecky from Okta. I have the -- You you have. -- slight. idea if I have to reload it again. Let's try again. Let me try it again. Did you reload? just reloaded."
  },
  {
    "startTime": "01:20:01",
    "text": "There we go. Thank you. Okay. So this is an update on the conversation we had last time at itf116. where we were discussing state of OAuth in native apps. particularly mobile apps. So quick recap of what we see in mobile apps is the kind of prompt for logging in with whatever provider. And if you do things properly, following the current RFC for recommendations for mobile apps. the phone will use the appropriate API to do this sort of in app isolated browser where you're not leaving the app you're not, like, switching out of the app. Like, it used to be a long time ago. but you still get this first prompt of from the from the operating system. showing you the domain that you're about to go login at which point? the little browser pops up. where you can see the address bar and the lock icon, which is an intentional design decision. and this is where you log in. And this this website, this web page is not visible to the app. the native code in the app, The website is isolated from the app so the app cannot look at the password field. and the that means it can actually share system cookies if you are already logged in. in the browser on the phone. It can share the cookies and you're already logged in here. So overall, there's been a lot of has been a lot of, you know, years in the making of making this experience as good as possible. while also protecting from from protecting the making some of the app cannot actually observe anything going on in the login page. And this is obviously very desirable for the case of a third party app using a different identity provider to log in. some some we can even go so far as to do, you know, multifactor off and using web auth in and and origin bound credentials and stuff. So It's great. It's great."
  },
  {
    "startTime": "01:22:02",
    "text": "And then eventually, you'll get back here, and this is where the app is exchanging the authorization code for the access token is usually spinner or a little moment where you're waiting for the login process to finish. This is good for 3rd party applications. It's that, you know, you get the good isolation, the app can't see anything that's going on inside of the with the authorization server. You can take advantage of an existing session you might have. and it supports strong, multi factor, multi factor, However, In the case of people building 1st party applications. this is a not desirable and people want a better user experience. And People are currently finding very clever ways to avoid doing what we have always recommended, which is opening that browser in apps. They are doing their own DIY authentication schemes and just not using a LOFT at all. They are using the password grant from OAuth. They are I'm OS servers that want to actually facilitate this will have created proprietary APIs to support direct authentication from the mobile apps. And my favorite one is this last one. where the app developer will open that authorization server page in a hidden web view put a password field in the app, and then try to inject that password into the hidden web view pretending like none of this is even happening. which then, of course, breaks as soon as you try to do multi factor. some. This is kind of the state of things, and it's kind of a mess. and it's I clearly a problem. John, did you have a question about -- I'll wait till Okay. Yeah. Ready. Fair enough. Okay. So All of these things are frankly worse than"
  },
  {
    "startTime": "01:24:00",
    "text": "the worst security outcomes than using o off the way that the native apps best practice says to use OAuth. however people don't want to do. So gonna put a pause in that. Now I want to tell you about the authorization code flow for web applications. Forget mobile now for a second. We're in a browser. writing a server type application, It's like a server server side code that's running. And how does the OF flow work? Well, the client application, which is on the server, starts the flow by redirecting the user's browser to the authorization That's RC6749. It includes a client ID, scope, code challenge, all that stuff. The next thing that that client sees is the user is back at the redirect URL of that application, and there is now an authorization code there. and then I can exchange that authorization code for October. Cool. That's great. Well, what happened in between? in between, is all of the stuff that is, quote, out of scope of OAuth. how does the user log in? How do they authenticate? What kind of multifactor do you? What kind of consent gathering do you do? What kind of registration flows or recovery flows? All that stuff has to happen. and it does happen, but the App doesn't see it. It's all stuff happens between the browser, the user agent, and the authorization server. what this means is when someone wants to implement OAuth as in as in an authorization server. have to read the the Authorization code flow spec, and they say, Here's how a client will start the flow. And here's how I issue an authorization code, and then they have to figure out what to do in the middle. and they have to write a bunch of code that ends up being proprietary, intentionally, that deals with actually authenticating the user and doing all that all those other steps that are not defined in that was obviously the design goal with OAuth was to separate those 2 concerns. which great works great in the web world. So"
  },
  {
    "startTime": "01:26:00",
    "text": "If we try to bring this to the world of native apps, can actually do something that's very similar. where we could, define a Framework that looks exactly like an authorization code flow except not in a web browser. where it starts to flow, And then undefined things happen, between the authorization server and the app that are the business of that authorization server. and the flow ends by the authorization code being issued. So this is what we have done in this new draft. that we've put together. So -- So So just a question. If you go back -- Yep. So when you say this, are you talking about the blue side or the the blue arrows, the stuff that is -- Yeah. parallel to the authorization code flow for Webex. Right. is the new draft that we've put together Got it. Yeah. That And that's the part that's in scope of that draft. k. So This the goals here are reuse as much of the OAuth building blocks as possible as in try to make sure we can leverage all of the existing stuff in OAuth where it makes sense. mirror the web web based authorization code flow defining how the client starts and ends the flow. but leave the specifics of how the user authenticates up to the business of the authorization server so that it is continues to be the proprietary authorization server specific flow like it is right now in the web server example. In the future, we could define an extension that says, says Here's how you do passkey authentication for mobile in the context of this authorization code flow for mobile apps. think that will be a a great extension to do. We could also do that. For web apps, apps, No reason. We couldn't. Right? Maybe there is benefit to do doing it in the web world as well. I do think that benefits are a little bit more concrete in the mobile case, but It's it's"
  },
  {
    "startTime": "01:28:02",
    "text": "we we we have the same gap in websites in the web right now. So Has anybody read this draft, by the way? 12 of you helped write it, so I hope you would have read it. Okay. A couple. So the core thing that this draft does is it finds a new endpoint We're calling it the authorization challenge endpoint And this is meant to be the native apps version of the authorization endpoint. in authorization code flow, the authorization endpoint is endpoint that the user agent will be redirected to in order to for the user to then do a bunch of stuff there that's not defined in the So same idea, but now it's a new endpoint because this endpoint accepts post requests from the app. Basically, anything that would have been sent in the query string as a as a get to the authorization endpoint is now sent as a post parameter to the authorization challenge endpoint. including any extensions that are defined anywhere in a loss. So pixie resource indicators, open ID connect stuff, whatever, like, anything that you can extend on the authorization end point, You can also extend it here. So it the client starts to flow by making this post request saying, hey. I'm trying to log in, and then the spec doesn't say what happens next other than you get back an error code saying, something that you can define, and you get a little handle, that which have to rename it for reasons, but there you get a little handle that you can use to keep coming back to the standpoint. Until eventually, you get back an authorization code. And this is another important distinction. Like, this is meant to return an authorization code. so that it mirrors the web authority in Goflow. not a token here. because If you want to slot this into an existing implementation of an authorization server, You already have a way of,"
  },
  {
    "startTime": "01:30:00",
    "text": "creating an authorization code, and then you have a token endpoint, and the token endpoint has all the validation logic for how do I know whether it's okay to issue a token? based on a bunch of stuff which might include extensions to OAuth. like proof of possession, DPOP, and all that kind of stuff is already in the token end point. So we don't wanna duplicate all that stuff in a new endpoint. instead, this endpoint returns the authorization code. which you can then take to the token endpoint just like you would have if you had got it from a reader My my my mic. I know. That part makes a lot of sense, but, like, on the flip side of it when you're describing the initial stuff, the authorization code originally came as a construct to sort of bridge the gap between that browser redirect. and coming back. So it's I I get it. However, that is the world we're in now. Yeah. So Yeah. k. Let me just see. The okay. So, yeah, on the Tokyo Care point, Dick. Yeah. Yeah. Agree it's the world we're in now, but it actually maps into how implementation might have done a separation to concerns. and that the thing that issues the authorization code may not have the same permissions to issue a token, right, that the underlying infrastructure might be completely separate for security reasons. So I I think it's a good approach. the the Yeah. I I agree with that. -- for that additional reason. I agree with that. Like, if you look at the the 2 endpoints and oauth the authorization endpoint and the token endpoint, they do completely different things now. 1 is handling user interaction and authenticating the user, and the other one is a token is outputted or an error is output. So what this means is we're not changing anything about the token endpoint in this spec."
  },
  {
    "startTime": "01:32:02",
    "text": "We're not creating a new place tokens come from. We're not making any changes to the token endpoint. the the app just sends an authorization code that it got a different way. the token endpoint. Okay. Yeah. k. It's odd. Okay. Okay. You wanna wait for John or Oh, I have a couple more. Sure. Go ahead. you finished a couple of slides then all. Okay. Okay. Yeah. Try not to interrupt you. So I I guess we've already said some of this. So why is this a new endpoint? because So we can't use the current authorization endpoint. And the reason for not being able to use the current authorization nine point is that That is specifically meant to be interacted with by a browser, It does not accept post request from the OAuth client. And that means that there's actually a lot of implementation logic that has gone into all the existing OAuth servers, that might even go so far as to block post requests from a client or things like that or, like, ensure it's being interacted with via browser by a user looking for user agent strengths, using doing other kinds of things. That's all, like, Again, this is a proprietary endpoint, endpoint, The only thing that's defined on it is the beginning and the end of it, and a lot of people have done in interesting things to try to make sure that it is used that way. And we have got some initial feedback from people that they are not willing to change that logic to return JSON data. Like, that endpoint always returns HTML because it's meant to go onto a browser people people don't want to modify that. to conditionally change it to then output JSON instead. So that's the reason for doing this as a new endpoint. Okay. So Couple other things that this spec defines. Did you wanna add to that? Yep. Yeah. I'm just adding yet another supporting that the hello implementation, it's not even a server endpoint, the authorization point is actually a spa. Yeah. Right. Okay."
  },
  {
    "startTime": "01:34:00",
    "text": "Good point. Not the first time I've seen that. So excellent. The other thing that this draft does is it defines a new error response at the token endpoint, which is optional, but it's a way to for the token endpoint to indicate that the user needs to go and start to start a new collection, new authorization session again. That's essentially meant to to let the authorization server, on a refresh open request, say, actually, no. I want the user to log in again. So go collect whatever we need again. And the other thing it does is on resource server, it also adds a similar error response. of Sorry. It doesn't add it, but you can add you can years that resource server error response to also indicate that you need to go start a new So, for example, using the step up draft. So that would be the 2 other endpoints that the app is gonna interact with of, you know, using refresh tokens the token endpoint. access tokens at the resource server, and you may want to be able to force the user to start a new session new authorization session again. So you have the option of doing that. with these error responses. Okay. TBD device session is the term that right now you'll see in the spec for that string that is able to the phone's able to use to tie together the whole and forth transaction, which eventually will get an authorization code. It's not a good name. need to change it to something because it's not really meant to be a persistent device identifier, So we should change it something like authorization request. ID or transaction or whatever. It is but the concept of it is the same And then the other thing that we want to be able to add is jumping out point, to be able to have the authorization server say, I know you want to do a native flow, but, actually, we really do need the user in a browser right now. for whatever reason. So how do we enable popping out to the web when needed."
  },
  {
    "startTime": "01:36:01",
    "text": "An example of that would be you are starting with, like, a passkey And the the phone has has collected that challenge and sent it up, and then the server says, Actually, we need, like, a second factor that you don't have the ability to collect natively because it's something special to the AS or it is a whatever it is. So ideally, that wouldn't enable would be able to Bounce out to the web, but keep the context of whatever's happened already. So it's not, like, starting a new OAuth flow from scratch. won't be able to carry the context of whatever's happened in the flow up until now, bounce out to the web. and then it continues on, like, an oauth flow from there. And then the other thing that we've heard a lot of is that people want to do Fido, OAuth grants. People wanna exchange a Fido credential for access to it seems like this is the place to do it. Again, we don't want to define that in the core spec. This is meant to be the the bookends kinda like the web authorization flow, but there is an opportunity for someone to define how that works in particular. to fill in that middle chunk of here's how we take a FIDO credential and turn it into an authorization code using this framework. Hey, John. Would you like to tell us how we can do that? are with I would love to tell you how to do that if I knew the answer. So more people are asking me that question almost on a daily basis. I have a call this afternoon with the financial regulator in Brazil who wants to know exactly that. Let's step back a second to something lovingly called DCP Two Twelve. I understand from our the the app off BCP. I do understand from our dutiful chair that it has come under"
  },
  {
    "startTime": "01:38:02",
    "text": "some -- attack. -- Attack. on. and I guess this is also an indication that some people are dissatisfied with that pattern, though, four people like, say, Okta. where you may have a native 1st party native app like trip it, trip it, trip it, We still that BCP is what enables trip it to go through Google to Okta to authenticate to enable employees to get into that app, which is an important pattern. Yeah. Yeah. We need to if we're going to introduce a new pattern, we need to make sure that We don't break Federation, and we don't break the ability to do Web bath in. So I'm not necessarily opposed to a new pattern as long as we don't unintentionally, you know, as a side effect break things that are important to people. So let me back up a second. and the I I can't get back up on the side side. Where do you or not? Which is fine. And I don't remember where it is. Hold on. Point is, Oh, the one that's talks about breaking out to the web. It's, like, 1 or 2 back. That is an example of one reason you may wanna force people to get out to the web suit. So in an enterprise case, would actually expect this is never used. because, again, the scope of this 1st party Well, except at 1st party apps, do invoke enterprises as in the triptic case. So is Trippet the first party app, in under this on in the in the in what we've describe so a lot of the draft is actually not the mechanics of this. there's A good half of the text on the draft."
  },
  {
    "startTime": "01:40:00",
    "text": "describes the scenarios in which this is appropriate to use. AND That is not supposed to be one of the scenarios where it's appropriate. So -- Right. -- it is because it is the authorization server is not Trippit, tripit, tripit. So so I think We may need to if we're going to introduce this new mechanism, we may need to actually update the BCP so that our advice about what you do with native apps includes this includes updated Apple APIs. I mean, it's not the worst idea. I mean, William Dennis and I wrote that 5 years ago. APIs have changed since then. No. It was not. Sometimes several times. It was almost 10 years ago. was 2020 14? Well, we started 2014. I think finalized in 2017, and then It's a while ago. -- take a long time to thin it. But maybe maybe it is time to update that probably is. And this this may having a new mechanism that could be included may be a reasonable trigger for that. So I I think that it's important for people to understand when this would be appropriate and when it isn't because That's actually like, somebody like Trippet, or or I mean, Apple just freaking shot themselves in the foot. the other day, themselves with their 1st party app on Android. People can no longer people who have updated their security can no longer log in on Android. So so, actually, this the all of what you're saying is actually argument for a strong argument for having the option for forcing the out to the browser again. for all those fallback cases. So the tripping example let me let me give you the tripping example. Trippitt has a a web API, and they have their own authorization server for their own stuff. Stuff. Stuff. And, yeah, then they do enterprise SSO. So if they wanted to launch this, want to use this pattern for their own application, people logging in with the tripit password, then, you know, they just they follow this these steps. if they want to then add an enterprise SSO connection, they would use the bounce out to web option."
  },
  {
    "startTime": "01:42:00",
    "text": "for those customers, for that user once once we get to that point. they're like, oh, I can't do it. I can't go any further natively. on the native app. So I'm gonna now bump out to the the web redirect option and finish it So since you've volunteered to help me update the BCP, I'm willing to help you make sure that this works as well as it can, and Yes. I think we also need to think about where we do the work to have include web auth and information in Jots. There's 2 different cases. One which is as the client authentication, the other is providing evidence of a user authentication as part of another back end interaction. So there's kind of 2 2 proofs that I see people people wanting. So figuring out where and how we do that would be a good thing. I don't know whether it's this spec or another spec. Yep. k. Good. Well, John, you are on the record. So Not the match. we have a volunteer. So Yeah. And I'm I'm gonna drag you guys you and and Aaron for that discussion with the with arranged the call for you. the guy. -- already Okay. George? Yeah. This is just a quick comment back to our discussion about token m using the token endpoint with codes. And for me, Another reason to do that is the breakout to the web that you described. Right? bit so that as an as a mobile app developer Right? I whether I have to bounce out to the web or I don't have to bounce out to the web, the process of getting the tokens is the same. Right? I get an authorization code. I submit it. as opposed to having 2 ways to get to Yep. makes a lot of sense."
  },
  {
    "startTime": "01:44:00",
    "text": "Oh, boy. Oh, Horace, Steel. So the the device device session to be renamed sort of flow. I've seen at least one API that implemented this sort of flow exact well, maybe not exactly, but very close similar sort of thing. They called it they actually had 2 identifiers. They had I struggled to understand why they needed to, but they had a transaction identifier and a workflow identifier that we're sort of together in the API, and you could get you know, bounce down around this loop going, you know, to different places gathering all of these pieces up before you'd finally get to the end where you might be able to exchange something for for a proper token. And I not mentioning the API by name intentionally, but I'm happy to talk to you about it. outside. Yep. That's it. Definitely worth looking at other existing solutions have done some of my things. Tobias and maybe this detail hasn't worked out yet, but when you bounce out when you say bounce out to the web, is that supposed to be to finish the flow, or is that potentially an intermediate step. Right? Because we talk about the code before, I think it was kind of maybe to George's point sounds like it's implied that, like, if you were to bounce out to the web, that would be like, your intent to finish the authorization. Right? And you would get the code back wouldn't be like a a piece in the middle where you do some native app interactions, some web interactions, some native app interactions, and then complete the flow. Right? The intent was if if you're bouncing up the web, it's like the last resort because you can't get an authorization code from the native -- Right. -- flow. Right. Then the output of that would be the authorization code or error like termination can't continue. Right. And and I think you maybe touched on it, but they would probably need to be extensions to the authorization request to maybe carries some of that context through. Because if you're starting like a native at interaction, Yeah. Exactly. So it would be"
  },
  {
    "startTime": "01:46:00",
    "text": "It would be an extension to the authorization code flow to pick up the session that you've got going natively -- and then start an authorization code flow with that. Right. Hi, Justin Richard. haven't read the draft yet, but I have opinions. I bet you do. No. Seriously, though, to to follow on with Tobias' point, I think that there is there's a need to be clear about whether the inverse of of the error flow that you're talking about is also the case. So I try the web first and that dies. And so then I go to native what is the use case you would imagine for that? somebody thought it would be a good idea is the use case. So we need to be clear whether allowed Right. Right. So we need to be we need to be clear whether that's that's an allowed fallback direction or not. I under I understand that this is that we have an intended directionality to it. the only one that makes sense to me too, but I've seen people do weird stuff. Yep. The the other part of this is that I think that with the extensions to the authorization request and stuff like that. I'm really interested to see where something like this would align with par. Because if you're doing intent registration to set all of this stuff up, then that can put you in a in a place where you're not even ever going to the browser if you don't have to. I would imagine that frankly, I would probably recommend you building on top of par for this. for that. But the output of part is a request URI that you take in a browser. to continue. to to to do the flow. Do the flow. Do the flow It is today. And this as specified as best as I can tell is kind of another intent registration endpoint. Almost? This is This is not a par endpoint because the par endpoint returns"
  },
  {
    "startTime": "01:48:00",
    "text": "request. I know. The return is different. Exactly. But it does take all the same parameters at the par end takes? That's that's the point that I was raising. So whether this is something that subsumes par or something that sits alongside it. I don't know what the right answer is. I that's a discussion that we need to have if we hold this in. My my instinct there was to not make an extension to par -- Mhmm. could make an extension to par and make it a new response mode or something that park and switch off of. Right? And then -- Right. -- our endpoint either returns a request to your eye, or this new stuff. Mhmm. That felt messier because it felt like more overloading. And if there are any existing there's existing implementations of par Then Supporting this means building something next to it rather than modifying that. Mhmm. So that was kind of the idea. It was, like, it's a separate thing next to it. It's gonna look very similar to Par the par endpoint. except the return values of So -- Right. And it's also going to give me something that I can carry to an authorization endpoint Yes. which is probably gonna look a lot like a request you're gonna arrive. -- a lot like a request. Right. Exactly. So there's that's Those alignments need to be figured out. I I'm I'm with you that I'm not sure it should be an overloading. architecturally, it seems that it kind of is though. And I but I don't know which is less messy. That's a good question. And what we could do is right up. So one of the in the in the bottom chunk of the spec, there's examples example, user experience section, and this example request section. And one thing we could do is write up take those and then rewrite them as if they as if it had been a par endpoint. Right. And then see, like, okay. Is this something that people can support alongside actual par. Right? Could I extend my par to also send back this other stuff or not. Yep. I think that's the question. Alright. Thanks. Dick. Yeah. Just turn that comment. I I"
  },
  {
    "startTime": "01:50:00",
    "text": "like the idea that it's a separate endpoint than par. because it's returning a different thing. But it sounds like you're thinking that it could take a par request and return back the the everything that we've everything that you sent in the first bit. is the same as par. And then there's the unspecified proprietary stuff back and forth that's not part of the spec. which might be weird to shove into the power endpoint. Yeah. Right. But the beginning of it is the same. And then the output of it, the responses either an authorization code request URI, or the proprietary stuff. So it's yes, it kinda looks like it could you kind of smush them together, yeah, probably, that a good idea or not? I don't know. Okay. I'm You could pass all the pars stuff plus the extensions into the endpoint you're proposing. Yes. Okay. Yeah. Yeah. Yeah. I don't know that that all became clear. I think that's a good idea. That's what I would say. Mike, thanks to the the like, Mike Jones, I think I'd support just what Dick said. My additional suggestion is since this question came up here a few times. like, write a section, which is a note to implementors saying, How is this like and different than par? Right. Yeah. Yeah. k. Thanks, Mike. Brian. Quickly to respond to Justin. What you would get back is a lot like a request URI, but not really. Like, it's the request URI is con like, the actual request parameters in context where I think you'd be getting back here is, like, a context identifier or whatever you're gonna call that Well, the session thing. But the the value of the request URI is not defined. So -- No. The value of it, but it references the content of the original request. Which this would too?"
  },
  {
    "startTime": "01:52:00",
    "text": "or not or whatever whatever it would be whatever transactional context that authorization server wanted to maintain at that point that's decided Yeah. You're right. It's it's a little bit more than the just the request. AND MAYBE LESS. Like -- Yeah. and you could have discarded that information. I don't know. I I agree, though. I think the separation from par is there's a lot of things that feel like they could go together once start doing that, it gets ugly, and I think separate employments worthwhile. something else I wanted to say. 1st of all, I I'm I'm deeply ambivalent about trying to standardize this. So don't take any of this as Having said that, that whatever you're gonna sorry. Whatever you're gonna call that device I already forgot what it is, but but transaction identifier. The transaction identifier. So when when you kick out of the error, you get that identifier and you go back. Right now, it's to find a presented as a you know, form and coated, content. Right? Like, the interaction with this is. And that if this was the proceeding goal. That's, like, placing a huge restriction on the actual API that this endpoint would wanna offer for interacting with with the clients. Most people are gonna wanna do that, you know, with some sort of JSON based API. sending JSON the input Yeah. Like and I know OAuth does a lot of farm and coated stuff, and there's reasons for that, but, like, for something that's basically -- Mhmm. craftING A FRAMWORK AROUND WHAT'S GOING TO BE A proprietary API. And par this par so par is a Jason request? No. part is forming current endpoints, but it did that for a couple of reasons. One was so could take advantage of client authentication mechanisms, which are also form encoded. So there was a lot of, like, old history and historical reasons that it use form and coding to be compatible with existing constructs on the off framework and so forth that sort of just had to be, but this is your"
  },
  {
    "startTime": "01:54:01",
    "text": "you're kind of you're trying to allow for arbitrary custom API interaction, but at the same time, forcing a content type on it that I see. The people will Hate. Well, I mean, people there's there's a lot of objection to the form and coding in the first place. there's good or bad reasons, but reasons to have it in the law. Here, you have an opportunity to not do that. You just need to give some way to get that contextual identifier back and forth. So I don't know what the right answer is. Say how to do it in JSON. Make it a header. something, but if and how this proceeds, that I really think that's gotta change to be more flexible. That's a good point. maybe maybe putting it into a header is a a way to push push the problem out of we're not we're not we're not specifying the content type of your requests. Yeah. Yeah. because that's what what depop does, and what Deeplop does. That's what it I mean, it's kind of a cookie. That's what a cookie is, and But yeah. Okay. Yep. Yep. Thanks, Ryan. Corey. Corey. Oh, he Ori Steele. He's he's basically said everything that I chewed to say. But the the reason that the API that I was discussing before has this dual identifier structure is is specifically to address this kind of case where I start this flow off in some context that I'm trying to complete a mission that's complicated, and I wanna retain mission. And the first response that I get is my transaction identifier that I then keep reusing until I complete the mission. and that particular API was implemented in Jason and sort of assumed very, very specific type of Jason. was the only thing you would care about. So So I I would like to level up a little bit. So the the PCP"
  },
  {
    "startTime": "01:56:01",
    "text": "native apps, VCP wasn't published that long ago. it was end of 2017. And and, obviously, there was a lot of outreach and so on. And so I'm wondering What we could do to actually get a more feedback from others because it's feels a little bit like We've done the work But then some part of the developer community I didn't agree with what was done or what he didn't like it or whatever. it's It leaves a little bit of bad days behind, to be honest. So I wonder whether we need to have more outreach, maybe We talked to a lot of people, but not saying that. And it was ongoing, like, false Number of years, And so but still, it's it's weird that even after such a short period defined as this major gap. So major issue -- In my my understanding of the situation is that Owath started just for third parties. Like, it's all over the spec. Like, this is for 3rd party apps. Right? The mobile app, BCP, was also written in that context of It's gonna be used by 3rd party applications. And there is no question that it is still the the correct option for the 3rd party app case. and enterprise SSL. And anybody who's trying to argue that is wrong, and there's a lot of good reasons where we can spell out very clearly why. And you can't occupy someone that they should do a native login handle users passwords in the 3rd party application. Right? Like, Not a good plan. And now there's technical reasons why it won't work because of origin bound multifactor and stuff. So Cool. However, I think what ended up happening was people did start using OAuth And Open Ready for 1st party cases. all over the place, And that's where this kind of breaks down. because the attack, vectors that we're talking about"
  },
  {
    "startTime": "01:58:02",
    "text": "for 3rd party apps don't apply in the 1st party case. And then developers look at often they're like, well, why do I have to go through this extra hoop? if I'm just to open up my own authorization server, like, I don't want my users to see this weird prompt as as I'm trying to sign in with the app domain, and then they have to click 5 times to get through, like, I just wanna a password form in my app. Right. Right. Right. Right. Right. And I think that's really what started breaking that down. It it sounds like a nice story, but I like, from my recollection, like 1st party use was an was a topic also, like, during that time. So it's not something that suddenly, showed up in in the last two years. No. No. wasn't -- So so -- So -- -- wasn't sudden. but it's A lot of a a lot of the the OAuth documents were have been written in the context of 3rd party primarily. even if everyone kinda knew that people are using it for 1st party stuff. Okay. If we can't do better, then that's that's what it is. But but if we can, if you guys have some ideas on what we could do differently this time would like to hear about it. And I'm sure very far too. Absolutely. Okay. we are almost done. So but, yeah, George and John Yeah. I would just say, Hana, that it's not developers. It's product owners. Right? I I've it's not been since 2017. It's been before that. Product owners. Right? I want the I want to design my app. I wanna design the look and feel. I wanna design stuff. I want the colors to match this. I want you know? I don't you know, if if I bounce out, to my SSO provider in the web. It looks different. And how do I make that look consistent? doesn't feel right. It is you know, as developers, for the most part, we don't care, Right? It's relatively easy. Open a browser, send it over there. I get a code I'm done right"
  },
  {
    "startTime": "02:00:01",
    "text": "But the product people really do care, and then it becomes us architects who have to, like, go in and try and give the security reasons and all these other reasons and try and explain why They actually should be doing it in a browser, and It's an And I don't know that you know, so we you can make argument and try and win and sometimes you win and sometimes you don't. In this particular case, I think, because we now have good ways to have assurance that I'm talking to a 1st party app we have the ability to, you know, allow for a better user experience. And I do think they're, you know, the the conversation that Bob likely started ages ago at Identiverse about recognition versus authentication. Right? When you have a mobile app, you have a ton of signals. Right? And so the ability to potentially let a user in for low value things, but out doing anything actually starts to become viable. that you could do in this kind of a context Right? Still leveraging OAuth or OpenID Connect without actually having any user experience at all. That's John George. Sorry. John wrap it up here. So I think George's right about the product owners. I think some of the developers are also slightly bitter that they can't use a web view to log in to Google. and a bunch of other places. Why? Because it's insecure. but it's not because the BCP doesn't let them. You know, Google at the time the BCP was written blocked webviews being able to authenticate to Google before we actually finished publishing the BCP because it was insecure. So there are some people that Basically, have the view I'm good. Why should I have to jump through the hoops? that try and stop the bad people because the bad people are going to do bad things anyways."
  },
  {
    "startTime": "02:02:01",
    "text": "So I think you know, maybe we didn't do enough explanation in the BCP to say, yes. you as a relying party if you're gonna have 3rd party logins, don't allow them in web views. Maybe that wasn't. clear enough know, things like pixie, which was in that BCP, is now part of OHA 2.1. Mhmm. people should still be doing pixie. down. Yeah. Yeah. I think for the purely 1st party app use case, think we do actually need to look at the grant types now that every freaking mobile device has pass keys, Why aren't we just doing a passkey login and -- Mhmm. -- as a as a simple grant type. We could make this in There may be be use cases for this. But maybe there's an even simpler, more direct thing that we can do. Well, user logs in back and forth, and we're done. If you look at the examples there, like, that's the intent is that it should be that simple for those cases. Like, it's not meant to force you to do a 10 step back and forth collection of credentials. But only in the it's meant to enable I've got -- At some point, I'll actually read it. Yeah. But I think that if we do this optimized for the very simplest case where every iPhone, Android phone, Windows phone, has pass keys on it. if we can make it simple for the simple case where it is truly a 1st party app, because There is already native API that all these apps can use to get pass keys. in the context of the app. where it's 1st party. We don't have to deal with all of those third party things, but still enable enterprise or these other apps, which you know you know, you know, You still have first party apps that are using login with Apple and various other things where actually"
  },
  {
    "startTime": "02:04:01",
    "text": "breaking out to a browser so that they can do the appropriate authentication. is essential. So getting apps to understand the various levels and reasons why they need to do things. I think this Could be an important piece of modernizing it but we're still always gonna have people who compliant. Okay. Thank you. Great. You you got lots of great feedback. There is more to be done here. There is lots of interest. So and which is great. Yeah. I guess that means do we do we should we ask for adoption of the draft It seems to me a little bit premature. Okay. right now. So let's talk you talk with with John and see. Yeah. And and ask for reviews. And then because Seems like there was a lot of interest in solving the problem. Correct. Exactly. Not specifically the draft itself. Okay. for now. Okay? So let's let's keep talking about this, which is good. Okay. Great. Okay. Great. Thank you, guys, and gentlemen oh, go ahead. And thanks for the meeting minute, Deka. show, and Talia, I was like, this was like writing heavy. It's like a book. Thank you. Thank you, guys, and see you Friday."
  }
]
