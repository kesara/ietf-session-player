[
  {
    "startTime": "00:00:25",
    "text": "so 9:00 now is 15 15 so we start the tough session so I welcome to tough session somebody can close the door behind that would be really helpful so again welcome welcome to tough session in ITA 102 in one show so this is not well the first thing first I think most of you know about it if you don\u0027t know about it you newcomer please read about it it talks about your following the process of ITA process and policies and contributions how should we do so my name is Jay hydrogen wash our car and here we have Erin coach here hi Erin thank you here is the agenda you can see here so you have chairs update and then we will have the discussion about what would be the publication track for some of our drops that we have adopted then you have this try three and kind of drops that is very popular in among the caps right now so I guess I Krista dropped it will be present by Tommy then there is a interface draft that would be and then there\u0027s implementation brush that will be present by ana and after that we\u0027ll have these experience so we have some implementers implementing taps will listen from them we have Tommy from Apple will talk about the thing that they\u0027re shipping in a bitter we have Tom Hornet project will present his experience and we have Tessa to talk about and policy for some details from the implementation point of view and last not but not the list here we have this security protocol sorry so Christopher will not be present it will be I\u0027ll do the president am i right yeah so I think no trigger just make it yeah okay anybody you want to say anything about you wanna bash this agenda it\u0027s fine good good go ahead okay I saw some nodding so I\u0027ll go ahead so document is chatters we have not published an RSA since last meeting but we have one in working on Roscoe this time inset and then we have four updated documents that will know into this presentation what what is it about the - chance I think we have the milestone that still July 2018 that submit informational document defining a security related service I didn\u0027t just do that I think I don\u0027t know need to move it for a bit yeah yeah but "
  },
  {
    "startTime": "00:03:29",
    "text": "other one is on track and then we have some other 2019 will see old it with that I think we\u0027ll go back to the agenda and we have this we should start the discussion about traffic publication trucks diction and Marin I want to so we had some discussion on the list about the we\u0027ve got the three [Music] okay now I only have three slides so we had some discussion we met these three fundamental drafts right we\u0027ve got the architecture the interface and so he a little bit of dialogue on what track should they go on so I think the only one where there\u0027s really some potential for doing standardisation is the one that defines the interface and I think basically zyyd and I were unable to agree on our own so we weren\u0027t able to propose a decision to the group so we want a little bit of feedback from you guys which is probably the right thing to do anyways a little bit of a sort of process context for this there\u0027s a web page from the ISG on making a distinction between informational experimental turns that this question has come up before so and I\u0027m delighted most of the text here and try to just capture the the high order bits experimental is really about that research development effort could apply to this right we\u0027re doing some new stuff here but you could also say that you know it\u0027s getting a lot of engineering we\u0027re doing specification so informational does not represent internet community consensus or recommendation that really kind of stuck out to me I feel like I\u0027ve seen informational documents that don\u0027t fit in that so well okay so thanks isg thank you for that Spencer mate he\u0027s already here we go Mike oh wait wait Spencer let me finish my second slide and then the next slide because that\u0027s really just part of it this I just I tried to collect the information I could find quickly on that applied to this and so the the webpage goes on to have some more detailed guidelines and they\u0027ve got these sort of five tests and the ideas "
  },
  {
    "startTime": "00:06:29",
    "text": "one of these fits you then stop and you don\u0027t need to continue because some of them you know will take you in a different direction so if it can\u0027t be practiced it\u0027s informational well I think that clearly applies to the architecture document right so to me that means the architecture doctrine is informational I feel pretty good about that too if it\u0027s not gonna be changed no matter what it\u0027s informational and this is for vendor protocols other SDOs stuff that gets published so that doesn\u0027t really apply to us through a similar case that could be practice was developed by the ITF who\u0027s been dropped for some reason but being published for the record well I don\u0027t think that applies to this for reg if may publish something based on this on our standards track once we know how well it works its experimental so I think if we\u0027re in a situation where you were not if you know you want to publish as a standard at some point in the future but you\u0027re pretty sure you don\u0027t want to do it now and I think that\u0027s really kind of the core of or as I\u0027d and I are having a disagreement and then a 5 if document contains implicit or explicit success/failure criteria it also is experimental so we don\u0027t have any explicit success criteria but I think if we were going to publish this as experimental we would need to make some so we would know when it would go from experimental to scanners traffic okay so at this point let\u0027s put Spencer on so he has to say in front to speak we can\u0027t hear you Spencer perhaps remuda okay Kamino yeah I was just not exactly sure where I would pop up on my my screen here showing me that I was talking so now that I\u0027m talking the isg was also somewhat surprised to discover thee does not represent the consistence of the ietf part of the definition so congratulations you\u0027ve all qualified for that part of the audition for the iesg having said that and that\u0027s actually what I just push the button for that Aaron you mentioned the thing about although this is getting a lot of engineering and and I don\u0027t want to express the opinion about that until the working group has a chance to cogitate about all this but I know I noticed that when you said it okay okay how rows are combined so the one thing that I don\u0027t see on this that surprises me is any mention of the word normative right and so this is just for differentiating between informational experimental well no this isn\u0027t for differentiating between those two and standards track and so I think that\u0027s normative would be standard strap well not necessarily right I mean there\u0027s plenty of normative language in experimental traps or at Witness CCP crypt okay right it\u0027s basically just saying saying you know if you were going to implement this you must whatever right what I\u0027m "
  },
  {
    "startTime": "00:09:29",
    "text": "informational drafts right seem to be something that\u0027s describing the state of okay what was that mariya yes and they can also manage in informational drafts it shouldn\u0027t be did you have no okay I neglected I didn\u0027t really put my cards on the table which I feel like I should because I want to get feedback yes I think please do I think this should be standards track I think that there\u0027s there\u0027s a lot of thought that\u0027s going into this I think you\u0027ve got multiple people working on implementations of it I think that we don\u0027t know whether it will be popular and get deployed but I don\u0027t think my interpretation of experimental is we\u0027re like we\u0027re not sure if it\u0027s safe we\u0027re not sure if it\u0027s going to scale you know we\u0027ve got concerns about the health of the internet or or security or you know one of these sort of concerns that the IETF applies and I don\u0027t think that really is a apply to this case so for me I think that it should be standard check now the counter-argument are you with myself chef Yeo Joo doesn\u0027t standardize api\u0027s sorry I missed the beginning and I just saw the other site you put up very quickly right and I want to clarify something just to make sure that you having the right discussion can you put the other slide up this one and an information and document does not present internet community consensus it actually is it doesn\u0027t have to present usually most of the information or documents published does have I Spencer I think alluded to that and we think this may be an error that\u0027s okay wait are you I\u0027m done were you done waiting yeah so I really don\u0027t want to have B or F C++ pause and here again even though this would have been an appropriately sized room for it I think that there\u0027s so yeah this this really cuz I was I was talking to decided last night actually and he almost had me convinced it experimental and and I\u0027m sorry man but not quite there right like so I think this is the difference between or the original intention of the difference tween draft in the internet standard or proposed in in are oh yeah sorry right we got rid of draft right proposing an Internet standard right so um I am I mean I think we should I think we should sort of like you know home and move on um after we\u0027ve talked about it a little bit I don\u0027t take all day on this yeah but I am trying to figure out like I think we would have to actually write down success or failure criteria for an experiment and I\u0027ve been trying to think about those and they can\u0027t come up with ones that aren\u0027t like contrived is an exercise to get someone on the IES to you to check off a box that says it has via criteria right it can\u0027t be real ones yeah thank you I think your point about not spending too much time on this is a good one so let\u0027s try to get the input "
  },
  {
    "startTime": "00:12:29",
    "text": "out here quickly and especially if you if you are a contrarian view please be sure to mention that gorrister hist I\u0027m not sure whether oh yes I can\u0027t become Chari okay so and I don\u0027t see an X parent I think I see personally that we charted this work to do work in this space are we\u0027re trying to end up with something that we can standardize just as we do in any other IETF group we have not previously done much API work but we have done api\u0027s more recently in the idea so we believe we can do api\u0027s we\u0027ve never standard other people\u0027s standardized other people\u0027s api\u0027s here that\u0027s a difference but this isn\u0027t someone else\u0027s API so I think it should be proposed standard and I wonder whether the architecture document could also perhaps be people\u0027s standard for a different reason because other standards groups regards poor standards as documents which are normative for them so if we are defining a framework and we want to know the standards group to adopt this and use this then there could be some reason for making that proposed standard is there any normative language in the architecture document said no there is not because we wrote it this way um this is one behind was editing in this way I just leave that as a thing for the end of the process though because I think the first thing is decide on the interface and I say the interface should be proposed standard Thank You Tommy probably Apple is a bad mic yes hi Spencer so I agree with it being proposed standard I think based on the definitions here even if the informational one is slightly not correct I don\u0027t think information really applies for the interface because if it we\u0027re not a proposed standard it would definitely be on the something that we would not be sure about that we want to eventually become proposed standards I think experimental 2 standard is the spectrum upon which it lies and I agree that the experimental aspect doesn\u0027t really fit if we need a criteria to evaluate it against I think it does challenge us if we are writing it as a proposed standard to make sure that we do not include any elements in this interface draft which make it experimental I think I think there\u0027s a gray area there and we can definitely have extensions to this or peel off experimental parts of the interface that we\u0027re not sure about that have not been battle tested in real deployments at scale and I think that\u0027s a perfectly okay thing to do and the practice of making the interface appropriate to be a standard I think will be a good editorial focus for us Karl Rove\u0027s Akamai yeah I mean I think either experimental or proposed standard makes sense for this depending on the level of "
  },
  {
    "startTime": "00:15:31",
    "text": "confidence that we have that this thing is fully baked I\u0027m sort of uncomfortable with moving something to propose standard immediately when it\u0027s still very young and hasn\u0027t been I mean it\u0027s been widely deployed within one Enterprise it I\u0027m sure is so young when we\u0027re done with it well yeah the standards process those have that does have that property and I mean I\u0027m actually being totally serious I\u0027m okay with us sitting on a finished document for a while and getting some deployment experience and then revising it before we push it out to an RFC yeah that may be the right thing to say so if we\u0027re gonna take that approach then I think proposed standard makes perfect sense the other thing is that to the interface questions the API question it\u0027s fairly abstract right we\u0027re not creating a C API right we\u0027ll leave that to POSIX or you know people who I think the truism that we don\u0027t stand that API is really applies to those kind of API so okay Kalan Perkins I think I\u0027m mostly agreeing for everyone else so I will be brief I think we should be a proper standard if we were to be experimental I think the experiment would be that there is something we are not sure is implementable the experiment would be to check if it was amenable I don\u0027t think you can well I think you can go to PS without an implementation I think in this case I mean you could show that you could go to draft with without an implementation well I think there\u0027s a difference between without an implementation and we are unsure if it is implementable how else would you be sure well there may be things were where we haven\u0027t implemented it but we can see exactly how to do it and there may be things where we are unsure if if it will actually work in practice and in that latter case I think that might be a case for an experiment although preferably we were just waiting implement it but if we don\u0027t believe that\u0027s possible in short timeframe you know not hurry I\u0027d rather get it right [Music] so so yeah so the thing that I want to emphasis here it\u0027s like this thing you said is like experimental part I mean I have been involved in API definition and it may be my failure but I have never been succeeded to write an API that looks same before I shipped something it goes through an evolution and it I always get it like same way right so to say and then evolve even understand you use it and that\u0027s why I don\u0027t believe like the interface document need to be like really perfect in the first time but you can do we can write and we can put our best effort to make it like evil because the the point is point here is like they if somebody implements taps into our perhaps it doesn\u0027t make sense to me because we\u0027re making something for "
  },
  {
    "startTime": "00:18:33",
    "text": "the developers that they\u0027re gonna use it so if they\u0027re gonna use it and they things like this is good or they care they have a chance to come back and say hey I used it but it doesn\u0027t really like it doesn\u0027t help me much or it was really good so we need to make this space for them to come back and say what they think about it now that\u0027s my sense whether you can achieve it by doing it as a experimental so that they have it something it\u0027s travel they can try and they can come back and we can also take the next we can I\u0027m pretty sure we can if we think about it hard we can actually come up with some experimental criteria because this is an interface and this is this is a selection we have a policies we can see lots of criteria that actually focus on one interface so I can see like there is a way of creating some criteria to do that experimental so you can do that that way or we can say like what you did like we can stay so long time so that we make sure we have some inputs from that developer so that these interface is unusable I think I think I had were on the same page and publishing an experimental RFC and then going back and publishing in snares track RFC is kind of a heavyweight approach to do what is essentially the same thing is to wait for a while implementation experience and then decide that we\u0027re ready to go forward so sorry I interrupted you did you know I said like we have done it before I think this is not the first time that we will see like something does experimental and then propose the standard but with that said if the working group things like we can actually keep to our promise here like we\u0027ll be really watch food before proposing to IHT to put something I want to see that there is a measurable value here using these interfaces that we can say like we\u0027re proud of I won\u0027t have want to have it as a standard but that\u0027s what the taps will make value otherwise it is a academic exercise to me I agree I also want to point out that I think that point to collimate about this is a the fact that this is such an abstract interface that a lot of the fine tuning that I think you\u0027re referring to you is when you do the implementation of the abstract interface and that\u0027s gonna that\u0027s going to definitely take some time in that doesn\u0027t appear in our documentation so I think it\u0027s happens where the outside of that yeah yeah sorry to hear just to respond to that and you had again as a new job so yeah I mean I think we will move will like evolved architecture architecture is good start but it will evolve and then it will reflect on your interfaces and it\u0027s just like that so you will do that and you will find it so yeah so we need to be watchful and very very caring about so I\u0027m gonna cut the line and then we\u0027ll do some hums and then we can move "
  },
  {
    "startTime": "00:21:33",
    "text": "on to the technical substance blooming I don\u0027t want to stain your opinion just clarify some stuff so first of all propose done that doesn\u0027t have to be perfect there are many proposed standards that have air at her that get updated obviously whatever imminence then it has a very different notion it has to be kind of perfect in there still not right but in there key affected criteria but propose then that doesn\u0027t have to be perfect the reason why we have experimented in many cases is because we have protocols where that we have developed and we have done some kind of control testing lab testing whatever but we still have issues where we need like kind of Internet sky deployment and to test out this issues and we are not sure if those issues are strong enough to make the whole protocol fail so I don\u0027t not sure I don\u0027t think that\u0027s the case here um the other point I wanted to make is that if you if you have the architecture as informational and the interface is proposed standard then you will have a down roof so I mean so ahead now I mean I actually I\u0027m not sure like this and what you said like this wide deployment of traps will not hamper something I don\u0027t think like I\u0027m not sure about it because it it is actually so what are we doing here like we have some external protocols right and that people have been using in a certain way we\u0027re telling them this is a new interface usually you\u0027re supposed to get the best out of out of the protocols right and that actually creates an expectation for the developers who will use it and then perhaps if somebody was using their protocol and the texture like for example disappea they got some other protocol is the it has a different kind of behavior different kind of condition control is gonna hurt them a bit so it would be like I mean how do you cross taps architecture or traps interfaces provides the robust behavior I think I\u0027m not sure about that yet we have not gone through that process yet like what happens if I am enough if I implement taps version 1 and you implement tips version - it doesn\u0027t matter - matter right because you will get different kind of protocols no because the protocol is the same underneath it can\u0027t you can\u0027t have to talk to each other right fully yeah ok I\u0027m and I\u0027m concerned about time we\u0027re kind of at "
  },
  {
    "startTime": "00:24:33",
    "text": "the end of this slide so so down roof you will have a down roof it\u0027s not a problem you can if a down roof if you want to have a down roof or maybe there\u0027s actually I yeah I don\u0027t understand why I think it should be a normative reference how can you understand the IPA without reading the architecture yeah yeah so anyway so you can\u0027t have a downer if it\u0027s not a pro Marek inhibitor but we also had documents I could textured documents without normative language because it\u0027s not like this is stuff different criteria that have been published as the post Center okay thank you that\u0027s good Pete also I want to play spencer\u0027s in the one did anybody know such a mess was in the line before I cut the line it was okay we\u0027ll get Spencer the last word a pea present it can Spencer made me get up too late didn\u0027t really want folks are getting there themselves wrapped around an axle here 20:26 allows proposed standards to be technical specifications and applicability statements you don\u0027t that you don\u0027t have to have technical specification to have a proposed standard second thing proposed standard is part of the standards track there is an expectation that you revise it and maybe it will recycle it proposed or maybe it will go to internet standard it\u0027s a track and you can continue to make changes to a proposed standard although the entire internet runs on proposed standards we know it yes and internet drafts as well experimental should be there for when you\u0027re not sure what the outcome is going to be like and you want to do something off in a corner and not have it deployed on the real internet you want this deployed on the real internet I don\u0027t see any reason for this not to be all of it standards track be done with it we\u0027ve done informational of protocols when it\u0027s not our protocol that we\u0027ve developed and we just want to let people know here\u0027s a protocol but we\u0027re not recommending it for something this is proposed standard are you speaking as Pete or as Spencer I\u0027m speaking as Pete okay we\u0027ve moved in no no Spencer just made me get to the mic [Music] sort of building on what Colin said about you know things that would be you know if you don\u0027t think I think is if you think something might be dangerous like you know an attractive nuisance and the example I can have is if you had like a way to people to plug in their own congestion control algorithms or something like that I don\u0027t think you know if it makes you go oh my god that\u0027s horrible but it wouldn\u0027t certainly wouldn\u0027t maybe we don\u0027t want to do it at all it\u0027s also possible but you know certainly or in the or if you know you\u0027re defining the interface to something that is itself an experimental protocol then that would be "
  },
  {
    "startTime": "00:27:34",
    "text": "something that we think that can be peeled out of the core document and also proves that it\u0027s a sensibility mechanisms work right right and net dev was last week so okay so I want to go Spencer and a bunch of the things that I was thinking people have already said but I did want to mention two things quickly first is you know and that\u0027s actually kind of echoing what Jonathan was going with the you know is there a concern about the impact of this on the Internet I know that if we what we were doing was selecting between TCP and SCTP there would not be but that yeah it\u0027s the working group to think about that a little more broadly the other thing I was going to say was I\u0027ve done a lot of flexible things when there was a good description of what was going on in the Shepherd right up so you know like if at least one format of the Shepherd ride app says like up front you know why you know what what publication status is being is being requested and why so you know you can you can do you know just just tell just tell us the ugly truth and we\u0027ll do the right thing and with that I await you all strike a petition enjoy your enjoy a material Thank You Spencer so with the I\u0027m going to take a few homes with the assumption that we will can hold publication the document till we get some implementation experience let me start with with the interface document I get people to hum if they feel like standards track is the appropriate track for this okay and if I get just the interface can I get people to hum if they feel that experimental is the appropriate track for this okay but the sorry for the minute so let\u0027s say that there was a strong hum for standards track there was a small home for experimental is there any would anybody like to hum for informational for this document no homes for informational okay the architecture document it\u0027s a hum for standards track for the architectural document and hum for informational for the architecture document so I\u0027d say a strong hum for standards track and a a light hum for information and implementation hum for informational document for that and does anybody want to hum for something other than informational for that anything else I\u0027m for anything yes I don\u0027t want to go through like that yeah the complete "
  },
  {
    "startTime": "00:30:34",
    "text": "space here John I mean the one thing I feel like I mean it\u0027s been I\u0027ve read all the documents at once I might be misremembering but if there was some stuff in implementation that described how interface applied to particular protocols and I think that would really need to be in something that it\u0027s drank tell me Polly Apple so in general I feel informational for implementation just because that\u0027s the part that this is more of a guide I feel less confident on specifying it all there now the point about mapping specific protocols into how they behave deterministically within the API is a really good one and what we may end up doing especially for new protocols as having separate documents which are proposals of here\u0027s how you map quick into taps here\u0027s a you\u0027ve got that into that and that may not at all be the implementation draft may define like you can have these set of documents but it may not actually be the definitive reference for any particular protocol okay one more brian traymor one more on that point and I would say if there are if there\u0027s the temptation to add normative language the implementation document that says that you must have this behavior than any must on the behavior needs to pop back up an interface that\u0027s part of the contract so in and let me just take a final hum how do people feel hum if you\u0027re in favor of getting implementation experience before we afford these to the iesg because our schedule currently doesn\u0027t really allow for that you and my feeling is that it\u0027s a good idea but let\u0027s just have a hum in favor of that and how about a home in favor of moving as fast as possible to get the RFC\u0027s out okay I think that was unanimous okay so it\u0027s one colon plugins but actually in many ways suggest with was stronger than just implementation experience and one two implementations no strings yeah I think the criteria we should figure what the criteria are for how to exit this but I think that um it\u0027ll be easier to do that once we really get you get into it but but that\u0027s a good point okay sorry this way a little bit long but this is very helpful thank you so I think the home has been loaded um "
  },
  {
    "startTime": "00:33:46",
    "text": "all right okay hello everyone I\u0027m Tommy Pauly and I\u0027ll be sharing with you our updates to the architecture traffic taps which apparently is now going to be a proposed standard so I\u0027m going to go probably a little bit shorter than our expected time for this to make sure we have enough time to talk through all the interface details um there just a couple different updates I wanted to give most of the document is the same we did do some editorial passes for knits um thanks Corey for a lot of those so we\u0027ve updated this as a oh one document just before the deadline recently and there are two main sections that have been added which I would love all of you to read and consider there\u0027s one that discusses a concept which was not previously defined which we are calling protocol stack equivalence and the other one is section when I think Colin added on message framing and parsing which was something that had not previously been fully covered in the architecture which is a fairly fundamental concept and so needed to be addressed so first protocol stack equivalents so we already had the definition of a protocol stack essentially this is one thing that you can have as your candidate set of options to actually send data out into the network this includes any framing or application protocols that you need on your transport protocol and your IP protocol options and this would contain and carry along with it any of the protocol specific options that you had from the application and so you have multiple of these candidate protocol stacks and the idea is that you could do racing between them you can be flexible you can swap them out necessary but the key thing that we needed to define in the architecture is when is it appropriate and when is it possible to do this kind of racing or swapping this is a hard question and so we called this the equivalence and I essentially view it as meaning that these two things are isomorphic from the applications perspective and you can swap them out safely and if they\u0027re not then you should not be doing any type of racing between these without the application being fully involved so we came up with a list of a couple of requirements in here and so I\u0027d like to share them and if there any things that you think are missing or that you\u0027d like to disagree with please speak up now or raise an issue on the github so the first item is that the two protocol stacks must have the same API surface it seems pretty clear just quoting directly from the document they must offer the same interface to the application for both the connection establishment and for the data transmission so this simple example here is saying that if I have a Datagram or messaging interface essentially when the application is being guaranteed that there sends and receives have preserved message boundaries that are actually transmitted "
  },
  {
    "startTime": "00:36:47",
    "text": "across the other side any stack that I\u0027m switching between must have that property so I could use UDP because that has well-defined message boundaries but if I wanted to use something on top of TCP I would need some type of framing layer that actually delineated where the messages are this could be something like HTTP this could be just a basic TLV but something has to do it and so if we had just UDP versus TCP those are of course not equivalent and it\u0027s a fairly obvious point but I think it\u0027s important to make because this applies to any of the bits of the API surface that we\u0027re working with the two stacks also must have the same transport services that they offer but these are in context of what is required by the application so if the application requires reliable transmission then let\u0027s see I think I have it backwards yes sorry those labels are wrong swapped labels I\u0027ll update the slides for you so if the application allows unreliable transmission then a UDP interface is indeed equivalent to a TLV interface over TCP one does offer reliability where it is not needed but that isn\u0027t a problem if it\u0027s not necessarily required however if you did require a reliable transmission on both sides again flip these then they would not be equivalent so protocol stack equivalence is dependent to some degree on the application required properties Colin Colin Perkins yeah that\u0027s one we have to be careful of because yeah you\u0027re quite a recurring reliability affects the timing so so the comes between yes yes so if the only thing the application said is I don\u0027t need reliability then it may be okay to put this over TCP if it is I need this with certain timing requirements or not head-of-line blocking then that wouldn\u0027t be appropriate so the outcome of a lot of this is that you have to be very careful with these and there are a lot of stacks that may look equivalent that really shouldn\u0027t be so it\u0027s let\u0027s be very careful let\u0027s not break the internet and then the other part and Chris is not here but he contributed a lot of text so that is saying that they have to have the same security properties and we\u0027re remanded on this to be safe is to say that you really have to have identical security protocols to ensure the equivalence so you can have different stacks that both include TLS 1 3 for example I could be running a h2 stream as my transport stream or I could just be using a TLS stream directly but if they\u0027re using the same version of TLS and the transport stacks otherwise offer me the same transport services that should be ok however if I have even the same TLS protocol but a different version then that should probably not be "
  },
  {
    "startTime": "00:39:47",
    "text": "considered to be fully equivalent yes what John thanks I guess my first would you consider DTLS to be the same but given the caveat to the previous slides right that\u0027s interesting question so I think Chris\u0027s answer would be no I think this is something we should debate and discuss more in detail like for example if I have DTLS one three and quick if quick offers unreliable datagram frame transmission within it are those equivalent enough we should look at that and the other thing is if you know on one thing I have I can do you know 1/3 or fallback to 1/2 and the only other one only supports one - those are are equivalent because 1/2 was allowed in both cases right right Cairo\u0027s Akamai so I\u0027m going to be put in the interesting position of arguing against something that I\u0027m going to be trying to argue for in the presentation later right but the problem that I have with this framing is that it\u0027s even for even for the same security protocol you could introduce a side channels because their particular transport layer property or application layer property that would differ you know that would cause the that would cause the security layer to reveal different information right so they\u0027re not really equivalent necessarily anyway it\u0027s also the case that by making this the requirement then for instance G quick is not equivalent to anything because nothing else uses quick crypto so I\u0027m wondering if what we should do instead is have a requirement will reap unto the security area essentially what is the what is the bar that each of these things satisfies right like is Mical e if you want if you want security you know you define some you defined some some framework where you say where you say I need these properties of the security layer and therefore any of these are good enough to achieve that and that\u0027s how you decide which ones are equivalent for your applications purposes I just I think there might be something more there might be something richer that we can do that would be more meaningful from the perspective of deciding whether protocols different protocols are cool mm-hmm yeah a couple responses to that one I agree that we should again loop in security area to get advice on this I think the point you brought up specifically about different things being given away is one of the reasons that Chris was arguing against making DTLS 1/3 and TLS 1/3 equivalent because they also have such a different interaction model with their underlying transports that they may be giving away different properties so I definitely that\u0027s something to look into great so that\u0027s that comments and stuff on the github would be very very welcome "
  },
  {
    "startTime": "00:42:47",
    "text": "or on the list the other area is message framing and parsing so this defines that we do have a focus for data transfer around the concept of messages protocols that natively support messages translate very naturally to this and it does briefly mention how streaming protocols are really only preserving one message boundary which is the end of the stream and so this implies that in order to be able to usefully have multiple messages within a stream you do need a concept of message framing that can get pushed down into the protocol stack this is already all in the interface we\u0027re just kind of bringing the abstract definition shipment definition of it up into the architecture so as far as what\u0027s left open issues here I think one of the big things is a bit of documented restructuring currently these new sections that I just mentioned are tagged on at the end of the document it doesn\u0027t really flow particularly well that way I think we need to introduce the concept of messages and these ideas at least earlier up in the document even if they\u0027re just referencing back to the main text which is later on so we\u0027re going to do some word smithing there if people have thoughts and opinions please share them the other thing is we definitely need to fill out our privacy and security consideration sections I think part of that will be taking more into account of what we\u0027re just discussing as far as security protocol usage and then also we do need to look at how we are handling storage and caching of data if we\u0027re doing this across connections we need to make sure that anyone using this type of architecture is not accidentally leaking information across boundaries in which they were not intending to share data so if this is all within one process space or within one system we need to make sure that the data we\u0027re using to be smart about how erase connections in resume connections is properly isolated I think that\u0027s going to cover that so that\u0027s all I have if there any questions about architecture the more question for you Tommy just kind of a management question it\u0027s just based on the issues that you\u0027re raising it sounds like this document is mostly complete would you say that well I think it\u0027s at this point the scope covers mainly what we want to have we definitely want to keep refining it as new concepts do come up in the in the interface but I think it\u0027s going to go into more of a reactionary mode pretty soon you don\u0027t have a lot of other than the two things you just mentioned other holes this reflects the open issues that we currently have yes Gouri Fair has there there may also be perhaps a few more architectural pieces which we want to keep vague might like perhaps there\u0027s policy stuff we\u0027re going to talk about later has to somehow fit into the architecture and be described in a nice concrete way without paying it down into kind of real definitions so I think there\u0027s probably need for a few more revs of this to get this right right and I think those are going to hopefully align to the new texts that we "
  },
  {
    "startTime": "00:45:49",
    "text": "add in the other drafts that\u0027s why I say like mainly reacting to flesh out the full picture sure show hands who\u0027s read the document okay it\u0027s good I recommend it so if you haven\u0027t read it you should look at it thank you target right thank you so I bought their messing with this I\u0027m Brian Trammell I\u0027ll be talking about the interface document which compared to the architecture document is currently kind of an incoherent mess so please read it but in in the the architecture document if you read it and you don\u0027t understand that that\u0027s a bug and we need to hear about it and if if you read the interface document and don\u0027t understand it then we probably already know we\u0027re gonna have a little bit of a discussion about some of that so basically they\u0027re the reason that this is currently incoherent is this is not as done as the architecture document so we\u0027re rubbing this um much more actually keening go to the next slide while I\u0027m rambling on oh this is um you know the design principles is basically just a review this is we haven\u0027t changed these that\u0027s good we think the interface design principles are correct we\u0027re kind of following the process of like working on all of the of turning this into a coherent and consistent implementation of the architecture our projection of the architecture into something that\u0027s implementable um and basically we\u0027ve been working on that continuously in fits and starts since London and what we see today is a just before the deadline snapshot of where we were there were a couple of large things that we did to the document that took a fair amount of effort those are done and then we basically kind of like we need to go and we have a growing list of issues I\u0027m just basically putting this up here for people who haven\u0027t seen what this talk and I\u0027m not gonna read it to you this is just sort of the review of what we\u0027re trying to do in this document this is the interface diagram as of 0 1 things in red or changes since 0 0 we have some terminological changes um these are called properties now as opposed to parameters I think they were we realized that you actually need a way to stop listening Thank You Jonathan it\u0027s like you couldn\u0027t stop listening before you just had to take a pre connection and crash out the application which is probably not the best way to do it we added message contexts an end of message in order to support partial sends which I\u0027m going to talk about in a moment we added received partial as an event "
  },
  {
    "startTime": "00:48:52",
    "text": "for partial receives and we actually made it clear that data and metadata are associated with the received events so with the receive metadata for example that\u0027s all the way down to if the stack supports it you may forget this object that um everything that the stack knows about the message and is willing to share with you comes up we haven\u0027t really made concrete what it should or must do yet that\u0027s that\u0027s um that\u0027s in the future but we\u0027ve we\u0027ve said that this is actually part of it in to some extent it might even be what exactly or here\u0027s the minimum contract of what that\u0027s going to share with you but what exactly is is stack and implementation independent um it\u0027s gonna be interesting because I have some animations and they\u0027re not gonna render okay good so a non editorial changes since double zero um yeah these are basically the six pull requests that we got through we\u0027re only gonna spend time talking about the top two today because there are the big ones um is this the point that you want to come up okay um actually no no I\u0027m gonna do this one you can then you can come up after um Philip insisted on giving this part and I actually am going to be out in the audience heckling him because of this point right wait whoa we don\u0027t think we have this rate yet so we\u0027re kind of you know we basically snapshot it there was a gigantic editorial change to take all of the various places that we were talking about properties and parameters put them in one gigantic pile so that we could try to systematize how we talk about them and we have at least three proposals for systematization I think actually probably we\u0027re going to interrupt in the middle of this and then go to Tommy\u0027s proposal for that after um so we actually that the slides that Tommy sent it can we want to insert in the middle of this clock okay yeah so we\u0027ll see when um so yeah the new approach we did basically take all the parameters that aren\u0027t security parameters and we call the properties we stuck them in the new section this is a really useful exercise because it allowed us to see where all of these things were like the document distance between these was pages and pages and pages and you know out of this exercise like the first thing we found was just oh we we actually did some copy-paste errors like some editorial stuff or we didn\u0027t think about how these things interact the the basic mechanism by which we do transport protocol selection which is where the you know the the important Topsy part of taps is pretty much the same we still have preferences they\u0027re expressed using you know requirements preferences avoidances and prohibitions and then new because of how we interact with partial sends information that\u0027s on a per message basis is bound to a message context and then you can keep sending data to that message context probably we will recommend for the common case of not doing a partial send we will recommend syntactic sugar for um for paper and over that it\u0027s in there Oh excellent um "
  },
  {
    "startTime": "00:51:53",
    "text": "so this is the part at which Philip wanted to come up so we were thinking about how to structure these now called properties for the various effects how to send stuff how are sent messages how to do the selection and we basically start out sorting about different things so first we clearly defined data traps they were in the old version they were just described in the text so this small as a boolean now we somehow came up with some kind of structure that can be also used in later documents that for example define properties for certain other protocols we added a scope describing whether these properties apply to pre connections connection our messages which is also pretty clear which also enabled us to D dublicate some properties that were once defined for messages and for connections but apply to those then you can just describe the one thing and say okay it applies to pre connections and connections and to the messages and finally we have the need to thinking about whether we need to classify somehow the properties by they decide how their work and what effect they have and I think this is the most controversial one because this kind of classification we did there is more or less the let\u0027s say upper bound of detail one would want to have a new classification so therefore it\u0027s really an upper bound proposal that may be kept down later on we\u0027re aware of it we are not insisting in having it that complex we were just want to you know in the working group to think about this process so first there are two aspects to classify them one is whether is the level of abstraction so whether they have an immediate meaning so whether you can just go into the implementation document or the API to commit and say if you set this property it will have the following effects on the following protocols and you have a clear meaning that will be consistent about all implementations that will be consistent on all environments this application is run elm and we have stuff that is interpreted so as if the current version we only have the capacity profile property which is interpreted but it can have different meanings depending on the environment it\u0027s run on during a discussion with Gauri I think it\u0027s really he convinced me that it\u0027s really "
  },
  {
    "startTime": "00:54:54",
    "text": "important to at least tech properties whether they have an always I wouldn\u0027t see consistent but at least you\u0027re consistent meaning or they are interpreted by the transport system so that\u0027s one dimension of the classification the other one is what these properties mainly targets to control this is in Caban case the selection protocol and path direction this is the second case some of the protocol operation and that\u0027s for some that were mainly left coming from the message context properties that control how the transport system actually works and this that changed the state of the transport system itself indifference to the protocols as we had they were neither clearly being protocol properties nor something else we made up a new box and called them control properties maybe we need to structure this completely differently but at least we needed some box to put them on and make sure that they are it kind of different beast than the properties that are used to control protocols um yeah this was mainly what I wanted to show you front will you go to ton check you\u0027re about halfway through your time you get ten minutes yeah but I reckon read fast great there we go okay we\u0027re done with that yeah so we actually took this with these sort of axes and applied them to all of the properties that we have you can see some question marks in there these are things that we\u0027re not even actually sure our properties um I\u0027m not gonna go through each of these I\u0027m just gonna ask people to have a look so you know here type is the data type I actually think the data type is useful we should keep it it turns out that we do actually have this horrible thing which is a when you\u0027re talking about interface and PVD instances you have to have an enumeration slash preference to pull we maybe can do that a little bit more cleanly the scope is does it happen on a pre connection just happen when the connection just happen on the message the to control properties are here the selection properties are here this dependency means in a lot of cases when you have a message property it actually depends on a protocol selection property to have been applied to the pre connection right like say you basically can\u0027t have a per message reliable transfer if you didn\u0027t select a transport protocol that configures reliability per message there\u0027s an open question as to whether or not doing stupid things is an error or just ignored by the system like we need to that\u0027s we just need to make a choice that\u0027s a bike shed and we can paint it "
  },
  {
    "startTime": "00:57:56",
    "text": "looking through these though you know there\u0027s a lot for you know controlling how you send messages there\u0027s this check some coverage thing which games out came out of min set UDP light there\u0027s one intent uh which is the least horrible name that we could come up with this is called capacity profile what basically means do I intend to send traffic in kind of an interactive way or in kind of a bulk transfer way or in kind of a scavenger way I\u0027m just basically talking about sort of the yeah well the capacity profile that\u0027s the the best word we can come up with I don\u0027t quite when a wordsmith fat right now gory I only have eight minutes all right but like we have this you know we looked went through this whole sort of orthogonal sort of thing oh and then there\u0027s all of this stuff for you know buffer sizing rate and these are sort of read-only right it\u0027s like you once you select a transport protocol you might actually want to know how big the buffers are so that the application can figure out you know how it should interact with it we tried to do these as axes and then we realize that they\u0027re not orthogonal which is kind of one of the rules for ax easy and then I went through this list we have like six distinct kinds of thing great sir of very clearly we have preferences used for election you we have a property that controls how the message is sent in a scope go message and it\u0027s usually linked to a selection preference we have a property used to control operation um and it might be usable for selection as well right like so for example if you\u0027re gonna say hey I need a protocol that it\u0027s going allow me to send atomic messages of 128 K um good luck the system will go off and implement and define the nutrients per protocol for you I guess then you have properties to inspect protocol operation so these are always read-only things at the end you have the special snowflake how do you figure out that you\u0027re going to bind something to a set of interfaces and/or provisioning domains and we went back and forth on this one for a while I think this we actually got this one in before London right and this is the least bad way we could come up with it that fits into you sort of the way that we did things we might actually these are special enough that we might actually want to treat them entirely differently in the in the API like so we need to we need to probably even file an issue and say let\u0027s go back and revisit this and then we have intense which are you know sort of down at the bottom of that of that thing because they\u0027re entirely different in how they interoperate era interact with the system like an intent can be used at any scope and can have sort of like higher-order effects on how things are put together from an implementation standpoint I\u0027m not entirely convinced that intents aren\u0027t like another layer on top of this API right like so there\u0027s a you have an intention of an API that "
  },
  {
    "startTime": "01:00:56",
    "text": "lives on top of this one that basically turns your intense into these five types of properties and then maybe you know their implement in the same way there alone in the same stack right but simply because and actually the exercise of putting it into that um into this thing over here it kind of shows they\u0027re different right um so that\u0027s that I\u0027m gonna open this for 45 seconds of discussion oh oh yeah I know right this is the point that you need to vote they\u0027re dropping yeah yeah yeah yep I can just talk them over here this is Joey so we were discussing this a little bit earlier and so this is a very nascent idea you actually get uploaded essentially before we get the slides yeah the idea so basically I\u0027ll let me introduce oh there this you know so my idea one was okay let\u0027s try and you put this in a whole bunch of sets of orthogonal axes actually on on applying that and this is just you know my opinion it seems like we have a whole bunch of points in that space that are not occupied and will never be occupied and I said well simpler would be to you know classify identities in kinds of things which is actually kind of what we had before but we haven\u0027t really reasoned about it in any rigorous way the downside of my proposal is that does my cloth ad hoc classification work because of some essential aspect of the problem or is it just the ones that we\u0027ve thought about so far right so I don\u0027t like the non orthogonal \u0027ti of it um and then at lunch I think Tommy and Colin invented a third thing so anyway yeah this is a just an attempt to try to graphically draw it out so the idea here is just cuz Phillip mentioned there\u0027s kind of a scale of we have deterministic properties and ones that are more interpreted and as Brian was saying we could probably get away with maybe saying the interpreted layer is a different thing for now and so the goal here is to allow us to vary deterministically say what is going to happen in the system based on two categories of properties which you actually get from the architecture there are so the architecture defined general protocol properties and specific protocol properties so here\u0027s how this could work out right so let\u0027s say I have a generic property about my type of congestion control that I want and I say I want background style congestion control which is a very concrete thing to ask for but it could apply to different protocols potentially differently as opposed to saying I have a very specific protocol property like if I\u0027m using TCP in this connection use let "
  },
  {
    "startTime": "01:03:56",
    "text": "so there\u0027s are two ways to specify this so the next slide um actually one back yeah nope there we go so the way that this plays out deterministically is that if I use a generic property I don\u0027t know which one I\u0027m going to get but I we will have a specific mapping for every protocol that we can actually define in a spec somewhere saying that when TCP is running and it seems back on congestion control it will run LED bet and and if you say require background congestion controls and you have a stack that doesn\u0027t have for it in which fail you\u0027re dead right so it actually creates a very deterministic way to select which protocol stacks are even eligible here and then let\u0027s say quick comes up with a special background bbr which is getting called bb-back or baby back ribs so please someone create this as a background congestion control protocol exactly as opposed to saying if I only want to if I only want to use LED benefit of doing TCP that will not affect any stack that uses quick so it gives me the flexibility that I need from an application standpoint but also makes it very deterministic and we don\u0027t have to worry about an application saying oh I want this property and maybe it\u0027s interpreted one way today by the intense engine and then we can never really change it because they relied on that one last slide something that Eric brought up when we were discussing this earlier we can also do a cute thing of rather than having the options for TCP ever be called LED bat just have it be TCP background check congestion control such that the types are always the same we just say it\u0027s more specific to certain protocols so this is an idea that we could start to explore for categorizing things and it fits a bit better with the architecture cool so again right before that you got one minute and to the end alright umm yeah ok then we might have to bring this back at the at the end of the thing but yeah you know what I\u0027ll take it offline umm wait wait wait we have an open issue they don\u0027t to bring up Tom you got like five seconds at so Tom jokes just very quickly I totally agree and I go to them over lunch but I don\u0027t want to build it massive databases right yep yep there\u0027s another thing that came out of that and I don\u0027t think we say anywhere in any of the documents that we require deterministic outcomes and we should probably have a statement about that so many phone is you thank you skips us like yes oh yeah right Oh personal send/receive oh that was what you want to say okay cool um on uh how much time do you need can I have some of your time okay cool okay Kyle do you need all 20 minutes fierce okay I\u0027ll take ten okay good good all right yeah as long as as long as I you go she "
  },
  {
    "startTime": "01:06:57",
    "text": "ate four more time before it runs out right like if it the door doesn\u0027t open and I say here okay good um so partial send and receive do you have a question or a person send receive should I run through this real quick run through it\u0027s and then I have a comment okay um so on the API on purpose is organized around atomic read and write of messages but it turns out that buffers have finite sizes yeah it\u0027s kind of unfortunate the solution here well and sometimes there\u0027s actually an application layer thing where at the beginning of sending a message you don\u0027t know how long the message is going to be because you\u0027re actually streaming something off of something that\u0027s actually a physical stream but most often this is you have an object your higher-layer application thing as though I don\u0027t want us in the entire JPEG and the JPEG is huge because it\u0027s like the Hubble Deep Field and okay well now you need to do a partial rewrite so the way that we did this is is it inspired by or stolen from the API that that so the Apple implementation of this it\u0027s pretty much straight up how they do it um where send now has an optional parameter that says I\u0027m done sending or not and there\u0027s an object that you bind that sends to you which is the the message context right like so in a in an object oriented like a classic la Victorian program I\u0027m sure you could implement this by essentially saying I\u0027m going to create a message context for sending bound to this connection and I\u0027ll just keep writing bytes to it there are a bunch of different ways that you could sort of project this into different languages um as long as you don\u0027t say I\u0027m done is this is the last right you can actually have a zero byte last right as well right like so you can essentially say oh yeah I thought I wasn\u0027t done but now I\u0027m done once you say you\u0027re done then the message context closes on the other side when you receive a partial message so a message that the system does not know is the end of a message either because it has protocol they are framing because it was UDP or SCTP or because the D frame are actually detected end of message but it\u0027s still larger than the buffer you will end up with a received partial of course personal readwrite boundaries are not preserved right like that only the message boundaries are preserved across across this end assuming that you have either framing in the transport protocol or a correct D framer um so this complicates the API somewhat in that you can never be guaranteed ever that you\u0027re not going to have to hand will receive partial but it allows us to essentially flexibly handle sends and receives in a message atomic fashion without requiring you know everything to be under the size of the buffer so Colin so Colin Perkins so I think if you look at the architecture we have quite a nice "
  },
  {
    "startTime": "01:10:00",
    "text": "high-level view of where you\u0027re sending and receiving messages and putting the framing and deferring if those messages down into the stack yep I think this this is kind of losing some of that it\u0027s pushing the some of the the knowledge you need to do framing it back up to the application so that\u0027s I\u0027m not sure we quite have this right well so we may just be that you\u0027re and I mean Tommy has comments about Bank pressure and I get there and I think we have to resolve this somehow the idea of sending a message objects which can then lazily load the rest of the content for examples which seem to match yes so if the downside of that of course that you might end up with unbounded buffer attacks right so I don\u0027t think it\u0027s moving the complexity oh great yeah okay and great yeah probably more natural to to implement in some languages than others and we may be able to come up with wording which satisfies both implementation styles but so yeah we landed this in order to be done for um and we\u0027re gonna have an answer so you know I think what we have is okay cool so we\u0027ll keep working on it final an issue assign it to : tell me so just to respond to call it I think what this phrase is what we look at the architecture versus what we have here is a bit of a philosophical question that we should all ask of like when we say this is message oriented what is then what is the thing about the message that we like I see two possible answers to that there\u0027s one that just means that message data has well-defined boundaries right we want data that\u0027s just unbounded streams who want well-defined preserve boundaries that are actually communicated between two sides of a network the other one is that we can do things atomically and this version of message has boundaries but is not atomic it can sometimes be atomic but it recognizes that that breaks down so if we define messages as well-defined boundaries of your data then I think this does meet with architecture needs but it\u0027s a question yeah our definition I think I agree it\u0027s clear that we need passion of wheat because you might just not know where the boundary is right but at the moment where you send a message it\u0027s blob of data so like it\u0027s it hasn\u0027t links right so you can just give it to the other their great great default desert yeah so the problem is this is the thing that only actually happens in a corner case where you\u0027re trying to send things too big for the what the transports dot can give you and to some "
  },
  {
    "startTime": "01:13:01",
    "text": "extent like I mean so applications right now you there\u0027s no application that opens if I guess there is send file okay that breaks things but yeah that breaks things more ways than one but like so if you\u0027re not basically you know telling the kernel to blitt a file to a file descriptor that\u0027s also a socket that might be UDP yay what happens when you do that the right well in this key in this case that\u0027s the right question right um Brian yeah I know I\u0027m rambling we have one more topic it\u0027s a gigantic bike shed I think that what what actually is come out is that we need to have talked about this let\u0027s okay so we have one open issue which is hard to follow because like we did half the discussion on the issue and the other half the discussion on the PR because Colin wrote something that he thought was a pretty good idea and then like I said no this is terrible and then the end of the no this is terrible were four options called option one option three option three point five and option five there\u0027s there\u0027s also on option two which I wrote down but when I was making this slide I realized that didn\u0027t understand it anymore so um basically this is the this is the Apple versus Linux how do you do TCP fast open fight the first option is that you make everything was it you "
  },
  {
    "startTime": "01:18:06",
    "text": "[Music] you can\u0027t do TFO way one with OpenSSL at all yeah I could have an air this time I disagree with calling this is why we have meetings I thought the whole exercise is to not let the application to specific protocol properties I think that\u0027s great yes there is a security here is great but like first of all you have to negotiate PFOS in previous connection right so you have to have the house the ticket or a breeze so otherwise you cannot do TiVo so the problem here is that is that 0tt is a very special stuff I know so what we should do is like we should say if a message has Ida put no not by default it\u0027s not our department so you cannot use it and you have to actually declare that inside a potent and whenever you have an idempotent data and you have session keys from previous session you can use to fill of course but yes well we know that but the problem is that how do i express how do i keep the thing from running the connect before I\u0027ve sent because you know you have session keys okay so that\u0027s option three or three point five so if the stack knows that it can zero RTT because that session key is it actually been says screw it I\u0027m not even gonna try ray city because there\u0027s a racing yeah there\u0027s there\u0027s a racing problem here as well not like a race condition problem that are a connection racing problem here as well can we talk for a minute how you gonna one of these options yeah I think we\u0027re gonna do a bit of a survey and then we\u0027re gonna flip the coin and then we\u0027re gonna a three and a half sided coin yeah and then we\u0027re gonna argue and then something will fall out of that and that\u0027s probably an interim that\u0027s a virtual interim topic if we don\u0027t fix it sooner can you note the two topics that we said so we can pull those out for the agenda later there\u0027s this one and then the partial says yes persons and receive do it better yep good excellent there are other open issues I\u0027m sure that we\u0027ve actually added more I sent some to the list please comment on the list and or in the github issue tracker thank you very much we hope to have a better document for Bangkok so any you think you can do it in ten minutes does have to be comprehensible yeah "
  },
  {
    "startTime": "01:21:25",
    "text": "okay good so hello everyone I\u0027m Anna Brunnstrom and I\u0027m here to give you an update on the implementation draft yes so just to start to give a recap of the scope so the implementation draft is the third draft in this series so it gives some guidelines on how to implement the API that Brian was just talking about so it\u0027s a complemented architecture in API draft this draft has also not changed so much since the last time not because it almost has everything in it like the architecture draft but because the as you saw it we\u0027re currently debating what the API will look like so it\u0027s hard to see how we implement it before we actually settle on some of these issues for for what the API would look like so it has become a working group document since the last time and the two pieces of information that have been added in terms of any content is that there is some further information on how to use the transport properties during the selection of branches when you do the connection establishment one of the updates in the API that Brian did not have time to talk about was that there is some new text on how you do batching sums and there\u0027s also some matching text for that in the implementation draft so those are the two pieces that have been added so we have a number of open issues for this document also there is some structure porch so one aspect is the the system policy and the caching and how that will come into the implementation draft and that will also be related to the discussion that comes how we will deal with policy in general we have two sections of the document that has to do with the connection establishments we have one section on rendezvous and discovery steps that are now in its own in Section ten prepared peer-to-peer connection establishment and then we have another section for where we have the text on candidate gathering and racing for for the other protocol so these two sections need to be integrated and generalized and we also have some alignment of terminology and those pieces when that settles in the other drafts we have a number of missing pieces in this draft so here once we have settled how the protocol and path selection properties are defined we need to have the mapping for what they actually means in the implementation so this is of course waiting for this part coming from the other sides we need a privacy consideration section to "
  },
  {
    "startTime": "01:24:25",
    "text": "distract as well we\u0027re going to add some pointers for the different implementations that are available we need some discussions on threads and concurrency there are some additions for ordering of API events that has gone into the API draft it doesn\u0027t have anything matching in the implementation at the moment so we need to at some point see that we have matching things for everything so in general there will be a number of alignments with the architecture and API drafts as those stabilized and details for all the open issues is in github so this one applies to all the three drafts if you want to see the details for what is under discussion that\u0027s it anything you want to try to get feedback from the not specifically because I think most of the things that we have open here are really depending on where we end up in the API and then we need to give you know do the matching part in the implementation draft but we don\u0027t have any big debates here yet because I expected me come back I said yeah the mapping so I guess this is related to Jonathan X sorry it\u0027s related to my comment when we were discussing the document status the mapping of path protocol section property it\u0027s many of things of parts of that are something it actually should be you know normative in the on the API rather than just implementation choices and that needs to be something that can be move probably into the into the interfaces document rather than here yeah I think this is something that we need to think about how we\u0027re going to do this split because we have I mean I agree that some of this needs to be standardized but we also have the mapping for all the protocol so it will kind of maybe be a mess if we\u0027ve moved everything of that into the API so we will have to think about how to structure this one and if maybe some of those pieces should even be separated or but I think maybe we can deal with that when we have come to that point but definitely that\u0027s something that we have to take into consideration so is he um hyper in dremel I see from sort of the the earlier discussion about status and how we want the workflow to go and then like the state of each of the documents that we\u0027ve had to this point I see sort of like two kind of functions for this document one is what we thought the original function this document was was to show that we have an idea about how to implement these things in order to justify their inclusion in the in the API document once we move toward more implementation from people within the working group that function is replaced by sort of a implementation considerations function great so once we move into implementation I hope that the workflow that we have is we dump observations into this document they "
  },
  {
    "startTime": "01:27:26",
    "text": "bubble up into the API documents and then anything in the API document that conflicts with the architecture might bubble up into the architecture document right so we\u0027ve started this process sort of top-down architecture implementation or architecture API implementation once we get an implementation phase I think the work will have a top-down we\u0027re just going to flip the directions that make sense whether it comes through this document or it comes directly to updating they I guess I think the I certainly will reverse because at this point we are focused I think as a group in the discussion for the getting the API sorted out and kind of trying to verify that it can be incremented and not be that that suggestion seems to make sense to all the editors because that seems to be what came out of this meeting that\u0027s actually kind of a useful are useful work so thanks we\u0027re on schedule everybody stays in there alright so while we\u0027re getting slides up I\u0027m Tommy again and now I think we\u0027re going to go into a section both of talking about implementation experience as well as specifically talking about how we deal with policy and how tap system interacts with the rest of the operating system so what I\u0027m going to be sharing here is specifically our implementation so we actually in June we when we released our new betas of iOS 12 and Mac OS Mohave along with that we have a new framework that\u0027s available which is called Network framework currently all that is contained in this framework is essentially a new transport API layer as well as things that allow you to look at your current network state and so this transport API is where we want to be continuing to develop our taps layer it does provide truly a post sockets implementation we do use sockets as a substrate when we need to but otherwise we actually are running a userspace stack within this so we\u0027re trying to free ourselves from the shackles of sockets and see how things actually work the real world this is implemented both in C and Swift the API interface I\u0027m "
  },
  {
    "startTime": "01:30:28",
    "text": "going to be showing here is just the Swift bindings because I think that works a lot better when we\u0027re talking about some of the modern conveniences that we are discussing in the taps API all of this is possible in C it\u0027s a little bit more cumbersome and less clean mr comment yeah hi I\u0027m structure from Apple I just wanted to set some context here because when you talk about public betas that might mean months or years and I want to set some context what we\u0027re talking about here is this may be public beta now but when iOS 12 ships and you can make your own guess when that maybe this will be the official public API great so if you are early adopter and want to try it out now you can do that it\u0027s also available on our documentation website if you want to see what the API surface looks like in full the documentation is not very well fleshed out again still so working on that there are a couple sample pieces of code though so the objects that we\u0027re exposing here we have some pre connection style objects we don\u0027t have something called a pre connection but we have a static endpoint object which can describe a hostname of asura service address ports and then we have our parameters which is essentially the rest of the pre connection that isn\u0027t the destination you want to connect to this has a lot of generic parameters but it also includes a protocol step protocol stack which is composed of various protocol instance options so you can essentially build hey I have an option to have TLS using these options on top of TCP using these options on top of IP using these options we have three currently different active objects a connection NW connection NW listener and end of you path monitor the connection and listener are pretty much exactly what we have in the Cape\u0027s api the path monitor is this other we have to essentially discover other interfaces and paths without actually connecting over them this allows you to if you need to have a different UDP connection or listener on every single interface that messages a certain criteria you can do that maybe that\u0027s going to be something that\u0027s similar to what we\u0027re going to need for ice and other strategies going forward and then there are two other objects that are used for more like introspection and dynamic interaction there is a end of you path this is the thing that you can iterate with the path monitor but you also get a path from any connection you create so it says here are all the network properties of the thing that you are using to connect on and you can get protocol metadata which is used for sending and receiving or just introspecting general state of your connection what is my current tcp receive buffer size so as an example of connection establishment Here I am creating a destination endpoint to "
  },
  {
    "startTime": "01:33:29",
    "text": "example.com on port 443 which I have a convenience for as HTTP we can establish a connection to that endpoint using a set of parameters in this case I\u0027m using a really stupid little convenience API initiator for the parameters of just dot TLS and this says just give just giving you the default TLS like behavior over a reliable stream you can go in actually configure all the bits yourself but that\u0027s just a four-character way to say it if you don\u0027t really care you can then say this say a state update handler the states I\u0027m listing here there\u0027s a ready state which means you\u0027re ready to send and receive data this is like our fully connected state in the taps API it means that TLS is finished TCP is finished you\u0027re ready to go we have a waiting State which is actually very important for our mobile devices oftentimes you don\u0027t have a network at the moment but you\u0027re about to have one or you haven\u0027t network transition happening rather than just failing if you create a connection when there\u0027s not currently a network we say you\u0027re waiting and we will automatically try to connect for you when a network does become available it\u0027s not something we\u0027ve really talked about in taps but it could be interesting when we look at kind of multipath mobility aware transports and failed if I have a fatal error and then after I have created my connection and set my handlers then I call start so we did choose to go with this split model of a create a connection object set some update handlers on it and then call start rather than just having a single combined initiate and that did influence how we did fast open when we look at the data path we have a basic send call so in this case the basic send we create our data in this case I just want the bytes of hello and I can call send on the connection passing that data as my content and then they have a completion handler which lets me know if there\u0027s any error sending that data and it only gets invoked when that data has been consumed and processed by the stack so in Swift you are allowed to have kind of optional parameters that have default values such that when you\u0027re using the API they\u0027re hidden from you so we actually only have one send call and so this implicitly has a end of message is complete flag that is always true by default and it also has a message context parameter which is just default message by default and so I can simply call send with my data and that is sending a message if I do want to go in and say oh this is actually partial or I have these special message parameters or properties then I can add those but those don\u0027t get in the way otherwise we also have a operation for doing batching of sins and this was really really important for making sure "
  },
  {
    "startTime": "01:36:29",
    "text": "we have good UDP performance if we\u0027re sending a whole bunch of data grams at once and so we can essentially just create a closure of a batch and any operations that we do within that closure are assumed by the stack to be held until it completes so we can say send send send send send and the stack will not intentionally try to process and drain that out until you\u0027re done with that batch operation only we can do a simple receive in this case we just get our complete actually this should be called receive message we\u0027re only wanting to receive a complete message that has a strict boundary on it and we get back our data in a context that has metadata about the message I received it lets me know if it was complete or not and any errors I thought if I explicitly want to receive more of a stream I can set the minimum incomplete length but I\u0027m willing to receive at any given time and the maximum length that I\u0027m willing to receive at any given time so again we have the I want one message at a time and I want to stream my data both of these work over TCP and they actually both work over uneven UDP as well if I just want to for whatever reason read out only parts of my Datagram at a time looking into message contexts the way that we did this we have a content context object it has a random identifier so we can trace it throughout the stack better and it has some of the properties that we\u0027ve discussed here as a expiration it marks is it the final context on my connection does it have an antecedent are there extra metadata settings here the metadata settings that we currently support are ecn flags for IP we have timestamp option now but the good stuff and then we also have some convenience send contexts so the default one whenever you\u0027re sending is default message which is this is a message it\u0027s complete I don\u0027t have any other special properties on it there\u0027s a special one for just this is the final message and there\u0027s also a synonym that we made for default stream some of the people when we were reviewing the API were concerned that if it was only ever message oriented the people who wanted their TCP stream might be a little bit thrown off so default stream behaves exactly like a final message and it\u0027s like if you use default stream you only have one message and you can just keep streaming to it and then you\u0027re done so if that\u0027s the world that you want to live in if you want to treat things like a byte stream you can but it\u0027s not the default so diving into a little bit of the implementation details here and how we are interpreting parameters currently this kind of gets into our policy discussion the application can constrain their path and their protocols using the parameters so for here for an "
  },
  {
    "startTime": "01:39:30",
    "text": "example we show requiring a specific interface type or we can prohibit an array of interface types and then here\u0027s a kind of just like a flow diagram of how the state works so the application comes in with their parameters when we\u0027re actually doing our connection candidate gathering we run that through what we call a path evaluator which takes those parameters and interprets them based on the system policy and this may be things about which applications are used are allowed to use which interfaces and what are the available interfaces at the given time and then that all gets generated into the object which we call the NW path which is essentially the current snapshot of the policy result based on the system policy and your parameters and that can have on it one or more interfaces that you are allowed to use and that essentially determines all of the rest of the machinery and we have a similar thing for any per protocol or historical performance properties looking into how that system policy actually works the system configuration itself determines a ranked list of the interfaces and there that are allowed to be used for default internet traffic so generally this is going to be if you have Wi-Fi and cell available Wi-Fi and cell but it could also be a VPN interface and can list all of the different default routes you have and those could all potentially show up in your path most of the extended policies we have do occur on a per application or per process basis certain interfaces or interface types can be prohibited or required and also I want to note that we have certain application parameters actually can be keys to influence which path you take so your parameters could include something like here\u0027s a specific account I\u0027m associated with or the specific endpoint I\u0027m associated with and that could determine based on system policy where you are bound so the policies that get installed in the system can look like if you are process X and you\u0027re marketing yourself as working on behalf of account Y then get scoped to this interface and so as I said before the path includes not only which interfaces you\u0027re going over but the protocol settings such as ecn and TFO allowances and your predicted RTT so we can do better happy apples so one area that I definitely want to see this evolve going forward is making this much more flexible for protocol selection as we get better options of equivalent protocol stacks to race between right now the things are fairly static you have a default stack let\u0027s say you create your transport options you can put them in great you have TCP you have "
  },
  {
    "startTime": "01:42:32",
    "text": "your options it\u0027s not doing a lot of protocol racing now other than in cases in which we have proxies or other things that we know really need to be interjected so I think this is an area in which we need to look as a group of do we have arrays of our optional protocol stacks if the application wants to explicitly state the protocols that it knows the server supports we can also imagine more conveniences for creating these type of stacks in the future so right now the default protocol stacks that we can configure our TCP UDP TLS over TCP and DTLS over UDP but it\u0027d be really interesting to say I want to default convenience for things that look like quick or HTTP to and essentially have that larger category such that the tap system can determine where to put things yep and here\u0027s just a lifetime diagram of our internal connections everything it matches up fairly closely to these state diagrams that we have within taps with a couple of differences the one main one I want to highlight is how we\u0027ve added that waiting state for whatever the network is not available it\u0027s not the same as the failure but we can\u0027t connect right now and it\u0027s a useful signal and has the interesting property of that\u0027s the ones to you that can kind of go back and forth between actually setting up and being in this holding place and that\u0027s all I have so if there any specific questions I have a you just want to jump the queue and Eska has sort of a working room chair kind of question so first how well does this match up with the proposal as it\u0027s currently defined and how do you feel about continuing to move closer to that as it evolves from I\u0027m asking Apple right sorry I can\u0027t speak on behalf of all of Apple I don\u0027t know what the future will be specifically I think things do match up fairly well with the overall interaction model I think right now our data path is quite similar some of the areas that are different right now are in the way that we specify the pre connection how we specify these properties because this is also the area that\u0027s fairly flexible in our own documents this is an area in which I think as that becomes more and more clear we will probably likely want to add those knobs to this API we may not necessarily remove other ones so it may be a little bit a superset of the taps API but I think having something that would conform to the general model that we\u0027re designing here is a goal it\u0027s really high competence so the the beginning of that sort of left-hand side of the state diagram them sort of breaks down what what I guess we\u0027re calling pre connection writings into a few more "
  },
  {
    "startTime": "01:45:34",
    "text": "states you\u0027ve got a waiting State and you sort of broken things down a bit do you think that\u0027s something we should be trying to incorporate it to the taps a theory it\u0027s something I wanted to share I don\u0027t think it\u0027s an essential part from the perspective of taps as transport protocol agility but I think it is important as a overall concept of moving beyond sockets especially if we want to be affording for very mobile type of networks in which things are coming going yeah we should maybe think more about how we represent in interfaces and their availability in terms right and really just discuss too much it right Kairos Akamai is is there any hierarchy within the properties or they all so for instances there is there any encapsulation for the path elements it looks like they\u0027re all at the top level right so this is something that we look at it I think we will want to probably add hierarchy as things are defined within taps because I think hopefully we\u0027ll get to a better structure right now we\u0027ve tried to constrain the number of top-level parameters we have we do have them mainly they\u0027re around path selection and not protocol selection those ones are fairly top-level the things that we have done for specific protocol options we do have within a hierarchy they belong within the protocol stack and so those we believe are not going to conflict with the model in which we are actually racing between different protocols or being more flexible so I think protocol options right now have the hierarchy but there is a flat area and I think that\u0027s an area I want to see this evolve right because one thing that I one thing that I\u0027ve been thinking of a use case that might be helpful would be being able to race between two different MPLS hats right maybe I don\u0027t know whether that\u0027s in scope for taps or not but it would be an interesting use case so another one other minor NIT I think I\u0027d like the I think I\u0027d like pre connection better than endpoint just because the pre connection incorporates more than just the endpoint properties right includes a path and so I think to be clear the thing that we have is a pre connection I continue to be equivalent to the tuple of our endpoint and all of the other parameters associated with it so there definitely is a because it\u0027s not a clean mapping in that regard I parallel there\u0027s actually the first many questions I\u0027ll probably be bugging weekly with over time on sort of feeding your experience back into I like how you said yeah you were gonna move toward this burger not to remove anything I think that it\u0027s actually kind of and we want to be a superset I think that most implementations of the system should be a superset of what we specify right like we should be specifying something that is as sculpt as possible "
  },
  {
    "startTime": "01:48:39",
    "text": "to the stack agility stuff that were that we are shorter to do I think that you know when we can get cheap wins that also you know our stock modernity wins we should do them but but this is a stack agility first and stack modernity second idea I I heard one thing that I wanted to pick on though so you said that you did some testing with people using the API and they were scared of not having a stream is that it is that feedback to the taps working group or is that should be considered what I don\u0027t think so this is not actually feedback that we received from people adopting the API again whose mainly from like other people reviewing baby and I think they were concerned that a lack of the stream would put some people off but I think the time frame that we\u0027re working on here and the documents to back things up actually justify not really focusing on that [Music] Mia Kulemin are you supporting multipath and are you exposing any of that to the application yes yes so this these connections to support multipath is exposed as a as one of our few top-level protocol specific parameters there\u0027s a multipath service type in which you say you want no multipath you want handover Sal multipath or you want more interactive or bandwidth aggregating multipath giving there might be madam as quick at some point it would actually nice to have a transport independent interface that is it\u0027s a top-level thing so it doesn\u0027t imply MPT CP it is a multipath class are you supporting framers or have your plan how to support them currently no that is something we want to add thank you hello targets um I mean it so it came up with the interim that it would be good start working on policy within taps and in the knee project we did quite a lot work on policy is the the magic barber system and so he came over we should talk about it in the in the working group so we can get basis for the work that we did and just to refresh everyone\u0027s memories meat was a was an EU project they aim to build a single API to internet transport and support single sided deployment we built a call back driven system we had a policy system which I\u0027m just going to try and flesh out here we support multi sharing multipath and and pluggable security are our terms are different than from the taps terms and sort of all of this is from you contemporary with "
  },
  {
    "startTime": "01:51:39",
    "text": "the early taps work and definitely before they set taps documents we\u0027re doing and and so we talk about application requirements the applications signal meant a stack for the things they need and and then we work through and transfer protocols to try and this is one of the core parts of the end result and then we deal with with paths and um a lot of the the way we we dealt with paths was storing stuff per per interface and we also work them out through a source address and a destination address and then and then finally the result of our policy system is a list of candidates that are tried by another part of the system and so I talked about this quite a lot and early on it was it was fun to talk about the nee API because we could say you know knee is gonna give you selection and it we\u0027re really straightforward the application will say give me a reliable transport will await see and you will just get it and it\u0027ll be magic and and so we built an API that would would enable that and so the interface of the application was setting up the the properties that needed the things that required and then we had a logic layer and then we worked through our policy system that would would work through this and give you what you requested there and the best thing that you requested from the available set I\u0027d obviously this this didn\u0027t work there\u0027s there\u0027s a lot of complexity in here and so even the simple question you know give me a reliable transport on a low latency path turns into give me an acceptable reliable transport on a low latency path and actually no I wonder wait and see to be you know less than five milliseconds and you know I have some other conditions so I want you know the solana of network buffering and it needs to be high capacity and you can just force our way through this list and we can go on and on and on till we get it\u0027s a really fine grained point and and really a comprehensive method for this is just too hard to consider for Standardization there\u0027s too many too many pieces to this problem okay and so our policy system and as in the last slide the interface we designed was very simple for applications applications say what they need and then they they fire off the new system and the new system had a user API which was this interface and a set of logic for for building up the the imputes into the the policy manager which instruments policy system and then the policy manager were trying to set of candidates that the logic in the new system would try and this is where we\u0027re called contacts racing happens we call transport selection this is where we actually figure out what is going to work and then once we have what\u0027s going to work we can choose the the best one so the policy managers made of a couple of pieces and we had a flexible rules engine which allows you to allowed us to compare properties from the applications in in like fuzzy terms and because our interface was JSON thing could be misspelled and we would still match on these and we could figure out if things were in numeric fields and and "
  },
  {
    "startTime": "01:54:39",
    "text": "then that information is kick paired against two databases that we maintain as part of the policy manager so we had a policy information base which is sort of static information and a collective system for higher level policies and a characteristics information base which is information that we discover or our local network from connections which have succeeded from connections which have failed and so we can build up a historical database of what is probably going to work these information bases store mostly per interface but we did have a second level object for this and information on transfer protocols latency message size the whole set of all the properties you could you could want to compare against and actually a very good source of information would have been in the in the early PVD drafts they they tried to codify some of these transfer properties and when we implemented PVD integration we just pulled this properties in and we had a very nice mapping between the two okay so the the application sets of their request and they get sent to the the policy manager and and we had the ability to codify high level properties high level policy requirements at terminals very hard for us and so in application could say wanted low latency and the first step for the policy manager would be to expand what we meant by low latency into a concrete set properties and alongside that high level policy the application could also indicate some more specific stuff and so we use this to cull down the set which was in the the predefined larger request the the policy manager would then evaluate the information in in the SIB and we would generate a set of policy candidates and then we rank the candidates on some values of best we had a very confusing precedence score that either one was the best or two was the best and they went up or down and I can\u0027t remember and and then finally this this candidate list result is fed into the racing line selection system and so the important thing from the slide is that the API into the positive system comes from three directions it\u0027s the application requesting things it is the the logic layer which implements the transport dealing with this and forming more concrete tasks and then finally off to the off to the right we have an external system and the external system allowed us to integrate into rest-based endpoints and through this external interface we were able to do dynamic provisioning for Sdn and this external information interface is how we pulled in PVD stuff and this is really powerful part of the architecture we did so the project is has concluded and so we can actually have some solid lessons learned and the SIP is is actually a really "
  },
  {
    "startTime": "01:57:40",
    "text": "powerful part of this problem and it\u0027s really useful to build up a database of information and it\u0027s also an absolute nightmare the I think things change interfaces come and go our paths will change in the network you know SCTP not working to an endpoint now doesn\u0027t mean it as an end work in the future and we have to figure out what\u0027s going to work and we have to continually review this and and solutions here just depend on the context so being in an SDN environment gives you a very different network perspective than being in a mobile department and some stuff for taps we I think we need to capture the basic features of a policy system into our documents and but if it is really too difficult to have a big you know mapping of all features together I don\u0027t want to fill out our document with this because just nobody will read it and and the the high-level piece is actually something we can do we managed to have five high level policies that were in a system and I think by the end of going through some implementation experience we will have a set of what is high-level when applications really want and if the architecture is right then we can augment so protect that\u0027s me we got to Minister questions any questions Tony Polly um so a lot of this you were speaking in relatively past tense I guess kind of like the question that Aaron had earlier of like a are we gonna incorporate some of the tap stuff what\u0027s the future path for this implementation like as we because it already has a lot of the right building blocks easy going to also start being a place where we can incorporate these ideas and testing them in a different implementation and I mean it\u0027s it\u0027s open source it\u0027s all there and somebody would have to have there somebody so somebody would have to have the right incentives to work on this and it\u0027s not me okay no Kyle you can do neutrals yeah No yeah no okay uh hello I\u0027m telling the egg hunt and I\u0027m going to talk about the policy system of the sub attendance prototype which is joint work with Phillip now the focus of the socket intents prototype it\u0027s it\u0027s a research project and we are aiming to optimize application "
  },
  {
    "startTime": "02:00:40",
    "text": "performance on the host so the scenario is multiple permissible paths are available to the host and we want to figure out which of them we actually like better or which of them will actually help us optimize application performance and now we do this by basically selecting one of multiple available local network interfaces and for this in our policy we do a lot of heuristics like we estimate download time over different interfaces and that sort of gives us that gives us an idea of which of these interfaces works best so if we talk about a policy and socket intends it is basically a and implemented decision logic that gets several inputs such as the available local network interfaces and some characteristics for them I\u0027m going to go into detail about that in some next slides and then from the application there is a request to open a new connection for examples or some sort of request to communicate and the application also gives us the socket intense and this these are our inputs to the decision logic the policy and then the policy can rank in in tabs we call the rank in halves and in socket intents we call it well it selects the better of multiple interfaces and then it can also do some more things so first about the inputs and a little more detail socket intents or additional pieces of information that information that tell us what to optimize for so the application on some higher level what it once prefers or expects and we have already talked a little about like is more high-level inputs from the application so for example avoiding a costly interface which in which could be a better way to abstractly say I don\u0027t want to use LTE like right now because maybe who knows in the future what other types of interfaces we\u0027re gonna have or like what is going to be behavior so we are like we are opting for a more abstract way here to specify such properties and then also for example properties of the traffic hey I want to send a big file and how big is big well it\u0027s gonna be like an update for my operating system so it\u0027s a hundred megabyte or I already know that and then the socket intents policy can use this as input to the decision and then the other part that the policy gets as input or characteristics of the path which we mostly abstract per interface and basically in our prototype we gather some characteristics periodically by "
  },
  {
    "startTime": "02:03:41",
    "text": "observing the local traffic and then aggregate them which would be a similar thing possibly as some like characteristics information base which we have been the implementation draft and like sort of parallel to yeah but we don\u0027t like we don\u0027t store the exact same type of information but we do store some metrics of the paths and there\u0027s more details about this in the paper and a poster that I submitted to that we submit to a and your NR a and RW and there\u0027s the poster is downstairs if anybody is interested in the details and yeah here we reason a little about like how do we actually get those like per interface our TT values or bandwidth values or what does the current utilization which again helps us optimize and then the policy gets both the socket in and those when it gets the socket intense and to spell characteristics and then the application wants to for example open a new connection the policy can select a path via choosing the local network interface it can also as it resolves a name to an IP address and maybe it gets different IP addresses it can order them so it can like sort of impose a preference for a specific end point and then it can also set a socket option on the socket and what we also have what I\u0027m gonna talk a bit more in the next slide is the policy can know about oh there is already a connection open and it is not being in use right now so I can reuse a connection which is what we need for a message path selection so for example there are multiple requests being sent from the application and like it wants to get a response to each of these requests and then we we can choose the suitable interface not only for the entire connection for example for a TCP connection but we can also distribute different HTTP requests onto different network interfaces for example and so implementing this is not trivial for a screen based transfer protocols such as TCP what we do is we have a pool of open open connections basically open sockets and there can be like some TCP connections over the Wi-Fi some over the LTE and then the application just says hey I want a file transfer of 100 megabyte and then we give the application back one of those sockets and it could be the socket over Wi-Fi or the socket over LTE the application at this point doesn\u0027t have to know and then it can just use the socket and then say ok now I\u0027m releasing the socket back into the connection tool and this is how we like do this type of selection now yes this the general question like how "
  },
  {
    "startTime": "02:06:43",
    "text": "do we assign a message to a path if we had a multi streaming protocol that would be easier because at some point we are running out of TCP connections we have to open once which the policy also factors in but yeah multi-part quick for example would be really great in a prototype we actually also play a little bit TCP path managers but yeah I we think that selecting a path like for individual messages could also be an interesting thing and yeah as a some words about the implementation your sentence prototype is on github under this URL so people can play around with it it\u0027s still being developed and the amount access manager is a another component that is like not the API but it\u0027s a daemon running on the host and this is the the part that collects the path characteristics and it lost the policy as a module so again the policy is kind of implemented decision logic that gets some input and has some output and it can also be exchanged at runtime now in the future we want to explore more like possible performance benefits and which intends to actually give us the best performance and how much and then also another idea that we have is to formalize these socket intense policies more because now they are kind of like heuristics but we could also formalize them a little more to like maybe be able to reason about them differently using a domain-specific language and you can read a little more details in our draft which you can see on slides and yeah I think that\u0027s it for this presentation questions Cairo\u0027s Akamai I have a I have an implementation question about the about the stream socket reuse you go back to slides is that this seems to be implying something about the about the underlying sorry about the application layer protocol right so like this works with HTTP because it\u0027s stateless right it doesn\u0027t you know you the socket you could stay etc what are there are there you know like settings or whatnot in there that tell you whether the pool can be reused well we have in the API we basically have a knob that or we have a parameter we get back it tells us whether this is a new socket or whether we have seen the socket before and so we know whether we have to like set up a new state on the circuit for example encryption oh oh this is so this is not necessarily not necessarily reusing a connection it "
  },
  {
    "startTime": "02:09:43",
    "text": "could just be you open a bunch of connections in advance to make sure they\u0027re there right now these basically open a new connection if we don\u0027t have one that we like enough or otherwise after we have used one connection and it goes back to the pool because it\u0027s been freed then we can reuse this connection so we don\u0027t like open the connection can be reset or it\u0027s stateless hmm I\u0027m sorry but assuming the state of the connection can be reset stateless protocol hi Jed and I\u0027m from the floor yes I was waiting because we have this experiment this is kind of like what you guys are implementing and Neil you\u0027re talking about policy and I was hoping with somebody we\u0027ll talk about a policy that also have something called network policy in it so what does that means like we heard about like system policy from you stuck on system policy parameters and then you also have some policies that it\u0027s actually it\u0027s a system or application want to talk with your touch services but there\u0027s also called network policy because now it is the applications are creating a settings from the network saying lying on a particular network you might want to select to this stick to this path say you say like LT it\u0027s a light on LT network you might have something called zero rating zero rating that means you don\u0027t want to change because it doesn\u0027t really matter because talk about cost like cost be hot or costly interface so I was hoping some of you guys will be coming here and saying like yeah we also consider network policy as a input to our policy manager or something so you guys are thinking it\u0027s not discussion is not particular to you but anybody can sir I\u0027m sorry just so clarifying you mean that the network has a say in which interface I use right because this is 40 no space well later don\u0027t habits it has input to it so say for example say on a LT network mmm your alternator you find a new interface called Wi-Fi and obviously II really would still like LT is the costliest switchover to Wi-Fi but the LT network operator could actually have a agreement with the application saying like as long as you\u0027re on my network I don\u0027t cut your bucket the delicate so in this case you would like to have LT connection because that\u0027s more reliable than hmm sorry Tom Jones just responding and we we model this in neat with with the information you get from PVD PVD will tell you price per megabyte um and so we can use that as a selection criteria to figure out if this is the right network to use and the the PVD information carries of this is Wi-Fi or LTE so this could be "
  },
  {
    "startTime": "02:12:44",
    "text": "inferred properties from that we also get some information from the Wi-Fi access point about current channel utilization like yeah that\u0027s true I mean you can it can do all these things I mean I just hoping you have more explicitly have some information because P DVD you have a like and get a bucket kind of information but that\u0027s for your interface not for particular application you might actually have the same like a connection that has a different behavior for different application so we\u0027re over time so it\u0027s an interesting point but I don\u0027t think we\u0027re going to Sara Lee resolve it right here okay you should well then we\u0027ll take Tommy and Brian\u0027s question and maybe you can revisit this if we got some time like there is there is no meeting after this I don\u0027t know when things leave for the social but all right Tommy Polly so thank you for sharing this just one high-level comment this actually reminds me a lot of some of the layers that we saw our system built on top of us which are handling kind of HTTP loading and stuff the fact that you have a pool of connections the fact that you\u0027re determining which is the best to use between them so in a lot of ways I see this as potentially a layer on top of some of the stuff we\u0027re specifying here in taps big yeah I think as I\u0027ve expressed previously some of the vagueness of what the intense may mean especially if I need to know oh this is the number of bytes I have a priori what happens when that does not line up with exactly with what we\u0027re gonna have I think it is appropriate at a higher level how that translates down into a lower level is less clear one thing that was thinking of though because you\u0027re mentioning a multipath quick could be great and I I think when we look at things like multipath quick or even just my gradable quick and NP tcp things that can dynamically change what interface they\u0027re using that\u0027s an opportunity for the taps layer not to rely on an intent of saying I\u0027m about to send a lot of megabytes but to actually react to a real send such that maybe some higher level like what you\u0027re talking about here determines the initial configuration to use but once you actually schedule a send of a hundred megabytes that\u0027s a great opportunity for a my gradable connection using MB TCP or quick to actually react and use the same logic that you\u0027re talking about here but which is the best interface to select to dynamically so I\u0027d like to challenge you when we\u0027re applying some of these things to taps what are the ways in which this same logic can be done automatically based on the information already being communicated by what the application committed to in the send thank you brenell second thing Tommy actually a "
  },
  {
    "startTime": "02:15:44",
    "text": "lot of the stuff that he said which one the reason they came in after him I think one of the things that we need to do in the taps interface document is to make sure that systems like intense can right on top of them right like so that you can take these higher level goals without reaching all the way into the connection selection logic and changing sort of the rules of that I\u0027m not sure how to do that I think this might be the experimental RFC bit Saul had wants us to produce with a different hat on I would encourage you to take the interface and path measurement stuff and I know you\u0027ve already given a presentation to pan or G I I\u0027d like you to bring that to pan or I like to distill it down a little bit so this what yeah this path characteristics per interface will have to fix that but the the this is like sort of the first question that we have in energy I think would be answered by some of the research you\u0027ve already done um so yeah I know you\u0027ll be there on Friday but I think I would I would encourage you that question is going to come up and I would encourage you to stand up and say oh we\u0027ve already thought about that so Thanks last but not least oh yes all right so we\u0027re going to I\u0027m going to give a an update of the security of the security survey this document has undergone a bunch of a bunch of evolution since London the updates include improving protocol justification text and sorting protocols based on use and impact so there was some feedback at the end of the London session about well I think concern basically that we were either including too much stuff that was not maybe not appropriate or maybe not widely enough used to be relevant and also to make sure that we came up with some consistent standard for deciding which protocols to include we also spent a bunch of time canonicalizing the security feature set so that we would have some consistency between the protocols that are that were listed in the draft before it was kind of it was very ad-hoc it almost seemed like some text was copied and pasted from different places and not not standardized in some way that would that would allow someone to understand exactly why we chose one thing and not another and we also did a bunch of the interface cleanup whereby interface I mean the way the security protocols "
  },
  {
    "startTime": "02:18:45",
    "text": "interface with the transport protocols and other layers of the stack so these are this is just an example of some of the security features that we listed in the dock there\u0027s a much more exhaustive list of them in the dock I encourage you to take a look at it I\u0027m not going to read through all of these we did come out with five mandatory features for any taps protocol that requires security and these are segmented Datagram encryption and authentication seems obvious for security protocol for word secure key establishment this seems to be standard now so we\u0027re not going to accept anything less secure than that we\u0027re going to want public key raw or certificate based authentication so we need some way we need some way to authenticate endpoints and so that will feed into some of the protocol security protocol selection later on in the doc we need responder authentication which is what was Tommy do you remember what what exactly that means it\u0027s a term of art I\u0027ll look it up and mention it later but it\u0027s something I just forgot and then pre-care pre-shared key support yeah yeah are you confused that I mean there are a couple of protocols which support encryption without out indication or encryption yes no but if somebody so so for instance one of the I\u0027ll get into this a little bit later in the in the presentation but we have a in the list of optional features there\u0027s a essentially application level delegation of authentication all right this is what TCP crip does right it doesn\u0027t do authentication but it provides you with a channel binding where upon which you can do authentication at the application layer and so it for in most cases you\u0027re going to want to do some kind of authentication but whether you need to do it at the security protocol layer or a layer above is something that\u0027s up to the application does that make sense we\u0027re just providing a little bit of flexibility or maybe I will take more than ten minutes elect about authentication without encryption the Atari isn\u0027t it sorry like TCP was a colonial way yeah that\u0027s out of scope for this so this is the matrix that I was talking about so this is essentially a table of optional features and showing weather for each protocol whether that feature is supported "
  },
  {
    "startTime": "02:21:46",
    "text": "mandatory or unsupported and so you can use this table by by looking through the looking at the columns of the feature that you want finding which ones are either supported or mandatory and which are unsupported and then essentially taking the intersection of the two so in this case systems wanting to provide algorithm negotiation meaning some some sort of algorithmic agility and mutual authentication can support the protocols listed in blue because that\u0027s the intersection of of supported or required on both columns similarly for this for this example systems which must provide connection mobility and session casting management should only implement the protocols in blue so it\u0027s pretty straightforward so we got some informal feedback last time to remove protocol details that do not affect features or interfaces so there was a lot of text in the draft about features of the different security protocols that were not relevant to the choice to include or not include the protocol in the draft and we removed most of that because there are normative references for understanding the protocols themselves we just put in a very basic summation of the stuff that was relevant to taps we also found that trying to generalize security interfaces for all protocols is hard like this is not it\u0027s not an easy problem and we spent a lot of time trying to come up with a set of features that sort of made sense across the wide spectrum of security protocols that we were surveying so generic and protocol specific interfaces must be must be provided right we need some way of of separating out the security features that are relatively generic across protocols and then the security features that are specific to an individual protocol so there are some things that you\u0027re going to want to be able to configure for any security protocol that might be appropriate for your communication but then if you happen to choose a specific protocol if the tap system happens to choose a specific protocol you may want to sort of tweak the parameters of the specific security protocol that was chosen and so we have to find we have to provide some way of doing this finally going back to the earlier discussion where I said that I was going to be forced to support something that I was not entirely in agreement with this is that slide so it\u0027s this is saying the protocol equivalence must be based on name not feature availability and I\u0027m gonna sort of argue that there are two ways of looking at this and one is yeah we\u0027re not really chartered to do like to do in-depth security analysis to understand whether protocols are exactly equivalent or not but on the other hand if you\u0027re requiring let\u0027s say you\u0027re doing a race between multiple protocols and you\u0027re "
  },
  {
    "startTime": "02:24:46",
    "text": "requiring that the security protocol in the stack for each of those be exactly the same you\u0027re going to end up with less agility in in the the protocols like you that you\u0027re able to race between right if you can\u0027t consider TLS and TCP crypt with application level authentication to be mostly equivalent or to meet some minimum standard that is appropriate for your application you\u0027re gonna have a you\u0027re not going to be able to race multiple things you\u0027re basically going to you\u0027re going to imply a single protocol just by your configuration and I think we want to avoid that I don\u0027t think that was the intent either so I think we need to clarify this and come up with an actual set of criteria that will allow us to say race you know if we were going to cover G quick race G quick against you know HT HTTP I mean I monix I agree that you know security probe ones or whatever is probably way too hard for a v1 spec but I could certainly see something like an application saying okay any of you know G quick or TLS or DTLS are accessible for my purposes and I\u0027m just giving you a list of everything that\u0027s acceptable when all those could be raised right and I mean that\u0027s actually that\u0027s one of the things that I was thinking would resolve this so I yeah we\u0027re gonna once is HTTP to TLS over TCP and it\u0027s easy to live a quick which should should be counted as equivalent but then they\u0027re different right well it\u0027s not I mean so h2 over quick might not be the right way to phrase it yeah but like the Institute like layer that is you know yeah but but the the way they do the security is different but they should be comfortable if they\u0027re both dropping down sir TLS one country equivalents right right but it could you know as I said before right you know conceptually like they\u0027re theoretically there could be some side channel that\u0027s exposed in one and not in the other just because of the way they do framing or something like that right and I don\u0027t but I\u0027m not sure that that that\u0027s the level of control we need to provide the application I think that\u0027s getting way too far into the details so anyway so next steps are to formally circulate the draft in the security area to find out what they had to say about this and then finally getting back to the point that Aaron made in London maybe consider relocating some of the more obscure protocols into an appendix or into some other section questions I added the shadow it was the first time I was playing with keynote so um I was wondering whether it makes sense to move this security protocol equivalence to some higher layer like we discussed with some of the other properties before so "
  },
  {
    "startTime": "02:27:47",
    "text": "having a higher layer that\u0027sa specific Allah wants decent set of security protocols and saying okay that\u0027s out of scope what apps here we want to have the list of the ones that are reliable by name but perhaps moving this to a higher layer yeah so I think so there are two sides to this so the first is I\u0027m not going to specify anybody specifically but channeling some of the people in the security area you\u0027ll get the argument that that\u0027s a good idea partly because there is a minimum bar for security below which you must not go and then anything above that is kind of like icing on the cake and is sort of irrelevant like you know you don\u0027t want to go below like aes-128 right or something like that the other side of that though is that individual security protocols have their own little quirks that may make them more or less appropriate for certain use cases and so it\u0027s not clear that they\u0027re it may be that it\u0027s that it it really does matter what the application is doing as to whether a particular protocol is appropriate or not it seems to me that Tommy\u0027s proposal for generic properties and specific properties that earlier could be sort of bent in such a way that it would allow us to sort of you know have both kinds of equivalence class we\u0027ll just make sure that yeah right having an option that you add 40 LS yeah is you know and like some new vertical comes along and you meant to have a padding option associated that but it was a protocol specifically a no-no so specifically I actually want to take the concept and bend it a little bit so that you actually do like you would have essentially a selection scope in which naming is is how you do it then there\u0027s election scope in which equivalence class where you basically have sort of a security or equivalence class where it\u0027s like everything that is at least good enough to not get you yelled out and sag goes into an equivalence class right that is going to expand over time right yeah yeah so whatever framework we come up with has to make sure that it works with applications that are written today and wait it will expand over time and then occasionally in fits and starts over time it will things will get shed right this is how we do it right now all right like so 20 years ago we thought TLS 100 is fun you no longer have to specify export no rate exactly yeah exactly but I mean like so the set of things that go into that sort of that big you know I don\u0027t care class um that\u0027s the security areas job to do and I actually already publish recommendations there and we can just follow them right okay any other questions tell me I have a question for the chairs about what do we want to do with the schedule for this document based on the milestones um III "
  },
  {
    "startTime": "02:30:50",
    "text": "think someone\u0027s separate about here about equivalence that that\u0027s actually not this document right that\u0027s the architecture and other stuff this is just survey I think the main thing that we need to do is get the formal feedback because we\u0027ve we\u0027ve talked to echo and other people about this but we need like their formal review what do you see as the next steps here I think I think the form we will learn a lot in the formal review about how much more work is required modulo that are we sort of in the fine-tuning stage is this would we if they came back with an old response which you say this documents ready for working class call now by the time they get back to us I think it would be yeah I think it\u0027s close so I think maybe that\u0027s we should do we should we should take it to SEC dispatch or whatever the appropriate way is to get their review on it and and continue to work in parallel on fine too bad those meetings didn\u0027t occur in the other order yeah you know we didn\u0027t know we were ready I mean it doesn\u0027t happen the reviews not gonna happen in the meeting a question I have it but you and Chris feel like you can take it to a sec dispatch that do you want the chairs to be involved in that oops I don\u0027t see that it\u0027s a great idea yeah I think it\u0027s - if you say there\u0027s a chair you can just click a button and because the safety review really you show me what the button is I\u0027m a Muslim I had a question on this is it yes the survey or this should also kind of incorporate the main set part of things or sorry what do you mean so for the protocol side we have the survey face right and then the min set step so that the analysis was kind of in two steps and I was not sure for the security protocol side if this is supposed to cover both of those starts or that\u0027s having an interesting framing I didn\u0027t think about it that way yeah well what we basically tried to do was take a candidate set of protocols and then sort of distill out what the what the the common properties were and or properties that were commonly found in protocols and then choose the ones I think to some extent we were relying on our on our experience with with other with with the security area to know which word the minimum set "
  },
  {
    "startTime": "02:33:50",
    "text": "of things that were required for security protocol so maybe that was implicit so I\u0027m not entirely sure how to answer your question okay but so in some sense the equivalence class could be was a I mean in some sense it\u0027s in your tables right I mean like what you are showing right well there\u0027s there\u0027s interesting interesting features somebody might want to use but are not mandatory or not kind of that the the low bar for what is required when you call something secure right I mean you know we\u0027re not going to support like rot13 even if somebody really wants that so you\u0027re 10 minutes on is it 20 minutes now and you have one more question so we give Michael the last question and then that things up Michael you\u0027re on the enemy this is not really a question I\u0027m just trying to answer actually I think having read the document I think this is a min set type document I mean it\u0027s pretty similar in style and what I try to do in the document and I don\u0027t know if you could say it skips the service that bit probably doesn\u0027t it\u0027s probably rolling balls into what I think type thing I mean trying to do the same thing in same style do do either of you have had recommendations on how to improve the document I would be interested in hearing that I\u0027m sure all so well I mean I don\u0027t want to answer it now right I mean you know if it\u0027s an email to sorry I I wrote some in my comments to the list and I was happy with your response to that and you know how you addressed them okay thank you Michael so just a confirm cut you want to read the document again now before we send it who for a second security review almost certainly okay so some no to list when that\u0027s ready and then I will now I know where the button is okay all right sounds good thanks all right thanks everybody see you in Bangkok oh we\u0027re gonna schedule a virtual interim probably in September since that\u0027s about halfway between there when is trammel 2.1 expected to be deployed okay so September would work for that I just want at least know the month the other blue sheet somewhere you may see what the other blue sheets are thank you "
  }
]