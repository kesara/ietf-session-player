[
  {
    "startTime": "00:00:09",
    "text": "welcome to the ietf 112 netmod session i'm blue burger here with my co-chair kent watson we also have a third co-chair who i think may be trying to join the material for that we'll be going over today is all uploaded on data tracker and we are using the note taking tool which today i think is called uh hedge doc it'll change tomorrow but we're using the note taker tool the link is here it's also in the chat session we ask everyone to please jump on and help us capture everything that's said during discussion time we don't have to capture [Music] what the presenter saying that's on the slides excuse me um we're well into the ietf this week so i think folks will be fairly familiar with our notewell we have a set of documents and pcps that govern how we uh interact how we operate that covers both technology disclosures patents ipr as well as code of conduct please keep in mind that everything we say and do here becomes part of our public record we are uh recording this session and though this session will be made available uh via youtube as well as other ietf memes one of these pcps is our conduct guidelines it's bcp54 we've been asked by our leadership to highlight this and you know that this has always been there uh bcp54 but there's been some recent discussions and we think it's uh we think they think it's very important to"
  },
  {
    "startTime": "00:02:00",
    "text": "ensure that we keep our um interactions very respectful and courteous and collegiate and even if we're having heated discussions which is also just fine to have discussions which you are maybe a little passionate about but please keep it technical and uh always respectful uh we're using medeco if you are listening you you found us and as i mentioned we're going to make a video recording of this so you might be seeing this on video the note taking we've mentioned before it's the collaborative uh i've seen uh one person join since i asked others to join we have please take a look and click on the chat button go to the top and click on the um the note taking page and and help us capture the discussion it's really important that we um capture actions and and the good discussion just quickly add um also the link at the very top of the meat echo window the fourth icon from the left on the in the top uh right corner is taking the notetaker tool as well thank you and that was kent for those of you that don't know the agenda is basically as published we've had some i think we had a speaker update and some versions update uh but the the agenda is largely unchanged again all the material is posted we think this session is going to run so tight that we're not going to get to the last slot this slot is actually coming to us from a c camp document and i think the main question really there was which working group does this belong in and generally we follow the the practice in net mod as if there is another working group that has expertise on the material being covered"
  },
  {
    "startTime": "00:04:00",
    "text": "uh by the model it should be done in that working group so we would expect this to continue and see this work to continue in c camp um as uh as is indicated by the draft name we have not had any rfcs published since the last time we met but we do have some items in the rfc editor queue i don't think there was anything particularly noteworthy there to talk about i'll defer to kent if he wants to jump in with anything but i don't think there was anything really noteworthy there um the post-last call documents we have a couple that are expired the authors are have committed to doing that update so these aren't dead even though they're expired so we'll keep an eye on that we do have one document that was returned to the working group um basically there was some uh alignment necessary to reference documents the action for that sits with the authors and we really are hoping that the authors um uh take initiative there uh if they don't if there's others who wish to help out i would suggest that they contact the authors as well as cc the netmod chairs and we can we can discuss that we have several uh documents not on the agenda um no tags has hasn't been modified in a while there has been an update on the list a couple of times uh so we're really looking um for an update there the next one the the uh we there was some recent good discussion about whether to take that to um last call as is or wait for addition additional changes uh we we think that it would be um fine to move this forward if there isn't something immediate that would that had been identified by the working group that should be added so please take a look at this document if you think you"
  },
  {
    "startTime": "00:06:01",
    "text": "have something you want to add to it please propose it on the list if we don't see anything probably sometime in december we'll take it to last call versioning requirements uh that document is pretty well uh complete we're just waiting for the other versioning work to it to advance it we haven't had any recent incoming or outgoing liaisons proposed if you think you have one that is important please let us know um and the best way to do that is on the list um yeah that's sort of the first point here is utilize the list that's where we do consensus these discussions are good the interims are good they're very important for helping us make progress but decision making happens on on the list this is particularly important when you have it to keep in mind when you have an active set of authors that are actively discussing changes um they may to agree to a set of changes but if it's a working group document the acceptance of those changes is governed by the working group not the authors so those that it's great to have that progress but the this the discussion has to be reflected on the list then we have to get buy-in from the working group there we continue to support and offer um informal meetings that we can that the chairs can support uh that through scheduling working group web access we also can have virtual interims like we did uh last month and all that takes again is a request to the uh authors um uh or sorry request from uh to the the chairs with that we're going to move to the next presentation i believe that's bellage bellage up on the top there should be a share preloaded slide button if you could click that you should be able to find"
  },
  {
    "startTime": "00:08:01",
    "text": "your shot your slides and present okay i think you were down at the bottom listed as zero two i don't know we can't reorder but their number they are numbered if my screen says a new deck is being shared but i don't but there it is here we go great thank you okay uh we see it let's go so hello everyone i'm speaking on behalf of the active authors of the network network versioning group on the versioning agenda i will present a short overview of what we are doing and then we put more time for into what's happening into yank packages we are still having weekly meetings and which are open to everyone they are quite a good participation for multiple companies and if you are interested then yeah you are also welcome what we are doing these days is we have the first two drafts the module versioning and the yanks amber drafts we try to finish that and push them to work group last call so and then we are beside this we are also working on the package drafts or package draft there are a number of open issues we have an issue tracker on the idea website we are trying to close that and re solve all the issues"
  },
  {
    "startTime": "00:10:01",
    "text": "so what updates we have been doing we had are at dash 05 at this point that was released last days for the module versioning basically it's editorial updates and adding a few small statements correcting uh some of the examples and that not nothing new major com functional happened here for the stemware this which defines our versioning labeling method we have a bit more work we had the full reviews by the authors corrected everything we found we defined how this is usable for sub modules text previously referred to modules we've changed the prefix to make it shorter and and unique uh in the in our yang module and then there were a number of editorial changes yeah for sub modules the basic statement is that they can this they can be versioned using yank semantic versioning if you change the the sub module and you change the semantic versioning of the sub module then you also have to change the modules semantic version similar as what we have with revision information dates so if you change the sub module then that means the module is also changed next steps what we are still working on we have the tracker for the first two modules module versioning and some um"
  },
  {
    "startTime": "00:12:00",
    "text": "semantic versioning the issues are closed we believe we found a solution for every of those issues and the authors believe that these two first drafts are ready for work group last call so we call on the chairs to decide please and we are focusing on the packages draft without the all the number of issues and number of people are contributing text and we'll have a bit more uh presentation on what is happening there and with that i'm open to questions or i would hand over to my colleagues to speak about what's happening in packages not a question but comment um just as a recap the uh the plan for the working group is that we will take these first few drafts to working group last call but then the chairs will hold them within the working group until the entire set all five drafts are last called and at which point we'll take them uh to iesg yes and besides the meeting as the chair said we we try to get all uh issues also to the mailing list and we i hope we did it correctly i see that beau has a question or a comment go ahead bill oh i i don't have uh comments on this i'm just preparing for the next i think she's just the next speaker well with that maybe move on to the next presentation thank you but are you able to share your own slides"
  },
  {
    "startTime": "00:14:01",
    "text": "i'm trying okay yeah i see a new dash here we go can you see but right now same size yeah it's good uh hello everyone this is bohu and uh as just lash mentioned i'm going to present young packages dropped status on behalf of all the authors and and the versioning netmode versioning team uh uh since last revision uh we we don't do very uh major uh changes but we uh we tried to uh remove the package uh check some definition since uh mod module versioning draft has uh removed all the module versioning module checksum and packages draft needs to keep consistent with all these checksum issues so that's the only changes we we do to this uh revision uh regarding all the other uh open issues right now um we still have uh 20 open issues and blush also mentioned that all these issues mostly issues has been assigned owners so the contributors and working on that and to move it forward and here uh we list the three issues uh we are"
  },
  {
    "startTime": "00:16:00",
    "text": "in that we are under discussion in the weekly meeting and i'll i uh took it each on this and about uh issue 65 uh this is a quite typical one that uh in in the open issues that we need to refine the text and since young versioning drops has been stable and so this draft need to be made the changes this one is the previous version young packages uh definition just use uh same word label but uh we don't have a samurai label scheme so in in so right now we are uh blasha working on this and to uh to to proposal text on it and about uh some new function of these young packages is scheme amount right now uh in in this revision young packages doesn't define uh schema amount uh functions um so the question is the authors think the packages can contain modules with module points so packages can give some constraints on the mount point so for example uh for itf uh basic package it means mount layer 2 vpn or layer 3 vpn packages"
  },
  {
    "startTime": "00:18:02",
    "text": "so uh for young packages then in the on the mod points we can list some constraints whether maybe only their three vpn needs uh is allowable uh package so to this uh issue with we think we will update to include the mount point information and define some constraints for mounted schema here we list some rules on this like uh some package package x can constraints the uh instance of one point to con to restrict only layers two vpn earlier 3 vpn to be mounted and schema months listed in packet is can be override of months in the included package and the rule number three will be a list of allowable packages must include all allowable packages from included packages these rules are initial text we are proposing to add to young packages in the next revision and one major issue is that uh right now young packages also define a model list but jan proposed this issue that he he has some concerns on uh"
  },
  {
    "startTime": "00:20:02",
    "text": "there are already four mechanism standardized by ietf they are hello message net conf monitoring young library uh seventy nine fifty um mandates in uh one one one dot one is that young library is mandatory and [Music] so module list is already there and also we have uh 883 42 mmda young library so young package will be the fifth mechanism to list the set of modules and so right now yen is working on this to try to propose some way to remove this duplication so right now the team are working on this issue but we need to further discuss in the weekly meeting and then when it when the authors think it's ready then we'll bring back to the working group for further discussion so that's almost uh the status and progress we made and and also the k issues so next step they als the team are working on the open issues and try to move make more progress on this so that's the end of my presentation thanks any questions and comments"
  },
  {
    "startTime": "00:22:06",
    "text": "uh thank you for the hard work and progress update as a reminder to the working group uh anyone is welcome to participate in it it's a working group activity it's not an author's activity um so it's open to all um and uh if you could just um uh try to re-post or post what you think weekly uh issues that are going to be discussed um that'll help to identify help people to identify when they should show up to these meetings um it's it's a request it's not a you know if you don't do it we can live with it but it'd be nice just to give warning of what issues um you're going to talk to talk about each week just so that if someone's interested in a particular issue they can show uh thank you for the the work and also uh thank you both for uh ending early and keeping us on schedule indeed thank you and next presentation is coupon and if you're able to share your own slides that'd be wonderful can you see my slides yes okay so hello everyone this is chufong on behalf of the authors and contributors i would like to give a presentation about system defined configuration as you can see it's a zero zero volume draft but not really a new work actually it has already been presented in netcaf and neta mode working groups for two times and in last itf meeting it inspired a lot of good discussion so thank you jason blash rob and kent"
  },
  {
    "startTime": "00:24:02",
    "text": "for your valuable comments and also there was a lot of discussion on the mailing list it's more than a 14 number a 40 number of messages and about one month ago a two hour network intern meeting was held on this work it's about 15 participants and i believe that we have reached a lot of agreement with the objectives scope and solution on this work so a new draft has been proposed to document the outcome in the internal meeting so the authors tried to rewrite the previous confidence system dropped and resubmitted as a nato model individual draft based on chair suggestion so yeah so regarding the motivation and goal there are four points which are actually aligned with the objectives discussed in the internal meeting if you can still remember that the visibility means that we want to enable a server to better document the system configuration and convenient because it is often the cases that the client want to the clients want to reference a system configuration which is not visible in running and we want to avoid at least reduce heaven to copy the entire contents of system configuration into running when possible configurable is a capability of capability of being configured there may be a desire for clients to configure descending nodes of system defined configuration and last one is the client control we want the client to have control over"
  },
  {
    "startTime": "00:26:00",
    "text": "the configuration which means a read back of running should contain only what was explicitly set by the clients and it was as it was discussed during the intro meeting the complete solutions consists of two parts there is a mandatory with system parameter which is used to retrieve running and system configuration combined currently this parameter is defined as an empty type but we can discuss whether enumerated values are needed for example to control whether to return all the system configuration or online system configuration which are referenced and both netcast get and get config operation and the rest of get and head methods are updated to support this parameter and the second part is that we can also have an option system data store which is read only for clients but its content may change dynamically and our intention is to have no impact to operational that is to say those present in operation always equal system will still be as obvious this work doesn't change that behavior and system defines those are non-deletable but we do have some system configuration which are modifiable a client could define a new value in running which will overwrite that in system and it may also be possible for a client to configure a descendant node of system defined list entry and the mod results will flow into intended so system may be overwritten or extended by running to create intended"
  },
  {
    "startTime": "00:28:00",
    "text": "so here gives a simple example of configuring a descended node of a system defined node in this example suppose system provides a loopback interface configuration with a name and two ip addresses and step step one and step to show that the configuration what the configuration looks like in system and operational respectively and in step three the client tries to configure a description node which is a descendant node of system defined interface list node and after that the configuration of loopback 0 shown in operational includes the name description and two ip addresses and the original value of those explicitly configured in running is intended otherwise it equals system i saw jason in the queue so do you like to would like to say something about this go ahead jason jason uh do you find that they should just continue jason might be having issues with his microphone yeah okay so uh yeah i can't hear you let me uh apologies i i unmuted my own mic but not in meat echo are you guys hearing me yeah okay i guess my question was about step four um and maybe this is still uh a point we're debating in the draft but would the origin there not be running instead of intended"
  },
  {
    "startTime": "00:30:01",
    "text": "i believe that there is no running a value named running in origin is only intended which means flow from running data store okay okay i may be misremembering the the nmda uh origin then okay thanks so there are some open issues some of them may have already been discussed during the interim and others may not first there is a very fundamental question whether we want running osp valid i know that both 7950 and 8342 define that running must always be a valid configuration that tree and i also know that there may be a concern that if we allow running to be invalid then comes the issue of backward compatibility the offline validation for legacy client will break unless all the reference system configuration is copied into running but there is also another view that if we allow the reference system object not in running for then for offline for online validation the server can just accept the system configuration that the validation passes and for offline validation there are three ways first one is that the client can offline merge running into system but it necessary client to be able to access system data store is easily achieved four mda clients bundle solution for non-mdia clients the second way is that clients explicitly copy and paste reference system configuration into running and we know that copy and paste must already be"
  },
  {
    "startTime": "00:32:00",
    "text": "done when configuring descended nodes as i mentioned before the client wants to configure a description node for a loopback the interface this node with a key name is indeed is needed to copy and paste but the question is must it be done for leaf reference 2 and the last way is that the clients use always system parameter to get a module view and then validate against that merged view but it's debatable that if it's a real a really offline validation because the server must be online to respond that request and there are other open issues something like should we define an immutable flag which is used to indicate to the clients which system configuration is read only or which is not the server will return an error if the clients attempt to configure a value for a read-only system configuration but what if configuring one with the same value as found in system is more like a copy and passed in this case but should we allow it and whether it's sufficient for this immutable flag to be carried only when the the clients retrieve running with system parameter the the next issue is that should with with origin parameter be supported for intended the server must remember whether a specific data node intended comes from system or running but my question is should we expose this origin information to the clients and should the origin ecosystem be required for system"
  },
  {
    "startTime": "00:34:00",
    "text": "configuration copied and tested into running currently it's more like a explicit with default basic mode and in default data nodes explicitly set by a client will no longer be treated as a default data even with a same value but always already equal to intended seems more like and overwrite rather than copy and paste yeah go ahead jason please hi guys uh just making sure you're hearing me again hello thank you jason you'll see that the mic goes up and down don't wait for acknowledgement please okay um so the um for the last bullet here um i i would i'd propose that if if uh if like an interface has been defined purely by system then the origin should say system but if if the user or client has explicitly declared that interface in the running config then i think that should be reflected as a different origin somehow so either intended or or some other whatever the same origin is for explicitly defined config to show that that's been kind of you know explicitly entered into the running configuration and because we're kind of taking the stance that overrides and takes precedence over um the system configuration and that my second um comment which is kind of related to the origin is um i mentioned i guess i asked earlier in the example where the origin should be shown as intended um i checked nmda and you're right it"
  },
  {
    "startTime": "00:36:00",
    "text": "doesn't seem to be a running but there's going to be a little bit of confusion i think because system merges into intended so when we give an origin of intended um it's it could it could be a little ambiguous as to whether that actually came from system or from running i mean i know we have an origin of system but we may want to have some more discussion about about those origins hi this is kent as a contributor oh i'm sorry yeah go ahead please yeah you can't go ahead uh yeah thank you yeah i just want to respond to um jason's comment actually both comments um so the um for the origin equal system uh when when copy pasted into running i think the idea is that uh you know all the ancestor nodes uh or really everything that got copied would initially have the origin equal system but then if descendant nodes were being configured then those would be the ones that would um have the origin equals intended and then but then to your second point and actually the middle bullet point on this slide i think the intention there is whether or not this work should introduce to the intended data store like with the operational data store inability to uh you know when you get the configuration from intended you could actually specify a with with origin parameter that would then annotate those values so that even when you're getting from intended it would be visible as to whether or not those values came from system or from running uh currently of course that's not a bill that nmda didn't allow for that it only allowed for the with origin to the operational data store"
  },
  {
    "startTime": "00:38:02",
    "text": "that's all yeah the the server must remember whether uh a data node intended it comes from system or from running so so that you can make sure that this it will have no impact to operational those those will previously present in operational with origin ecosystem will still ecosystem and so that but this question is should we define this already information to the clients so that can retrieve from intended so the third bullet for us a very common use case is that people do a show all configuration store it somewhere and then replace the full configuration back now in the such case you need the origin equal system markings to be able to say that yes but the origin marked nodes i don't we don't have to push back if we would lose that because it's not there anymore then we try to override them and that leads to problems so yes for the bullet definitely thank you yeah okay thank you go ahead jason um i guess responding both to to kent and abelash um so balash if if someone um does a read back from intended or operational and they have not explicitly declared system configuration in the running then it would it would report those system configuration items as origin system"
  },
  {
    "startTime": "00:40:00",
    "text": "i'm only advocating that if an operator explicitly declares system configuration themselves in the running that it should be considered with an origin the same as any other config that the client does in running i think it would be odd that you could read the running uh see certain statements in there then you read uh operational and some of the statements from running have a different origin than other statements in running so i'm i'm still of the opinion that anything you kind of um anything you declare and running that overrides system in my opinion that that is considered just like any other client config and would should be reported as that as that origin um when when a client declares something in the running in order to make offline validation work they don't have to copy the entire object and all its descendant leafs they just have to copy basically the the list entry and its key to resolve the leaf ref to make it opera to make it valid all the rest of the descendant nodes in that object for example that interface could stay declared by system they don't have to be copied into running go ahead john thank you yeah my main concern here is that uh we are redefining 7950 and 83 42 and in a sort of highly incompatible way and i'm not very favorable with that but i agree very much with the intents of this work i think system config is important that we can do things there but maybe we should try to reverse the the flags like with system should maybe"
  },
  {
    "startTime": "00:42:02",
    "text": "perhaps be without system instead so that if you don't specify any flag everything works as normal and then if you're if your client is capable of seeing things that are well sort of leaf threats pointing to things that don't exist in running and then you specify this without system and then you can deal with that so i just want everything to work as normal as long as you don't specify anything special contributor so first i think actually the width system gives you the normal behavior by default but we should double check that um to jason's point uh the comment of the in parenthesis at the bottom of that previous slide is said much like the default flag in um the with defaults rfc in the sense that uh for those servers that had the explicit mode um you know the default flag is there so that the server can know for sure that like the client was configuring back into running the default value if the client negated or neglected to specify the default annotation then the server would say oh even though this value is the same value as the default the server is explicitly configuring it so that exact same behavior i think is what we'd want to carry over into this system uh idea um [Music] maybe we need to have something like um system modes if there's you know with default modes maybe there's like with system modes and so the server can advertise its behavior in that regard uh and then sorry my second point is is that uh actually i think uh the first open issue which is the on screen now is probably the more important one to be focusing on is the extent of backwards compatibility uh and right now i think this work is teetering on needing something like yang next or neck of next rest comp next would you know do or or if you know we could structure in one way that it doesn't uh you know because it could be"
  },
  {
    "startTime": "00:44:02",
    "text": "that's not aware of the ability to process system information will be suddenly very surprised if it you know does i get um on running and it and some extra annotations appear uh such as the origin equal system uh by default um they may not know how to process that so i i guess we just have to work through that detail yeah and we'll have to take more discussion at least on this on to the list if you could wrap up your presentation so that we have time for the next slot please yeah there is i i believe uh we have already discussed the issues all and i have already wrapped up i'm happy to ship the issues to the list yeah yes please uh really good discussion i'd like to continue if we get enough intensity and interest we can always hold a uh another interim and with that uh moving on okay thank you uh oscar can you uh there you go and let me see ah sure yeah that's good thank you continue oh okay i hope that you can hear me good so thank you very much for giving us the opportunity to present this this work on the extensions of the acls okay so here we are on behalf of my co-authors also from from telefonica and from i'm from orange so the the idea the idea of the or the motivation of this draft is that we took as a starting point the acl young model that is defined in"
  },
  {
    "startTime": "00:46:00",
    "text": "net mode precisely in 8519 and that that young model targets the configuration of the forwarding behavior in a device okay so you can create this these filters okay so this model you can create the entries so this acas the matches and the actions okay so to that point everything so good so far and we have been doing some work internally in the in both in telephonic and audience compiling the operational experiences of of the use of the of the acls in the deployments and trying to see if we can do everything using this this young model and we have documented here in the in the trap that we are presenting a set of improvements that that we think are necessary to the acl model okay and what we would like today as we'll see at the end is to discuss with you the approach of doing those those extensions so the current young module defined in the in rfc8519 is prepared it's already prepared to have some augmentations okay so it's been prepared to be to be extended however because of its design there are set of limitations that it makes it complicated to do all the improvements via augmentation okay so in order to do some of the improvements we will need to do some redefinition of the of some things so here is the the list of the or the functional of this this enhancement and functional gaps uh and classified by what is the the problematic that we have that we have found and they are documented in the draft so on the one hand some that lead to some sub-optimal configuration so one of them is the lack of manipulating a list of practices okay so typically you need to you can only do one prefix at a time in"
  },
  {
    "startTime": "00:48:02",
    "text": "one entry okay so you will have to duplicate many entries to create that for manageability also you cannot create or define aliases or or sets for example as we will see prefix is a very common functionality that we that we require and then functional wise um we lack uh the handling fragments of ip4 so we can discard for example a fragments okay also the the handling of tcp flux is sub-optimal for example it does not support all the matching uh as for example it is uh supported in pdb flow spec okay so will see that we could for some do some bit some mask to be able to filter several several deflects also in in the actions and right now you can accept and discard or either silently or or not but for example you could also have rate limited actions also you could perform a payload based base filtering also separately the couple from this functionality of them of the model the current model is a device model okay so it's intended that you have a device that has them that you program there the acl but we can also use it at a network level okay to manage the the acls in a network for example if you want to and to configure the the perimeter security of the network and you to manage all the filters in a in a central way so then you would require also to extend the model to be able to to use it in a network and maybe bind the say which hcl applies to uh to a device okay and also you could be able to reuse the acr and"
  },
  {
    "startTime": "00:50:00",
    "text": "the content of the acl for some template or the sets across regular devices for example the prefix list that you do that you define is a previous list you can you can use a multiple device and you can define it once at network level and being able to apply it in several devices okay so we'll go which is of the the problem so the first one uh that we mentioned is the the not that we currently don't have a possibility to work with list of prefixes okay so so now you can only say which is the destination ipv4 or the next image ipv6 or the source and ipv4 or ipv6 however uh when we didn't want to for example mitigate detours attacks we need to provide a big list of addresses and even if we didn't want to do the combination of sources and destinations even if it makes a worse the problem multiplies okay so then if we want to create those rules today we wouldn't require a and multiplied by m entries okay so instead of creating a single a single entry okay so this is how with the old one just to create the destination and source in into separate entries and you could combine them in a in a single one just by allowing changing this to to allow a list also the um how we've seen that operators work is typically the network operators maintain a prefix list okay to to use initials okay and also it is very common that the department that is manipulating this project is a separate department so it's typically a security department or in the case of business customer even is the it can be the part of the business department that maintains their own list of officers so typically"
  },
  {
    "startTime": "00:52:01",
    "text": "people like to maintain one list okay with some naming and all the addresses addresses there so that the management is separate okay so so we think it's it's good to be able to have those those in those lists okay so for example the the rooting policies already have the notion of sets and particularly the prefix sets in that case it's prefix range sets even they call it a prefix sets so and also we can generalize this concept also to have aliases or define sets okay so we can have these reusable definitions that you can use across multiple acls and you can have for example these prefix the specific sets of prefix list where you have all these ipv4 or ipv6 prefixes the protocol says or port number sets you defined as in the the set of the set of ports to reuse or even icm icmp sets what you can filter the type or or or the code and you can have them already pretty fine and reduce them uh also another another thing that we that mentioned is the the handling of of lux so even the acl is applied locally it is typical sometimes it's triggered by biodirectors for example the video flow as i mentioned before is one of the one of the possibilities and the we cannot easily map all the all the filtering rules and in particular one of the things that we we cannot do is the correlates handling all the tcp flags in the in the current draft you can have um select one flag today or one one one one bit of the tcp flag but you for example cannot create a mask too much of a serial tcp tcp flux okay so what i what i wanted to ask the working world today"
  },
  {
    "startTime": "00:54:00",
    "text": "is several questions first of all i mean these are the we are willing to work on on the extensions necessary to to fill this discuss but we need some guidance from the working group especially that the starting point is an existing rfc okay so so what are the so we want to ask the working group what is the best suggestion to approach the enhancements so either we have an a new version of the acl model so just version whatever or not fcbs or whatever way we can minimize the number of compatible changes there there will be some number there will be some changes that break existing structure but minimizing them either we could uh augment um the existing ninja module not touch everything that is there but only if we need to add things we have everything on on top in some cases it will mean having two structure a little bit similar but with more capabilities and also for sure open to 20 quests and to open two opinions here and also the the differentiation between the network model and the device model is okay do we create a separate module for the network module because we might need one like that is extending for example the itf network and then we plug there the the sets and the and the acl templates on top of it and if we go for that having a separate module for the network-wide module of acls and sets is that module to be work also here in net mode or everywhere so here any feedback from"
  },
  {
    "startTime": "00:56:01",
    "text": "feedback on this is appreciated so thank you so jason's in queue um yeah i guess just about how to approach the work um it might need more discussion on the mailing list to see how the scope of the work evolves and how much functionality is being added and how backwards compatible it is but um you might my initial gut is it would probably be a a separate rfc that augments um you know with with extended uh extra functionality um just as a as a as a first cut from what i'm seeing from this um about the network versus device model i guess i had a question when you say device uh like a so there's per interface acls and then you have this kind of device or network acl is the intention that that's that's an acl that is effectively applied to traffic coming in on any interface the second question of the network no the idea is to be able to uh manage uh acls that or or sets or prefix lists that are used in several devices okay so that you can have uh for example a template an acl template and that acl template if you want to replicate it in several devices okay from uh for example from a controller that you can that you can reuse it easily so it's something to facilitate the management of hcls and prefix lists from a central location for example especially for the prefix list then you talk on that they if you define in the operator you define some deny list for some service this is independent on the device that"
  },
  {
    "startTime": "00:58:00",
    "text": "you are your running needs so you will define it once uh and then you will say okay this applies in this device this device and this device okay from a controller perspective then you will download the specific configuration to the device but the network model is uh when it's referred to network is that applies to several devices okay that was the and to be able to help in managing several devices at the same time okay it looks like jason doesn't have anything more there uh so in general uh it's a judgment call of whether you augment or revise right and uh you really have to get into some of the details to figure that out um and then when we start getting into the details we'll also figure out what the details are of device relative to network and if there's a existing model you're augmenting all of those getting to those details will help you answer the questions on your slide right now you just have you know an empty section so it's a little hard to evaluate or give you a definitive answer but you know as a general rule if you can uh it's a judgment call but if you can augment um and you're adding optional capability augment is the way to as a separate rfc is definitely the way to go if you are looking for um revising the core behavior that everyone needs to adhere to then you definitely want to rev you know do abyss or a placement mod model so i i think we need to get to the details and uh the the motivation that you've given here is just right for the presentation i think for the draft rather than focus on motivation focus on what you're actually going to do so focus on the new capabilities you're defining in the draft describe them and then throw out some proposals some details and then we can really jump into asking this question so you know from i uh i i don't think you know we haven't"
  },
  {
    "startTime": "01:00:00",
    "text": "heard anyone jump in and say you know this is completely wrong down what we've heard is is uh you know um looking at uh you know the best way to do it but again having details will help us understand help the working group judge whether it's something that they want to a support and b what's the best best mechanism to implement it okay so we can update the draft with uh with a we can go in the we can propose in the drive that if you want the two directions okay one that implies breaking a little bit what was there and the one that we would augment so in some cases we have found that we need to break a little bit what was was there okay so but then i guess we can we can do that we can prepare a new version of the draft with some of these of these details and then have the conversation to the site thank you that's great thank you uh jason's in queue we're a little over time but jason you can have the last word just a really quick question um is there is any of the functionality you're proposing here means stateful firewall behavior is it all stateless is so far it's all stateless we were not considering a stateful so far so it's all rules no follow the same approach it's only enhancements over what was there uh thank you for the presentation look forward to seeing the next revision as well as future discussion on the list uh with that we're actually uh out of time and uh thank you all for participating in this meeting look forward to possibly seeing some people in person uh the the next meeting there's you know rumors that that might be hybrid so uh thank you all uh for"
  },
  {
    "startTime": "01:02:01",
    "text": "contributing nice you"
  }
]
