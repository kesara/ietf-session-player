[
  {
    "startTime": "00:00:01",
    "text": "here. Thank you for working on pull requests and issues this morning Yeah, I wanted to do that earlier in the week, but I just I just found I would just falling asleep during sessions so all my attempts kind of failed until the day for looking at stuff on the document, did you want to share from your computer or do you on? me to try to do that? I can try. Okay Yes, let's say I should probably look so I can let you do things So if you request oh grant screen Trust is not fantastic Oh Thank you think he be better in light mode?"
  },
  {
    "startTime": "00:02:01",
    "text": "Oh, how do I set light mode? Yeah, uh that's a system, it's just your system setting, uh, okay, so if you go up into Control, are you on a Mac? Yeah? No, I'm on Linux. Oh how does Linux? do dark mode? There's a system level setting setting It may also be a browser. Right, and the browser by default follow the system level level Yeah, yeah, yeah, yeah, right, right, right. So I guess it depends how we went Yep and actually does, do the render HTML follow in light dark? It depends on the website No, no, no, no, but I mean for draft when we're looking at the draft text. Yes I would assume it The RFC doesn't The AFC doesn't. Doesn't Yeah. I'm very proud that I got the SVG images to to got the SVG images to... Ooh, ooh! I should go look at that code All righty right I think let's just get started David's not going to be able to make it, but mainly we want to be going through this draft that Lucas has very kindly been continuing to work on. I think, you know, we need to give help here and I I'll volunteer to help work on this more too So the state of this document, so I guess"
  },
  {
    "startTime": "00:04:01",
    "text": "for everyone you know, this is EDM, so we're doing evolvability, deployability, maintainability protocols, kind of the one last item we have that we have kind of agreed to work on is trying to give more concrete advice around greasing and things that look like greasing We have previous RFCs that we've produced like the user lose it document, that cover things like greasing, but did not go into some of the more practical details about how you actually apply that into protocols So that's what we're doing here. And this includes things as we'll talk about that go beyond just greased code points, et cetera you actually apply that into protocols. So that's what we're doing here. And this includes things as we'll talk about that go beyond just greased code points, etc. The status of this draft is that it is kind of like a IAB track individual draft, it's something that it would be great to kind of formally adopt by the IAB but I think what we talked about last time, was that we would want one more revision before we ask for that because that does involve like a bit of a community review at the time of adoption or at least announcement on the architecture discuss list Okay dokey. Lucas do you want to talk about where we are, what some of the pull requirements? you've been making are like and what would be helpful? to you yeah sure so to talk about where we are, what some of the pull requests you've been making are like, and what would be helpful to you? Yeah, sure. So, we've got a lot of amount of issues. A lot of them have been created by me as you can all see um probably better if we just start at the bottom So, you know, this is going back to probably like the first ed if we just start at the bottom. So, you know, this is going back to probably like the first EDM meeting we had after publishing the zeros zero whenever, you know, aligned"
  },
  {
    "startTime": "00:06:01",
    "text": "with San Francisco, say, probably So I had a few various people proposing that we talked about additional things that wen lin that zero zero draft and then we haven't done anything. So I think in particular, it would be useful to understand if if those issues are things we still think would be beneficial So I'm trying to poke people this morning assigning some issues i know dave thaler had volunteered last time to participate. I actually had a chance to catch up with Dave robin particular, but something we discussed at the interim was to just try to assign some of these issues to people just to make it clear maybe who's holding the pen that And if they say no, that's fine, you know, we can say no one's willing to propose any text deal let's just close the issue then and move on or to find somebody else who's a suitable pen penholder. I won't go to her text here, let's just close the issue then and move on, or to find somebody else who's a suitable penholder. I won't go to those right now, but if we go up, there's other things that just bring to my mind that just a suitable penholder. I won't go to those right now, but if we go up, there's other things that just bring to my mind that are just like aid memoirs to me I need to think on those longer if they make sense or not. You know, that's how my brain works It doesn't necessarily work for all. But some of the others are just editorial things that come up. So for instance, Tommy created issue 20, which was, you know, we have all these considerations for applying grease in a section They might be as consumable as they could be. So let's just go in and put some subject in. We should just move that in my opinion I just was to go into that one specific You know, it's a very clear proposal about what to do and then we've done it I don't know much more to say, we could argue about whether we should have these precise"
  },
  {
    "startTime": "00:08:01",
    "text": "names or not but personal preferred having subsections here to give some I don't know what the word is kind of like anchors for people to help people talk about these things i think my observations have been that it's greasing is like there's multi-headed beast, especially when we're thinking all the different protocols that are in scope or the different ways you could do this and um it's kind of nice to find some terms here within this trial at least So I don't know if we need to waste any time now of reviewing this or if we could just hit merge or we merge later, I don't know what you feel feeling that on me. I know you took a look at it before the meeting Right. Yeah, I gave a suggestion thanks for incorporating that I think it was just to make it a bit more declarative around you like you know, use this, don't use that I think I think it's fine. I would, I think you can go ahead and merge those unless people have particular bike sheds on them That's editor Yeah, let's, yeah, let's get into what are some of the substantive ones I know you have a couple other PRs, maybe one about the abuse potential Yeah, absolutely interesting to discuss Yeah, so let me just get the full scope of that window. Let me open the windows like you know so you can see the full text and so this came to mind during the main interim since we kind of started this document at least from my perspective in my position, in the world, which is very quick and H3 oriented, and I, fully appreciate there are other protocols out there but I'm tainted by what I see"
  },
  {
    "startTime": "00:10:01",
    "text": "There's been a number of attacks and exploits in the world that have affected a range of different implementations just by using the protocol in the way that is was defined, but that those implementations weren't necessarily built to robustly handle variations in the protocol usage. So and a recent example of this, there's something called like the H2 Continuation Flood without going into too much boring detail, you can send a request message in a sequence of frames, either one header's frame or a header's frame for followed by multiple continuation frames So that's a kind of variation in the pattern of frames And due to implementation details, certain patterns of frames could cause excessive resource usage in some implementations if they weren't monitoring things like cumulative size if they'd have done something like tracking individual frame size limits, none of the tracks would be triggered by sending a sequence of small frames that could bust that limit. So the text I've highlighted here in the issue is just stuff that I had to mind in May, which was really to H3's kind of explanation of this space based on the kind of security-minded review we had at the time both from the editors and external But they're quite specific to H.D and they're also quite loose and I think that thing I'm concerned about is we go and write recommend people, you know, greasing's great go and use it a lot and then they do and then they either make themselves so"
  },
  {
    "startTime": "00:12:01",
    "text": "open to be in Greece that they create an attack factor that they may not have had before or that they are aware of these things and they do have monitoring observability but their limits are so tuned to their current experiences with either their own stack or other implementations that they end up having false positives. The way you would react to any form of abuse generally would be to say stop the internet on an individual flow basis or maybe close the entire connection or or take other preventative or mitigation action So that's kind of the summary of what that issue is. And the proposed text that I came up with is basically copying out the bits from H3 because somebody already did that and it has been really and had working group consensus from those groups so why we're in about the wheel but you know try and take out the specific bits there and try and keep the text very short and readable I'm just trying to scale my window so we can read this more easily There's just a comment, I will commit that so we can review this more easily Just to say, you know, while protocol, and so H3 was very much specific about you know, reserved frame types or source types or whatever, there's documents focused on various things, three categories protocol, features, extensions, and visions So just orient the text on them to say that they will have legitimate uses, but they can become a burden when used to access with a simple example but not to go too into the depths of every possible example in the world"
  },
  {
    "startTime": "00:14:01",
    "text": "And then to highlight that if you're not monitoring for this stuff, you are exposed to some form of risk. That risk could be large or small, but that's effectively upon implementations to figure out but that we recommend that they do some form of tracking of these things and set limits on their usage and highlighting the risk for false positive if those limits would be too low That's about as much as I would like to say, but I their usage and highlighting the risk for false positive if those limits would be too low. That's about as much as I would like to say, but I'd love to hear people's thoughts on if they think that's a clear enough statement or if they think there's more text that should be added We have Mike in the queue queue Hey, so I like this text for greasing. I'm listening to you talk about it and going over it again. I'm it makes me think that the requirement to consume these and drop them only the ground if you don't recognize them is actually not all that different from padding and so I wonder is there a useful comparison? we could make there with just throwing extra bytes in that the receipt just has to deal with, but it's a legitimate use big because the, you're trying to change what your wire image looks like Effectively, something you know the pier is going to ignore is the same as padding Corey, yeah, I wonder if this is just about when you throw values in that create state or do work, you've got to be very careful I mean, if the values are simply filtered and dropped, that's all just about when you throw values in that create state or do work, you've got to be very careful. I mean, if the values are simply filtered and dropped, that's okay. But I can think of protocols where when you sense a new type, it actually creates an entity when you do that and it then kind of has to track it and you really don't want to be doing that"
  },
  {
    "startTime": "00:16:01",
    "text": "You really want to be dropping it early. So I mean, I something about making sure we discard the greasing early in the protocol design Yeah, that makes sense I think, though, to some of the cases, even dropping can be expensive, like in the case of like a continuation frame if the construct in which you were adding the ignored values causes the other side to have to keep state to aggregate those things to just ignore them, like, you know, depends on what layer it's at then it can definitely be a problem Mike, to your point about padding, yeah, I think it's quite similar if I think of like padding frames in Quick, I mean, you could just be you know, flood an endpoint with entirely padding packets and just kind of, you know, doss them with the amount of packets that you're sending to them. And that's it another form of this, right? Like, you still have to protect against that as an endpoint and think about that I did suggest a little bit of text here on the, or not text, I added a comment to that. Text on the PR I think it would be useful also to clarify what you mean because I think if we don't give some at least abstract examples of, you know, what the type of thing like a continuation frame or whatever else looks like we may not be obvious why it is a problem to just ignore things B, it's just like it's a lot of packets to hand or you need to add extra state just to parse and reconstruct the things to ignore them Yeah, I think continuation is a particularly useful"
  },
  {
    "startTime": "00:18:01",
    "text": "example of that because anything H-pack, you can't just drop it You just, you have to run it through your H-pack compression to maintain state, or you're going to kill the connection yes Sorry, Mike, you finished. I was just going to say thinking about flooding the pier with padding that can seem like a DOS attack, but on the other hand, I remember during quick development, we talked about trying to hide bursty wire images by having a constant bitrate on your connection That if I don't have anything to send you right now, I'll send you batting And that's a defense. It's not an attack depending on when you do it Yeah, so I now, I'll send you batting. And that's a defense. It's not an attack, depending on when you do it. Yeah, so I'm wondering, you know, we've tried to speak to this three different aspects of what this draft is talking about in general about, you know protocol greasing and variability I wonder if actually might be better to make this a subsection of the security considerations to talk about DOS and then break that out to grease which is like padding and has its own set of things and then protocol features as well. I don't know of any version like DOS by vision mutation off the top of my head, but I wonder if somebody has an example And especially if we had to break that out into a subsection, then tell me we can do what you said we have a bit more scope to kind of add some concrete examples in and i'm happy to add that text All right, I think that's good I wonder also if because this current is positioned as a security considerations bit"
  },
  {
    "startTime": "00:20:01",
    "text": "which is good for how you need to defend again how you're processing, greasing, or other protocol variation But if we have the earlier section, that's more like these new little subsections of here are the pieces of advice to follow, maybe clarifying I guess, positive advice to the clients or whoever is generating Greece to not you know, not do it too much right like use it use grease sparingly don't don't over grease the thing because that could lead to these types of processing problems or hitting the limits if the peers are trying to check for that Yeah, but not work to distributing it through the document and then maybe just a you know, the security sections can take a rough reference back to say, you know, the things in there are related to potential security I'm happy to do that I was just writing that in the PR. william carroll Bear assigned. I'm just wondering and I'm new to this discussion, but would it also make sense to say that it might be good to first try this environments? I mean, it's your many cases, a provider, will say, you know, here's our test version of our AP or something like that. And to say you know, to tell them, well, we're going to be testing, you know, we're going to be greasing with various values and things like that We're going to run it against your test systems first to see if they're compliant and at least warn them or use those environments first and that that might be a good place to try before you potentially"
  },
  {
    "startTime": "00:22:01",
    "text": "do something they might see as an attack I think that also kind of gets into, you know, the phase at which you're applying this greasing And I think we've talked about this before, how there are protocols like TLS where that is been added in relatively late in the process for versus protocols like Quick, where it was before any large-scale deployments of Quickly 1 existed most of the implementations had already done greasing testing with each other in the interrupt tests, and that certainly found things but everything was a test deployment at that point I don't know, Lucas if you think anything there fits in with this scope Not for this ticket itself For the document, yeah Maybe I don't know. And I think like You know, I, my brain not working very well today. I was just thinking you know, about some of the other protocols when the came to my mind was EPP, where you know, it's an established protocol it's been around forever and you know, if you wanted to start trying to do greasing around it there's only a handful of providers that accept it so you know kind of how could you do that in a way that's not going to make them freak out? So, you know, telling them, we're gonna start greasing, we're gonna run against your test environment first, you know, all of the above might be a good idea because it's, you know again, that's a small community and they're probably hopefully you're in communication with them, but who knows? Absolutely"
  },
  {
    "startTime": "00:24:04",
    "text": "So to replay what I'm hearing is that it might be nice if this document contains some guidance for people of extant protocols on how they might apply some of the techniques discussed in the document Is that right? Yeah, I think so Yeah. Probably just its own little standalone section Yep, there's a great ticket so we don't forget that But I'd welcome some proposed text too if anyone feels up to it Let me, for people just drop in the GitHub issues list into me Meetecho That was overly ambitious Ask, yes, yes Confirmed So while Tommy's doing that, I raised an issue that might be interesting to discuss But something that came up this week that made me think that maybe we need to have some discussion about the topic So this one's fun and it's good intentions end up in interesting places. So if you have a if you have an HDP3 server that also supports web transit and you receive a bidirectional stream from the client, it could be one of two things. It could be web transport or it could be HTTP And the way that you tell that it's web transport is that there's a the first frame on that stream is a web transport frame"
  },
  {
    "startTime": "00:26:01",
    "text": "or a web transport looking frame because it's not really a frame. That's a different thing And so the way that you might handle that that thing might be checked whether it's word transport, otherwise it's HTTP 3 But the thing is, for most people, prior to encountering any grease at that point the logic is is it an HTTP 3 header frame? or is it a transport frame? And it's a very easy mistake to make And it's exactly the sort of mistake that we're trying to combat through the use of things like that Greece. So there are implementations out there that have never encountered any Greece at this point. And at the point that they encountered the Greece at the first time, what a reasonable person might might do in that situation is go, oh, we messed up and change back to the correct logic But it turns out that that's incorrect also because there are a bunch of frames that you might receive in that situation that are eras All of the other HTTP 3 frames that you understand are not allowed in that situation You can only take headers. So the correct check is, and Lucas, if you scroll down a little bit Yeah so the correct check is not this, but this is what people tend to do which is check whether it's headers are okay, good, we've got HTTP3. If it's a web transport from good, we've got web transport. If it's Greece well, we can ignore it and everything else we've got an error. The correct logic is actually, if it's headers, then it's actually no, sorry, if it's web transport, then it's web transport Otherwise, it's HTTP 3 It's the original check, but then you have to add another check"
  },
  {
    "startTime": "00:28:01",
    "text": "to say if it's a frame type that I understand and it's not headers, it's an error That is not the obvious path to follow in this case. And this is the sort of pattern that I'm seeing in a lot of scenarios when Greece comes up is that people identify the grease and go, ah throw it out. Rather than stepping back and thinking about what it might be to handle an extension at this point and what the rules of the protocol actually are So I don't have a good answer to this so I'd like input on it. If you ever have a chat, for F, Greece, ignore, you've done it wrong. That's exactly right but that's a red flag. We don't say that quite so directly We can strengthen the text But I mean, does it help the implementers? Right And so I think the key thing that I realized here is that the draft talks is attempting to talk to implementers, not to the protocol designers And is there anything we can say to the protocol designers? that might lead to a better outcome? there? I was lost by that. Is it, if supported, then it's greased Is that what you're saying? I didn't, I didn't get the conditional bit in the middle. So what Stuart said is key. If you're implementing, so in a lot of cases, unknown stuff should be ignored is the rule. Okay And if you ever get into a situation where you're doing, if you're doing, if you're implementate, so in a lot of cases, unknown stuff should be ignored, is the rule. Okay. And if you ever get into a situation where you're doing, if Greece, then do something special or ignore it. Right. The idea of Greece It's a mistake. So you're saying... Yeah, sorry, go you're doing, if Greece, then do something special, or ignore it. The idea of Greece, it's a mistake. So you're saying, yeah, so it's exercising the code that's supposed to handle unknown future things. If you actually start special cases, in the Greece and recognizing it, it's not an unknown future thing"
  },
  {
    "startTime": "00:30:01",
    "text": "anymore. Right And doing that implies that you missed a check that you were supposed to have for how to handle unknown versus known fields, or whatever that may be. Oh Dave, please go ahead Hopefully you guys can hear me. Okay. I had intended to be there in person but if you haven't heard last week, I tested positive for COVID, so switch my registration to remote You're welcome. So my comment is, uh, examples, at least for me, always help understandability And so I like the examples in this issue when for the target audience of being implemented to say, like the code snippets that you should there, I think are very clear and allow you to actually save the source of things we've been saying. So I would actually love to see either these exact examples or some variation of them into the document because it makes the points very clear So that's my suggestion, which does not answer your question about what we do for protocol designers, right? I'm not answering that one. I'm saying. I think these were be useful for an implementer audience Yep, I definitely agreed with having concrete examples to help I think it's interesting the audience question, and that goes certainly beyond this issue but maybe we want a different issue on how audience there So looking at this, I think a lot of this stuff we have for considerations for applying greasing does seem to be directed at implementers, but there are certainly parts that are directed at the prototype document authors of talking about what should you do in your IANA registry. Having a consistent audience would be nice, and I wonder if the right way to phrase all of these things"
  },
  {
    "startTime": "00:32:01",
    "text": "is to talk to the protocol document authors and talk about what should be in their definitions, right? Because, I mean, you know it'd be great if all the implementers of every protocol read this document, but that's not going to happen But maybe there's something we could do to say, hey, when you are either defining Greece within your protocol, or even describing these places where you have a function that needs to be greased like, you know, the Asian 3 frames and whether or not they are known or unknown how you handle them. Maybe there's some advice we can give to how we can clarify you know, this is the check you need to make in your implementation because otherwise you're going to get it wrong Lucas So I'm a bit confused, so we're saying we want protocol writers to speak to the implementers rather than us Is that what you're saying? Potentially, um, think that way, you know, we still have effective the advice to the implementers, but maybe there's also something to be said about when you're defining the thing to grease as well as how to grease in a particular protocol, is their advice on the pIETFalls to point out? There's just a proposal of how we could phrase it to be in a particular protocol, is their advice on the pIETFalls to point out? There's just a proposal of how we could phrase it to make it more clear. Happy being. Yeah, I'm not against them I'm just a bit confused. I think that particularly in this example, part of the problem is that web trans come along and is basically extending H3 in a way it was never intended to be used"
  },
  {
    "startTime": "00:34:01",
    "text": "which is quite an interesting thing as well It is negotiated extension up front. Some of the extensions we've talked about, you know, it's an unknown frame, or it's a frame that you could just like parse the value if you know it and it's a payload and that it. But we have in H2 and H3, these are the forms of um extensions that kind of break the interactions or patterns we might expect So I think, you know, maybe it's like what could we have said in the web transport document that introduced this form of extension to tell people how to implement it properly If that's the framing, I think yeah, like, let's write the text here and wave it in front of the web transport specifiers, because that's still in progress Dave So I'm just thinking more about the audience question. I guess I'm starting to form an opinion and I also just fouled another issue where the audience would be protocol designers And so my current leaning is that I think it's going to be easiest if this document addresses both audiences Because I can say it should only address one, only address the other split it in two different documents, or combine them in the same one Right now I'm leaning towards the probably the best answer is address both audiences in the same document, maybe in different sections to make it easier to find, right? And I think that there's a little bit of overlap between protocol designers and implementers and putting it in the same place actually gives more maybe visibility into both audiences. And so I would actually keep all the guys guidance to both audiences in here. So for example, what I'm was talking about on the, what's being projected here would be maybe"
  },
  {
    "startTime": "00:36:01",
    "text": "guidance implementers about how to write code that actually adheres to the, you know, how to write code or pseudocode, right? That adheres to the guidance. And then there's also guidance to protocols designers and right now i'm thinking i would just keep them the same document It's going to be a lot easier rather than trying to write two different abstracts and so on because I think there is valid things to say to both, and there's going to be some things that are in the well is this for protocol designers or implementers and the answer is it's kind of both I'm just saying it once. And so, anyway, that's where I'm leading right now I just want to share that Gory. Yeah, I've got a third set of people who might want to read it, which is people who are working group chairs or are experts or something because it seems to me if you create a registry for a new protocol, then probably you should see that. And it's kind of in there There's a paragraph that says protocols might ask Ianna to create and it's hidden in the middle of something else and the IANA considerations say nothing And yet, as a chair, I probably would love a bit of chunk of text to say go look at these three paragraphs when you give me your protocol to review and decide on this. It can't be that difficult to add that section in the right place Proposal Is it good or bad? william carroll, Harrison I'm wondering about the choice to make this informational and not a BCP and whether they're is room here instead and I'm sorry as I walk into this as a tourist but I guess what I'm wondering is whether there's room here since we keep talking about two different audiences and I'm not necessarily volunteering to do this work, but to do a BCP or two BCPs, one for implementers and one for protocol designers or something along those lines that sort of shortens this up I mean, I like the informational. I like the examples and everything about that at the same time"
  },
  {
    "startTime": "00:38:01",
    "text": "I'm not sure everyone's going to read this that thoroughly and I'm wondering if there should be a pithier, you know here is what you must do. Here's what you should do kind of a thing, particularly on the protocol designers, and I'm thinking more of some of the possibly ossified protocols like DNS where I'm more in that world, there's a lot of times when the implementers, the protocol designers did not put much in about what happens if you do pass in these strange values or anything like that. And as a result, we end up often saying oh implementers some of them returning us or fail and some are returning you know an annex that. And as a result, we end up oftentimes saying, oh, well, implementers, some of them are returning us or fail, and some are returning, you know, an NXD. And it's like we didn't specify what they were supposed to return and then you end up having to years later, sort of code around eight different possible responses, where that probably should have just been a line earlier on that said if you receive an unknown value, here's what you're supposed to do and that would have handled reasing and also just future proofing but that was not done so that's the kind of thing that definitely would be advice for protocol designers that I think maybe we've learned from our mistakes but probably not Just very practical on the informational BCP thing Given that we're doing this, well, so we're talking about this in an IAB program, right? And probably like the user lose it, we would put on the IAB stream, which can't be BCP or standard So, I mean, you could go the route of, you know, get a AD sponsor for it, et cetera I don't know if that's really worth it. But I think the content of what you're saying Yeah, great. All right Gore, did you have anything else?"
  },
  {
    "startTime": "00:40:07",
    "text": "All right seen Suzanne mentioned something about greasing and DNS in the chat I would think I had to expand on that Do you want to come up to a mic so that? Lucas can hear? Yeah, there's actually a job draft that's being proposed for adoption in D&ZOP about various code points and various registries where Greece might be possible to retrofell and, you know, as I think you were getting at it's a different problem with a legacy protocol that's widely used as it is with all of its pains and agonies And I'm trying to get my head around how do the concepts apply So the really interesting thing is that TLS is also a legacy protocol with all of the pains and whatnot and it was a great example of how you can take something like this and poke it into the protocol and interesting things pop up, pop up, and you learn stuff about the protocol in the process. And I think that's really the key thing is it's not some things pop up and you learn stuff about the protocol in the process and I think that's really the key thing is it's not something you just do and it's done it's a learning experience And I guess we're still learning because we keep coming up with you know examples like this even in protocols that are new completely fresh and new, but in old protocols you have to sort of think what are the things that you want to be able to do?"
  },
  {
    "startTime": "00:42:01",
    "text": "with this protocol in the future, and then you use something like this to test whether or not those future flexibility things are available to you. So, I mean, go ahead and do it, is my recommendation there And yes, stuff will break Well, as kind of an example, looking backwards, one DNS standardized a mechanism for handling unknown, RR types was very much along a step down that path it turns out that a lot of parameters are harder to do this with, but in fact the RR type one is a pretty is frankly a really helpful move has helped a lot And I think to some of the other discussions we've had in the RFCs we've done in this group, like finding the extension points that are actually extendable and are handled well is what encourages them to be used in the future and the other code points, maybe you're not going to use them so much Yeah. So, so my recollection of the RR type one was that when someone first started down the path of trying to add new ones, it was quite difficult But because there was a strong desire to be able to do it there was a good push and people made it happen. And now it's the case that you wouldn't necessarily need to create RR types because people are out there using new RR types pretty successfully right more or less yeah but and in fact the reason they're not is largely a set of beliefs more than the technical difficulty Yeah, the situation we were in was that the R-type register requires is expert review required and since there was no mechanism"
  },
  {
    "startTime": "00:44:01",
    "text": "for handling unknown R-R-types, basically if you RR type table wasn't a updated in your, you know, in a new release, it wasn't even external, you know, it wasn't even an external reference yeah, we did eventually figure out how to put a stop to that. And yeah you went from a situation because so in practice deploying a new R-R type was basically standard required or even higher as a barrier to entry. And now it's at least a little bit more in line with having the registry be expert review Kyle, do you have a microphone? Exactly, yeah, Kyle, it looks like you have a good comment. Do you want to share it with us? Yes, no All right Can you hear me? Yes, we can. All right, fabulous Yeah, I mean, I was just, I've been thinking about this problem for a while and, but not keeping up with the ecosystem here but it just seems like what you really need to do is do unexpected things and tell people in advance you're going to do unexpected things and they'll appear in implementations, arbitrary And if you don't follow the normative language, your system, your NOMCOMpliant system is going to break. And then you're going to be you know, and maybe, you know, we're going to implement these in Firefox and push it out on a Friday just to make their life especially miserable. The idea being to incentivize them to be complete with the spec"
  },
  {
    "startTime": "00:46:01",
    "text": "And I just, I feel like this is very much an incentives matter kind of problem. Like you have to incentivize implementers to do it the right way and giving them a list of code points in advance is just going to result in a special casing that we're that Martin and others referenced earlier One other thing to point out about, I think, DNS that maybe is different from some of the other protocols, but I don't know if there's applicability william carroll, Versaigne, would be I guess it's possible to, because you can end up sending a request to resolve her, and then if it is one of your own domain and your own authoritative, you can actually see what it forwarding through, right, you know, how it's setting that on. So you can actually see whether it did strip out or, you know, I say it, but it could be middle boxes and God knows what But anyway, you could actually see if things are getting stripped out somewhere along the way and then you have a potential bug report or something like that but other protocols there's no real visibility on the client's side like that, right? There's no easy way to test and see, you know, did I sent you something strange? I mean, I can see if you reacted in a bad way, but that's pretty much all I can see. So I don't know if that's something to keep in mind as well that some protocols may be more testably greasable than others Um, it took me a while to think I see the point, sorry, I see the point he is making, but what concerns me is like, say, for H"
  },
  {
    "startTime": "00:48:01",
    "text": "HP3, if I as a one endpoint, the client or the server decides, you know what I'm not going to use that grease value I want to use a non-grease value that is to my knowledge, not used by anyone And it's just a random thing. And I'm going to send this frame with the type that nobody should recognize with the length and it should cause no problems whatsoever The reality is that that could be being used by a private extension of some kind that isn't registered or that my implementation is so old that this thing has been registered in the meantime I don't understand it, but other people do and that it would potentially break me or them illegitimately because I'm doing something that they they wouldn't expect and a good one would be that web transport frame type we've got on the screen If I just chose to send that with some expectation of what could happen and that kind of worries me from a security perspective of what might go wrong if we assume types aren't used like that that was kind of the point in registering the types to express you never be used by anyone to avoid this kind of aliasing risk that might happen But yeah, that's just my immediate kind of new joke thoughts Yeah so a lot of this it's funny, I think the original definition of Greece was testing the TLS protocol ecosystem in production because that's the only way you can really test some of these things is you have to test them in the wild and you run the experiment and you see what happened and I think perhaps in some ways perhaps we've gone a little too far with the idea of reserve code points and things like that up front because it's meant"
  },
  {
    "startTime": "00:50:01",
    "text": "that people have started to do some of the things that I've identified I've had a number of comments with David about, who is one of the original authors of the TLS greasing work about what it is that we might do to continue to promote the health of the protocol ecosystem. Some of the things he suggested was well, we can define the new version of TLS and redefine all of the code points to be off by one That will certainly cause a reaction. Right, and so the the point there is to deal with expectations that people build up around how things are structured If you don't negotiate that protocol version then everything's fine and you're implement the new version and everything's completely changed And we did that with Quick already, and it has had some success, I think but I don't know whether or not we've done ourselves any favours by upfront defining what the grease values in don't know whether or not we've done ourselves any favours by up-front defining what the grease values are in quick it might have been better to have an extension document that took took those code points away rather than put it in face defining the grease values kind of difficult the point of them being Greece because now they're not unknown Lucas said something very interesting there which I had not thought about before. The whole point of greasing is to check that you ignore unknown things, correct? But if you're trying to help the greasing process by generating unknown things and your implementations, old, you risk stomping on things So I was thinking, how would we deal with that? and I don't know whether this is feasible Could we require that if you're going to be part of this? greasing process, if you're going to be injecting noise in? you need to be in an environment,"
  },
  {
    "startTime": "00:52:01",
    "text": "where you have access to date and time and there's like a sunset clause in the code that you only grease up until January 2020 and if that date comes and the implementation has not been up to date, then it's like, okay, you don't grease anymore because you're too out of date to know what you're supposed to do now embedded systems might not have access to date and time, so they don't grease at all, and that's fine But to participate in this greasing service, you have to know the date And they can certainly be greased on an embedded system you just wouldn't generate the grease. That's what I'm saying. Yeah right this there's the receiver of the grease that's being tested and there's generator of the grease that's doing this public service that exercise the other implementations it's talking to and maybe you shouldn't be on the exercising side unless you have enough information to actually do that competently. Okay Isn't it? I mean, isn't it? sufficient to, to change? periodically add new grease code points and immediately start using them in implementations like basically say every three months we're going to add a new grease code point and it's going to appear in an implementation and if you're not compliant your existing installed base is going to break now I mean you know system owners implementers could defeat this by observing the ion installed base is going to break. Now, I mean, you know, system owners, implementers could defeat this by observing the IANA registry and updating their implementation, but that would very quickly get really irritating So I'm just wondering if something like that that doesn't require us to make sure that systems are are uh only responding to greased code points within certain times bounds. I mean, that might be a little bit more complicated than I think"
  },
  {
    "startTime": "00:54:01",
    "text": "is what is actually needed to incentivize the right behavior Great Yeah, I just want to cover on the notion of, you know, I'm going to do something that's going to cause your user brace to break The challenge is that often the incentives are misaligned when such a statement might be true, and that is, if your user base is large and incumbent, then it prevents me from doing something because something breaks, I'm the one that gets blamed, not you And so that's the problem Yeah, I was just going to point out when Carl's talking about the continuous thing, and I kind of like that idea the idea that we might continuously do this. If someone is observing the IANA registry and updating their implementation, live, that's probably a good thing for the health of the ecosystem because it means that they're reacting to the way the protocols are not the problem. They're not the problem Yeah, totally not the problem so um but i do think we're on to something with the idea that we have this can continue If the namespace is big enough that we can afford to burn another code point every couple of months, right? Yeah. As long as there's not an 8-bit field, as long as we don't mind burning through them, then that's a good approach And we shouldn't assume the implementers are malicious They're not trying to defeat us. What we're trying to do is make the path of least resistance be to do the right thing So when people write this fragile code, it's not malice, it's that they're inexperienced, they don't know what they're doing, and we just need to guide them in the right direction, right?"
  },
  {
    "startTime": "00:56:01",
    "text": "If they want to defeat us, they can defeat us right? Those are not the people should be worried about It's the people in the middle who are accidentally making mistakes that can benefit from some assistance Yeah, I'm still thinking about the full pipeline of the incentives as Dave pointed out, when I was an implementer the balance had to be between doing the right thing with respect to the protocol and the code and doing the right thing with respect to my customers, and those are not always along And what I'm thinking is it needs to be clear that there's a way to implementers can protect I'm not even sure that's the right word but that it's pretty careful compartmentalized who's playing this game and who isn't Because for most people, most of the time, they have more pressing worries than the overall future robustness of the software and the protocol. And that's why we get the kind of that's why we get fragile code and people that don't understand the problem and so on And I think it feels like some of the incentives are still a little bit misaligned and that needs to be you know, that needs to be addressed somehow or nobody will apply apply some of the incentives are still a little bit misaligned and that needs to be, you know, that needs to be addressed somehow or nobody will apply that that needs to be you know that needs to be addressed somehow or nobody will law um so going on the kind of continuous idea it reminds me of something that mark nottingham had discussed around how you would do greasing for HTTP header fields. I don't remember if that ever got written down anywhere"
  },
  {
    "startTime": "00:58:01",
    "text": "maybe an issue somewhere But that was effectively a situation where we were thinking it would make more sense to have something coordinated where, you know, for this month everyone sends this header and then they move on to another one. It's, I think it ends up looking somewhat similar to what we're talking about here of the continuous approach. So just saying, they may have some broadening of applicability Yeah, this kind of thing reminds me like a flag day but a very long one with Randy values, but from a purely processed perspective, like if we wanted to say, have a new one every three months or something, can we could we even dispatch those codes to to iona that quickly like what would be the mechanism for, for writing? this thing? Like the benefit of doing it all up front is that we preserve this huge range once and we never need to go bug Iyana again But like, what how would you write a document or some process to allow random person to send an Iona request? and get experts to approve that? I'm kind of, my brain's going wild with thinking like, oh, we do this random thing with an omcom all the time Could we set up some similar kind of? well-defined process? And then the answer that comes out at the end is different every time But the inputs and what we need and the definition of them is well understood by people. Just a thought So I've been thinking about the incentive issue and I'm not exactly sure what"
  },
  {
    "startTime": "01:00:01",
    "text": "to say yet, but I at least filed an issue to track the discussion but I think there's an existing IAB, RFC 817 planning for protocol adoption subsequent transitions That one does have a discussion about incentives and thank you So does 5218, which we do reference, but the document doesn't yet reference 8170, and so I imagine if we could figure out what to say we could add some discussion of the incentives and reference the section 81 so so it we could add some discussion of the incentives and reference the section 817. So again, I have to think about what to do and I might be willing to contribute to text, but I just don't know what it would say right now, but I have to think about it after reading through both, the documents basically back to back to see if I can figure out what good way to relate them Yeah, just thinking through the a little more, I'm wondering whether or not the idea that this is an experiment as a concept that we've been trying to eliminate is actually something we should be embracing a little bit more with this idea of continuously experimenting on the protocol to determine that it still works in various ways and that we have certain degrees of freedom within the protocol the incentives are aligned with those people who want to continue to do new things with the protocol, right? So the reason that people wanted to try to do Greece in the first place was that they wanted to make sure that they would be able to do something new in the future. And so their incentives to do the grease in the first place was to check whether or not the thing that they wanted to do, the real thing had any hope of success And we're seeing in some protocols that those experiments fail They just completely fail because the ecosystem is so tightly bound up in awkward ways that"
  },
  {
    "startTime": "01:02:01",
    "text": "they just, okay, that particular course of action was not available to us. And that was the experiment that we ran in TLS with the version numbers. We had to develop it completely new way of negotiating a new version of TLA for TLS 1.3 because we ran the experiment and it failed That, um, that the of negotiating a new version of TLS for TLS 1.3 because we ran the experiment and it failed. That sort of idea of continuous experimentation to do this is I think one aspect of it the other one is that that experiment runs in production because the only place that you can genuine run that experiment is on the internet as opposed to in dedicated test environments. And I think Bill's point about, how do we, how do we check for the EPP? ecosystem whether or not something works is kind of an interesting one because I think you might, operating in a much more constraint space with a limited number of people and so you have a different problem to talk about there You probably have phone numbers for all the people involved in those implementations, right? And that's not really the the setting in which this is really very helpful it's the setting you want to run an experiment on an ecosystem that's large and unknown and potentially unknowable. Gorey That sounded better it's sounded that we were also getting to a bike shed discussion about how to design something bizarrely complicated And that's not great if I've got to advise people on how to actually write protocols for this So, Martin, I think you're experimental thing is right. I think what I was hoping was people report the results of experiments and they say, well, this worked and maybe there's a MapRG taught that spans all this stuff. Maybe sometimes it's embarrassing for people because"
  },
  {
    "startTime": "01:04:01",
    "text": "it doesn't work, but most of the time it does Is that the sort of thing you were hoping for? Some sort of like positive feedback to the community yeah I think actually calling it an experiment it continues or otherwise, is the right way of thinking about it. Because it does encourage that sort of feedback loop as well So one of the great things that came out of the original Greece experiments was that people shared what they learned But again, running the experiment is a public service, reporting on the experiment is a public service. I don't know how to do address Dave's questions about incentives Being a good, good act in the ecosystem is is like not something that's really incentivized Yeah Just to point out, I think the incentives I mean, this differs from protocol to protocol and community community because thinking back to say the EPP one in that case, the users and the customers are essentially they're the same, right? And so you don't necessarily need a public, name and shame campaign to incentivize anyone because if your customers say, hey, we're gonna be testing our systems, we want to run them against your test systems, hey, we found that when we have such and such value doesn't work, I can go I can call the customer service and say I'm filing a bug report I mean, that's, and I'm your customer, and I would like you to fix it this, please. Whereas if we're talking about something that's some sort of more widely used protocol, then we're talking about, okay, we're doing an experiment and do maybe a name and change campaign and say, well, we tried it against these 10 implementations and eight of them failed you know that kind of stuff. It's going to, it's going to, it's going to, experiment and do maybe a name and shame campaign and say, well, we tried it against these 10 implementations and eight of them failed, you know, that kind of stuff. It's going to, it's going to differ case by case, right? So"
  },
  {
    "startTime": "01:06:01",
    "text": "I don't know that we can generalize that in these documents, which kind of have to accept that's the ecosystems working in Yeah, so I find in the incentive discussion kind of interesting as a as a maintainer of a huge, well, I stack that services lots of different clients with lots of different web traffic and if we break stuff it can take down huge proportions of the internet, or at least users access different web traffic and if we break stuff it can take down huge proportions of the internet or at least uses accessibility to portions of the internet and that's sad and it we're generally fairly risk-averse for doing things. Hence why building something in from day one making sure it's always happening is a lot less risky than saying okay well we're gonna we're gonna something different this month or this quarter so that the incentives for the folks that would sign off on doing work in one quarter to the next they might say, okay, let's do an experiment why are we doing this, it's good for the internet, okay, fine, we did that experiment, we proved it, why are we doing it again and again? and again. And so to work around that kind of view, would be maybe thinking of the differently and thinking of it more like when we have to do key rotations you know no one has to argues that we need to do those They're just understood that they're important to do. And that you know it's kind of like a rotation of greasing code points It becomes part of the process And you would invest the effort in building up the capability to do that in the first place as part of the initial experiment and then others might do it as an experiment but for certain operators, it's just business as usual that this would be regularly happening and we need to make a less of a strong case for keeping the lights on for that thing, and that we would build the mechanisms to identify those issues if they occurred. I can think of examples"
  },
  {
    "startTime": "01:08:01",
    "text": "where we tried H2 extension frames and they worked fine, and then they broke people and we have to turn it off because people who we broke said it could take six months for them to fix so there's a lot. That's kind of a lot of political or meta level stuff going on here, way beyond protocol designers, I would say And even implementers, it's the, how much risk do you want to take for your specific? deployment? All right It's a good discussion. Hopefully helpful for moving the document forward Timing wise, you know, let's wrap up around 9.15 so people are sufficient time to get down to sessions etc Anything else we think we should? talk through? Lucas, what do you think would be helpful? for issues or getting recruitment? recruitment? So I hear a lot of different ideas that are very interesting but it kind of worries me in case it's going to be scope creep for the document which we were discussing trying to maybe get you know, tidied up and then, you know, put out for wider review So I think what help is a clear understanding maybe of if we think we want to tackle some of those bigger items we just discussed today or if we should focus on the kind of current scope of the document as it is now modulo issues related. Some of them have been open today"
  },
  {
    "startTime": "01:10:01",
    "text": "There's things we can, we can respond to quite quickly and get some text in and iterate on and come up with a new draft Or if we should maybe you know, should we be thinking of another interim between? now and the next IETF to try and tackle some more of these things now that people can go away and think about them a bit more when they don't have COVID and maybe come up with some proposed texts for them So I think very practical they're in the short term, we have some practical issues and PRs and there are other ones that I know you would comment on this morning, which we don't need to discuss here, but I think they're are places where I can provide some text, et cetera other ones that I know you would comment on this morning, which we don't need to discuss here, but I think there are places where I can provide some text, etc. So let's do a pass of adding some of that extra policy and extra examples into the document Dave, I know you had previously been offering to help co-author on some been offering to help co-author on stuff. So if you want to help do some of that too, that'd be great And then, you know, kind of with co-author on stuff. So if you want to help do some of that too, that'd be great. And then with the current scope, let's get a revision out and then we can talk with the IAB and try to say, with the architecture discuss list get some review there and more or less for formally adopt it onto the stream And I think in parallel, some of these other you know, bigger ecosystem incentive and kind of continuous greasing changes, I think, are good to continue. It may be nice to have someone who has a good idea around that write something up. That can just be an issue on the GitHub, or an email to the EDM list or something else And maybe once we have some kind of concrete"
  },
  {
    "startTime": "01:12:01",
    "text": "idea lobbed across the wall, then we can have some discussion on issues and list and then sketch an interim around that if we think there's something fruIETFul to dig into Yeah, that sounds good from my perspective It's going to take me a while to get home and back to 100% after holidays or whatnot, but I'd like to target sometime in September to get another the new cut of the draft without all the polish landed and that we've just discussed. I think that seems reasonable Cool All right Sounds good to me. Thank you all. Anything else? Anyone wants to bring up? All right. If not, thank you for the early morning discussion And thanks for the people remote or stuck in their hotel rooms for joining. Very much appreciated And we look forward to seeing you again. Cool. Thank you all One is again. What? do you suggest again should be um for the next meeting i think based on what we're talking about um if we can get kind of sufficient energy or ideas, written down in some form that there's something concrete to discuss about for some of these bigger conversations September you know, something midway between IETF meetings otherwise we wait until Dublin and we go okay All right. Thank you all"
  }
]
