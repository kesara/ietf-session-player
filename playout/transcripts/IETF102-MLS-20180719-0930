[
  {
    "startTime": "00:01:18",
    "text": "okay hello everybody and welcome to the first session of the MLS working group if you are here for another working group please leave now and if you\u0027re here for MLS you\u0027re in the right place so here\u0027s the note well you\u0027ve likely seen this before if you\u0027ve been to any of these other meetings please read it understand it take it to heart it\u0027s very important so in terms of before we start we have a few requests minutes takers we have a minute taker jabber scribe we have a jabber scribe and a follow up jabber scribe and let\u0027s pass the blue sheets out as usual we would like everyone to be able to understand who\u0027s who\u0027s saying what at the microphone so you come up to the microphone state your name this is not only for the people in the room but it\u0027s for the remote participants we have at least six Omnitech though right now so please keep it professional and let\u0027s move on to the agenda here\u0027s the agenda let\u0027s open this up to agenda bashing does anybody have any questions about this or any suggested changes no okay so we\u0027ll do administrivia charter review architecture and then several presentations about some of the documents that have already been presented and some of the ideas that have been discussed on the list and at the end we\u0027ll discuss a few at other extra topics that are unscheduled let\u0027s start with the Charter Review so since the Boff MLS was incorporated and here are some key excerpts from the Charter and I\u0027m just going to go over these from a high-level right now the main important pieces are that this working group is here to develop a messaging security protocol for human to human communication the above and there\u0027s that there\u0027s a list of properties in in the Charter itself specific security deployment properties and the goal of this is where applications to share code so that they can be shared by shared validation the protocol so everything that people use well underneath for this anything that people use MLS work and can use share code basically and the goal is not to enable full interoperability or Federation beyond the key establishment authentication and confidentiality so we\u0027re really looking at the crypto here we\u0027re not looking at making sure that different messaging protocols from a high level can interoperate we\u0027re "
  },
  {
    "startTime": "00:04:18",
    "text": "looking at standardizing the crypto and another point is that while authentication is a key goal of the group it\u0027s not the objective to develop new authentication technologies hopefully what the result of this working group will be documents in which you could use x.509 or other authentication techniques and and plug them in similar to how TLS does not define which specific authentication technologies are used in okay without will do an arc the architecture review slides I\u0027m on okay hi everyone I\u0027m ed Amara from Google so big here I will cover tooth presentation today\u0027s architecture and message ordering both of them are basically overview of what we have today in the drafts followed by a list of open questions to the group not necessary to get answered all of them today but just only the discussions often you get some answer to most of them so this is the same as I go through like a Chinese above because nothing has changed since then but you could get through this in slides again so this is what a typical imaging system looks like server side the client side several to services most of the time to return to the same service which is authentication delivery clients are the members each member has a bunch of voices each device in MLS is actually a separate client each has long term identity key in this picture there\u0027s a group of a BNC he has three devices vs 2 ones he had one okay what syndication service basically storage mapping between long-term identity keys between user name ID even long-term identities like email phone numbers to identities the other service ensures reliable in order delivery for a message and attachments store the init keys which are signed by that indicates and option is to grow membership so everything has a straight core story here is one of the open questions we\u0027ll discuss event so store bro membership is one of the hoenn questions also the reserved responsible for affecting long-term passive user is to ensure this year\u0027s client yes this is a typical client operations st. John group etc since devices are presented established client so basically invite member advice all the simulation scene for remove member or remove device orgasm operations so in this picture a one tries to create a group with DNC so a one daily request in each case for a 2 a 3 B 1 B 2 and C 1 verify the signature in this key is created secret encrypted message then they want me to and see one receive the message we create the same chip shared "
  },
  {
    "startTime": "00:07:19",
    "text": "secret and decrypt a message function requirements scalability obviously supports large groups the number came up with 57 clients a synchronous all aggression can be done without having the call devices to me online most of all devices should be supported natively because again voice it just say first client storing history is met requirements by the protocol but again the application can support this client set recovery if the client was staged to be able to restore the state without corrupting the entire group mitigate the collection this is for protecting the privacy so the both EDR years and years should be collected the minimum yes I needed to deliver the message Federation as I mentioned in what we discussed earlier is that wouldn\u0027t expect introverts application layer like but most of ammunition should be able to integrate versioning I\u0027m going to talk more about this at the end but we should really support version negotiation and have mitigation for downgrade attacks security requirements of course message secrecy in terms of medications message should be decrypted by only existing with the group and only existing members can send this message another asterisk in your message appearing to prevent traffic analysis so this is optional for secrecy and post command security to refresh our minds forward secrecy it means if the attacker has all traffic history and key k1 should not be able to decrypt any messages before key one would scheme would be for k1 the other way around is pcs is if taker has k1 and some encrypted traffic and in the time time T Prime the key has to Quito shouldn\u0027t be able to decrypt any traffic after Quito little membership Secotan who all never should have the same thing of group members this can be done by using merkel cheese proof commitments client who joins the group should not be able to decrypt any message before joining clients from removed from the optional be able to encrypt messy after leaving attachment security should have all the security semantics of any message except the encryption key she tends to be longer because of that attachment Netta origin authentication means new impersonations so Alice can\u0027t impersonate pops in the message as pop this usually done by having signature and every message typically this we can use the long-term energy for signature but if wanna provide deniability to will be optional we\u0027ll have a secret nature cave and the signature keys would be to change it over than average channel security consideration so what happened delivery service compromised so the most of us can always do the US which there is nothing towards this but it should not be able to do inject a message or reorder and if it happens the clan should be able to take this if authentication services compromised our it\u0027s it\u0027s it\u0027s more serious because it can allow impersonations so a condition in encrypted engines and concerns pretty loving or something like it transparency to do so if if this client compromised this is the worst "
  },
  {
    "startTime": "00:10:20",
    "text": "case because attacker will be able to encrypt and decrypt messages but it can be defeated after the compromised client has been updated that give material but it should not be able to do any newest attacks again it\u0027s other beers in the world I gave this is a list of open question we have today notice it\u0027s come up or answer today but solving for discussion the first one should the drive to find the frequency of zob this or key is completely open to that the other question is came up during the path it\u0027s something too concerned about exposing the user devices and this is a privacy concern third question is the server trusted the store group membership and last one should address communication for traffic analysis or just forget about it yeah so is this the time for discussion great yes so yeah MT just remind me one at a time so I\u0027ll just start with the first one shouldn\u0027t you have to find the frequency of key update or leave it up in the application I think the answer is yes I think oh there\u0027s nothing we can do with the voluntary standard yeah I\u0027m elaborating here so I think we should both provide guidance on the frequency of key update but be realistic about how tightly constrained applications so for instance we might say we really strongly recommend that you have a do you update your key at least once per day but they\u0027re gonna be things that are offline that are gonna miss that budget and so it\u0027s gonna be up to the applications and to make their best effort to meet virtually just just accommodation looking for thing anything yeah I think that\u0027s right it\u0027s it\u0027s gonna be about you know what the defaults normal case behavior of the app is and they\u0027re gonna have it they\u0027re gonna violate their their update budget sometimes we have a remote question from from vendor oh can I respond to it he just sat first yes um shouldn\u0027t frequency be a function of how secure the key is if you have weak keys and you want to refresh them more frequently I think that one element regarding the question whether the server can be trusted to store the group membership I think in a number of vacations this wouldn\u0027t be an issue but there are some applications where it would be an issue so I think it would be a good idea to have it optionally work in a way that the server cannot infer who the group members are from "
  },
  {
    "startTime": "00:13:21",
    "text": "persistent data okay okay we\u0027re gonna take a question from the queue here I\u0027m sorry ruff hi Robert from wire let me take another question from online Ben everyone so I\u0027m Ben the Uche I\u0027m working with Karthik in Paris yeah so I wanted to discuss what what a Matt say and a child about I think it\u0027s good to have a recommendation in the spec about the dating of the be louder yeah and you got me now more please okay cream okay um you know we can hear you but you\u0027re quiet so speak as loud as you possibly can okay so I think the recommendation from from Richard seems a good idea to me like when updating the key the GUP key one per day the coop secrets once per day seems like a reasonable recommendation to me especially because some security properties will actually depend on that secret and maybe I\u0027ll come back to it a bit later in the message protection part but typically depending on if you want to get pcs for the message protection for them for the messages and not for the group secret you will need to to update more or less frequently the the top secret in that sense I think updating once a day is all about you just to be clear I\u0027m not asking what should be them at the time I\u0027m just asking should the draft proposed recommendation yeah my answer to that is yes we should have a comment something like one or one updated a feature that we should add some guidance about what to do with it and I think that there are a lot of techniques that you may know that in Safari we have a document about regime that is close in to is G period that there can be some key Iraqi that key can be changed for example once a day and the session keys can be changed frequently but yes I totally agree that we should add such issues in the draft the document may be as a guidance or as best practices but we should address this issue because we know some examples of messengers for example which care of this problem with keys that are not being changed so yes "
  },
  {
    "startTime": "00:16:21",
    "text": "this must be addressed in my opinion and second question I have here do we address authentication techniques indication methods as part of the key texture or as completely independent separate document and separate since this to discuss so right now is indication is a lean out-of-band but I guess reach out more about syndication you mean user authentication or message authentication okay thank you every scroller so I guess in sequence yes we should provide some guidance on key update there are actually three reasons why you might want to do key update one the one was alluded to by the previous speaker well not previous previous speaker or not likes it no stops but on which is uh you know wikis that\u0027s probably not really an issue in this case um you know you um if you know if you if you rotate your keys you know like once a day you basically get here you get said you get something like you know like four or five extra bits of security that\u0027s really get you very much um but the reason is to do it our four key exhaustion in terms of aes keys is GCM keys and also for PFS and pcs so we should provide some guides on that on though perhaps it should be him I tried to guide people I had to think about the problem as well it\u0027s just read numbers um um I know DK do you want to talk about the protocol high user devices whatever he\u0027s about to say I don\u0027t we of course wrong exactly yeah more seriously um I think would be good if it was able to but I don\u0027t think it\u0027s I don\u0027t think that um there seem to be some seem to be a bunch of I get the problem is that well that\u0027d be a nice feature it comes along with a lot of package so if they analyze with that packages and whether that baggage so I guess you want to where my sense from current analysis is it is not but it\u0027s not just a yes/no kind of question um with regard to the server being trusted store group membership I\u0027m actually again two issues here right one is is this her trusted to accurately report group membership and the second is the server trusted to know group membership the the server should not be trusted to act the group membership for obvious reasons um and that should be pretty easy to cryptographically fix um in terms of sorts or be entrusted to know group membership G would sure be nice if we\u0027re able to bolus system that didn\u0027t require that but I suspect when a system practice will end up having that information any case on so again we have to figure out the baggages their motor systems on familiar with on as a practical matter if you know group membership anyway so doesn\u0027t make that much difference um finally the guard traffic analysis mitigation on I think we should not do anything here I think there should be a like a section that says like this is like a huge source of like information leakage um but like every time I\u0027ve seen anybody tried is it turns into enormous rathole so I don\u0027t think we\u0027d actually do anything separate traffic analysis on mitigation document "
  },
  {
    "startTime": "00:19:21",
    "text": "that\u0027d be fantastic and I\u0027m kind of hoping that hair RG or whatever they\u0027re called will actually give us some help here but I think we shouldn\u0027t like we think like that\u0027s that that could show a lot of working your time for not much value let\u0027s close the line after Richard hi John Milliken and so on the topic of defining our frequencies of he updates or recommending I think we should include something on it but we need to be careful that\u0027s what we say will make sense for both groups and three puzzle groups so for example if we were to specify to do it every day for fifty thousand person group with far more key update messages and processing you actually have useful messaging but in fact very well maybe that the security properties of when you get to that scale me are somewhat modified or at least what the expected security properties are modified so that slight a different PA schedule would make more sense whereas yeah if you\u0027ve got a very I think for Beth of users it\u0027s okay don\u0027t sending updates for a long time but once it start sending messages and if your combination is one day and they have been sending a message for two days with the first message we should issue an update from users I think there is no need to object compromise or the global pcs guarantee would be that if any group member is compromised that there will at some point to be the group security will be healed so if we want to aim for that then we may have to consider positive members but in general I agree with you and that\u0027s for most operations thank you and this is Daniel Caine Gilmore so I do believe that the draft needs to specify strong recommendations for key update we have experience of not recommending key update schedules and other protocols and people done don\u0027t implement them at all maybe they won\u0027t even if we recommend but if we recommend that we give him a chance I recommend framing it as a minimum and maximum key update range because you want a maximum and frequency or or or period but if people read it too fast then we get that we run into this problem that that John describes and if they update you slowly then we know that the PCs but we should put in a concrete recommendation and I agree with John that thinking about how we frame that with regard to number of groups is important as far as hiding the user devices I\u0027ve mentioned this on list the current arrangement where we are currently saying well you know multiple members and each have multiple devices and the devices are visible that is a strict superset I think of what we minimally need to do minimally we need one device per user "
  },
  {
    "startTime": "00:22:21",
    "text": "and the user could do something like MLS between their own devices to synchronize whatever key storage and state they need to synchronize if the user doesn\u0027t do that then they end up showing up as multiple devices the reason I think we should avoid trying to get too deep into the weeds of a multiple in the multi device case aside from it being more than we need to do to get something working is because I believe that the multi device case where every peer can see everybody every other peers device it has two problems one problem is that I don\u0027t necessarily want you seeing my devices and I don\u0027t think we have a good sense of how we can explain to the user a choice of do you want to expose that you have multiple devices or do you want to just pretend to have one right I think that\u0027s a that\u0027s a bad question for user interface and we don\u0027t want to give users the choice of switching in between there and the second reason is because once your keys are being updated like that and it appears that you have a new device you\u0027re gonna increase the number of notices that new devices show up or you\u0027ll start removing those notices because they just get in the way and so in the fourth in the first case you end up with security fatigue which means you don\u0027t notice the actual big devices where a user gets read which is the wiretap scenario and in the second case where it\u0027s all hidden you can\u0027t notice it so I think that when we if we go into the point of exposing multiple user devices it leaks privacy and it increases the problem that the the ease of inserting an additional key for a wiretap scenario which I think we should be avoiding we should be avoiding making this wiretap facilitation scenario I will not comment on the third one but on the fourth one we need to include a mechanism for traffic padding we do not need to specify exactly how to pad but for the protocol messages in particular all of the stuff that I\u0027ve seen across the ITF the application layer is what knows best how to pad and so somebody who wants to write a draft should be able to do that at the layer of MLS but we don\u0027t need to include the specific advice in the first round here we just need to make sure that we have a mechanism for padding that someone can write a document that describes the standard pattern thankee I Lucia Ballard from Apple just a comment on the first point I think having the recommendation here would be really useful having a strict requirement would potentially be a hurdle to adoption or if you go with the minimum maximum idea and making sure that minimums pretty generous just because I\u0027m thinking potential clients adopting this are in the very hugely in their expected group size in their sort of expected connectivity for group participants and in the amount of already deployed infrastructure at scale that they have to deal with so making sure that there\u0027s some flexibility there it would be very helpful for the charters to have you thank you bob Mascis HT consulting I\u0027m going through the list I\u0027ve seen so many scenarios but "
  },
  {
    "startTime": "00:25:23",
    "text": "ripping the IOT arena where I think good guidance in different classes scenarios will be very good because one community we may be very insular and not being able to think really out of their own box of what they may be doing so they can see how in this particular case a different key update method will maybe use may open their eyes to a broader view of it but in IOT arenas with some multi-class case I seem like you\u0027re not gonna get key exhaustion for a few years and devices are not going to be updated for even maybe more years than that so they don\u0027t even talk about key update in those arenas because of that but but even so those people should still think about some of the other cases so good guidance I think is what\u0027s needed in the key update arena and and strong recommendations in certain for certain scenarios I would like to see how you\u0027re going to be able to hide the privacy of the user devices and this is really really hard and I\u0027d be really interesting to see see how you\u0027re gonna recommend that because it might be interesting or we may just be wasting a lot of effort to make to to have some smoke mirrors also in many again it depends on the multicast cases whether you can really can not store the group membership so that\u0027s really related to what you\u0027re doing with with multicast and and so how does MLS or have really anything to say to the group about what they\u0027re doing in terms of group memberships store so I think that\u0027s out of scope for MLS and on the last one I assume you\u0027re talking about traffic analysis of MLS not traffic analysis of how those keys are used therefore I strongly think that MLS itself needs to include traffic analysis mitigation and in that and I hope that that\u0027s what that point is talking about now traffic analysis for other multicast protocols Rob secure protocols hey Richard we\u0027re gonna have a quick question from Karthik Karthik if you can keep it short and then we\u0027ll Richard y\u0027all have the last word hi guys this is Karthik I come from India just a small question about or small comment about group membership which is that I think it\u0027s an important question to ask at this early stage what we really expect from tanam about I think a few other questions have raised this point too I mean is it actually necessary for every member of the group to actively maintain a group membership list to know immediately who the members of the groups are whenever the group changes or is it something that you want to be able to query on demand from some distributed set of participants say and this is just I\u0027m just throwing this out as maybe it\u0027s not clear-cut that everybody should always be able to know who the other members of the groups of the group are okay thanks Karthik this "
  },
  {
    "startTime": "00:28:31",
    "text": "Richard Bruns again I spoke about the first one already I\u0027ll just cover the other three briefly which is largely plus one of those some other folks have said too with regards to Bob\u0027s question about hiding devices I think the flavor of hiding we\u0027ve discussed here is a John John Milliken came up with phrase pre trees where you might have a leaf node in the mls tree actually represents a whole subtree of devices that belong to a user\u0027s perspective of the overall group you would just see the user as one node in the cryptographic State even though there might be that no it might be a compound with other ones that\u0027s kind of I think what ml d kg was referring to take your three-letter acronym Dicky was referring to you when I was talking about running the protocol among your own devices which i think is exactly the right way to think about this I don\u0027t think we really need to get into the details of how you might go about hiding things we don\u0027t need to treat that as a first case use case here just as I think we can just note that one could do this if you wanted to protect device privacy I\u0027m largely on the same pages I could with regard to storing group membership the only thing I wanted to know was something that I think John and Raphael raise pointed out to me was that we might not we might you know use the the server as a cache of some information but not require it to store the whole membership of the group so you might you know trusted the store you know a collection of public keys for nodes in a cryptographic state but divorced from identity information about the participants and I think John\u0027s nodding I think that\u0027s sort of already saying so we might trust the server to cache some stuff that\u0027s kind of not identifying a participants and so not sensitive but I think the general requirement here is let\u0027s just think about how much we require the server to cache versus what would be useful for it to cache in terms of distributing information finally traffic analysis mitigation it\u0027s a Bob\u0027s point about what we\u0027re talking about mitigating I think the intent here I don\u0027t think anyone at least I\u0027ve been chatting with Alice has been thinking about protecting the MLS key exchange method messages I think we weren\u0027t even thinking about encrypting those so those those are just like handshake messages that the system can see I think the concern here is traffic analysis mitigation with regard to the messages that would be protected by a message protection scheme that Benjamin is going to talk about in a couple presentations and I think the answer is roughly what I forget prior person said that we should have some padding mechanism in here but leave it to the applications to decide how how do you so to summarize we almost all agree that we have some guidance for the first question like min and Max style should prefer other devices I guess we might add option for this but I still continue discussion for this part its server trust stewardship I guess our conclusion adjust may be optional but don\u0027t require per se and the last one we should "
  },
  {
    "startTime": "00:31:35",
    "text": "include some include some can even but it leave it to that aside how to do it correct okay so question for you and that is as editor of this document you feel like you have guidance to go off and I think so great great thank you so the next next week come on before that happens can I see a show of hands of who is read this draft a fair amount that\u0027s good whichever previous draft a lot could I should write yeah cuz what we\u0027d like to do is do a working group adoption hum so if you\u0027ve never done this I\u0027m gonna like Nick do the actual hum but the idea is that we have an individual draft now and we\u0027re gonna make it a working group top so that we can take it I think it was good that we have these open questions because it shows we\u0027ve got work to do so it\u0027s not fully baked so that\u0027s that\u0027s perfectly okay but we\u0027ve got a good basis of a place to start there anybody else who has a competing drought that they would like to throw into the right you you cannot do that alright okay so the hum is going to be for adoption of the draft of the draft as a working group document the draft specifically is amounts of architecture draft so if you want this draft to be if you agree that this draft should be adopted please hum now if you disagree that this drop should be adopted please come now pretty clear the remote was also yes thanks our team on let\u0027s move over to the next one handshake message ordering perfect so handshake message ordering so this is physically specified in that protocol draft I\u0027m gonna quickly explain the problem and the solution described in the draft and again open question then so what are the handshake messages they are any messages change the group stays like group in each other ad group add remover update each handshake message is based on the current groovy state I will choose a pop field for this of course conflicts can happen if two or more clients issue a same handshake message on the same group state usually this can be solved using server-side enforcing or client-side enforcing in both approaches that might call the starvation\u0027s so a given client may not be able to send handshake message because it\u0027s always get rejected so we understand art forces Tekin however you know correcting the difference more in the next presentation three Kim doesn\u0027t have this problem because it\u0027s able to marriage concurrent updates without rejecting any of them so the wave server forces ordering the "
  },
  {
    "startTime": "00:34:37",
    "text": "message you will have authenticated equation number which is a book field and the delivery service will just process them in order and if it receives two or more message on the same sequence number it will just pick one of them and reject all the others and the rejected client will reach for again after update English states the way underst client first identified correct me if I\u0027m wrong it spins in two steps we\u0027re at sea this is how its described today is the critical draft the client proposes the update first and since update if it gets fifty plus percent by other clients it\u0027s a question you know what if most of the clients are offline like fifty percent from the online user which is a security issue or how it works so these are the three open questions about this the first one should this section be moved to the optical dock instead of the protocol like covering this message or drank the problem is this only specific for any protocol that has shared will be state if or even something like sender kids they will not have this issue so the question should we this PR overall in the pressure block or not again back to the server the server divisive is Trust is the delivery service trusted to enforce our drink what\u0027s a security consideration if it does and regarding starvation is actually a problem in in busy groups or in gratitude to a teammate might never happen like someone eventually it will eventually issues our update and it\u0027s all in from discussion again so yeah I think it would be good for the architecture document to have a very clear statement on this the the question here is what assumptions the protocol document can rely on if the protocol can basically assume that clients are presented with a linear sequence of handshake messages that dramatically simplifies the client logic you\u0027re going to have to put put into your into your stack so I\u0027m very much in favor of making a clear statement in the architecture that whatever the delivery service is that\u0027s do it that\u0027s providing delivery for this protocol it ensures that all of clients receive handshake messages in the same order and that frees us up at the in the protocol document from having to do anything about what happens when things arrive in different orders at different clients this is a simultaneous at or simultaneous update question so you okay with a set of our trusting yeah I am comfortable with trusting the server to enforce ordering but as long as we can assure in the protocol that the only thing that that can result that the only thing the server miss ordering things could result in is a denial of service condition so we should make sure that it\u0027s that the trust in the server is bounded but as long as the server can\u0027t do anything besides deny service or fragment the group I\u0027m comfortable with that "
  },
  {
    "startTime": "00:37:38",
    "text": "agree of trust in the server because the server can can cause fit those sorts of failures anyway on the starvation question I think that\u0027s a real potential problem but I think it\u0027s something we\u0027re just tactically speaking I I would be comfortable pushing forward with a solution that had some risk of starvation doing some prototyping dropping again getting some experience in real ish environments and then you know if starvation looks to be a problem in some cases looking for some methods we could use to try and address that as an addition to a baseline protocol that\u0027s linearly oriented I\u0027m going to comment that the concern I have it with several cross to death the server might reject a specific a bid for a specific client so which means risk is the PCs for specific clients but if we have like if we do like bundles update with the message itself this means that mass will not be accepted on slaves objects is accepted okay this is just an idea this is d kg so on the security considerations side back on 14 and says modified reordered or replayed messages must be detected by the clients in the event of delivery service compromised so I think that goes to what Richard was saying that there needs to be a detection I confess I\u0027m not sure that I know that well if I hear so there is no reordering this would be preventing from updates so the client who rejects updates so if it is a vos at that so the server will reach its updates this means I\u0027m trying to address the questions about forcing the ordering not about starvation ok wait sorry yeah sorry I wasn\u0027t clear about that so I confess I am NOT in sure that I understand what reordered means in a distributed messaging system like what does it mean to say that the that the server if the server reorders the message that\u0027s detectable by the clients when we\u0027re talking about a messaging system where there is no canonical source of truth about when the message was originated well if two messages coming from the same client for example can send two before one so we\u0027re talking about just about it is the way the ordering works right as a replay attacks replaying the same message multiple times or the order machine from the same client so just from the same client yeah I would state it a little differently I I think the risk here is in handshake messages so the key exchange protocol I think we can tolerate arbitrary ordering in the message protection as Benjamin will talk about a second but I think the risk here is that the key update messages are premised on a given state and so if those are delivered in a you know in an order that doesn\u0027t correspond to a linear evolution of states and or if they\u0027re delivered in different orders to different clients that can cause clients to end up in inconsistent states and so I think that\u0027s the type of reordering that\u0027s the concern here is that there\u0027s not a consistent ordering in terms of "
  },
  {
    "startTime": "00:40:38",
    "text": "sorry if all clients don\u0027t receive key exchange messages in the same order the objective here is to have clients agree on a sequence of cryptographic states and so if they if the server can reorder messages to to change to cause clients not to agree on that like that\u0027s that\u0027s the type of reordering I\u0027m concerned about anyway anyway it sounds to me like we\u0027re not entirely clear that we\u0027re all talking about the same thing so it might I think sorry I think they\u0027re talking about regular messages are Fisher\u0027s presentation and Richard talked about the handshake messages here right I\u0027m talking about the handshake message on appengine yeah I mean I think there\u0027s a separate set of questions about a transcript consistency which I\u0027m not trying to cover right now so this time I will agree with EKGs um I I think it\u0027s clear that like the system can\u0027t enforce like strong ordering like guarantees between two simultaneous up this year different people um like Eric Ries Corolla um uh no I mean like if you and I you and I send updates like at the same time like approximate the same time they\u0027re like no there\u0027s like no way for the system to guarantee that the one that was like sent and like like I was in order quality in like Walcott I\u0027m like two milliseconds before the other is the one is delivered first like the server obviously word of them in anyway of leases so huh like unless you men ISM news to go dater because I\u0027m not aware of so so so I mean the best in that respect what we can do is we can guarantee um is we can guarantee that the messages within a client or say are delivered in the right order handshake or not handshake on the UM similarly like the server can obviously suppress that you know the server can obviously suppress messages from any client it chooses and so what I think um the I was over what I mean as I think we agree there has to be trust consistency otherwise the system doesn\u0027t work properly and to what Ahmad was saying earlier is the we should be targeting here is you can\u0027t selectively suppress handshake messages while delivering application their messages and in terms of being able to detect reordering and resolution then that\u0027s what that gives you which is to say that if you have consistency with if your consistency within a client and I receive like you know messages two three and five and they\u0027re all messages and then Irish I\u0027m missing message for that I know I know that\u0027s been deleted and um and then you have to like come with why did the server not delivered that now um if you want to go beyond detection is suppression one might wish to make handshake messages in some way indistinguishable from from from from application their messages so that it was difficult for the server to selectively suppress those um but there\u0027s only so much you can do I do think by the way that on to Richard\u0027s point that I think that\u0027s totally reasonable at this point to say we\u0027re "
  },
  {
    "startTime": "00:43:39",
    "text": "not effect if we trust the server to do this properly and then attempt to detect when it fails to rather than try to build a system which operates properly in the face of an arbitrary malicious all right nobody difficult thank you yes refer Robert so to the first question I think it should be part of the architecture document especially if the answer to the second one is yes because the server is then very much part of the architecture and so to answer the the second one we have to look at what the options are so one thing is what you outlined amad is that it\u0027s being decided on the client side and for that we would need some sort of mechanism where clients can actually decide on the order without relying on the server and and that is difficult because you pointed out that it has to be asynchronous or finding some consensus asynchronously sounds a bit contradictory happy to be proven wrong there but sounds like a tough problem to solve especially if you don\u0027t want to add a lot of overhead and the other option would be if ordering is not really that necessary so this comes down to art or tricking which I think John will mention later so for art orderings absolutely necessary and for trick em you have a little bit of flexibility some messages because some stuff can be merged but it\u0027s it\u0027s still not very flexible so I think in practice the the best solution right now would be to trust a server for that and regarding the starvation this really comes down to the scope and and the amount of messages you have at the end of the day so this if the scope is really only the handshake messages personally I don\u0027t think we could ever run into starvation frequently because if we have so many handshake messages that many participants and devices send them out at the same time constantly then we have a general problem I think uh Jonathan I was just think I mean I think the question with starvation is you want to make sure that clients can distinguish genuine starvation from you know some malicious server or potentially even malicious other group members fault you know falsely making you think you\u0027re being starved and locking you out of the column and you know I guess it\u0027s it\u0027s kind of the same DDoS attack you just you know denial of service attack just by dropping the that\u0027s malicious server but I want to make sure that you can tell a malicious server from genuine starvation Bob Moskowitz perhaps I\u0027m showing my age but where\u0027s the state machine they were talking about reordering the rest being important there must be a state machine here someplace and the state machine should handle all cases my professor way back when forty years ago "
  },
  {
    "startTime": "00:46:39",
    "text": "whatever wouldn\u0027t know more than that would not let me do anything like this without including the state machine so if we\u0027re concerned about it we should be able to talk about that and again maybe I\u0027m just showing my age on that and and so the state machine would then tell us whether we can trust the ordering the rest of it so that\u0027s why I say about that starvation that\u0027s Doss attacks so he has a real problem and it will occur so again it\u0027s how do you recognize and understand that and again the state machines just show that again showing my age sorry thank you John Milliken again so I think I think my my take on questions two and three is one of it would be it would be lovely and I don\u0027t know if it\u0027s possible every lovely it could you get to a state where the server can do nothing to the security properties without actively blocking blocking people\u0027s messages so obviously if one person can never send a message on then put pcs with respect to that user is is going to be compromised but if we can get to a situation where so long as everyone in intermittently get messages through global pcs can advance then that would be that strikes me as the property that we should probably be aiming for with respect to them okay yeah just to emphasize on this reordering semantics the the the order that is important to preserve here is not the order of origination of messages which echo as I could accurately points has interfered with my relativity the the important thing to preserve is the order at which messages are received by the participants and that you can easily enforce that with things like two-phase commit so that it\u0027s you know there\u0027s a variety of mechanisms where you\u0027re well known we can use to preserve that property so we regard to starvation I think something that might be useful to do here is to have kind of a starvation consideration section here because another thing I might trust did the server did you uh Jonathan mentioned malicious other clients trying to omit a lot of update messages so that no one else can advance pcs and that is something where you could have the server do some some stuff to help like it could it could recognize especially active clients or it could recognize that you know this client hasn\u0027t had a chance to update in a while so let\u0027s get and let him in and so the you it seems like you could put some considerations like that in the architecture and as in terms of recommendations for things servers should should consider implementing finally I wanted to end with a question the thing that I\u0027m actually surprised hasn\u0027t come up yet is Federation because these this consistent ordering are super easy to implement in a single server system you just have a lock and you know you wait to get the lock a free transmit but it\u0027s harder to implement in federated systems where you might need collaboration among domains to synchronize when messages can be "
  },
  {
    "startTime": "00:49:39",
    "text": "transmitted so I\u0027d be interested to hear from folks who are interested in that use case as we\u0027ve said in the Charter it\u0027s not a primary use case here but we won\u0027t want to have real hard barriers here so I\u0027m interested in whether people think this would be a real hard barrier in Federation Daniel Franco so ekor is of course correct that that you can\u0027t totally order messages and asynchronous setting but that doesn\u0027t mean that we necessarily have to settle for just total just just ordering messages from from each individual participant there are very very nice middle grounds here like vector clocks okay no I can\u0027t ask you mara 4:17 G for them speaker I may have misunderstood the problem so apologies ahead but with respect to messages and ordering when we\u0027re talking about end to end and I guess that\u0027s what we\u0027re trying to achieve here server here is strictly to facilitate certain things so when we talk about security and it\u0027s the service roles in all this is to harden the model not necessarily to make it secure and therefore when we talk about the order of messages I see two types of messages messages that are specific to a state in which case like the gentleman mentioned a state machine or crypto a cryptographic binding to that state is important and that solves the problems of server trying to mess around over the order with messages that don\u0027t really affect the ordering just need to get there that\u0027s a different problem so I think it\u0027s important to separate the space of the type of messages go through because some messages need to tie to our specific to state some are not and those are are tied to speak to a state need to be somehow bound to that site either cryptographically on earth rather means so you\u0027re sort of this is to the point where the server is just facility and transfer instead of an insurance and security properties all right if you want so I was thinking about your question about federated the case and I\u0027m wondering whether since this is human communication whether it might be enough to to be able to inform the user that there is sort of that the various end points who don\u0027t agree on the on a particular message order and so if you can if you can even if you can show that right we\u0027re and that might be enough in the Federated case right I\u0027m not entirely sure you have to force ordering in for every case but as long as the user knows that there is contention contention in a perfect particular case about a pair of messages right this your your the whoever used your chatting we believe that they are actually in the different order you may "
  },
  {
    "startTime": "00:52:40",
    "text": "have to work that out but since this is human to human maybe your config maybe that\u0027s enough so my cum talks in one more comment respect servation is I may be wrong but there\u0027s not much you can do them in depending on the capabilities of your attacker and adversary right if they can control the network they can potentially compromise the server because the server is sort of less trusted i was just mentioned that probably one includes a mechanisms where a client understands that he was not able to participate in their ecosystem for a period of time at which point he refuses to participate at all to say that you know what I wasn\u0027t able to persuade therefore I have no trust in the system anymore and I\u0027m gonna back out until some recovery mechanism is in place so this is to say that you can\u0027t control the world but the client can say you know what I\u0027m gonna be defensive I\u0027m not gonna participate if it doesn\u0027t play by the rules Brian why is cisco so traditional group security systems do tend to trust servers and have a lot less trust in the clients and i sense from this effort that it\u0027s all the way just flipped around they\u0027re the direction we\u0027re trying to trust clients and not the servers and I think that\u0027s not clear at all in the architecture and even not in for example the second question here I\u0027m sorry don\u0027t trust anybody so so I think that\u0027s that is even more important that the architecture itself needs to take that statement and make bounced around around what do you who is trapped you to do what and who really is trusted generate keys who really is trusted to decide when there\u0027s a key change those are those are it\u0027s really hard when you don\u0027t trust anybody so you\u0027ve got to assign some amount of trust to somebody and then in the architecture is linked okay John Milliken again just in response to Michael\u0027s point about clients deciding that they have been locked out for long enough and they\u0027re gonna stop responding I think some of the offline discussions I\u0027ve had with people about this in discussing maybe if the protocol can automatically expire clients which have been silent for long enough can so rather than the client deciding that it\u0027s going to kick itself out everyone else decides that they\u0027re going to keep the client tabs for the purpose I mean that\u0027s why this cool okay so that we understand the answers are its yes for the first question for the second question the server is trusted to do the functional delivery or the function Orion but to the security semantics so and if there is any compromised from the server should be taken by the client it was ever did anything with this the client should be able to detect it somehow to understand correct starvation when I when I mentioned summation here I meant innocent distillation like functionary "
  },
  {
    "startTime": "00:55:41",
    "text": "should not attack voiceover attack by the by other means because both of them are at the addressed in succession dr. Beane\u0027s cannot deal with other peers and was the idea we have with minimum and Max and the update this should solve this problem you can\u0027t really actually issue up this all the time yeah I was just gonna say as author of the protocol document which is not yet adopted but maybe in the future the less is the takeaway I\u0027m getting here is that you the architecture is going to document this requirement that the delivery service provide a consistent delivery order for handshake messages to clients and I\u0027m going to rely on that in the protocol document yeah by the way should it be : ten shake messages that\u0027s just what that\u0027s the terminology we have and I agree now we can change it later and I think the what I\u0027d like to see for the third one is is that we have some considerations around how to address starvation and then we we keep an eye on that problem as we move forward and see if we need mechanism to improve the situation okay in the way a thief provision is if it\u0027s it intended starvation but also for other being just a way of us like to card in the same direction or not I think clearly we need to document that it\u0027s a condition that can arise okay I think we should also document some things that the server can do to help if it arises due to malicious clients it\u0027s not good any other question okay okay thanks John let\u0027s run your ass cool so I\u0027m just gonna talk about that the big open question of what should lay at the heart of the protocol we\u0027ve got two proposals at the moment are tan and tree kam and this whole thing is an open question rather than the specific specified open questions at the end of em had slides please pop up and ask questions at any point so first to just kind of refresh us on what the various operations be able to support at so we\u0027ve got group states stored in somewhere both the proposals at the moment own key trees of various forms and every participant cache is some view of the tree and then the operations that we have to have are being able to create a group at users users add themselves to the group users update their own keys in the group and being able to remove users from the group so this is just the key exchange protocol it\u0027s somewhat divorced from the messaging itself so the first "
  },
  {
    "startTime": "00:58:41",
    "text": "protocol but to borrow my slides from the buff is called asynchronous ratcheting tree came up with this last year and it\u0027s based on a different binary tree so any leaf can be updated in logarithmic time by updating the Leafs tree and sorry the Leafs key pair and just recursively recalculating the entire setup to the root this can operate asynchronously we have proofs in the paper linked of the confidentiality of the group keys in this setting only for static groups this but this paper does not fully prove art as used within the MLS protocol doc but it\u0027s partway there and within MLS we\u0027ve actually defined some things that were left out of scope in the original paper so we have additional constraints and the tree structure as I said we allow membership changes and we talked a bit about race conditions which we have the luxury of assuming did not exist in the paper so to that the fundamental building block of this is diffie-hellman and a way to derive a different key from a dippy Hulman output so if a mb perform a key exchange between them they get the output a B which they can then use to derive a key pair and then a B and C D can then perform this etcetera etcetera recursively up the tree and so for example you code to do Expo 5 5 1 9 so X 2 4 5 1 9 just of the hash of the diffie-hellman output that we found at the hackathon or the other day that if you just use a washout 2 5 6 there are a bunch of potential tricky potential conflicts that happen but yeah this is just an example we do not recommend this in practice to know terminology here so with respect to see we\u0027ve got a bunch of terms so we have obviously the roots of the tree we\u0027ve got the direct path which is in bold so that\u0027s C and all of its ancestors we have the KO path which is the sibling of all of Steve\u0027s ancestors and then the frontier which would be the siblings of all of the ancestors of a hypothetical Mew key to be added to the tree so the direct path and the co path are all with respect to have given nodes the frontier and route are with respect to the tree as a whole and from a leaf and a co path you can compute the entire path of that leaf so the way we "
  },
  {
    "startTime": "01:01:41",
    "text": "anticipate the group evolving is that this is just used as a mechanism for inputting into a more general group key ratchet so the tree root is KDF t\u0027 in to the existing group ratchet etcetera etcetera so we don\u0027t just require the correct tree but we require the correct order of trees as well so the first operation create group is very little to talk about this a has a different key and that\u0027s pretty much it in the art paper we defined this as starting with a pre-existing group in MLS we don\u0027t do that yet we just assume it\u0027s the one member groups that\u0027s very difficult to talk about this it is a combination of few of later operations such as the group initiated out so this is a situation in which a member of the group wants to add someone to the tree at this point they take an init key these are also known as pre keys and of the protocols which has been pre published by the user that\u0027s going to be added they generate a difficult and key which they then publish alongside the init key and from this the user can generate the the rest of the tree so they also have to publish the path sorry no they\u0027ve in in this yes in this diagram the add key is sent to the other members of the group and so everyone has either the add key or the init keys private key and can recalculate the rest of the tree based on the frontier of the group the next option is the user initiated add so this is d adding themselves to the group as the the frontier has already been published all D has to do is perform the the diffie-hellman with its own key it\u0027s fairly straightforward for PCs this is when someone wants to rotate their key pcs being post compromised security that is our future secrecy as it\u0027s also known so be simply update updates its key recalculates its path and publisher all of the public keys up the path and then everyone in the group you should be able to calculate with respect to one of those public keys what the rate is and then removing is essentially an update where someone performs an update to someone else\u0027s key by replacing it with an eviction key this has some intricacies that have admitted from this slide but we essentially we have a double join problem where you now have whoever\u0027s evicted the other member now "
  },
  {
    "startTime": "01:04:42",
    "text": "knows some of it some other node in the tree so if they were to be removed they would still have access to some state of the tree in the protocol dock we talked a bit about how we can address this so as an alternative to this bonds occur and Karthik came up with this alternative approach tree can so this is a new primitive as opposed to the diffie-hellman key tree which we were used in art whereas art used diffie-hellman x\u0027 which are contributed they require both of the children to contribute something to the key this is non contribute \u0027iv so every node or every parent node is derived from just one of its children when you send out updates you send out the parent nodes secret key to whichever child should know that secret key and simply send it as an encryption operation rather than through any derivation and then for the most part the properties are pretty analogous to us this tree structure is the same but we have a couple of potential big improvements one of them and which I think was the main motivation behind this design is that multiple updates can now be potentially merged without conflicts because the non contributor bertie means that no one needs to know one of the two children\u0027s private keys to update any given parent and also because as I will cover in a sec the keys are derive by hashing one of the children keys once you know one of the private keys it\u0027s pretty much an o1 operation it is a lot logarithmic sequence of hashes but because they\u0027re orders of magnitude cheaper than asynchronous operations we treat them as essentially free so the way this works we have a new derived key pair operation which mats a random bit string to a public key pair but this is a public key to use for encryption rather than key exchange could still be difficult and that doesn\u0027t have to be we have a strapped away the specific algorithm and so you\u0027ll see here that you\u0027ve got this the parents is hash of a B P doesn\u0027t come into a digital so this is what the tree looks like the various definitions are exactly the same but you\u0027ll see that you\u0027ve just got different values here so see in this instance was the most recent person to update so C\u0027s key is represented at the top was at each stage of the tree you have the node was derived from one of its children I think I just always went for leftmost apart from see example this is exactly the "
  },
  {
    "startTime": "01:07:45",
    "text": "same the slide was just copied so you just to demonstrate that you can use it exactly equivalently so in this instance to have a group initiated add you generate an add key this is just a random sequence of bits you encrypt that add key to the new user using that init key so that\u0027s this ciphertext add key in the structure you calculate the sequence of private keys and public keys up up its path and then you publish all of the public keys in the path keys sorry you publish all of the private keys in the path keys having encrypted them to their sibling so in this example Javad key is encrypted to cv and hash squared of ad key is encrypted to the hash of a is public key and this allows everyone to calculate that calculate the route with just one single decryption so the next operation the user initiated out this is again pretty similar to art so it\u0027s just deers adding themselves so they take their own randomness hash it up the tree encrypts the relevant hashes to the private so to the public keys of the other children and DS key is now at the root of the tree for an update so if we imagine in this situation that a had had been the most recent person to update at the point that B now sends their update again the root to the path is just completely rewritten completely unrelated to what it was then finally remove we\u0027re looking at exactly the same processes in art just send out an update for someone else\u0027s key so the key comparisons here are so first in the update complexity so where as art every update is essentially a log in operation pretty much everything in art is log n tree cam updates a log n for the updater but they are just there oh one in terms of expensive operations for everyone else in terms of concurrent updates because of the non contribute ility it\u0027s much easier to imagine multiple updates being handled at the same time and having some decision to which wins without having to discard any in its entirety art has a few situations and when it might be able to handle concurrent updates but it\u0027s much more restricted and one note here from the academics is that we have not fully "
  },
  {
    "startTime": "01:10:45",
    "text": "studied tree cams PCs properties we\u0027ve got a bit a best slightly better idea of arts properties but that is incoming for Trika I believe open issues with both this is the same as it was with art so we\u0027ve got to prove the various operations security within the model that we want figure out the logistical details around removing massive sequencing mess various other topics which have been covered earlier or will be covered later today also attachments this slide was copied from last time this is not so relevant to tree kemon art specifically cool any questions / comments yes I think the salient question for the for the moment you know what we need right now in order to keep the protocol moving forward just a kind of tea at the discussion for everyone is we need to decide you know which of these or both we want to move forward with so in the the rev of the drought with the protocol draft we we produced for this meeting I just put in a switch and said you can do either of these as the inner loop of your MLS you know either you can have an MLS route based on here it\u0027s here you can have one based on on Sri Kim and I\u0027m guessing that\u0027s probably not the optimal outcome so I realize we might need to do some more verification about the the properties of some of these algorithms but I\u0027d like to know like it seems like these are pretty easily swappable so maybe we can proceed with one while we do that verification so I\u0027d be interested to hear you know whether people think we should pick one or keep both and if we should pick one which one we should operate with for the moment so personally a back on your you\u0027re sailing a comparison points slide I am less concerned about the concurrent update benefits now given the last discussion we had so if we have a strong assumption about consistency in the received transcripts then in principle you never run into a situation where you\u0027re where you need the merge concurrent update and the only way that might be useful is if we really have a bed starvation problem and we need to do some merging I\u0027m also worried because from a protocol point of view even if you can cryptograph of the emergency updates you need a way to communicate that and so you need some you know language to say here\u0027s the set of updates I have merged and I\u0027m using that for this epic so I think it introduces a lot of complexity so I think the the primary advantage to me here is in the the performance difference and that that even that I think comes with a cost because tree cam requires several more primitives having your code you\u0027re not just doing d-h you also need a public key encryption primitives so it seems like there\u0027s some "
  },
  {
    "startTime": "01:13:46",
    "text": "drop back there too honestly I\u0027m not really I don\u0027t feel like there\u0027s a strong winner here and so I\u0027m looking forward to hearing from other people yeah if you don\u0027t also mention actually tree can message update messages are about double the size of art once but not order of magnitude difference I reeling from catriel cone Gordon she\u0027d like to hear on lists from some Federation positive people about the concurrency assumptions she expects they have situations where it is not satisfied - laughs - laughs thank you I really think that both constructions worse considering I\u0027ll just want to at one point that tree came if we could be sure that it\u0027s really secure regarding assess properties has one more advantage it\u0027s much easier to build implementations as it is resistant to side-channel attacks because we really have much less public equations in some points that can be quite frequent so I think we really need to try to evaluate and assess tree campuses I think that may be safer gee I can help asserted that can be pushed to safer G and personally I\u0027ll be happy to try to calculus and as it was mentioned both constructions seem to be more or less equivalent it in the set of interfaces so we can proceed with without choosing one or another one right now but if we could prove all properties of chicken really personally I prefer it as construction Thank You pecker let\u0027s go to Benjamin Karthik and what are you everyone I guess it\u0027s I don\u0027t know can you hear me this time yes okay so I actually I don\u0027t think I agree with with Richard on this I think we we should actually keep both constructions in the spec right now because it\u0027s we still need a lot of analysis right busan art because it\u0027s been studied only for static groups and for trick em and I don\u0027t see an actual drawback in keeping both in the spec at the same at the moment that\u0027s it Thanks hi this is Karthik thanks so much for the discussion and the slides at John I think it made it very clear I think what\u0027s very clear from the slides as well I think for a lot of you is that there are lots of gamma commonalities between on purpose between structure of Arts and shake em which means that many of the issues that we we will see about "
  },
  {
    "startTime": "01:16:47",
    "text": "authentication about message authentication and so on a completely orthogonal and will apply to both and there are many open questions which aren\u0027t both as well especially to do with authentication as well as we all see so and on the analysis indeed ChiCom is newer and has received less analysis and CRT but we hope to address that in the in the coming months and I have a have a foolproof that\u0027s what I\u0027m saying thank you yep no score so I think I differently Richard up in a different way I despite the fact they the system requires consistency um it doesn\u0027t require doesn\u0027t require complete lockstep behavior and so the impact of having um the one at a time updates of art is going to be an enormous number for any large grouping an enormous number of rejected updates they\u0027re predicated on the previous crypto state that they give bounce back and figure any significant message latency um and a significant rate of rate of key Church now if your change changing once a day this almost never happened but if you\u0027re changing people are if you have a significant size grouping before attempting to change like essentially every message the way like some systems do then you\u0027re gonna constantly have collisions and it\u0027s gonna be a lot of back and forth so um I do that\u0027s a significant issue in terms of handling the pairi the problem of figuring out which set supply to which a POC is a real issue though it\u0027s not it\u0027s important to recognize is that it\u0027s straightforward to label the a box essentially by which set of up case has been applied and so you can always figure out which keys apply to which messages apply which at buck what\u0027s difficult is effectively knowing when you can um because they\u0027re positively um because of multiple updates can be applied to say my buck what\u0027s difficult there\u0027s knowing um when you can discard the keys that are that required to basically it against the next a buck so you know I\u0027m at box zero and you know that includes and then includes basically updates ABC and D then at some point I say well I\u0027m in order to process a you\u0027ll get a and you have to keep that you\u0027re like epic zero plus a and you know and then in order to process B you have to have the zero this is your a POC and you can all and some point you\u0027d have to discard zero or devalue and it\u0027s the different questions my dad answer um but um we talked about a little bit so I think there are some ways to do that I\u0027m basically a effectively you need you you cute for some period of time afterwards and then you could and because you haven\u0027t because they\u0027re tres persistency guarantees everybody agrees when they can describe the keys and that so you will occasionally get people who get bounced but don\u0027t be very common um so on this isn\u0027t to say that I think that uh that we oughta destroyed have tree can um I think what I would say is going back to let Stella said a few minutes ago it seems to me that in terms of properties there\u0027s a reservable properties tree has larger superiors rural poverty start however it\u0027s less clear that it\u0027s like that it\u0027s safe um I don\u0027t have a safe but like treat it\u0027s like less less clear we reach "
  },
  {
    "startTime": "01:19:49",
    "text": "weekend dinars um so I think well I on the other hand we\u0027re also not frozen ship to protocol today so ho-hum I think we ought to do is operating the assumption that both of these are secure which may be false but operated as a moment on and attempt to attempt to sort of work out as soon as possible what this our operational details of each one of them is and if we convince ourselves that which one ever only thing\u0027s operational superior we should like cross the other one on the draft and put it in some like you know it\u0027s get so we can like just put it in some stash and get back to it later um and you know tape but hit that one either graft temporarily and perceive with the other one and I lost it today but like perhaps that you normally do that and but relatively soon and then pushing the other one and if it turns out that like there\u0027s a serious problem then we have the other one sitting in the back burner for us to pull back out but having to drop I mean given that we\u0027re not proven your ship tomorrow having to alternative mechanisms to sort of reason about it I think makes life harder just add to your point of about tree can can definitely merge updates in a way the tops art cons catriel did have some questions about whether pcs is actually preserved when that happens so it could be the emerging updates to no effect or to no security that binky doc as responsible ad just I want to point out please do not send the document to Dyess today is GE that has both options in it unless you have some like compelling difference between them that would cause even want to pick and you know if that means keeping both in the document and it\u0027s low per coin after work last call I\u0027m totally fine with that raha Robert again so just want to emphasize the update complexity and the last slide here so particularly for passive participants which is all of them except the sender there is a huge performance difference between art and tree cam and we were saying earlier that we might want to have some recommendation on how frequently keys should be updated so in large groups and we\u0027ve been talking about up to 50,000 so far that will lead to a lot of handshake messages a lot of updates that all need to be processed by all participants all the time before you can actually even decrypt the next message so that\u0027s a very high load during an idle time basically even if nobody is really writing anything so trinka Muses hashes which are incredibly fast compared to public key operations or diffie-hellman operations like in art so I think this is something we should absolutely keep in mind and right now a tree can on the performance side seems to stand out quite a bit absolutely so just to compound the issue Zekrom ention this is Richard Barnes in addition to the when do I throw away state question if you allow concurrent "
  },
  {
    "startTime": "01:22:49",
    "text": "updates you also have a question of what when I want to update myself what state do I build on top of I mean in in the worst case here you can imagine this branching tree of states that everyone has to has to maintain in Trika so it seems like you start at zero a updates a a B and C update some and then someone updates on top of a be someone up that\u0027s on top of B C and you have at least this kind of woven texture of updates um I mean so I don\u0027t think maybe take this offline I mean there\u0027s a there\u0027s a temporary variable because you I mean it\u0027s absolutely true that um so so I guess I mean when you say updates I mean I mean any any any given set um I mean so that may be records going I think is that within any given set you you know updates we\u0027re kind of flat and parallel but when you do something like an add or remove that does bump-bump to the next yes and so you know you do have to have kind of a convergence algorithm to decide on which of those states because you need for them to choose consistently or else you get ramification so that that\u0027s one observation I had another one but I\u0027ve forgotten it the way forward I was going to propose is that I think we\u0027re going to propose at the end of meeting we get together in September and talk about things I think one thing it might be useful to do is kind of keep this ambiguous until then and like try and do some initial code see how big the performance difference is see how big the message size differences are and so we can kind of take some quantitative measurements to see how the different how bad the differences look and I\u0027ve just remembered the other point I was going to make which is I think one I\u0027m not sure if you mentioned this or you mentioned they have the same underlying tree structure which seems to indicate that they can be hybridized which is probably pissing off catriel and Karthik even more than they already are but you know if we see that say you know updates are going to be super frequent and so we want them to be performance and we\u0027re willing to take message overhead for that maybe we use tree CEM for update messages but for adds and deletes we use a rt4 because we want them to be small I mean I don\u0027t have a preferred solution here but I\u0027m just wanted to point out that that those solutions I believe are possible if we can you know dot the i\u0027s and cross the t\u0027s and you know convince the a week we get assurance from the academics that it\u0027s okay to do that so that would require multiple traits right same structure but different trees because they keep the internal keys are totally different the internal keys are derived in different ways but ultimately they\u0027re still just the H keys oh well so "
  },
  {
    "startTime": "01:25:52",
    "text": "so assuming assuming we\u0027re using something like ec IES for the public key encryption so assuming we have algorithmic consistency between the two comments from the jabber facepalm and it\u0027s from katrell and benjamin both Cheban say if you decide to go for it with both options for now I think maybe useful if we at least mentioned in more detail what the advantages and the disadvantages are maybe in a separate draft or maybe in the same in the same draft I think that we will use from an implementation point of view sure in Metamora and we also know respond to rafael comment towards the performance of the hashing complete Richard and John correct me if I\u0027m wrong there is still log n public encryption right it\u0027s not only ashes sure yeah great how we move forward all right so we\u0027re going to move forward with NASA\u0027s protection Ben can you step up to the remote stage a German British good okay sorry okay so right now so I\u0027m gonna discuss a bit of message protection which is currently not in the draft next slide please again please thank you so right now in the in the the protocol document are basically nothing about message protection which is obviously a big part of what we want to achieve here so there are multiple possibilities about that we could actually to include the message protection part inside the protocol spec or we could do it with side my personal "
  },
  {
    "startTime": "01:28:53",
    "text": "opinion is that we could we could put that in the photo calls back because it sort of makes sense but we need to define anything so the the main point of message protection right is to go from the unshaken schedule that\u0027s been shown by many people before to go to the let\u0027s say let\u0027s call it the applications be scheduled so basically going from the epic secret the group epoch secret to the encryption of application messages and to do that we did this schedule this application key schedule and we need a set of algorithms and to define the objects with that we really want to encrypt right next site so that\u0027s the current that\u0027s what he\u0027s currently in the protocol spec right on shaky schedule so basically it\u0027s does work for both after and 3 km it\u0027s completely sort of separated because the update secret as you see on the left is generated from the hood secret of the trick M or arteries then you derive a goopy goopy pop secret which is basically the most important the most important part of the protocol of the of the secret because everything in the Hoopoe Park is going to be based on that thing so depending on the security properties that wants we\u0027ll need to keep that around or not for a certain time it\u0027s it on right now the message master secret which is which I called the application secret because it\u0027s it\u0027s at the moment used to to compute keys etc is the most important parts what what what can happen is actually which derive the keys from that secret from the application secret so like basically completely splitting the the the uncheck part from the messaging part while of course everything every keep a graphic a keys that is going to be used to encrypt most application messages is obviously dependent of the of debug secrets in terms of security next slide please so um from this application secret we could there are too many ways of deriving keys right we could do many things we could directly hatch this application secret or we could expand extract and explain this this secret to get a Adi GG\u0027s you could even directly imagine instead of having this application this application secret hack tatted you could imagine instead having directly expanding all the entries for the end participants at that point and I\u0027ll explain why it\u0027s actually "
  },
  {
    "startTime": "01:31:53",
    "text": "a different approach which has different security properties so if you consider that you have this application secret there are multiple ways of going right you can directly who hatch at this group secret this application secret in two ways either in interleaving thus under contribution or in parallel meaning that you can either for this application if you had one forged client and an hard set independently these this these secret chains or you can ask for each a participant to each sender to Hajj set its next message key from that from the same who touch it and those are very different very different properties in terms of the security properties as some sort of the same but the forward secrecy is not exactly the same because you need to keep around more more things in the case where you your watch set per participant so let me show you let me show you the some examples next slide please so here is for example it\u0027s a completely example nobody thing is in the but nothing is set yet and we discussed there are many there are basically as much as as much as many different key schedule as you want but there are basically these two categories of person who had set of box on the hatchet so it is an example of who pockets you have like the initial application secrets from which you derive the sender authorize an AGP and unknowns and this application secrets is going to be hot shattered in a way that each sander is going to contribute to that hatchet so this is this is nice because it so loose to group each participant to keep one who project but it\u0027s actually bad because it it forces sequentiality of the of the updates right so in some sense it\u0027s a it\u0027s not good for for parallelism and it\u0027s actually it\u0027s very wrong for for out of order you can\u0027t really do it about messaging out of this thing next slide please and then you have the the per participant case so you can next slide please where you could actually from the initial group application secrets derive many applications initial application secrets one top participant and Hutch said this participant application see catch instead meaning that is no completely independent it sits under as it one hot shot basically what\u0027s mostly what is done in current protocols right you you had set "
  },
  {
    "startTime": "01:34:53",
    "text": "independently of course we don\u0027t have the experience of multi-party but large experience of beauty a large number of participants in in groups but the for that scenario the drawback the benefit is that you can actually encrypt in in parallel and send messages in parallel out of order even if you skip if even if you here there are two messages from the same sender as long as you keep the key n minus 1 you can recompute n n plus 1 and plus 2 the the obvious thing is that this is for what you could but this is not this does not have pcs right because you are sitting forward doesn\u0027t give you pcs only changing and in that way if you want pcs for messages you only can hatch at the you need to update the group secret deepak secret so that\u0027s very different so there are three basically the very different approaches well one is you directly driving n keys or one group an application secret or one application secret for each update to the group and you only have one set of keys per participant for each epoch good or you can you can basically have forward secrecy for the keys of the the keys for messages but you don\u0027t have pcs until you refresh to group secret that\u0027s that\u0027s my understanding next next slide please so that so the study I showed before was basically TLS based meaning that there is can you go back sorry and there is a from the application secret you actually F expand level an AGG and an HIV so that\u0027s really useful because it\u0027s a it\u0027s it\u0027s good for misuse nonsense it\u0027s good for fighting against using the notes because for each message you can imagine you catching the participant application secret and you get a new idea and in you key so you don\u0027t risk using the the notes so that\u0027s very TLS based because it\u0027s a it has like the right key and the right AV that are mixed in back into the application secret ratcheting chain and there is the the next slide and there is a proposal that\u0027s been done that boost proposals are actually input requests right now on the on the repo this is a proposal from alexei that basically is very similar it\u0027s a powerful participant hatchet where small like signal in some sense why you expand both the change secret "
  },
  {
    "startTime": "01:37:55",
    "text": "message key nonce and you change the chain secret but you don\u0027t include the message key in the in the chain and bush both are reasonable approaches we still I mean we can do any things as I said all of those things should first come from defining exactly precisely the the security properties we want for messages for keys and for the group epoch secret because those properties are very different depending on if you want and the the method will show that we have to adapt depending on which properties we want will be very different typically rejecting rejecting the application secrets inside the same epoch or only generating keys for for every participant once epoch secret next please so as I said basically to balance and I don\u0027t see any good way of solving that problem now so it\u0027s it needs a lot of description I don\u0027t think it\u0027s ready but I\u0027m pretty sure we can do something that works and I think everybody is convinced after the discussions we had with each other informally that we can make it using any of those ways but it\u0027s unclear what the exact security properties are at the moment so we need to define them more so goes group hatching you reduce complexity you improve so for what secrecy in the sense that you don\u0027t keep around application secrets per participants if you don\u0027t use them because you watch it everything so you only one such application secrets that\u0027s that\u0027s updated frequently but it doesn\u0027t handle out of order and it\u0027s the opposite for the perversion or the profit thing okay next piece so in that setting in that setting one Becker okay yeah I don\u0027t understand this last point which one we can forward secrecy okay so that\u0027s a sort of abusive term saying that you you are for what secret but the the the the duration in time where you keep the keys is different if you keep the keys for like two weeks without updating the group secret or like two years or whatever you you still have for you as long as you are for what you cut it\u0027s fine but the way you have to store the keys you have to keep them for a long time it\u0027s not the same thing as if you touch it the key for every second or something so there\u0027s no message "
  },
  {
    "startTime": "01:40:56",
    "text": "encrypted of them so it doesn\u0027t matter yeah yeah but if you want hit one message and then you keep out the next key for the next for the next message encryption and you wait for long time then you you can lose that key and this key is gonna be useful at some point III don\u0027t understand this this doesn\u0027t seem like this is a policy right I mean first of that if the group with the group is ratcheting then the and every time if the group ratchets then then you afford secrecy because the key to the whole Keys pulling away and forward to Chris\u0027s back you already beat the future kids we\u0027ve already been used so if the keys just sitting there like this it has never been used at understand what the problem is all the group it\u0027s fine but the point here is not necessarily to like the point of the weekend for what secrecy is like it as I said so in abusive term to say that we should also consider in this in doubt and the security measurements we do like in the security proofs keeping your own keys is always bad right so my point was just to say we should be careful all along we keep the keys when we do that that\u0027s fine that\u0027s all I mean I assume keys which don\u0027t used to encrypt anything so I think keep them around is probably ok I guess that maybe was some formal property referring to but I\u0027m not following with actual security property you\u0027re trying to talk about it so maybe be able to I mean III guess it\u0027s probably not practical to do at this particular point ok might be nuts but uh because I don\u0027t think it\u0027s a high point in determining which of these is a more attractive protector system but uh but but I also I mean anyway I do agree that the participant 1 is the abuse is a preferable choice I mean in my opinion but I didn\u0027t say that ok can I go on a you have one more slide and then ok can you go to slide 11 next one again the getting the next one again please oh yeah this one okay so there are as I said there are two to pass we need to handle the application fee schedule and the message protection itself yeah the encryption I think for for for the message inscription we can use very straightforward things like AIG encrypted voicing as discussed before in emerge talk I think there is the padding issue so I wrote some initial text in a pull request and I\u0027m in favor of as I said before I\u0027m in favor of patting I mean I\u0027m in favor of MLS providing a mechanism and leave it to the application to decide all to use it but my point is that we should not like lick the length of the application they suggest to everyone for which for 4h "
  },
  {
    "startTime": "01:43:58",
    "text": "encryption and then they are depending on oh you want auntie Kate currently the the authentication is done by using signatures depending on oh you authenticates there are things that you should but inside the ciphertext or not typically right now having the signature for authenticating the participant strongly meaning knowing which educating the specific parties a specific center to other parties members of the group is done using signatures in the current setting we can actually encrypt that signatures in patches inside the ciphertext and it could be safe because we have an implicit or education for party on the fact that if you can decrypt the ciphertext it means you have the idea the IAD keys to decrypt the ciphertext meaning you are a member of the group and that\u0027s all next next slide I think so in a way to move forward is I think since now we have nothing in the in the text safe approach would be to defeat to define an initial message protocol protection text where we use something very straightforward that I think people can reasonably agree on typically having like per participant purchasing scheme using ahd ciphers optional padding and optional signature of the of the plaintext in the ciphertext and there are basically two pull requests on the on the on the specs that Poe is that and I see cam done so yeah I agree we should go ahead and get some stuff in the document here I\u0027m put a stake in the ground and start actually writing is protocol in terms of the key schedule could we skip back to that slide as I figure it\u0027s probably going to be nope forward the comparison one that one for me the kind of killer app for the group ratcheting is the reduced storage if I\u0027m in a 10,000 person group in order to get any forward secrecy I have to generate and store 10,000 keys constrained devices and wave and wave I mean but also these divine Yahoo I\u0027ve got a an account then you know an app that has you know it\u0027s in 2,000 groups maybe so I think that that complexity advantage seems to me worthwhile to do the group ratcheting the thing at least to try it I don\u0027t think the out of order thing is going to be a big deal but I think that\u0027s something where experience will be helpful in determining whether it is actually empirically a big deal I think much like the the a RT versus tree came here I think what we should probably do technically is pick one of these go with it but keep the other one "
  },
  {
    "startTime": "01:46:58",
    "text": "in the back pocket if we need to switch it out I think this is a component that can be fairly modular lease with the swamp and swapped out in the future one other thing I would push back on the last slide is the this idea of optional signatures I think we my assertion here is that we always want to know where who a message is coming from I don\u0027t have any use cases for generally getting message that came from someone in this group and I don\u0027t so I would propose that we make the signature field mandatory built in always they\u0027re part of the message protections my take on that would be that maybe we can do it for unchecked messages and leave it to the application to design for the for the application messages I mean to a degree any work on a message protection format here is kind of optional for applications Els like the G TLS SRTP uses the TLS handshake with SRTP encapsulation so I mean in principle you could do the same thing here but I think for the default case we have here we should go ahead and and have that level of direct authentication this is dkg I\u0027ve just gonna plus one would echo said earlier about not seeing the forward secrecy advantages that were claimed for for group ratcheting and that yeah precipitous been spender sender seems like the clear wing to me yeah I said that Richard and I have a philosophical disagreement about the level of locks deafness of this protocol so um my concern actually is less about then necessarily out of ordering that about the receivers implementation of how much we know he needs to keep of all keys and like we\u0027ve spent an inordinate of time in quick and NLCS trying to reason about like what happens when things get really when you can cut over from state a to state B and then get like these messages from like you know random people the mailing list or not random people saying like I have found in this case where if you do the following 19 things like things go to yet and like so that and what those things trying to is like incredibly ornate receiver side algorithms for freaking out where you can timeout keying betrayal and given that as far as I can tell the only effectively only cost here that anybody that is actually bearing is 16 not 16 to 32 octet submissive state for like basically for peer and that like every messaging app which I\u0027m familiar like a keeps like the transcript for the messages and be like keeps a list of everybody in every group and and all those things like much larger than like the Nike material I just like that seems like a ripped making like a lot of program like City for like like the first economy is saving like a really really small "
  },
  {
    "startTime": "01:49:59",
    "text": "amounts of data just does not seem like a reasonable structure yeah refer over it again can we go back to the comparison slide so initially at the same reaction then Richard when I sort of all the state but then and more we take her when you really think about that what that means it\u0027s we we talk about kilowatt and it\u0027s also not clear if we have to keep all of it potentially this is only between two group stages and where we have to keep stuff we don\u0027t have to keep things for passive participants in very large groups it\u0027s potentially still not a lot of state we have to keep so my opinion this strongly strongly favor the second one for the participant ratcheting because the other one means that we might again run into the servation problem if we conflate that with handshake messages so we typically would expect text message to be relatively high frequency compared to a handshake messages which means that there is a real risk of starvation there which we don\u0027t really have if we have a per participant ratchet this is a decay cheap rock scene for Karthik Karthik asks it is unclear what the security guarantees of application key ratcheting are it only provides forward secrecy against a very weak attacker and only if all receivers including passive receivers regularly delete all the application keys so a question is do we even need application key ratcheting as long as the group epic secret is frequently enough updated exactly so that\u0027s the that\u0027s the thing I mentioned at the beginning at the very beginning of a PCS about directly extracting one set of n keys for son dr epoch secrets directly at the beginning and depending on the exact Prakash\u0027s we want that might actually do a new one of the only way to get the PCs for the check message for the application is interesting and maybe so maybe while you are a child here you can talk about I didn\u0027t mention the the new three bays the application key schedule thing that we were thinking about when we can give a word on that too because and I think I\u0027ve forgotten what it was we talked about so basically we discussed the fact that we might be able to improve on the storage for the participants a cheating thing by having a tree structures to store the the yes now so you could build a structure where you had started with an application secret and you know hashed it in two directions to cover halves of the group and then so on out so you have to the "
  },
  {
    "startTime": "01:53:01",
    "text": "leaves to seed out those roots and that way you could only store intermediate nodes in the tree and an opportunistic the generate things as people transmit it\u0027s a mild optimization over the person they\u0027re ratcheting I wanted to come up and respond to eckers notes about reordering I expect on this topic we actually don\u0027t disagree about lockstep penis I\u0027m fully um I don\u0027t think there\u0027s any need to assume lockstep for messages I think there\u0027s a sort of reorder in here we\u0027re gonna have a reordering window in the receiver and I I think that actually argues for the grouped ratcheting though because if I\u0027ve got a buff you know a fixed-size buffer for real for maintaining keys for reordering in the person they\u0027re ratcheting I\u0027ve got you know I\u0027ve got to maintain a number of participants times reorder steps keys in order to have reorder steps keys for each participant versus in the application in the group ratcheting context I only have to maintain reorder steps keys now you disagree the issue is that into a participant reordering is much more extreme than interpretive reordering so if like if I I mean that like what wrong way which participant gets reordered right in one way one which worrying happens is I is I send a message we might end current key but I\u0027m not online and so now I come back online in ten minutes and now that message is like way to hell reorders but everything else and so um and so but that\u0027s like different but but if I reorder like if message you get reordered between the things that transmitted it\u0027s generally common that that you know that what\u0027s happens you had a message loss so that we were transmitted like almost immediately but so that really mean if you\u0027re also be narrow but if you want to be able like if you if you mean look to the math if you have a group that has you know your group that has you know the ten messages a minute which is an uncommon um and you\u0027re offline for ten minutes you\u0027re not looking you\u0027re now looking at like a hundred messages wearing window my ten minutes like easy right am it\u0027s like is a different you know your cargos in the tunnel or you know you\u0027re you go in the elevator and so um so II was just uncomfortable but even in your example I have to maintain you know a hundred messy back log of application secrets in order to be able to do that reordering and which is a lot less than you ten thousand that was the size of the group well I depending on like how much were in really tolerate I mean like I seen slack messages ruler for hours two days um someone you know so he was an airplane right on but um more generally you also don\u0027t need to retain like you also don\u0027t the only reason is that the "
  },
  {
    "startTime": "01:56:02",
    "text": "only reason that you think you need to retain on like a long ass a long wind like that is it\u0027s like the research is a strike right mister right um so basically um you know you don\u0027t need it like because the keys are generally argent are generally a forward chain right what you basically what basically that the dynastar she maintained is effectively the next hop and is basically all is basically like okay depends on how you bought that does number waste a bullet I think in Benjamin\u0027s proposal it\u0027s not a strike register because the the application keys aren\u0027t single-use so so you could do it by maintaining a single end key like they\u0027re the first thing from which you can drive for you in any case like I\u0027m not sure how to resolve this but like yeah like you you see I using it under some under some impression that like the amount of storage of L to the client is incredibly small whereas these clients are like an enormous amount of storage um and they\u0027re very powerful and like and and and by and large I say they they store that they store the transcript all the messages which they can amass a larger and like any possible Suffolk a material so like unless you can demonstrate that light you know it\u0027s like like is like I want to see an argument that like use the store like mounds of data that are comparable to like you know the size of like the photos of your iPhone before I\u0027d actually can throw this being an issue uh Matthew Miller I think at the end here I\u0027m basically just agreeing with that career and I think it is important to remember like when we\u0027re talking about high transmission you know high frequency of transmission sometimes groups get super super SuperDuper active and trying to deal with that kind of problem I mean I\u0027ve seen this in the past with other clients where per per message ratcheted keys are in use and there\u0027s been essentially the group becomes unusable for a people for a period of time until everybody finally sinks back up so if anything I\u0027d either be arguing for you know the per participant Center or just not worry about it for right now it\u0027s our clothesline after John so we have time for the next presentation tomorrow I agree with a correct story local authorities at least concerning this protocol like whatever lies how to design this so III disagree with supporting their it points at how come this historic is an issue for person directing I also think the other one as the course it is wrong so I guess there is no red actually things with person directly I think it\u0027s it for me it\u0027s intuitive it makes more sense John Milliken so I I just wanted to respond to a kiss point but I I do broadly agree with actually that I don\u0027t think we need to worry too much about storage space but I like to be careful that we don\u0027t build for modern iPhones and we build for low-end circa 2012 devices or "
  },
  {
    "startTime": "01:59:02",
    "text": "something because we still support them in cosmetics have just we were briefly chatting on the jabber came to the conclusion that if you want per per participant signatures which Barnes said he wants that means you need the each person\u0027s public key which is gonna be a lot bigger than this key anyway also so Benjamin it sounds like you and I should chat and you know game out some models and provide some quantitative estimate on what we thanks Ben thank you yeah authentication and Oh gets quicker all right so those of you who have read the protocol draft recently have seen there\u0027s a fairly basic fairly naive authentication framework in there assumes that each participant has a long-term identity key and that user in it keys and group in it keys are signed with those identity keys and in the group in a key case we also include a proof of that proof that the add that identity key is a member of the group by committing to a Merkel tree over the identities in the group and have providing a proof of inclusion in the group feedback here okay that\u0027s what I was hearing a little bit likewise when we have when we send handshake messages we include a signature by the identity key and a proof of inclusion one thing we\u0027ll need to keep an eye on as we go forward is that you know the authentication we\u0027re running it and long run is going to be about identities you know email addresses or usernames or something like that not public keys and so we\u0027ll need to add credentials at some point which we don\u0027t have in the current draft so want to step back briefly and think about requirements for authentication what do we want to verify at one now this is again to the academics this is not the precise definitions it\u0027s kind of taking a functional view of what does you know a participant in a group want to verify at different points in the life cycle if it\u0027s it\u0027s interaction with the group so when a client connects to the group it\u0027s going to want to verify who the other members are in the group so it knows who its encrypting to when it encrypts to the group so this is something in which I think Karthik and Benjamin might disagree on because there\u0027s some ideas that you might just want to know that when you receive something it\u0027s from the group and so you might not care about who the other members are in the group likewise when you receive a message you want to verify something about who it\u0027s coming from I\u0027m going to assert that we should verify the precise identity of the sender "
  },
  {
    "startTime": "02:02:03",
    "text": "either at you know a user level or at a device level you could also argue as I think Karthik and Benjamin have that you might want only want to verify that at the group membership level we can have some discussion about that if I\u0027m in a group already and someone joins will need to have a way to verify the identity of that new member it\u0027s kind of update the roster we have the raw so the client has the idea the client has of who\u0027s in the group and when we remove the interesting case here one that\u0027s different from the others is that removal requires knowing a co path for another node so this is different because it\u0027s not about identity verification it\u0027s about verifying that you have the same crypto state as the rest of the group so just to graph that out if we imagine the case where a node F in this industry wants to evict node J as John was detailing earlier F needs to generate an update for J which means it needs to generate those or solid orange nodes on the paths from J to the root and in order to generate those nodes with a new leaf value for J that J doesn\u0027t know it needs to have those orange outlined boxes on one of those labeled I and there\u0027s other an arrow pointing to the other but F under normal otherwise operation of the protocol ignoring removal is only going to have its own direct path and public keys for the co path and so it needs to have a way to authentication distribution to distribute the notes but but more importantly eff needs to be able to verify that when it gets these Co path nodes from some source that they\u0027re the right Co path notes and if you if you want have to be able to evict anyone else in the tree then it needs to have the whole state of the tree needs to have the co path for every note which means it needs to have the public keys for every node in the tree and so we need some channel for authenticated effectively authenticated distribution of the tree so we have kind of two classes of authentication problem authenticating identities authenticating the tree we also kind of - I\u0027ll say functional - kind of points in the lifecycle of the group where you need to verify things you have points where you are already a member of the group and you\u0027re trying to authenticate something about the group so I\u0027m an incremental change about the group and you have the initialization step where you\u0027re joining the group and you need to initialize your state with the authenticated roster so I kind of treat that on connect initialization question as separate from the once you\u0027re connected to the group cases so I think these post Connect cases are a little bit easier in particular message okay authentication is is really just a signature vendor might want to make it optional but I think we should we should require this in the current draft we include a "
  },
  {
    "startTime": "02:05:03",
    "text": "signature together with a membership proof you know that proof that the identity key that signed the message is recognized or part of the Markel tree of identity keys that was committed in the group init key that kind of defines the group that\u0027s handy if you only want to cache on the endpoints that commitment the head of the Merkel tree and not worry about storing the entire list of identity keys but you know maybe we\u0027re not worried about storing a ton of stuff and we\u0027re willing to cash all the identity keys in that case you don\u0027t need the membership person we can leave them out of the protocol and as Benjamin just presented there was you know he\u0027s got some stuff in his pea about how exactly to encode the signature it\u0027s not you know there\u0027s no magic it\u0027s just a signature ever the message to authenticate that it came from this public key for authenticating new joiners I think it\u0027s similarly pretty simple it\u0027s going to be about signing this the user init key that\u0027s presented as part of a group initiated ad or the user add message that\u0027s presented as part of a user initiated ad signing that those the content of those messages with the identity key and presenting a credential at that stage I think the the concretely and I forgive I apologize for presenting this a slider and not a draft but I think the right answer here which will probably get it in draft soon is something that kind of looks Sigma like so if you\u0027re familiar with TLS the way the thin ocation is done in TLS is the authenticating party sends a certificate message that sends a certificate verify message with a signature over the handshake transcript and the certificate and then it sends a finished message which has a Mac over the handshake transcript the certificate message in the certificate verify message so you have effectively a a consent of the private key holder to join the group and then with the Mac under the new group key a kind of consent of the group member to have that identity so I think we can kind of map that into this group space by doing by maintaining some transcript hash which I\u0027ll talk about on the subsequent slide maintaining some transcript hash assuming this lockstep handshake process assuming consistency and then at incorporating that into the message authentication with the signature and the corresponding Mac so so that\u0027s kind of the cases where the authenticating party is already a member of the group or where the part they\u0027re relying party verifying the authentication is already a member of the group initialization is a little more challenging because it\u0027s linear size and Linear\u0027s not a word we really like around this group you really prefer log or constant things but you know when you\u0027re talking about the list of members in a group that\u0027s kind of irreducibly linear size you have to talk about and things and when we\u0027re talking about also authenticating the tree you have to n intermediate tree nodes roughly give "
  },
  {
    "startTime": "02:08:04",
    "text": "or take you know plus or minus one or two notes so it\u0027s roughly twice the number of participants in the group so we have kind of identities and identity keys to talk about the members of the group and then roughly two entry nodes I mean of course we need the authentication information to prove this is all correct one observation I think is useful here is that handshake messages that are exchanged in the course of the protocol carry a lot of the information we\u0027re interested in here so whenever a node sends out say an update or a user add they are sending out the public keys along their direct path to the root and so if you watch the activity of a group over time you can build up the state of the tree in particular if you observe the last message sent by each participant in the group you can kind of stack those on top of one another and then you have the you know the the state of the tree at the end this is kind of nice and if you have the authentication and then the information you need to authenticate that those are from real members of the group you have an authenticated copy of the tree and you know the identities of the participants so this kind of suggests that we could use messages themselves the handshake messages that have been sent within the group as a way to distribute the tree and to distribute the roster so like I said if you see the tree or if you download it from somewhere or if you see these handshake messages or if you download it from somewhere you can reconstruct the true the public state of the tree as it is agreed by the participants now it\u0027s you know I said we hated linear stuff is even worse than linear now we have n log n things to download but again I think that\u0027s it\u0027s not unavoidable but it\u0027s better than some alternatives you can imagine one challenge here is that if we if you\u0027re going to take this approach of using the messages you need to verify that so you want to make sure you\u0027ve got the latest message from each participant and that the server has it\u0027s kind of injected a message in sequence or omitted one injection being a bigger risk so you need to have some idea of the whole sequence over the set of messages you need so in this case you know see updates and then APA and then B and a update at the very end and so you need in order to get the tree you need those messages from a B and C but in order to trust that those are the correct messages for you to build your tree off of you need some information about all of those messages in the middle and so now we\u0027ve gone from linear to law and law again now we\u0027re at you know lower bounded by n log n we may need more I think we can do a little bit better than "
  },
  {
    "startTime": "02:11:05",
    "text": "n log n though we\u0027ve already said that we need some degree of hash of transcripts recording we\u0027ll need you know transcript hashes to do this signal like stuff and so we\u0027re already kind of it\u0027s kind of hints at building a hash chain out of handshake messages so at the bottom here I\u0027ve got kind of a cartoon you know you you initialize off some hash and then whenever you send they have a handshake you hash it together with the previous handshake hash and and has shane along in that way so you can imagine you know distributing these the the handshake messages that you need in toto to build the tree along with basically the sequence of hashes that demonstrate that there is a sequence there is a sequence of handshake messages in the middle of the connects these so you at least know that you\u0027ve got a subset of subsequence of the the actual sequence of handshake messages likewise one thing Rafael and I discussed that at the hackathon last time when we first realized we had this tree authentication problem is that you could encode in the in the group in a key a commitment to the current state of the tree and you know we like to use Merkel trees for commitments because they compress you down to one hash value and so the figure on the right here is a tree on a tree nice thing about the tree stroker we\u0027re using is that it can very easily be mapped to a flat list of nodes and so you could take the actual ratchet tree at the bottom not those nodes up into a list and then build a Merkel tree on top of that that would give you a commitment to the tree and so now you\u0027ve got assurance that the message of the handshake messages you\u0027re getting are correctly from the sequence of handshake messages you know the handshake history of the group and using this commitment to the tree you can verify that the tree you\u0027ve built out of those messages has the correct uh.could the correct collection of nodes for the whole tree so this is very much kind of how should we do things forward this should really have been in the draft if I were doing this that properly but this is basically my rough proposal for what I think we should be doing to build out an authentication infrastructure in the next groove of the draft it\u0027s obviously needs a lot more detail in order to be implementable in the room be really protocol but I thought I\u0027d presented here too to see if it was looking plausible to folks so the rough outline is that for these post connection cases where I\u0027m verifying individual messages or her own joins to the group will have just you know signatures as you would expect and for joiners where we authenticate identities will have some signal like thing we\u0027re rehashing where we bring in transcript the hash of the prior transcript and we do the signature and Mac dance to cover credentials and have the counter signing account or Mac I guess from the group membership but then for initialization of new joiners the will take the "
  },
  {
    "startTime": "02:14:07",
    "text": "approach of using the the messages themselves as the distribution channel there as the things we expect to be passed around by the distribution by the was a delivery service you know somehow that the delivery service will range from this much stuff to get passed around so that endpoints can members of the group can you know verify that they\u0027ve got the right sequence they can build up the tree they can verify the identities that have sent these messages so at this point I\u0027ll just open up for discussion does this look good what looks good what looks bad what looks challenging what did I screw up consider let\u0027s start with Karthik from online and he disappeared okay get back in the queue Karthik and will add you John okay John Milliken so a couple of points one is that in in the situations where where clients do have a full list of the people involved in the conversation why so for the remove case why not just store the entire tree on the client because that\u0027s it\u0027s still it\u0027s only double the size right it\u0027s there\u0027s no order of magnitude difference yeah yeah I mean if I think that it\u0027s totally plausible that you could have clients store the entire tree locally you still need to initialize I think the hard part is initializing your new clients with with the tree not when when they start out when they join the group show so but a couple of concerns with your proposal one is the ship it\u0027s seems to require the delivery service to store a lot more metadata longer term about the conversation and I think potentially a lot of us would like to avoid that if possible so this wondering why not have just a have the service store the entire tree and the commitment from one of the members to the tree in a Merkle tree yeah so Rafael and I were talking about this yesterday and one of the things he observed was if you have this commitment to the the tree over the tree then the server could you know cache the tree and deliver that to people safely and the server could strip out the identity information of messages it only needs to keep the tree bits of the messages show and not the identity but so you could reduce the amount of metadata that way you\u0027d still ultimately need to get the identity of information somewhere sure so that you know who you\u0027re talking to but you could get that in a peer-to-peer fashion but this then may reduce the requirements to Oh n storage of the of the tree states various three states now that\u0027s true yeah yeah okay will do Karthik now I guess first is that we "
  },
  {
    "startTime": "02:17:13",
    "text": "seem to be responding check transcript for for the Sigma and I would like that the group secret box is already mixed again pretty much attention so we might be drive some the box secret you know that\u0027s a slightly more concern is that although we are thinking that well read I suspect if we end up update because yes and if this is all compromised then we can\u0027t just say that we got your key indicating voltage we want to roll to which means we need student fresh signature and somehow he and so on so I think it\u0027s a bit more you want come from security code signature and then that was a little bit garbled here the thing I was nodding about at the end was that a and I thought I heard Karthik saying that it\u0027s difficult to get post compromised security with regard to signature keys as well as the the contributory leaf leaf secrets we\u0027re talking about here of the confidentiality keys yeah so that is a property of the proposal I\u0027m making here is the identity keys are long lived and so this doesn\u0027t this this game overall doesn\u0027t provide pcs with regard to the signature keys I think I think Benjamin has thoughts um about how you might do that by say initializing with proof by with a long term key and then doing future signatures with a different key authorizing a different key that could do future signatures that personally I\u0027m less worried about these authentication keys than the confidentiality keys although I\u0027m not sure why I say that would be interested in people\u0027s thoughts about whether it\u0027s worthwhile the to aspire to piece some sort of pcs with regard to signature keys I Lucia Ballard from Apple again um so I haven\u0027t seen this before so it might be misunderstanding but what are the authentication properties for receivers of messages like if there\u0027s a someone who hasn\u0027t sent a message for a long time in the group how long does it take for me to verify that they are in fact - I think they are when I\u0027m sending a message to them so just to make sure I understand the question are you saying "
  },
  {
    "startTime": "02:20:16",
    "text": "there is a sender who hasn\u0027t sent for a long time and now they send and the question is how long does it take for the receiver what was the effort for the receiver to verify their identity so it\u0027s the other way around so if I\u0027m a sender and I\u0027m sending to a large group and there\u0027s some like silent members of that group but I want to make sure that their identity is in fact the identity I think it is how long does that take time so you may have had so the situation with a sort of Rises like you kind of senators offline for a long time he may have missed some folks joining the group and he\u0027s the updated state it\u0027s an interesting question I had mostly been thinking about this as in the context where you are seeing joins as they happen I think the way I would be tempted to think about that the simplistic way it would be in kind of a fast forward context where I the the the simple long way you might think about building is to have the server cache the handshake transcripts and then when someone comes online after a long time they just Elmo does as the fast-forward version of the handshake transcript which means you gotta read forward but you\u0027re gonna have to do that anyway so that you have them the confidentiality keys you need to transmit mmm so yeah I think it\u0027s it\u0027s a little expensive but at least the messaging overhead you can offload to a server and a server cache well have been asked the next question and then because there\u0027s a few things after this way okay so regarding your last point deniability the original so tired and that\u0027s why I said optional signature in my when I discussed it is because I I don\u0027t like I personally don\u0027t like the idea of signing everything with the long term identity key but that doesn\u0027t mean we can\u0027t get better privacy out of it as you mentioned we could my thinking is that we could actually use ephemeral signature of keys for get to at least you get FS for signature keys I\u0027m not sure about pcs but at least you get FS and the general deniability point is if you you could I\u0027m not sure we might get in a be able to get deniability if we rapture the link between the initial ethanol signature key from the long-term identity key by let\u0027s say the user is establishing one-to-one deniable channel to send is own private initial XML signature key so there are there are things that we could do to get better things but we need to think a bit more about it well in general I mean I\u0027m not a magician is that we should not sign everything with "
  },
  {
    "startTime": "02:23:16",
    "text": "the long-term identity key so what I wondered is kind of in terms of order of operations it seems like these schemes for forward secrecy and signature keys which maybe adds up to deniability are sort of additive yeah in the sense that you could take a scheme that doesn\u0027t have that property and add on to it a mechanism for authorizing short-term scientist ease so I think I wonder if we should go ahead under the assumption for now that we have long term identity keys and then we can consider later how that might be extended to have short term kind of signature key rotation okay that would be my operating concept almost you think that that would be that would make it too difficult to address it wasn\u0027t clear to me it might be fine I think it\u0027s awesome chef yeah I think that if we have that basic assumption of identities that being more trusted then this is a good good start to go and we\u0027ll refine delicious if that start with Sigma like protocols have some issues and I have maybe some basic equation which is continuation of one of previous equations do we want to give some exact combinations about the users that really want to be anonymous but that want some mechanisms that may be outer Bank mechanisms so that they are direct receivers of messages or senders to them can verify their identity but should we provide some out of bed mechanisms for that or should we just if some recommendations have to do it so if I am the new user I don\u0027t know anyone in the group and no one knows me but I know someone in personal and I want someone to trust me what is the mechanisms for me to be able to prove that I am program there are a lot of techniques in existing messengers for example in Vicker such that video call is just pronounced in your public key there can be some techniques based on Peck for example if you just transmit as short as four times and uses just indicates a shortened session those indicator of your public key so there\u0027s a lot of variety of options could if clarify what\u0027s your current positions on this and do we want to clarify this because we really want this to be to protect an immunity of the users who want this yeah so I think I\u0027ve I\u0027ve as I think in my head mentioned I "
  },
  {
    "startTime": "02:26:17",
    "text": "think for to a large degree the authentication service itself is fairly separate from this we need to have an integration point which I\u0027ve called credential here but I think we can keep that integration point fairly abstract so you can think of it as a certain you know normal x.509 certificate if you want but you could also insert something it\u0027s like if you want to do a fake thing you could put something in there that would say commit to a fake output as the identity value there the important thing is you need to identify to bind the identity which is the thing you\u0027re going to use in the authentication system to the public key with that you\u0027re going to use it in this system yes and I take point that really it\u0027s maybe unrelated to your current presentation you have a point of integration and it\u0027s all but regarding the group at all maybe your slides are more related to the things that any other so should we think of putting some black text to secure considerations about recommendations or techniques for initial authentication because I think that it\u0027s one the crucial point for practical security for example if you know a lot of strange stories with telegram in Russia and ways fight between enemy anonymity of the users and the mechanisms to protect this I think that it will be really good to add some recommendations about how to protect privacy but to be able to trust the US we want maybe as a new group that has been developed in IR AF PRG will be a good place to discuss this issue yeah I think that that\u0027s a totally good suggestion it puts you know kind of an outline and security considerations network with these privacy talks to to elaborate some other options again thank you let\u0027s be very brief because we have to do a home and we have three minutes left Rafa Robert again I try to be brief two things so one is both compromised security and there it was mentioned that there is a bit of a gap between the signature key and their group secret and so I know privilege setting you can compromise both if an attacker has access to the local storage of a device but there might be other ways of compromising the group secret where pcs is relevant for example when there is flaw in the crypto level in the and check messages basically you can get access to the group secret but in that case you still don\u0027t have access to the signature key so in that sense your gut feeling is sort of justified there that the signature keys are actually better protected because they\u0027re not being negotiated over any protocol the other thing is the last point on your last slide and that is deniability so I\u0027ve had a number of offline discussions with a number of people and the really the only common denominator there is that "
  },
  {
    "startTime": "02:29:17",
    "text": "everybody feels about it very strongly some of them are in favor of it others are absolutely opposed to it and they don\u0027t seem to be any meaningful common ground there for some consensus of what could be done so I think personally the the only way of going forward is to have optional deniability and the practical proposal here has been that we use this Sigma like mechanism to distribute an ephemeral signing key in a one-to-one way so this would practically work unfortunately it\u0027s quite expensive so it would be fantastic of course if someone has an idea on how to make that more efficient but it would be a start okay d could you any quick comment we\u0027ve got like yeah so I just wanted can you go back to the the signature thing just wanted to point out there\u0027s a particular potential user experience confusion here that we should give guidance on in the draft which is that you could in this scenario you could have a validation success for one for blue say and the validation failure for red and if we think that any validation failure should cause the same failure that\u0027s fine but if we think that there\u0027s something else that happens in some other way we should just be very clear that we expect both of them or none of them I think they both need to pass or if the message to work right so then but then if the inner one fail if anyone fails what we\u0027re now saying is that the Mak like you\u0027re not treating is that there\u0027s a Mac failure to think about what the consequences are there and we should put put guidance in the draft about what to do in that case absolutely Thanks so I think the key point here is that we know that there\u0027s a lot of open issues in the protocol draft um and I think that that\u0027s perfectly fine because otherwise we\u0027d be done in one meeting right that\u0027s not really the goal but I would like to get the working group process started and actually get that document adopted into the into the working group I see a show of hands who\u0027s read the protocol document good a large number we are now going to hum for working group abduction it is not set in stone it is not done it\u0027s gonna get revised so this is not like what\u0027s in there now is gonna stay because we know there\u0027s stuff that\u0027s missing in the line arts so please hum now if you would like to adopt this as a working group item for Martin if you would not like to adopt this as a working group item please home now okay so it\u0027s pretty clear we\u0027ll definitely take it to the list pkg was there stuff in the chopper only a hum of adoption on whatever to excellent thanks so notes up here some other things that we obviously have to talk about we are planning an interim since we kind of ran at a time here we think we could deal with some real head-to-head time for like a day or two we\u0027re not quite sure when that\u0027s gonna happen but right now the Nexus of people "
  },
  {
    "startTime": "02:32:19",
    "text": "that really are working on this or in San Francisco Berlin or London so think about that NDC so we\u0027ll get back to you you\u0027ll start seeing some messages on the list about confirming adoption of the to working group jobs thank you very much for your time "
  }
]