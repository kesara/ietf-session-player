[
  {
    "startTime": "00:02:07",
    "text": "hello everyone hello Pascal"
  },
  {
    "startTime": "00:06:04",
    "text": "okay so we are five U minutes below so let's start the meeting um so yes this is a JF meeting so the not well and the best practices apply so I expect by now you're all very aware of those best practices there is the code of conduct if you if you feel there are some misbehavior please contact the but Steam and then there is the the patent rules if you're aware of any IPR new IPR undisclosed IPS being discussed uh please refrain from discussing it or please announce this AP and with this um so our agenda for today has two main items um the first one is shic compression over 154 it's going to be careless presenting there is a new version of his draft and then we'll continue in your discussion on the architecture and some slides uh so yes a lot of new work has been published so at interior there is a new version of the protocol numbers for shik and that's where we probably have to update to ask for a next header as opposed to protocol type uh other than that the draft is pretty good pretty stable that's also where we are asking for nether for shake then there is the shake architecture version one which is out and and covers what we discussed last time um the state of the discussion it's not final it's just where we were um just to write it down and um then there is the uh flow compression by Anna and there should also be 54 I don't know why doesn't"
  },
  {
    "startTime": "00:08:01",
    "text": "show that carless has published um oh maybe it's at six low the uh HC sh hc4 2015 for we have requested a session for ATF 118 and so we got it it's going to be 90 minutes and it's going to be uh at 5:00 pm so the last session uh at uh in on Thursday we have asked for a big room and and the new thing we've done this time is we talk with car and we agreed to make the shic meeting adjacent to the six low meeting and that means that um if somebody just comes for one day he should be able to attend both meetings and with this uh caress if you want to to to take the ball and start sharing or or I can share for you and uh then pass you the ball it's say you prefer okay maybe if if you can share the slides we can see you I can barely hear you carless oh oh oh push the volume a little bit on my side I don't know how the others I push the can you can you hear me I can and it's just slow so I don't know what the are getting for me I have to the volume very high to to hear you so Ian is it okay yeah well it works pushing the volume it works okay okay I'll try to or you want to do it yourself K uh can can you maybe uh browse the slides for me please yes sure"
  },
  {
    "startTime": "00:10:03",
    "text": "now I can pass you the ball on them if you want okay well as As You Wish okay you should have control though yeah I have control okay thank you okay hello everyone so uh the idea the motivation for this presentation today is that uh for a while we haven't discussed this this document in a shik working group or lp1 working group meeting um so this is intended as an overview rather than just focusing on the most uh recent updates and well some of you are also uh participants in the six LW working group but anyway hopefully this will be uh useful so um anyway yeah uh what we are presenting is uh already contained in 03 which is a document version that was uh uploaded recently a couple of weeks ago so um in this document what we want to enable is uh shown basically in the protocol stack on the right in this slide so on the left you can see the traditional six L Pan based Pro protocol stack over 15.4 but what we intend to do as the main goal in the document is to allow the use of chic header compression instead of uh six lowan header compression or is not alternative uh for example to be able to compress IPv6 UDP Co-op headers in this case uh you may note how the idea would be to to continue using six low or six pan fragmentation so in addition in the document we also describe other options other uh protocol Stacks that we call transition protocol Stacks uh where six lopan Heather compression would still be used to compress ipv six headers uh and"
  },
  {
    "startTime": "00:12:01",
    "text": "then for example RFC 8824 also enables compressing Coop headers by means of shik so uh the two uh approaches uh in the slide are possible thanks to this RFC and there is also another option which is uh compressing well using Chic to compress UDP Coop which so far was only uh considered or enabled somehow by our the present document this uh six L draft uh but now with the recent updates in the shik architecture draft uh well it's also covering mostly the this at least this part is covered in the Chik architecture draft so uh perhaps let's see how things evolve but we might end up just uh from this document referencing the shik architecture document so we'll need to to see to to keep coordinating and align both documents so um then because 15.4 networks uh offer or support different topologies like the star topology and then the mesh peer-to-peer topology um we Define how uh it is possible to transmit IPv6 packets uh with headers compress by using shik uh in different scenarios and there's single hop communication for example and also there's multihop communication so uh for the first one single hop the idea is that uh what you can see on the slide is the frame format that would be carried as the 15.4 frame payload which would start with uh first field the leftmost one uh on the slide which is the shik dispatch which would be a Copan dispatch type uh that we plan to request for shic actually Pages 0 and one and this is one by uh intended to"
  },
  {
    "startTime": "00:14:03",
    "text": "signal that what comes next is a shic packet a packet with uh the header compressed by using shik and in this case in single Hub communication yeah uh we state that both endpoints must store the rules for compression and decompression for uh their communication and then for multihop communication uh the document presently uh enables route over and mesh under and for Route over there are three possible approaches uh I see Lan in the que yes um just clarification on the on the previous slide uh yes you you put CH header and I think that now it's can be confusing it's more the p as a protocol reader or something like this to to avoid confusion yeah good point yeah so so this figure came from before the the New Concept of the Sheik header so yeah indeed that's a very good catch thanks okay yeah so sh uh either for this protocol something because as we go we see that we have common needs for sh headers uh like maybe uh we need check some or we need a next session or a next header or something next protocol so so we have defined information but we realize that depending on where we play we might have a different format like for IP for internet Etc so you might need to Define your Chic protocol specific header it's still a sh header but it's the the thing we've defined Lon is very abst ract it's not"
  },
  {
    "startTime": "00:16:00",
    "text": "um we have a formal format if you like for V6 or at least we have a proposal for that for the other formats we don't really have a proposal there is something in the PPP draft as well but generically speaking they're all shaders they're just just that the shik depends on where you place it so it's a family it's not yes no Pascal I don't want to the long debate here but just here I think we have protocol header and what we are now defining as a shic header will be in the shic packet that is represented above the sh packet that is represented above well we'll have to come back to that slide we are not I'm not 100% sure we are clear on the format but after the shake dispatch just says it's going to be Shake then there needs to be a some rules and some stuff where you write sheds which will be compressed but we will know where will be a well-known decompression scheme and and then that will tell you what's next and that will be based on local rules but the beginning will have to be based on well known because we we have no way to Signal which rules would decode the beginning of the ship P anyway maybe we we talk about that at the architecture but basically you're also a victim of the architecture here G yeah you have to Define how it works in a very generic fashion and then oh if it's PPP if it's 154 if it's IPv6 if it's ether that here is what you find yeah okay yeah thank you um okay so about the multihop communication there are the the approaches of mesh under and Route over and for Route over"
  },
  {
    "startTime": "00:18:02",
    "text": "we have three different methods now we have attempted also to Define some acronyms um the three ones are the straightforward route over SRO the tunnel Ripple based route over T and the pointer based route over P so next we're going to see a few details uh about these three Alternatives so about the straightforward one uh the idea here is uh a quite simple use of uh transmission of shic compress packets the idea would be that all routers must store all the rules in use for compression and decompression in the network and uh perhaps a host must Only Store the rules for its communication with other end points so we have some example Network here showing which would be the the rules that would need to be stored by the different nodes uh by the way uh host e would be an external note uh outside of the 15.4 network uh Pascal yes we we have this concept in the architecture of uh nesting shic compressions like you could you could compress from ethernet all the way to IP then have a new quote unquote Sher to comp price IP all the way to co-op I don't know and then have a new sh so you have nested sessions or nested instances I think we on stor session um but anyway we have to agree on terminology but but we can Nest them and the end points are not necessarily the same what I'm getting at is when you say all the rules um if we do a good nesting of shic compression the router would just need to be able to decompress all the way to IP but even if the above IP"
  },
  {
    "startTime": "00:20:02",
    "text": "it's compressed it can still rout you see so so it would be kind of weird to have a single set of rules which compresses everything from IP all all the way to the payload you probably want to have shic rules which compress IP and then nested shic rules which compress the application in which case the router would not need to know all the rules as you say but enough to decompress IP I see um yes and so yes yes Pas agree on this one and and maybe here the point is that uh maybe there is one shic rule that compresses like IP and above and in order for the router to do its work it needs to know that shik rule so it can compress the IP part you know what I mean I mean it's not necess so it's not necessary for the route there to be like two shik headers if if we are saying there is a router the router needs the IP part so that it can do its work so I I just don't want for us to to get in this impression that there should be two Shake headers because there is a router somewhere you know we can still have like a uh something that's compressing the IP part plus above and um and yeah well I mean that that would mean that there there is sh on on both sides and the rter decompresses the IP part does the routing and then you know maybe Rec compresses it again with the same rule or or sends it on the other way I'm not sure what you're saying speaking which you understand only for apart because the rule must match the whole thing or much not but but then again it's an architecture discussion so I guess we don't want to Ste care less time but but"
  },
  {
    "startTime": "00:22:00",
    "text": "uh whether you do nesting rules like this rule compress all the way to here and then you have another set of shake rules which start here or whether you want to have a single big rule that compress everything uh it's an architecture discussion um I I I I have a sense that we don't agree on the result of this so so let's let's take it to the next discussion okay okay okay thanks thanks lot for the comments um then okay assuming well the same approach follow uh for this example uh yeah well some additional detail is that the frame format used in the straightforward approach for Route over would be the same as the one used for single hop communication which is the main advantage here because uh of the low overhead of just one bite for the sh dispatch and then the second approach is what we call the tunnel reple based route over so the the problem with the previous one with the straightforward approaches you have seen is that the routers will have to store a lot of uh rules or at least will have to store rules for the communication of all the end points involved and here the idea would be to make the the all this a bit more scalable with network size so one option is the this approach where the idea is we can have a tunnel say from host a up to the sigl V which would be a rout by the way the assumption is that Ripple nonstoring mode would be used and then from there there could be a downward tunnel say to host B if needed and uh then by doing this the intermediate nodes 6lr here uh would be be relieved from having to store all those rules for"
  },
  {
    "startTime": "00:24:02",
    "text": "Heather compression and decompression so um then the penalty somehow is that well the these are the formats that would be used to carry the shic compressed packets so here we need to include all the routing artifacts uh which would be compressed by means of RFC 8138 um but well here the the head over head is greater than in the straightforward approach so we have a sort of a tradeoff here by the way uh you can see there are the downward format then uh the one the downward one when the source is the root which is a special case which is a bit shorter and then there's also the upward format which does not include a source routing header and the third approach for Route over is uh the pointer based uh route over approach where the idea here is that well maybe moving to the format used in this case that is that the shik compress packet would be preceded by a shik pointer which indicates uh where in the shik header is the location and and then which is the size of the destination address residue so that a note that receives this sh compress packet like say a router intermediate doesn't need to store the rule that has been used to compress the IPv6 header and uh then it's possible for this note to anyway uh understand which is the destination address and then do the routing and so on without the need to store the rules so this is a second approach which tries to be more scalable in terms of network size so the intermediate notes like the sixl RS as you can see in the figure would also not need to store any rules uh for this example"
  },
  {
    "startTime": "00:26:02",
    "text": "and then um yeah you can see that the format is just couple of bytes for the shik pointer then this would need to be preceded by a shic pointer dispatch so this is a second bit pattern that we plan to request to Ayana to indicate that what comes next is the shic pointer so um then there's in the draft there's an analysis in appendix B which TR is to to study which are the the pros and cons of the three different approaches so for the straightforward one uh the idea is that it's of low header overhead just one bite but then it's not scalable in terms of network size rather suitable for small static networks then trro has a greater Heather overhead but then it's more scalable with network size and uh some features are that it requires rle non storying mode and the for in network communication it requires traversing the the root node which might not always be optimal and then P has a relatively low uh header overhead at least for some cases so it's three bytes plus some variable part uh this variable part could be very small in only very special cases for example if the full destination address is known beforehand um but then in inter network communication when the prefix is known then maybe it could be the the additional part the residue for the dress compression would be something between two and eight bytes depending on how this is handled and in cases where there might be for example communication between some note in the 15.4 network and then maybe some different possible external networks with different destination prefixes then perhaps the the whole destination address uh would be uh not compressed so then uh we have"
  },
  {
    "startTime": "00:28:02",
    "text": "this overhead which is variable and also this approach is also scalable with network size like the second one and as other features well uh the pointer based route over doesn't require the use of Ripple and uh for inter network communication in this case it's not constrained to traversing a root node although there might be other constraints uh for from the routing protocol to be used if not Ripple and well this is trying to to summarize a little bit so for small networks perhaps the straightforward approach could be suitable for larger networks maybe trro would be the best when communication with potentially several external networks is dominant and PR could be uh more suitable when uh internet or communication is dominant and well so other than that well there are some next steps so of course uh possibly the main point is we need to enture alignment with the shik architecture draft with a new updates regarding the the Chic Heather nested sessions and so on other than that uh also we plan to provide additional details on managing rule IDs for example when a rule ID needs to be unique within the whole shik over 15.4 Network or not and also we have some examples in appendix a uh so we need to complete also this this section at least okay so uh well this is again intendo does an overview uh of what we have so far in this document uh thanks for the comments already and I don't know if there's maybe time or if there's other comments yeah Lan yes it's good because pro has no counts so so that's a good name for for the protocol uh now just to come back for"
  },
  {
    "startTime": "00:30:03",
    "text": "Unicity of rols and maybe it's something we have to discuss in the architecture working group but when you put rule one for a b and c this rule one could be different and so in in the Border router you should have rule one for a rule one for B and Rule one for C in in my video you cannot share rules it's really a point too association between two points you mean in in which of the three approaches for examp uh I don't see in in this uh because here in lbr you have only rule three so for example say here yes in this one so for me you should have a rule one for uh a rule one for B and Rule two for a and Rule two for C so you have to to associate the this to the source with the rule ID but that my view we think is things that has to be discussed in the architecture group okay okay any other comments thank you so much for your presentation I to go and S slow and I guess we we got our sessions back to back as we requested right have not checked actually if we did but actually we didn't get the sessions back to back and in fact we we requested in six we requested a 90 minute session but we got 2hour session on Friday"
  },
  {
    "startTime": "00:32:00",
    "text": "so yeah okay we on Thursday yeah yeah yeah so so sorry I that won't be away but we tried okay at least we tried we tried I don't know I thought it was was okay but I didn't check okay so so yes so I encourage people to go and and attend six law as well I realized that your biggest problemes are related to the fact that the architecture is not so clear right now on how you you do in particular Chic nesting or no shic nesting and what is the shic header and what we call shikor Etc and and what the instances or sessions are and and so we need to be very crisp on all those in the architecture to allow you to progress actually so thank so much thank thank you thank you it's really really interesting so yes [Music] with this do you want to go and present your slide oh no I have I have a little bit one or two slides to present on the architecture and then we go to to yours um okay so let's go back so the architecture just wanted to give uh an update so we we provided a new version of the Chic architecture and the the changes are limited the the main thing is we we this we we propos the packet formats that were discussed in the previous meeting since ATF 117 um the references are updated in particular carless there is a reference on your draft there's also a reference on the PPP draft and the protocol numbers draft and we also have references on the lp1 rfcs which are s"
  },
  {
    "startTime": "00:34:01",
    "text": "Fox and la so this is this is what's new and then after that the discussions is still very open so I will go to Laurence proposal and if you want to present it okay so let me find the slide if I you can upload if you like I'm on it so I can I can sh okay you have it here okay so yes it's I'm not part of the architecture and I don't want to to be part but uh that's some thought I got reading your document and also what we we have done on the on the shiker so I tried to as an exercise to see how we can put Co-op nocore regarding this architecture with uh so if you can go to the next slide uh oh I have control sorry uh so um I just took some uh hypothesis on chck header so it says that it's carry some information like the next toop we have also the session sension ID so as we had a a comment from Mano last time I will prefer not to call it s because it's confusing so I took sesh and also the the CC uh because maybe we we need it and we have already a discussion on that last time so we have a for the shiker we have a rule ID space that is independent and if we have only a single root it means that we don't need a rule ID for for the shiker uh so as I say I try to look at the layer shic it means what we have defined as car let say in 8824 and also in 8724 so we have three"
  },
  {
    "startTime": "00:36:00",
    "text": "instances of of shik one for Oscar that compress the inner message one for Co-Op that compress the outer uh Co-op message and it's end to end between the device and the application and then we have the network that can compress IP UDP here on the lp1 segment and so we have also three independent rule ID space for this three instance I don't know how we call it so here it's a representation of this with some uh attempt to make thing clearer so maybe it could be also useful in what car shown it's that when I put the name of the protocol uh it's it will say no compressed and when I put it between parentheses it means that it's a compressed so it's a regular ship packet with uh rule ID residue and payload so and then when I put it in bracket square bracket it means that here is encrypted um when you have a white an empty line it means that uh what is above has been inst is view as a payload of Cor so same thing for Co-Op we have end to end compression of Co-op and here it's uh what is not so obvious is that then we we have to put this on IP UDP and here the the destination part of UDP will be uh Co-op will be shik sorry to to tell that we we are sending a uh a shic message then we it's so this uh either IP with the destination Port"
  },
  {
    "startTime": "00:38:02",
    "text": "equal to shik is compressed using rule to to be sent on the uh lp1 Network and then it arrive to the core the core text the compress IP generate an IP message containing Al sh a shake message and on the other hand you you do the opposite things so what is important is that if here uh at VIP level uh when we do the the compression we also add shic header so in this example I took two values one that says that it's the real port number so it's 83 sorry not 84 for Co-Op and then we have 8 bit that could be the shic CRC so this give you an example of what is is sent and if we represent it as the architecture so we have what I call the session management that contains uh the rule ID for the shik header and so we have a set of rule that has been Associated to that and to go to this uh session management we need to look at the source address and the source address because we can receive packets from different element and it may goes to a different uh Shake s management then it arrive to the situation management maybe in the ruer in the shic header we have some session ID and so the session ID will point to a different sh in stance and in sh each sh inance we have a set of rule for compression decompression and fragmentation so that's an element so last thing and that's what interest me uh is about management so how we can"
  },
  {
    "startTime": "00:40:00",
    "text": "make a way to modify the set of rues that we have in the shik stance and in the shic section management so there is maybe one solution but I don't like it but will be be to notify to in the shik header that we have a management on shic management message or a regular shic message but if we do that means that we lose one bit all the time to say if it's management or not so maybe it is more more General to do it in a rule so right now we have uh three uh natur nature of the rule which is compression fragmentation no compression and we can add a f fourth uh nature what could be management this management we can say that it's only uh using link local addresses so maybe we can imagine some any cast uh link local addresses one for the uh the device one for the application or the core and so regarding the direction and uh then we Define some shic compression rules that are specific for the management for for instance to do the key the key management to key establishment for osore or the TLs and we have also the rules to uh manage core con uh for for the device so we need these rules but we don't need to impose a rule ID and during the implementation of the rule we can say uh to give the rule ID to these rules and of course this rule ID is competiting in the compression fragmentation no uh compression"
  },
  {
    "startTime": "00:42:00",
    "text": "space so that's I send a mail with that uh yesterday so I hope it will be useful for future discussions okay I've seen the email effectively and I recognize the text here and and what you present actually helps understand that email because it was looked a bit criptic to me but yes that's you have to look at that I was still concerned by the need of this um bit for saying it's it's management but I don't I don't know what else to do so yes we'll discuss that um before we we move on um yes it would be nice to have a a whiteboard discussion in Prague the set thing is uh I will not be in Prague uh so that would be Alex but that won't be me that's what I understand so if you do this whiteboard discussion I can start a WebEx or something like that to to join um so so that's one thing the the other thing I wanted to share with you was um Eric has sent also an email that lauron you have started to respond and I hope that we would have a little bit of time in this call to discuss the mail by Eric so if if you're done and there are no questions on what you presented then maybe we can bring up that email so I have it with me somewhere so there is a long email by Anna Anna I'm sorry I'm still on it I'm still showing it uh but there is also looking for email by"
  },
  {
    "startTime": "00:44:03",
    "text": "um answer by sorry I'm digging for it I thought I [Music] had yes it's called some comms maybe I could share it or I could read it so Eric do you mind if we go to your to your um email and and we we discuss it a little bit of course not please go that's was a goal right okay good thank you ER and thank you for for those comment section um so you you were saying I wonder why the uh shic overnet is always for IPv6 actually it was not the intention um because the idea was in the shic header version for ethernet the next header would be another E type so it's basically saying it's basically you're inserting a shakeer in Ethernet just like you're inserting it in V6 um meaning that you have an next header which is of the same type as the next that points on you so if the e type says Shake then the shake header must have an ether type which says what is The Ether type of what's being compressed okay so basically you can if you say next header I mean next eer type in this case is 800 this we mean ipv4 right yes exactly you could mean ipv4 you could mean some other protocols which are not IP I mean we we are at EET level so the idea was it's always the same structure if like something which says what's next Etc but what's next is at the same level as you are so so that"
  },
  {
    "startTime": "00:46:00",
    "text": "that was the intention here and I think that's what they have in the document concern that there was a concern there I check but alternatively right so there will be not so many things so we can get one specific eer type for shic followed by IPv6 another one for shik for by ipv4 for instance as long as you don't go for too many you are gaining two bytes right if not mistaken yes that's co uh on the other hand why restrict sh to une if we do that and we don't say in the shik what is the E type of what's next um then we are restricted to the E types that we will Define oh Pascal I think the the confusion comes from the name NH which is next eer next eer comes from the IPv6 vocabulary yes but the shover ethernet document in in the 6.1 section of the architecture it it shows that you have uh I can I could share it I guess but I think La this is may be the source of my confusion there if it's next problem solved right yeah let's not call it like suggested next header because there a next ether type it is next e type that's what is called in the in the figure it's not called Next header okay my bad no sorry so yeah it says in the that in the to header The Ether type says shake and in the shik header there is an ether type that says IPv6 in that example and then you have IPv6 header and IPv6 and hrp I guess that's because the example"
  },
  {
    "startTime": "00:48:01",
    "text": "I'm taking is IPv6 that you were misled but it's really an example like this type could say before which case you would have a V4 Etc so that was the intention I if if after saying that it's not clear we can always rewrite a little bit to make sure that's more clear um because stand there is a confusion also means that it could be written better um then you say understand appreciate that an extension header is layer three when a protocol header could yes exactly um you have this sentence where you say an extension header is layer three while a protocol header would look like a layer for header and it's Weir to change a layer for header to a layer for header that was exactly what was trying to say last time so I understand that from an architecture layering point of view we agree that sh uncompressed version which never goes on the wire it should be a shic header followed by the UDP protocol if UDP is being compressed right we we seem to agree on that and then there is your but uppercase but at least we have an agreement that the nice architecture is is is this yeah agree on this one normally an extension header has a length which is a multiple of eight and yes that's still true in our slide Eric because before compression that's what it is um let me go back we have problem with my browser no it's gone"
  },
  {
    "startTime": "00:50:08",
    "text": "can you still hear me yes I lost the window where you are so so that's a bit bread for the window is is gone I don't know which scen it is now but at least I lose the communication very incredible what did I P do okay there you go um so so let let me bring up the slides with the architecture let's show what I wanted to say so at some point you've get in red the shic header which says next header equal urp and that shic header is is before compression exactly like you say you see you have your head bites and then you've got options which must also apply to the alignment but that's before we compress it and once we compress it then it becomes a nonaligned green thing but the red thing at some point on paper in memory if you like was uh eight bytes aligned yeah but then the green line green one needs to be eight bytes line if it's an extension header well it is before compression but once you compress a packet what goes on the wire"
  },
  {
    "startTime": "00:52:00",
    "text": "is what goes on The Wire I me for if any middle box wants to pass the extern other chain and Shake is Define as extension Eder it needs to be able to pass it right to get what's after and then you need to be eight byes line you mean is there is a a yeah it needs to be T right that I mean I I agree that that you're talking about middle boxes now and um that that's this format is is for the case where we don't have middle boxes which which would do that sort of games because when we do have middle box we have to resort to encapsulating the shake thing no no you don't have to I mean Pascal you you have exent adders can travel internet the internet not all of them but many of them can do um UDP is safer for sure to Traverse the global public internet but there are different steps between a complete lp1 Network or controls thing and the global internet right so they are you can for instance go over a specific arrange Network so what you you're saying is we could compress the black and purple things like shic pd2 but you would not comp press Shake pdu one because you want it to be align and pass those middle boxes and to be correct if it's an extension header now if it's a protocol header is different right it's Antion header it must be 8 bytes you will maybe it will go over the internet but it will and then um for this one I'm raring back my ad ad I'm afraid it will not pass the isg if you're on the white you are not to line on 8 bytes and then I'm removing my ad at now right so oh okay yeah so we"
  },
  {
    "startTime": "00:54:00",
    "text": "one way of answering you is to say hey okay um then we send the red uncompressed which is a line to byes and then we compress pd2 um if we do that though it will say next head or equal ulp meaning whatever the ulp is but in in practice um because of the Chic header we have to understand that the UL piece is compressed and so if there is a middle box which looks at the ulp header it will not find it what you can do is something similar to ESP and offis skate the next header so it will never be designing allow right it will never be six for TCP it will be blah blah because office six by exing by something else okay okay but and it passed for ESP so you're saying it's if it passed once it will pass again because yes I mean the machine which will if there is an intermate machine it will find that it's crumbled and yes you cannot pass it but yeah it's pretty much like you are doing ESP in the chain right so you cannot pass the rest this compress encrypted is basically the same thing yeah yeah yeah it's just a compression is an encryption where you know you publish the rules yeah yeah okay so so so what you're saying is if we if we send the red in the air and we compress the pd2 and we scrumble the next header equal urp we all set designing allow right yeah yeah I mean you can and then if you want to be an extension address and again you're right it's more it's nicer it's because you cannot get layer two layer four and"
  },
  {
    "startTime": "00:56:01",
    "text": "layer four right um right as I said Below in my email right that you have this ipcp a very old one yeah we can of course it's not the same compression but it's basically the same place and the same features the same function different ways of doing it right less efficient blah blah and they have the draft of PBP anyway yeah sorry so I have the draft for for shik over PPP we have to to explain how that works and so so so yes you want me to read you say ipcp is similar to shik but uses a protocol header what's the difference that that's your question correct I mean this is a rical question right so well effectively we the shic header itself is is an abstract data and then we have a shic IPv6 header which is the one that I just showed and and there is a shik PPP header and when you can find the shik information somewhere else then you don't have to write it in the shik header and effectively for shik with the ipcp we have uh do we have actually that's that's the only one I found very easily if you go about the protocol number that's how I find it yes but because in PPP you have the the session so because you have a PPP session we don't need the one in the in the header you have the CRC in the end so we may not want to do the check sum but we might because we will have an IP check sum later or we might still want to have our check sum and then we need the pair of of application layer um I guess the ipcp didn't tell you and just it just tells you it's ipv4 IPv6 I'm trying to"
  },
  {
    "startTime": "00:58:02",
    "text": "remember what else I don't say Pascal I don't say reusing ipcp but it's very similar in the sense of ipcp is not an extension header it's more like a protocol number and that's what I think it will be much it's moreit point of view but safer for process wise at this stage right I have no head right so you I can be over other the point is the ipcp well you have the NCP and then the IP or the ip6 CP which the NCP tells you the layer to information ipcp tells you it's IP and and here is and so it's basically like an ether type or something in my in it's below IP right what I'm saying is it's it tells you it tells you that what's next it's like it tells you that what's next is IPv6 or ipv4 it's it's like an ether type of sort right yeah I mean again it's pretty pretty do not there is no need I don't intend to reuse IP comp by by bite but the concept of Ip ipcp runs over everything can be in between everything right basically can be above a pv4 pv6 and can have a pv4 pv6 after so whatever yeah I have to do some homework to understand better what what you're saying here but you just how it how it's inserted Etc you have to understand and so your last sentence was using a new IP protocol would allow the use of shic over IP SEC yeah because you can chain sh after ah for instance or after ESP we can already chain sh after"
  },
  {
    "startTime": "01:00:05",
    "text": "anyway no not you can place you can chain Ed after IH but not after but notp right so so your point is must extension edgers must be I mean they got to fix place again that's the the issue right if you put extension either it must be before or after and most of them are before ah ESP so if you use an IP protocol number you get ah and you can change it to ah or ESP obviously right or the same thing over pv4 so you can get ipv4 header Chic header and then the payload of ipv4 not that I like to support at pv4 right but yeah uh just one question Laur do you want to say something yes I want to just if you come back to the previous slide Pascal and I think it's also th for confusion uh here you put the next eer in eight eight Bits And if we are Layer Two it will be 16 bits oh but this is the shic header for IPv6 I was saying it's an abstract format the sh the but each layer has a different format if if you if you put the Chic above Layer Two then uh you will have if if a type for different why yeah it's a it's a different format because you have to place you need to Define for each protocol you will want to compress a new Cher I guess so yes because what you put in it might be different for instance in in PPP I one where I don't uh I don't have a session for because the session is is implicit because of PPP session now but when you do compression at Layer Two you will know that you are Layer Two and and so you know at this time that"
  },
  {
    "startTime": "01:02:00",
    "text": "you are dealing with things [Music] on that's the point 18 bits so you know you are you should that's that's one drawback of the having a bite representation of the Shader I think it should remain yes it is this is the bad for presentation is just because at some point we needed to to present to IPv6 and ask for her next header which is true or not true depending on how resolv you know the questions by Eric but um yeah that was only the version of the shik header 4 it's the shik next header if you like it's the sh this it should not have called this picture the drawing next shik header because it was just a drawing in the case of IPv6 in the header chain but yes it's not the format for PPP because in PPP I have another format uh it's not the format for um uh sorry the ring two theat you have to yeah me sorry excuse me so I'm sorry I had non-maskable inro but it's it's mass now um so yes what I was getting at is this format was just for V6 we need to to be more clear on that we need to define the format every everywhere and so that's many formats effectively on on the when we want to spare the bits and I"
  },
  {
    "startTime": "01:04:01",
    "text": "understand that you're you're saying that everything which is only compressed we should not even need to spell out the bits right that's where you're getting at for me the rule is a format yeah exactly I see what you're getting at and it's it's of everything on the wire I would agree with you and the discussion was whether there is a time something which is not on the wire like this or whether just have and I think I had an argument for needing this format I forgot which one it was effectively yes if if the rules tell you uh this exist and it's it's you have well you have so much bits in in the residue to find head length then you have your head length and it's it's never really in the air um it's I mean it's never really written with with a bitwise format anywhere so you don't really need to have to know this bitwise format so that that that's basically your argument for cl why should we ever spell it at least we need yeah I don't know we need to to be able to explain when we can compress an exender when we can compress session ID etc etc and if it's how it's obtained when it's compressed but effectively in the air if the Chic header quote unquote is always compressed then there is never really uh a need for a bitwise uh you know a drawing like this work I I I understand your argument I'm"
  },
  {
    "startTime": "01:06:01",
    "text": "why I thought we needed it but just now it doesn't come back to me CC but we I think we can discuss about that we I think we can do the CC on the compressed version Oh yes it was the CC good yes just just to explain to the others at some point um there will be a CRC to be sent or check some for some content and we need to know if the CRC is done on the compressed or on the uncompressed version if it's done on the compressed version anyway uh we're back to to what you are saying La we don't really need the format and all we need is to be able to expand the values so we can we can have them and work with them but they don't need to be with a bitwise format yes if we do that before we we push a CRC I agree with yeah then the check sum for instance in this picture the um the check sum that we have is the one in the Chet pdu so it's it's the check sum of the compressed shic pd2 so the real value of the check sum uh in the black piece is lost and um we just validate that we will receive all the bits of the compressed version correctly but then the other way of doing that could have been to say that the check sum in the in the compressed red block is the check sum that you have before you do any compression so so you take the the first"
  },
  {
    "startTime": "01:08:00",
    "text": "picture everything and compressed you have a ulp there which says which could be say UDP which has a check sum and you have the green the red piece which also has a check sum and which protects everything after it and and basically if we said that the the check sum of everything and compressed is the one that goes in the compressed pdu then we could have validated that when we uncompress we get the exact same result on the other hand if we say that the check sum that goes in the green shic pd1 is after compression then which we validate that after compression we receive the packet correctly but when we re expand we don't guarantee that we get the expansion that corresponds to what was there originally that's that's the difference basically whether the check sum in the shic header after compression is is the check sum after compression or before compression the big difference being that we know that we restored exactly the same packet or we don't know if if we comp if we compute the check sum of the compressed green pieces then we know we transmit them well but we don't know after restoration that we restore the original packet that's that's the difference from there I don't know I mean how important is it that we know we restor the original packet could it be that some rules Al some slack in what's being restored for instance some padding which could be restored to zero or to something else and it would not matter but the check some would"
  },
  {
    "startTime": "01:10:00",
    "text": "change um it's I think it's a super interesting discussion but um we are like 10 minutes after the hour oh we oh probably let's let's stop here and um yes we'll continue uh well well in Prague I'll try to set up uh to reserve a meeting room and and set up a video call for Pascal to be able to to be present there so yes um so thank you very much thank you Pascal thank you everyone for for being here and uh yes see you in three weeks time I think in yes so physically or not yes or not see okay bye-bye hello crap"
  }
]
