[
  {
    "startTime": "00:00:17",
    "text": "um hello the two of you um even though I would generally try to start minutes on top of the hour um I think it would make sense to wait a few minutes because there's three of us and while that is a group um I think we will have a more productive interaction if there are a few more interesting a lot yeah Marco responded to me on the jabber before mid Echo started so my response on zulub actually is now part of the meeting because it is in the the time span of 10 minutes before the meeting yeah yeah so I just wondered why there is no meeting materials a link on the data tracker upcoming uh Paige and Marcus Lewis thought that this is because we didn't submit a separate agenda oh never look yeah we used we used to have uh we used to have a dummy agenda but given that the actual actual agenda is always in the minutes anyway yeah yeah um so I think we should always submit the single line agenda that has a pointer to the notes page yeah I used I used to do this um I think I should yeah I should probably should add this retroactively for the for the ones in this term which Barry had set up um yep we'll do that yeah"
  },
  {
    "startTime": "00:02:02",
    "text": "okay I don't know if it's intentional maybe it's something to discuss in the tools team yeah the material the material page exists anyways so why not link into it even though there's no agenda you may still have something else yeah so it's probably to punish meetings that didn't update foreign I know that we will be a rather short group given that Ira said that he won't be here today and Barry won't be here either um yeah I don't know where the Michael is coming provided feedback on the mailing list so I'm not at all unhappy um let's let's use those two minutes to go through the formalities so this is a sibo meeting um we are an ITF meeting a place be nice to each other and follow the note well and I yeah the length of the minutes is um I'll post here again just in case anyone listened and thanks Marco for adding to the minute we have one basically two items on the agenda today cddl 2.0 and zero path both of which we have in your slides customers so maybe it's just"
  },
  {
    "startTime": "00:04:03",
    "text": "maybe you could already just start them up and if Michael still joins [Music] um also give brand we don't we don't have to hit off into the into the most important parts right away yeah so let me just uh do the silver path thing on on one slide um so this popped up uh more or less independently and uh I think it's a pretty obvious thing I mean I can probably reveal the secret that that I actually became an editor of the Json past action when with the view to actually being able to use the work in in the Civil uh context uh so this was uh quite foreseeable and now somebody has stepped up and actually started uh defining what they think and civil path is and um I think it's pretty interesting so my initial view was that a siwa adaptation of Json pass would essentially work with Json path as is but then we don't get access to the more extensive generic data model of sibo so we don't get access to bytes or to map keys that are not text strings so that's one thing and the other thing of course is that sibo has a third container uh kind which is tag so we we Jason has arrays and and Maps which are called objects in Json and sibo has arrays maps are a little bit extended because the keys can be anything not just strings and then we have tags so those are the obvious places where adjacent zero path would extend uh Json path"
  },
  {
    "startTime": "00:06:02",
    "text": "[Applause] um so I I always thought let's finish Json path and we are almost there so yesterday we had a an interim where we essentially got stuck on the type system issue that we probably need to cover more days to understand uh but we should then go into our Google Plus call um so uh interestingly uh the other Michael has with the long last name that I kind of remember has generated a rust implementation uh instead of writing the document first he wrote the code first and I think that's that's not at all a bad way to uh start with that and one interesting thing he contributed was let's not use text for this but structured sibo so we we are not going to make the detour over a URI to a CI but we as we will be starting with a CRI in the first place whether this is not a UI but you understand what I mean so so not quite so the the um the format of the seawall path would be sibo already is that yes which of course could be shown in diagnostic notation exactly so um the diagnostic mutation uh that that would result from Michael's proposal here um is uh not that bad so um I I think we could live with that uh but I I mostly wanted to raise this so so people who know that we will have to do that and obviously the The Next Step um somewhere in the cdbl world is doing what dsdl did by adding schematron to relax Ng uh we will probably need some way of"
  },
  {
    "startTime": "00:08:01",
    "text": "attaching predicates uh to places in our data models and something like zero pass or an extended form of sibo path Maybe the the obvious way to to do this so yeah that's going to come up maybe not this week maybe not this year but definitely civil path is something that we want to have in in our tool set so please have a look at this GitHub issue which is on the seabor GitHub IO page um we always have a hard time putting up issues for a working group but I think that that's pretty much as good as it gets um and look at the issue like look at the linked rust implementation I didn't put the zinc on the slide because you can get through it from from there and it would be great to have some some discussion that that might include the sibo meeting with everything so that that's all I have about this one thanks um I personally haven't had a chance to look into it but sounds sounds like something that would be good to have yeah so it's probably most useful for those people who are in in the Venn diagram between uh the the Json path people and the receiver people and probably that part of the Venn diagram is pretty small at the moment and I'm trying to get more people interested I I was more thinking I'm I was not so much thinking about Jason's path but more in the direction of like people people don't use the traditional tools set cut orc Etc so much anymore but start using"
  },
  {
    "startTime": "00:10:03",
    "text": "um JQ and I think this would kind of having something that works with c-bob with seabor and I think sibo path would fit the bill here um might might make things good better here yeah so maybe at some point we can have a discussion about tools that might uh like uh civil support added to them um so JQ certainly is a nice uh tool I found that it's very different uh in usage from what I would use a CQ for um so I I wasn't so motivated to to actually uh get a student to submit a patch to to JQ uh but let's see uh so good I I was just thinking more on the high level not not necessarily like exactly you see JQ but it might it might find a place into link yeah yeah any questions on that topic Marco uh specific for me either thanks um being 10 past I I'm afraid we won't have Michael here today so um I'd say let's go to onto cdl2 anyway and hope to produce something something useful also in the minutes for those who review this later yeah and we also have the recording so um yeah let's talk about the the current"
  },
  {
    "startTime": "00:12:01",
    "text": "bike so I just wanted to to implement something so we can play with it so this is not necessarily exactly what we will put into a CDL 2.0 on the other hand um I find what we came up with so far actually quite useful and and it's almost an 80 solution to the the things I actually need so uh let's see but um essentially it's it's trying to uh address uh three requirements uh one is a requirement for someone who has a slightly larger cdda project to construct uh the cddl from multiple files so files are taking the role of a module here I think we all have tried uh languages that do multiple modules per file and that that can be um how to use so maybe equating files and modules for the moment I get to it this an individual more detail later uh works so when I I'm doing a project where I need to do A4 I may want to have multiple files and I may want to integrate them in a very defined way of course I can do this with the make file and Cat um but yeah that it's more interesting uh to to actually have a file that that has a standardized meaning that every tool can understand or that at least every tool can can somehow process so that's one thing uh maybe more important is to be able to reference existing cddl as a library um so what what the previous one is handled by the include director if this is handled by the import directive which otherwise are very"
  },
  {
    "startTime": "00:14:00",
    "text": "similar but the difference here is that when you use an existing CDL file as a library you do not necessarily need everything that's in there so when I write Syria specifically for a project then of course what I write there is meant for the project so it is all meant to go into that project but if I use an existing city as a library then then maybe I only need cozy encrypting and not course designer or vice versa so that that's what import is doing and uh finally there is a very small appendix here that actually does something that reminds uh of namespaces so that that's the as clause in an include or an import so that's really what this little spike is trying to do um we still have a cdl2 plan document which has a few other things that also have to go into a CDL too uh these are of course are not going away but this is I think the the most useful start for uh doing some some module structure and some some namespacing foreign so um the approach here is uh pretty weird um so the idea is that those things can all be done by a cddl processor so I'm not calling it cddl preprocessor because the cddl processor is fully aware of the semantics of of what it's actually throwing around here so it's not like you see preprocessor it doesn't understand C the cddl processor actually fully understands what a rule is and and how you for instance what substitute names in that and and uh and so on um so the the CDL processor would make"
  },
  {
    "startTime": "00:16:01",
    "text": "use of the fact that we planned cddl2 to be a superset of cdl1 and what essentially process uh everything that doesn't work everywhere but in almost all cases what process everything that is not the video one um and turn it into compatible cda1 so we can continue to use cd-day Cogen and and Andrew wise CDD air tool and the early cddl tool which I hope will go away within this year um and um just make sure that the studio2 introduction is not disruptive nobody feels like they cannot use cddl tool because their tools are not yet supporting them the other effect of having the serial processor spit out cdl1 is that whatever processing is going on is very inspectable so you you never have a question mark in your mind of what's actually going to go on you just look in the output of the cddl processor and we'll be able to to find out what what your directives actually did so this is an implementation uh approach it's of course not the only implementation approach not the only valid one so some implementations will simply integrate that and actually that's going to happen in the inverse Direction with cdlc which is a cddl processor and we'll get all the other parts of the early cddl tool in in time but on the other hand if you have an implementation that that really is trying to be simple and focused on a specific issue like code generation uh maybe you don't want to implement all of of City there one even and uh CDL processor might be able to help you so cdlc has a prototype the genic genericizer so if your cddl tool doesn't support"
  },
  {
    "startTime": "00:18:02",
    "text": "generics that's not a problem because you can convert your your CDL input to a generics free cddl and process that with your tool so that that may not be satisfying for another reason because maybe the way the the studio one is generated is not what your tool needs but that is of course a separate issue so um the the Prototype right now is in the cdsc tool which is essentially a converter or compiler for cddl and um you use it by using the dash 2 flag which means it's supposed to do cdl2 stuff and that currently only works with output type cddl so minus t cddl is is an option you need to put there and of course if you know posix command line argument rules you can stick this together so Dash 2 T cddl is what you will typically use and yeah you you apply this to one or more input cddl files and get a combined CDL one file which I have called completed City delt here and often you don't even do that but you you just pipe the output into another tool uh so you can generate instances that's the the cddl GP here or you can verify instances that would be the dash VP or excuse me validators the right word not verify so this the need for this will go away with respect to the early cddl but of course other tools the the code generation or things like that will still need that so that's how you use"
  },
  {
    "startTime": "00:20:03",
    "text": "this and um yeah let me just to explain the the main components of this and and I will uh start to ask questions to myself a few slides from now but right now I'm just presenting what what uh this uh projectile does uh so um semicolon hash include does a wholesale inclusion of another CDA file um and the wholesale inclusion is sometimes a good idea because you if when you are developing something uh you want to be aware of unused rules um so that's why there is an include and not just an import the input simply gets rid of unused rules and that's exactly what you don't want uh in in a development situation so if you wrote a rule and then that isn't used then probably something is not working right um the import directive operates on an undefined list so when when the CDI processor processes a CDA file it looks at all the rules in there and computes a set of rule names that are not defined so not defined here means the the current module doesn't Define them and it's also not defined in the Prelude the Prelude is currently is still the special case I I hope to be able to explain what the Prelude does the the thing where where we're real names like into and float and so on are defined um so of course that shouldn't uh turn up in an undefined uh list so it is somewhat special and that that will probably change at some point um yeah so uh after processing the the file uh and and removing all uh used"
  },
  {
    "startTime": "00:22:04",
    "text": "names that were defined and all names that are defined in the Prelude you have a list of names that somebody still has to Define and that's the undefined list and what import does is it looks at the module to be imported and tries to find those names and if if those names are in a rule in the imported module then that rule is important plus everything that is not defined uh in that rule every additional name that it uses that is not defined gets added to the undefined list and we do that until we we have either finished the undefined list or uh there is the it's there is no resolution for an undefined Christian a brief question um if the thing that is being imported has internally missing items will those missing items just leak and create some um some scope that I would consider weird in that it only laterally gets imported by another another input yeah that's the subject of isolation and all the undefined items from an import need to be resolved so the the the undefined list of the imported item doesn't leak into the undefined list that will be used by the next import so that there is some isolation here um but definitely the the way this isolation X is something we we need to discuss in in a few real world examples but I would expect I'm going to use"
  },
  {
    "startTime": "00:24:01",
    "text": "import on something that already is is somewhat stable and somewhat complete um so it it knows um how to do this and what the the one of the next slide says is that the imported module can of course itself have Imports again and those are at least conceptually processed before the imported modules even looked at so for instance RFC 1953 the Cozy algorithms uh defines a few pieces of cddl that only makes sense if you are using RFC 1952 the Cozy structure standard and so if you ever include 1953 you actually want those Rules from 1952. but you don't necessarily want all the other rules of 1952. so the 1953 when you're only includes those rules from 1952 that are needed to complete the routes that are in 1953. yeah I I understand the silence but it really works out quite well in in practice okay um so this is all fine there is a little additional thing and that's where the namespaces come in um because the the world that you are importing here may be huge and there may be lots of things defined in there um it's probably a good idea to be able to name space them and the as clause in the include that can actually be used to say I don't want"
  },
  {
    "startTime": "00:26:02",
    "text": "to these rules to be imported as they are but I want them to get a namespace prefix which is just something with a DOT ending with a DOT um and that makes sure that the the rule names uh do not conflict but you don't have to do that if what you are importing is trivially enough or you know that they already have taken care of namespacing of using unusual names uh in some way in in there the module and I'm going to get to this in a moment okay and this is the the slide that actually tries to answer the isolation thing so uh when there the when a file is referenced by an import or an include um that referenced file is is import into a process before it's actually going into the the import include process that that initiated all this um so the the processing of the referenced file happens in isolation the referencing context does not change the meaning of a referenced module and I think that that's a pretty important um uh property that we want to maintain so you don't get surprises in what what import actually means um based on on uh what the environment the the import set up the only thing that is bridging between it towards the undefined list so this means that indirectly imported rules are present in the imported module so when you import 1953 then everything from 1952 that is needed"
  },
  {
    "startTime": "00:28:02",
    "text": "to do 1953 um is uh in the 1953 module as well and that's not a problem because we have this this uh um I'd important redefinition idea in in cddl so it doesn't hurt if things are defined a few times but also if you actually use namespacing then then you will further increase the the isolation here um so the the foods actually even have different names but it means that if you include 1953 um then you actually get to use the Apache info definition that is in 1952 so you don't have to do anything to do that but because you have to have it to to uh operate on on what 1953 uh defined but you are not getting all the rest of cozy uh India unless you do a separate import of 1952. I think that that actually addresses Jeremy's concern uh or there is of Jeremy's observation about the the weirdness of uh doing nested includes um that that actually might not span a tree but but have a general directed acyclic graph and so that need that leads to multiple includes and multiple includes are not either important in C and they are either important here so like diamond include yeah yeah and they are innocuous they also by by name spacing can be made even more innocuous so they don't even touch so you can"
  },
  {
    "startTime": "00:30:00",
    "text": "um inflation uh your tree what's the English word for inflation Okay so probably disentangle I think yes entangle thank you um so where do we get those module targets from uh so basically I thought this is really something that should not be uh nailed down in the module files because you want to freely move around module files and the modules are not going to know where they are and and where the modules are that that these modules actually including and if you actually want to do a new version of a module uh for some reason you want to do a bug fix then you have to make sure that you don't get the original one but the new one and so on um so I thought that the the place where the module targets come from um should be defined in an environment variable and that's called cddl include path that works like most the Unix path environment variables so it's a number of directories that are separated with a colon and Dot of course is the current directory and there is a special meaning for the empty string so the empty string points to the the batteries included space defined by the cdlc module now that's probably something that that we we have to get some agreement on what what's in there um but as long as we only have one"
  },
  {
    "startTime": "00:32:02",
    "text": "implementation of the CDA process I think we can ignore this problem and once we get a second then then we probably want to set up some coordination of Yankee reduction something like this an INR registry um if INR is willing to play along with us uh that makes sure that these batteries included are compatible between different implementations so right now that directory includes cddl from all uh rfcs that were done in the XML age so from 8650 onwards I haven't actually looked if earlier uh RCS have interesting cddl so I I would love to get feedback on that and of course doing something like like the 1771 example that is in 8610 um would would also be a nice thing to include there even if it's not totally official but at least it has been published in an RC so most of the things come from your your file system and a few things come from of the batteries included directory and uh deliberately I didn't try to address uh sources from the web um because that's complicated and that's why you see an empty checkbox beside the to-door called scraping here because essentially I think we will need to do scraping on on essentially everything that we referenced including uh internet draft so uh the the three things that I think we need to have is Ayana"
  },
  {
    "startTime": "00:34:00",
    "text": "uh internet drafts and some form of GitHub import uh so you actually can point to someone else's project which of course doesn't need to be limited to GitHub it certainly it should include other places like gitlab um but yeah manufacturers might have sites with that as well and so on so here we are in getting catalog uh space here and probably need to do the same kind of thinking yeah so the Cydia England path really is the most important part here and and the rest will come over time so this is the the Portside and now we maybe should quickly talk about the expert side so how do you actually export cddl from an internet draft or RFC and the the default export is to to Simply take all source code elements that have the type cddl extract the text from them and concatenate them this usually gives you something that is useful it may give you a little bit more if the RFC hasn't taken care of separating its examples from its normative content um so that there is something called add name the name attribute in in the source code element of RFC XML that you can use to sort source code uh fragments into different buckets and we just need at least the convention uh to to for how to use the ad name uh for uh doing this sorting or you will have to actually manually scrape and and"
  },
  {
    "startTime": "00:36:00",
    "text": "so for for the like 20 RCS that that I have in the batteries included directory um about half of them had some manual uh tampering uh to make sure what we get is actually useful so often you will actually not just throw out stuff but you actually want to have separate modules and then of course these separate modules need names um and yeah we should have a convention the name of course should derive from the ad name uh attribute so so you get some control over that um yeah and and I also added uh some some uh semicolon hash Imports uh to some of the CGA files I talked about what you need for 1953 so that that is not useful unless you also include 1952. and uh so this is kind of automated here and we certainly should automate that in any future uh cdda we export so we don't have to uh do this manually okay so we we the checkbox is empty because we need a convention for how to export something from a doctor and um one question of course is do we actually need a directive uh to control that um so um I said we we can use the name attribute to sort something into a different uh bucket but maybe we want to to annotate this with some additional information so it's clear how this is imported so the export statement that that's in the second line of of the slide is yeah that can be a convention we don't have to write this into the uh document but there may be other things that are a"
  },
  {
    "startTime": "00:38:01",
    "text": "little bit harder to uh infer from from what's in the document so maybe we need something like an export a director fee I'm I don't know of any need yet but we might come up with something so a different thing that that an export directive could do or maybe that's a really two different directors um would be to identify those names in a library module that actually are meant to be imported so for instance well I didn't write all of them but in the Cozy module in 1952 of course Cosi key and cozy encrypt and cause encrypt 0 are really the ones that are meant to be imported and not label or values this those are not definitions that uh make any sense on its own they make sense in the context of a cosine module but they probably need to be namespaced away so your label and your values are not not impacted by possibly inconsistent definition so again I'm not sure we need this I didn't need this in in the current experiments uh but it's something we could do if we find out that that this is useful okay so this is scraping documents scraping Ayana is harder to do because Canada has no defined API so whatever scripting we do is probably going to be tentative and we are going to rework this at some time time when Ayana gets an API in London I talked to some"
  },
  {
    "startTime": "00:40:00",
    "text": "INR people and they seem to to have do you find API on the radar now so the the thought we should be having some discussions in this year and help them Define the requirements uh for that on the other hand um an experiment is only a good experiment if we can do something now um so I was trying to come up with something that that actually makes sense with the the undefined API that Ayanna currently has and for instance for cozy which is always my go-to example there is something called analog assignments called sikosi.xml and in that you can look for registry elements that have record elements that have value elements and you have to look at the the ID attribute of the registry to find out how that registry is actually called and this could be it's extracted using something like a DOT INR operator um I'm not phrasing this as a directive because that director would have to to interact in a weird way with uh names but that's also something that we definitely can can change here uh so the the three variables here are cozy algorithms and value so uh the the values you find in the Cozy algorithms registry would go into a type Choice here that is essentially the content of the dot Anna registry so of course the algorithm would mean all values that are registered uh in the Cozy algorithms registry and of course the the meaning of the changes over time so um that's another reason not to do this"
  },
  {
    "startTime": "00:42:00",
    "text": "at the directive uh is this is only about limiting values or would this also give us some means of annotating um say a numeric value with with its label or with another field because these annotations are something that's I think also on the radar for for cddl2 and getting them from their convenient that's very good comment yes yeah so this is here um essentially focusing on the selection but they may need to be some transformation some projection and so on um and uh we we have to collect use cases like the one you you just sketched um to to make sure we have good mechanisms here okay um scrapping internet drafts is I think I'm mostly covered that and definitely we will only support this for XML submitted IDs so uh those people who want to write the acidity drafts in Android uh they will have to do their own scrapping um that's the thing yes yes I actually worked with someone who was it getting an old um RFC back to Android uh so this still exists yes wow so it's a lot of work for the Secretariat because the Secretariat then has to do the transformation from Android to XML uh since RFC 8650 but yes it does exist and there are also people writing their uh in terms of their world so they're in"
  },
  {
    "startTime": "00:44:00",
    "text": "Greenwood um yeah so when we reference draft and we have the usual issue whether we actually want to reference a specific revision to get a stable uh outcome or reference the newest revision to get yeah the newest outcome so that will need to be specified probably by simply attaching the dash 10 revision number to the import name and then you know it's a specific version except for the one internet draft that actually uh describes how to delete code points 8 9 and 10 from bgp which is called draft something delete 8-9-10 and that is yeah unfortunately it doesn't have CDL in it so we don't have to discuss this um there are of course also internet drafts that have multiple modules in them so the same considerations about using the name attribute for for source code elements and and defining a good convention for that applies here next question scraping other sources luckily the other organizations that actually use cddl um all are stuck in some some weird IPR issues so we haven't needed to do this but I'm hearing that this is changing now um so we we might have some some interesting other seos that expose their cddl and we may want to scrape that so if you encounter some need to do that please tell the list or tell me now next name spacing so um the the import statement here"
  },
  {
    "startTime": "00:46:01",
    "text": "import RFC 1952 as cozy just is an instruction to the CDA processor to actually prefix all names that are in the imported rules that are not preload names with cozy Dutch so the only exception is Prelude names Christian looking at what was done in 9252 um the idea back then might have been to do something like um from from RFC 1952 import cozy underscore wildcard um question is does it still make sense to follow that route or do we just except that this is a road not taken foreign to select from a collection of names is somewhat brittle it might work out here but I would be a little bit hesitant to make this a major feature because this works until it doesn't and you might not have much control over when it stops working I mean for stable rocs it will stay the same but if you are talking about internet drafts or other sdos documents uh that you can get your nasty surprises but yeah I think it's a good idea to to think about wildcarding as a way uh as an alternative way to to um get the the important properties of namespacing without having to prepend this cozy Dot but we still have to do something about"
  },
  {
    "startTime": "00:48:01",
    "text": "uh the rules that are in the transitive closure uh like the the label rule that I just talked about so RFC 1952 has a label Rule and we cannot just dump this into another uh cddl spec because they are likely going to have a label as well and that might be subtly differently defined so we we have to do something here uh and and uh any case so that's actually something that I also talked about on uh no it's three slides ahead I I get to that um just brief question does does do we really have an issue with that label room because that's already in that should be covered by the undefined list so late we haven't a new document has a live defined label so that gets used and uh if the if the inputs are as hygienic as you mentioned then if it has label in there it would still refer to the label that is not addressable from the outside um of of the internal important yeah but the isolation is not that great so if you actually decide to import a rule you import the rule and this means that after import RFC 1952 without an escrow C you have a label in your root set even even if it even if it's not on the undefined list well it gets on the undefined list because something in 1952 that you are uh explicitly importing via you and Define this uh uses it yeah but only for the scope"
  },
  {
    "startTime": "00:50:02",
    "text": "there are no scopes I mean the the result is a cda1 fire and CDA one file doesn't have Scopes so any scoping we can do we have to achieve by by using namespacing then but if I would right now red document uh that says label label is you in and then okay that's probably bad because label is actually label is my my funny stuff and then I import RFC 1952. then you're getting a conflict okay because the transitive closure of of your undefined references is what gets dumped into your CDL file so you get another definition for label with which conflicts with what you have wouldn't the wouldn't the cddr processor be completely within its right to re-enable rename this label to underscore underscore I don't have a prefix for this but I still give clear prefix underscore label and and then have kind of it still can have Scopes and if the thing it exports to doesn't have Scopes it might need to get creative but all I'm saying is that it's probably easier to give the the person who's doing the importing here a way to to decide what that scope name is and then yourself so the the first line uh the the semicolon hash import uh line with the as cozy that makes sure that you won't have that conflict yeah but that also means that if I'm"
  },
  {
    "startTime": "00:52:00",
    "text": "using any document that is not already a set in stone as an RFC I will have to go for as cozy because a new document if a new document revision even if it's like otherwise completely compatible could always introduce some name that I also happen to be using so that that would make not known as Imports it completely hazardous game yes okay but you may not care yeah so um I think the the the convention should be to use this as the stuff and um there may be reasons why you don't need that uh but that's probably because you know exactly what you are importing uh there so the the coupling gets higher if you remove the s cause so there is another aspect about this name spacing uh that uses this dot name character which we actually put into CDL to be able to do something like this um about seven years ago um and um of course there are specs out there that have something like course with Dove dot something uh so they already are using such a name character and that would might lead to slightly uh and weirdly crossword dot crossword dot something in the output CDA so yeah um but I think in in the end since the Importer controls the prefix that is being added the the likelihood of of uh collisions here is uh pretty small except maybe for innocuous collisions which come from"
  },
  {
    "startTime": "00:54:02",
    "text": "uh importing something in a diamond and that's already handled by The Identical redefinition rule so that that doesn't hurt yeah and and I think the important property is that you get told about things you are doing that don't work okay uh racing through this now um the the uh objectives uh for for having and as is to namespace of the internal names what we just discussed and the objective of not using as is to have uh uncut cluttered uh names and maybe there actually is something in between which is this weird statement here which says we impart RFC 1952 as cozy except the name kosiki that is not namespaced so that that may be a little bit weird but um that would solve the problem that you don't want to to get this these names cluttered and of course we could have some wild card rule here um that that would be a place where I would have less of a problem with wild cards okay I haven't implemented this from thing uh yet but it would be pretty easy to do that okay um I have two more slides um one is uh we have to have bike sheds no protocol is complete without bike shots and I think I found the first one uh should there be a space between the semicolon hash and the word import or include so I'm asking you to take home this style questions uh and and"
  },
  {
    "startTime": "00:56:02",
    "text": "when the opportunity hits give me an answer but I'm sure there will be a few other things that that I just chose something for which has a much better choice that I'm just not aware of so please do think about that as well and finally slide almost all of what I said today works with ABN f the only thing that that really is difficult is that ABN F doesn't allow dot in the name so we will have to come up with some other conventions like three dashes or whatever um yeah but otherwise we can do all this for ABN F obviously the the processor is a completely new implementation because the processor is uh cognizant about the the structure of CDA so the processor for a b and F will have to do different things for a b and F but I think the the principles actually work and being able to reference a b and F and possibly have that namespaced is really really used for that so almost all documents that do something with ABN F have some references from 5234 uh like digits and and so on and we should um probably make that easier but right now of course we are not going to try to actually change IBM ABN F but just to do this for the ABN F support in in cgda so this would then at some point actually update RFC 9165. you also have some other ABN F modulations in in on a GitHub repo that I think I will be"
  },
  {
    "startTime": "00:58:01",
    "text": "telling people about soon foreign questions comments yeah you had one small thing uh and yeah I need to look into this a bit more to understand it better to give some some more but one thing I had in mind was the these as keyboard that could be used for both to import and include statements is that correcting can you say it again the answer the ass term or keyboard could that be combined with both include and import yes yes originally I only wanted to provide it for import but then I found it's easier to implement it for both okay but that that then okay fair enough then I get this so it's usable for both okay yeah thank you my comment is it's a lot to digest yeah it's incredibly simple I was really surprised but it's like 80 lines of code or something like that and it's nice though yeah for me I didn't mean for the processor um I I also have a comment um on the on the topic of import as um I would one hope that I have for cddl2 is that it will help me match the match and match an item that has cddl that is that I know to follow some cdtl with code that I have um and when items get when cdtl gets names"
  },
  {
    "startTime": "01:00:00",
    "text": "get changed through that import I may want to still have access to that original name because um it that that name might be somewhere in the code because I'm for example parsing it into some cozy structure that knows all its items by the original name um I I'd assume that if my processor where cddl2 aware it wouldn't need to go through the expansion and would thus see the items somehow in their original form but I'm not sure how that would work the way I'm thinking is like like you like in in I don't know if it works in C definitely it works in Rust where you can have a function but also tell it that its name for the purposes of linking is this and that roughly that that mindset I don't out of that is covered by the fact that something like import from uh will simply generate Foo equals cosine.fu rules because that's much simpler than uh trying to to change the imported module to use the unnamed spaced name everywhere um so the information will be in the rules uh but yeah I think it would be nice to be able to recognize automatically added namespace prefixes so maybe we need a different convention like dot dot and not just dot dot dot could still be present but maybe maybe the programmatic approach is like already good if it's if it's somewhere in the metadata I'm good you would warn people that it's not the great idea like not the great idea to start very real names with underscore and see like like everyone he did that"
  },
  {
    "startTime": "01:02:02",
    "text": "yeah but I mean everybody who works with C knows that they will get be get burnt so uh yeah right you would hope so there may still be a good reason to want to get the entrepreneur yes yeah that's an interesting point I didn't think much about uh yet so thank you for that I guess we'll come back to that when the topic of of back annotating siboro comes into well annotating cable comes up okay any more questions on on this anything for any other business uh here again there's one very brief sorry um customize that yeah I just wanted to say that my uh objective here was to get you to actually play with the thing and install cdlc in a recent version and start using it in your project so I get some more feedback about how well it works it works and where it actually starts hurting speaking of how well it works um when I don't say cddl I get some EST output is that stable and well documented and or has a plan forward because that looks really nice and I may want to I'd be much rather pass this than cdtl exactly that's one of the reasons I wrote the tools because people want Json and and no don't want to write pauses um so it's documented the freezer document actually has the section about that um it's also actually an AST and I found that I actually want to process uh rules before actually working on them so there is a second"
  },
  {
    "startTime": "01:04:00",
    "text": "form that you get with a dash r uh flag for Syria at Sea and that's actually much more useful but also it's not documented so what's that funny what's that t flag Dash r cdlc-r and then you get another form of Json that for instance has parameters of generics uh resolved so you you no longer get the name of the perimeter which which you really don't care about because it might be conflicting with some other names but you get a number that is local to the rule that is using the generic and these are the little things that are done with the dash R and it's the dash R form that uh I actually know how to uh do these these cdl2 things on and that is also supported by the CDL writer in in the tool what language is that because it has a equals greater than and it doesn't look like Json but it doesn't look like that sibo types take notation either can you probably see it in Json oh yep thanks yeah one action point for me write this up it's of course not it's even simpler than than the AST stuff but I have to write it down great thank you everyone I think that's it for today see you all in two weeks well actually"
  },
  {
    "startTime": "01:06:00",
    "text": "in one week because that's Seaboard but yeah have a nice evening yeah same to you thank you bye-bye"
  }
]
