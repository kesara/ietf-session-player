[
  {
    "startTime": "00:01:12",
    "text": "good morning everybody we\u0027re gonna get started just we do have a few remote participants so please be sure to use the microphone when you\u0027re making a comment so they can know what\u0027s going on hello welcome to the tough session for idea of 100 if you\u0027re not here for taps maybe you can think what you want to do you can leave your stage so this is not well not very well if you are not know what it is it is uh you can read about it on now online yeah as I said PC stops working of I took hundred meeting and my name is Jo Jo McArthur and co-chair to our own fault Erin so this is our agenda huh it looks like so we\u0027ll have chairs update then we have a couple of jobs that will be presented and then at the end we have like ten minutes for discussing on Saturday and three anybody wants to bash this as endure yeah I\u0027m willing to have my section be shorter than 25 minutes because it probably doesn\u0027t need to be that long so we can have more time on the Charter at the end I think we should have that yeah we\u0027ll see okay so this status we have two drops that we have sent in artist editor queue it\u0027s waiting to so so congratulations and I would like to especially like to especially thank the authors and the reviewers of the draft job well done thank you on the Charter random - we have between the item 9900 we have adopted this draft so I think we are going to have some updates on that one on charter item 3 we\u0027re pretty good in a good situation there are a bunch of drops addressing "
  },
  {
    "startTime": "00:04:13",
    "text": "these socket soccer intents happy eyeballs and there is a guideline and trapped on how do you do resting and there is a new draft from neat project right so we\u0027re pretty much in very good shape there we have multiple document addressing Chapter three so in this in this meeting actually we\u0027re going to talk a lot about about those traps and how we\u0027re gonna proceed with that one so that looks pretty good on the security topic I think we had an action point so updating the Charter we have some such detects that will very soon we\u0027ll be doing discussion discussing and there will have a solid draft Chris told me you guys have been updating that one and you wanted to have some review from the on the working group so you want to say something more about that yeah Chris would Apple we didn\u0027t make up its in time for the tracker but as discussed in the last medium we\u0027re trying to go through and just add as many more protocol descriptions that we can to get it pretty expensive and cover all our ground so yeah when we do update it will send an email to lists and hopefully people can read it and give us feedback and see how it goes from there I don\u0027t know what we have to do with regards to the Charter update we talked about it during the last meeting I don\u0027t know official what the official process is for updating things but okay yeah so so this is how it looks like so yeah so I think we\u0027re in a pretty good shape so let\u0027s talk about these security functions so we had a discussion of the last meeting about whether the Charter permitted us to include transport security protocols within the scope of the abstract API I went back and look at it and it doesn\u0027t specifically exclude it but it seems like it\u0027s a good thing to have charters talk about what you\u0027re going to do and that was the direction that we got from from our area director so I made a small hack to one of the paragraphs in the Charter and basically basically the first thing you do is you set up your new keyboard and so we had a bunch of discussion about TCP because TCP Inc was just kicking off when we were starting off here and that\u0027s not really relevant anymore and so that\u0027s a little bit of distraction but that a sentence here that says tab support for security services provided by existing ITF transport protocols and that\u0027s a phrase that we use for the rest of the scope of what taps is doing is in scope however taps is not chartered perform detail of thousands of security aspects of transport protocols so the so we kept that original statement which is to reassure people we\u0027re not trying to do new security stuff here but we do want to make it clear that security related functions are in the scope of what a taps API could do based on a quick interaction with Spencer he I got an early thumbs up for this if the group folks in the room are comfortable with "
  },
  {
    "startTime": "00:07:13",
    "text": "it we\u0027ll send it out on the list and then assuming that there\u0027s a however that converges then we\u0027ll go in submit that as a charter update and now our area director has something to say Spencer Dawkins responsible area director Aaron and so head and I had had the conversation mostly about the beginning of this you know what that would say and not so much about the part that\u0027s going away about TCP Inc are you thinking are you question is are you all thinking that that has been overtaken by events or they are that there\u0027s no work to do I think that it\u0027s basically a subset of the work that\u0027s described in the new sentence that\u0027s added to the first and if we left it in there then it just makes it better kind of confusing and charters are hard enough to read as it is dead makes more that that makes even more sense to me than what I was hoping thank you so much so you\u0027re alright with that Chris Kyle you got a comment I do Kyle Rose so the the discussion that we had offline about about there are properties of security protocols that we may need to abstract away and provide as knobs for taps users so for instance for token binding needing to have a channel binding is something that the security layer needs to provide does this language preclude that my intention of framing it that way is to allow us to have that conversation I didn\u0027t want to try to do it before writing the Charter I did want to allow it to happen in the room is that you know ideally if we can come up with like some general statements of how an application might ask for or interact with security functions that are integrated in the transport layer and I think that what you\u0027re time out we took combining is part of that I think that this language permits that okay I mean I just say it\u0027s like sort of the fine line of we\u0027re not chartered to perform detailed analysis of security aspects of transfer protocols is we need it we need the security you know any security layer that taps is going to make use of to provide a channel binding is that detailed analysis I see you\u0027re pining I didn\u0027t really want to touch the earlier text because that was sort of the let\u0027s not alarm the folks in the security area statement but but I interpreted that as a we\u0027re not going to try to do anything related to cryptography and or new security mechanisms that\u0027s that\u0027s the intent right that\u0027s really sort of security design and engineering where\u0027s I think you\u0027re right that what we are talk about doing is some analysis I mean it seems like like the the draft Tommy and Chris\u0027s draft on on the survey of transport of the transport security protocols you know okay how about why don\u0027t we replace the word analysis with design perform well let\u0027s maybe think "
  },
  {
    "startTime": "00:10:15",
    "text": "about that a little bit okay well yeah think about that I mean we don\u0027t need to make a decision here but your points a good one and and I would rather have the charter be correct then not touch things just because it could be okay thank you Amy it\u0027s Apple yeah I was just gonna say I interpret the security services as the knobs that we want to expose and yeah analysis maybe could be construed as potentially creating things that and we don\u0027t want to touch that or open that kind of worm so maybe just simply say that we\u0027re not doing any like you said security engineering or creation of transport security things yeah um so are you comfortable if I replace something along lines we\u0027re placing the word analysis with design and then we\u0027ll see whether Spencer gets any pushback from the isg and worst case we leave the existing wording in there and do what we\u0027re going to do anyways yes I would like design better I think okay Kyle you\u0027re you\u0027re taking notes right tails not here yet can you write that down thank you it\u0027s not sure you got something okay okay what\u0027s in it you want you some security engineering you have to leave the room hey all right this should be smooth and easy I hope it\u0027s a quick update about what I did to the min set document in a nutshell oh yeah it begins by saying also because I changed the sequence on this slide sorry first of all one thing that I added to this document was to have early configuration so that we can avoid issues so Francis if you read the main set right now and you would say well okay this is how we\u0027ll implement isn\u0027t associate and the protocol and let\u0027s say let\u0027s not build the tab system let\u0027s follow some of one of the API proposals you may end up you know making a choice for UDP based on what the application wishes and then the application says let me have reliability and that wasn\u0027t a good thing so you know a tap system needs to have some information early to make some decisions and there is a proposal in there on what for instance such a decision tree I called it the decision tree could look like but this is really only written as Nix so this is not that not as systemically arrived as the rest like they\u0027re back I want I don\u0027t want to say I can prove this the ideal decision tree based on "
  },
  {
    "startTime": "00:13:15",
    "text": "all these things it\u0027s an example of how you could avoid cornering yourself and then people asked at the last ITF to consider also you know supporting UDP and like discussing you know what would happen or like how much which of the things would work with UDP or not and I\u0027ve done that and make it clear that this is not an API proposal that was a request from a couple of people here so I wrote very explicit text I considered writing don\u0027t be afraid of the main set but it isn\u0027t an API proposal it\u0027s just you know a more clearer simpler coherent way of writing the services up so this is why the test is kind of form I think it\u0027s clear enough if you object to any of the text there is not clear enough I\u0027ve I can repeat the sentences three three times or something yeah I think you will okay so the example decision tree I\u0027ll just present it because it\u0027s in there I\u0027m not saying this is perfect anything you know very happy to get feedback on it\u0027s just an example but you could early on you could I mean this would actually at least if it seems to me this would cover at least the things that are in the main set and you wouldn\u0027t even call yourself on them you could ask for some form of reliability do you need this if node and you could I\u0027ll use all the protocols that are available you know based on the upcoming next requests you could then ask is any of the following useful to the application this is just looking for the set in the min set on specific checks on coverage specified checks and coverage required by the receiver and you can choose between you to be light or UDP and if you do need some form of reliability you really should be using SDPO TCP out of the set of existing protocols there so there is a disclaimers that we will call TCP you know with a TCP replacing vampy TCP or T or TCP hmm said you have two following useful handing over a message to reliably transfer before connection set up that\u0027s something that for instance SHP doesn\u0027t do but at the TCP does suggesting a timeout would appear notification of excessive retransmits notification of ICMP message arrival that\u0027s the stuff that TCP does and SCTP doesn\u0027t so in this case you will be having TCP instead of SCTP otherwise the recorder preferable you know full set up and then you can make your decisions possibly some stuff is missing I don\u0027t know I don\u0027t think so I mean I went went through the list and tried to basically cover all the stuff that is in the remaining list of the min set at the end and sure make sure that there wouldn\u0027t be anything that you were pick honoring yourself against this is just an update of the interface description the description is pretty much the same that I presented the last time except that I "
  },
  {
    "startTime": "00:16:15",
    "text": "marked some things with being impossible to support UDP fallback that you know doing this over UDP this would be the configure time mod it because obviously TCP doesn\u0027t have timeouts it doesn\u0027t have closed in that form it has some sort of an abort in that you know you can tell that you don\u0027t want to use this connection state anymore locally but close comes with the semantics of a message to the other end to tell the other end about it tui repeaters and UDP doesn\u0027t do that and then the parameters of send frame like choosing reliability choosing all that or not order choosing idempotent that stuff that UDP doesn\u0027t do and if you okay yeah so I guess add important is actually a mistake because that was about falling back and that doesn\u0027t actually you know just because they specified that it\u0027s unimportant doesn\u0027t mean that you have a problem with it arriving only once so that is a mistake but I think reliability and all that you know requiring all that is a mistake yeah some of the notifications a timeout notification close about notifications they wouldn\u0027t exist in UDP and the rest is just the old slide so this hasn\u0027t changed so that\u0027s what that is you know this was just more efficient condensed way of writing transport features it isn\u0027t before post APR repeated here a your obsessive very explicitly I did ask about fallback to tear this but I think this answer that I got from Tom animating this I I mean this service to discussion in my opinion I don\u0027t I think it\u0027s I agree you know I don\u0027t think that\u0027s the point in discussing it fall back because it should be something that\u0027s explicit anyway it\u0027s a it\u0027s a choice all the way I agree with that easy yeah well what else do you guys need from Fond du min set is like just the end of it already I prank Rommel is this an API specification it sorry sorry sorry sorry so there\u0027s a there\u0027s an interesting question on this slide that I think has nothing to do with this document that I just wanted to raise up and say we should think about is so there\u0027s an implicit assumption in um sort of the way that you\u0027ve ordered the protocols and then set that like there\u0027s UDP and then there\u0027s TCP in the nursery you\u0027ve ordered them essentially in order of additional features that you can get with them and then there\u0027s like TCP is the floor and then UDP is the subfloor and from a um from the standpoint of you know you have a feature set you need to meet it I think that\u0027s absolutely a right way to look at it there\u0027s this second sort of externality which is what can you get through the network which we should think about somehow and this when you talk about it fall I can t OS or HTTP it\u0027s like yeah you might have to go that\u0027s like so it the order is like more complicated services with less complicated services it could be in the subfloor is TLS with HTTP I\u0027m going to encrypt it and you know let you figure it out and then there is TCP and then "
  },
  {
    "startTime": "00:19:15",
    "text": "there\u0027s UDP right in terms of what gets you the network yeah that might be interesting to capture somewhere but definitely not in this document so I think this is getting pretty close to it to done so thanks okay Tony Pali Apple so one thing just on what you would started out with I think that yeah it\u0027s definitely good to emphasize that the configuration of what you might want to use out of the features does need to happen at the beginning before you end up creating things making that really explicit because that\u0027s essentially a something that we\u0027ve learned by doing the min set which is something that any API will want to build on top of this needs to take into account essentially says all of the feature space you want to use needs to be defined beforehand because if you end up saying I want to do this now halfway through the connection that could be really bizarre very awkward so Brian did you see the email I did sent out two lists earlier today okay because you essentially repeated exactly word for word what I had said about this so and we didn\u0027t talk I swear right so I think I like the document I think it\u0027s a very good survey of this I think the main substantive change I would do to it is just to kind of remove all of the references to fall back because that\u0027s much more of a normative time-based claim about what we prefer what the ordering is and maybe the order is what you say I think oftentimes it would be for feature set but there are other cases in which we may have different preferences there may be two completely other protocols that we have in the future like quick blah blah blah and so just for those who have not seen the proposal essentially what I was saying was for the feature lists where we have you okay protocol is SCTP and fallback to TCP does this fall back to UDP does this instead just for each feature simply list these are the protocols that implement this these are the protocols that can safely ignore it and these are the protocols that will not work with this and the idea of what order we want or if even if we just choose one is left to a later document something like the happy I abolish document something like an API document what\u0027s supposed to be in dr. as a service to those who haven\u0027t see my reply to that email I\u0027ll repeat that I agree with everything very easy so Spencer Dawkins is a curious individual I actually got up to say about 80% of what Tommy just said without me actually saying anything which is even better than getting somebody to say something without sending them an email this is why I\u0027m an area director I\u0027m just yeah so I have a couple of questions first um what is on the list of things that you believe have to happen before you can say this document is complete "
  },
  {
    "startTime": "00:22:15",
    "text": "incorporate Tommy\u0027s commands give it another proofread okay so it sounds like there\u0027s there\u0027s no additional content that you think needs to be generated other than Michael do you stand do you have any okay can I see a show of hands in the room of the folks who read the latest version okay so it looks like about maybe eight can I see a show hands of people who have read the min sets in the last six months a version it\u0027s more like 15 all right okay so that looks like it\u0027s people are reading it that\u0027s good so let me just ask the room is there any comment on so Michael taking the making the revision that was discussed this morning and then taking the document to a working group last call does anybody have any concerns about that that they want to discuss okay let the minutes show everybody loves that idea is tail here yeah oh okay the remote the negative Microsoft um is there any other active decision other than characteristics of the transport layer things like do you need this to run on a very small constrained device the reason I asked that is that once you add that into the possible axis of decision then other quarter code transports may come into play like coop specific air which from this point of view or from a point of view of the classical transport layer its application but actually it\u0027s being treated as a transport in many communities and you know some of those internal to like yeah or or other transports quote-unquote transport like that so it has that been explicitly uh you have to be out of or some reason well I mean this is so the men\u0027s that is based on the preceding document which is the users document which also relates to this RFC that gives a survey of things that we decided here to call transports I don\u0027t know if co-op is the part of that RFC I don\u0027t I don\u0027t think it is so I think we just at some point said we\u0027re gonna analyze what was it TCP UDP UDP light MP TCP leopard SCTP theäôve was the list that was just well anta means that it\u0027s just a matter of taking taking bodies and these are the document and saying you know how do you do fall backs and how do you which of this stuff do you really want to expose okay so maybe for a second everything another protocol is now a bit of but yeah because I did hear somebody mention in the future maybe we\u0027ll consider quick which is obviously missing in this one but yeah if it should be added in the next revision I suppose at that time it\u0027s something built on top of UDP not very different from what co-op can be or the main that at that point it might become "
  },
  {
    "startTime": "00:25:16",
    "text": "my hope I mean this is not explicit in the document and I would like to have at least a paragraph in the introduction saying this my hope is that because SCTP is a very very broad protocol it does a lot of things that you\u0027re not probably gonna very gonna get very very many things from newer protocols that that needs to be the D to be in the API that this document doesn\u0027t cover so might be won\u0027t feature here or there but not a huge amount and so that\u0027s that\u0027s also the case for quick-quick isn\u0027t a part of the end of the analysis because when when Creek is still even now it\u0027s still a moving target was this makes it hard to analyze I I think that let me I think that the goal the main set was to identify the minimum set of functions that a taps API should support to allow applications to get sort of basic functionality of what the existing idea protocols provide and the idea being they need more specialized stuff that the protocols can provide then you do it outside of the API it seems to me that if Co app is a candidate transport protocol the way that you\u0027re thinking of using it yeah that a useful test of min set is to say are the set of functions that min set says you have to support things that Co app can provide and if co-op and if there are answers where it\u0027s no that might be an indication that co-op isn\u0027t really a fully functional transport protocol it doesn\u0027t mean sort of the minimum bar of what you can do for a transport protocol or if the answer is no and you think that that it is acceptable then maybe we\u0027ve got stuff in min set that doesn\u0027t belong there so I don\u0027t think it\u0027s so the first step was like let\u0027s survey all the existing transport protocols to try to figure out what the functions are and then distill from that what like the really necessary functions are and then we come up with sort of the template and now if you\u0027re going to build a new transport well this is these are the things that you need to do well maybe co-op is doing that and so it would be great to use that as a test form in set to say oh you\u0027ve expressed things in a way that don\u0027t make sense to us or there\u0027s stuff that\u0027s missing or stuff that we could never provide but we think it\u0027s sufficient anyways so that would be a really nice discussion to have on the list yeah going through that the motto I I have in my mind of how this could work would be similar to motto applied ni RTF like I CCR GE and CFR GE they are sort of like places where you go to have a crypto advice which applies to many potentially several working groups tonight you have similar for congestion control several working groups in idea of mission control issues this could be sort of that source of I guess advice for people work in different transports and so you should probably go off and shop or expose this work in explicitly things like poor work looks like core and and others that are working on where to sequence while others that are working "
  },
  {
    "startTime": "00:28:16",
    "text": "on on transport issues it\u0027s a great idea I agree you seem like maybe something we should bring up it dispatched where where what\u0027s the forum where it would have reached the coop folks other than you happen to wandering in the core the core working group for that particular protocol is there anybody anybody in the room who\u0027s active in that group Hamas was she consulting yes actually I look at prom literally flipping it over I\u0027m really following this and very interesting for instance how would I run co-op over can FD in a car or run it over SMS and what sort of a sim and my other need how thin of a sim I\u0027m going to need such that I can be the co-op application can use this API and not know that one side is on can FD and the other side is this this co-op bus server up in the automotive cloud going through a canopy IP gateway where it gets stuck on UDP or whatever needs to get stuck on to go that way so that is what my looking at my my layering history to do this that how is this API now gonna make a possible where I\u0027m working with Macs that can\u0027t possibly run a transport for the limit either because if I is too limited or the Mac is too limited Aaron probably would so on you know that\u0027s our stuff so does this give me have you done this completely enough such that now we can say co-op you don\u0027t care what the transport is you just call this API it\u0027s a matter of the shims underneath which make this decision that I think is your goal so if you looked at min set to see does it doesn\u0027t I\u0027ve not looked at the last graph the previous graph it was not there this last graph I\u0027ve been very busy doing some like crypto stuff um work but I got to get back into it my will that would be a great reality test exactly yet that is my personal view and I\u0027ll be giving feedback along the way on this as thank you right Tommy Polly Apple yeah I think this discussion is very good I mean I think for the purpose of this document the focus on the existing transports that we\u0027ve already surveyed is the right way to kind of distill that set but as we go on to discuss API stuff of course you know any abstract API for taps should incorporate any of these other pseudo transport options to abstract the transport layer away sufficiently and I could imagine essentially using this min set format or wherever we come up with here as a prototype for future documents that essentially define the mapping of X Y Z other protocol transport or a layer two thing as something that could be represented beneath these basic functionalities so we may also want to think of that of how "
  },
  {
    "startTime": "00:31:16",
    "text": "like we could end up with like mapping documents in the future that look like this you nice to have one for quick yeah me I could live in so a completely different comment I\u0027ve been thinking about how to map this to post sockets right and in post sockets we have like those boxes which all have some kind of interface and then we also have this one magic box which is like the configuration rate and you have separated the interfaces you have into think that are related to connection establishment and things that are related to data transfer but maybe it would be nice to take out of both of those categories everything that\u0027s rather something that is configuration and it\u0027s not essential to transferring data or getting the connection set up and have like a surplus in there because that would kind of make easier to make it to configuration so afters maintenance category that\u0027s that\u0027s I call it maintenance but it is what I met this with configuration stuff what\u0027s in the maintenance category I don\u0027t know it by heart weakness is a subset of configuration there\u0027s configuration that gets all you want to have you open all connections set up to add on to call the whole same configuration so um Tommy Paulie so Michael in some of our emails about post sockets and I guess we\u0027re going to get to that presentation next so we can just transition I had been bringing up the like the idea that there were pieces of functionality that are kind of like core transport functionality and then I was saying like and then there\u0027s kind of like the protocol specific things that seemed to be fitting on the side and perhaps I think that\u0027s the distinction that mirror is making this like things like I want to initiate a connection things I want to accept a connection I want to read I want to right those are absolutely fundamental things and they\u0027re certain maintenance things that are absolutely fundamental to the live interaction and then some of these other things like you\u0027re saying I want to disable Nagel I want to do this I want to set the timeouts those like anything that you say this needs to be expressed as a requirement before the connection gets created he is kind of that configuration bucket so you could add a distinction there that this is this is something that they like for example no so no application would need to say by the way I want to call initiate connection they\u0027re all going to do that but they will have to tell you I want to do this functionality or I give you this functionality for me so that needs to be said up front as a configuration right so yeah I mean you need to distinguish between what needs to be set up front and not but other than that I don\u0027t personally like drawing a line and saying this is kind of not so important functionality this core functionality you understand that number act but we\u0027re back to the old ways right you can send and receive and you have maybe the things that and you miss out on some services that would be good to have like for instance in your example that was to check some configuration bit I don\u0027t know on what basis you would say this is not the core "
  },
  {
    "startTime": "00:34:17",
    "text": "functionality right this because it\u0027s tasting it\u0027s not really about or and being more or less important it\u0027s really about fundamentals so without dysfunction you cannot communicate you need to call it some at some point in your way through all the function calls you do but like you know then you have just send receive pretty much unusual or like I\u0027m I don\u0027t see the point it\u0027s the point is to to map to to get the mapping between what we do in post socket and rise but I don\u0027t want to change min set for post occurs I think you should change post office for min set because well because the mins that describes the functions that are there right if they say these are not call things and then it just makes the mins that just I mean poster is just just do the call things that\u0027s not the right approach no no it\u0027s like it\u0027s it\u0027s not that we\u0027re not doing it it\u0027s just like in which box they go right and like if we change if you change it and post okay it\u0027s a completely different proposal sorry I mean I read post sockets I know the boxes yeah so what\u0027s the box so that there is a box which is called configuration it\u0027s called configuration and like and I think it would be important to know which function should go in that box 10 minutes over the line after keeping keeping on - you know my tradition of restating things that Tommy has said so there\u0027s I think there\u0027s a useful distinction in the distinction that you\u0027re making with respect to there are things that you need to do before setup and there\u0027s things that you need to do after setup that\u0027s a very clear line in sort of a configuration space it\u0027s like you cannot reselect a protocol there are also things you do like you can\u0027t um once you\u0027ve you\u0027ve decided which transport port you\u0027re going to use in TCP you cannot change that the destination transport port without having a new connection right so these are this is sort of a connection set up versus connection maintenance side I think that sort of the to rephrase what Miria said I think that the disconnect is this is necessarily bottom up right like min set is is designed to be bottom up in order to get us a yeah it\u0027s so let me ask my Jo question again is this an API specification and let me answer it yes it is it is a specification for the API in which you implement API is that you hand off to the application yes Swayne this is how I there\u0027s always you could easy to write posts yes oh yes so for instance when we say that certain things need to be known at the beginning and you can you just said you cannot change what\u0027s well with post sockets you might be able you create because because you can where you just create a new than you guys tutored on a connection open your new connection whatever I care gets me yes I right yeah the bottom layer they get basic they want to build is on is the set of the services that the protocols that that\u0027s what that describe and so so pro sockets essentially any post hoc encirclement ation is essentially an inter layer no I think I don\u0027t think that there\u0027s always a clear "
  },
  {
    "startTime": "00:37:17",
    "text": "to hire they wait like so why I don\u0027t see it would be it would be so I think what Miri was saying is that it would be useful if the configure a sort of a knobs that we have here were organized in the document in a slightly better way but like fundamentally you know most likely postdocs and implementation is an inter layer and you can I mean just throw another layer in there and adapt it so I don\u0027t think we have a big problem here right I mean I\u0027m not religious about this you know its distinction I made about maintenance and actually set up and tell whatever it\u0027s so we can\u0027t discuss about how we organize the texture briefly Goering I think I go confused I like what Michael said and I didn\u0027t quite understand the disconnect with the pulse sockets but I guess we can see that up on the list yeah well we have an agenda in amman po socket so maybe we will have an opportunity to revisit them thank you my god I think we\u0027re in the Folsom yeah they right we\u0027re already there yes so okay Brian now it\u0027s your turn at the microphone and Michael can ask you questions all right um hi I\u0027m Brian Trammell actually for my curiosity who here has read this document okay a few people good good so I\u0027m assuming that you\u0027ve either looked at 0 2 or 0 3 and that you\u0027re kind of up to date with this this is not the hole we\u0027ve already given the intro to post sockets like five times this is the changes this is the detail changes so this is changes since 0 1 because 0 2 was I I accidentally submitted a draft that had a whole bunch of editors notes in it that should\u0027ve been in there so so it\u0027s like 0 2 and then like 30 seconds later 0 3 came out and it actually breaks the data crackers diff tool it doesn\u0027t know what it\u0027s supposed to difficut it\u0027s pretty cool um so you may recall from last time we had a quick framing discussion about how scary policies are it turns out policies are still scary so we decided to rename them and call them configurations well no no no so there\u0027s actually there\u0027s there\u0027s a there\u0027s a real reason for doing this is is policy in a lot of contexts implies something it\u0027s much higher level right that\u0027s much you know I would like to have a connection that works anymore or something like this or I\u0027d like to have a connection that works and I don\u0027t want to use this interface because it costs too much unless I\u0027m in this situation right and this is like at a much higher level than one min set is and then to I think we can realistically talk about at this point right so what we can realistically talk about now are are much closer to the min set "
  },
  {
    "startTime": "00:40:18",
    "text": "configuration stuff so what what are the aspects of transport protocols that I\u0027m willing and able to use and then there\u0027s also this explicit separation where we took so in let\u0027s go here this is the slightly updated thing so this is the magic configuration box over here on the side we put over on the side so you wouldn\u0027t notice it the this is a protostar protocol stack configuration which configures a protocol stack instance which implements a transient and we basically took all of the things that you might want to push down to a specific protocol stack instance and stuck those in a protocol stack configuration so you could say for example my my configuration requires a reliable transport protocol if you happen to select TCP here\u0027s what I want you to do for congestion control and timeouts and whatnot there right so this is where the protocol specific tweaks live so this is why I\u0027m I\u0027m not worried that we can take everything in min set and put it somewhere if it turns out to be specific to a protocol or a subset of protocols we can just push it down into the PSC there\u0027s a new most of the work here that we actually got in for this Rev is in the API dynamics section so this is some ASCII art that attempts to show how all of this stuff fits together this is we used to have some examples which were just a sketch in go code and I got a pull request from somebody saying your go code doesn\u0027t compile like that\u0027s not the point so we basically said okay let\u0027s work all this out in something that\u0027s clearly not meant to compile and then we\u0027ll bring some examples in an appendix after we have prototype implementations that we can that we can use that will actually have building code in order to head off those sorts of comments these are the abstractions like I said before nothing much has changed here other than we\u0027ve got a little bit more detail and understanding of what\u0027s going on with configurations does somebody want to interrupt me here Spencer Dawkins as a curious individual is actually on the previous slide if that\u0027s okay so the thing I was curious about here or was if you were thinking that the PSE I guess would be something that\u0027s required or something so if I say I want a reliable stream and either end I don\u0027t care about the details you would be able to run with that so there is an unwritten in this river the document there is an unwritten principle which we need to write down so in some of the discussions we\u0027ve had before this meetings or in the hallway is for come clear that there are a few prints there are few principles that we\u0027ve kind of had in our heads when we\u0027re designing this we haven\u0027t written down yet that we need to write down and one of them is if you just go here and you say I create a carrier with initiate and I start sending messages at it and I don\u0027t do anything it does something City great so you you don\u0027t have to create a gigantic block of XML or something else horrible "
  },
  {
    "startTime": "00:43:19",
    "text": "and poke it into the Association before it works you you if yeah the it\u0027s a hard requirement that um initiate go just like in in in the current sockets API I just you know I have some information and I just I in order to create a socket I create the socket and I go that\u0027s a hard requirement of this arrangement the protocol stack configuration is really think of it as if you\u0027d if in a current operational situation you would go and put something in at ccTLD in order to change something then you\u0027re messing around with the protocol it\u0027s that configuration if you wouldn\u0027t think you\u0027re not thank you that\u0027s very helpful what my concern was you know we\u0027ve got like I don\u0027t know 20 or 30 years of applications that know way too much about the transport yes and I\u0027m hoping that that knowledge doesn\u0027t get stuck someplace where the application could still find it how and let me just still just continue to say if you\u0027re if your point was that the you know the default if you don\u0027t dork with it will work you know it unless it won\u0027t work for you you know something good will still happen that that means that most protocols both most applications may not end up with a lot of protocol specific knowledge that they don\u0027t need that they don\u0027t need that would prevent us from doing SCTP deployment you know in not that but you know in G here\u0027s what we hope we hope and I actually Tommy has a little bit of experience with this and it seems to to not be an incorrect hope so far we have this durable state here which holds information on a per path basis transport protocols generate an enormous amount of self measurement information and can be used to essentially figure out for a given path in a given situation for a given carrier from a given application protocol um this is the right thing to do right this is so you know we refer to configuration as the magic box actually Association is the magic box configuration is the box that you use in order to restrict the magic rate how hard it is for an application to poke a PS en I don\u0027t think it can be any harder than as ECT LTE and set saw copped but um if we want to make that harder I think that\u0027s probably implementation specific you know you have to break a hash and give it a Bitcoin and then you get to do something um but I didn\u0027t actually mean that just clear but but yeah so yeah this is exactly our goal exactly our goal is to you is to obviate the need for a lot of this dis dicking around with socket options because what you get by default is just better yeah and and thank you thank you for a very helpful answer and it\u0027s just because you said what I was hoping you would say that doesn\u0027t make it right but that you said well I was hoping you "
  },
  {
    "startTime": "00:46:20",
    "text": "would say Thank You Tommy Polly Apple just to that point briefly I think one thing that Brian said is I think it\u0027s key for these protocol side configurations is that I think it needs to be expressed in the API that this is if you use TCP set this weird wacky option if you use se TB and I think it would need to be clear that taps may choose whatever it wants and these are just extra knobs if you\u0027re a weird geeky TCP person you could certainly put something up in the configuration that says use TCP you create if you are a one-sided oh and this is another one of those principles that we\u0027ve not articulated is it has to be possible to use post sockets on a single side of a connection and have just circly sockets on the other side of the connection so in that case either taps will look at the association information and figure out oh okay I\u0027m not dealing with something on the other side oh and another principle that we have is that you shouldn\u0027t have to implement you must not have to implement transport protocol external signaling mechanisms in order to make this work this is not this is not like dynamic network stack negotiation because every project I know that\u0027s tried to do that got to the dynamic network stack negotiation part and said oh look we\u0027re out of money we got to go the so another one of these prints and that would basically if you\u0027re if you\u0027re really in this situation you know in that you\u0027re in that situation you\u0027re always gonna be in that situation you can always just poke something down into the thing that says use TCP and again it\u0027s it\u0027s probably implementation specific as to how you express that whether you have to trick it into doing that or whether you can just say like with like with um get out or like the the old get out our info hack where you had to like you know get out our info and then poke IP prototype en to it in order to get it to us STP yeah I mean this is we this is the magic box because that\u0027s the place where we put to do all those tricks um the then the one other thing I actually came up here to say as an author another change in the draft just for people who are reading it is around messages and the fact that because we like the mist of destruction but there\u0027s the whole problem with streams and like if I\u0027m just going over plain TCP what does my message mean and the solution that we came to there was that each side of a TCP stream is just one really big long message and so it means that the API for reading and writing messages may come in multiple chunks and I\u0027ll just say at some point this message is done and it\u0027s kind of degenerate but it allows us to put everything under that umbrella right without having to like have yeah we had this we had this other hack before that was worse so this is the better hack praveen baddest women in Microsoft so protocol stack configuration right so if this is if this is part of the API surface and there\u0027s there will obviously be system policy as well administrator configured for example how "
  },
  {
    "startTime": "00:49:21",
    "text": "do you reconcile those two is it is are both of those expressed in the same way the other question I had was is this an abstract representation like reliable semantics or is this the application allowed to say I want to use TCP so which way are you leaning towards so this is an abstract API so we hope that concrete implementations of this are going to have compatible representations of configurations and protocol stack configurations how the reconciling happens is that goes back to my taps the ITF 99 presentation of the jokey answer is it looks a lot like cascading stylesheets in that you have in it within any given system a defined hierarchy of which overrides which and then you just blow through the hierarchy and you get an instance right so there\u0027s hopefully we\u0027ll have inheritance rules that are less inscrutable than those used in CSS and I think we can get there because a lot of the externalities aren\u0027t the same but they kept that the point being is that they essentially cascade right and as long as that cascading is predictable and I think that is something that we\u0027re gonna have to drill down to on this abstract API is we\u0027re gonna have to make a choice about how that cascading works on the abstract front there might be applications that actually do not the API to be abstract so we might have to have cases where for example the application explicitly chooses it\u0027s for example TCP or quick right what\u0027s that we\u0027re gonna stop this discussion in five minutes so you guys can find out amongst yourselves but we\u0027re moving on so I think just the main point there is the abstract API should make it possible to do any of these protocols I think it is absolutely necessary in some cases that they could say I only want this one but the bigger point is that if I want to reuse my code for using transports in other places I don\u0027t have to rewrite it entirely to say now I want to go over this other transport I just flipped the bit to say now I want to use this one instead of this one yep thank you cool let\u0027s take let\u0027s take the rest of that one to list because I want to blow up the Charter in a second Kyle Rose so so I think you answered the first question I was I had which was you\u0027re not putting configuration protocol configuration into two buckets one which is generic and one which is specific so you can you know you could you could potentially have something where you say you know whether you\u0027re using quick or TCP I want to use a particular so that all goes up here and the things that basically it\u0027s like should you choose to select this protocol stack instance then then give this protocol stack instance a pointer to this information this is very low level and should remain obviously so this is higher level okay so two other quick points one is around predictability so there\u0027s you know when you\u0027re when you\u0027re running a worldwide service that has specific you know reliability and performance targets right if you\u0027re if there\u0027s too much "
  },
  {
    "startTime": "00:52:21",
    "text": "magic and you can\u0027t predict exactly what the system is going to do you might run into problems that are hard to diagnose so the more magic you put in that\u0027s a really good point can we take that offline because that\u0027s gonna be like half an hour okay yeah and the last point I had was sometimes you don\u0027t you want to override the magic in a non obvious way yeah so you know during the during the hackathon we were trying to do we were trying to do an experiment on aqm to decide you know like you decide whether ECM was providing benefit or not and we could not create buffer bloat right we were tried and and eventually we succeeded but it took a long time the intention is if you know enough about which protocols talk instances you\u0027re gonna select you can basically like and those protocol stack instances are implemented in such a way that they give you that nob then you should be able to get to it okay yeah so it\u0027s up to the protocol stack instance implementation as to whether you wants to let you bloat it um so I think all of this still is correct we\u0027re basically working on details now there are some of the things that are details are things that are implicit in the minds of the authors that should be explicit in the draft we\u0027re gonna write down some of those the two things that we have on our lists to do beyond just you know general document improvements are we need a simple protocol independent carrier state machine so this is basically the state machine that met that defines what happens to the carrier when it\u0027s not bound to a protocol stack instance because once it bounced once it\u0027s bound to a protocol second since that protocol stack instances state machine determines what goes on but you might have a carrier that has lost all of its protocol stack instances but and is trying to reconnect or is in a particular state where it\u0027s still racing Tommy you\u0027ll talk more about that the second one is exactly right how do we represent certain transverses to their interactions in a generic right way we don\u0027t want to be in a situation where we have to transport protocols that have are never retransmitted semantics so this is a thing that\u0027s outside the min set right is I have a partially reliable protocol and I want to tell it how to be non partially reliable or how that personal reliability works and so seq PPR has this never retransmitted semantics how do we represent these sort of specific tweaks in a generic way and and that actually seems like we\u0027re gonna have to do some work that looks a lot like the work that was done in min set and it\u0027s like above min set rate so it\u0027s that the things that are outside the minimal set but still at that level of abstraction and whether or not that\u0027s something that happens in the abstract API or something that we say okay well this is something that we put off to a concrete configuration so we have some open issues the drafts on github the issues are here if you read it and have a specific one we we take pull requests if you have a specific comment please bring it up on the list but and we can "
  },
  {
    "startTime": "00:55:21",
    "text": "put in the issues but feel free to file issues against it as well the question that we\u0027re gonna actually probably talk about later is is it time to bring this work into the taps working group here\u0027s our view there\u0027s a whole bunch of abstract bi not application no date these are not api\u0027s but they\u0027re api\u0027s right we have a whole lot of these here\u0027s how we think all of this fits together we have the requirements basically come from Mensa that\u0027s that that\u0027s the set of things that we that we can use to implement these abstract api\u0027s but we think obviously and I think that should be obvious in the design of post sockets we think it\u0027s time to take a creative leap beyond that in order to be able to do you know to have a transport layer API that gives us you know the advantage of the 30 years of experience that we have in this space we don\u0027t want to correlate the existing options in the least bad way we want to go beyond that we think that that creative leap is some combination of these right obviously we think that post sockets where we think the strengths of post sockets are or the interface that it provides up other proposals have strengths in in how that should be implemented and how that works down and we think that that combination should happen within the working group however that happens so I think what you\u0027re phrasing is pretty clearly not captured in the Charter so I think you\u0027re proposing a charter change I might be but because because the Charter item number three is about experimental support mechanisms you\u0027re not describing mechanisms right you\u0027re talking about you\u0027re talking about an architecture we have a we have time to talk about this okay later rates so we should think about that I could be convinced either way but you know I first push that doesn\u0027t seem like a mecha yep time can you go can you make a quick comment natural so Lincoln on that exact topic on request come from and said it seems that sometimes we\u0027re kind of trying to say we in the past have done the right thing and we\u0027re prescribing what things should be done because we have min set but at some point our users whatever is above us are the ones that are saying hey can you provide this to us yeah whether that is that\u0027s what I\u0027m trying to capture with this creative leap Yeah right or some other way there\u0027s something else that is max said else now I\u0027m not saying and approving that everything that every user requests is the right thing to do but we should consider whatever our higher-layer is one thing us to do in what we deliver AB now I\u0027m not saying that this means that we still need min said kind of to describe what the general said so far that we have observed so let me let me rephrase that slide then so requirements come from the layer above the degrees of freedom we have to implement those requirements complement set we have decided to limit ourselves in whatever shape or form whether we should and even if we decide to limit ourselves to just "
  },
  {
    "startTime": "00:58:21",
    "text": "a state that somewhere no no no this was a quick comment if we doesn\u0027t think about yeah worth coming the more I think about it the more I question the the possibility to abstract away from the transport layer because we can\u0027t even do it in the ITF whenever we have a new application we have endless discussion whether to use UDP TCP SCDP quick or something else and now we are trying to pass this task to an application interface and I don\u0027t think that\u0027s viable it\u0027s didn\u0027t work for the original sockets API I don\u0027t see it working in any of the approaches we see here I respectfully disagree thank you for coming yeah yes my Keveza thinking about why this why this isn\u0027t in the current Charter the reason the reason the Charter is why the way it is and it became so you know conservative is that we we had these ups and downs of people saying you want to be top down you want to support applications and I\u0027m actually not not not being able to agree on anything on that basis and what the Charter now offers is something that you can implement now I would agree that this is I would agree that it\u0027s better to have a higher layer so I mean I this is what I like about about postdoc curse that it tries to have a higher layer of it and represent things in slightly different ways however I am very concerned about implemented bility of the things there I mean some things can be implemented but if I I mean I just when I read the document it gave me many many hiccups in the sense of oh how is this not how it is going to implement I mean you know I said you would need a system on the other side that\u0027s because there were many sentences in there that is that you couldn\u0027t actually implement this unless you have a system on the other side so there are many many sentences in there that need fixing many statements that things just wouldn\u0027t really match and couldn\u0027t really be implemented I think if if if the means that is defining what the protocols now offer and that would hope that this matches both future protocols off for pretty much mostly I will be you know give me any service that Creek offers that an application is to choose except for certain security things where that isn\u0027t the main set any I got it\u0027s it\u0027s not there\u0027s not easy to find much that really you would have to have in the API as input but as input to this document I mean what I what I want that document to do is to be able to map down to men set which is something you can implement so you can actually see how this is implementable and yeah I mean the discussion goes in this direction but the document doesn\u0027t currently match that so it\u0027s just if destroying and we can come back to this at the end if we have any time left we\u0027re so "
  },
  {
    "startTime": "01:01:35",
    "text": "hi this is the second revision or the run version of the socket intense draft before we start I will give a quick over what a socket intense isn\u0027t what the basic idea is by the way who has read the draft or some earlier version of it okay quite a few so this revision of the draft was basically for reshaping it that it better fits within the overall ecosystem and really fit makes clear what piece it is where to fit it and what it\u0027s supposed to do and it\u0027s essentially an input for automatic transport option selection or automatic transport selection so it\u0027s an input for that magic configuration box Rhimes stated for post sockets and a way to express stuff in there it provides inputs of the application it\u0027s a whether an application wants to optimize for bandwidth latency or cost whether how the traffic characteristics are how it tolerates packet data or collect connection while so beyond that I want reliability the power of whether my carrier or my connection breaks down is this a real problem for the application or has the application semantics on its own to say oh just it was an HTTP download I\u0027ll do a partial get up after the next context I don\u0027t care about my connection being lost so you can choose a trend a path that might break down I don\u0027t care just do it and also stuff like host preferences so saying oh please don\u0027t take a pass that is really expensive and so this kind of input should help a system like post circuits or the policy that is somewhere sitting behind it to do a sensible Church of paths to do sensible choose of transport protocol it\u0027s sensible shoes of endpoints that\u0027s the basic idea of socket intents being that kind of input so for one of the 101 it\u0027s really a pieces of information to tell the application what they know about their own communication what they really know and it should be intuitive in a way that it\u0027s not in the terms of the transport protocol not in the terms of what I want to set as a flag on the transport protocol but in the terms of the application developer I\u0027m going to transfer about a gigabyte over the socket or I want to receive about a "
  },
  {
    "startTime": "01:04:36",
    "text": "gigabyte of the socket it should be somehow generic that it\u0027s not bound to any transfer protocol or not bound to any application semantics that\u0027s really in a way that could be done by many transport protocols by many applications can can be reused by many applications and it should be completely protocol independent and the last this is highlighted this this time because it\u0027s exactly what Brian told about the post circuits it\u0027s best effort so if you specify a whole bunch of interns and saying well my application wants to have a carrier that is as reliable as possible and I don\u0027t like connection breakdowns if there\u0027s only a pass that might break down you still get a pass that might break it down if there\u0027s a path that might less likely break down you might get the past that\u0027s met less likely to break down so this policy behind that should try to match these intents to match these choices by the application but it just had this only has another transfer that doesn\u0027t match the choices oh well you get the best that\u0027s available and the basic idea about this is it should be standardized but it\u0027s an extendable set of hints that could be used for the transfer selection so instead of having for each platform for each API for each implementation some other kind of bunch of keywords to tell the transfer option selection or tell this policy thingy what the application is going to do you want to have one standardized set and if you move over from programming in go to programming in rust or programming in C it should be the same set of keywords it\u0027s expressed in a different way for a different language but it should be exactly the same set of keywords you already know you can look up at since some central place so how does this integrate we did an implementation as socket options on BSD sockets which turned to be out a nice thing to see that this actually works this concept of socket and turns but it also turned to be out not so nice in how useful it is because you can only do it on a connection level so you can\u0027t say well I don\u0027t care about the delivery of this message or I can\u0027t say I wants to do something like HTTP connection caching and therefore I have to TCP connections one over LTE one over Wi-Fi and specify that this message should be low latency "
  },
  {
    "startTime": "01:07:38",
    "text": "this message should through P high bandwidth and then it gets measured ly matched to the right easy P connection something like this you can\u0027t do with BSD circuits but you should do with another transverse so therefore socket and hence works with PC circuits the terms were Lukas pieces but it\u0027s not as useful as it would be as with something like post softens in post so that you could just use this as address configuration which was in the last process I\u0027m not sure whether it\u0027s still the name the in the current draft but we can take this later or you could specify the width needs us as a neat property so it\u0027s the concept with them this is the but you can take it in any city should take them in any system that they like already told this is could write messages screams screams is what they the posted people just called carriers associations but they just called associations and Association said which is something about this which bundles bunch of associations so how are they represented so it\u0027s pretty simple yeah just key value pairs you have a pee just kilo case s key string Sam sings symbol something to remind which I guess should be best captain Diana registry sometimes somehow but I think that\u0027s an interesting discussion item and have a wall value and the value should be have some fixed type so then enum if it\u0027s kind of category integer float string or sequence of one of the above if this is needed I have don\u0027t have a use case for the sequence yet but it might be useful the initial types we forever a traffic category which isn\u0027t you know and it\u0027s applicable to streams associations and Association says size to be sent and received which also makes sense on messages the duration of the stream or some other transport the bitrate sent and received which also makes no sense on a message how bursty traffic will be which might be interesting if you either to decide whether to schedule something over Wi-Fi or LTE if you want to save energy how timely the delivery should be so whether you rather want um so something like this be Nagle disabled or whether you want a low latency carrier were they how disruption resilient if the application is so whether you care about flaky Wi-Fi or rather want to be "
  },
  {
    "startTime": "01:10:39",
    "text": "scheduled on more expensive LTE connection but that has a high likelihood of not breaking down all the cost preference so whether you care about whether you sync your traffic is so important that it should be carried over something like data roaming or whether you say oh it\u0027s an operating system update we can do this at the moment when we have a cheap path available so in this case even telling the socket API if you don\u0027t have a cheap ass available just deny this request just fail the creation of the connection it\u0027s fine for me so with this I come to the questions after the basic concept so it\u0027s this interface of this idea easy enough that it could be useful for an application developer and could be useful as an input to a transport system it\u0027s the structure sufficient and in can it express all fountain in the functional and non requirement performance preference because you should can\u0027t use this to communicate I\u0027m literal idle channel because it you need a reliable channel if you need a reliable channel and then the transport system can\u0027t if you UDP and what intents what kinds of information are missing to make this useful of the first page of the questions my Michaelis there was at least one thing on the previous slide that would never arise from just analyzing the transfer protocols and that\u0027s actually actually something that was a bit of a concern to me when we started with this analysis that you might miss out on some things that seem important like burstiness I think could be important for making a choice on the path that you want to use on some choices the depsite type system is going to make but it wouldn\u0027t be wouldn\u0027t arise from looking at what the current transports offer all right so I\u0027m wondering if I mean I\u0027m wondering what you specifically do with burstiness and I\u0027m wondering if there are more of these things that we should have covered somewhere as features that actually don\u0027t you know you don\u0027t get from just looking at what the protocols offer but isn\u0027t the request this is describing the applications traffic behavior what kind of a you know my opinion about Transport automatic prints code layer selections or I won\u0027t repeat that I guess this is far too complex in the application that because the application has to guess what the network or what the application interface is doing and I don\u0027t know what "
  },
  {
    "startTime": "01:13:39",
    "text": "is thirstiness we have to explain that to an application developer and this is hard we\u0027ve seen it 20 years ago with 80mm you had to fill out a form like this what\u0027s your bitrate what\u0027s your burst in US and people never got that and I I think what it would be better to expose the attributes of the underlying layer to the application and that the application decide how to do with with that if you tell the application ok this is an LTE link which might be costly the application can decide ok I\u0027m now using a simpler codec or something like that instead of leaving it to some lower layer I also are happy to disagree with this I think then the point the big difference between ATM and this is here the application tells what it knows so it knows whether it will send bursts of data or whether it sends so what we rather smooth scream so if you\u0027re doing something like HTTP streaming it will have its bursts but it will mostly stay at its data rate if you have a protocol like machine-to-machine communications will most likely just have either small bursts I will send a few small messages it\u0027s not about the exact burst rate it\u0027s not exactly about the exact band was here using it\u0027s just about saying well there will be rather big bursts there will be rather small sources take bit rate for example what\u0027s the bitrate of the opus codec if it\u0027s var I have a bit rate I can can give an upper limit but it\u0027s not very useful because it won\u0027t reach the upper limit and pray often so bitrate received I don\u0027t know so if you if you have so again let\u0027s consider service like YouTube you rather know how the bitrate of the video is you\u0027re requesting or you can know this and then you can tell it to through the transport whether you then later on have to decide to switch to lower bitrate that\u0027s fine but then then you can still tell the to the transport OS which too low a bit bitrate I expect a lower bitrate on on the transport weather that this is really awful used for the transport in this situation in the current configuration the application can\u0027t know so but the application has to know what bitrate is possible so it can adapt for example YouTube will choose a different codec or a lower the codec bitrate if it experience some congestion so my point is expose the attributes of the underlying layer to the application and that the application decides enter in principle and my point is if you really "
  },
  {
    "startTime": "01:16:41",
    "text": "want to do if you go that down that road you end up with all applications having to know all transport protocol they might potentially use and to know all the knobs of it but I think still Bose has a valid use case I think if you\u0027re at the point where you have an application that you have exactly tailored to a transport protocol then it\u0027s much better to expose the attributes of the transport through the application if you have an application that doesn\u0027t want to invest too much of the engineering into this part then it would be nice to have a layer to take care about this problem pravin Microsoft one of the things I see missing here is there is no intent expressed for the send or receive pattern I think transport performance could be improved if the socket intent would say for example what the sending pattern is like for example to 4k sends and then I wait for a message from the other side before I send again some pattern like that Express to the transport you could automatically do intelligent like you know disabling of niggling or figure out your delay tax strategy and things like that so I think having an ability to express intent of what\u0027s the pattern would be extremely useful thank you that\u0027s +1 2 that Tommy Polly apples so I mean thank you for presenting this thank you for doing this I think it\u0027s a very difficult area to get right I very much agree that oftentimes we\u0027re going to need to just expose the protocol knobs because that\u0027s really what at the end of the day is there so when we look at this kind of when we\u0027re talking about with post sockets we have the configuration which is like this generic thing and there\u0027s like my protocol specific configurations I think you know the protocol specific configurations are where we historically think of as socket options for that one transport these things are the things that go into the top-level configuration in this great generalized world I think there are some things that are in that category I think you mentioned like I don\u0027t want an expensive path that\u0027s one of the things that we have been able to bring up into that top level configuration because you could say I don\u0027t want cellular I don\u0027t want this particular carriers network and you can because you know that but oftentimes people really just mean I want something general so I would love to see us work on this as a working group and likely it will tear it apart and most of these things like bitrate may need to be stripped out or something but I would like us to have the conversation because this comes up all the time from people who are doing implementations of oh we want an abstract way to do this and I think it\u0027d be great to come down on each of these and some of the other options and say kind of definitively this is something that can be expressed abstractly this is something that can\u0027t and get our story straight and so it may end up being a "
  },
  {
    "startTime": "01:19:41",
    "text": "very difficult discussion and a tricky process but I think we should go through it so I just want to insert myself into the queue here that a question for you Phil have you implemented this so we implemented this on top of BSD sockets but to be honest the only policies we really used was the traffic category and the send and receive size this is the only stuff but we really have experience and we really have evaluations on I think that I think that is an excellent point which is sort of harkening back to the ATM discussions there\u0027s been many decades of categorization of what traffic what applications want from the network and what the network can give to the applications and I think well we have an opportunity to do here is some experimentation and that the whole idea of that taps API to allow you to you know mix and match transports based on map indications is we may actually be able to make some progress here but I think that this table is a little bit of a tractive nuisance in the sense that many people have seen tables like this in the past and they weren\u0027t believable then but I think that the real test is going to be what we can implement in turns out to be useful and I think Tommy\u0027s make making a good point which is you know it\u0027s a let\u0027s view this is a work in progress see what works what doesn\u0027t maybe some rosy table will leave me will add some new ones I think the intent of this table is really started this cash it\u0027s not that I want this table in the final draft it\u0027s just it\u0027s the strong resemblance to the to the ATM traffic classification table I think that is a set people off at least for me yeah I think that and the RSVP stuff : Baggins so yeah that the table makes me nervous and that this table makes me nervous and when you start trying to categories application behaviours there\u0027s a it\u0027s very easy to rathole in a far too detailed way that goes nowhere useful that said if we you know if we\u0027re building these sort of generic API is there would seem to be a scope for passing in something about what the application knows about the data it has to the transport so I think and we need that ability I\u0027m unconvinced about how we do it I think we should think we should at least think through that this this is a feature of the future API right there are some semantics that come from the AVT world that might have something country yeah I that world I think is really good at going overly detailed and producing unusable things "
  },
  {
    "startTime": "01:22:43",
    "text": "like a soulless LinkedIn I\u0027m still grasping my head around a few these things but the the first thing is talking about intents from the peace table that you had some of these things if I read it correctly is what the application or whatever box is above this layer intends to do right so it tends to send so much it tends to so it\u0027s kind of communicating this is what I\u0027m intending to do peace feel please feel free to optimize maybe around that some of the things you had in the box are not things that I intend to do but things that I want the system to give me so I don\u0027t think there should be mixed up so the example would be timeliness you intend to be timely you don\u0027t intend to be hungry you you you want the system to give you some type of timeliness you do intend to be bursty or at least you expect to be bursty and I think in in the draft the wording changes when you once you get to those descriptions so I think we should be careful to separate things that you\u0027re intending and just saying hinting at what you plan to do versus thing that you want the system to behave number two point and maybe more abstract is both for these things and four configurations that you\u0027re giving to a system in this case this one a particular if the system is to make a choice and do something for you is because you\u0027re you\u0027re asking or presenting a trade-off right I\u0027m not gonna tell the system please perform the best possible I\u0027m hoping it will perform as well that\u0027s that\u0027s what I\u0027m intending to do but if I if I tell it that I want things to be and this is bandwidth is because I want you to make the creative for me give me bandwidth versus latency for example so at all points in all situations you\u0027re expecting whatever you\u0027re asking to have a cost so we should be clear when we\u0027re describing what cost you are expecting to potentially pay by requesting something and this should be reflected both in configurations for this or for anything else that we\u0027re doing right obviously otherwise all applications will request give me the best service possible all the time right that does not help us right what helps us is somebody telling you I want bandwidth please sacrifice these other things for me to optimize for bandwidth and to be generic obviously if you\u0027re on a bunch of these things then you could have like weighted averages like 50 percent bandwidth and 30 percent latency and 20 percent reliability whatever right so you can come up with weird systems but but just be clear that we\u0027re asking for trade-offs and that should be reflected in the commentation and then the API is the we design that\u0027s a great point me and I can\u0027t agree more to not just that\u0027s absolutely right and also I\u0027m wondering how much of these things we actually have to specify somewhere because um it really depends on what protocol your interface supports like if the only protocol you support is UDP then much of this is not useful if you invent a completely new protocol you need something completely different so I\u0027m not sure what what makes sense to specify here I must say this lot of this attributes comes rather from the path selection ideas than from the question of protocol selection so I think most attributes only makes "
  },
  {
    "startTime": "01:25:45",
    "text": "sense if you want to decide which takeoff to trade for a pass not which trade of to take for protocol also your implementation of pass selection can be a limited right if you have exactly one interface there is not much selection to do yes then come to path aware networking there\u0027s the afternoon hi Brian Trammell can you go back to the ATM table again so everything nacho said plus so I think there\u0027s this this um are you gonna take that what are you doing okay um yeah okay so so this this year there\u0027s there\u0027s there\u0027s two issues with this so I like the the farther to the right you get the happier I am the further to the left you get the less happy I am some yeah and then like from the out in is kind of like this this sort of the heat map of how I like this table right so I think there\u0027s a so there\u0027s a prop okay so you start trying to solve the problem of how do we take intents and express them in a way that you can do path and transport selection which is mixing two things together that maybe shouldn\u0027t be mixed together and like expressing it this way makes it clear to me so I hadn\u0027t really I\u0027ve also am I thinking I\u0027ve been thinking as a path and a transports stack as potentially partially equivalent and this really underscores to me that that\u0027s wrong and we need to go and look at those sockets and make sure that that they were good there the second thing is there seems to be this we have the the started from a concept we\u0027d like to be able to take some intent-based thing and use it to poke it at the transports back and have it do something nice for us and this looks like it drilled all the way down to the bottom of that problem and kept throwing a bit and it\u0027s and when it you know when it before it hits the ground it\u0027s it\u0027s doing really great stuff and then it hits the ground and then so finding the ground there I think is a really important thing to do and say okay here\u0027s we go this far then we stop and I don\u0027t know where that is but I think that this work is most useful when it\u0027s higher layer and gets more problematic the more lower layer it gets because this also goes to sort of the discussion we were having a post sockets about granularities of of configuration and I think there are two extremely distinct viewpoints that are represented in this room who I will call application chauvinists and transport chauvinists the application chauvinists are people who just want the transport to do something I just want to write something fine and for the most part they don\u0027t pay attention to us anymore they just use zmq and like wave their hands while they when people ask them security questions and the the the shape of the API is that we produced or from a "
  },
  {
    "startTime": "01:28:47",
    "text": "very transport chauvinistic area it\u0027s like we\u0027re not gonna trust you to do pacing because you\u0027ll nuke the internet right it\u0027s like there\u0027s still people who are very scared about user space transport stacks because they believe that this route user space a route non-root user a distinction is useful for security which it just isn\u0027t um and I think that I think that this here this really has shown that we need to kind of try and find the balance there right because this is a very this is a very application chauvinist way to do it but does it in a way that like selects an application chauvinist by the way so I\u0027m with you on that I think that we should give application developers the things that they want not that things are we think we can give them and yeah actually you know what I\u0027m gonna take the rest of this offline because we should get moving all right cool thanks let me just paraphrase what a piece of what I think you said which is I think that implementation experimentation of this stuff is going to be critical because we don\u0027t really know what\u0027s gonna work and what\u0027s going to be useful there\u0027s canasa when you\u0027ve drill too far so let me come back to the point of experimentation so we did experimentation really with this option with this send and receive size and we found out that it really helps for examples to decide whether you to do HTTP pipelining on a specific path or whether you want to do multi participate for this kind of decision it really helps it only affects about five percent of the use cases we really had where it made a different in 50% of the cases it was just doesn\u0027t matter and 50% so therefore I think this bubbles past week I can sit and say it is useful for these cases for the other ones I just cannot tell David Skinner\u0027s e Apple so I\u0027m gonna introduce the third type of shavon s which is an engineering chauvinist which I am and it kind of reflects what you two were saying I think there\u0027s value in creating a framework for socket intents saying like this is what a socket intent is maybe have a registry an eye Anna or here\u0027s where you put your new socket intents when you come up with them I think there\u0027s value there traffic categories those have been implemented by Oasis for decades those have been proven to have value in some cases and apparently you\u0027re saying this has to be sent and received as well and in that case I think it\u0027s great you can document here\u0027s how you specify those and here\u0027s an example how they can be used here\u0027s how we\u0027re using them you get these benefits the other ones I would really recommend against specifying these things because you\u0027re like oh here\u0027s how you specify burstiness and everyone has a way to specify burstiness no one specifies it and no implementation does anything with it so I don\u0027t think I think it\u0027s premature to have a laundry list of all "
  },
  {
    "startTime": "01:31:47",
    "text": "the things we could possibly want when we don\u0027t know what to do with them I really like praveen\u0027s example that I think you can act on really messing with a delay DAC and I call you play with Nagle that\u0027s actionable that\u0027s something I can write code for how bursty you are as someone in the DC B\u0027s like what am I supposed to do with this so I would push against to try to standardize things so we have no idea what we would use them for Gouri the line was closed as a quick right yes it can be quick yeah thank you okay so um okay so I look after RSVP stuff I\u0027ll look after diffserv stuff there is stuff in between and it\u0027d be really nice if the transport stack see some of this but do you know it\u0027s really better when we see binary things I want low latency I want low cost I want zero cost I want I am very very bursty but just not get into the details so I like the list I think the list should be bigger but I think the data type value should mostly be binary I think the data type should be enums choose this or this I think the last question I had is better for the for the last chartering and discussion part yeah thank you next is all right I\u0027m Tommy I\u0027m going to be talking about another aspect of kind of the it\u0027s like the guts of a taps implementation hopefully none of this ever gets exposed to anyone but it\u0027s very relevant for how we actually make a system that can try multiple options actually happen whenever we\u0027re talking about trying multiple paths whenever we\u0027re talking about trying multiple protocols Colin that\u0027s very quick that\u0027s very quick it\u0027s a sort of scoping question I think and maybe you\u0027ll get to this when you say racing do you mean happy eyeballs or do you mean things like ice as well I\u0027m coming from it from the happy eyeballs side it\u0027s so I\u0027ll explain so let me get to the next site I think I\u0027ll define the scope and people have brought up the you know the term is "
  },
  {
    "startTime": "01:34:48",
    "text": "the term racing the wrong thing so we can have another term for a but I didn\u0027t want to use happy eyeballs because that\u0027s really v4 v6 dependent in people\u0027s minds yes yes it\u0027s just that when you say should be hidden me if happy eyeballs I would agree for ice probably not okay so I did this I did this particular thing as a draft update to the taps type guidelines document I had done last year it included among other things this generic racing guidelines and I kind of distributed all out to just be that part because I think everything else is captured elsewhere in things like post sockets so this is a much more focused document it is trying to generalize happy eyeballs so that\u0027s kind of angle it\u0027s coming in on so happy eyeballs is RFC six five five five that is now we have abyss for that in the RFC editor queue so that will soon be a new RFC number which gives a little bit more advanced algorithm and it has certain aspects that I\u0027ve incorporated into document as well and then also this draft is trying to take a little bit stronger stance on saying that there are things that you really should do when you\u0027re building your options for how you\u0027re doing connection establishment racing and so these are intentionally things I want to discuss and if you think they shouldn\u0027t be assured or a must please let\u0027s have that discussion because I think they can be very important so what is a connection option I think that gets to what Colin was asking I\u0027m referring to that here as a tuple three tuple of your endpoint your path and your protocol stack which may be your protocols your protocol options let\u0027s say I have TCP and TCP using TFO I would consider those two different rota calls right so we can distinguish those just based on options it defines a notation for how we can essentially look at how a connection is established I view it as a tree essentially the point of that is that it has a hierarchy of how we look at deriving these options if you just took all possible options and built them as like one big matrix like a three-dimensional matrix of multiplying all of these things not all of those make sense if I do a DNS resolution on Wi-Fi I probably shouldn\u0027t just arbitrarily assume that that endpoint that I resolved works on another interface piece maybe it\u0027s a local resource so this is an attempt to cull down that space of options so what are the ways that we have options so we have paths branching in just like the path we can protocol stack branch oh we can do endpoint which I\u0027ve been calling derived endpoint branching because there\u0027s always the endpoint that you have at the beginning that the application wants to get to we\u0027d better have that but there "
  },
  {
    "startTime": "01:37:50",
    "text": "may be stages such as Bonjour service resolution service discovery or just normal hostname to address resolution that can be happening to generate new sub lists of endpoints yes is a VPN full splitter full VPN is that a path yeah um that would be that would be a path so another term for path for people who are in PVD discussions is a PVD so uh up half is not just an full interface it\u0027s essentially just a self coherent set of routes so a split tunnel VPN definitely falls into that yes the derived endpoint I choose may drop me into a different path but these are more about which like when I\u0027m making an explicit choice at the beginning what do I want to say I want to force this attempt over a certain interface or do I not care so the document kind of is saying like there\u0027s a should between the ordering of these that certain things like a resolved endpoint coming from one path probably shouldn\u0027t be used on a completely different path so that I think is a pretty strict one similarly if I have an endpoint that I have derived us very specific to a given protocol let\u0027s say I have one protocol stack is using a proxy and it has you know a new in point because of that that endpoint probably doesn\u0027t make sense if I\u0027m not using that proxy or not using this protocol that requires a different port so I think those are very clear we\u0027ve been having discussions with some of the neat folks um I think the distinction between dua branch for path or dry branch for protocol stacks first is a little bit more flexible I think it becomes simpler if you choose generally which big path I\u0027m going over first but that is maybe more of just a recommendation rather than a must it\u0027s coming hi : Perkins is v4 v6 a path or a derived so when I at least when I think of paths as pvd\u0027s and in that regard you can have your v6 and v4 kind of bundled as this is like here in set of things you\u0027re doing yes they certainly have different properties I think I would agree with you that when we look once we\u0027ve actually connected and we\u0027re using our path properties the path is definitely different between v4 and v6 but when we\u0027re talking about the intent of the application to try to different path options saying that I want to try the v6 or v4 option doesn\u0027t really make sense until I\u0027ve actually "
  },
  {
    "startTime": "01:40:50",
    "text": "done my resolution do I even have an address for v4 v6 but saying something like I want a VPN or I want Wi-Fi on cell or Ethernet or something is something I can say up front yeah okay okay yeah I guess that makes us I\u0027m still trying to think how it fits to a sort of natural versal style where your trains find sort of interfaces protocols configurations the work so I\u0027m just trying to figure out how it fits with natural vessel and when you\u0027re racing different options there is that a pathways that it had derived endpoints right so what one thing I\u0027ll move on quickly but one thing I want to point out is that when I\u0027m discussing this this is all about the kind of the initial connection establishment so not necessary time at the net reversal for ice but like for things like MP TCP I mean which you know ultimately we will be using multiple paths this is the algorithm they\u0027re using essentially for the first leg just say can I get any packets out once you can certainly use more paths and more addresses later on and I\u0027m sure that you know doing ice stuff will end up using multiple things this is about just like does this thing even work the ice stuff is about determining that hmm the ice stuff is about determining whether it works right so I think this is an area that we do need to explore more in this yeah yeah I would like a review from yeah I think Pafford derive 10 points or maybe not as clearly separated as you might hope so it also defines three styles of how you can actually do racing between your very options once you\u0027ve built a list at each level these should be relatively non-controversial I think you could do things simultaneously and the draft essentially explains why you should probably never do that you could do something based on a staggered delay or you could do something as failover I really prefer this option I only want to try the next option if my primary preference has completely failed there\u0027s also the question of what does it mean to be established so traditionally happy eyeballs is something that ends once you have the three-way TCP handshake done and that\u0027s great but depending on your use case you may actually want to see is this really a usable path or usable connection am I going to be able to get my security handshake done am I actually going to be able to receive useful data maybe I\u0027m doing zero RTT work and so I don\u0027t want to just assume that something\u0027s going to work so interesting questions that an implementation has to decide there so that\u0027s kind of a summary of this draft what I want to bring up here now is we have two drafts currently in taps that are very related on this topic there is the neat draft on happy eyeballs and then there\u0027s this draft so what do they have in common how we\u0027re going to reconcile them I think there should "
  },
  {
    "startTime": "01:43:50",
    "text": "probably we should combine them and only have one but I\u0027d like to have that discussion out here in the open so what do they have in common both of them describe how you do happy eyeballs for protocol stacks the needs when I believe kind of just goes into mainly that doesn\u0027t really go quite as much into the path racing but they have the protocol stack racing in common they both recommend a kind of historical database of what you\u0027ve previously probed or what you\u0027ve previously passively learned about your various inputs and paths and that should influence the ordering and timing that you use so that\u0027s very important one and then also it\u0027s an important observation that both of them have that the combination of what options you\u0027re allowed to use come from your application preferences plus your system policy plus your historical data and so there are three different sources of this okay so what\u0027s different I\u0027ll go to the bottom one first so there\u0027s the question of should we have this structured tree or do we really just generate one big list and then it\u0027s kind of free-for-all you let the implementation decide what to do I\u0027m fine making this kind of more of a recommendation I think if you structure things as a tree it makes certain algorithm decisions a little bit easier um the happy eyeballs timer racing between v4 and v6 address on Wi-Fi really has nothing to do with be happy eyeballs racing on a different path on a different interface that\u0027s happening simultaneously if you as an implementation want to kind of manage those all together you can but there be dragons down that road Brian did you have something on that one or no okay okay so I think the bigger one I want to get into is there\u0027s kind of a fundamental difference in the drafts of are we what\u0027s our space of things to race so are we racing things that the application didn\u0027t ask for or not and I think that really makes a difference in your decisions so in the draft of what I would like to propose is essentially that we are only going to be racing between things that the application has kind of whitelisted in as my server probably supports this as opposed to just trying to do probes because the system likes this protocol or this other one we think that this one might work for example like if I just want to try SCTP because I want to make it work on the Internet you would likely want to try it but then have a very quick failover because it\u0027s probably not there that seems to be a little bit harmful for the algorithm and for the Internet and I would prefer to see it\u0027s something that is more opt-in by the application so I\u0027ll just rush through these slides so I think it gets to the overall question of when we\u0027re racing what are we actually connecting to and these connection options they all come from either the application or they come from the network right so when "
  },
  {
    "startTime": "01:46:50",
    "text": "we\u0027re doing happy eyeballs the options were racing between our things that DNS told us we know that these are real options when we\u0027re doing racing potentially between your quick and hb2 this is something that applications do all the time this is a LPN TLS is explicitly indicated someone out there knows that the service works this or the application I just say yeah I know I built that server for my application it supports these protocols on these ports so we can have you know vague preferences strict preferences how are those actually determining what we\u0027re doing I think the vague ones are useful for tuning things but we kind of we should I don\u0027t think we should be using vague preferences to infer protocols that we don\u0027t have any explicit knowledge of them existing and so this is a bold assertion I\u0027m we can talk over the email list but I think it\u0027s an important thing to really clarify it as we\u0027re going forward on these algorithms right so one of the main points that we\u0027re trying to do here in taps is say let\u0027s make our transport library flexible we don\u0027t want to ossify on just everyone\u0027s just doing TCP I think that\u0027s great but why is this really happening so one thing that I think that we think of a lot is that okay we have applications that are writing code that only worked for TCP it only works over sockets this is definitely true when we see the ipv6 transition problems because people wrote their code for v4 addresses only and that\u0027s a bad practice is that true for why it\u0027s hard to deploy new transport protocols or get applications to adopt their code into new transport protocols maybe but certain things like I I see a lot of socket code out there that it really just deals with things in generic way they just have a sock stream using a stream just a stream couldn\u0027t I run that over any stream protocol and so I would like to point out here is that sometimes actually the fact that our libraries are implementations like sockets give us these generic vague options for protocol selection but then we end up only doing one thing beneath it in that current implementation actually led to the ossification the fact that we say sock stream is a stream you can just write your stream on this but then in practice that always meant TCP that means that applications have been deployed that they will get worse behavior if we start doing things under them that our stream that they never opted into and so if we could end up deploying a cap system right that says oh great taps works with quick SCTP and tcp woohoo and then the applications get used to that set as being the things that are there and the moment you try to add number four they have to now wait for that racing or they\u0027re delayed or it just doesn\u0027t work so we don\u0027t want to get into that situation again so the we can read this online I don\u0027t want to take up too much time here but essentially saying that our API should work under with any protocol and we all shouldn\u0027t have to change any of the application "
  },
  {
    "startTime": "01:49:50",
    "text": "code however we shouldn\u0027t just be inferring things I think is sufficient for a lot of these taps work to say all you can do is change the Flippa configuration but to turn on green light this protocol say I support this and that\u0027s a great goal but we shouldn\u0027t be doing things that the applications don\u0027t expect in this racing I think that ends up being harmful that might be great so I\u0027ll I\u0027ll point out that on this light these right now seem to be slightly mutually exclusive in that you say okay well we\u0027re not going to and I think that\u0027s bad and I don\u0027t think it\u0027s a problem with that I think I don\u0027t think it\u0027s a problem with the expression of the thing I think it\u0027s a fundamental problem that we need to find a way to solve it is you\u0027re saying okay we\u0027re not going to have the library do unexpected things to you by being right by sort of essentially greasing the protocol space if you\u0027re familiar with the concept of greasing but then if you have applications that are used to having to trick the API you can\u0027t fix that without tricking the application I don\u0027t know how to fix that that\u0027s just a that might be a fundamental problem that we have to throw some brain at right and what I want to say is that it\u0027s actually not that big of a problem to change the application telling the aberration to rewrite their entire library yeah op using sockets is terrible telling them to change a bit like yes these apps yes they deploy new versions all the time turning on a boolean whenever they turn on the new protocol on their server end is not that big of a deal okay okay so basically the one of the the application deployment and development cycle that dominated the sockets era is not the same as the current application development employment cycle and we should pay attention to that okay that\u0027s an it that\u0027s a that\u0027s an interesting insight I\u0027m less unhappy now it\u0027s not the thing I came up here to to say the thing that got me in the mic line was as you were talking about what should you raise much you\u0027re not racing should you tree it or sequence it I think that the the distinction that you\u0027re making here or something we should pull into PO sockets it\u0027s things that the application cares about then we know and not at the library thinks um but one of the advantages of having a tree oriented as opposed to a sequence oriented thing is that you can use the same mechanism to do both current things that we know we want to do as well as to have the library potentially I\u0027m gonna race this psi and I\u0027m never gonna use it because I want to know we actually do that like when we\u0027re trying to probe 40s 1.3 great ability we light it up another tree great and then you store that information in the Association for the future okay cool okay I\u0027m gonna lock the line and resonator hi Colin Perkins so I think this has to be a tree because you can always collapse it to a tree with just one set of branches which gives you a sequence and and there are tell you things where you need that that flexibility in terms of racing things that you don\u0027t expect "
  },
  {
    "startTime": "01:52:52",
    "text": "the the the issue which came out with a lot of the ice work was that you got so many candidates that you ended up congesting the link and people people are actually trying to cut down on the number of things they\u0027re racing so adding adding more into this mix I think is likely to be a problem so yeah I agree on that on this ossification point a lot of the problem is we tried to be general but it wasn\u0027t actually general there\u0027s only one thing there you know if we from the start have multiple options I think we avoid if you say stream and it could give you more than one thing I think you avoid some of that problem the other thing is give an explicit way of getting a protocol right don\u0027t say stream and assume you get you get TCP say you have have an option say I want a TCP connection exactly say that I want to interact with it as a stream but the things that I allowed to use are TCP in yeah yeah I I want to stream but it has to be a TCP stream welcome back most of our application layer RSC\u0027s explicitly state protocol to be used exactly sometimes we have option to use different protocols but most of the time we have use UDP for radios or use TCP for something else use that under server support yes we we have very few I don\u0027t know of any application RFC which simply states use a protocol which with partial write reliability and quick interactivity or something yes you state the protocol because we have discussed the pros and cons of the difficult of the different protocols another thing about the previous slides you\u0027re only talked about connection oriented sessions but sometimes we have things like switching from UDP to TCP for example you want to do voice over UDP of course but sometimes firewalls only allow TCP and yes in the super odd we have standardized this ice stuff which is very complex and takes a lot of time which is bad for a session setup time and and this is something you can\u0027t handle in some general library you have to use it to it in the application so not necessarily um so I have experienced with doing things like for example like ike VPN negotiations run over UDP we can fall over to TCP where we need to because there\u0027s an tolerance for that I think the solution there that gets back to the point of how are we determining what establishment means if you actually include some level of application protocol into that like the application determines that I got useful work back and this is going to work for me then that determines it so I can use a UV protocol and if I determine after some time it\u0027s not the same algorithm for how you fall over "
  },
  {
    "startTime": "01:55:53",
    "text": "to another path still applies and we do employ this for UDP you have to get some reply and sip you have to stun message to show that you deeper layer level becoming established didn\u0027t you just you cut the line after I\u0027m not after you just very quickly following upon the the ice points and you you may have to hook this racing into the application state absolutely yeah so Soviet so you\u0027re hooking into applications things like not all within the stack spencer Dawkins interested individual first observation I would have this not only do we have reordering problems with transport protocols we even had them with a mic line and transport working groups apparently awesome good job the thing I was gonna the thing I was going to ask about and I don\u0027t need an answer like in the next 18 months so I\u0027m just yeah I\u0027m just telling you anytime between now and and work ITF last call is fine but I was also interested in your response to Brian about kind of what application development looks like these days compared to the socket Sarah and I believe you and I\u0027m curious as an area director about what the tail looks like for that and like I say the don\u0027t don\u0027t answer that now because the answer will change by the time you know I mean you\u0027ll be further down the tail but I would just like I would like for that to be cost somebody\u0027s mind before IETF last call when all the people that don\u0027t do it that way tell you tell us that they don\u0027t do it that way you say does it make sense you said there\u0027s a fantastic point my initial gut reaction would be that detail of people who aren\u0027t pushing new updates their code are probably not going to be adopting anything after socket anyway at this point and and like I say that\u0027s a fine that\u0027s a fine that\u0027s a fine answer if it works no no I think I\u0027ll take that question offline but just for your environment I mean you take 23 minutes say 8 percent accuracy "
  },
  {
    "startTime": "01:59:03",
    "text": "okay okay we will use this computer so Cory if we\u0027re gonna if we\u0027re gonna have any discussion about the document approach in the working group we\u0027re gonna need to end this pretty sharply I\u0027m 20 minutes questions just setting expectations yeah I was gonna be quick with my laptop but I actually click anyway so this draft is short and easy to read and people have accused me of writing too much this time I wrote too little to figure out what else that we need to write next so let me tell you what it\u0027s about and expect the NEET protocol stack so it\u0027s about something that implements some of the things in taps with real running code so this is a result that is generated code where we can signal things down to the stack and the stack can make decisions on behalf of the application in the ways we\u0027ve talked about it supports a single API to transport it\u0027s got explicit support for multi streaming a multipath security it\u0027s got a policy based selection engine in the middle which does the happy eyeballs candidate selection and that may be the bit that\u0027s most interesting currently I don\u0027t say much in the draft so if you want to see more about that ask questions or we all write more if people want it this is the sort of thing that NEET does when you start an application and you set up the neat system by initializing it and then you pass a JSON string expressing what you might want so here\u0027s a very general requirement you might have from the application you want a reliable transport things can be either required or they can be desired so we have both levels of functionality if you want if it\u0027s required it has to be provided or your connection fails if it\u0027s desired then it\u0027s something that goes into the ultimately into the candidate selection whatever the properties you request from the application nique proposes a set of candidates in this case there could be different transports neke performs happy eyeballs and we we have a draft already on happy eyeballs and how that works and then finally a neat endpoint is used for communication and then we enter in the medicines mod where you can adjust things but they are only the connection that\u0027s already been established so this is a diagram which kind of shows a little bit more how it works internally which is probably the most useful part of our draft because that this particular draft brings together the functional parts the app indicates properties the you call a set properties call give it JSON you could indicate things that require like transport and "
  },
  {
    "startTime": "02:02:04",
    "text": "tight you can indicate properties like the dscp value or the abstract dscp or something even more abstract like you just want high throughput or whatever then you do an open call and finally you can get back from the system what properties were actually set because you need to be accountable I think when we define this so that attach they can find out what happened when you did all the magic underneath to make up the connection that you finally chose so underneath we have the neat user API which is the main topic of the draft then we have the neat logic which is by far the biggest chunk of code this is the piece of code that actually does things and from the neat logical is a policy interface to a policy manager which is the piece of machinery in need that takes the properties input it combines them with a policy information base which configuration information this links properties with rules about how to use them and it link them with profiles defining what it actually means when you ask for something so it expands the property list we also have the characteristics information base which is learned material you\u0027ll see synergy with the things we\u0027ve heard earlier in the taps meeting this is things discovered from the network and it could be path history information it could be Proust called history it could also be explicit signaling I\u0027m a great fan of PVD so if you want to imagine PVD in here we have a way of injecting pvd\u0027s into the system so that network interfaces then become pvd\u0027s and you can learn about the characters pvd\u0027s whatever you have a shared a lot of information what\u0027s configured what was asked for either concretely or abstractly and the information you\u0027ve got about paths out of this comes something so properties come down up comes candidates and as Collins already pointed out whenever you do this you end up with an infinite number of candidates so one of the things that the policy manager has to do is protest a suitable list of candidates which come up to the neat system and then it has to decide how to use these and that\u0027s a racing decision and it\u0027s easier when you\u0027ve got a connection-oriented transport and you have a Kinect it\u0027s rather fiddly when you\u0027ve got UDP or dare to ground-based transport because you don\u0027t actually have a Kinect so you\u0027ve got to define some notion about choosing which one and sometimes that means you have to use this failover mode of racing because really you just don\u0027t have a connection set up but sometimes you have a protocol on top of UDP so this is a little bit more tricky yeah you can do it and then you do the full ice thing if you really wanted to we don\u0027t know who this policy interface who is using this policy like who is setting setting deserve the the policy interface is between the two parts of neat the policy manager and the neat "
  },
  {
    "startTime": "02:05:05",
    "text": "logic so this is an internal interface but it but we thought it was a real interface that existed will you suggest properties and you get back candidates the external interface is the policy input infobase which is the horizontal line and this this in our system is currently JSON files that\u0027s just the link goes missing O\u0027s not sure I think yeah and the pipe the coccidia for information base also appears as JSON so um I was taught to be quick so I\u0027ll carry on being quick happy eyeball simply selects and when you\u0027ve got these candidates it chooses one of these possibilities and one of them wins that was simple it was easy and lots of difficulty in actually realizing this so what happens when you ask for something that\u0027s a little bit more abstract and maybe low latency and low latency is one of these services you might want because you\u0027re doing a background file download and it\u0027s a concrete application requirement my preference is kind of for things that come be expressed by applications and make the tap system do something and then the application knows that that thing is going to be done so when you ask for low latency you\u0027re asking for taps to put in the neat system a set of properties to implement low latency then the application has to decide if they want low latency and Dave if they do they request that property and becomes a profile of things that they get I prefer that to try to say I want to legislate less than X or I\u0027m trying to send this much because these things I find very hard to actually match with things and I\u0027ve played with RSVP for many years and I know there are many many parameters here simple word goes down the stack this is actually a profile the profile has to be expanded by the system according to the policy information base we get candidates back now we have probably two things to race we have some notion of interfaces preferably PVD and we have the notion of which transport we should use so in this case we have decisions made at two levels we could argue which level we do first or whether we do them in combination this is all good fun and I suspect in reality we\u0027ll end up with different versions for slightly different views this may be different versions for whether we\u0027re doing dare to ground versus connection-oriented maybe if we have slightly more PVD information we get heavily into path selection but ultimately we have to choose a path to work where the after views of Transport to work with and we end up with this um so if you were clever you\u0027d realize I didn\u0027t talk about anything which I will put in the session there I believe the session layer exists I know it\u0027s the ITF but there are functions a book transport on below apps and yeah yeah they really are yeah and the post sockets api talks about this I mean neat we don\u0027t talk somewhat much "
  },
  {
    "startTime": "02:08:06",
    "text": "about keeping such and connections alive over time we don\u0027t talk about the mobility and moving of connections between one bear another or carrier in the sloppiest case this need to concentrate it particularly on the things that we could actually implement now and we have a concrete way of doing it I have slight concerns about making things overly complicated when we do this adjustment because I really want people to buy into the taps API and if we start bundling too much I have fears and good news is we\u0027ve bundled this much so far in our project and we\u0027re happy with this so and we can figure out how much is good the slightest callback based I think that to me is an essential part of the whole thing this is probably a more fundamental change than any of the other changes and it\u0027s a change it\u0027s already happened in the app development world so whatever we do with the taps API it has to be callback based that means when you make a read call you\u0027re told first of all to go read you read when you make a write call you write and it tells you it\u0027s written you can argue about whether it has to tell you every time it\u0027s written or whether it\u0027s tells you but all of it but you get a callback you also get a callback when it goes wrong some sort of time outdoors pay it\u0027s gone wrong and that\u0027s the same in neat for all the other messages if you want to pick up an event for something happening you get an event call it comes up so this means you have to rewrite the programs in a different way it turns out most people already writing that way so it\u0027s cool next steps uh-huh trying to be quick we have cold so we would encourage people to play with our code or ask us how our code works you don\u0027t have to Chloe that you can just simply ask you can go to the github and get it um yeah I fail to draw asking out by the deadline I was I was feeling that diagram looked terrible so there\u0027s a red one if you haven\u0027t seen it which has the ASCII art in um what does the working group do next which is kind of passing the book back to you people because I think this space for some sort of document which is architectural and defines some like API maybe more than one API so is that the way we go before I write a shedload of text I would really love to know what sort of documents you want to produce and you say something about your the example apps that you\u0027ve got running on this sorry can you say something about the example apps we just send bytes backwards and forwards it\u0027s good and we we we have caught from Mozilla which runs a version of Firefox on it and it\u0027s got issues because Mozilla Firefox is a pretty big package too on top of it but "
  },
  {
    "startTime": "02:11:07",
    "text": "it it sends packets backwards and forwards and we have other apps as well mia Kulemin so I have um two concrete points say one is that this approach is like the main planet primitive is still a stream and I really think it should be a message and well datagrams are not streams ever mirror yeah so but what you kind of do is like as humans a stream and if you if you have data Gramps and I kind of merges into a message but the base primitives should be message that\u0027s hot no no I agree with you it\u0027s not how a messages of cool messages are what we are and the second part is that I think you have today even if you say like I don\u0027t know all this what we have hidden in the association is something that you don\u0027t have to do in the transport layer I think there\u0027s already thinks in the transport layer that have like long term state and that need to be covered yeah we have a long term state as regards path information so we information about what transports where can we keep information about what lacy was seeing on paths that soldiers stuff but what I\u0027ve avoided was was keeping things through that we would call socket handles relating to connections we\u0027d set up in the past because I think that belongs to layer above now you could argue we should specify that as well yeah so I mean like I guess our main use case is if you take TLS basically as part of the transport layer then you need to handle session resumption as well and that layer but yeah we say that suite so we do TLS but magic happens when you handle the keys Cairo\u0027s so I would have a minor quibble with the way that you phrase the API the API the requirement for the API model you said event-driven it seems like so there are a number of different there are a number of different models that are used widely in different languages right I mean sometimes you have an event-driven model but sometimes you want blocking or you want to be able to program in an imperative style or you\u0027re using continuation passing style or something like that right I so I think what you want is the API to be able to express a multitude of programming models and it may be that that having a having an event based model is sufficient to implement all of those I know what are your thoughts on that I think the event based model has got to be the way we go because and even when you get right down to the interface we\u0027re actually sending blocks of packets etc and what I understand I mean the I guess the point of having an event based model is so that you\u0027re not forcing blocking on people and you\u0027re not forcing polling right yeah okay so okay so I can\u0027t send much to answer your question but I mean the system we have is based on libuv we have above this a socket Shin which rewrites at all the sockets so clearly "
  },
  {
    "startTime": "02:14:07",
    "text": "you can do many things are built the callback beckus api including reverting back to the previous version of this world where we use sockets so we actually have that was running code as well so I think the callback based API could become the basis and on top of that you can build other approaches if you really want to do you do you want to respond tell me sorry for cutting a line I think the main point is that we don\u0027t want blocking api\u0027s to be the native thing but I mean event is one way to do a synchronous you can have completions like there are many models for asynchronous I think any of those are on the table it should not be one model of a synchronicity that works here and yeah they\u0027re pretty much equivalent well and and well the thing is that there are existing applications that are that are developed in a specific model right and so some are going to be using continuation passing style some are going to be using event loops some are going to be yet doing other things and it just it would be good to make sure that that whatever the API here is can support all of those models and so I think just and it may be that that an event based system is perfectly sufficient for that right and they recognize that like in the neat document especially in the neat happy eyeballs document it actually goes into a fairly detailed discussion of the libraries that are being used for venting that\u0027s fine for an informational but I think anything that is produced as this is an answer KPI should absolutely not have any reference to how the implication should do it for a synchronicity all right second set because you have to compose this network interaction with other interactions like form from the queue or something generally when you use corvex I want to use an application data thing in my coop I can not just the writing the written data or the received number because else I have to use Global\u0027s and the other thing was that\u0027s fine and I think we should have this discussion going on I mean one of the things I was trying to say was we we did it all in this way we also did the socket layer manipulation on top which reverted to socket I guess the way in which Mozilla actually called their internals of their product isn\u0027t something we want to talk about but it\u0027s not quite the same as the way in which we envisaged it so there\u0027s yet a third way is the API is being used my second point was about this low watermark stuff where I can limit the queue size but the queue size itself doesn\u0027t tell me very much because I don\u0027t know how fast my connection is what I really want to know is what an Jacobsen called the packet sojourn time through the queue you can do this today with the socket API if you have the buffer occupancy and the last received acknowledgement number and you can calculate the time packet the last "
  },
  {
    "startTime": "02:17:09",
    "text": "packet used to traverse the queueing time and then you can get some estimate if your message will arrive in time and that\u0027s somewhat missing here is a way to determine the actual time I pick it stays in the queue your real time person yes yes the question kind of looks like it\u0027s framing sort of packets online your multimedia is something which is an application where you really want that sort of functional my use cases of the SIP proxy we had this problem in the wild where the sip requests in the TCP Q and times out before it gets sent yeah this talks about this Policy Manager and there has been other discussions like racing and a payable and some other discussions here what\u0027s your thought on that and policy manager like how do you see like I mean do you see like this is a part essential part of this drought that you talk about it or you see like this draft can refer to some other things that I mean okay so it doesn\u0027t clear on the policy manager like how you need to use that okay so you okay so I see happy eyeballs as two parts I see some one part that generates a list of candidates tree of candidates however you wish to express it not all of which you will try and then a method for trying them so in my own thinking I see the happy eyeballs as how you choose amongst those lists you\u0027re getting but there\u0027s a question how you generate that list because that list also includes preferences for bandwidth or cost or protocol or reliability or maybe timing etc so there\u0027s another bit in here and how that interfaces with the stuff that\u0027s configured versus learned versus accepted from the application so that\u0027s the bit where the policy major fits in and I drew it used as a big blob I didn\u0027t say what it was but that\u0027s kind of what he does is that something we want to define here well I I think we\u0027re discussing some of these things here like within tens and for suckers and racing so obviously there\u0027s a there\u0027s something that we\u0027re gonna anyway talk about yeah and I just like confused about like whether this is a fit to the draft or is it should be something something else yeah maybe my final point is since you kicked in come back again and give me another chance and is maybe we\u0027re beginning to reach the point where we want some sort of architecture which is why I try to draw big boxes on my diagrams if we can come up with a architecture we can all agree on them maybe we can start precision in the language we use for these things or maybe be slightly more agreement if we have the same language thank you Gauri that\u0027s actually a really useful point so the next agenda item is to talk about the document number three or number three "
  },
  {
    "startTime": "02:20:09",
    "text": "so when we created when we wrote the Charter let me say something before you comment on it so when we wrote the Charter personally the model in my mind was we were going to spend a bunch of time wandering around looking at existing protocols trying to abstract the stuff that was going on inside of them there was a lot of interest in energy Ian sort of coming up with a happy eyeballs equivalent for transport protocols and and so the text that came out of that discussion was doctor after we come up with min set was well we\u0027ll do some experiments we\u0027ll build some stuff we\u0027ll write some documents that describes what we built then maybe we\u0027ll recharter we could certainly do that right there\u0027s there are several activities going on I\u0027m actually personally extremely excited about the the level of energy and the fidelity the work that\u0027s happening in this working group I think it\u0027s I was I was a little depressed for a while the group was kind of quiet but but you guys have really kind of lifted my spirits and but I think that Gauri I think summarized it rather nicely which is you know we we could go in start writing rfcs about the stuff that people are doing or we could try to come up with an architecture that maybe synthesizes some of these pieces together and then write some RFC\u0027s that reflect that and I think there\u0027s a really interesting combination of perspectives here between sort of the neat perspective and the perspective and that you know need is very much supporting the existing technology suite post sockets is trying to come up with something that will support stuff that hasn\u0027t been invented yet there\u0027s a lot of commonality between them I think there\u0027s a lot of agreement so my gut tells me that there is an architecture that can be extracted from this but it ultimately it\u0027s going to come down to whether people in this room want to work on creating that it may be that you know maybe people would rather just build their own stuff and so I don\u0027t know if we\u0027re gonna converge on that today but I\u0027d like to hear a little bit from the folks in the room about what you think you\u0027d like to do I mean do you want to start if we\u0027re going to start taking a milestone three the way it\u0027s right now I\u0027d say we\u0027ve got a set of candidate documents we can take at those in his working group documents and they\u0027ll be published with a title like something like taps candidate you know post sockets taps candidate media taps candidate you know racing or something like that and just you know they\u0027ll be sort of snapshots of a bunch of research work in progress around this general problem area or we can try to tackle the nut which is you know how do we push these kind of interesting perspectives together where there are some obvious tensions in them hi Brian Trammell would it be problematic for you to put like my "
  },
  {
    "startTime": "02:23:10",
    "text": "fourth slide back up would that be easy or hard to do um so I I agree with you that those that\u0027s the choice before us is that we could we could basically say okay well this is the you know we\u0027re doing experimentation with post sockets right now we intend to do much more of it and we could basically frame this as yes or the third slide yeah that one um number three not number four show proof of soft proof with for a fast night what what\u0027s that even for go on back sorry third slide not fourth one but I\u0027ll point out that that\u0027s basically an architecture right those are relatively high level boxes each of which can be implemented I mean like each which can be implemented within the system in a in a given way but it\u0027s um the most abstract API we can come up with it still says something and it it basically you know this right here is Norka picture that you can hang the rest of this off of now whether or not it\u0027s the etabs architecture or not I mean obviously want some things under working group change control um you know we discuss about it and we we tweak it and we change it and we you know put different um multiplicities on the lines and we change the colors and stuff and whatnot but I would point out that we basically kind of already were there great so that\u0027s that\u0027s the story of an architecture so I would be pleased to hear whether people who are working on other projects agree with your statement that\u0027s what I textured that that makes sense to them that there\u0027s stuff inside yes cool so feel free those people weren\u0027t in a line me I could have I\u0027m not working on another project but I\u0027m not sure of the word architecture is actually the absolutely right word is probably more a framework or whatever but the main point is this is on a higher level of exception than the need interface is I just wanted to say to need architecture so it\u0027s it\u0027s not that it\u0027s like one or the other it\u0027s just a different level of extraction and we should decide which level of extraction we want to document we could even do both I\u0027m not sure if that\u0027s useful but that\u0027s a decision we have to make I think if we do both we either have to say how they\u0027re connected or we say that these are two independent activities no no I think they I really think they should be connected and I don\u0027t see them as independent it\u0027s I would like somebody for me to agree MacAvoy I mean for two points first answering the request on somebody from need saying what they think about this I I think it\u0027s useful useful architecture I agree with that as an architecture I agree with how Maria says that being a higher layer another point of why I actually went here is that the way you talk about the third item we could basically you know if we would leave it as the Charter is now it could just be more or less done with the documents we have now if I read this correctly I would disagree with that because the "
  },
  {
    "startTime": "02:26:11",
    "text": "point of the Charter I mean at least this was my interpretation is that this is about about how you will actually implement that stuff and the current documents yes I mean happy hour bowling is one part of it but some part of it there is more so I think we really need documents explaining how to implement that stuff and I mean I appreciate this being good but that\u0027s not all that needs to be yeah I\u0027m sorry if I was not trying to say that an architectural document satisfies charter item three I was saying that that you know you could do you could talk about implementations and the designs of those implementations without talking about architecture and about and without connecting the implementations together in some coherent fashion and I think that this is an approach for doing that but it\u0027ll take some work from everyone involved to sort of like mash their stuff in so it fits into this model so you can see how they\u0027re related right I think that would be a useful thing I also agree as the questions like I was asking Philip earlier I think I\u0027m a meditation experience is extremely important for validating some of these ideas right right all that okay we have three minutes Gouri fair full disclosure i working brought both projects so but i see this more as a framework and I see and the the postdoc is tufas higher level and okay I don\u0027t seems incompatible but there are different levels to look at the problem whether we want to look at both levels or whether we want to collapse it into just one I don\u0027t know another instance are working it I agree that we should try and merge and have the connection between them I think that maybe we need something that is I think this is a good starting point for the architecture maybe this is a little bit too abstract and maybe need is a little bit not enough abstract so we just want one API maybe it\u0027s a little bit somewhere in between Tommy Polly Apple um well I do think this probably seems like we should be rewording Turner or item three either way so that should happen I think with the terms of like do we have implementations or do we have architecture I think if we just stop with the implementations that\u0027s interesting but that\u0027s essentially we have today and we have a good amount of experience I think we have enough experience in the room from various implementations I also think from people who aren\u0027t speaking up to give their examples of how they do this when I\u0027ve been working on the post akut stuff this is agreed at a very abstract level I think it could be very interesting to say let\u0027s all come together work on the abstract definition there\u0027s a neat implementation document like here\u0027s how we decided to express this I could write a document on how I have decided to express it and we call it all maybe something like post luck or something abstract on top of that with various "
  },
  {
    "startTime": "02:29:11",
    "text": "levels of how to implement this depending on your system and that way we have both something that\u0027s like I think what I wanted to get out of post or at eye level architecture is something that is forward-looking enough that it doesn\u0027t become irrelevant in ten years but then we all should have also should have things that are concrete enough that someone can implement them now and those are two prongs that may end up with different documents I didn\u0027t think we\u0027re gonna have the architecture piece so I\u0027m actually kind of happy that that looks like these things together okay we could have it again so um I also wanted to make one comment that we\u0027ve been I\u0027m going hear a bot nap approach so we\u0027ve been analyzing what there how can we generalize this and then going up but I believe that somebody who reads the tapes documents later on this document would probably be the starting point and you would start from the more abstract as it is a general thing so that something we should keep in mind when we try to align things so I already see that the whole post sockets need the socket and stuff every sing the people are now going towards common language and trying to at least find a common language and I think this is the way how this can merge but I think it has to do em to merge in the DES separate documents and then converge to something later on with the common language we later on half so I would rather be for keeping it separate and trying how it merges over time with the experimentation with the experiences and then find out over time what makes sense what\u0027s the right abstraction I think this we will see this later i I think we can\u0027t decide this now just one thing in response to that Tommy I think one thing that could help speed up that process or make it easier and we had mentioned this earlier was to have a maybe a terminology document right because we have a great survey of transport protocols we have a great min set stuff but there are these words that are floating around that lots of people have different meanings behind of paths and endpoints and connections and maybe just having one terminology document that all of these other ones implementations and abstracts api\u0027s can reference so we don\u0027t have to worry about the differences there and get confused would really speed up the process and I think we would end up realizing what we have in common much more quickly somebody want to raise their hand to submit a draft for the next meeting I think the bar is low just terminology but a lot of it could be copy and paste "
  },
  {
    "startTime": "02:32:11",
    "text": "are you was that it that was that a thumb or was that a little hand house alright I think we\u0027ll probably have to take this to the list we don\u0027t time to talk about it now but maybe we can have some hallway discussions this week and see if we can get some folks together I think this was a really productive discussion thank you everybody for waiting it out if you didn\u0027t sign the blue sheets I\u0027m as my bad for not nagging you about it please do it those numbers are actually useful when we pick the room sizes for the next week so for no other reason if you want to have a seat in London sign blue sheet thank you\u0027re ready we\u0027re done "
  }
]