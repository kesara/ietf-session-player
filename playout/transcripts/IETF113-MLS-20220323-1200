[
  {
    "startTime": "00:00:05",
    "text": "tony ran away [Laughter] wait a minute somebody ran out did we scare him away you scared tony rodney okay hey there there's some spots power all right we'll give everybody two minutes and then we'll jump into this so"
  },
  {
    "startTime": "00:02:01",
    "text": "all right i think it's probably time to get going here um hey everyone this is the mls uh meeting at uh itaf 1.3 um here's some particulars about the meeting as much as kind of a resting um slide for us um nick and i are the chairs just saying hi i think i don't know if you want to pop on and say hello real quick all righty get to the good stuff this is the ietf notewell um you've probably hopefully seen this by now since it's wednesday um this is about the policies and procedures that you need to follow are that you've agreed to follow as part of participating in the ihf meeting a lot of us do with ipr patent policy kind of stuff if you know something say something um you know working group process a bunch of other things there anti-harassment procedures code of contact et cetera um this working group has been well um is in my mind is uh doing very well um but i just want to remind everyone of the itif code of conduct guidelines here that are documented in rfc 7154 basically treat everyone with respects um try to speak slowly and limit the use of slang i feel like that was probably written for me dispute ideas by reason to argument uh use your best engineering judgment find the best solution for the whole the internet and contribute to the ongoing work of this group and the rest of the itf um again uh please keep in mind that both the mic on the jabber and the meat echo are on um the thing i guess is to please state your name when you get to the microphone it makes it easier for the note takers to to figure out who said what uh here's our agenda which is uh our typical kind of uh light agenda we got some of the ministrivia um we're gonna go through some things uh virtual meeting tips the virtual blue sheets"
  },
  {
    "startTime": "00:04:00",
    "text": "that's right i forgot to say this if you're in the room please go ahead and zap the qr code because that's that that takes um that takes the place of signing up on the blue sheet so you don't have to touch the aki aki pen sheet of paper so i appreciate that thank you very much if you are going to join the queue and when you're in the room please the the q tool and we can i can manage it because i can see the key just fine um and basically we're gonna go through the protocol architecture and federation drafts um uh the quick synopsis is we're getting pretty close on the first two and the third one we're gonna try to revive um all right so the next the next one the status you know basically it's time to review these are all it's time to it's time for review for the architecture draft the mls protocol documents pretty close to being done and the mls federation draft like i said we're gonna revive this should look pretty familiar um this is the timeline we've had for a slide for a couple of uh meetings now basically we did a working group last call we did a feature freeze and we've done a bunch of versions of the draft to try to get through the github issues and pull requests and we've done that now we're on draft 13 we may need a draft uh 14 then we'll do a working group last call and then we kind of you know go back out and see what happened and so we're getting there slowly but surely um the other thing to note is that uh the way we've structured these documents is that there's no way that the protocol document can really get to the isg before the architecture document um because of the way we split things out that they basically have to progress together so when we're doing the kind of progressing the documents to the area director that the um architecture document is going to have to go with the protocol document because otherwise it just won't make a lot of sense all right so that's pretty much the end of that stuff now we're going to jump into um [Music] richard slides and hopefully he has"
  },
  {
    "startTime": "00:06:01",
    "text": "arrived there he is great i will stop talking um richard do you want to uh maybe i stopped showing this and you grabbed the ball um i'd rather drive the slides off the media echo thing as you're supposed to have yep they're loaded so i will stop i think if i stop sharing and then you share them then that works i can try yes i think if you hit the little the thing next to the that yeah how do i do the slides so if you hit the one word then next to the handout button there's a shareply preloaded slides so i click that and then yep and then you'll get uh yep there we go gotcha excellent thank you i'll stop talking all right so is that showing up for folks yeah it looks good looks good cool um so um we were at draft 12 at the last ietf meeting as i recall um we have since issued draft 13 and i think we're going to do draft 14 before we go into working group called delta between 13 and 14 should be pretty small so this is mainly just a little bit of background on what we did in 13 to kind of queue up the discussion for the issues to try and get those last couple issues in prs closed out so diving into this draft 13 um did a bunch of stuff um this was a really active uh version um thanks to all the folks that did really good analysis on here and i think a lot of this was due to implementation works which is exciting so i'm glad to have more implementation effort here um i'm not going to go through all these but i'll go through a couple highlights um one thing we did was um we did a stoppage a temporary stoppage on all the technical work to just put the document in a more sensible"
  },
  {
    "startTime": "00:08:00",
    "text": "order so as you can see with the arrows here we kind of move things around so they read a lot better note like i said no technical changes to that but i think that the document flows overall a lot better so it should be more comprehensible when we send it out to last call and you know when people pick it up later on um another you know building up more technical from here um one of the changes we made that is is a little different if you're coming from a tls background is we streamline the the vector syntax down a little bit in tls you say you know how many bytes of length you want to put at the front of a vector which constrains how long the vector can be in bytes which means that if you have two implementations on an interrupt they have to agree on how many bytes that they're going to put there so we found when we did some interrupt testing on earlier address this led to a bunch of stupid interrupt bugs and you know there's obviously more code to kind of negotiate which um which sizes you use so the pr we did we just made the uh the length field of the vector encoding a variable length integer so that you just put as many bytes of length as you need and there's some signaling to say how many bytes there are um stealing a scheme here from quick which um you know i think eckerd proposed putting into ctls is a compact way of doing vectors there but yeah that's got to make make some things a little simpler use this v notation to indicate it in the brackets um let's see what else another nice um kind of conceptual cleanup we did was to split um leaf nodes and key packages um so key package as you recall in prior address were used both for initializing pre-publishing my capability so i can be initialized into a group and for representing my appearance in the group in the tree after i joined so what we did i think this was due to a suggestion from teophil wallace we split the those kind of two roles so"
  },
  {
    "startTime": "00:10:01",
    "text": "the leaf we now have a leaf node struct which is what represents a member in the group in the tree and then that leaf node gets wrapped up in a key package and the key package is used only for pre-publishing information about a client so they can be initially initiated into a group while we were doing that refactor we did a couple of other things that kind of clean up the structure so things that were expressed as extensions but always had to be in a key package we just promoted those to being fields we now have two separate signatures on a leaf node and a key package so that you can verify that the leaf node verify a leaf node in the tree as well as verifying the key packages pre-published that both use the same signature keypad that's in the credential um one thing's really nice here is we now have two hpke public keys so the tree the key that goes into the tree and is used for treechem is different from the key that is used to encrypt the welcome message when you join so you have kind of that nice crypto separation between the one-time initialization operation and the ongoing uh tree cam membership in the group um finally the last thing this let us do is i had really illustrated the slide here is that when you have leaf node that's added by an update or commit um that leaf node gets re-signed and that signature covers the group id so your leaf nodes are now bound uh to the group they're participating in and by the way people should feel to step in if there's comments or questions here i'm just kind of rolling through um the high points of graph 13. um a nice suggestion from martin mullarczek which gives us a little bit more efficiency here is that we've updated the algorithms for how we update the tree so that um we no longer generate what we call redundant nodes um where we're done by redundant we mean a node that only has one child that's populated so here i've put keys nodes that have key pairs attached to"
  },
  {
    "startTime": "00:12:01",
    "text": "them in black nodes that are blank and in white so all of these nodes that have the arrows next to them in the lower graph they're all redundant because they had only one child that was populated so you know if you in this case where we have only three members in a tree that's bigger because it used to have more members we no longer need any of those intermediate nodes and so we save on key generations on this streamlines tree truncation later on um generally makes things a little bit cleaner so it's a nice simplification one thing that took us a few iterations to figure out is this um tree hash based parentheses another thing from from tafil and then the inria folks um right now with some parent house you'll recall is how we enable someone who's joining the group to verify that the keys in this you know who who has access to the keys in the tree that the trees are actually following the what we call a tree invariant that the key is only accessible to the the nodes below it in that parent hash the parent hash here at v would cover its parent x and a representation of its sibling zed and so right now uh in draft 12 uh we use the resolution of that sibling because z is populated here with the resolution is just the node zed uh and so the change we made was to use the tree hash of the sibling which binds in all of the the entire sub tree under the sibling node um which obviously gets you a tighter binding to the structure of the tree so you type in the whole structure of subtree tie in the things that are in the leaves like the credentials um so you get a lot more more information tied into that parent hash and so more rigidity in the tree fewer ways an attacker can lie the challenge you get with that is that when you do this at the right edge of the tree"
  },
  {
    "startTime": "00:14:00",
    "text": "um that you're binding the tree structure but the tree structure at the right edge of the tree can change when you add someone so in this example you know someone has added this node h as new member h um without sending an update path which is legal so everyone just ratcheted you know symmetric ratcheted forward and as a result h and the blank parent of h got added to the tree so what that means is when h gets the tree it needs to it's going to need to verify the parent hash at v and it's going to need to recompute the subtree at lead at from before h was added so it's going to need to you know in addition to computing the treehouse the hashes of the trees that exist today it needs to compute some historical hashes and teo field provided some nice analysis on which we validated an implementation it shows if you do a super naive algorithm here you end up with doing n log n hashes i'm having because you're having to recompute some things um if you do a smarter algorithm that has minimization you can get down to n log log n um and so there is some cost to this it's it's worse than o n but not worse by much of a factor it doesn't get to do much and so just to validate that that uh cost wasn't too much um i prototyped this out in um in mlsp the c plus base stack that we're using in webex um and looked at a few cases so the the the thing that really makes this um algorithm uh challenging is unmerged leaves um because as you can see the the way that tree structure change happens is when you have unmerged leaves so simulated a few cases here you know looking at a full tree with no unmerged leaves and then synthetically made some trees that were either like half on merged or three quarters of merge to really try and drive out the painful cases uh for this new algorithm um and then finally it's"
  },
  {
    "startTime": "00:16:00",
    "text": "tested you know a case where we have one very sparse tree with one path populated as if you had um you know someone adding a bunch of folks to the tree um and looking what they had to do to join um basically this path case is the best case um in fact in that case you're actually doing um your performance looks better than the previous algorithm even in the worst case you're you're at about a factor of two um worst case performance um and quantitative in absolute terms um you know the you can see the the top right graph there you're still taking on the order of 30 milliseconds to verify the tree when you join which when you consider these trees at you know 200 plus members or in the order of megabytes it's going to take you much longer than that to download the tree at all so it's not really a salient performance hit uh to do this uh parent hash and get the increased binding so i think that's everything that went into draft 13 so i think um you know the upshot of all this discussion especially after we close out our last few issues here is i think we're we're pretty much ready for working group last call so with that i think it's time to ponder draft 14 um which is uh you know going to incorporate i think just the the prs we have outstanding so sean did you want to drive um you want to share github and and walk us through that um i can i think that you need to relinquish it or i take it from you hold on yes so i have relinquished you relinquished it now let me see if i can screen share do you really want to stream scare yes i do let me tell you which thing i want to screen share how about issues this one allow is this actually showing look at that it's like i almost know what i'm doing all right cool where do you want me to go um so issues wise i think that one issue is covered by an existing pr so we can"
  },
  {
    "startTime": "00:18:01",
    "text": "just dive into prs um and let's see i think we can go through this in kind of easiness order so 619 the top one there i think to feel proved that this morning all this is doing is going through and annotating all of our code blocks with what type there so there's not really any technical content here it's just saying that you know this this one's tls this one is ascier this one's pseudocode um this allows um if you pause it one of the aasvg ones they're shown actually um this is you know the tls bits i came across this because actually i was trying to extract the tls syntax to help with implementation um the other cute trick you can do here's this aasvg tool that martin thompson wrote we'll actually convert this ladder diagram to an svg file so it looks a little prettier uh in the html rendered version so um i think we can probably just merge this because i think it's just editorial but i thought i'd let people know in case there are this is editorial i think you can just lock the button on this one yeah all right next um this one is slightly uh technical um if you want to go to the changes it's a small change but it's again trying to go for um more key separation um so right i already said we uh one of the things i mentioned in the key leaf node key package separation that was nice is we have these two hpke keys now one for initialization and one that is my long term key in the tree there's no requirement right now that there's actually be different keys and so this pr is just adding that requirement in there so require that they'd be different main"
  },
  {
    "startTime": "00:20:02",
    "text": "draw vector is it's the other key so you need more entropy to generate it um but i suppose you could comply with the protocol by deriving them from some common secret as well so i don't think that the entropy requirement is too terrible so i i'm inclined to merge this unless folks have objections i will consider that silence to be consent 617 i think we've got pretty good agreement on this as well on the mailing list um 617 we had some discussion about um i guess the discussion started here about deniability um where folks were there's some ambiguity um uh or some disagreement in how people read the spec when it came to what keys were used for signatures and as part of that discussion it came out that um there was ambiguity around these pre-configured centers as well there wasn't uh it wasn't kind of defined interoperab interoperably how you would make sure everyone agrees on who's pre-configured so this pr um cleans that up basically it ensures that every everyone in the group agrees on who the external senders are so they'll everyone make sure that everyone will agree on who the valid signers of a message are so if an external party non-member sends a message into the group we're guaranteed that everyone in the group will handle that in the same way and either accept it or reject it consistently across the group so i think we discussed this pretty thrilling list i think it's got a couple of approvals in github um but i thought we'd bring it up here just in case there are any further comments"
  },
  {
    "startTime": "00:22:01",
    "text": "hearing none we'll consider that merged okay so now that these last two are maybe a bit more controversial um so rowan proposed this one to indicate the mime type of the uh application data that's carried in an application message um my comment here in the pr um so my inclination um to just a bottom line up front um is to to close this one with no action i think this is probably um kind of getting a bit premature in terms of signaling inner content types i think we've got the tools to add this later on um but rowan did you want to tee this up yes hi good morning everybody um so i think mls is a little bit unique among itf protocols and not either uh having a place where you can describe what the next layer is or defining explicitly what the next year will be and so this was my attempt to to fix this so i don't think it's premature at all i think this is this is basic uh hygiene protocol hygiene and pretty essential um if you're in a group an mls group that doesn't require um you know that that is uh completely heterogeneous then you can then you could admit this and the only harm that this would cause would be a single extra byte saying that the length of this is zero bytes so i"
  },
  {
    "startTime": "00:24:00",
    "text": "first of all like i don't see that there's any great harm and second of all it means that you have the ability to to have this basic function where you say okay i'm the thing that i am sending is a this and um if you need something more fancy than than a specific mime type with parameters then you can send a mime type that has further descriptions uh and it you know just because it's just because it's a mime type doesn't mean that that thing needs to be text you could send uh applications or you know application slash vnd dot you know example vendor this crazy special message format um so those things are all possible yeah and just to kind of make an analogy for people i think if folks are coming from a tls context i think the right analogy here is something like alpn which was added to tls as an extension but you know you could ask the question is if if we were doing tls over from scratch would we develop alpn from the start eric mr squirrel are you intending to speak here we're not getting audio from you i was intending to speak but you know then didn't um i mean i think so the airplane is an interesting analogy i guess you know i i tend to think of this as um um you know like mls is designed to be embedded you know in other protocols it is in itself like a complete protocol um and so i would think that the largest are those protocols to define what um what what the contents of those messages are um and so like why i'm a little suspicious of the lpn analogy um i think that's what i mean i might think of this more like aed in fact as and say that there's that information obvious it'll be elsewhere i guess i don't quite understand why"
  },
  {
    "startTime": "00:26:02",
    "text": "like um you know it seems to me that that you know one might wish to have you know that i mean the different different groups that are all on different things and different conferences around different things and i'm not sure why why where they can dictate one label one type of labeling here i mean it certainly seems to me like that if i want to build a if i want to build you know uh um you know if i want to build my own messaging system like they use mls like i'm going to want to dictate like how how the how what kind of message is going on and how that how those message types are conveyed and it's not quite any an mls solves that problem so in regards to whether you want to convey the content on the outside then i think the reason is obvious that that you are leaking information which would which could otherwise be private if you're putting it on the uh if you're sending it possibly unencrypted or sending it that's not what i'm saying well what i'm saying is like that that you define the message types and inside the message inside inside the message bodies can convey the types of messages any further that have information right so so like you can say external like i say like if i want to do my message system i say all my messages are mine and everything inside is mine and so you look at the interest inside the message right and so that's i think that's the correct the correct locus for defining the message types is inside the message but the correct locus for defining the format of that is outside um i think i i'm not really understanding where what you're getting at here because i'm on type doesn't need to be you know like rfc uh 28 22 style mine right uh i could send i could send like a vendor specific mime type i could spend send cbor i could send protobuf i could send"
  },
  {
    "startTime": "00:28:00",
    "text": "json i like i just need a way to say the thing that i'm sending inside has this because this framing this structure whatever and i can further define if that's not explicit enough then that can further describe its own content i i agree with that can i say that eric can i can i try restating just sure so so i think what what eric is is saying is that to deploy mls you need a number of specific things defined um like the specific transport that's going to be used uh who the authorities are that it depends on and what i think what eric is saying is that one of the things that need to be defined in order to use mls is how you should inspect how you should treat the contents of any given mls message right and one of those ways may well be that the message is a my message and other ways may not want that mime overhead and given that mls is not a specific concrete protocol but rather an abstract protocol that needs some parameterization before deployment why not use that why not put the how how to deal with the application data in that parameterization right and a common pattern may well be that the beginning of the application data is a mime type uh but there may be other situations where that's not necessary and it's not clear what what we gain from sticking this in here if we don't actually have a um you know a meaningful way to to deal with that right like what if i have an application where i expect all of the messages to be uh image png's where people are just like i don't know texting each other photos or something um yeah and then suddenly you get something that doesn't say image png in it um"
  },
  {
    "startTime": "00:30:01",
    "text": "what's supposed to happen to your protocol there right so it precisely as you described this is a this helps solve that problem it is just a tool and help helping to solve that problem but if you uh if you define your group so that your group only ever sends pngs then you could leave this you could leave this blank and only incur an extra byte of overhead uh if you wanted to explicitly signal that you were sending one of several types of supported content then you could put in this in this field before the application data you could put the the type that you happen to be sending among the types which were were predefined by your application that they are acceptable types you would send that type and then the application data doesn't have to have any mime texts it doesn't have to have any headers it doesn't have to have any extra framing and that's the the value there is that you have you have some agility in that if the group allows it you can send optional types which could be ignored you could send uh you could if you have multiple choices which are all acceptable you can signal which one you're sending it provides a lot of flexibility and so it provides a basic way of signaling what is what is this content inside consistent with whatever you have defined as your group policy i mean honestly it just seems like a"
  },
  {
    "startTime": "00:32:00",
    "text": "no-brainer to me uh jonathan hoyland cloudflare um just a couple of questions sort of quick first style if you like um if i have this mime type defined uh how is that made available to the application and secondly if the application data has in it a mime type is there some way to enforce that they agree and if they don't agree what is the correct behavior so can you give me an example of where you would the content that you would be sending as your application content uh if you wanted to send for example um a multi-part alternative then i'm thinking of the case where i know i'm using some bad api and i can't get the mime type in my upper level application so i just put it also in the application data just so that it's there and then somebody says ah here's an image png and then at the upper level it says ah it's actually an image jpeg and suddenly it's all broken and bad things are happening for no apparent i mean i i i feel like if you if you've got an opaque application it would break in mls if you put i could cite you know a dozen different things in mls that would break if you didn't get if you didn't get the sender information from mls if you didn't get the the group id i mean right but this is a piece of information which is potentially defined in two different places right and can be just in two different places don't put it inside either either either set the value to either set the value to zero"
  },
  {
    "startTime": "00:34:01",
    "text": "you know to no no length before the application data or set the value before the application data and don't and don't try to replicate it by stick by putting it somewhere else if if that was enforced that would probably be better colin go ahead i'm just playing oh it looks like i'm on okay um [Music] so i'm not arguing for against this one way or another i'm just sort of saying that like this is a i think the analogy to lpn is actually really quite good we could have defined tls so that when you are using tls in a given application context of the protocol you're putting over it the first thing that we do is send a wrapper header as the first bytes in it that tell you what's coming next inside the stream that'd be one design it's just such a common thing to do to be able to switch between them and we already had these other protocols defined and didn't want to define a wrapper protocol for the protocols we're putting over tls that you put in an optional field to carry this information and it really helps with negotiation upgrade and stuff i think that's a fairly clean analogy to what's going on here like whether you should do it or not who cares i mean you can either put this identifier of what the data is you can either put as the first bytes of what you find in the message or you can put it in the metadata outside of the message we can go either way but um i think this is a i i think saying this is very different than tls i i don't i i don't see that at all actually i see it as about the same as tls thanks well i mean so i think first of all i think the tlc analogy is a little odd in that the reason the airplanes are the way it is is because this client had to discover what the server's"
  },
  {
    "startTime": "00:36:00",
    "text": "properties were and it had to be done in the first round trip so um that's not the situation does not apply here um but i mean we're not we're not actually debate what we're not this i think we generally have this problem in systems where when you have like an opaque transport and you want to demux you give us the types of things under it what specific specifies like you know how that debossing happens and what you propose is to find the specific define the in this in this specification that you almost must have the unboxing of a particular type and the other option no it is you're saying you always have to have this if this is this value always the beginning and always just be there and and but it can be but it can be zero yeah it could be zero okay but like that which is which and this is the case we always come into when we have these things and and what i'm saying and what i'm saying is that the description of what to form demoxing including the zero or not should be on another layer and you could have precisely the same wire formats by the way namely that what i'm saying is that in your ml specification mls mls um concrete deployment you say we use the unboxing specified in this pr and so the wirefront will be precisely identical the only question is who just is is where is the information conveyed that of which which form of in-message debuxing you're using and i don't understand why it has to be in mls suppose in the concrete instantiations of mls other protocols so if it's not in mls then i think we must define that the next thing that for the framing that says what is the thing inside yeah and that happens in the messaging protocols which make use of mls and each one so how would we we it's like how many layers do you want do you i i think it's just no i'm not all right because i see as many like precisely as many layers we're talking about in every every case you have mls and then you have a concrete messaging protocol that makes use of it and and in and as i said the wiring coding was precisely identical and the question"
  },
  {
    "startTime": "00:38:00",
    "text": "is merely who specifies which where the wire encoding is specified and so we and what you're saying is every use of mls must use this prefix monitor encoding and what i'm saying is that mls is embedded in you know did you say prefix mime encoding because there's nothing i'm not you're saying what i'm saying what is this prefix mine this prefix find type value well actually a concrete suggestion occurs to me here so rowan you presented this uh draft on mime type negotiation in dispatch which i think is a fine idea i mean like if you're doing that extension you could extend the in the semantic of that extension so that it also said put this mime type in front of the application data it would be a trivial increment on that extension how could you do that it would be an illegal it would be like any mls library that you used would then be using an illegal tlc record format well no so what you would say is that the app the structure of the application data if you use this extension is mime type followed by arbitrary data so you would you would be structuring the internals of the application data sorry then go ahead maybe i can jump in here and try and uh d do something so like i think the point that i've heard several people trying to make is that like our foundational assumption is that we are not specifying a complete interoperable protocol here like we're building a framework and we expect as any precondition as a precondition for any deployment that you're going to have some sort of integration glue to integrate the thing we produce into your actual complete deployed system and you know it's it's a very good question to say okay well how is the actual uh structure and payload interpretation of the payload to be conveyed like thank you for raising this question it's it's good to consider where this should happen but because what we're building is sort of a framework rather than a concrete protocol"
  },
  {
    "startTime": "00:40:00",
    "text": "it's not immediately clear where the right place is to include this information we could say as a precondition of using mls you must supply your own form of this content negotiation we could also say we will provide this thing that you can use um but because like we don't have people with a wide community of deployed implementations using our stuff we can't really say is it going to be more convenient more of the time to have this be part of the integration blue or is it going to be more convenient more of the time to have it as part of core mls and so unless somebody can propose a way to like have a metric to decide which form of the integration is going to be more useful overall we don't really have a way to answer this question and in that sort of scenario we might consider it quite flat so i will i will um i think that's a nice way of framing it benjamin um but uh or sorry a nice way of framing it that i think the um an analogy for me would be if somebody had imagine if somebody had defined http without having any place to put a content type and it said we're going to just leave this up to the uh to the application and the first application that anybody ever used was they put some they put some some html at the beginning and imagine that basically every non-html usage of http now had this extra croft at the beginning that was in a in a format that you otherwise wouldn't have needed to parse so you know you have you have this extra you know like html and then some you know some extra thingy inside um maybe it's only"
  },
  {
    "startTime": "00:42:01",
    "text": "20 or 30 bytes but it's always in this ancient format that we don't care about uh i think that that's that's precisely the cop-out that we are making right now if we don't do something like this if we were to say you must always put an extra tls record layer formatted thing at the beginning that has some format i think that that might also be fine but this just seems like such an easy way to say what is inside that is within the context of the group that you negotiated uh so i guess my very quick reply is that yes this is an easy way to specify what's inside um it's possible somebody could come up with a different easy way that is a better fit for their application in the future and if we specify this way now uh there's a decent argument that we're locking somebody else out from doing something better in the future and so i think that the options here are basically do this or something similar to it or clearly document as a precondition of using mls that you must supply your own content type identification so if you say that you would be locking somebody out of doing it in the future um so i'm countering that you wouldn't you could define it in your group you could include that preamble and you would set this you would set the value of the the tls record layer included fields to a null value yeah i mean my my sense here was that the topic that i think jonathan was bringing up about like if you have two"
  },
  {
    "startTime": "00:44:01",
    "text": "different similar values how do you enforce consistency between them and you may not be able to enforce that you always have access to it but i think i'm also probably running over time here so maybe i should shut up yeah sorry yeah i think i would ask the chairs to yeah there you go so i think what we're going to try to do is actually do a show of hands here sean i think we lost your audience we lost sean entirely maybe nick could run this i think i can access the show events too oh thank you stephen if not maybe an ad can do it i don't know i had a bit of a death there um so the show of hands tools um we're gonna do you know we talked about us a lot so this is gonna be a merger not merge kind of questions um so um whatever what's the number of this pr doesn't matter doesn't matter 605. um so let's do with merge number 605 let's see if we can do that so you're going to raise your hands if you think it's a good idea to merge this and then we'll do another one about not merging it okay oh no this is yes or no right there's only two options here so i think when we do this it'll be let me start it it's yes or no so yeah raise your hand if you think we should merge it and do not raise your hand if you don't think we should rate we should merge it we have 81 people in our room we have currently have 15 participants i'm going to let this go for another minute"
  },
  {
    "startTime": "00:46:04",
    "text": "[Laughter] all right well what happens we take it to the list um in the poll we'll take it to the list there's one other pr related to protocol that we're also going to take to the list um so i will go ahead and do that uh the other the next draft i think we're going to switch over here to benjamin to give us a kind of quick walk through of uh the architecture draft thank you tell me what you want me to do so can you please show the issues for the for the for the documents actually i think it's going to be a very short discussion because pretty much here is a very easy editorial and not much has changed since september so the the like i think if the protocol document is done uh richard and i did a pass on the architecture document uh over the last week and uh and typically richard made sure that we are lined between the the architecture document and the protocol document so that we don't have any um any differences in terms of the the way we name the group id things like this i still need to do a last editorial thing but the last editorial pass but generally i think it's pretty close to be done there are only two real issues left that are also mostly editorial one is 75 which is uh tactics the expected type of deployments and typically what we have been uh what's been asked here is documenting more uh kind of deployments meaning like like the the framework on which we built mls is mostly the centralized deployment but we"
  },
  {
    "startTime": "00:48:00",
    "text": "made sure that the protocol can handle you know like animals deployments a different kind of delivery system for messages and you know some people typically brandon actually asked whether we should document more use cases more kind of architectures in this document i at this point i don't think we should do that i think a much better place to do you know federated deployments decentralized deployments is in the federation document because like the the main one the centralized deployment is is the one we refer to for the for the for the deployment of the protocol and uh you know so it's it's it's an id i mean but i'm not convinced that we should go there so we propose that basically we don't do anything we keep the centralized deployment as the main use case but i mean to you know to make a point i mean the document is written to make explicit that this is not the only deployment right like we can deploy in many ways uh and we have like only in the architectural document the minimal assumptions which is we need some kind of authentication service which will authenticate these or provide keys for for signatures uh later on in the protocol for authentication but we don't say we explicitly say oh by the way this can be you know a consensus mechanism this can be a central server this can be so we already have this notion that the centralized deployment is not the main domain the only framework so for this one i would i would pretty much say that we should not act and we don't do anything and move that basically issue to the federated into the federation documents um"
  },
  {
    "startTime": "00:50:01",
    "text": "so are there any questions about this any comments i think you know like the point is that this document is very clear that there are other deployments that the central one and it actually already provides intuitions or explicit recommendations of other kind of deployments but you know i think writing down a full federated uh or decentralized uh architecture is like a separate thing uh if we want to instantiate this like this is really focused about the minimal things that we need for the protocol to run so yeah i would say not touch not touching it is the best way to go here any comments that's chair i think this is definitely one of these um please bring pr if you think that this is needed so you know if if brandon shows up with you know 50 pages like hey great we'll review it i i i imagine that sometimes which he might it's very possible right um that if it's not forthcoming that it's okay that we put it in the federated document or it's been open for a year and a half now so you know i don't think i have a slightly different take here i am not sure this belongs in the federation document because i think that'll be a little bit more protocol oriented than talking about these deployment considerations but i i don't think it's actually all that useful to talk about these kind of aggregate deployment scenarios either because the individual properties um that are talked about here get covered in the architecture document so net net i'm i'm okay uh closing this with new action as well i i don't know if brandon's here or if anybody else wants to get speakers but um let's go ahead and proceed with that and if there's a rush to the microphone here"
  },
  {
    "startTime": "00:52:03",
    "text": "all right i think we'll go ahead and you can see who closes from now or if we do einstein i just need to just go through it now we're down to one number 71 yes and that's also very very straightforward i think um chelsea actually um wanted to make sure that the phrasing in the architecture document um is is good enough so that people just assume that because there is an uh key package or an init key that is used that is added to a group means that the the the participant is actively contributing uh meaning that you know like anyone can take uh i can take the init key for jobin or whatever and like do an x3dh session with him uh it's not gonna mean that he wants to talk to me right or that we're in an active discussion and we have a very slightly similar issue in in mls uh the way i see it so i want i like things she wanted to improve the phrasing to say that only when a participant actually committed to that group in response for this ad we should consider this uh as a participation um so i don't even want to go that way and say he is like this person is participating but i want to make sure that the phrasing doesn't imply that because someone uh is added to a group because it's other two group uh that person accepted to be part of that group until there is no until there is an actual action from that person uh you know you can't assume anything of its active participation so that's the i think that's like uh very straightforward uh i am waiting for chelsea or someone else maybe you know that wants to do a pr for that one but"
  },
  {
    "startTime": "00:54:00",
    "text": "it's like really a simple editorial pr to ensure that there is no confusion right um and at this point i think the only thing that we really need is his review for the architecture draft like last review is from richard last week i think he made a nice set of editorial comments to that document uh we merged them because like there was no change uh that needed to be discussed this was purely editorial like changing names uh for the for the types that were used in the protocol documents and things like this welcome i think we are done so on number 71 here um i think that it there is probably a conceptual distinction to make between membership and liveness because when when someone has been added even before they commit they are a member of the group in the sense that they can access the group's secrets decrypt messages etc i i agree that they may not have you know consented they may not be actively involved in this group it may be a stale key package or whatever but you know they regardless whoever has has access the private key is has access to their secrets and it's just a member in that sense so i think we may if we really want to clarify this one up we may need to you know clarify that and make a distinction make a distinct notion of kind of liveness and consent um that's a separate from membership i i can take an action to think about how to express that that would be great apart from that i mean the the last two issues are really like making sure that we have all the citations for the paper that we wanted in the architectural document and ensures that the affiliations and the contributors are correct uh the rest is like yeah if anyone has like uh i don't know do you want to proceed uh sean with the timeline come on i want to make sure that robin"
  },
  {
    "startTime": "00:56:00",
    "text": "uh you're in the queue yeah thanks sean is the audio okay yep yes good yeah i wanted to pick up on the point that richards alluded to here because the alarm bell that set off in my mind was um are we opening the door there for the kind of proposal that was put forward in the uk the so-called ghost protocol or silent listener what i don't want to see i think in a spec like this is um a a staged view of someone being a member of the group that would make it possible for someone to participate in the key exchange but for some reason because they're not at that point considered to be a full participant of the group for other people in the group not to be notified that that person has has undertaken the key exchange i think that would be bad and dangerous so we don't have that uh definitely we don't allow that because the protocol actually enforces that everyone sees the same thing you can't hide basically like the the nobody can add a participant i mean that would not be visible by other members the only the i mean let's be clear any application can do that right like any application can link that or any any programs that forwards the message to from so any malicious participant can do that but like uh forwarding messages i mean but they cannot add people that won't be detect that won't be actual members of the group what i mean by that is that the cryptographic state will include the the key from someone that has been added uh but the application must know that you"
  },
  {
    "startTime": "00:58:01",
    "text": "know the this person hasn't sent them a message to that to that group um is it is is what i said here i mean the the fact is that philosophically you can't either participant you can't do like the uk backdoor thing thing okay yeah that's it's it's reassuring and i think um it suggests that chelsea's comment is really about clarity of the text rather than uh safe safeness of the protocol thank you definitely all right so what i'm going to do is i'll benjamin to answer your question i'm going to ask for uh volunteers is there anybody that wants to go on the record for saying that they're willing to review this uh soon um because otherwise we are actually going to do a working group last call and there i would love to have some people also volunteer on the record to have a review so reviews are very helpful right and they're necessary so yeah it's hard it's hard for me to tell benjamin hey make some changes he's like uh nobody's asked for any so i do think that as we progress this into a working group last call that the reviewers will come out of the woodwork and that's certainly when we progress this to uh the air director we'll probably get some uh reviews i don't know i assume we're probably gonna get paul um i think we'll get some reviews but i know that when we leave the working group we're gonna get comments from people so um so all right cool i didn't get any uh people that uh volunteered but we'll we'll i think we're gonna get some by uh force of nature here so um the last little bit here is on federation so um uh raphael if you want to jump in i don't know i can hear you excellent okay i'm gonna"
  },
  {
    "startTime": "01:00:01",
    "text": "try and go really fast on that one um so yeah a really long time ago the working group created a document called federation because at the time a number of parties had expressed some interest in that um we haven't really been working on it because we've been focusing on the protocol itself and the delivery service and the authentication service um so it's become quite stale at this point um but in the meantime the protocol has matured and we are relatively close to the work group last call now we have several implementations we even have one deployment so that means that we can actually we're now in a better position to talk about federation with all the experience we have now so the idea here is to see if we can resurrect the federation documents and the old version is still around you can use that as a starting point and modernize it specifically rowan has proposed to make some initial contributions to that um and as a reminder maybe this document is a non-normative document meaning it's not intended to specify a full wire format to do federation it's probably more likely going to be about the different components and how they can interact so yeah i think that's actually it so looking forward for some contributions and discussion yeah so the only thing i want to add for those process wonks that might be in the room or on the in the thing here is we've already adopted this draft um and there's a repo for it that uh we're gonna let the editors do their thing if they've they want to rewrite the document or whatever um they're just going to go ahead and do that we're not going to do the whole individual re-adopt process delay we're just going to set them free basically um and so i thank you for reinvigorating that because it's one of the things that's on our uh to-do list so thanks and thanks everybody for showing up it's 901. thanks for staying that extra"
  },
  {
    "startTime": "01:02:00",
    "text": "minute uh go get some uh libations before uh the plenary or the ohio or wherever else you're gonna go next thanks a lot thanks so bye expect some mail to list ciao thanks again stephen and robin um how um well he'll be at dinner tomorrow [Music]"
  }
]
