[
  {
    "startTime": "00:00:06",
    "text": "come take the center chair that\u0027s why there are three of us actually is for redundancy if if we happen to lose a working group chair in the middle of the meeting we\u0027ll just continue as though two is a sufficient we don\u0027t have diagonal parity though so the loss of two would be a catastrophic event um okay it\u0027s one minute over so I guess we\u0027ll start ITF 102 net mod working group if you are here for M Bundy you\u0027re at the wrong end of the building so I\u0027m Joel yeagley can Kent Watson and Lou Berger are the other chairs our illustrious ad is actually sitting in the front row looking diligent if you see him run to the mic it\u0027s probably because we have committed a grievous error we have the note well you should have read it several times by now but it is included in all of the presentation start-up materials in in every session so you should be really familiar and having completely internalized it by now blue sheets are going to be distributed please sign them so that we know that you were in the working group and that we can inform the Secretariat of how many people we can expect in the meeting room apparently fewer directly after lunch so all of these sessions are being streamed and recorded so please when you want to ask questions or communicate with the presenters do so using the microphones and please state your name for the record of the minutes before speaking or when speaking blue sheets are being handed out do we have note takers you\u0027re gonna Cantus taking notes do we have a jabber scribe is there anybody who wants to hang out in the me deco and scribe excellent we are yes we\u0027re also using ether pad so we\u0027ll be taking notes there I won\u0027t be doing any of those things since I guess we\u0027ll be presenting from my laptop all right "
  },
  {
    "startTime": "00:03:08",
    "text": "so we have two sessions this week this is session 1 obviously and session 2 is actually on Friday morning we intend to use both of these sessions fully so if you were planning and skipping Friday because you thought it would be light we do have a full agenda there so if you\u0027re especially if your draft happens to be presented there it\u0027s probably a good plan to show up for the Friday session ok session 1 we have 10 minutes through the agenda so I don\u0027t need to pad this out too much but our presentations are going to be the interface extensions discussion led by Rob Walton yang module tags yang data extensions and yang versioning that is the design team exercise and that actually is expected to take up the balance of this session session 2 we\u0027re going to look at a bunch of the recent submissions or documents that we have taken updates for right surely I believe that we have at least seven of those currently scheduled and since the last meeting we have two new rfcs RFC 83 48 and 83 49 so that is the entity module and the ad 22 Biss work we\u0027ve submitted a bunch of drafts towards the tail end of Benoit\u0027s tenure and to get and to keep Ignaz busy so that was sixty eighty seven bits that\u0027s now in the RFC editor queue syslog model is actually miss reffed because it has a dependency ACL model is in iesg review right now and schema mount which you know we actually managed to get closure on in london is now also in RFC an ISDN review so the things that depend on schema mount that are sitting in miss ref will likely shortly exit that position so a whole bunch we\u0027ve we\u0027ve broken a logjam and a whole bunch of documents are coming free we have no post last called documents right now working group documents that are on the agenda this time include the interface extensions the sub interface VLAN model module tags and the yank data extensions somebody else want to talk "
  },
  {
    "startTime": "00:06:08",
    "text": "about the liaisons i\u0027m actually not that familiar with that ekiden i don\u0027t have too much more to add and what\u0027s on the slide the one thing I\u0027ll point out is is that I believe the broadband forum liaison just got refreshed it\u0027s basically the same liaison but it was just sent to list so clearly they\u0027re looking for some reaction so we really encourage you all to look at the liaisons if you have any comments on them or have any thoughts suggestions on responses if you think they\u0027re necessary please send those comments to the list if you don\u0027t you don\u0027t wanna send it a list you can send it to the chairs yeah thank you um yeah so that\u0027s it so I think we can actually step into our agenda as soon as I can find my pointer okay so I think Rob Walton is the first presenter with the interface extensions big obligatory one to attack okay then your face extensions like this oh did it actually that\u0027s the one that is a PowerPoint Rome they apologize we lost the Chromebook right before the start of the session so it\u0027s just a few minutes extra hi Bob Wilson and I\u0027ll just say update on these two drafts so there\u0027s not that much to say so go through relatively quickly the to draw scintillates extensions draft is adding some sort of common functionality to interfaces it wasn\u0027t in the original interfaces model this work has been going for quite a while and it was sort of slightly languishing because the nmda work took priority kissing that\u0027s out finished more "
  },
  {
    "startTime": "00:09:08",
    "text": "recently have now updated the draft of the examples which was one of the sort of key outstanding things to do on my hints I think this draft is pretty much or very closely ready for it last call there\u0027s two issues that still remain to be resolved the some comments from only been in the yang box reality to check that they\u0027ve been addressed I think the most them happen what the check they\u0027ve all been done and then there\u0027s a bandwidth leaf that was in the original model and I\u0027ll cover that in a bit more detail so the other issue the author of resolve is this ban with leaf it was in my original model added in I notice that several vendors had this and I\u0027ve removed it from the most recent version and when I spoke to AC I had some feedback and there\u0027s some discussion as to whether this leaf could be targeted towards a sort of configurable tunnel reserve reservable bandwidth and so I think I need to get closure on that issue or may see much might be helpful to see if it\u0027s useful to include this leaf and is where their goes into this model or whether it goes somewhere else there\u0027s a better place for it but I don\u0027t want that to really hold this draft up I want to effectively either choose one where neither goes in and we\u0027re done or it doesn\u0027t and we move on without it so that\u0027s that\u0027s effectively only minor things to resolve so I think that this one should be able to go to working group last call fairly soon are there any comments or questions on this one at all I have one comment that\u0027s we related to these drafts in general I think these drafts are excellent and very good a very good value for people who are implementing these things but I had some troubles in using these drafts together with the I Triple E drafts in particular other problem with implementing simple configuration for for a transplant which that takes just four lines in open wrt but of course valleys now a yang with you dot1q from something from I Triple E which is a terrible overkill and it\u0027s not structured well enough to be able to just take some power that\u0027s around for my work so we had some discussion about that so I would like to ask whether there is some option the the I Triple E liaisoning was mentioned I don\u0027t know if we can do reviews of their modules because I believe some kind of better "
  },
  {
    "startTime": "00:12:10",
    "text": "structuring of their more use would be immensely useful but I don\u0027t know if we can really I like this so I think the answer is the boats probably sailed already on that ones I Triple E models been around for quite a long time and it\u0027s been developed independently with some awareness of this but they want to have their own I think they have their own configuration model already for those devices I think they\u0027re trying to provide a complete solution that map\u0027s quite close to the a 2.1 q draft so they are more constrained I think in terms of how they implement it and although I would have liked to see them reusing like the sub interface constructs and things that doesn\u0027t doesn\u0027t actually necessarily work with with their model or with their or the devices that implement the dhawan q model so in not this draft the next one I talked about I\u0027ve given examples of how to use sub interfaces with the LTL TPM model and that allows you to do transparent bridging as well maybe not quite the same so flexibility in terms of VLAN awareness but that might be another option I see somebody\u0027s posted a draft today about and transparent forwarding or something again I don\u0027t think is tied into this model but potentially should be there will be possibly issues with it with I Triple E got one Q working group in terms of ITF standardizing that they\u0027ll say that sort of stepping on their toes I suspect so I think it\u0027s a bit tricky in terms of ownership of concepts and this but my concern is that somebody who just wants to implement something and take this my thing that this yang is just a pile of crap so my solution for that that case was to write a simple module myself instead but that\u0027s not of course the solution so yeah so I don\u0027t have an answer that I don\u0027t I suspect you can\u0027t standardize that anywhere that\u0027s the problem I don\u0027t think that I Triple E would take it I don\u0027t think ITF would take it because of the conflicts that rippling hi scott mansfield ericsson also a frequent attendee of I Triple E as well as IETF and other things so this issue of yang coordinate is something that the ietf that the I Triple E has been trying to take very seriously for the last year or so and the I Triple E in the itu-t have been coordinating on work to ensure that the I to use performance monitoring aspects that the they\u0027re creating the yang model on that for Ethernet and it needs to work with the dot1q and the CFM modules that the I Triple E is creating okay that\u0027s my preface the to back up your point about dot1q the dot1q document is "
  },
  {
    "startTime": "00:15:10",
    "text": "passed whatever the magic process is in the I Triple E to become an I Triple E standard and so that that draft and all the associated modules associated with it are what you got what you got right now and that\u0027s going to be the standard there is upwards of eight or nine other modules being done in the I Triple E that also have to work in augment the work that\u0027s that happens in dot1q so it\u0027s a it\u0027s a pain that people in the I Triple E are feeling as well so having said all of that I wanted to point out that there are opportunities for collaboration if people want to as individuals there is a meeting of a yang group in the I Triple E the last Wednesday of every month there is the last the third Monday of every month there\u0027s an ITU coordination meeting for yang so if there are if\u0027 people that are interested if there are if there\u0027s work that we can do the I Triple E does use the yang catalog and it stores its drafts there and if you put comments on the drafts they will be considered when you look at the yang that\u0027s that\u0027s in the yang catalog so there are ways to collaborate and ways to get comment back in even if you\u0027re not an I Triple E member so I\u0027ll leave it there if you want to talk about that there\u0027s lots of coordination opportunities thanks Scott what do you think about a lot of specific suggestion composing a liaison on the topic exactly I think I think liaisons are helpful because it didn\u0027t it\u0027s an official statement from the working group to another another group but I it\u0027s helpful but what I think is more helpful is if individuals do this collaboration that we have a couple times a months and really become part of the process because as we\u0027ve seen as the industry changes and standardization changes throwing liaisons of one another is not the way to get progress to happen we need to have people working in both organizations following their relative organizational paths and processes to get change to happen so unfortunately I think you\u0027re right we missed the boat on helping to restructure dot1q but there\u0027s plenty of opportunity to work with broadband form math ITU I Triple E in Yang and making sure all the Yang is happy when you put it in a pot and run peeing on it so I mean I think actually there\u0027s a fundamental issue here that there\u0027s almost two different configuration models that involved in the industry there\u0027s one there\u0027s I Triple E Don Q based and there\u0027s one that\u0027s IETF based I think and those two things are developing in parallel so there\u0027s going to be issue with features like CFM that bling long sigh triply campin and and actually fit into that "
  },
  {
    "startTime": "00:18:10",
    "text": "model but say not to work with seven phases so so I don\u0027t know how your this is very important to do sure at that point as well it is very important to understand that the CFM module that\u0027s being written in the I Triple E at this point is being written so that it can work without being tied to a dot 1q bridge okay it\u0027s the same for the work that the ITU is doing on performance monitoring it doesn\u0027t have to work with a dot1q bridge it could be something from the broadband forum it could be something from some other groups at once so it\u0027s important to modularize these things and unfortunately dot1q became a little too monolithic from the way that it was put together but that\u0027s not to say that we can\u0027t you change it moving forward so that\u0027s why talking now would be good this is as much for the chairs as the room do you think this issue rises to the level where it\u0027s worth trying to coordinate a discussion at the next meeting given that the IETF and I Triple E are meeting back-to-back well they\u0027re already well my opinion sorry Scott Mansfield again my opinion is that since there already is a standing basically a standing group that tries to coordinate I eat EF and I Triple E together anyway getting a smaller group than that that\u0027s that\u0027s focused on yang getting the something that\u0027s even focused not just specifically on yang but how data modeling is done in general because what happens when yang becomes the has-been and there\u0027s the next yang right so we need to have the opinion and the understanding of the community that we have objects that need to be managed and who creates the protocols to manage those objects are important as well so having that conversation be good I got lost their bite sorry are you saying that yes we should try so I\u0027m saying yes you should I think since what I said was yes we should okay focus on the goal now the goal focus on the goal should we do that in the context of this other meeting that you\u0027ve talked about well that\u0027s a design loudly okay then let me start again and I\u0027ll try to get to the end without distraction right the there we have a group my suggestion is getting a subset of that group to work on that that are interested in yang to work on the yang issue yes okay we\u0027d love to work with you offline to try to bring that thank you we\u0027ll talk offline and figure out if it\u0027s already happening then great yeah okay yeah I\u0027d like to also reiterate that we are using etherpad and we\u0027ve really helpful to get a few people in "
  },
  {
    "startTime": "00:21:10",
    "text": "there taking notes you don\u0027t have to take every sentence but just adding a sentence or two really helps the tools page and find it or off the agenda please please join and take notes okay so I think that closes out that draft and then the do I seem to not how funny clicker anymore yes the other draft don\u0027t quit date on is the southern face model so I\u0027ve added examples in here Felton L through sevens faces which actually has been very illustrative of some issues I added an example using a VPN young model and actually when you put that into instance data I noticed some cases where I think it\u0027s missing a container at one level which should be there and it doesn\u0027t look as neat as you\u0027d expect it to so I\u0027ll feed that back into the LVP n low moral authors and that might need an update to the yang model if they decide to change it it\u0027s not it\u0027s informative ala normative and now I still need to check with the dot on cue working group that they\u0027re happy with the change that I made previously so that needs to be resolved that they still happy the structure I hope they will be otherwise again this one things ready for working group last call I don\u0027t have John\u0027s hit go see him so any questions on this one a little while ago we did say that we would do a liaison at some point on these documents just to do an official notification that they were ready it looked like we\u0027re close or are we there what do you think I think with I think we probably there that we could do that so I Triple E in check that they\u0027re happy I don\u0027t care to draft a yep sighs yeah Chris I lost my network well the very beginning I saw pop-up three times everybody right so this is just an update to module tags that very small update was posted recently basically based on Andy\u0027s comments to the list and so that\u0027s what this slide will address so right there was a recommendation that we clean up the text on the the old version said that all module definitions "
  },
  {
    "startTime": "00:24:11",
    "text": "that include tags the tags would be standardized I\u0027m not sure if he meant the subtlety that I took from that but I clarified and said all standardized module definitions are standardizing tags I mean that\u0027s kind of like the mechanism by which you standardized a tag is through like an RFC publication and so I didn\u0027t the another suggestion was well there was a recommendation to vendors to put an org name or something that would probably keep collisions from happening like example.com so I took that in I didn\u0027t adopt the extension and he had said he wanted he thought it should be machine readable but it adds a lot of complexity that I don\u0027t think is really required that the right now.we we specify what tags should go when a designer wants tags added to a module they put it in the description text that\u0027s really a directive towards the implementer all right it\u0027s not it\u0027s not something that parses it it\u0027s not something that goes and gets parsed and then Auto generates the code to implement a model right I mean there\u0027s actually some human being who actually writes the code and you know this is so adding the complexity of having you know pi yang and all these various things have to support this extension I don\u0027t think it\u0027s that worthwhile but that was it from the comments I think oh there was one other so there\u0027s two other issues one is a small one which I guess we could go either way on right now it\u0027s a list at the root and I think Andy said it was we don\u0027t want to do that which should be a container at the root with a list inside of it I I could go either way on that dunker really care the other one what the Rob and I were talking about is the solution we have here we\u0027re doing something in this in this draft we\u0027re doing something that might come up later in other other people might need and that we\u0027re doing some concept of like a whiteout right so we\u0027re deleting something through configuration right so it would be the case here is if a vendor adds a tag says I support this feature and then as an operator I say no in fact you don\u0027t your your your implementation is buggy so I want to remove that tag right so the way we do that is we have a mask list but there\u0027s this is a kind of a general concept right where you you might have dynamic configuration that\u0027s added that as the final arbiter you want to remove and how do we do that you know we might want to think about that I don\u0027t think this should be the driver for that I think we have a fine solution here but it might be something to think about and if we do come up with some better solution before this gets published then we could incorporate it but again I don\u0027t think we should block on that right so I think we\u0027re probably ready for working the blast caller to "
  },
  {
    "startTime": "00:27:12",
    "text": "ask for it well I mean that\u0027s a question that we can ask the sense of the room who here is read the document either in its present form or in a previous draft it\u0027s a healthy set of the room um do people think this is ready for working group last call we can take a home on that I can\u0027t really hear see hands we\u0027re not counting okay we can do hands too so who in the room believes that this document is ready for last call yeah that\u0027s a significant fraction of the people who\u0027ve read it is there anybody who thinks it\u0027s unready okay we\u0027ll take that to the list great thanks okay Ken Watson Jennifer networks presenting yang data extensions this is presented last time by Andy we actually haven\u0027t made much progress on the draft but to recap RFC 80/40 defines yang data in the IETF rest cough module it was never intended at that time to be used outside of that draft it\u0027s really just defining protocol operations and errors for rest off hence it\u0027s neither an ideal definition or having an ideal location like it being inside the restaurant draft it\u0027s not what we want to say expect it if you know from other module designers the draft defines the current draft defines two extensions there\u0027s the Aang data and an augment yang data next slide talks about both yang data is intended to be a better definition it\u0027s slightly more tightly defined than the version that\u0027s in 80/40 it\u0027s also a better normative reference and import targets so if the you know you\u0027ll be importing IETF yang data instead of IETF restaurants which is nicer for drafts like zero touched and instance data and subscribe notifications all that are currently wanting to use yang data two of them are currently pointing at this draft and I think subscribe notifications is still putting it RFC 80/40 "
  },
  {
    "startTime": "00:30:12",
    "text": "notice I say here is nicer for zero touch it used to be that it was needed for zero touch if some of you may recall there was a discussion regarding a top-level choice over two containers and whether or not that was actually compatible with the definition that was in RFC 80/40 after some discussions with my co-authors who are also my co-authors of RFC 1840 if necessary we could clarify the definition that\u0027s in RFC 80/40 to make it usable by zero-touch so it\u0027s no longer we don\u0027t need this draft any longer but would it be it\u0027d be nice for the reason just mentioned also there\u0027s yang data sorry argument yang data which is actually needed for the notification messages draft which is in the net Kampf working group and also it\u0027s needed for an effort that I\u0027m aware of Joe Clark is working on that augments instance data and so he also wanted or has posted to list that he\u0027s wanting to have this Auden and yang data extension available so one of the extension statements it\u0027s nice to have the other ones must have or what we can debate what it means you must have it see there we go okay so last thing we actually thought we were done but then some working group members raised viability concerns and concluded that a proper definition should be part of a new version of yang I think the history of the original yang data that was even in rest conf a lot of I recall you had a lot of concerns about that definition and he raised some of those concerns with this effort Jurgens also posted some serious concerns about whether or not we should be doing this and/or waiting for a next version of yang Andy has I obviously he\u0027s a co he\u0027s a co-author on this draft but there\u0027s an aspect of this draft that he\u0027s uncomfortable with which I do have a last slide to touch on if necessary and then I think you\u0027re gonna I saw Martin and I are supporting the straps um going forward as this go ahead I think the fundamental problem is really an extension is defined in RFC 7950 as something that attaches Nanyang semantics to two statements whereas here we are we are changing youngsil inside this yang data the semantics of yang statements is different so I think this violates this principle and there are I guess two problems to this I understand it\u0027s really something that\u0027s needed and it\u0027s very convenient you can define some some scheme of independent of encoding and so on but on the other end if we do this I\u0027m of "
  },
  {
    "startTime": "00:33:14",
    "text": "course if you or mat you know or young experts use this I\u0027m sure they will know what they are doing so it will be okay but this way we propose it as as a standard as a normal way of using language which it isn\u0027t and by the way it OSHA also shows vendors or other people the way how to redefine yang so I will just put something at some extension at the top and then I can use a different different syntax for regular expressions let\u0027s say and things like this so I I believe this is really slippery slippery slope so if we want to use it internally then let\u0027s use this this rest conf thing and just live with the limitations it has because I don\u0027t think this is so good so just if I can be clear your your concerns are equally valid against RFC 80/40 right I mean your your also those were your concerns before also before right yeah but in in rest confine rc8 in 80/40 it\u0027s just some write some rational way which is not and by itself it\u0027s not the official standard the official standard a rest has come say so this may be officially official izing these things that are really not much twice to do a lot of Asian why do you say it\u0027s not official because it\u0027s in a standard yang model it could be included it\u0027s an extension it would be it\u0027s it\u0027s just as usable there as it is in an example if you before this work start if you asked this working group who knows about something that\u0027s called yang data expansion I would say maybe 5% of people would would admit they they knew it so it\u0027s really something that it can be used it can be useful but I wouldn\u0027t recommend to give it to people as a standard to for the data modeling because it just really finds quite important things in in the yang that like the XPath context and and so on and so it really undermines the value of yang as a standard and I think it was in ideas 87 that I proposed to change the definition of en to remove the net from specific parts and so on and to enable such uses as we now have but this didn\u0027t happen and I don\u0027t know if I think it\u0027s not the right way to do it this favor extensions so your concern is "
  },
  {
    "startTime": "00:36:18",
    "text": "the pollution of what it means to define an extension it\u0027s not so much this extension it\u0027s just what is the nature of exemptions in general yes and that being the case there wouldn\u0027t is it you think there\u0027s a possibility that there could be an applicability statement or something like this inside this draft that would sort of I mean I don\u0027t know if it\u0027s the right play you think I\u0027d ability statement would really be about yang data not so much the use of the extension and what if it is proposed standard I would expect can be offered to people whose okay so perfect so that is in fact the concern I\u0027m a little lost a lotta spoink is is it that you don\u0027t like yay the data extension or you don\u0027t like extensions I don\u0027t like an extensions that change young semantics so that changed the outcome of what you think that the schema is and what the semantic constraints are and so on so we already had several discussions like this one of them was this syntax for for patterns I don\u0027t know there were other points like this and so far my understanding was that really you can use it as in an ACM for example there\u0027s an extension that that attaches some some authorization related semantics to to yang statements which is okay or for relational has nothing to do at the end so that\u0027s fine but as soon as we start changing what\u0027s written in RFC 7950 then it\u0027s it\u0027s really a problem since we have what since the base extension that we\u0027re talking about that I think you\u0027re really talking against is already in an RFC maybe what you really want to do is put out a draft that says this is the right way to use extensions and in there capture what you\u0027re talking about and we can we can as a group agree with you or disagree with you and then follow that course you know I sort of feel like the ship has sailed on this one because it\u0027s it\u0027s already done and it\u0027s just whether or not to be publishing them it\u0027s not only done because now you have this young data augment thing that was not in in in a second which is another so people might want to add other things to this and it will just become a new new yang that defines using extensions and that\u0027s it\u0027s really impossible in my just undermines the value of yang as a standard and people outside this working group can be really confused by this and they can misuse it in possible racism I don\u0027t like it really okay I\u0027m sir question rubble since is a question for later on shades is if this was done in yang one dr. yang no 200 "
  },
  {
    "startTime": "00:39:19",
    "text": "with that would you be any happier with that or do you still think that basic premise what\u0027s being done here is not good yes I would be happy and this is actually what I proposed in Berlin a couple of years ago and so it means what we could do is to really remove the net comfort specific part to make to make basically yang just limited to defining the schema and things like what we have in our system to 950 like different data stores and xml encoding which is the only encoding actually officially find at the time for for en so i think this could be done really I mean I knew a new specification for en could be really slim not much text so it would mean in my view remove some text and then write other specifications for like using in for format come for things like this right and just clarify what I was saying I think that if a new version of yang were to come out it might find this statement yang data is a top-level statement but without the use of the extension statement it would just be yourself a top-level statement so in that sense it wouldn\u0027t be polluting what it means to have an extension statement maybe that wasn\u0027t a misunderstanding I don\u0027t know Rob did you mean to to have something like yang data in in the yang one but to know my idea was just to use yang just for anything openly for for that data store content without any rapper useful for for any purpose like I know what Robles and so basically saying to make yang more generic more gently used I think it would be to use yang to define the data model without any notion of where that data models being used if its configuration or state or file or it\u0027s just the model okay so great conversation which leads us right into how should we proceed as a working group we have three options in front of us I think the first option is to stick with the current scope of defining both the yang data and the augment yang data the second option is to only define augment yang data remember there was the nice to have and must have so this would actually still provide for those other drafts that wanted to use or need to use augment yang data or we could unadopted this draft which would mean that those other drafts that are currently referring to this draft would have to then point to RFC 80/40 and for those "
  },
  {
    "startTime": "00:42:21",
    "text": "drafts that want to use augment gang data where you just kick the can down the road and they need to revisit this idea later so we actually kind of need to get a sense from the room at this time maybe the chairs can help with this Rob did you want to say something before we got the preference we better ask the room then I get chance to do that anyway so okay so to be clear on option two you\u0027re not getting rid of yang data you would just use the definition in RFC 80/40 correct yeah I what it means it would not be defined in this draft is only the ugh me right so the difference between one and two is whether it becomes sort of a standalone first-order definition as opposed to something buried in another document yes okay I shall we go pull yeah preferences one two or three so let\u0027s start with why I\u0027d say that I would call that a few and I have Martin also supports one okay it I see that as a few do you wanna make comment before I get it - I would kill Clark Cisco I would prefer one but I could also live with two I I can what you\u0027re saying and I like your idea that the yang next I want an augment yang data or I want some way to you I want some way to define a thing something to represent a thing that isn\u0027t necessarily implemented on a in a datastore and then I want to be able to augment that I don\u0027t think any of the other drafts what I\u0027m working on is currently internal I don\u0027t think any of the other graphs need that requirement but for me I don\u0027t mind referencing 80/40 and this so I\u0027m kind of like one or two either way would satisfy me okay so - if you\u0027re interested if you\u0027re you want to pursue two hands that\u0027s no one know joe said he prefers one but could accept two he didn\u0027t raise his hand are you checking the drivers alright three I would say is approximately the same as one although a little less Jurgen is online and oh and Jurgen in fact in jabber says number three so we\u0027re we\u0027re actually pretty split on this you know we usually don\u0027t "
  },
  {
    "startTime": "00:45:25",
    "text": "unadopted we do a working group last call on one of the comments and the last call is no way and we hit reset you know so it\u0027s not like just because we adopt that it\u0027s it\u0027s set in stone Robert in Cisco so one can raise depending on our they were going to discuss yang next at all not today but we discuss it on Friday may be the outcome of that discussion might drive into whether we do this will not to delay this or there\u0027s another way to put that though also which is to ask like who cannot live with number one is is there anybody who like absolutely cannot live with number one okay so I mean that\u0027s a data point to yeah so um yeah I mean I think we\u0027re we we definitely have more interest in working on this than not but we don\u0027t actually have a we did we don\u0027t have a we don\u0027t have an exit strategy at the moment let\u0027s continue working on this document and see how it progresses give it given the last question by the way I wasn\u0027t gonna say that until you asked last question that was a good question asked vodka I can live with this draft and perhaps I may even be using it in in the future because it\u0027s really useful but I think right I mean that that\u0027s actually a fairly important distinction like I use lots of stuff that I don\u0027t like very much right that is in fact you know the nature of some IETF work right but it\u0027s really important if you can divine that like people have genuinely good reasons why they really don\u0027t want to do something like those are important super important to capture like if they exist so as as far as improving the document to getting to last called there I do have next slide covers one issue but in addition and that\u0027s the only one issue I\u0027m aware of but in addition to that I do recall a little while back and saying something about the wanting to clean up a little bit more the definitions in this document if we were to move forward with it so even though I\u0027m only gonna cover one issue there\u0027s actually two but before you go there at some point when we start talking about how we add features to the language it\u0027s gonna be worthwhile to consider that there\u0027s multiple ways to do it whether we do something like a 1.2 or we use this extensions and I actually accept "
  },
  {
    "startTime": "00:48:25",
    "text": "but I think a lot of this implication is that we\u0027re actually not using we\u0027re abusing the language a little bit but if that allows us to be a little more nimble you know that\u0027s not necessarily a bad thing and actually to the point about yang next you know but the potential discussion we may have on Friday or maybe even some today if we were to go that route I fear we\u0027re probably at least adding a year if not more time to until this would become RFC status which then would put a lot of drafts like zero touches and other ones I mentioned into miss rough state for for that amount of time so well I\u0027m sorry just one more to come if that were the case if we made that decision then as the author or the CEO touch draft I would immediately point it back to 80/40 just so I can get it out to her see so Rob Wilson so based on Ladas coming I would like to retract my option 3 and I know he\u0027s fortune one actually I think if he\u0027s saying that people were to use this it makes sense but and also to go to lose comment that maybe we should consider whether we refine how extension states allow to be used if the issue is it is one about how extension sounds to defy today and limiting the scope and we\u0027re finding that this is hampering us and making our life harder should we consider changing that I think we have an existence proof in 1840 that it\u0027s not hampering us but maybe should have been hampering us that maybe we\u0027re bypassing the rules already and maybe be better to document that you\u0027ll have to do that it\u0027s ok great so now that we\u0027ve I think our iterating towards option number one there a question with regards to the yang data definition and specifically if yang data can have the same name as he top-level node so is this legal or not you have module foo with container bar but also yang data containing container bar and so the options here are yes it\u0027s legal because only one bar can exist in any given context if you\u0027re talking to a server and you say get data then you\u0027re gonna get the bar that\u0027s the the first bar but if you\u0027re looking at an offline instance document that you know it\u0027s you\u0027re being told through context that\u0027s provided to you outside the document itself then it\u0027s understood that you\u0027re only receiving the second bar the game data bar that that be the no no because the instance document alone given that extra context may be ambiguous right so some people feel it may be and just be clear Andy is definitely in the know category on this on this one so probably it\u0027s long Jerry\u0027s about to say that but he\u0027s definitely thinking that need to have you know given an instance document he feels like you know knows I say the instance document alone with no context so he\u0027s thinking there\u0027s no extra context so in that case you don\u0027t actually know is it representing an instance of configuration or is it representing the yang data so and and "
  },
  {
    "startTime": "00:51:26",
    "text": "but the flip is that the the doubles argument is that well you would have some context to to make that not be an ambiguous case so go ahead well in generics I\u0027m sorry I didn\u0027t read the very last version as I understand it is possible to define multiple yang data extensions side by side in module yes so probably that\u0027s also possible conflict if you have multiple in each of these you have the same root element defined so for those we definitely have to clarify that there can be no name conflicts amongst all the young leaders let\u0027s go then all the way you know secure okay well anyway we didn\u0027t need to get a sense from the room on this one as well I think or or any more comments actually first all right so I think you can run this as a technical not a procedural thing okay you all right yes sir um so actually could I get a raise of hands for those who think that this should be allowed it\u0027s legal I and Martin I know Martin also feels like there should be allowed so a few and then for those who think it should not be allowed please raise your hand and also a few but more double probably I think so and I know sorry there\u0027s comment coming to microphone vodka understand way it is important to to say no here because of course it can break tools who just want to have one yang they turn out in in this top-level context but in fact if young data is used for defining an error message there is really no reason why the error message couldn\u0027t have borrow whatever so it\u0027s really some CLR that and I\u0027m afraid that we will need to come up with more such cos you know in order to make this thing work in it with so it\u0027s really complication and I think actually ami made that exact same point about tools and how we might have to go back and revisit some tools to ensure they don\u0027t break so so I think more people were favoring no and I know that Martin and I had previously an author\u0027s meeting said that we would you know capitulate and you know if it\u0027s okay we\u0027re not gonna we\u0027re okay we can live with no is one trying to say so assuming that we\u0027re moving towards no is there anyone in the room that cannot live with no like they actually feel like we we must or we really should support this and one coming from what so like I asked terrific clarification question so this is for Y and theta for normal schema "
  },
  {
    "startTime": "00:54:27",
    "text": "data if they have a module say why and we have a same bar with this container that would be okay right so this is in the context of a young data but I\u0027m asking in normal non young data it\u0027s just a skimmer yeah skimmer so if I have a one module foo and another module bar with the same container oh those are viewing different namespaces so that\u0027d be fine so this is not affecting though the only is only ones being when the two things are being defined in the same module or the same namespace because the same thing same module you imported from another module you gotten another namespace oh you\u0027re talking about the case where you\u0027re importing yeah module like importing a sub module so yeah well okay the resolution of the import of the fact that you\u0027re importing some sub modules doesn\u0027t actually change the nature the other model itself so if we go with no then it\u0027s going to be illegal in that case that\u0027s illegal right so let\u0027s make sure this is illegal if we\u0027re choosing no and we\u0027re saying that this should not be legal and if you\u0027re saying that this whitey yang data was actually brought into this module through an import of a sub-module like an include I shouldn\u0027t say important and include that then that would also not be legal because when you\u0027re using includes it\u0027s just a way of factoring your yang it doesn\u0027t actually change the nature of namespaces so you may encode won\u0027t be legal either for yam data but for normal schema node so participate we have a normal module fool and have you call from another module bar and put the container there so they have a name space bar column a container box so that what you\u0027re using the word import and you import you\u0027re actually defining in your namespace right so there\u0027s no conflict yes this mix or yeah okay okay okay all right so I think the resolution here is no we\u0027re not going to allow this to be a legal thing to do all right and with that I\u0027m done thank you very much so with that we\u0027re going to move into from the working group documents solution documents into the design team that we talked about at the last meeting that\u0027s looking at versioning every we want to call it right so I\u0027m going to give an update and what the yang regime design team has been doing for a few months and then I\u0027m going to talk through the required draft so I hopefully have some helpful we interesting discussion on that and what we do next to have a go forward so a "
  },
  {
    "startTime": "00:57:30",
    "text": "very quick update the design team\u0027s been doing it was formed after ITF 101 took a while to get going but once you get going we had weekly meetings the last couple of months the focus being is very very specifically on the problem statement and the requirements themselves rather than any solutions or solution discussions there has been some but that\u0027s what focus has been we have produced a requirements draft 0-0 draft and that\u0027s what I\u0027ll go over next I know the requirements in detail and there\u0027ll be some discussion on what the next steps could or should be and I\u0027ll cover that at the end there may be a slot to discuss the clark law draft which is one of the potential solutions here at this time so we\u0027ll see how time goes so requires draft is fairly basic we have a short summary of the problem and we\u0027ve included the in the background information the examples that were from the clock our draft they\u0027ve been refined somewhat but they\u0027re fundamentally sorta same some examples in there extend it a bit so they sort of set a reasonable background in fairly concrete way of what the issues are we think what the requirements and sort of problem statement text and I\u0027ll go over that that problem statement here or summary of it and then the requirements and then afterwards I\u0027m going to be asking for of which we discuss working group adoption not necessary as a way to take to a wait RFC but to show the working group agrees broadly what the requirements are and we head in the right direction so problem statement summary and Soyoung versioning in terms what we want to do young obviously has had quite a rigid way in terms of how you do upgrades in the past that they have to always be fully backwards compatible and effectively in the market we found some issues with that and that\u0027s what we\u0027re trying to address and change here rather than requiring that your young models are perfect or perfection on day one we want to allow them to evolve over time to the right solution the current mechanism is that once you\u0027ve published your young model you can make no backwards incompatible no non backwards capacitor changes too much also you are allowed to add new leaves you\u0027re now to extend the value space that\u0027s something that you can\u0027t either reduce the value space or change the type or delete a data node of X and the think that this has this sort of in flexibility has made people try was too hard to get young models to be perfect and appointment published them so it\u0027s taken a long time I think for ITF to publish young models because people think well once it\u0027s out there it\u0027s hard for me to change and the cost of doing that change is quite high on to the second point if you do have non backwards compatible changes today then you are forced into one of two routes "
  },
  {
    "startTime": "01:00:30",
    "text": "either you have to introduce new data and the data nodes represent those non box compatible changes or you have to have a new module name and both of those have a hugely high impact in implementations so if you have to be forced to a new path than every client that was using that existing path is now forced to use a new path an impact there and if you change the module name space impact is even worse so everyone that\u0027s interacting all the clients interacting that much obviously now have to interact the new module name and all the imports that are important this will also need to be updated to import that you what your name so if for example you wanted to make an on backwards capacitor change to ITF interfaces perhaps when the miner leaves for example if you are forced to change it to ITF interfaces to then effectively you\u0027re going to fragment the include or import statements from all those other modules so so that\u0027s not really necessary a viable solution there\u0027s some other related issues as well that aren\u0027t quite so so directly tied to back-fat abilities were related to this whole thing about lifecycle of models and one of the means that today the way that yang defines States deprecated it gives the server the choice as to whether or not it implements this note and that means that a client that\u0027s interacting with one of those servers if they see a node that\u0027s not status deprecated they do not know whether they with the service going to implement that or not the only way that can find out is by try to write to it and see if it\u0027s there or read from its it\u0027s there so I think that is too ambiguous in terms of that behavior and we need to try and tidy that up in one way or another another related thing is that if you look at how deprecation is handled in progra languages then api is there is often you have a statement saying what the alternative is so this says you know this api is going away they\u0027ll say you could use this other API instead or give an explanation as to why it\u0027s go away so currently yang doesn\u0027t have that the state of statement just says you know what the current status is and although you have the option or maybe of updating the description statement associated with the data node a better solution probably is to have a description state or equivalent tied in with that status so you can actually say it\u0027s been deprecated for this reason and this is what the alternative is this is the way forward and that\u0027s all about almost guess or for guidance to people who are using models and that being the press it being deprecated and there have been changed over time and then the final point in terms of problem statement is that some systems where we are sort of generating young models they they simply can\u0027t follow the Strich we have it\u0027s just not pragmatic that with the models have been developed in ITF then you have this option and almost "
  },
  {
    "startTime": "01:03:31",
    "text": "science is heading for that wolf of creating a close to perfect model from day one and that you\u0027d be very strict and say okay we won\u0027t allow any non backwards compatible changes the cost of that\u0027s too high but when it comes to the vendors and things and these yeah models are often being generated from other internal data models and those internal data models may well be quite closely aligned to implementation or the hardware that\u0027s the thing then you have the you have issues that as things changed evolve over time sometimes just not pragmatic to never make any non backwards compatible changes at the cost of maintaining that box compatibility is too high relative to the impact it will be on on clients and legs so as it stands today then certainly the case that quite lots of vendors are making non backwards compatible changes in their yang models as they go forward and so I think we should try to look for a solution that standardized and explains manages what people are actually doing rather than pretending that nobody should do it so any comments or questions on the problem statement before I move on to the requirements so the requirements themselves there\u0027s five slides for these I think about 50 requires in total my intention here I\u0027ve grouped them by the sect intersection and that they come under I will go re through each the requirements to summarize it and then if people have got any comments or questions on those then please come up as I go through these so the first requirement necklace is required to update a module in a non backwards compatible way without forcing all modules with import dependencies on the updated module from being updated at the same time and so effectively what you\u0027re saying is that when you want to update a module in on/back was collateral way you need have an easier mechanism that allows other people that are import not to have to change their import statements is too expensive to say I\u0027ve updated ITIF interfaces and hence you\u0027ll have to go and update every other model under 50 plus of them they\u0027re importing ITF interfaces and needs to be a way that by and large those import states can stay the same unless they\u0027re affected the second requirement is a mechanism is required to update a module in a non backwards compatible way without forcing all clients and servers to access data nodes in the model on new paths or a new module namespace specifically if a particular data node is updated and on backwards compatible way then it may be desirable for it to be available on the same path in the same module namespace so so this is the same closely related to one that one is saying from a client perspective if you are interacting with one these modules that you if you make an on back with a class will change it\u0027s not good enough "
  },
  {
    "startTime": "01:06:31",
    "text": "to say oh well the answer is to use a new module name or to use a more new module namespace or to say you have to add a new data node to represent this and Mark the previous one is deprecated that is too expensive and the specific comment here is that if there was say small subset of module maybe was under a feature statement it was something that was added in later on in the process and it didn\u0027t really get enough review or coverage and people weren\u0027t using it and then at the point that they come to use it they fail actually this is broken I need to fix this and the only way to fix that is either by saying oh I\u0027ve got to read the whole module so all the bits of the module that are fine are being used you force a namespace change or module name on that or your force effectively to continue supporting this deprecated part and at the same time support a new revision of a fix-up model so we\u0027re suggesting that there needs to be a way to handle that the third requirement that\u0027s related to this is that a refined form of yang\u0027s import statements must be provided that is more restrictive than an import any revision I just import and less restrictive than import a specific revision input by revision once number collateral changes to modules are allowed the refined import statement is needed to express the correct dependency between modules so so what yang has today\u0027s you can either import a module and not specify a revision in which case is ambiguous as to what revision you get an implementation is only allowed to implement one revision but it can import multiple ones and and so that allows the modules to float and be modified and updated okay but it doesn\u0027t give you any control over that if you do any yang versioning the other side the other end of the spectrum is that yang wanna one they allow on import with a specific revision but this has problems too so you now constrain the problem space to say I want to import just that one particular revision but if somebody comes along and makes a minor change to that or bug fix to that imported module suddenly your import dependencies broken so and and and that broken import dependency would effectively propagate through all the other modules so I think the import by revision doesn\u0027t really necessarily work that well I think it is too limited the cases where you can use it in a sensible way I think is very small maybe some types and things so what\u0027s being proposed here in the requirements is saying there needs to be something that\u0027s between those two extremes where you can say I want to import\u0027 a set of revisions with this major version number of these sets of major version numbers or any minor version number this may fix major and any - oh there needs to be enough flexibility that you can tailor what you can import and what you can\u0027t import so does it "
  },
  {
    "startTime": "01:09:35",
    "text": "have any questions or coins on these requirements before I move to the side yeah Chris yeah Chris ups italicum so that I\u0027ve been a proponent in the past of just using the namespace name change so it looks like two of these requirements are specifically addressed to that I\u0027m curious I mean so these are the requirements obviously there is some kind of justification for them right like it\u0027s too hard or because I\u0027m thinking specifically about 1.1 right I mean why wouldn\u0027t you want to go back and at least look at your I mean if you\u0027re importing a model and you have now a backwards incompatible change right why is it not reasonable to say I need to go and change one line in my model to say I\u0027ve looked at this and I know it\u0027s still compatible that doesn\u0027t seem like too much work it actually seems like a safety valve then number one point two though isn\u0027t that what prefixes ever I understand like you don\u0027t want to create a ton of work right where there doesn\u0027t need to be any right like if I\u0027m if I\u0027m using a model and in a client I\u0027m using a model and nothing changed that I care about right then I don\u0027t really want to have to do much work but in that case you know all my node all my paths and software using prefixes again it should just be a one line change so I you know now we\u0027re talking about changing one line is too much work I think it depends on so I think depends on how well people are play to the code to the clients and whether people are using fixed paths or whether they are their decent level of abstraction there from our client perspective do you think anybody\u0027s actually doing namespace things and all their node specifications I I don\u0027t know well okay but that we shouldn\u0027t we shouldn\u0027t optimize her dumb design right I mean but even even without that even we are is thing the client you still have the import statement issue as soon as you change the name of the module you force all those imports to change yeah because you have to go back and make sure that they\u0027re actually compatible still right if it\u0027s only one line that\u0027s not too much to ask I think to say I\u0027ve looked at this thing it\u0027s still compatible I\u0027ll change this line I\u0027m done but it\u0027s not that one module it\u0027s all modules and then that would potentially propagate through so but you don\u0027t want any of those modules to automatically use the new model until you\u0027ve actually looked at it right I mean that\u0027s working you have to do when you make a backward in battle change if you want to use the new model right I mean you don\u0027t have to use the new model you could be using the old battle still and then everything keeps working it\u0027s only when you want to update to the new model that the namespace changes and then you have to go change your one line in your model so I\u0027m gonna use the new one so it depends on the scope of what that non-black was a capacitor changes so if it was right if interfaces example you were completely restructuring it then I think that sort of thing you say well it\u0027s fair enough to define an ITF "
  },
  {
    "startTime": "01:12:35",
    "text": "interfaces - that\u0027s probably the right answer but if you were changing something that is not gonna break all those imports if it\u0027s like a leaf in the model list that you\u0027re changing you know backwards compatible way then it seems quite a lot of work to then say I want to change this one leaf I made it I made a mistake here out of a buck and I want to change it or to change its type and then you\u0027re forced effectively everyone has to update their imports to do that to pick up that latest leaf and they\u0027re not going to be impacted so I think this stills meant to be some common sense in terms of what numbers classical changes are meant to be I don\u0027t think we\u0027re trying to say there should be free rein and anyone do anything I don\u0027t think that\u0027s the aim here it\u0027s trying to be pragmatic okay I mean yeah I do see I take your point that there might be small and compatible changes but I they also might not be that important right so I don\u0027t know okay so Tim Karen okay just to fall on but isn\u0027t what you\u0027re saying in 1.2 just what you said you\u0027re trying to get away from what you\u0027re saying is in 1.2 I have it a leaf node call it foo yeah right that I change in a non backward compatible way and the client still will reference foo right even though he doesn\u0027t know it\u0027s not backward compatible or potentially so so the proposal is effectively view some Stu versioning semantic versioning or equivalent scheme here is that you would then have a change to the version associated the files the old one just like this that\u0027s the module you\u0027re getting into a solution I think if you another way to answer that same question is you have a requirement later to cover what he\u0027s talking about to ensure that you cover the back Pat ability that\u0027s true but but I\u0027m talking just about the requirement right there\u0027s more requirements I understand I read them all okay okay and so Mike and this is the one requirement that I had a concern about was was because I looked at it from the standpoint of the client having something called foo right that was not backward-compatible that if I read this requirement that said well I\u0027m required to not give you any indication that this is not backward that this is as a client I don\u0027t know that this is not backward-compatible that data node that leaf node foo that I\u0027m using right so that\u0027s not the intention here and it\u0027s not the intention to be saying obviously in terms of the requirement sees the exposition is the clients can find out there\u0027s something\u0027s changing your numbers compatible way I read requirement this set of three to cover the exact concern you have so whether so you got to put it three of them together "
  },
  {
    "startTime": "01:15:35",
    "text": "so if requirement three doesn\u0027t cover your case you should fix the language on it 1.33 we haven\u0027t even gotten taller okay all right so I\u0027ll wait for three and I\u0027ll put it in that context yes this was the only requirement that I had the biggest concern okay you tell who\u0027s it from away I feeling that too here you are consider the case where you are greatest server to a new version which is not backward-compatible you want the client to run smoothly in backward compatible way what happens the other way around you are create a client in you know using a young model which is not backward-compatible and you don\u0027t upgrade a server are you consider in this case and consider for example the situation where you\u0027re a very archaic controller which is controlling multiple domains and you have a new features and the subs a subset of this domain suppose a new feature and knows a subset of both domains do not and do not agree if you consider also this use case so I think the versioning is happening between a client-server interaction we are certainly considering the case that you want to do some sort of control and maybe version selection between those so in the case of our controller we\u0027re talking to servers where some of them support some functionality and some some don\u0027t I would expect there to be some negotiation on each of those or so you\u0027re expecting some version negotiation between the client the server to figured out how to talk to each other well version selection again is going to the solutions but there is a qualms for box compatibility to sports existing clients in the box compatible way thing about what about the existing servers it\u0027s the case where you are great a client and you don\u0027t agree the server see if you had a client you can\u0027t have a client talking a new a young model to serve took an older one I think I wouldn\u0027t work I think we\u0027ve got you can detect that case because you know what you can know what versions that the server\u0027s using through yang library okay you tell you could detect that today ok what about if you if you have a new young mother you don\u0027t use a new leaf because you know the server doesn\u0027t support in your lips see you also you can\u0027t write to lift that the server doesn\u0027t understand you can never know yes true true true but you can if you if they\u0027re great is us you are the new nodes a new leaf and leaf is associated with for example with a feature then a young model you can agree the server the client without a grade in the server and the server will be you don\u0027t have the feature something like that so I say that gonna you can if you have the new features to your young model you would have the optional feature yeah as soon as you talk with an older server that doesn\u0027t support the feature you will never use that that leaf you use only the subset of the two-year models which is common but now we with because of the number of compatible changes you don\u0027t have any longer the common subset I think you "
  },
  {
    "startTime": "01:18:37",
    "text": "still end up I think something you\u0027re maccalister\u0027s do the same thing so one of the in terms of requirements the requirement is we are condoms the later accounts are should we\u0027re taking away obviously yang\u0027s for compatibility effects you\u0027ve always upgrade things and as part of that we require to say what are we going to offer stet the way to support existing clients yeah you go Bruce can i ha way I support the issue that it\u0027ll just raise so if the client walks a was 20 sewers and works in exact same way so now if you have like a model which is not that good compatible right some of them do things differently from others and there is no common ground okay on which you can scale down and come up with a common solution right so it\u0027s a big issue so again I think actually that question might be worth looking at the end of the requirements because again there is a qualm to address that a concern well as Daniel Erickson I think that\u0027s the case today as well because you can just obsolete or deprecated something tree it\u0027s gone and then your client suddenly finds that oh I thought this was compatible but it\u0027s not there anymore also for the other way around for if you need a feature you need to check the provision of the model on the yank server maybe that I have an old old module on the yank server that doesn\u0027t have my feature yet because it\u0027s an old module so I think anyway a client has to check the revision of all modules before really working and that at least for our systems that\u0027s the case today so that\u0027s not changed or updated by this recommendation right second move on to the next set of accounts so identifying you want to warn people that there\u0027s actually five sets there are five sets that\u0027s true okay this is harder to read so readers of readers of modules and tools that use modules must be able to determine where the changes between two revisions of modules to do to backwards compatible on but compatible version change in addition it may be helpful to identify whether those changes represent bug fixes new features of both so it\u0027s saying that you have to have a way in this scheme of identifying that when a modules been updated it\u0027s been updated in a non backwards could pass away or a backwards compatible way and maybe maybe some indication as to what that scope of the changes so is a bug fix is it new functionality or is it major new functionality and then requirement to "
  },
  {
    "startTime": "01:21:40",
    "text": "point to a mechanism should be defined to determine whether data nays between two arbitrary yang module revisions have one not changed to change them backwards compatible way and three changing a numbers compatible way so where is requirement to that one is at a module level it\u0027s saying whether or not the whole module has been changed in the backwards compatible numbers collateral way 2.2 which is a huge rather than us is actually looking at and tracking backward compatibility on a per data node basis and this may be particularly important where you have where clients are using in subsets of modules rather than entire all the leaves in a module then they may be particularly interested whether the subset that they\u0027re using they can move between an older revision a new revision you know backwards compatible way and hence to be able to identify that on a per data node basis is potentially a better solution so widely by limit this of data nodes 1 and also other things are pcs replication etc is it by there as well they should probably be included schema nodes well you wanted the not risky nodes of the right answer as well I think it might be day - no I can\u0027t what the definition is but yes those but you\u0027re not trying to track the change of say a type statement itself you\u0027re to tie it tight to the actual thing that\u0027s instantiated in the model schema you know the questions on these or shall I move quickly on to try and get through all these requirements we can come back so requires three supporting existing clients so this is all about we\u0027ve had some discussion about in terms of how do you handle clients they\u0027re already talking to the server and so the solution must provide a mechanism to allow servers to support existing clients in a backwards compatible way so whatever solution to me these requires comes up with it has to have a way that you\u0027ve got an older client talking to the server that can continue to talk to that server or the least be a mechanism or a way how to support that and then related to that is 3.2 and the solution must provide a mechanism to allow service to simultaneously support clients using different revisions of modules a client choice of particular vision of one or more modules may restrict the particular vision of other modules like me that may be used in the same request or session so this requirement is saying that the any solution space needs to be have a way that clients can choose which module revisions or versions they\u0027re talking to and that doesn\u0027t but they don\u0027t have free rein they can\u0027t say I want to have maybe one version of the BGP module and "
  },
  {
    "startTime": "01:24:41",
    "text": "a completely different version of ITF interfaces module where there\u0027s dependencies between them this probably means that actually when you select one version or module or a set of modules that you you\u0027re selecting between a set of them and that affective constrains the space you active example this concrete example might be that you have a vendor that\u0027s producing particular software releases maybe they say well we support an order revision of our software and the later one or something similar something like that so that one\u0027s a lot suggesting any comments on these ones Robb Kent as a contributor yeah so when you say existing clients here do you mean clients too that are today clients using existing yang they stamp sort of version or do you mean like more forward-thinking that after semver whatever the solution is existing clients at that time and then you are moving to the next version so I think existing clients today so this kind of moves into what is the migration or a straight transition strategy okay Chris Hobbs Telecom so I think the this is this is a requirement that actually pops out because of you saying you need to be able to have multiple modules without different namespace names yes right okay just want to point that out you don\u0027t have this problem with you Chris what you\u0027re saying is a solution to this requirement that\u0027s well I\u0027m saying if you get rid of requirement one and you just keep the things the way they are I mean we\u0027re creating problems right that didn\u0027t exist before you can have multiple modules if they have different namespaces so so one solution to this whole problem is to do nothing and say that what yang does today is I don\u0027t think that that\u0027s not actually what I\u0027m advocating for but I\u0027m looking Chris if you have like a solution in mind that\u0027s that satisfies all the requirements except for like it changed it you change names and there\u0027s some interesting way to do it but you know that\u0027s worth talking about I\u0027m just I\u0027m making comments let\u0027s get to a good solution so the fourth set requirements is documenting data node life cycle so 4.1 on my velocity super smear for the 1a mechanism is required to allow a client to determine where the deprecated nodes are implemented by the server so this goes back to today that the deprecated statement doesn\u0027t mean that the device is necessarily implementing it and leaves it ambiguous so there needs to be some way that client lease find out whether or not those deprecated nodes will be implemented 4.2 if a data node is deprecated obsolete and it must be possible to document in the yang model what alternatives exist the reason for the status change or any other status related information so that goes back to the same comment I had early in the problem statement that when you do "
  },
  {
    "startTime": "01:27:41",
    "text": "deprecated something or you know you\u0027re about to then having additional information on having mechanism to provide information to readers and users of the modulus to why it\u0027s gone away and what the alternatives are is required 4.3 I think I don\u0027t have to scroll this text a mechanism is required to indicate the certain definitions in a yang module will become status obsolete in future revisions but definitions marked as such may still be something implemented by for around 24.3 yeah a mechanism is required to indicate there\u0027s certain definitions in a young module will become status obsolete in future revisions but definitions marked as such may still be implemented by a compliances this sounds like a strange one but effectively it means that if we if we don\u0027t change the definition of Yang\u0027s deprecated statements to mean it\u0027s still supported but will go away in the future we don\u0027t do that then instead we need to introduce some alternative mechanism to do the equivalent of of a deprecated that means it\u0027s supported today but it\u0027s going to go away in future ie the standard definition of deprecated you\u0027d see in like a programming language API and then four point four which is not even us life is wrapped is if multiple revisions of a yang module are published then the solution should allow for bug fixes to be made to know the revision of the module so the idea here is that if you have multiple release trains and you are updating modules on different release trains like vendor modules there needs to be a way of putting bug fixes and changes to those older release modules it\u0027s not sufficient just to say every change or bug fix has to go in to the latest revision that\u0027s not pragmatic lost my slides right and I\u0027ll move on to the requirements number five and these requires related to documentation and education so 5.1 says the solution must provide guidance to model authors and clients on how to use the yang versioning scheme so we obviously have to tell people how to use it what\u0027s the right mechanism 5.2 is the solution is required to describe how to transition from the existing yang wonder I wonder wonder scheme to the new scheme so obviously you got to describe how we migrated from where we are today and then 5.3 is the solution must just describe how the versioning scheme affects the interpretation of instance data and references to instance data for which the scheme definition must be "
  },
  {
    "startTime": "01:30:42",
    "text": "updated in a non backwards compatible way so this one is quite interesting and it says if for example you have some configuration on a device which you regard as instance data and you then update that device in a non backward compatible way what happens to that data what happens to the bits that are non box compatible or another case would be is Blaze\u0027s instance data document where that is defining some instance data how what happens is the modules that have been used to represent that data have changed in a non backwards could cut away so the solution needs to consider this and describe how is that supported and that finishes my requirements thing so the question is are there any questions on the requires there any questions that go back to these points that have earlier so I I don\u0027t know if I zoned out at the very beginning of this when you started didn\u0027t we actually talk about what problem we\u0027re trying to solve yes okay yeah because I mean that\u0027s what these are speaking to but so I mean I\u0027ve got a pretty good idea that I don\u0027t want to talk to solutions too early right but um you know that\u0027s I think the thing we\u0027re really trying to do is allow for I mean I remember you saying allow for changes quickly but I think a lot of what is going on here is to make it less painful for clients right so you want like if I can make this incompatible change but everybody\u0027s gonna keep running anyway because they don\u0027t hardly you that little thing over there all right you know and there\u0027s obvious like semantic versioning is a fit for all the requirements you\u0027ve put up there but really what we\u0027re thinking is is describing the things that changed having a sub may be an automatic way to do that right and linking alright and the major version number of the semantics is really just the linking right so I guess what I\u0027m saying is I don\u0027t I\u0027ve never liked the major version of the semantics I don\u0027t think we need it but we we might need a way to say this namespace the new version you know a pointer to it right and maybe as part of that metadata you include the changes right that you know anyway I don\u0027t want to jump too far in this lessons but well so because I like the way that it\u0027s backward compatible with things that don\u0027t you know it\u0027s like nothing has to change for this to keep working right and then things that do change can use the new stuff you\u0027re coming up with here yeah where is it if you if you require like a semantic version you know you know it\u0027s not as backward compatible but that\u0027s my main objection to that sort of solution okay so I think and after some hour discuss solutions we will invite people to if your alternative solutions then it\u0027s definite forum or juniper Networks so what makes me a little bit nervous when the mayonnaise is what exactly does backward-compatible mean and how do we define it because "
  },
  {
    "startTime": "01:33:43",
    "text": "obviously if something crashes you know it wasn\u0027t backwards compatible but if you already want to write something saying okay I need to decide is it not backwards compatible yes or no we had discussions before about which which statement was legal and whether we\u0027d accept it or not so how how would you kind of grasp this in in the requirements so or in other words as a requirement I would like to add here something to define what we consider to be backwards compatible that can be checked yeah you know it helps me as a coder I think it\u0027s fun that it\u0027s worth adding so the definition we\u0027re taking is the one that\u0027s in 7950 so they\u0027ve got a description of updating a module and the and the rules as to how you update a module are these the rules on what you have to do in a backward compatible way so any changes you make to a module outside what\u0027s allowed in rc7 950 by definition not backwards compatible change so I think we can understatement to the to the draft to clarify that yep thank you got a question Vladimir I hear the sense that making this for the notes level for me it feels like it\u0027s over engineering it and I can put it in the same category as introducing sub modules like when you introduce sub modules and people start using huge modules of multiple sub modules suddenly you have that problem that you need to introduce solution for node level compatibility so if we stay away of that I will be very okay so the just special for node level is not necessarily a version statement but because the ideals one of the ideal solutions here is to do this in an automated way to have tooling to be able to detect whether going from any given revision or module to any other revision is is backwards compatible or not and where where it is back where it\u0027s not and you can do 95% of that today so you can the rules are quite clear and you can pick up what\u0027s changed but what you can\u0027t detect automatically is if you change the semantics of a node in a description statement there\u0027s just no way that Orion can understand and read English or where it\u0027s written in and so the idea there is have some way of marking those changes to then allow this tooling to work and actually then say okay this part of the module is entirely backwards compatible these changes are not and you as a user of that module if you can refine and say I\u0027m gonna using this subset you could say well although the module might be an on back change I\u0027m not using it so I don\u0027t care can we get your name one more time for the minutes please "
  },
  {
    "startTime": "01:36:45",
    "text": "vladimir veselov thank you so requires draft next steps the so I think the question here really is is does the working group agree with these requirements so we\u0027ve had some feedback of on some of them there\u0027s not been a major objection so what the designs he would like is we\u0027d like for the requirements draft to be adopted by the working group and the aim here is not to say that we will necessarily take this all the way to our C status but it\u0027s to try and get it as a working group document that people can then comment on to broadly say that yes they think that these requirements are roughly the right scope and we\u0027re going in the right direction in terms of of the problem statement and then over time depending on what solution looks like whether these requirements might get folded into that or maybe it\u0027s not a solution drafts that working together maybe they\u0027d be a separate or the requester would be taken to our C I have to say I have a strong objection I mean it might be the only one but I have a strong objection to the requirement in one right because you\u0027re forcing a solution you\u0027re saying you requirement of this is that you have to be able to do this without changing the namespace and I\u0027m saying changing the namespace is one of the solutions that you can do everything else you want to do through a different mechanism but leave the change in the namespace so having that as a requirement is is removing all those solutions okay well Ashley angel Erickson I actually don\u0027t really agree with you because the reason we want to keep the name space and the name module name in this next requirement is that it is sometimes much more expensive to change the name and namespace to reflect compatibility than to deal with any problems that might be raised by the incompatible but changed incompatible but but still kept namespace you have to track down all the potential clients scripts whatever who have written it\u0027s impossible really to track them down so it\u0027s sometimes it\u0027s and and it\u0027s a rare in the rare case where you say that yes a backwards incompatible change is validated is reasonable and it should be a rare case it is much cheaper to keep this because once you start changing the namespace or the module name then that means that all your importers all your clients be that just may be a little script that some operator must be updated so that one line you mentioned one line update x I don\u0027t know many how many and tracking down all that all those one lines that\u0027s course gets very "
  },
  {
    "startTime": "01:39:45",
    "text": "very expensive even more expensive than some time taking the hit off a backward incompatible change right so what I mentioned this at the very end I wanted to give a solution right that this is what you could do with linking right you can have you can have a link between the two different names faces and you could have the clients automatically you know you can still have an automatic upgrade mechanism right where they run with the new module because they know they\u0027re compatible because they looked at the list of things that would make them incompatible right I mean it is literally just a way to leave backward compatibility right because we\u0027re talking about moving forward things would be designed with the solution but when you when you keep the namespace the same now you don\u0027t have the backward incompatible way to you know blow them away but then not saying I\u0027m not by the way I\u0027m not saying that like you know maybe I\u0027m wrong right I\u0027m just objecting to a requirement that removes a set of solutions which is which I think then we can look refining that text what specific language do you see here that removes the solution you\u0027re envisioning requirement 1.1 in 1.2 it says this must be doable without changing the namespace you see that well one put once inside that yeah all right thank you so that\u0027s it I\u0027m in the end maybe maybe I\u0027ll think oh this is a you guys were all right right some just objecting that it\u0027s it\u0027s limiting the solution space at the get-go so perhaps we should revisit the phrasing of one to two to make it so it it\u0027s more open to different so yeah maybe like what you\u0027re really intending there right yeah is that the you\u0027re sort of describing what you\u0027re intending through a solution yeah I wasn\u0027t in touch but yes we consumer fun it if I understand it correctly this option of changing the name of whom are you is already here probably because quite a few people including myself so this is not a visor not good good good way to do this that\u0027s so in a way if if we want to change module names that we can and if we agree that this this is this sufficient we can just stop this work and then well I think Chris is come sight differently saying that maybe there\u0027s a there\u0027s a prone to be solve here but it might not be that this is the problem that the problem is that you can\u0027t handle changing the names of modules in an easier way and potentially a different solution would be to find better way that that could be managed is that fair so we\u0027re not I don\u0027t think we\u0027re trying to preclude solutions here so I think I\u0027m happy that we can try and refine this refinement X that the potentially allows "
  },
  {
    "startTime": "01:42:51",
    "text": "so so what I\u0027m able to do here in terms of we need to look at refining this requirements text for 1.2 but in terms of did we do that on the NS and then ask I think it would be worthwhile to see just sort of get the feel for the room of how many people are feeling comfortable with the the requirements presented with an understanding that we need to fix 1.2 at least and just just sort of get the the feel of the room so I\u0027ll ask a couple of questions [Music] comfortable not comfortable and maybe disinterested so how many feel comfortable with the requirements as they get presented for the problem that the design team is trying to solve I\u0027d call that a pretty reasonable number yeah subject to the modifications have been discussed so that\u0027s that\u0027s a pretty reasonable number how many are uncomfortable with the requirements as they\u0027ve been discussed I see no one oh please so I think we saw one person raised her hand who I think they very been to the mic and express what their discomfort was and they\u0027re nodding their head yes and how many are think this is not a problem that we should even be talking about and no one on the lotta is still in the room all right okay well I think that\u0027s a pretty good direction it sounds like we do you want to try to address the issues first before we do an adoption call or doing an option call on this version and with the understanding that we\u0027re gonna try to address really the two points that were raised here the one I took away the one as the one point two as in don\u0027t be prescriptive or could don\u0027t constrain the solution and then the other one was if I understood it correctly was about complexity so we have some folks lining up binoculars so actually maybe you could postpone this question for Friday because you\u0027ve got a design team meeting on Thursday so maybe you could try to directly address this and a second at a time sure maybe maybe maybe the design team can meet and have a new version by Friday I mean this is what I mean submissions are unlocked now so if you if it sounds like you guys are comfortable either way so yes if you have a new draft then that\u0027s certainly "
  },
  {
    "startTime": "01:45:51",
    "text": "something we can ask about Jason Stern like it\u0027s I think at the last working group and still now seems like there\u0027s a lot of interest in progressing on this topic so I\u0027m not sure if there\u0027s a lot of point in not adopting it that working groups thinking about it and working on it we\u0027re gonna refine it there\u0027s people with different viewpoints but you want to resolve the issue the open issue that was raised here so why don\u0027t we plan to pull this in short order after the meeting and if you\u0027ve published a new version and that\u0027s what we\u0027ll that\u0027s what we\u0027ll pull and if you haven\u0027t we\u0027ll pull there and for those who have comments please feel free to reiterate them on email if they haven\u0027t been addressed I\u0027m not sure we fully captured that other comments it would be really good to get that on the list so thank you all right and if I could just Kent as a contributor with regards to the yang data discussion yang data I mean there\u0027s a name space but there\u0027s no other instance data or anything to identify what version of the module was used to encode that yang data so I\u0027m not sure if this is an issue requirements we need to address it or maybe it\u0027s a problem the yang data authors need a resolve that\u0027s in that I I don\u0027t send your questions watch you do an import to use it right you end up having import the module the module that defines the ending data in order to use it so if you\u0027re saying if you have an instance document that\u0027s using game data it inside the instance document there may be like the name of the JSON namespace for the XML namespace but there\u0027s no other versioning curse no relation to what version of the module yeah oh yes so that may potentially you may need to update the instance data document to actually say at the top of that what are the revisions of the module is using maybe but I guess my question is there\u0027s a requirement that you might that you think the design team might need to take or is it really the author\u0027s to worry sounds like a yang theta was gonna bring up his graph that he\u0027s presenting Friday say that\u0027s the latest often so so the next step to so only something that will adopt this document fey soon we\u0027ll continue to refine the requirements as people have comments and things I\u0027ll stay because a document but the next step for us is to actually consider the possible solutions so I want quite clear that solution proposals and ideas are welcome Chris in particular you\u0027ve got an alternative solution please PLEASE sketch it out to us maybe you\u0027re free on Thursday come along a viewpoint that we hopefully could discuss it as well at the moment we\u0027re a really aware of one potentially and one other solution drafters out there so at the moment this the certain aspects of "
  },
  {
    "startTime": "01:48:51",
    "text": "that solution that we are considering and what the impacts that that would be so we\u0027re hoping to do enough to give an update in the clock our draft but I think we\u0027ll do that afterwards it was time and then so once we considered the possible solutions the idea of the design team is to progress a particular solution to a working group adopted solution draft and then after that at the moment the remit is for that to close the design team and the authors of that solution drive to take it forward so in terms of the class the question on the prayer yes I\u0027m not sure yeah great thanks so in considering possible solutions obviously they\u0027re the members of design team have set of solutions that they\u0027re familiar with if we have other people who want to bring solutions such as Chris or someone else who\u0027s out there what\u0027s the best way to sync with the design team you want a full draft can you know people drop you email do you want it on the on the other on the list what do you think would be a good way to sort of socialize ideas with the design team so certainly I don\u0027t you need a full draft I\u0027m happy for it to be an email I think that the low barrier to entry is good as well it\u0027s thought out I was suggest sending that the design team copying the networks is fine as well there\u0027s no shoes there in terms of and again you\u0027ve got solutions for just some of the requirements you say well I\u0027ve got a good idea of how we could solve these problems then then that\u0027s fine that\u0027s great I think some of these requirements is sort of a fairly obvious solutions like the deprecated potentially and adding a description statement to status seems like a no-brainer almost so some of those I think are fairly easy other ones I think it\u0027s more more pragmatic so whatever is the easy way to do it is my suggestion and I think we should also send an email out to the network a deist to highlight this thing on this reading to say look this is opportunity and I suggest maybe trying to get something in before before the end of August because I think it\u0027ll go quite over the summer so that gives people some time we\u0027ll pick up more steam after that I suspect and just to be clear from a working group process standpoint the design team isn\u0027t the working group so if you have a proposal and you talk to the design team and they\u0027re not keen on it but you are there\u0027s nothing that prevents you from bringing it to the working group and socializing it may be the working group will even accept your proposal over the design team and that\u0027s not hypothetical attack that\u0027s actually happened to me before where I disagreed with the design team and ultimately the working group accepted the solution I had proposed so so this is sort of hypothetical slide in terms of if we were to go forward with the semantic versioning solution then there\u0027s various aspects we already know what that would look like so it would look like that we\u0027re going to add "
  },
  {
    "startTime": "01:51:53",
    "text": "a thematic version number to yang modules we\u0027re going to potentially add an import by version number or range of version numbers or a major version number dot star star but effectively we would be modifying or extending the import behavior today and potentially through an extension statement we would essentially consider changing the meaning of status deprecated so change what that\u0027s defined as from ways today to meaning this different definition we would be changing the young module update roles that are in 7950 they\u0027re quite strict as to what you\u0027re allowed to do and obviously this work would be allowing those rules to be broken and then perhaps again we\u0027d be requiring version selection which would be changes for protocols or extensions to the protocols to be able to select in some way what version of software a particular client is interacting with and that may also require changes to yang library effectively to represent that so it\u0027s very clear that this would work as it looks at the moment if this solution goes forward the clock our solution then it would need to update 7950 and so there is a question as to what the best way of doing that is how do we do this work so does this mean that we can do an extension statement or use extension States to modify yang in this way can we do it an RFC that that only defines yang versioning and doesn\u0027t touch the existing drafts or does this require a yang 1.2 or yang to the youngest document and if we do that is that gonna then delay this work by a long time how do we how do we do this work in an efficient way to get to a good point without it taking a long period of time and then related to that some of the discussion that design teams having it they had related to sort of yang next is that there\u0027s a load of other stuff in yang then the yang dross that could be cleaned up you could take the xml encoding out of Yang and put it into a separate RFC like the Jason one it\u0027s it\u0027d be good to take the net mods the net conf related text out of Sendai fifty and put that into a net Protocol draft so there\u0027s a reasonable amount of cleanup work that could be done to the yang draft could that work be done in parallel to this does that make sense you know what what\u0027s the best way of going forward if we end up doing a Clark like solution Kent as a contributor so I mean I think there\u0027s two approaches what one could use a yang version that we have today but that\u0027s never yang module but if we were to change that and that would necessitate a change in yang we need a new version yang another idea is to define an extension statement called you "
  },
  {
    "startTime": "01:54:53",
    "text": "know whatever semantic version yang whatever and but the problem with that is that extension statements are optional to implement i\u0027m sure the design team is sort of that\u0027s exactly what you\u0027ve been talking about right yeah i need and it might be that you can actually one option is to you can do some of this work now and you\u0027re doing an RFC that covers some of this and you delay some of it maybe you delay the import by version two I mean it doesn\u0027t have to be that we have covered everything in one go crabs so this is a the pain that we\u0027re feeling at BT right now is sort of a it\u0027s like we get a thousand models right because the the vendors update their models on every compile right like or whatever and so so I mean we really do want some way to be able to easily say okay the model didn\u0027t actually change all right I don\u0027t want to have to do any work so not actually fighting against that I want that this is what actually worries me right the reason that I\u0027m so resistant against the namespace changes because you can maybe do all of this work without requiring you know we can get all the benefits if we could approach us differently right you you know if you have a sort of sideband solution right where you you haven\u0027t you have an extension or whatever that says I\u0027m gonna describe how these two models are actually the same here are the changes now I can write my client software and it can automatically just work with the new version and I don\u0027t have to wait for yang 1.2 right which is deadly long yeah I mean it\u0027s just it that\u0027s the problem with that solution anything that requires waiting for another revision of yang I don\u0027t know it\u0027s that\u0027s a we have a problem now right we need salt and in like you said I mean it\u0027s affecting how we design a model modules you know it\u0027s affecting everything so yeah so there\u0027s definitely gonna be different options out there this is the type of question that I think it\u0027s really helpful to evaluate in the context of a specific solution and as is always good engineering principle if you can solve something in a less disruptive or simpler fashion you know you there\u0027s going to be a bias towards that of course if the simple solution is wrong you know it\u0027s wrong it doesn\u0027t help you so I think we should and look at this while we\u0027re looking in evaluating different potential solutions and certainly go to the simplest answer that solves the the problem I don\u0027t care I\u0027m not sure if it was mentioned in in the requirements but what happens if if a module specifies "
  },
  {
    "startTime": "01:57:53",
    "text": "Norma Norma import by revision with an exact revision so does it mean that the new solution can just get rid of this so this is not taken into account or because if so then I would locate the option off of going to a new young version because then it\u0027s again what a relief did the same popeye revision yes so if it\u0027s important I reckon then it can be just you know what if you have this new solution so that would mean again some incompatible changes to the yang semantics so I think that would be if we\u0027re doing young well not to you potentially do that if you were you would do yang but wonder too for that reason this my guess yeah meaning one more comment I would agree that I would suggest that Chris outlined some solution that and if the solution doesn\u0027t meet and the changes that might be the best way to go so so yes it Chris if you have time this week to sync up that would be would be good we\u0027re all here so yep and we have another meeting on Friday so we\u0027re gonna wrap I think Kent has very quickly I can\u0027t as a contributor on the very last question I\u0027m you know there\u0027s a lot of discussion about maybe thinking about how to modify 7950 it seems to the first effort to that might be to iterate over the issues and github tracker and evaluate them on a few different dimensions such as easy hard backwards compatible not backwards compatible important not important right like that and and so I think I\u0027m as a contributor might do this if others would like to work with me on that perhaps we could have a even an interim I don\u0027t know if one actually called an interim but we could do something like this to try get some more understanding about what that might be we just something at the moment yeah and maybe Swift trying to see and get some people this week to first pass through it together just in the pub or something okay thanks everybody um we\u0027re at time um we\u0027ll be back here again on Friday at looks like 9:30 so see you then Lou sheets up front please "
  },
  {
    "startTime": "02:01:54",
    "text": "[Music] and actually it actually probably probably more likely previous trains [Music] "
  }
]