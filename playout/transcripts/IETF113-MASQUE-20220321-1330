[
  {
    "startTime": "00:00:08",
    "text": "so oh i wouldn't necessarily tie all that together but okay"
  },
  {
    "startTime": "00:02:32",
    "text": "so so thank you good afternoon everyone and welcome to mask i will hand it off to the chairs now all right thank you david welcome to mask in vienna and or online specifically and online because please go join the on-site tool if you're in the room and have not yet already just a quick reminder that this session is being recorded we've got a link in this slide or in its equivalent pdf to both the on-site tool and the fully remote video stream if you do not join the on-site tool you won't be on the blue sheets so make sure you do that you can enter the queue in both tools with the raise hand button and leave it with the lower hand button if you are on site make sure that you enter the virtual cue because that's the"
  },
  {
    "startTime": "00:04:01",
    "text": "only place where we will be dequeuing someone from although you will need to get up to speak at the actual physical microphone if your remote when your turn comes just press the microphone button to send audio and press it again to stop sending audio this is the ietf notewell especially as it's monday please make sure that you've read it recently these are the terms under which we collaborate here at the ietf we've got some helpful links to our agenda and other notes in here this is mostly for the pdf later and our agenda today first things first we need a jabber scribe and a note taker somebody willing to volunteer to reflect notes at the in person or virtual mic and or take notes thank you alan we've got a jabber scribe someone to take some notes all right who else can help with minutes here we need that to get started people thank you all right martin lucas thank"
  },
  {
    "startTime": "00:06:00",
    "text": "you so much wonderful that's martin thank you appreciate that let's take a quick second to bash the agenda if anybody would like to reorder or move things around what we've got up are our main active drafts so we've got h3 datagrams in connectudp and then after that we will be doing some ip proxying support and calling it a morning all right that means david all right i'll try to share locally all right take us away one second i'm trying to get the clicky to work good afternoon wow really have to eat this thing good afternoon vienna and good morning good evening good middle of the now the entire rest of the world thanks for coming to mask so my name is david scanasi and i'm going to be talking about http datagrams and connect2udp so first off quick note about the hackathon we had a quick table which lars decorated to also make a mask table this joke never gets old we didn't quite get interrupt in the room but we did amusingly with the latest drafts since they're wire format compatible with the"
  },
  {
    "startTime": "00:08:00",
    "text": "previous ones uh assuming you just disabled contacts uh we already have a drop which i copied the matrix from last time so we're already in good shape implementation wise even those those are pretty new only came out two weeks ago but let's do a quick recap of where we are um so the focus of these two drafts is to build connect udp which is like the http connect method but for udp instead of tcp um there is interest in other places to do datagrams as well so we split into two draft the first one being http datagrams which is used for example in web transport and then the second one being connect udp which has a dependency on http datagrams so over the course of the last year and a half we redesigned i think a total of four or five times i lost count after a while the core design of this um so since we were kind of going in circles we decided to go with another approach we formed a design team which met a few times and we came out with an output at an interim a few weeks ago and got consensus so all that was good that's been merged and now we have these new drafts so i'm going to quickly go over what the drafts do right now so a first part that is in the http datagrams draft is the capsule protocol so the capsule protocol runs on the data stream which is what we call the data that goes after the headers so in http 2 and http 3 that's the data frames http1 it's after the two new lines after the header block and it's a bidirectional sequence of tlvs and it's meant to be end to end if there are any intermediaries in the middle and any method can choose to use it or not connect udp does and so that allows it for example to um to send datagrams um and there's a little header that we added as well so"
  },
  {
    "startTime": "00:10:00",
    "text": "you can tell in terminaries uh that the capsule protocol is in use it's not mandatory but it exists and intermediaries are able to translate between versions of http like they do for other methods and for http datagrams the difference between those and the quick datagram frames is that the http datagrams are associated with a currently open http request stream so what that means is they're always tied to an open client-initiated bidirectional stream um and so you can still send them kind of think of it as a sidecar but datagrams don't exist in a vacuum they're always tied to a request and so the formatting is there on the right so when you send a quick frame um that is the quick datagram frame it has the quarter stream id in it followed by the http diagram payload so we divide it by four because all the client initiate bidirectional stream ids are multiples of four and we also introduce a datagram capsule so capsule being a sequence of tlvs the t have an inn registry and we define a single one which is which means datagram so if you receive one of those it means the same thing as receiving this datagram quick frame and quick you generally will want to use the um the datagram frame but if you're using http 1 or http 2 this allows you to still support things like connect udp over older versions of http and yeah that works for all known versions of http uh so the the biggest point of contention that we had in http datagrams over the last year and a half was extensibility and demultiplexing and what we had with context so the consensus that we landed on was to take that out of that http datagramsdraft and put it inside connect2udp so that means that for example for webtransport it doesn't have this feature because they didn't see a need for it so when it comes to hdb datagrams"
  },
  {
    "startTime": "00:12:02",
    "text": "we're pretty much done uh we've resolved all the issues um we'd like to move forward because that unblocks other working groups like web transport and i think we're ready for working group last call so i'd like to kind of pause here and ask like the chairs what they think or anyone on the floor if they have thoughts or comments not seeing anyone get up in the room chairs what do you think i think we're looking pretty good um i think we'd generally be aiming to initiate a last call for this on the list after this meeting but that is also a massive thanks to a whole lot of folks who have put a lot of time and effort into this especially before our previous interim and a lot of that stuff so a thank you for that and uh now that the slate is looking pretty clean um we're probably going to go and start a last call right after this meeting wraps up thanks eric i see maria in the cube yeah hi um is it working here it's working but please state your name mia coolivin um yeah i think this looks pretty good it's pretty clean and it's probably ready and what i would like to see is have at least one draft that uses the extension and you know think of it a little bit more about if we did it right at the end so there is no more extensibility in http datagrams the extensibility is inside connect2udp oh sorry i thought we're talking about both of them well right now we're just talking about http no that's easier okay okay but uh hold that thought i'm gonna keep going then for connect udp um any other thoughts from anyone on http datagrams before i switch over to connect udp"
  },
  {
    "startTime": "00:14:03",
    "text": "eric sorting out the cue um just wanted to ask is there anybody who thinks that we should not move hb datagrams forward without connect udp or anything else because i think our intent here is to move hp datagrams forward especially because there's other working groups that are depending on it sooner and then continue to wrap up connect udp and then connect ip afterwards excellent i will take that as a resounding silence thank you awesome all right yep um so i i definitely think we're ready for working for last call i would just uh note as hgbis chair that when we send that out let's also send a note to the http group to also review since there may be some folks in there who haven't been paying super close attention and it would be great to get their review kind of alongside the rest of working group yes absolutely thank you awesome thanks okay moving on to connect udp so connect2dp it is not an http method we it was in the earliest version of the draft and we kind of kept the name but it is now an http upgrade token so http upgrade tokens allows you to use a mechanism in http one called upgrade where you send an upgrade header with this token so in this case we picked connect udp and then it replaces the protocol on the wire with something different so that in this case is the capsule protocol in http 2 and http 3 hp upgrade tokens are used for something called extended connect"
  },
  {
    "startTime": "00:16:00",
    "text": "where you send a method of connect and a protocol of connect udp and this is documented for http 2 and rfc8441 and we have a draft uh for the same thing http 3 that has already been approved by the asg so we have a normative dependency on that but we see this draft as happening before connect2dp anyway so we don't see a problem there then on the topic of extensibility we kept the concept of context ids from the previous http datagram drafts and we moved them into connect udp so if you look at the wire format image here on the right after the quarter stream id which is part of the http datagram layer you have a context id also a variant quick rfc 9000 variable length integers and we define a specific meaning to context id 0 which means udp payload so every time you see one that has zero you put that in your udp socket and vice versa when you receive a packet on that socket you put it in a datagram and send it back to the client and all other numbers exist for extensibility and we decided that they are dynamically allocated which means that each like both the client and the server have a way to generate new numbers that haven't been used before the simplest one is you just keep a counter so you start at two and you return two and then four and then six on the client and same with odd numbers but we don't mandate exactly how you do that for example if some future implementation wants to um reserve the uh low warrant numbers which only take one byte encoding for some things they can do that and give them out of order so that's kind of all we do to specify them and uh from the thoughts that we've had for our extensions this seems to be powerful enough to enable any extension that we thought of because you can for example create an extension that adds information to udp let's say"
  },
  {
    "startTime": "00:18:02",
    "text": "ecn bits and just define a new context id for that or you could define a context id that sends information that's unrelated to a specific packet let's say you received icmp which is not tied to a udp packet necessarily and so we we introduce in this draft the concept of registration um which means that we when an endpoint decides okay i've picked number four and number four means this that's how it informs the peer of that format of those formats or that format in those semantics um and we don't specify registration exactly we say that you can use http headers we say that you can use new capsules uh because headers are kind of simpler you're guaranteed to have them like during the request response cycle capsules are more powerful if you need for example for something like compression where you don't necessarily know what the value is at the request response time you can add them later so you have the option to do both but we don't define how to do it we say okay we leave this as an exercise for future extensions and i kind of want to pause on here because i know some folks had thoughts my personal preference is to kind of keep it like this i would keep this rather keep this draft simple and allow us to move it forward more quickly but i want to pause here and make sure that the working group agrees with that statement i see ben schwartz in the queue go ahead ben hi uh oh boy echo that's exciting so uh yeah i'm one of the people who has expressed some concern about this you know i tried to drop a"
  },
  {
    "startTime": "00:20:00",
    "text": "draft that sort of made use of this and found that i ended up writing a lot of boilerplate to explain how this registration and negotiation worked and that i was getting lazy and leaving out parts of it that i thought i could probably get away with not dealing with like deregistration or handling error cases uh and so i i worry that we're going to end up in a situation where where we have extensions that all have slightly different ways of registering and many of them are missing important error handling and garbage collection uh cleanup type functions and we don't get as much code reuse as we could that said i am okay with this uh i think that maybe the right approach here is to pretty quickly try to come up with some um extensions that we think really do things right and provide a template that um that hopefully subsequent extensions can follow thanks ben that makes sense uh ted uh chad hardy speaking i i agree with you that probably you you will have use cases where you want to uh other http headers or capsules but i think what you probably should do now is pick the one you think will be the most useful quickly put that in the draft and note in the draft that the other might be defined as a later extension that means you don't define both paths as a later extension you end up with something in the in the draft that says this is a mechanism that is known to work with the workout issues that ben was alluding to so that somebody who wants to say okay i'm gonna i'm gonna do this with an http header knows how it works and somebody who decides that they really need a capsule knows that well i need all of the things"
  },
  {
    "startTime": "00:22:00",
    "text": "that are in that plus whatever the capsule needs um but that also means i'm defining extension as the cost of my going off the base spec now um i i would actually say for the reasons you already elucidated that htv headers would be the one i would put into the graph now if you are going to put one into the draft um and i i think functionally you're not going to be able to put this complexity off long since you're going to want to do this soon so you might as well tackle it now you could put it in a different document if that helped you but i would do it now thank you i my personal preference is to keep it in a different document because oh i see ted gives me a thumbs up because uh the use case that we have for actually putting this in production doesn't need extensions just yet and it'll be easier to interoperate with folks if we have a standard for like that what we need but having um a draft for this that we start right away sounds great to me honestly um thank you ted uh mike bishop is next okay do i have audio yet uh we can hear you but you're very quiet uh you have to eat the mic okay so i'm going to [Music] i feel somewhat hypocritical because the h3 draft does kind of say you have to figure it out but it gives you a suggested mechanism which is sending a setting and defining a setting as part of your extension you don't really have settings here so i'm not sure how you would how you would hand wave this away i feel like it needs to be defined it also helped in h3 that we had several extensions that were already in progress when we wrote that so i think a separate document would be fine but we do need to start it and we do"
  },
  {
    "startTime": "00:24:01",
    "text": "need to actually define this and not just leave it for each implement each extension to figure out how they want to build it thanks uh so on the topic of you know like the analogy we've set with settings um we have an equivalent which is http headers so let's say and and you're right there maybe in this draft we kind of add a bit of text explaining um that's what you use but since the capsule protocol is only in use and http datagrams are only in use after the http request and response have been received you can negotiate any kind of extension by sending them in headers so that gives us kind of our extensibility joint for negotiation and then the the context id allow the rest thanks mike martin seaman i'm wondering how extensions compose you've already mentioned uh ecm bits and in the draft there's a example extension for timestamps so you would have one context for the ecnbits one context id for timestamps what happens if i want to send both ecnbits and timestamps do i need another context id for that that's a great question so when we talked about it uh that's how you would do composibility of extensions is say uh if i want to send both uh the ecn bits and the timestamp i define i use this to be defined negotiation to say this context id means a udp payload with first ecn bits and then the timestamp and then the udp payload uh martin duke uh martin duke google as an individual"
  },
  {
    "startTime": "00:26:00",
    "text": "um so uh like obvi headers you know requested responses are a pretty obvious extension joint but i will say the downside of that is that you can't um you can't use the extension necessarily in the first flight uh depending on you know the specific extension if i if i send a if i want to send a request with this extension negotiation and then immediately send datagrams with this thing like i don't know the cert that the server can accept them so it's a downside it's not a show stopper but um so that's a very good question and we actually have a solution to that i think in the draft and i need to double check that if that's written down or just in the back of my head but all we need to say is that you drop context ids that you don't know and so you can let's say as a client uh yeah we called this zero rtt extensibility in previous meetings if anyone remembers but the idea is if you want to send something in your first flight you can like send your i want to use this extension in the header and in in another header say context id4 means this new extension and then you send a datagram on context id4 if the server supports it it says with its server response headers yep i support this and then it processes the datagram and if it doesn't that header gets ignored the datagram gets ignored and it's it's lost oh sorry the datagram is ignored yes and uh but that is a good point i will double check it all relies on saying that you just ign silently ignore a context id you don't know just drop them and i need to double check if that's actually in the draft um if anyone has it open let me know but otherwise we should say that so i mean i guess okay so i mean the ecn case is the one that that um you know i certainly have my mind and that certainly sounds fine but what you're describing is also a an attempt to use your rtt essentially gives you a 1rtt penalty"
  },
  {
    "startTime": "00:28:01",
    "text": "which also is not great um and i'm pointing at problems here i don't have a solution but uh i'd encourage you to like think a little more about if there's some way to like a more robust system for this uh so there used to be in the draft and the kind of consensus of the design team was that this was sort of too complicated so it was removed and that's kind of we ended up with the current design i i personally want preferred that feature but i think i kind of agree in hindsight with the rest of the working group that you know keeping this simple even though we might have some edge cases like that is probably worth it in the long run great thanks cool eckers in the queue yeah i mean on the topic of the hierarchy of sensibility because i understand the mechanics of information oh that's a great thing for you isn't it i'm just gonna keep talking to your head after afterwards yeah um sorry yeah i have a really hard time hearing you can you speak closer to your microphone maybe slow the acoustics aren't great and it's probably because i'm behind the speakers here yeah um hard for me to get much closer without like having my face attached to my camera um so um on the topic of you know having accessibility in the first flight um you know as i understand the mechanics inspiration um you either have to that's great i have the echo on your title did you guys echo cancellation i need to put the microphone down sorry um well it's not helping um so i understand the mechanics of the xero rtd sensibility here um unless you have mandatory extension even if these sensors are self-describing you can't use them guaranteed in the"
  },
  {
    "startTime": "00:30:00",
    "text": "first flight if they're aside might reject it and so as a practical matter the most you could possibly do is announce them in the first flight and then have and then still have the in your behavior that you described here um i suppose you could have extension persistent from previous handshakes the way you are those your rtg features but i as far as i can tell physics in the situation just dictate that there's no way to be absolutely sure the attention would be acceptable in the first flight and start using it for anything that is critical path and will cause disaster if it fails am i correct about that um i wouldn't say it's a disaster if it fails i would say the datagram gets lost so if it's something critical let's say you want to send your quick initial in a udp packet for this and you want to send it with ecnbits and the server the proxy doesn't support the ecn extension it's going to drop that datagram tell you and then you're going to back so you're going to lose a round trip for that connection establishment and that's pretty bad so i think in general probably when we get around to writing the ecn drafts we might say unless you have a reason to know that the proxy supports ecm like you're saying maybe we remember it i would just like not use it in the first flight because it could cost you a round trip but the the failure mode is just that datagram gets lost it doesn't get misparsed right i think you and i are the same nature what i'm thinking is you can't use extensions for anything where if it was um where if it was lost it would cause good that's right okay and i think we're on the same page cool thank you um all right um so it sounds like what i'm getting from the room is folks are overall okay in not having this draft define the whole system but that we should start work on a separate draft to actually define how to do registration and that sounds great to me uh all right now for everyone's favorite"
  },
  {
    "startTime": "00:32:02",
    "text": "game let's close some github issues um so uh one of the things that i didn't discuss too much yet is how you configure clients so for http connect uh like you know either in the proxy settings of your computer or os or of your browser you put in a proxy host and path sorry host and port um what we do instead for connect udp and the connect ip draft for that matter copies that as well is we put in a uri template and so it's kind of a thing that looks like a uri which has these magic variables target host and target port that anytime the client wants to do a connect udp request it swaps them out for the actual host and part that it wants to talk to uh so here are three examples on the slide um uri templates are a little bit complicated uh we added some text uh pretty recently i forgot if it got into the last draft two weeks ago or i think i might have landed that pr uh before after the draft caught off so sorry i added a paragraph that tightens up the rules on the ui templates so you can't use some of the really crazy and hard to parse syntax in there um and i think that makes it a lot more wieldy however one thing we thought of was a lot of existing os's have a ui where you can only put in the proxy host input you can't put in a new uri and we kind of probably want to work with those so the draft defines something called a default uri template which is if your ui kind of has this limitation here's the uri template you should use so it's pretty simple you just use the proxy host call in the proxy port and three slashes with the target sword and target post there um and i think it was eric nygren who filed an issue and saying well"
  },
  {
    "startTime": "00:34:00",
    "text": "should this use dot well known um i don't personally care much does anyone have opinions on which way we should go here do we keep the current one which is short or we do we move it to something a dot well known um i see ben schwartz in the queue go ahead ben hey i think that well known is correct here sorry you see that again a bit slower i think dot well known is the correct place for this okay anyone else have opinions empty plus ones in the chat apparently thank you okay uh the one that i put up there dot well known slash smash slash udp slash target host target port does that work for everyone i see rajiv in the queue go ahead yes uh one point that i have is uh in many cases uh a lot of intermediary hosts um especially proxies and cdns to have some special handling logic for well-known which we already use for a number of other protocol uh activities so do you think this might uh you know be something that interacts badly with existing rule sets around the taught well-known path um so i don't know so thanks for your question i don't know if i have a great intuition for that um my gut feeling is you probably want well you're going to need some special handling for this path if you're doing connect udp like this is fairly different from most http existing http methods so probably having that well known maybe makes that easier but in our"
  },
  {
    "startTime": "00:36:00",
    "text": "implementation like we don't have any specific rules that tie to the well-known prefix so the problem maybe some text in the draft around the fact that this might be something that interacts with existing rules and implementers should uh you know maybe just keep an eye out for such interactions could be part of the draft just as a warning to people who are you know implementing functionality around okay thank you yeah that makes sense we can add some uh some text to make sure people don't get it wrong all right uh unless anyone objects i'm gonna write a pr to move to that uh well-known path at the bottom all right and now for another fun one um so for http 2 we use extended connect and the method there is connect for http one we use upgrade um upgrade works in theory uh with any http method um and whatever we put in there doesn't really have semantics because we could say it's whatever any proxy that correctly implements this spec we'll handle it doesn't matter we don't get any information out of the method the draft currently says we should use connect for consistency with what we do for h2 and h3 and eric i believe pointed out that um we should use get because that or maybe we can use git because that's more consistent with what websocket uses when it does upgrade which is kind of the really only widely depe deployed use of connect of upgrade that i am aware of um lucas pointed out on oh yeah we discussed this at the last itf meeting and kind of the consensus was let's ask the https working group so i wrote an"
  },
  {
    "startTime": "00:38:01",
    "text": "email and got zero replies so clearly they care and lucas pointed out that connect might cause more deployment concerns so how about we just use get if anyone has thoughts or opinions please come to the mic mt is in the queue go ahead uh audio going out everyone um so it's casual by default so i think there's the possibility that very stupid cash might accidentally um cash something but it shouldn't but i'm gonna be okay as well whatever so sorry i didn't quite get all that the audio is surprisingly bad from the front here uh you kind of ended with whatever um so i put it in the chat but if you have a cache that i could get out from the chat so empty said what about a caching proxy that falsely caches all gets ah caches i heard hashes thank you okay this is really terrible um no that that's that's a that's a real concern um lucas since you're the one uh who was preferring get to connect you wanna come say something because it's it's true that get is marked as casual whereas connect"
  },
  {
    "startTime": "00:40:01",
    "text": "is not hello i'm lucas can you hear me yes yes great um i mean the problem would exist for get websocket upgrade then like i what i like about using get is the symmetry and the asymmetry between h1 doing what it does and h2 and h3 doing what they do and how it works already for websocket if we if we followed this it would at least at least if there's caveats drawn out in caches for websocket today they could still look at the upgrade header even if they didn't look at the content and just say oh you know this isn't cacheable even though it probably is uh in this with respect to the connect you know the it's connect is just weird and trying to build something new on top of it with 1.1 doesn't fill me with a lot of confidence if we had to probably again could carve out another caveat for it but it just seems like i think this or that whatever yeah oh i'm very much in the whatever camp uh thinking more about caching um so this is for the case of some box that doesn't support this so they're probably gonna send a 404 or some other kind of error if they cache that that's not a problem because the answer is going to be the same every time eckers in the queue i'm just having a little trouble understanding what the scenario in which this needs to be a problem is someone lay it out for me so the idea is if you're talking to and granted it's an odd scenario let's say you set your proxy settings to"
  },
  {
    "startTime": "00:42:01",
    "text": "i don't know davidskenazi.com i don't support connect udp on there yet uh the same server runs mask.that's different um and you try to do this you're gonna get some you don't want the proxy to catch fire uh you want it to properly say nope i don't support this go away and we're trying to think about like in all cases it's nothing really too bad but we want to find the least dramatic way for the proxy to fail i guess oh okay i i feel like my response to this as to every other concern about proxies did not speak this problem is don't do that you don't accidentally get connected to a proxy which has the wrong semantics you mistyped or you're misconfigured so i actually do not care the proxy and the process you shouldn't catch fire with any data sent to it obviously but um you know i don't care if it hangs indefinitely um and you have to wait to time it out because like that's a misconfiguration so i just i just don't understand how the situation arises so i don't understand why using kind of you're right it's a theoretical concern to some extent i'm with you there uh rajiv okay that was a terrible idea i apologize everyone okay what i was going to say is i can't hear you and from the looks on in the room we can't hear you at all if you"
  },
  {
    "startTime": "00:44:00",
    "text": "could maybe type it in the chat and then someone can come can you hear me now is this is it better now yes that's much better thank you okay great so just moving a little closer to the mic so i i was just making a point that a lot of uh you know network transition and edge devices like firewalls or intercepting proxies have traditionally had very different uh conceptions and uh you know security rules around gets and connects because of the way they've been used like you said traditionally 1.1 and you know prior connect has always been something that was a tunneling system and it's a very different security handling than any request with the get you know method so that might also be something that a lot of people have been changing uh you know because of web socket but i don't see that having changed uh so much so it might actually make sense for us to stick with connect because that's closer to the kind of uh you know security handling that people expect around this kind of traffic again just for just a thought over here okay thank you uh eric i think is it theoretical i think what really comes into play is if you start having um multi um multi-tenant services so if you have for example a cdn node that wants to be handling various things is it the traditional connect method does not have good um multi-tenancy support and becomes really messy and having the connect method have different semantics between extended connect and non-extended connect especially in a multi-tenant environment gets extra messy i think margin suggestion of post if that works might also address this well oh my only problem with post is then i"
  },
  {
    "startTime": "00:46:01",
    "text": "can't resolve this with a coin flip anymore i need a like three-sided dice um how do people feel about post that's fine by me because i'm think i'm very squarely in the eckers camp of this will never happen and at least speaking for myself and i think quite a few others we're never going to actually implement this over h1 we're going to use h2 we have to implement h2 because some networks block udp and quick and h3 but h2 or h1 is inside tls so like the only place where this will probably be used over h1 is inside someone's network between their front end and their back end and if they're implementing this they're going to fix their network to their firewalls to make it work so i really don't care about the answer let's just pick one um does anyone object to post yet again seems gross that was my objection to get too i guess i don't understand eric i mean i don't like love connect but i don't understand eric's point about why um so the i i think it comes down to someone who wants to deploy this on some back end when they have like some appliance in the middle like a firewall or something that's going to treat it weirdly and i think that's where the fears come from um like i think um i'm i'm not entirely sure to be honest um empty oh good job"
  },
  {
    "startTime": "00:48:01",
    "text": "um so i think the key here is that as soon as you upgrade header on the request it doesn't know what the method is what we've heard from people is if you happen to use connect in combination with upgrade they don't know what will happen as in if things might explode so i'm happy to avoid correct uh but then and look at the look at just anything else uh okay well we have someone who wants connect and someone who wants anything but connect this is going great um mike bishop um so i think the the issue with connect is that http handles connect very weirdly basically anything else the method points to a resource connect points to the target and so what eric was alluding to is something we talked about in hgv before and i think here before that it might be nice if there were a different method that was connect like but are good at extended connect however i feel like if finding a new method might be a challenge here and it might be a bigger fight than the mass working group wants to take on if we have to do a hack of combined boost is a reasonable hack if we want something that's not a hack i think we define a new method okay that is yet another option thanks uh ben ben schwartz"
  },
  {
    "startTime": "00:50:00",
    "text": "i was going to put in a word for a new method extended connect i think the cause of confusion here is that the upgrade path in http is nominally optional for the server so the the server is always within its rights in principle to say never mind your upgrade i'm going to answer the request as you sent it and if we send a connect method with a thing that follows it that isn't a host and port then the the server that tries to do the thought that ignores the upgrade header is faced with a malformed request which seems kind of ugly so i think that's why people are looking for some kind of method like get or post where at least that would be a well-formed request even if it's nonsense but a new method would let us have you know clear semantics and possibly say something like upgrade is mandatory with this method thanks ben um uh cheers was my mic was before ben i think yep there we go ecker yeah mt persuaded me so i'm i guess i'm fine with anything but it including non-connect things okay thank you that's that's helpful because at the end of the day a lot of these considerations remember this is upgrade so an http upgrade you no longer have like the similar things that you would expect from the rules so upgrade like connect or like weird abnormalities in http land um and you know just thinking about this more like these problems exist for websockets like it's not like days haven't been solved like if someone"
  },
  {
    "startTime": "00:52:01",
    "text": "wants to deploy websocket today they need to fix this so if they want to deploy connect udp just point at oh the guy next door deployed websocket asked them how they did it um so let's make me lean towards there at the end of the day honestly i really don't care as long as we pick one uh lucas hello lucas again um just i guess adding more flavor to my um not liking connect it's that you know the if you read the spec that defines the connect method it says this is this is how you should handle it and and this is what you do and if you're a server that doesn't want to do that then you you don't and you reject it and you might even just say anything that has the connect verb in in this part of the the bytes that form the request i'm just going to instantly respond with no like this this doesn't make sense on my deployment my infrastructure now if if you add a well actually if you add a upgrade header you need to read that thing and then maybe also look at the contents and maybe decide to do something else it might be too late for them to even bother wanting to change but meanwhile they might well already handle websockets and would just take that parsing path and added a new handler for a new value in the upgrade header and it all makes sense so just from a purely like i would need to analyze this and and understand the security considerations it's it's a no op if you were to use get because it's already been done for some kinds of deployment okay thank you yeah that that sounds sensible to me uh tommy all right yeah i just got in cued to say that i've been convinced by this discussion that we should just go with get connect clearly as problems and as i mentioned in the chat i don't think the overhead of trying to use a new method or even using a method"
  },
  {
    "startTime": "00:54:01",
    "text": "other than get which isn't being used with upgrade today is worth the effort considering that we don't really expect this http one use case to really ever be used in the wild um so it's not worth going through allocations or paving new ways for it thank you tommy yeah i fully agree with uh having less work for the editor because that's me uh so i'd very happily not create a new method uh martin duke um very briefly like um i will just like say get because um of the wisdom of the agents who did it with websockets and maybe there was a good reason and beyond that just like be consistent with the approach we have but more than that this is starting to smell like a bike shed since everyone agrees it's a corner case that may never actually come up we're spending an awful lot of time legislating this maybe we can take it to the list if there's other stuff thanks um phb uh you are muted php no i'm not muted i'm on the wrong microphone we can hear you what we can do i'm just wondering why you're doing 1.1 at all i mean if you if you think this is a corner case you think it's you know you've got a complicated enough spec already why not just get rid of it if people need to downgrade let them sort it out um that that's a reasonable point uh i suggested that a few years ago and we got some pretty like clear working group consensus that we wanted to support h1 uh so we decided to do it accepting the fact that we"
  },
  {
    "startTime": "00:56:01",
    "text": "didn't want to spend too much time on it so um what i'm getting from this discussion is that the folks who were against gets seemed to at least some of them seem to have been convinced that get seemed fine and a lot of whatever we don't care please move on this hurts and i would like to not have to take out the hat of consensus because that always works so i'm gonna propose we go with connect can anyone like really really not live sorry with get with get sorry whoops we i'm going to propose that we move forward with get here can anyone absolutely not live with that okay then we shall go with get thank you very much for our traditional mask bike shed of the of the week and was my next light button not working so fun fact that was the last issue on the connect udp draft that's why we spent so much time on it even though it wasn't very interesting and so this is my favorite slide because it's fun um we've managed to resolve all remaining open issues on connect udp where do we go from here um i'd be inclined to perhaps also move it to working group last call we're in good shape we have multiple implementations this is out in production for some folks can we like start that working last call chairs what do you think our no worries uh thinking that a last call"
  },
  {
    "startTime": "00:58:01",
    "text": "is probably appropriate for this as well let's try to wrap up kind of the issues that we're resolving here today and get that out for folks to to look at but i think is you know when we are rapidly approaching the point of having nothing more to do for this one and it would be good to get that stamped and wrapped up yeah and as with other like you know this is part of our process working group last call also kind of motivates people to read the drafts and i'm sure they'll come you know that'll get a bunch of review which is also what we need so i think we're in we're in good shape okay i that was it with my slides and so as we're clearing that out of the working group i think we can start focusing on connect ip which if i understand it is the next presentation thanks everyone for listening all right hello everyone i'm tommy pauly and i am going to be sharing our other adopted draft which is connect ip or ip proxy support for http and this is a collaboration between myself and the folk at google and erickson who had had previous proposals around connect ap and we had merged the document before and we have a pretty quick update today um so the main change in the last version of the draft was just to update things to align with the changes that you've already heard about in http datagrams and connect udp a lot of it is very much mirroring"
  },
  {
    "startTime": "01:00:01",
    "text": "connect udp um as far as how it uses um the datagram formats how it has support for context or extensibility the existing work we had done for the capsules to negotiate uh the different ip address routes and address assignments not all remained the same as it was before so we really have two open issues that we want to go through today that are interesting problems still to solve and then the other point i'll mention is that we do need more interop testing on this so far a lot of the work has been done around basic http datagrams and connect udp those as we see are getting pretty mature and now i think it's going to be useful for implementations who are working on mask to start playing with connect ip and doing interrupt testing i can say for my own implementation this is again still a to do to really get ready for interop but if you're interested in doing that let's talk collectively about that and prepare for a checkpoint at some interim or at least by the next ietf meeting so that we can get some good experience with this protocol all right so let's dive into those open issues the main one which is interesting is mtu handling and this is something that in general you have to deal with with encapsulating protocols and proxies to some degree uh people need to think about it for connect udp but this is really an interesting problem for connect ip specifically and the problem which uh was raised in an issue that david wrote up"
  },
  {
    "startTime": "01:02:02",
    "text": "cases where you have a small quick packet size that is the actual kind of tunnel and it may be too small to actually hold the minimum mtu that's required for ipv6 which um you know not only is it annoying to not be able to hold large packets but it actually becomes a protocol violation or like you essentially can no longer use this as an effective tunnel for ipv6 so i give two examples here of some of the sizes that you could expect the first one is if you're on a normal 1500 byte mtu link if you do the calculations and figure out how much room you have assuming that you have relatively small stream id numbers etc and packet id numbers you have plenty of room for a minimum ipv6 packet you can actually have a pretty large packet going through here um over 1400 bytes however if you have the minimum quick packet size then you are not going to be able to hold the minimum ipv6 packet size inside it and this is particularly interesting because some quick implementations will start uh with the a minimum packet size and try to explore up which means that there may be times during your quick connection lifetime in which you aren't going to be able to tunnel certain packets and then later you would be able to so this is really an open question and i'd love to hear people's opinions i don't have a particularly strong opinion here of what should we do when we run into this case um you could have a failure on the request stream essentially saying if you are trying to do a connect ip request and you're using"
  },
  {
    "startTime": "01:04:00",
    "text": "ipv6 and the other side knows that it's effective mtu is too small it will generate an error you could essentially fail over by saying if you have these unreliable datagrams going by that won't be able to fit you could make them reliable by putting them inside datagram capsules and spreading them out over multiple quick packets which could have lots of interesting consequences you could have extra signaling essentially within the capsule stream or something else to say hey i'm dropping packets or i wasn't able to send packets and then practically we should probably do this as well as the other things there should be a recommendation that if you are using a quick connection for connecting ip you really should be starting it with at least around 1 300 bytes of mtu starting with the minimum 1200 if you're trying to use it for a tunnel is not going to be a great idea and even in cases where today we're using connect ip sorry connect udp with quick we start with more than 1200 because we want to be able to send large datagrams so what what do people think let's see we have some folks in the queue let's start with ben hi i think that we should uh hold on i'm gonna mute the room i think that the core specification here the connect ip draft itself should should essentially note this as a problem you know be very clear about about the issue here and and essentially note what is required to ensure that the inner stream is ipv6 compliant and not attempt to solve the problem of of stuffing oversized packets in in the"
  },
  {
    "startTime": "01:06:02",
    "text": "case where the mtu doesn't fit i i do think that we should solve that as a working group but we should solve that as an extension to connect ip so to be clear like looking at kind of the options here i kind of interpret that as being like the last one just saying you really should have your tunnel be big enough if you want to use ipv6 otherwise you've done something wrong and you need to figure it out or have an extension yeah that's that's a fair summary okay all right thank you ecker we could just restrict ourselves ivy before [Laughter] um seriously i think again if you advertise yourself that you're an ipv6 carrying tunnel then you have to carry um then you have to carry a minimum to use by packets everything's just gonna fall apart um so um um the um uh so i think that's right question number comes and what what do we do um um you know uh i'm not a huge fan of experimentation reassembly um i i think you know um you know i i'd like to be sure of correction and we actually need that in practice um before before we do it um so i think really the question is you know um distribution between so between these you know between between these options you propose right um the first is kind of like i mean i guess i guess maybe you can imagine doing that if you say like well i can only negotiate 1100 so i'm gonna allow ipv4 and not v6 um it's not like a totally crazy thing to say um though they're pretty gross um um the um um i i don't think we should i don't know the adding capsules is the right answer um so i think um you know this last point is really an implementation point um you know i think i think i guess what"
  },
  {
    "startTime": "01:08:01",
    "text": "i would say is that we should say if someone asks for ipv6 and you can't do you know 1280 and you ought to reject it and then you must reject it and like we strongly advise you to like use it and and so it's your job to negotiate up to the right the right size whatever that size is and we strongly advise you to do that by using large initials but otherwise it's going to take additional round trips so i think that the only the only mandatory piece is that it is that you must reject if you can't carry the ipv6 minimum but then some personalize with strong advice about how to get to the point where you are carrying where you're able to carry that minimum okay so that sounds like a combination of this first line of you have a description of here's how you send an error back if you do the wrong thing but then also focus on the advice of the right way to do it of starting with the larger side that's my suggestion yes great i like it lorenzo hello um i haven't heard of this ipv4 thing that you're talking about but uh the uh so i mean like you have a problem if the link that you're running on and has an empty of 1280 because then you're like the last option is just infeasible you you basically go back to the first one which i assume is unacceptable [Music] i mean like we need something is it is it a doubter attack is it a downright attack if the if the network because like the network you're visiting could be intentionally sending a you know i don't know right like hey my network is 1280 so you can't use connect ip on my network my network my rules do you want that i don't know um or you can now only access the ipv4 internet through this tunnel like i said i don't want to i don't know what this ipv4 thing is that you're talking about so yeah so i think it's either so you you could have a combination which is basically like i think i think the last one is good because it's the one with the least complexity but you have to have if you don't want to do number one which"
  },
  {
    "startTime": "01:10:00",
    "text": "i think you you basically is a downgraded attack then you basically need to have a fallback mechanism and the question really is like once you have the fallback mechanism then why do the maybe you can do the fallback mechanism first and use the last one as an optimization i don't know but you don't have a good solution either way yeah you know one if i kind of combine the feedback i'm hearing from people you know one option would be that we would you know recommend do the last line have a way to fail it as with the default of this draft does but then to ben's point you know allow an extension and another document to describe if you're in an adversarial situation or if you really need to get this packet through because you're on a tiny link but you also need to do ipv6 here's a flag to do something like that number two but that's going to require a bit more work and analysis of the implication of splitting up packets okay rajiv look hi guys can you hear me yeah okay so my you're very quiet for the room if you can speak a bit closer to your microphone again my point here is more on the lines of uh you know we should not be failing any traffic unless it's uh you know an absolute essential and there is no way of getting that paper too especially considering the fact that mpu changes may happen um there may be an intermediary isp link somewhere that goes down and can be routed to an alternate link that just happens to have a lower um mpu and suddenly i'm in a situation where an existing connection you know uh it basically ends up getting dropped because of a complete means somewhere that i don't have control okay and it's not happening at the initiation of the connect that i can take off am i negotiating an mpu uh with my path to"
  },
  {
    "startTime": "01:12:01",
    "text": "the remote because my path may not be starting so i think the correct uh handling for this really should be uh allow the connection uh you know where a parked mtu uh you know issue crops up wherein we don't fit in it to allow segments to fragment and reassemble up that opens its whole whole can of worms but probably pair that along with some sort of error signaling saying hey um your packets are being fragmented uh maybe at uh you know you may even want to put in a hop count or whatever else but the idea is uh to have the uh stender get some notification that yes there's fragmentation happening so therefore there's a degradation in the performance of uh you know the tunnel but the tunnel doesn't fail unless you know it absolutely has to understand and it's up and it's up to the end point to say okay if i see fragmentation maybe i i make a decision as uh one of the tunnel endpoints to drop the tunnel and initiate a new uh negotiation to see if i can probably get the mtu back up maybe maybe a new connect you know bypasses some connection tracking gets onto a different link you know cross your fingers and hope but the point is that uh a running session may degrade because of an mpu uh shrinkage but it should not fail you know that's my opinion on this one question to you rajiv actually before you go um would you be fine with specifying essentially this fragmentation reliability behavior as an option or extension that you could essentially say during setup like i support this that would work that that should work you know"
  },
  {
    "startTime": "01:14:01",
    "text": "again you know the question should be i i believe that um having a flag might be useful if someone wants to explicitly you know disable it but i still believe it should be the default option our default should always be try to get the traffic through uh you know as best you can but if someone really wants to ensure a certain level of performance or a certain level of reliability and does not want partial packets and stuff like that give them the power to turn it off that's all the more power to the you know implementer yeah okay thank you i'm a bit tempted to say instead you know that it's something that would be an opt-in but it can actually be an opt-in that would apply we could also define it for connect udp for cases where you'd have very small mtu's there and you need to fragment data anywhere with similar behavior this makes sense okay thank you all right mike of the opinion that we should try and get it through it seems like if you're already building on top of capsules and http datagrams then having a datagram capsule is a relatively small vist i may be mistaken about that um so i would think the simplest path is to say that your connection should have a large enough datagram or a large enough yeah mtu to be able to carry these without using um a capsule but if you need to then use stuff in a capsule and keep going okay david david gennazi google um"
  },
  {
    "startTime": "01:16:02",
    "text": "my thinking here is that a network with an mtu kind of that that low is for the outer one is kind of barked right um and we know how to handle those networks uh that are borked another example of a borked network it's one that doesn't allow udp uh when that happened we switched to connect ap over http 2. so i like that last approach of saying you know if you want to do ipv6 over connect ip yeah just have initials big enough that if the network is worked we don't use it that way and that's just really simple in practice that's what i think i'll implement and everyone's happy uh like figuring out other things seemed like really complex and given how much time we spend on simple issues i'm terrified at the idea of how much time we'd send on complex ones so let's keep it simple cool uh gory and if people as they're done being in the queue could remove themselves from the queue that'd be great all right gory i'm just joining the queue um the okay so we went through this when we did dplp mtud which wasn't kind of trivial because there was lots of these cases and this is that final case of what do you do when it doesn't work so let's go right back to the beginning i think the last bullet here is the right thing to do you know just send a big packet across it and see if it works of the right size yeah i mean if you need a few extra bites check it out make it work right if you if it doesn't work what what the heck do you do i mean do you want to fragment and reassemble here and then somebody tries dplp pmtud over the top and tries to figure out the fact"
  },
  {
    "startTime": "01:18:00",
    "text": "that it's not broken and then you get kind of brokenness twice or i don't know so there's a warning kind of like don't do this at multiple levels second thing the third thing is um as you go down these numbers especially with ipv4 and udp you're going to hit barriers so if the path changes it will change that mtu if you start getting uh into the bigger numbers so you've got a problem there as well the past might not stop working later on so we have to detect that somehow and if detecting it simply means it doesn't stops working then maybe that's a good signal to the app so maybe simple is okay yeah that you may need to close your stream if your mtu drops yeah yeah you have to figure out lack of connectivity and just close the stream exactly yeah all right martin duke google um as an individual uh so this strikes me is like not a new problem i mean ipv6 or ipv6 tunnels have it and i'm not like an interior guy at all but presumably there's some sort of received wisdom on how to handle this sort of case and maybe we should maybe we should take it um secondly like this certainly quite a cute connect ip this also exists i think is somebody already said connect udp and um i'm i'm i know we just closed connect udp but like if if there's something we decide we should do here like uh i mean we could have a reference which would be sad or we could just like cut and paste the text or something but um this is not just a connect udp problem or connect ip problem rather thanks um what one comment i would have about solutions at other layers of tunneling is"
  },
  {
    "startTime": "01:20:00",
    "text": "you know there is something we need to do here just because with a connect ip request stream it is a bit more stateful as a proxy here and we do need to just know how do we spell the semantics of the error handling in http right yeah can i just jump in as co-author um to answer martin this problem is specific to connect ip in the sense that ipv6 has a minimum mtu of 1280. for connect udp that's not necessarily the case um and so for those you can still have things be functional right yeah for certain use cases but like for instance if it's an ipv6 only proxy uh you obviously have this problem and of course you know as you know with quick if you already know so i like that if it's ipv6 only where underneath or inside the tunnel inside the tunnel that only applies to connect ip i i it's just so it may be a clear and cleaner example would be a a network that only lets you do 1200 by quick packets and then the connect udp you're trying to do over that is itself to a quick server and then you wouldn't be able to get the minimum quick packet size yeah that's the simplest example i'll try and generalize it but as i think about it maybe that doesn't work but nevertheless yeah so clearly they connect udp use cases where it's just plain old gdp running like tiny little packets and you don't care but um there's still a problem here as we're looking here to all tunnels when you know sometimes the tunnel will break your application because of packet size mia coolevin um i would like to at least see or work on a solution that uses capsules we have these capsules we have this reliable streams and just putting some ip packets on that doesn't mean that it's ip fragmentation for me i think it should just work i don't think it's as complicated"
  },
  {
    "startTime": "01:22:00",
    "text": "as we think and if it's easy we should do it okay thank you enzo lorenzo again i'm going to disagree with myself um i think that uh everything should be ipv4 yeah [Applause] um i i think yeah we have this problem i think we have this problem with connect udp unless you want to go into like saying that udp is a stream i don't really know if it is i think it probably isn't um so what i would say actually is um the last one okay so the last one is like all of these are more complex than just to fail but if it's unless failing in any situation is acceptable then we need to then simplifying the implementation means only sporting one way to do it and that basically means number two actually so basically like if you're implementing you want it to work the same way all the time regardless of what happens to you and so like rajiv's point earlier was like yeah the network can send you a packet too big at any time and now the ip stack is obliged to send a smaller packet what do you do to that connect udp do you fail it suppose you return an error to the to the app but that's that's also pretty bad right it's kind of even like a denial of service vector right so at that point you know i think something basically i i i'm going to display my ignorance here i don't know why the the capsule must be reliable you know can you make it like is that the problem so the way the way a capsule works is that these are it's essentially it's a way to put your datagram on the uh this the quick stream on the http stream that is the reliable stream because you're not able to send it within one packet so you have to send it across multiple right so you see so it forces you to enable retransmission"
  },
  {
    "startTime": "01:24:00",
    "text": "is that the problem yeah exactly and there's no there's no way to make it like unreliable just to put a fragmentation you could you will you could introduce fragmentation right like you you could have like a separate fragmentation mode of putting it through unreliable in that that's its own can of forms i i guess i would say like whatever we do however we do it it should be the same thing all the time yeah for implementation simplicity otherwise you end up with these dark corner cases that like you only happen sometimes and you get consider ip fragmentation it's like the the boon for security research is everywhere you know as soon as you look at it there's a bunch of like you know corner cases overlapping you know negative lengths so i think you know might as well just do it all the time basically fragments everything all the time as long as you can get the performance overhead to minimal then i think you're okay i mean the benefit of putting it over a capsule is even though you have the extra re-transmission it's extremely simple and it doesn't have all the caveats that fragmentation would yeah ecker yeah i'm like super yeah about putting it over a little bit more reliable um that changes the entire conduction dynamics once you accept it like we took the packets now um now you've dual conditioning hole made out so that seems like extraordinarily undesirable um unnecessarily reduction control for google engine systems now right um um this is sort of an issue for udp as people are saying but every mvp system i know um either either assumes a minimum i mean so first of all like um you know people don't build gdp systems to play work or ipv6 um because that would be silly and so um so every udp system that i'm familiar with has to be able to handle um you know packet sizes that um that go down the ball because you have to like uh still i mean or you have to just say i'm going to fail over i can people"
  },
  {
    "startTime": "01:26:00",
    "text": "people small ipv4 links right um so like if you look like these you see a lot handshake for instance it's willing to negotiate download below below a thousand um the um i'm gonna say if you if you don't do that you're like operating at like you know risk of life the thing that's not working in general right um um the i mean i'm i'm not on the long run fragmentation it's my knowledge the problems of fragmentation are largely um due to attempts to do um passive packet inspection by um by stateful ip inspectors um and that and because we're encrypting things that's largely not the case here um so i'm i'm most concerned about that um i guess i would also observe that like this is putting them in castles in fragmentation it's like this is a different form of fragmentation that treats them in infrastructure i mean it's inherent in a quick stuff in any kind of like any kind of system that breaks them puts it back together again whether it has retransmission or not that is like a form of fragmentation so i don't really understand why one would think that like it'd be substantially better to have like a reliable like you know i mean in fact there's no data loss um you know fragmentation and um and and and uh you know we just really might reach this mission identify behaviors right so um if i think the question we have to ask is can the system ship at all without having some mechanism for handling in this case um and i think the question and then the question becomes i think you know how bad is it um you know so as we've already just described it's possible to discover um at the beginning whether your path handles this um and the question becomes can your path shift in a way that you do not have you no longer handle them to you and does that cause like some sort of goofy um goofy problems right um you know i think mt was worried about that um i'm perhaps lost worried about it um you know my instinct i think would be to say let's try feeling about this and i see if people encounter problems and if they do we can always add a mechanism for doing this um but i think if we think we have to do something then we should just do we just need to do a fabrication reassembly system because like it's like yeah because it's the minimum change so what one is in there"
  },
  {
    "startTime": "01:28:00",
    "text": "i'm getting a lot of echo ah the the case of doing fragmentation over capsules which i fully agree is fragmentation it's just like fragmentation with re-transmissions is essentially the exact same behavior that you would have in the case that david mentioned of if i start big and i have to fall back i'm falling back to http 2 and http 2 for connect ip only ever sends them over reliable capsules so to that end i could argue that if i'm having to deal with a world where i have to i have a fallback to h2 i already need to handle the performance characteristics and everything else of going over reliable captions that is a reality that we have to deal with well i think with the argument i guess you could i get a fair enough although i think i turn the argument around and say if you're going to bother to absorb the pain of like having his wrist and logic um in this case why not just use h2 um i guess one question one question i think um you know it's like we're worth asking about uh i mean is um you know um is let's distinguish between detection and you know i mean it's like i guess like for one of your taxes what does this actually look like so so i think um you know um so so so you see so someone says you a packet looks like at the bear which is at the very limit before and now and now for some reason books of the past shift is no longer it's bollard or limited right and so packing gets wrapped along the wire somewhere right um you know induces a should be a quick packet right um and um and so um and so so i mean just to recap what i'm saying you think the mtu that you're running over is 1300 but actually it's going down to 12.95 right and so you send a packet that's 1297 and it gets dropped right um and so now so so um you know uh so so now what right um you know um you know uh so so you have to detect that case and you have to fall back to small you have to know to do something"
  },
  {
    "startTime": "01:30:00",
    "text": "right and that thing now something is either start fragmenting packets or start tearing things down right um and um i guess so let's start with that question is how do you take that case and the way you detect that case is by repeatedly not getting acts or packets right at the bare limit right and so um um um and unless you want to do some sort of goofy gtossy thing like somebody gtls does um is you know when it starts it like says like well started like you know at like 1280 and said like two or three times and then it wouldn't work that's too big let's start backing off that's like not really acceptable behavior like an ordinary system right and so um and and so i just don't understand like like it seems to me like that um that that you're gonna you're gonna encounter like four or five round trip times before you realize that you have to start fragmenting or doing some other thing right and at that point like what is that really the behavior we wanted would be better to say like it's going to fail the connection is not tearing things down um so i guess i guess i guess i'm talking myself back into like i think we should just like fail because like i think that the situation otherwise is going to be an enormous other time to respond and the response is going to be kind of a pain yes um and by the time you already lost a lot of packets right i mean you may not have lost actually but you've lost them operationally all right thank you mario yeah me again um so i think there are possibilities to use unreliable datagrams and define a context or whatever where you have like a dependency between different datagrams and you can only develop them if you have them all or whatever that is possible but i think that would definitely be an extension we have reliable capsules here i think it's easy to use i don't see a benefit from falling back to h2 instead rather than falling back to capsules or at least trying to find a solution to fall back to capsules i think that's a tricky part like when you fall back but capsules are easy to use and give us what we need i agree it's very equivalent to"
  },
  {
    "startTime": "01:32:02",
    "text": "falling back to h2 except you just don't have to now bring up an h2 connection to do it um okay rajiv that keeps our implementation simpler um possibility like eric mentioned of using a two or a three or even a five round trip time uh michael just figuring out that you need to start enabling fragmentation all that we're the applications that are using this uh tunnel that now have to understand and deal with the fact that a tunnel that i thought i had set up is basically going to vanish uh you know out of the blue because if some network change it has nothing to do with either of the endpoints right so which means i probably have no visibility on when a tunnel may completely just rip out and die under me and uh all the uh you know error handling p connect all that logic now has to be borne by the application end of things okay so uh you know while it might be interesting to target simplicity here there should be some level uh you know of understanding that if we make it too simple we're not just we're not simplifying the entire solution we're only simplifying our piece of it and pushing the complexity somewhere else yeah so just that point that i wanted to make over there thank you thank you and we have lorenzo again yeah just uh just always do everything in capsules i mean um there's not even a problem traditionally if you retransmit something reliable you"
  },
  {
    "startTime": "01:34:01",
    "text": "have like a compounded re-transmits but if you you know unless you have like really really really aggressive timers above you the app will just see no loss and it won't retransmit it's a simpler code path it runs it's the same all the time it's the same as udp probably simplify the implementation and it'll work all the time and again like the reduce point as well like if you if you fail it uh you can't just fail at the big and you have to fail in the middle and you you basically are introducing the the possibility the app will see an error halfway through just when it happens to send a large packet or whatever or if the routing changes it's super unfriendly to the app and it like increases the complexity of the overall system right it should i think it should just work all the time which means yeah just just do the same thing all the time put them in capsules okay sorry but i feel like after nothing like that that doesn't solve the problem because the problem is discovering when you have to think more datagrams and so just putting them in the capsules isn't enough in the answer you need an answer for when for when the quick connection decides it has to do with duty discovery or something to go back to our datagram and so i can kill someone personally i feel like like this is not like the app right i mean you could certainly do something where you know like let's say i'm doing quick migration and like i know i changed mtu and like the tunnel has like a very clear event then you could easily say okay now i'm going to switch um but yeah it's it's the things that a quick implementation wouldn't right i guess all this thing is like we designed quick right quick was designed like quick was designed like basically the assumptions can use for h3 and like h3 like the world is pretty simple like uh you know if things that don't work it's like like you just tear the connection down and start over again right and like so you know we made it made hand waving it's not about having it work for things that weren't h3 but like we were willing to like accept this kind of failure mode maybe three because it didn't matter that much and i guess what i'm saying is"
  },
  {
    "startTime": "01:36:01",
    "text": "if the the argument we're offering is that um the argument here is that we don't want people to take weird mid-connection hiccups right um then we actually need to find an algorithm to not resolve your connection real new connection hiccups and merely saying some of our capitals does not accomplish that because you're still going to take multiple run trip times before you recover enough to send things in the smaller the smaller datagrams that they actually actually traverse the network and so like i think so i think like if people want to go that route like we need a complete answer that answer has to like just prescribe enough of an algorithm that like under unknown topology shifts which is the alleged problem here um that you apologize you're not not aware of um that you still recover properly because if the answer is like it's no apology shifts just do pmg discovery at that point and if and and if like and then turn the connections down if you don't if you don't use these requirements right so um so i think it has to be unknown to politicians and it has to be fast otherwise like someone just took four on trip times and like not how you're happy about that and and i know about like and the rediscovery i mean the retracement timers on like retired timers are pretty fast like on these end points um once you have established the run trip time so like you know so if we're going to take you know if we're going to take four rtt's to discover this like the other side is going to return that time period yeah okay i think we have drained the queue um we don't have consensus but we do have a lot of good input so thank you for all of that i think it's a very useful discussion um there's a lot of good stuff on the chat too so hopefully we have uh the notes that we can go back to in the video we can go back to and we can come up with a proposal for next time and hopefully also we can have implementation experience and actually try some of this out the one other issue um is related um"
  },
  {
    "startTime": "01:38:00",
    "text": "it's a broader question about error handling um what do you do if you receive a packet um in your http datagram that is something that you will refuse to route so let's say you set up with your capsules a very specific route or a limited route um and now the other side starts sending with an invalid source address that you didn't assign to it an invalid destination that's not routable for you essentially you have the options of you can just silently drop it you can try to drop it and send something back as ip packets within this tunnel as icmp or you can use something at the http layer to send the capsule or close the stream or do something um kind of at that h3 or h2 level do people have opinions on this rajiv here would be to stick with option two uh that most closely mimics what an application would otherwise have seen or if it was communicating on a pair network so you would expect them to already have the to handle stuff like that and deal with that and that also you know brings out the possibility that you know especially in case of a property which is not directly application uh in terms of understanding this natural syndrome translating it into something that you can in turn communicate to the app"
  },
  {
    "startTime": "01:40:01",
    "text": "so this way you know everything just goes as it could on any other network all right thank you corey hi corey first um two icmps are kind of nice um peter can you speak closer to the mic please no i i can re do the mic there we go um two icmp messages are particularly nice ptb if you translate it correctly so that when it comes out it's the the quoted payload is actually the one you want to respond to so it can be verified rather than just a random ptb of the outer tunnel and ttl because then you can as an operator kind of debug and figure out what happened with that tunnel and without it tunnels become very difficult to understand and this is like a tunnel other stuff i'm not really so sure about because i don't know what to do with it so i'll also be my two recommendations okay so again multiple people speaking up for doing icmp signaling and making it tunnel friendly miriam sorry just a clarification where do you send the icmp message isn't it within the tunnel presumably yes right so you would send it on that datagram with the with the quarter stream id to say you sent this to me and like no yeah so why i mean like this is not visible to anybody right so in that case i would rather use capsules um because but it allows i think the the person receiving the icmp to do a very simple thing of you know let's"
  },
  {
    "startTime": "01:42:01",
    "text": "say they've implemented their quick stack behind like a virtual interface such so the application actually doesn't have any idea that it is going through a proxy like it's you're using it as like a vpn tunnel at that point if you reinject the icmp into the stack it could look to the application like they were on this virtual network they get the icp that they would expect based on the packet that they think they formed um and still generate an icp message locally if you really need it right so it's yeah at that point it's a question of does the server have to do it or does the client side have to do it it seems like a dependency to a different protocol which is not necessary to me david i'll just since i'm next in queue go from here so i'm lazy um the what we're building here is sure a virtual tunnel but at the end of the day what it is is an ip link and the internet protocol uses icmp when something goes sideways and so in a way we don't need any normative text here like if like the two sides of a connect ip tunnel are ip routers and those are very well defined components in the ip spec and if a router doesn't want to forward something because of its policy because of its mtu because of anything it fancies the spec says you send icmp so that's like what it comes down to we don't need to invent anything we don't need to really say anything perhaps having some implementation guidance of saying by the way this is how this is done like you know if your stack pops out an icmp packet don't freak out seems useful but like we don't need to design anything new using a capsule or something we already have this in the ip specs"
  },
  {
    "startTime": "01:44:01",
    "text": "yeah me again i agree to that like if we if you want to use icmp we maybe give a recommendation but we don't have to say much because that's like not our business um i i wonder if there's any benefit of silently dropped because like silently drop seems to be an option when there is kind of a security risk or attack risk or whatever i don't think that's something we have in this tunnel so i think it's better to be explicit than being implicit making sure that the other end know it knows what's happening there and if we really want to make sure that the other end knows what's happening there we should have a feedback mechanism within our protocol well we already do and that's icmp why do we need something additional i think she's just commenting on the option one that option one is bad well that's fair but we shouldn't preclude it i mean just like for ip routers there are many different cases where you don't necessarily want to signal let's say you're under load um so like you know giving guidance seems reasonable to me but at the end of the day we're sitting on the shoulders of many hundreds of pages of ip specs no need to reinvent those yes if if you have a have a reason that's covered by icmp to drop it you can use icmp we don't have to care about it's not our business if you actually drop it because um that's not what you requested in in the connect request and like i'm providing you a connect service and i'm i'm believe that like you're not doing what what you asked me to do or like what i'm providing to you maybe it's good to say this explicitly yeah i agree with that that sounds like useful guidance would you second what maria just said that uh silently dropping in this particular context is probably something that would strongly advise the key uh you know in our text"
  },
  {
    "startTime": "01:46:03",
    "text": "either in terms of trying to protect the network integrity under either attack or high load solutions um you know that makes a lot of sense but in the context of a tunnel environment which we are talking about this is a much more uh you know collective use case of general-purpose ip routing uh stuff you you've actually got an environment where you have a stable endpoint at both ends okay and uh you've already negotiated some amount of you know connection semantics before you've started traffic at this point deciding to silently drop smash after doing that seems quite uh you know troublesome for the remote so i guess that you should always have a mechanism where uh a styling drop should not be allowed unless in extreme conditions okay phillip um philip we're not hearing you in the room either philip okay ecker so i was struck by what david did three minutes ago about standing on hundreds if not thousands of pages of rfcs um and you know it seems to me that this this is an aspect of mask okay like essentially like every other teleporter built and um and and as martin said it's like i think her mother like i guess i'm really hoping that we can like you know um that we can uh uh"
  },
  {
    "startTime": "01:48:01",
    "text": "like draw no other documents to behave the way that whatever those other documents saying you want to do says you want to do um so i guess i would i would i would kind of like to um so i'm in particular say invalid source requests like why isn't this just like you know addressable for like ordinary ip address folder right um so um you know it's pc 56 right um so like um you know why can't we just say behave whatever that has to do so um you know um can we maybe just focus this on topics which are distinct to mask if there are any going to behave those in chain and just find those behaviors and for everything else just punt to like whatever the 16 rfc say to do i mean require some research um um but you know um but but like that seems like better than trying to like you know derive a lot from first principles again uh martin duke google uh so it like i guess i don't understand i mean i went back and looked at the draft just now and i guess i don't understand the case where we should where the client could legitimately send a packet with an invalid sorcerer destination address right because those things are specified through the capsules or the host request so right so let's say you do you do a capsule negotiation you say the other side says you can send from this source address and you can send to these addresses but the content of my datagram is a full ip packet and so i can put bad ip addresses in it yes clearly it's physically possible for them to send everything but that is like great i violate what you told me i could do yeah well like i mean close the stream like if people people are are ignoring what the proxy told them to do then i mean i think that's i mean quick is a different layer but in quick like any time you you violated the spec we just we just kill you and i think"
  },
  {
    "startTime": "01:50:00",
    "text": "that seems totally appropriate here i mean icmp is a different world where you know you don't have these pre-negotiated things or the the context for icmp is a network a wild west where like you don't really know where the pact came from and and you don't know what's authorized and what's not but like here all this stuff is pre-negotiated the client is authenticated if the client's misbehaving just kill the kill the stream if not the connection i mean there are certainly other cases where you are you know the other side knows what you're assigned like an ipsec tunnel can assign you something but also your router will know what addresses you can send from um that they've registered so there are other cases where you could receive icmp errors that are equivalent fair enough okay i mean like my my argument for like a general ip case may or may not be 100 correct but i think the point stands that i i don't i don't see the downside to just killing the stream yeah actually if um if the source address is wrong there is another option which means would you would be glass just rewriting it silently without letting the endpoint know um i'm yeah and maybe we should just not um specify it in a way that this option isn't allowed i mean it's not necessary recommendation but in some cases it might be useful and then it would only work if you have a single address assigned yeah uh and then the um other option the other point is when you have the destination address that's not allowed in that case actually just dropping it might be an option because that would be the usual behavior you expect right if a point if an endpoint is not reachable you might not get a reply um however i think it would be nice to at least have some kind of singing mechanism to tell the other endpoint that something went wrong can i uh relay from jabba"
  },
  {
    "startTime": "01:52:01",
    "text": "yes please uh philip says inventing a new mechanism makes the world especially in regulated environments more complicated so icmp inside the channel is a good guidance still if we want to signal bad behavior with respect to the tunnel configuration sending the error as a capsule as a protocol error makes sense and turn it into an icmp on the client side make sense okay that's good feedback okay so much time sympathetic to connection if people behave wrong um i think that's a mistake in this case because um uh imagine the case where you have um the version of connect type basically two networks together um then you while having like any any misbehaving device that which i assure you there are many potentially quite connection be torn down um yeah so that's like um you know um in particular um you know um you know in an imagination where you're actually proxying like like a customer network and you know and now you have like thousands of devices that you don't control and then one of them delicious or non maliciously generates a focus ip and the whole thing is torn down that just doesn't like it's going to have all situations so um i don't think i think again this is like some situation where we're standing on the shoulders of giants and we ought to like steal from those giants and we know how to like i mean like this this is like building a transit network so like she behaves the same but that same one so i i don't think um i think it's i think you know it's one thing to think like if this is like the version where it's like the customer vpn in which case i could agree with like martin but like the customer bps are generating bogus things you know because he's like going and going to euro netflix then maybe you can tear him down um but i just don't think i think that they're all matter i'll concede the point okay oh"
  },
  {
    "startTime": "01:54:02",
    "text": "all right i think we've trained the queue um so those are our two open issues lots of discussion thank you everyone um the only other thing is if you're interested in doing interop and testing let us know these are some of the things we need to work through and we'll see you next time right thank you folks extra thanks to our note takers and jabber scribes and we have now come to the end of our agenda i think we're looking to do some extra interop as tommy noted for connect ip as well as folding in some progress on those issues and with that thank you all thanks everyone foreign"
  },
  {
    "startTime": "01:56:09",
    "text": "know foreign yes"
  }
]
