[
  {
    "startTime": "00:00:08",
    "text": "audio check yeah we can we can see your slides and we can see you that's great uh and we're also on the top of the hour so maybe let's get started already uh hi everybody uh welcome to the transport services working group it's good to see everybody on site or online those who are on site please remember to join me deco to sign the blue sheets and join the mic queue using the full version of mideko will give you access to the chat as well also i don't see anybody sitting towards the back of the room but i hear the acoustics are kind of better at the front if that's an issue um reminder that this meeting is being recorded and by the way my name is rhys engert i go by theresa in the data tracker and various systems my co-chair aaron fogg is joining us remotely and uh without further ado i will pass it to him for these chairs update hello everybody uh can you hear me you're a little bit quiet actually if you can turn it up a little bit i'll do what i can changing at least from here i'll i'll try to speak more forcefully um thanks okay so uh hi i'm aaron falk i recognize some of you in the very tiny window uh uh the president in vienna glad you guys were able to make it uh no well anything that you say here is considered an itf contribution you've probably seen this multiple times itf meeting tips hopefully you've seen this as well especially those folks who"
  },
  {
    "startTime": "00:02:01",
    "text": "are on site please use the meat echo light client to get access to the mic queue and um turn off your audio and video if you are not on site and um i see i should be using a headset well i couldn't pair my headset so i'll have to muddle through with that but it's a short presentation and nothing too controversial here i think today's agenda so um we are almost halfway through the chairs update so we're already making progress on the agenda tommy's going to talk about the quick mapping document uh gorban's going to talk about a new quick implementation pan api we have some time for open mic and uh that's the plan for today and please note that there's video taken of this session it will be recorded and available for later viewing okay a few updates on what's been happening so uh since itf 111 which was some time ago we've had six interim meetings we're trying to meet basically once a month two of our three main docs the architecture document and the api document have received reviews from the art reviews and sector as well as some internal deep reviews um working groups been focusing on uh resolving uh those review comments which were plentiful and we're grateful for getting that kind of external review and uh and we've been focusing naturally on getting the third document the implementation draft um ready for working group last call the last item to point out was"
  },
  {
    "startTime": "00:04:01",
    "text": "the these documents had have many contributors and the author list had grown quite long it violated the recommendation of five authors for an rfc um the chairs and the authors uh discussed this at length um some of the contributors the smaller contributors elected to remove their name from the author list we're still i think at seven authors on one document and five for the other two these are all significant contributors we've got a justification written for that when we submit this to the iesg and i feel really good about where this is right now i'm hoping that it doesn't become a problem for publishing the docs and naturally our area director is up to date on some specifics on the documents themselves the architecture document has concluded a working group last call and that included a bunch of deep reviews and external reviews the interface document in the same state there's still not all the issues resolved but we're down to only two which is awesome and uh the implementation draft is uh i think not quite there yet there's uh still a handful of open issues um but um um [Music] uh they're my assertion and i i think the current plan is to take this document to working group last call after the ietf we'll see if there's any discussion in that um uh when i'm through with these slides or uh and during the um uh the open mic time at the end um one thing that we'd like to do is uh is see if we can get um some non-authors"
  },
  {
    "startTime": "00:06:02",
    "text": "the document during the working group last call and so i thought i guess i should pause here to see if anybody would like to sign up to uh take that on [Music] i think we've found that um it's been useful for sort of editorial continuity and consistency with the other documents and just general quality um so uh my view of the room maybe if anybody is interested in taking that on you could just join the queue it's fascinating reading i promise you besides uh let's see do i have to push something so zad can talk i think i do hello uh so first of two things first of all thanks for resolving the author list issue i mean we have we have really worked really well together as a as a team to resolve that so i really appreciate all the authors and the chairs to actually helping uh on that one um uh so on this this this uh jointly submit jointly together i mean we can do that um do we see any any point of those who completed working last call to go for iitf last call um write the shefford document and eddie reviews and everything done separately and then go for ige evolution together is there any point of doing that just the reason that we elected uh to hold the first document was that um um we were on there's a this these documents have a lot of abstraction in them and um and we wanted"
  },
  {
    "startTime": "00:08:01",
    "text": "to get the wording consistent between them and in fact we've made a bunch of sort of you know search and replace changes to get the wording uh you know some of the term terminology to be consistent uh so uh i would uh um i would i guess uh uh once we get it through um a last uh uh maybe working group last call i guess we could probably release the first two to ietf i can't remember the ordering whether it's isg or itf so but um yes you know uh it takes you as long to review them as as it takes reviewing i mean we've been working on these documents for like seven years so um if you know uh you can spread out the workload in whatever way makes sense to you that's the burden of being an agent so it it makes sense to me just to if we are completing the working last call for taps arc and interface then let's put them forward and then we can also have another part of these issues when in the idea of law school we don't don't know what we're getting there so that might actually help implementation document actually to align with the terminologies and everything that anything we need to change so just just a thought i mean i'm not suggesting i don't have any extra opinion on that one but think about it yeah okay okay yep thank you all right so i'm actually curious who has read the implementation draft so i'm gonna see what a show of hands tool uh gives us in a hybrid setting so i guess people can also raise their hands physically but it's kind of interesting i think the presenter laptop can also raise its hand um say let's say within the past three versions so we have seven"
  },
  {
    "startTime": "00:10:00",
    "text": "raised hands and nobody is raising their hand in the room physically okay eight okay that's um that's good um all right let's end that so do we have anybody who can do a sort of more extensive review of this document in working group last call who is not an author i just uh i think that the just the level said here that the criteria for this reviewer you don't need to be an expert right we're asking for people who are non-authors we're looking for readability consistency you know comprehension um stuff that people who are really familiar with the content are probably going to miss so um if you have not been deeply involved in the past don't that does not disqualify in fact that probably makes you a better candidate for a reviewer all right seeing no volunteers i will take this to the mailing list to see if we can uh beat up some uh volunteer cycles so there is one hi brian dremel uh there is a question from thorben kruger in the chat about when we need this review completed which i'm bringing to the mic because that might be input to whether or not yeah thank you um i would say um ideally uh four weeks after itf um probably roughly the time for our next interim but i think if it um it's uh if we have somebody who would be willing if they had a little more time i'd rather have a volunteer who needed"
  },
  {
    "startTime": "00:12:00",
    "text": "more time than have to waste that potential review time finding another volunteer so okay well let's move on uh you don't need to uh if you think about it uh you can contact uh reese or myself okay dorban is thinking about it thank you norman um moving right along uh okay so a slightly revised schedule um you can see we are here on the left um the general plan uh for the working group our cadence has been to try to have an interim every month we usually meet for two hours and go over get issues and pull requests if we can get the review done by april uh we'll have a working group last call open then and then really the uh interims will continue until we resolve the working group last call comments our general cadence uh we actually i think uh got a consensus maybe it wasn't one of our interims that meeting every itf um uh didn't seem like it was going to be a great use of our time most of our working the interim meetings are quite detailed and um don't necessarily lend themselves to sort of the uh cross-participation uh and so we uh we are just meaning because we uh agreed to meet every other itf so if we continue on that then we would not meet at itf 114 um continue on with our interims and and then meet at itf 115 um"
  },
  {
    "startTime": "00:14:02",
    "text": "uh let me just pause here i people have not seen this before um so if anybody has any comments on it or questions we can talk about that now okay uh and then uh the final uh slide here is um you know we have talked about uh mappings which uh for those of you who uh who aren't closely involved in taps uh you know taps uh is a generic api for accessing uh services provided by transport protocols and we thought that it might be useful to produce some um documents that showed how a a protocol that's sat on top of taps whether it's a transport protocol or any other would make use of uh the api uh and um uh tommy's gonna talk in a few minutes about uh about quick for that uh the general feeling has been you know you shouldn't have to have a published mapping document uh to use taps but this is more of a matter to make it easier for folks to us understand how they would make use of taps if it was available for them and uh so the proposal here is to add a milestone for producing a protocol or one or more protocol mapping documents to our charter we need our area director's approval for this i'm raising it here in case anybody has any comments on it we're going to chat with zayed after the its on it certainly any comments on the value of the um the quick mapping that tommy's going to be talking about"
  },
  {
    "startTime": "00:16:00",
    "text": "uh will inform that discussion um and also whether there are other um candidates and i think that you know a candidate in my mind would be a protocol where it's not obvious how you would use taps to get what you want or maybe there are benefits from using taps that would not be obvious to the you know the upper layer protocol um and um and so it would be sort of a collaborative activity between somebody who has some expertise in the upper layer protocol and folks in the taps working group otherwise why do it in the working group so um let me just pause here see if there's any questions or comments on this or any objections to to doing this there's a comment from martin on the chat that http uh is one where the mapping is pretty unclear and i saw a thumbs up to this slide which excellent thank you i think we can probably find some hp http expertise within the itf um okay so uh that's it for me uh thanks everybody sorry i can't be with you uh and uh let me um hand the baton back to reese if i can figure out how thanks aaron all right uh so i think next up we have our presentation on the quick mapping so if tommy could join and share the preloaded slides please i told me hello hey everyone so you plant the slides okay everyone can see this"
  },
  {
    "startTime": "00:18:00",
    "text": "yes all right um so i'll be sharing a document which i only put out uh at the beginning of this week so after the deadline there was a previous document from a couple years ago where we talked about how you could use taps as an api for quick and it gave a couple different options that was before we had a lot of the formal mapping concepts within tabs implementation and it was also when quick was very much in flux so this is a simpler more direct document that hopefully will be useful as uh both an example of how we can do a mapping um as as well as just showing how we can use taps with quick all right so what is a taps mapping so if you if you have read the implementation document you should be familiar with this but as we see you know most people have not read that in detail there's a section at the end of the document with a bunch of mappings for the transport protocols that were originally analyzed within taps for tcp and udp and sctp but essentially what these are are just definitions of what happens when you use each one of the transport services api calls and a different transfer protocol is loaded underneath so it's very implementation focused as far as you know if you're building this api how do you actually wire it up into the individual protocol calls and it also tells you as an api adopter what the contract and guarantees are when you are using the tabs interface and this is really focused on kind of the establishment tear down and data transfer properties"
  },
  {
    "startTime": "00:20:01",
    "text": "there are a lot of other knobs within the taps api that aren't really transport specific they may just be about path selection or something else so not every api surface shows up in the mapping and from the implementation document we have an appendix in there which says here are the things you need to add or need to define in a mapping document like this one and so it has a template and so this is essentially the first document that's trying to follow this template and show how we can extend it and as part of the exercise of doing this i realized that we needed to update the template a bit we have relatively recently added uh some close group and abort group functions to the overall api to handle tearing down multiplex connections or groups of connections in general and when we added that to the api it didn't make it into the implementation document and so um we actually already have uh merged in a pr to update that and so that was one thing you know that's good about actually using this template and exercising the mapping is that we learn any things we're missing so it's a good part of the review of the implementation all right so going into this particular document it's very short you could read it in you know a couple minutes um it's mainly trying to copy the style that we have in the implementation document for tcp udp and sctp the particular approach for what the mapping is is based on our experience"
  },
  {
    "startTime": "00:22:00",
    "text": "within the network framework at apple since that is a taps like api and it supports quick and you know originally we had had uh various different approaches we were trying this reflects this this mapping reflects what we ended up uh shipping as our quick api and because it ended up being the most friendly for use on top of a taps type extract abstraction one thing i would point out is that there doesn't have to be just one mapping for a given transport protocol the one here that is defined in this document currently is just about quick streams and how to use unidirectional bi-directional streams within quick it doesn't currently address how you use datagrams and it's possible that you would essentially have a different mapping for accessing unreliable data on quick than you would for the reliable streams or you could have it as one so uh there could be you know a broader zoo of mappings that gets defined for different use cases and i think that is okay and as i mentioned before this is doing these building these mappings is a good way to exercise the api functions and make sure that we handle multiplexing protocols well all right so the first part of a mapping is just to define what kind of what are the objects at the high level what are they mapped to what is the overall contract of this and there are a couple different options so first we have to define what is your"
  },
  {
    "startTime": "00:24:01",
    "text": "connectedness of like is this an unconnected like udp is it connected like tcp or is it an inherently multiplexing protocol so quick is inherently a multiplexing protocol so it gets that connectedness the mapping also wants you to find kind of what's your basic data unit offered by this transport and so in this case it is a byte stream and that's why this mapping is specifically applying to using quick streams and not quick datagrams that would need a different mapping and then the last thing here is what is the connection object and this is probably the most uh interesting confusing controversial choice here this is like the main thing to choose um and this mapping defines that a taps connection which is you know the thing that you're used to using as a um a tcp stream like the equivalent of that is a quick stream um which makes sense like when you're just calling like i need an object in which i can create one and send and receive a stream and get to the end of stream that's the semantics of a quick stream not a whole quick connection because a quick connection really maps to what in taps is a connection group it's a bundle of streams that all work together and then the rest of the mapping this is not literally what's in the text the text goes into more detail but just at a high level to summarize what you see these are some of the interesting bits so a um calling initiate on a connection will because this is a quick stream if there's not already a quick connection to the pier it will have to bring that up but if there already is initiate really just is allocating a new stream id on which to send"
  },
  {
    "startTime": "00:26:02",
    "text": "um so it's either bring up quick connection and allocate stream id or just allocate a stream id on an existing connection cloning means you already had one existing stream so you by definition had a quick connection established to the peer so it is always by definition just allocating a new stream id an interesting thing here is that the connection becoming ready which means that you're able to actually send and receive on it is a function of both the actual underlying quick connections handshake completing as well as having enough stream ids available that you can allocate this new stream id so that could be delayed by streams being blocked due to stream flow control uh so ready tells you you know yes you you've if this is the 100th stream you've opened you are allowed to you're allowed to now open that hundredth stream um the listen and connection received calls mean that you have a new stream from the pier uh for sending receiving it's quite straightforward and simple the ascending just generates stream frames on the quick connection for that stream id receiving is handling the inbound stream frames that you get for your stream id closing the connection is equivalent to sending a fin on that stream just as it is with tcp aborting is sending a reset stream closing the group means that you close that stream and then you close the connection once all streams have closed and aborting a group means that you immediately close the connection and you just drop all outstanding streams so that's what is written in the document i think it's the most straightforward mapping too quick from what we have in"
  },
  {
    "startTime": "00:28:01",
    "text": "the taps concepts but i'd love to hear your thoughts or reviews on that yeah so we have aaron in the queue oh sorry stay watching thecube uh tommy um uh your audio is uh gating a lot i don't know if there's uh me want to turn off your video or something because it was distorting uh a bit might be sorry i can drop the video yeah we'll see if that helps um so i was uh uh i was looking for i just scanned the document for the comments that you opened with about sort of the uh the sort of the use cases uh for quick that uh that this mapping addressed uh that might help distinguish it from other use cases that might go to another mapping and i didn't see that and i thought that maybe uh that would be a good addition to the document the um you know what just even maybe sort of a high level summary of what is this good for uh and what is it not good for um to uh help people sort of understand um you know where they are in the zoo yeah that's a good point and hopefully my audio is a little better now um yes it is thank you good what one of the things so yes it doesn't have a lot of descriptive text but an option is that we could also add the quick datagram mapping into this same document as well and then you know essentially say here here are two different mappings real quick and then have some text to couch them and like this is when you use one this is when you use the other so that's if people think that makes sense that's the direction this could take thanks uh next we have brian"
  },
  {
    "startTime": "00:30:02",
    "text": "hi tommy thanks for being up so early to do this um so uh can we go back actually to the sort of the mapping bit um yes so i see sort of what happens if there's like create a new connection if needed so there's a quick connection right so i i get the mapping between connections and streams but there's one thing here that seems to be missing and i'm wondering if that's like at the at a lower level of abstraction that we want to expose through quick uh how does this interact with um zero rtt um is there anything that we need to say in the map yes it is mentioned so this is not exhaustive this is what fit on the slide and was interesting um there is an initiate with send that essentially says this is the same as initiate except right if you're bringing up a new connection and you have zero rtp keys use it okay good thanks thank you next lucas hello sorry hello lucas buddy cloud player um thanks for the draft tommy i had a quick read over lunch good the thing that struck me immediately was like the lack of datagram here i think given the progress that quick working group is making on datagram if you're going to do a mapping just consider datagrams and streams like those are the things that applications can use to just do it as well um contrary to aaron's suggestion i it doesn't seem like we need to say what you would use them for quick doesn't it just says this is what they this is the service that those um things provide and lose it up to other people that decide how to use them um we might be documenting that elsewhere and we could just point at that but i don't feel like taps needs to say anything"
  },
  {
    "startTime": "00:32:00",
    "text": "in particular um and then one specific point on the draft i didn't see anything about stop sending frames before like how to cancel the one one end of a stream i don't know if that was in consideration um at all or just didn't make it into this cut yep um yeah thank you so yeah on the point of including datagram and the reasons so yes i think to be complete this needs to include datagram and i agree with you that we shouldn't go into too much detail about the applications but having a bit of text of you know hey if you're using taps to get a byte stream then you should use the stream mapping if you're doing it to kind of replace your udp usage use datagram we could have some high level bits like that as far as stop sending this is something we have talked about um previously in the group and i don't quite remember but i believe the consensus was it's not something that is included in the base api for taps because it is a feature that pretty much no other transport protocol offers on its stream um you know within network framework itself we don't have an api to do it um it's not something i i guess it'd be good to understand kind of at an application level when is it needed if we believe it's generic because the other option is that you know taps apis certainly do allow you to add protocol specific extra functions if you want to support that in in your implementation but it's not something that you can expect that every uh byte stream protocol would be able to"
  },
  {
    "startTime": "00:34:00",
    "text": "support okay um i don't know enough about taps it just seems like a pretty critical thing for quick to be able to do that because you can't stop things otherwise um you can only close your side uh it's about we can you can always you can always reset the stream right like i mean resetting the stream will can be interpreted as well it can also like the underlying level can do a stop sending as part of that if it needs to okay um let's take it offline um but uh thanks for this work cheers thank you thanks lucas next we have jonathan hello jonathan lennox i guess my question having only briefly read this document and not thought about terribly hard is is this api sufficient to implement a fully fledged h3 client an h3 server or are there things that if you were actually doing that you would need to you know do something magic and maybe a network framework you've actually done this you know concretely or maybe you can just think about it but i guess my question is is this because i think that's the where the rubber meets the road for is this a complete api for quick or are there things that this doesn't cover uh yeah so we we definitely have built h3 on top of this there are i think the one thing that is used there that's not explicitly part of this mapping is what perhaps would consider like a protocol specific metadata to access the stream id numbers etc from within the transport um but so maybe that is something that would be good to add to the document of saying hey and you also probably want to expose a quick specific getter for your stream id but beyond that um this mapping for actually just using center receive create and close all work"
  },
  {
    "startTime": "00:36:01",
    "text": "fine for h3 thanks next we have martin uh martin duke google uh thanks for this um i've been waiting for it and i support adoption uh not that we're asking for adoption yet um but let me preemptively do that uh just a couple of nits like i mean on on the abort call uh it should be like reset stream and or stop sending depending on the direction directionality of the stream and like on the listen thing it seems to like say well open a socket but in fact listen is being used for receptiveness to new streams as well correct but conceptually is that accurate or um yes it is it is yeah so we can clarify that okay thanks thanks brian uh hi uh brian trammell google um i'll be brief because uh i think we're getting ready to go down a rabbit hole here uh i would point out on the quick datagram thing datagram looks kind of like sockseek packet which does exist in another protocol so i think that we can sort of like you know take some of how we've thought about sctp into that and i think it is probably important to do right like so we said we're going to do the quick base protocol but datagram is rapidly progressing through quick but i think these are things that we can do once it is you know a working group item uh look forward to working on it uh since we're not talking about supporting adoption yet i support adoption cool i mean the last slide does say should we adopt this so that is a useful question to answer okay next colin hi uh can you hear me yes yes"
  },
  {
    "startTime": "00:38:00",
    "text": "okay good uh so i i guess i'm gonna take something similar to what brian started out with um i can see how this can be a replacement for a bunch of tcp connections very easily i can also see how we can define this in a way that acts as a replacement for udp and provides security and all that on top of it um are we flexible enough in the way we've defined taps that we can ask for a connection which allows you to do both reliable and unreliable data on the same connection so you can have basic streams right i think that's where kind of what the mapping of connection objects uh turns into under in quick is very important so i think the answer to your question is yes a taps connection group which maps to a actual quick connection association between these two endpoints can include both bidirectional streams unidirectional streams and datagrams each of which would be a different taps connection object to represent that particular flow in that particular um contract right so it's a little unreliable connection to this point yeah exactly yeah okay thanks uh and we have michael and after that uh he was closed michael herzl um i wonder if these two things that were brought up regarding the interface and quick if they i mean i don't want to make things harder for the interface document now for sure but if they maybe should should be included there because i think the stop sending frame is probably safe enough to ignore for transports that that don't support that"
  },
  {
    "startTime": "00:40:02",
    "text": "and the stream id i remember we had a conversation about that in the context of sctp because that also offers it but we didn't see that there's a need to expose that if people are associating semantics with the number of the stream but i think that's also pretty easy to include as saying you know it could be metadata going on the connection if it's a stream multiplexing transport so i i think we should probably include that in the interface draft but i'll i'm asking that question i i would lean towards saying that you know for sure in the mapping document we should call out you should have a way to access the stream id and we should review the interface document to make sure that it's clear it sounds like you know what function you use to say you know get me the protocol specific information for this because you know the specific type of a stream id or one of these things could vary between different protocols so there should just be a way to say like for quick get me this property and then you say oh the i want you know quick property stream id and then it returns me an object which happens to be uh variant in this case yeah okay yes okay and we have the head uh transport eddie hat off i have one comment so we we used to have like those are ourses now we have to survey document and the feature document right the documentary service couple of transport protocols and also the transport features and recorded them so i think it would be good to have this this kind of mapping document also to actually have some sort of like background information and a surveys around it not just like direct mapping uh i didn't find it this time it would be good because uh some of the topics that i"
  },
  {
    "startTime": "00:42:00",
    "text": "think lucas was mentioning would could come up here and we could have a resolution in this kind of mapping document how to deal with those instead of like uh filling around already like long big documents so that's one comment i have think about it and that's the solution with my eddie hat on i don't find this uh as a related document in the data tracker so something went wrong so maybe uh we should we need to fix that yeah you i think i think the naming of the draft didn't allow it to record as a related document in the data tracker so maybe resubmit it with drafts tommy probably taps something well you should be able to the chair should be able to relate it directly as well yeah that's the truth okay i'll look into that uh thank you zahid uh and at this point i'm curious to just get a sense of the room for uh the first question on tommy's slide which is support for adopting this mapping document okay we have 21 raised hands in medical 25 oh wow and no physical raised hands i guess midair coins uh okay that's not bad thank you um so tommy is there oh yeah should we start others is actually the second question on this uh slide we we kind of have two minutes uh and then we have another presentation with 15 minutes allocated so maybe we can take this offline unless"
  },
  {
    "startTime": "00:44:00",
    "text": "brian has something urgent because we do have two minutes brand travel google no not yet let's do this one first i agree so cheers eddie interruption again i mean two things one if if there is anybody in this room who has not really used this uh online site tool or some way to log into this session they will be not part of the blue sheet so please do that and also like i will not pro and use your hand raise of hand virtually this time i think that's the that's the what we want not really raised in hand room so i think if you if you log into the system net ecosystem you will be able to register in a blue sheet and also raise hand there thanks thank you for the reminder side all right so i have associated uh the mapping dock on the data tracker so thanks all right and now i think we have slides up for torben if you would like to unmute and share audio hi am i audible yes i can hear you great all right um thanks for having invited me i guess um i'm going to talk about our panapi uh system which is a taps like transport system that we are developing um and there's already been some discussion about this on the mailing list and yeah and reece was so kind to invite me to give a talk um and here i am uh we quick although this is not exactly visible this talk is split into two parts i'm going to talk a bit about the system that we are building and then um i also have some feedback that might be valuable or might not be i'm not sure so who are we um i'm a phd student um at"
  },
  {
    "startTime": "00:46:02",
    "text": "the nexus lab um network and distributed resistance lab at the ottawa university in magdeburg germany um and our research group is mainly focusing on zion um as a promising future internet architecture um i think many if not most people here have uh at least heard about this but just in case there's here's the really quick repack recap um simon is a proposed new dead architecture designed to eventually replace bgp it exposes path awareness and multiple features to each end host and it has already seen a pretty wide deployment at least among certain industries so the financial industry in switzerland seems pretty keen on it but they are internationally there are more deployments um and the project is spearheaded by the network security group of etheric um cyan has some interesting implications and so we asked ourselves uh what benefit can pathways actually have on the end host so the actual user probably doesn't really care the internet usually works just fine most of the time and the average application developer probably also doesn't really care or rather simply wants to use a high-level networking lab library and not worry about the rest [Music] as networking nerds we most likely are the only ones who care uh and we would probably be the first to point out that um interesting new networking features should not complicate the lives for users because networking should be a commodity like tap water right so it should just work um so if we are interested in rolling out any new features this has to happen sort"
  },
  {
    "startTime": "00:48:00",
    "text": "of behind the scenes uh and hidden behind higher level abstractions and we were very gratified to find that the tabs community at the itf seems to agree and hold similar views so we decided to create a transport services system for scion but not only for cyan and we chose the proposed tabs api as our front end in the back end we have some highly scriptable environment that allows us to experiment with the interesting networking details um and to to that allows us to try out certain things like different capacity profile based path selection behaviors and so on um we managed to get ngi pointer funding for our system uh and we decided uh to call it panel api or panapi for a pathway networking api in case our lack of creativity wasn't already obvious yeah the system is written in go with a web-based scripting back a backend that supports lower scripts it also supports tcp udp and quick as well as udp and quick over cyan and we have been trying to follow the tabs architecture as much as possible but we have made some design decisions that are somewhat departing from the way that things are laid out in the drafts first of all we are obviously had to add science support in a way that is sort of in the spirit of the tab spec although tabs is very internet specific um we do not use an event"
  },
  {
    "startTime": "00:50:00",
    "text": "system because a goal already comes with different native ways to do concurrency uh properly um we try to have an event system but this turned out to be highly unintuitive and since we are in a sense developing an api uh that is meant to be used for the by the average goal programmer that doesn't want to worry too much about networking we decided to not uh like force an event based system on them and simply allow them to use idiomatic go as it's called um so we avoid the the old system of trying and failing by having all calls uh block and until they can either return success or an error if we need asynchronicity uh we can simply dispatch these walls in the background as required um [Music] the go primitives are really uh well suited for this and we have already had some discussions about the details of this and whether this is in the spirit of taps or not on the mailing list um i forgot to link this here but um yeah the the discussion is on record uh the second major design decision is that we have chosen to represent the different properties in form of in a strongly typed objects and this has turned out to be a bit of a nightmare but more on that later the idea is that we want to catch mistakes at compile time and avoid errors at run time which is in the spirit of the our chosen programming environment and language and uh yeah this is these are the the core um tenants of our design um [Music] i'm happy to receive feedback on this"
  },
  {
    "startTime": "00:52:01",
    "text": "after this presentation but for now maybe let's move on this is an example of a code that demonstrates how we how we are using this or how we have decided to to translate tabs concepts to our system you can see that we have mapped some properties to static types we do ubiquitous error checking and we don't have there's no event system in evidence then briefly we also have a back end um that is uh right now a science-specific back-end daemon um so meaning that for regular non-scion communication the ap api works just fine as a standalone library and in case there is a demon present and we are communicating via scion there are rpc calls happening between uh the api library and the demon we have uh support for path quality estimation and scriptable path choice um and optionally our backend can also perform active latency measurements um over certain paths and we found that most tabs concepts map map pretty directly to scion at least in in our opinion so we're quite confident that we are not under mining top semantics in any way so in the in the scion world different capacity profiles for instance can be satisfied by selecting suitable paths after considering cached path performance information similar to what the standard semantics are the same is trivially true for different"
  },
  {
    "startTime": "00:54:00",
    "text": "multipath policies which simply result in message duplication or distribution over different paths and other properties like session isolation are have have corresponding semantics um there is at least one thing that we sometimes use in the site in scion that does not appear to have a taps equivalent which is active probing namely something [Music] where we perform active pings over alternative paths to a destination and to just keep track of which which are available or promised to offer better latency than the currently chosen path and i would be interested if this is something that could conceivably be added or if this is something that should stay very much sign central so this continues the first part of my talk i hope everything that i've presented sounded reasonable enough to you i'd be happy to receive your feedback and opinions about pitfalls and both in general and specific maybe we can also talk about maybe having a scion mapping as rn proposed but i would propose to shift um the actual discussion into this uh to a later point since um i have some feedback of my own yeah and you have five minutes until the end of the session yeah so um there's uh i i previously mentioned that we have had some pain with uh with supporting the different property types in a statically typed way um and so and with their scope and their validity so on the left you see a quote from the api draft and here the properties are"
  },
  {
    "startTime": "00:56:00",
    "text": "meant as configurable parameters for protocol selection connections and messages and it's all sort of semi lumped together but not quite and sort of they're they're distinguished there's there are certain boundaries which are um which could be more explicit let's say um and on the other hand on the right hand side um you there's a quote where it says that um properties sometimes or at some point have sort of converged and can be queried so they have converged from um a preference to a boolean so from from an enumerated preference to a boolean and the documents do not disappear to distinguish between these two stages that the property can be in it can still be a setting that can be modified and this is currently still not not has not converged and it can be a converged property that that actually reflects the result of a selection process and we found that this is um that when when trying to implement this properly we sort of need to have this clear distinction between the two stages um i think right now the drafts are mentioning that um the preference can first be in this sort of preference state or probably in the preference stage and then at a later point it congeals let's say to a truth value and this is a very very let's say dynamic way of looking at this so in dynamically type programming languages this is easy but in statically typed programming languages this is really hard and maybe it's worth thinking about how to maybe conceptually distinguish these the second piece of feedback is a small nitpick so if you're remembering the um"
  },
  {
    "startTime": "00:58:01",
    "text": "the discussion from the mating list um i try to justify why we didn't use an event-based system and people were quick to point out that it's somewhere in an appendix it said that uh it's valid to implement this in a different way uh also and it would have been really nice if this had been clarified way earlier and this went more visibly so we actually wasted quite some time trying to get a shoehorn an event based system into this yeah into a a goal-centric uh way um but in conclusion uh it has been a pleasure to work with uh um taps and the work that you guys have been doing here um and i hope that you guys have interesting comments to what we have done so far and thanks for listening thank you jordan we have michael in the queue hello michael westley again um we have been around that block of selection properties morphing into booleans i believe that the reason they were unchangeable afterwards is that we didn't have a case of a selection property that would make sense to change afterwards like for instance you require a reliable transport you don't you you can't change that afterwards i i don't i i don't disagree uh that properties at some point become immutable it would just be nice if this was actually sort of uh being if it was a clear distinction between properties that are still mutable and those that aren't yeah but i i believe i believe it didn't have any i'd like to ask the remaining speakers to confine your comments to 15 seconds or at the end of our time let's just try to go quickly"
  },
  {
    "startTime": "01:00:00",
    "text": "take it to the mailing list so maybe you know if there's one concrete case where you think it would make sense to change it afterwards maybe you can propose text or make a suggestion but i believe we just didn't have a case i see okay okay okay let's uh drain the queue but we're running into overtime we have jake could i just ask you to go back to slide 9 and explain the address passed into the remote endpoint is yeah so this is a cyan address um this is the format of a sign address the 19 is the isolation domain the thing that looks a bit like mac address is um the the and the as address and the last part is the as internal ip address and the very last part is support okay thank you okay and brian uh yeah so uh thurman you asked a question earlier does this make sense is it in the tap spirit yes yes this stuff is awesome totally okay to not do it event base totally okay to do things um go like we've actually seen another um go implementation of this that was i'm just going to throw away the all of the naming because it should be called dial because it's go right like so this is i really like how you did this here um uh michael addressed your first bit of feedback your second bit of feedback has now been filed as issue 1009 uh and i hope to have a um pr for that by the end of the break so um yeah you're right we'll fix it i'm sorry we wasted your time uh you were talking about this thing yeah the event driven api stuff yeah i'm going to fix that right now thanks a lot yeah and we can also discuss the other one in an issue in a github if we would like uh yeah i hesitated i hesitated to open an issue because um it seems like this this uh draft is pretty much mature now um and so i wanted to discuss it first"
  },
  {
    "startTime": "01:02:02",
    "text": "for all an issue if it's if if like if it's too late it's too late if these are cheap and they're easy to close okay thanks so we are out of time uh aaron did you have any last words last word is uh think about whether uh what other tapping mapping documents might be uh useful and send suggestions to the list so thanks everybody for coming great discussion today yeah thank you everybody and i think we're gonna have an interim in maybe early may let's see yes [Music]"
  }
]
