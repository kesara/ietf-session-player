[
  {
    "startTime": "00:00:06",
    "text": "[Music] see share preloaded slides did you click on the your next your name the share screen and then you do share preloaded slides yeah except i haven't seen the agenda slides yet no here they are great we do have a pretty to the minute agenda so um i say we get started yeah so um we'll just kind of write minutes later based on the recording yeah i'll just do that it's worked out well so far so i'll just do that later after i'm starting to do taking minutes now so um thank you perfect okay awesome all right uh yeah shall i start here then i guess i usually do this please yeah please all right welcome everyone to to pym here in vienna except most of us are not in vienna um yeah we got the full agenda let's see got the note well hope everyone has seen that it's the same as it's been a long time [Music] the negotiator agenda so two first presentations will be about uh dr solutions so we should try to compare those solutions and see"
  },
  {
    "startTime": "00:02:00",
    "text": "what to do whether we want to stick with one or merge them or maybe go move forward with both or at least we need to figure out what we want to do then we got yeah the point to point policy ping which is the working group draft we got the pim light which has been presented before uh now there are several pretty new things let's see the snipping yang um that's some something that was taken out of the sleeping yen previously to to be able to publish without waiting for references but now we might want to move forward with this and then there's several other new proposals proposals as well um looking at the working group status we got the pym yang model it's still in the rfc editors queue it's been there a very long time it's still waiting for some final references i assume [Music] okay um we got the uh sleeping young model which finally got published so that's great um we got the bfd pointy multipoint use case published as well so making progress because the igmp mld extension draft which has been approved it just needs the lazy offer which is me to do a final update before it can be published um yeah i'll send an email to that working to the working group later i guess about what changes wherever yeah we're going to make no nothing too dramatic then they got uh yeah the dr drafts that"
  },
  {
    "startTime": "00:04:01",
    "text": "are presented this meeting a gmp mld proxy yang we probably requested publication of that um since more drafts here like the the packing drafts we also requested publication [Music] um a few drafts not presented this meeting we need to look into the igmp base again but yeah nothing this meeting there's also an elite draft that got adopted that is not being discussed and um the po point point point to multi-point policy ping will be discussed that's that's our status any comments on this [Music] there is someone i'm hearing like a buzzing i don't know if you're trying to say anything or yeah no idea just ignore until it gets worse and i'll have no idea where to do that yeah okay um so shall we just uh start with our first first presentation let's do if sandy's available let's go [Music] [Music] let's start with him he's on both drafts yeah yeah let's start with um the second so you pull my by the time yeah so i think you should be able to control your own slides and if you want to but let's see no you you you can"
  },
  {
    "startTime": "00:06:01",
    "text": "present that's right yeah well i mean i think anyway let's see ready so we can go to the first slide yeah so yeah just just tell me when to when to go to next yeah sure so good morning good afternoon guys so the first first thing is to talk about the problem statement so this basically our current pim rfc it talks about how to elect a pimdia in the land and in this case we are showing that r1 is the dr and it could be based on ip address or based on its prior configured priority now what happens that when there is any failure and let's consider that r1 fails amount of time it is going to take where r2 rr3 is going to take over as a new dr it depends on multiple factors and some of the factors are first thing is to detect the failure how fast we are able to detect that there is a failure and then depending on the hardware capability how much time we are taking to reprogram the routes and then how much time we are taking to rebuild the tree and again rebuilding the tree will totally depend on how diverse your network is so there are many deployments where these kind of mechanism doesn't work pretty well and they don't want any downtime because in this case if you see"
  },
  {
    "startTime": "00:08:00",
    "text": "worst case if we don't have bfd and we just rely on hellos we are going we may take up two minutes to even detect that dr is down so there was a need for some kind of mechanism some protection mechanism where we could really do fast failover and that is where this draft comes into the picture that how can we come up with a backup dr which which can keep things ready in case of failure we can go to the next slide now coming coming to the backup dr election how how exactly we should be doing backup dr election so what this draft talks about that to have a very simple mechanism so i'm i have just pasted from 7761 that today our dr election mechanism is based on our priority and our ip address so so everyone whether it is r1 r2 and r3 there are exact same algorithm to identify whether i am eligible to be dr or not so what i am saying instead of doing some extra signaling between these routers why not to run same algorithm and now you find if you are the second best so in this case when r1 runs the algorithm r1 knows that r1 r2 and r3 all three are in the lan and priorities are 190 and 80. so r1 picks itself as a dr now when r2 is doing running the same algorithm it knows that it is the second best router so in case you are second best router you definitely can qualify for backup drlx backup dr now the role of backup dr is to build the tree all all the way to source and you may backup dr will be getting the traffic as well but backup dr is not going to forward it to the"
  },
  {
    "startTime": "00:10:00",
    "text": "access and backup dr is going to forward it to access only when r1 fails it is it is kind of when you change your rule from bdr to dr that is when you start forwarding the traffic the benefit of this mechanism is now all the states are already ready as soon as you detect the failure maybe there will be bfd running or some other mechanism where you can really detect the failure very fast and you will be immediately able to start following traffic to the access so this kind of provides a mechanism where you will have minimum traffic loss so this is the mechanism of backup dr election next so that was one part of draft the second part of draft i think which we started uh discussing over email is stick idea behavior and why do we need stick idea so again there are deployments where they don't want to have dr election happening in case of any new order comes into the network it could be accidental conflict or it could be maybe customer is really trying to bring up a router which was earlier which was up and running which went down and now it's coming up back in in this these cases you don't want your dr to change and the reason for that would be again the kind of churn which you are going to see in your network so just by just because of one new router coming into the network or some router [Music] kind of went down and came back up you don't want so much churn to be happening in network and that is where there are many customers who are looking for a sticky dr functionality where once one router has been elected as a dr it should just stick to the whole network so to stick to that particular router unless it fails and that is where a sticky dr"
  },
  {
    "startTime": "00:12:02",
    "text": "requirement comes next slide now sticky dr procedures again we were thinking about it that how how can we do with very minimum protocol extension so the one of the step which looks pretty straightforward and easy to do is so first first step is let's have dr election as it was happening today so in this case r1 r2 and r3 they have three priorities configured so priority 100 is the one who is going to take over as a dr so there is no change in dr election procedure next step and now this is this is where something new we are trying to define that once you have taken over as dr we are looking at r1 now announces its priority as mdr max when i say pdr max so basically we can have a reserved number our reserve priority which is really the max value which should not be user configurable value and it is kind of a r1 is getting a sigma 4 that now r1 gets that max value r1 starts announcing its own priority as this highest priority now what benefit we are going to get out of it when r1 starts sending this mdr max priority no matter who is coming or who is going in the network it is never going to change the dr behavior it is not going to cause a dr reelection but to remember that even though r1 has been configured with priority 100 now it is announcing a special dr priority next now when sticky dr fails or the router which"
  },
  {
    "startTime": "00:14:01",
    "text": "was dr earlier fails so what is going to happen so in this case when r2 r3 detect that there is a failure they are going to rerun dr election and if there was a vdr vdr will automatically take over and now r2 is the one who is going to start sending this new dr priority at this point of time what is going to happen even if r1 comes back so r1 priority is configured priority is 100 but r2 is announcing pimd or max which means that r1 will never take over because r1 is always going to run its dr algorithm against this drmax priority next so implementation wise yes this this particular sticky dr behavior has been implemented and deployed as well next and uh with respect to ayana consideration i was thinking and maybe we can definitely discuss whether this should be just a user driven approach or we can reserve some range of values from the india so mdr is if i remember correctly it's 32 bit value so there was a thought that we can reserve some uh towards end some values which you should not be allowed to configure and we will use one of the number as a max dr value and the second second thing which needs to be discussed we really should we even send any flag with hello saying that i support pim stick idea because if you see in this behave this current approach i don't think even any capability exchange is needed because if there are there are other routers who don't support sticky tr if they are not dr"
  },
  {
    "startTime": "00:16:00",
    "text": "at first time they will never take over as dr because the whoever becomes a dr and supports ticket here will start announcing this max value and this max value will always be honored so i don't think there is really need for hello unless working group thinks that there are some cases where announcing option capability option in hello is going to be good so i think that's all let me go to next slide if i have anything else yeah so if there is any question uh i have just a single question here you are proposing you seeking ctdr or how about your bdr 5 if you have another router just come and then have a higher priority than the car with the pdr are you going to have the sticky bdr or not so i have i don't think there is a really need for a sticky bdr as well but if there is a if there is a real need i i don't see same same algorithm working for sticky bdr as well but in that case bdr has to as i said if we are reserving the range of max value then bdr has to be less than the dr that's all okay thank you sandy hello yeah yeah okay thank you my question is um i magmana for his presentation but i think that the contents described in the slides is not the same with the draft so i'm not sure on whether nankamana will update the draft to this solution"
  },
  {
    "startTime": "00:18:02",
    "text": "or keep the draft as the same as the as exists yeah thanks for this point so yes draft is going to be updated okay thank you danny do you want to directly con present yourself yes may i yeah we can discuss the combined uh discussion after your presentation that the one question that moncomata didn't get answered however is the whole pmdr max value do we need to add that um so maybe we can discuss it at the end yeah go ahead okay uh hello everyone i'm sandyson from litty and this presentation is for the same background of makabana structure for pmdr improvement dropped this chapter has been adjusted according to eddie's suggestion since washington next please the problem statement is the same with magmala's pro presentation but i can repeat it maybe you can make it all clear and so according fc 7761 the router has the highest the priority will be the dr so if working dr or the link between the dr and the landfills anudia must be elected another case is that if a new router with a higher priority connects in a"
  },
  {
    "startTime": "00:20:02",
    "text": "working lane the new router will be the via so the the there is packet losing during the switch next please so according to the problem statement we know that it makes the network more stable if we can keep their unchanging and we may also call it a sticky solution and a new bdr rule is needed the new bdr can be in standby mode and it takes over the dr's responsibility in case of drca note forward flow next please and so the solution defined in this draft introduces two new options in pim hollow message that's the difference between this structure and the mechanics draft they are the two new options are they are option and the pdr option and this solution will change the priority carrying function defined in fc 7761 whenever a router which supports supports this solution starts to work in a lan it should send the pin parallel message with the two options set to zero when hello hold the timer expires the router receives hello message from other router if there any monitor checks the hello message from weldon neighbors if it finds that there is their option set to non-zero value it won't elect itself sdr even if it has a higher priority but it still can be the video if it has the highest priority among the routers except there if there is no existed deer in the land then router has the highest"
  },
  {
    "startTime": "00:22:01",
    "text": "priority will be the fear in case there is a router since the hollow based message without a dr or dr option then all the routers in the land must use the function defined in fc761 to elect the deer the vr will be instead by mode the button not forwarding through until it finds at the dear count forward flow next please and so let's see what happened when all the router starts working that all the routers send the team hollow with the drpr option set of zero and they also send their their priority when the hollow hold timer experts the router with the highest priority will be elected and the bdr will be elected also all the daughters the hello message with dr bdr option set and let's see the second situation there is a working dr in the land already and rotor with a high priority connects in the net the new router sends the team hollow message with drbdr options set to zero and it also sends the their priority when the hello held timer expires the new router receives the hello message with dr option set to the working dr's at best it only replaces the working deer but it will be the bdr if it has highest priority among all the other routers except working there finally all the routers in the name will send the hollow message with the same value of dr on the bdr option set next please once the video is elected the tier will join the multicast tree but it won't forward the flow until it finds that the deal account for the float the video can monitor the dr by bfd or other detection"
  },
  {
    "startTime": "00:24:02",
    "text": "methods next and so this is a summary of this solution it has a bdr role to reduce the time of multicast tree rebuild the sticky dr and the fastest switching of video can minimize the packet loss the convergence time of dr election will be one hollow hold time and the solution has explicit signaling because the two dr bdr options are defined in hollow message and the election result is certain because either the router which has the highest priority is elected when all the router starts to work in the lane all the working deal would be replaced replaced even if a new router connects the lamp with a higher priority this solution is compatible with fc7761 and the function defined in fc7761 is used once a router sends a hello message without a new option okay that's all so so now i think we can talk about the difference between the the two solutions yeah i in my opinion the main difference between the two methods is that pimdia the improvements has explicit signaling and the the [Music] fun methods defining bdr draft has no explicit signaling accepted the max priority value so i'm not very sure if the max priority value has been used in somewhere or i'm not very sure and but uh i think the"
  },
  {
    "startTime": "00:26:00",
    "text": "experience with the deployment will to help with it so we have these two drafts that we've adopted as a working group the idea is valid we think it's a worthwhile effort to be working on and we understood the different solutions which is great so we either continue to progress these drafts on their own and update them like mankamana said he's gonna update his draft i guess the problem is that it seems like there's continuing creeping overlap between the giraffes so we need to try to avoid that do the would the authors of the different giraffes prefer to keep them separate is my opinion the non-stocky methods defined in video draft is useful and it can be used in the network but it has no explicit secondary but it still works and the the methods defined in existing bdr structure cannot be used because there are as many problems with it i also stand up the questions in the mailing list apart from today's math minus presentation we know that the solution the sticky solution for vdr is changed so i think only we can discuss is if we whether we use explicit signaling or no x explicit secondly yeah yeah i feel uh the main thing really is that we i think we agree that we need a solution for sticky they are and that's the main place i think where"
  },
  {
    "startTime": "00:28:00",
    "text": "these two you know documents both have a solution and they are clearly very different so ideally i would like to have a technical discussion like yeah like the email you sent sadly to the mailing list to to find out which which method actually is best you know what what are the pros and cons with each other the methods uh is there a need for both for them or is is one better than the other in some way um but if we pick a solution then yeah the question is do we want to have a yeah i guess we want to have a draft with just one sticky draft from sticky dr solution right that the working group picks um or if you want two solutions of course it could be two different drafts i know um but we need to have a technical discussion i think probably on the mailing lists but yeah with all these with all of your offers working on this i am also wondering though if it if it makes sense to have possibly a um i don't know um merge the documents or have a new draft whatever with all the offers together or that's that's a different matter i want to focus on the technical discussion perhaps on the mailing list and i think the time is up now for this one yeah i think we need to get going one thing though yeah we need to get something someone coming out the draft updated so that we have a good way of comparing the solutions and discussing them on the mailing list yes i will say okay all right thank you thank you yeah thanks so i guess uh uh just quickly stig or i"
  },
  {
    "startTime": "00:30:03",
    "text": "will initiate a email on the list and then please start contributing to that so we can come to a resolution and human is up next okay so this is the point of multiplan policy ping nexus right please okay so just a little bit of update and i don't know why it's cutting on the side but from draft point of view in in this solution when it comes to the replication segment and the point to multi-point policy itself uh we are almost done with the with that work there are a little bit churn on those drafts so talking to the co-authors maybe we start doing last call on those two on the yang side uh we haven't done any work on it so you know i would appreciate if the working group has started looking uh at the yang if they have any comments please bring it forward so we can start updating those i'll try to revive that draft in the spring again uh but yeah any comments over there you know i would greatly appreciate it so we can have a you know good yank um on the mvpn side again we are working on it i think that's best uh we are working on it we are trying to make the draft complete i think the next one i'm guessing that's the pce so yeah that's zero zero the pce has been adopted uh right now there are a couple of vendors that are working on the pce messaging and that's why it's just stuck on zero"
  },
  {
    "startTime": "00:32:01",
    "text": "zero uh probably in the next itf or the one after uh we do have some implementation so there's gonna be more uh churn into that draft so uh you know some of those changes will come forward on the pce side um the the next one is the idr which is the sr point to multipoint policy uh we just uh asked for uh adoption call uh and there was some good support so it should be okay the last day is actually today the 24th so we'll see what happens there and the last but not least is the pink which is the this draft which we are working on in this working group so that's a little update of what's going on with this point to multiplying solution from all draft points okay now oops i wonder if i did something wrong there uh yeah i was just trying to see if i can get it to look better but it doesn't look that way oh sorry yeah okay so what we are trying to achieve here as everybody knows when it comes to point to multi-point policy and the replication segments it's a pce solution so there is no signaling on the network itself on the line on the fibers itself so it is crucial for us to understand what the failure is within the tree going from the root all the way to the to the leaves of these of this puppy so basically the point of this draft is to come up with the oem mechanism that is capable of testing the tree for each candidate path again a little bit of reminder on the route you can have multiple canada paths"
  },
  {
    "startTime": "00:34:00",
    "text": "that they are redundant and the active candidate pad is the one that has the highest precedence uh any other candidate pad is staying there as inactive and based on the failure when the pce or the controller for that matter realizes that there is a failure on the active candidate path it will switch to the backup canada paths if you will so each one of these candidate paths have a trio for its own through the network they can be set up accordingly through the network they can be srlg meaning that they can be completely separate from each other it all comes down to the controller how they want to set up these uh canada paths through the network from the root all the way to the host sorry to the leaves so that said we need to be able to test every one of these candidate paths now there's a second concept under the candidate path uh and that concept is what we call the path instance so basically if a candidate pad needs to be uh optimized then we can have two path instances under the candidate path that the second path instance will be signal through the network through an optimized path and it can do a make before break procedure on the route to switch from one path instance through the second pattern sense so you keep that candidate pat up and running which is your primary cannon pack so this draft will introduce a mechanism to test every single one of these canada paths and every single one of these path instances under the canada path next slide please yeah let me try to to share the application here instead i think okay sure let's see um okay i need to let's see"
  },
  {
    "startTime": "00:36:07",
    "text": "let's see uh yeah oh much better thank you okay yeah okay right okay so um yeah or are you do you want to move on to the next slide right yes please thank you so uh yeah sorry look um okay here we go so uh when it comes to the uh packet construction and the the the packet format we didn't reinvent the wheel there's already rfcs in there for mpls encap which is rfc 4379 and 6425 we are basically reusing those rfcs and i guess one point that i'm trying to make here is that this draft is only for the mpls end cap when it goes to the srv6 oem stuff then there is a draft in the six man which is the oem for srv6 and we need to come up with a new draft that reuses the srv6oem packet format to uh to introduce oem functionality for point to multipoint three in the srv6 domain i guess one thing that we did identify into this draft is the target fake so we did identify the point-to-multi-point policy target fake that identifies this packet to the oem"
  },
  {
    "startTime": "00:38:02",
    "text": "layer saying that this is really for point to multi-point policy and the tlv to identify this oem packet uh if you could go to the next slide please and i realized the slide numbers are wrong but my apologies so yeah so this is the the tlv that actually identifies the packet as a point to multi-point policy oem packet and there are some questions here that we need to address i did send the email to the mpls working group asking that as of now as you can see uh the root address can be ipv4 or ipv6 root address and as of now we are using the address family to identify the length of the root address to be 32-bit or you know 64-bit depending on whether it's ipv4 ipv6 so one question is does it make sense to come up with two different tlvs one for ipv4 and one for ipv6 and drop the address family or you know one tlv is sufficient enough and you know keep the address family but the length becomes variable in this case so that's one thing that you know if you have opinions on i would greatly appreciate if you can feedback me or to the to the authors uh so that's that's really the story of what's going on and you know um and forget about the next slide obviously i'm in a security so that's update on this draft and all the other any comments questions did that uh email go to mpls and pim or just mpls and uh good question i i replied to everybody on the last email so it should have gone to pim i'll double check i'll double check as well but uh thank you we'll get we'll respond or hopefully they do"
  },
  {
    "startTime": "00:40:02",
    "text": "actually okay thank you see we have the same problem with the next slide so i'll share my uh share a window again let's see so probably it's the way i printed out then because i just grabbed power points and i print so maybe that's i did something wrong okay so the next one is pim light um basically what i'm trying to achieve here is to have the working group to come up with a baseline for this draft there there was a lot of conversation emails back and forth on the on the working group email list which is great uh but i think we need to agree on the baseline and what do we want to do here and based on that agreement take it forward and see what we come up with so next slide please yeah um let's see that's very strange yeah let me try to to to fix this just a moment um see yeah let's do it this way thank you"
  },
  {
    "startTime": "00:42:00",
    "text": "so um uh yeah sorry let's see all right so a little bit of history uh this uh draft uh well this idea came alive when we were doing the last car for beer pim signaling uh basically in that draft what we wanted to do was to send the the multicast estate join and prunes from one beer edge router to the next beer edge router and in the draft field explained that we are only sending uh joins and prune messages as a signaling from 1b router to the next one and then the question became that since these are packets are very close or identical to pim joints and prunes maybe we need to identify a brand new pim interface that could carry only the pim joints and prunes without actually trying to bring up a pim adjacency between the the routers or two peers for that matter and that's where the idea was born so basically we are not trying to complicate the story here all we are trying to do is and multicast states or remove the multicasted states between two pim routers that are attached either directly or via some medium and that medium can be anything it could be beer it could be any other medium and then the next question is if there is no hellos because we are not bringing up the uh we are not sending pim hellos it's just the estates then some of these messages uh like asserts or some of these other messages that are really relying on the hellos might not get accepted or processed by"
  },
  {
    "startTime": "00:44:00",
    "text": "the pim routers accordingly as well so next slide please uh yeah so basically uh again as i explained uh as of now depending what happens in in this meeting uh the entire idea was just to come up with a new interface whatever we want to call this interface that only is capable of sending a couple of messages including joints prunes and maybe asserts and to have the other router accepting these messages even though the fact that there is no pim adjacency or the pin hellos between the two routers uh next slide please so there were a couple of well not couple there there were a lot of discussions in the working group uh which i'm bringing up in this slide uh so just to refresh everybody's memory one thing was the name um some people didn't like light uh you know some people were saying it's light transit etc so we need to come up with a name and the next thing is there are conversations again if we can use hellos from other type of protocols like igp to revive that hello messaging between the between the two uh router so even though we don't want to send the pim hellos on this specific implementation can we kind of piggyback on some other type of protocol to make sure that the two pim light routers are still up and running and communicating with each other and there is some kind of heartbeat between them i guess the next question was as of now in the draft i mentioned that"
  },
  {
    "startTime": "00:46:02",
    "text": "when it comes to the joins and prunes and asserts those are the type of messages that are accepted when there is no pim hello so you know one question was do we really need a cert in this type of scenarios whether there's gonna be duplicated traffic and if there is duplicated traffic whether assert is the way to go to actually avoid that duplicate the traffic uh there were other comments with regard to the multicast to say that we need to identify the the states that we want to uh signal over this medium sg star g etc etc uh and and the last but not least was you know what is the interface itself itself uh we you know if it's pim light interface uh do we need to explicitly configure this interface because of security point of view and do we need to only accept the joins and the prunes on a medium that has this interface connected to it and if so in some of these mediums like beer you cannot really create an interface so what do we want to do there yeah so i guess we were hoping for a you know quick dirty way of making identifying this brand new interface and making it use in the beer draft but it might be that we created a bigger hole which we need to kind of figure out what we want to do here so i i think i'm going to pause on this slide and let it digest and you know if there's any comments or questions you know now there's the time tourists has one for you yeah so my recurring wish that i don't get for 30 years now um so if we have an upstream interface with a multiple possible senders of traffic and when we're doing a cert right now we've we've"
  },
  {
    "startTime": "00:48:00",
    "text": "termed a strong rpf to be able to filter out the packets based on who sent them we never did this because that's layer 2 filtering right you would need to know which of the upstream pim routers would send something but for example in beer we also have that right we have the brbfrid in the header so even on a beer site we know who sent it whether you call that strong rpf or you have a virtual interface on a per upstream bfr id and you're effectively you know changing your rpf interface so that you at the pim level representing not a lan but you know for every upstream um bfir a separate point-to-point interface i mean that's that's that's a modeling question but in the forwarding plane you obviously want to receive a packet and filter it based on the bfr id in the packet if you know the vendors think that can be done i'd be very happy because that would get us rid of a cert but i don't believe that will ever happen sure so uh yeah stick here so um with beer you don't have a shared medium right so i start swings work anyway um if a smaller router is forwarding something you would only reach it receive it if if you actually have asked to receive it right so um so the concept of a search only really really works if you have like a shared medium like an ethernet or somehow simulating that so i think it should be possible to say that uh this pimlight mechanism does you know doesn't have doesn't support a search but it's restricted to certain types of links or interfaces that's also why you don't need the dr priority why sorry dr election right for these other questions [Music] i don't see a problem with an rp"
  },
  {
    "startTime": "00:50:00",
    "text": "an rp doesn't need to anything in particular when it comes to neighborships um and for the interface being enabled i think it's fine to say that certain interface types say like a beer interface it's enabled by default uh it's enabled by default okay yeah i got you okay um so i think most of these can be dealt with pretty easily just need some text explaining exactly what the applicability is so of the pim light and explain why they don't need to need to worry too much about assets and smaller things okay okay so that that sounds good so maybe oh there's another comment sir go ahead cindy hello hello do you hear me hello okay uh i do support the motivation of this draft because i think the team over beer deployment will may be very widely used in the future so i do support this structure but i think the last discussion is very useful and some details must be added in the draft right so it will make the implementers more clearly about the solutions yeah about the name of the pimlight interface or something else it doesn't matter for me yeah okay thank you"
  },
  {
    "startTime": "00:52:04",
    "text": "okay so uh maybe the way forward is uh we'll wait one more ietf uh you know uh if everybody can ponder about this slide specifically uh and and based on the emails that we receive we'll update the draft and you know um in the next ietf we can do another presentation and you know see whether we can adopt a draft or you know how to move it kind of forward kind of thing um that's that's where i am right now i i think uh uh you know i in the next sorry can i go to the next slide my apologies yeah so i i think from what i'm hearing there is somewhat of an agreement we need to put a little bit more meat into the draft which is fine i'll work on it you know send your comments into the what what we just discussed so i'm getting old you know i might forget some of these stuff so please send it into the email uh working group email i'll uh i'll put them into the draft and the next itf will take it and we certainly don't need to wait to the next itf unless you want to sandy can certainly initiate an adoption call on the list okay appreciate it before then yeah okay thank you uh hi mike if you'll hear me yes yeah okay uh hello hello everyone i'm hunty from ireland now let me introduce a new individual draft about"
  },
  {
    "startTime": "00:54:00",
    "text": "hmd's moving young model standard for l2 vpn next week and this is the first version for the presentation and the effort is from the mankasi on design team uh the all servers and also that from everson ibm dream pro and china mobile netflix now let me introduce the relationship with rc-9166 uh the rc-916 define the young data model for configuring ignp and mld smoothing but it only but it only covers the and then hmpm smoking in the bridge service and this draft was published that um maybe february this year it's just published last week this first were this rfc was the hmp smoking young model draft and it was included the alpha european part for igmp and mld smoking and enter into the rfc and queue in august to 2020 and but it was blocked in the misraf state more than one year because of a non-tail reference to the atf by cell to repeat young this draft in this draft it will define the l2 review model but but but this draft uh has expired on maybe january 2020 uh this is not an active draft now uh so"
  },
  {
    "startTime": "00:56:00",
    "text": "we asked for our group last call in the in the pink in the pink working group for removing and removing the alkaline alternating part in in september 2021 and it passed so we uh so we removed the alternating path for the shaft and not long afterwards and this draft was published as uh rc rc9166 nice please uh but we think that but uh the ignpm while this movie could be used in lgbt service so we think it is still needed to be covered in the young data model so we make this new individual graphs and also and also the same as the authors of rc9166 nessles now let me introduce some details of this new individual draft first the m router interface for alteration and in amphitheater there are two types of ambulatory interface interfaces and it could be called the ac embroidery interface and pw amplifier interface we can we could manually configure the memory interface uh ac or pw and we could also uh and this amazon interfaces for automation could also be uh learned dynamically uh when they added uh when when when the"
  },
  {
    "startTime": "00:58:01",
    "text": "i'm sorry interfaces are they now they learn this um and they are read only and nicely second and there are also two types of uh outgoing interfaces for alteration [Music] we could manually configure the outgoing interfaces under the htmp smoking instance they are easy and finally uh the necessities similarly and these uh outgoing interfaces could also be dynamically landed and they are and they are read only nicely and now uh in order to uh use the snooping instances in the alteration uh the l2p uh the htmp smoothing instance and i mailed these two uh so in order to use the snooki says in albuvier we argument the level instance of cyborgs as african and the instances could be referenced that could be referenced in the algorithm service uh like below that's all the uh all the updates of uh that's all the key points of about this uh individual draft uh the next page and that's the uh that would like to apply for the uh working group adoption and welcome any"
  },
  {
    "startTime": "01:00:00",
    "text": "more comments thank you i think you want to go first i guess say that again no just waiting for you no i don't have a question i was just going to do initiate a uh adoption call on the okay well okay so one one question uh the the ltvpn draft that they were waiting on is that is that progressing now uh no there's no uh progress now the latest version is has a pair at uh in january 2020 um right so it means that if we move forward this with this it will get stuck again i guess but i i still think we should move forward though so the contents of this draft is basically exactly what we agreed to publish before right is is the content is the content of this shaft exactly like the model that was in the previous drafts right yes yes yeah okay yeah thanks so right now we do have 10 11 who are showing adoption agreement for this draft hongji and none against so um i think that's fairly conclusive"
  },
  {
    "startTime": "01:02:01",
    "text": "we'll send an email as lit as well we're up to 12 now but i think you can safely assume that we will adopt this draft so for the record we're at 15 right now in favor and none against then i'm gonna go ahead and end the session thank you very much all right thank you okay okay let's see next new song hello go ahead go ahead yep yes go ahead issan okay okay hello there everyone i'm isung from chain mobile and today i will present the p pim mflr based on the trfa this is the second time to present this draft and the next slide please firstly i will give the brief introduction of this draft and as we know and the pmfr it's a very important protection mechanism for the multicast deploys it can minimize the packet loss when the failure happens to the multicast parts but in the rfc 7431"
  },
  {
    "startTime": "01:04:00",
    "text": "it can only use the rfa but rfa can only cover part of the network develop topologies [Music] so there are some uh kind of uh the topologies and it cannot cover and the trfa can help the unicast fr to achieve the almost 100 percent uh network capability uh coverage so uh we are in this draft we provide a new mechanism by using the tfa for the pmfr and it's no need for the additional extension of the pin protocol just to use the existing pin features and this time we we update the jobs as a informational drive and that is a recommending recommendation for the uh multicast protection deployment in the sr networks next step please sorry i can't see this line oh okay and the first uh firstly uh is the mfr based on the rfa that is uh has defined the at the arabs in rfic 74-31 so the uh ability to to build the backup multicast tree just according to the normal uh protocol procedure of the rfc 70 77 61 the next slide please"
  },
  {
    "startTime": "01:06:02",
    "text": "and we come to the uh rfe rfa and the pqt it the pq node for the rfa and uh for the unicast it will uh establish the uh unicast tunnel to protect the unicast traffic so the typical we can use the pmrp vector attribute we can look the pico node at the first part of the backup multicast cheese root uh so firstly we can uh uh build the first the first part of the tree and the when we when the uh pq node select the example at the example uh r3 and we it will remove the vector and then it will uh establish the multicast tree according to the multicast source directly next slide please so this is the tfa for the unicast fr in the sr1 networks and the draft uh trp has defined the solution and the unicast traffic can be protected according to the sr repair list and for the example uh in the picture uh the the repair list uh including the"
  },
  {
    "startTime": "01:08:02",
    "text": "a node seed uh from the p node and uh the adjacency node adjacency seed for the uh p between the p and q so uh we can uh we can get the second at least uh to uh to protect the unicast but how to use to the pim join the next slide please uh fortunately we we have uh we have uh defined uh the features for the rpf vector attribute and the explicit rpf vector attribute for the node seed we can use the rpf vector attribute let the r4 in the picture for the r4 in the vector we use the tab 0 of the joint attribute and it will uh look up the unicast routing to the r4 and hope i hope to send the pim joint from the r6 to r4 and the the second uh the second vector is that the exclusive rpf vector attribute that the tab four of the draw attribute it will uh it will not uh look up the unicast routing table and just specify the p upstream neighbor so when the pim john received by the r4 and we it will check the type 4 attribute"
  },
  {
    "startTime": "01:10:01",
    "text": "for the r3 and will directly send the john to to the r3 and after the kim jon received by r3 and it will remove the vector and and in the jump packet there is no uh vector now and it will continue to establish the multicast tree to according to the rpf uh uh of the multicultural source directly and herbert hope to establish the uh remaining backup multicast tree so that's the method of using the sr repair list to to establish the uh mofr backup multicast tree next step is so that's all and any comments thank you east song is your goal to continue to work on it and then oh sorry human go ahead yeah just one question i wasn't clear uh in in the slide that you're sending the joins uh are those going over the segment routing or or are they just like going over the interface oh did just going over the interface it just"
  },
  {
    "startTime": "01:12:00",
    "text": "use the segment routing as the segment list as the reference to the rpf okay but but then the part that gets i'm still confused is when the traffic comes from r6 and goes to r5 and if the r5 if you are not tunneling the traffic and the r5 says that no no this is not the best path go back to r6 how are you mitigating that issue like how are you going from pspace to cue a space without the ps base sending the traffic back to r6 oh this also according to the pin protocol and the state for the sg okay r6 will uh we'll send the drone to the r5 and r5 we will we will create the sd state and also look for the r4 s3 so so basically what you're saying the multicast i guess part i'm confused about the multicast traffic is never going over any sr tunnel it's just being forwarded yeah yeah yeah yeah okay my money costs the traffic never never to the sr other parts nils is there a question can you hear me now yeah okay great"
  },
  {
    "startTime": "01:14:01",
    "text": "yeah um i also have a question um from my understanding of mofr this is a live live communication so you will receive on our sixth um the streams twice so um i'm i don't know if i'm just um thinking too far out in your example but looking looking at the example that you've given here with low bandwidth routes this this this really seems a bit uh like constructed um is is there a real life um demand behind this or is this more of a theoretical and educational rfc uh this is a information of the information dropped and we just uh re recommended this uh mechanism in the sr networks if we use the pim traditional pim for the multicast okay yep okay thanks okay thank you stig may have to make a call on this draft going forward since i'm draft right yeah so the draft looks interesting"
  },
  {
    "startTime": "01:16:00",
    "text": "to me as well um i wonder um i guess we can do uh we can do a call i wonder whether we you know whether people understand really enough what's it what's in the document or or not but maybe maybe most people have read it and get it um let's we can we can try a poll and see you may do that or are you doing that i can yeah maybe you can do it okay i'm trying to figure out how here but yeah a little under the weather today yeah yeah you're a hero for being here do you guys see the results like i'm seeing it i'm seeing it at least is can a non-chair see what i'm saying i'm guessing not it's not fair if you can see it right before i would think maybe well right now we've got 14 that have raised their hand in support against so yeah so um well there's definitely a lot of interest but yeah see we have you know a couple of people against as well so so i would say we need to take it to the list"
  },
  {
    "startTime": "01:18:01",
    "text": "we need to understand you know why some people are against it as well and also possibly why people support it uh but at least we have a lot of interest so uh we should definitely go ahead and do an adoption call on the mailing list yeah so just for the notes from when i do it right now it's 15 in support and one against then i'm going to end the session great thanks now we now uh now we have a few drafts and it looks like we've got a decent amount of time here that all have some something to do with uh point to multipoint uh srv6 and related ideas and so um waymo is going to be the first one he's just getting back from presenting in another working group so he's a hero for getting here quickly yeah i'm here i'm here you hear me great yeah thanks so hello everyone i'm going to talking about multicast using multicast routing head next page the existing solution based on sr include srp 2mp policy and our previous draft there's a v6 ptop pass which we have received lots of comments from the working group so these existing solutions have some weakness and the multicast using multicast routing overhead is a good alternative which takes"
  },
  {
    "startTime": "01:20:00",
    "text": "these comments into account and also is more scalable next page so basically each link of a node has a link number which is local each node in the network have a table this table maps link number to the last hop address of the of the link a multicast tree is encoded by linked numbers the increase of the tree in caps the mycast package into a multicast routing header for each subtree from the desktop of the ingress and then send the package to the next hop and then finally the package will reach to each of the eagles node and at the transient node after transient nodes receive the package transient node just gets each of the linked numbers from the uh matrix routing header and then find the next hardware address from the link number from the label table and then send the package to the next home at the equation node equals nodes just recap the package and then send the package to the ip multicast forwarding module next page so this is the basic encoding of multicast tree we're just encoding the tree every every link on the tree and then each link from node u to d is encoded by three views link number field indicator link number unknown to you the lumber branches is the number for links we lost the slide stick"
  },
  {
    "startTime": "01:22:00",
    "text": "can you refresh i refresh i can see the slides is this yes then the third or not the previous one previous yeah yeah no no the previous one page page yeah this one page four okay the third field is a point to pointed to the sub tree from b so for example for link from ingress from p1 to p1 the link number is 2 and then the number of branches from ge1 is four we have four links from p1 and then the number 22 as a point pointed to the subtree from g1 so next page so for the which is for the equals node for the link to the user node those are number of branches and the point are all zeros and then we can introduce a flag l to indicate this linkage to eagle zone and then we can remove those uh two fields lincoln number of links and the pointer to the sub tree so in this way we can reduce the overhead for example after receiving the those two fields for the link to the equals note we can use 16 bytes to inc include to encode 14 notes three the trigger with 40 nodes so next page so in addition to that improvement we can also remove the link example field using a bit bit set one indicate that the beast number will be used"
  },
  {
    "startTime": "01:24:01",
    "text": "to encode the encoded link numbers from a node b so for example we have subtree here from p3 to p4 to [Music] pe4 to p mark p7 so in this so those links from e4 can be encoded by bit strings and also we have a p flag indicate that those nodes in addition to represented by the beast number and also indicate that the light swap is a leaf nose so in this way we also remove the l bit in this case so in this way we encode the subtree here just using four parts so next page so this is another example to use use the piece to encode the part of the sub tree so this in this way we just when visa is used and then we also remove the link number link number field so we further improve the encoding so next page so we come together we have a encoding for a whole tree so we use certain bytes to encode the whole tree so when we use this one and then we in english english node we just includes the subtree from p1 so in fact we only use eleven pad to do the forwarding that's the overhead next page mud has rolling head the mud cast rolling head is a rolling head with a new routing type"
  },
  {
    "startTime": "01:26:01",
    "text": "this header is similar to sigma rounding header it will contain a subtree from an ice hop and then we have sl we are pointed to the sub tree we have field mb which is the number of branches or lamp links and then we have bit to indicate whether whether the bit string is used for the links from knightshop on the english english note of a multicast tree will encap a package in a mud cast rolling header for each next hop and then send this one to the next hop the mic rolling header will include subtree from next hop and then the english node which just set the fuse such as sl mb and the b in the multicast rolling header to the corresponding value to for the link from english node to the next hop for example here mb will get the value from this uh cycled one which is a value corresponding to the link from english node to e1 next hop and then just set send this package to the microsoft which is p1 next page so after p1 as transcendent receive the package so it will send a copy to each of its last hop for example for electro g2 v1 just sets the fuse bmb and sl in the header to the corresponding value for the link to the next hop and then deliver to the to the next hop that's very simple without any modification inside of the tree included"
  },
  {
    "startTime": "01:28:01",
    "text": "in the in the header for egress node for example for from from p1 to p8 which is the eagles node we just set sl to zero and then deliver the package to the equals node after receiving the package if it is a equals node which is indicated by sl equals zero zero equals node just the capital package and then send the package to the ip multicast for the module i'm done so next page yeah i think this is the first street fold and the symbol and then i would like a comment and also if possible i would like a requested option called as a individual contributor to this draft it would also be helpful if this would probably be something that we need to discuss of course further on the list but um bob hinden did mention to us that the uh so waymo presented this in six men as well this week and bob mentioned to us that the header format and processing would be okay for six man to discuss but a whole the whole notion of uh this multicast routing header that waymo described would be better in the work group that's focused on multicast and that's why he's presenting it here so if we were to ever take up a this draft six man would then work on the actual um uh processing and the header format it probably would be kind of similar to"
  },
  {
    "startTime": "01:30:02",
    "text": "what uh newman did very successfully with point to multi-point draft and having a replication segment defined in spring and then the stitching of all those um segments and a policy done here so it's kind of a rough equivalent to that so just wanted to throw that in there but you're going to have to drive the stick right uh for this stuff i feel like we probably need people to you know give people some time to read it carefully uh this this is uh all new right so [Music] i i suspect not too many people have really started it yet so uh yeah i would say let's let's have a let's follow up on the mailing list and try to try to um try to have some discussion there it would have been nice if you could ask how many people have um read it perhaps but if it's worth having a poll just for that okay i'll do that and robin's got a question okay sure okay uh okay robin from huawei so my comments is that later we will provide some this compilation between the this solution and the premiere this solution yes yes progress this p2mp that's the uh i sr solution that uh that dropped us also to encapsulate the p2mp3 okay right you're right so there are a couple of"
  },
  {
    "startTime": "01:32:00",
    "text": "or different solutions here right yeah so we may have to give it some time to you know have people understand all the different options so ten people have indicated that they've read the draft and yeah i've indicated they have not so there you go yeah yeah okay thanks yeah i think let's uh let's get all the you know all this potential solutions yeah um first and then uh we need to you know discuss them a bit more carefully to find out which solutions look the most promising so i would say let's just take continue discussing the draft on the mailing list but we uh yeah we should work towards evaluating the proposals and finding out which which solutions would look the best uh tallest oh i'm just waiting to uh present right yeah let's let's take it to the list and uh twirl us next step can you still share the slides so i'm not sure that uh yeah oh i know you can easily do it yourself but i i got it here now yeah okay so presenting um what yeah uh alternative option or but whether they're exclusionary or um amend each other i think that's that's another interesting question next slide okay so um what what we want to have is"
  },
  {
    "startTime": "01:34:01",
    "text": "a native ipv6 srv6 solution for point to multipoint that is stateless homan already done all the work for the state full ones with the replication segments so this is intended to be part of the srv6 architecture for networks with only ipv6 and srv6 so where the operators do not want additional layer 3 forwarding planes for multicast that are not ipv6 and we want this as much as possible to be well as little changes over you know what we're doing let's say with the sra chatter for for path but just the same thing for multicast replication and there is no such solution the ietf today um that's unicast only srh but we already saw one other proposal to do this so um and in this proposal the core property is really of the encoding of the compressed tree which we call recursive bit string structure next slide so the recursive bit string structure is shown on the right hand side that is um in the blue box the whole address structure as it is seen for on the first router a and that router a simply needs to examine a single bit string that is indicating the adjacencies on that router a to which it should send packets so in this example here it has four possible adjacencies two of them have set bits so that is an adjacency to b and adjacency to c and so what router a needs to do is simply do a lookup of these bits in the bit string and then for each of the copies the new work is that it needs to rewrite um that compressed address so that only the subtree for that particular neighbor is the active address for that copy being sent and active means it could be rewritten so that everything is thrown away except for"
  },
  {
    "startTime": "01:36:00",
    "text": "that subtree or it could be pointers that basically say here the active part of the address is just that subtree and that is i think a little bit also the question with six men because uh shortening um an address is something that is not officially endorsed by um rfc 8200 but it's also not prohibited so we're fairly you know not not opinionated on that but let the iatf decide what would be best next okay so why do we want this so all these wonderful traffic steering things we can get out of that right so the [Music] prerequisite for guaranteed resource path with bandwidth and latencies when we have a pce and admission controller it's great for the path diversity with the zero loss multicast for net with pre-off it's great for minimum cost steiner trees capacity optimization through non-ecmp load splitting which is pretty much today in unicast 95 percent why customers are using segment routing so the ability to engineer this path in multicast trees would then also mean that you can utilize the capacity in the network for multicast equally better as you can do with segment routing for unicast and then of course also and that's maybe uh even more going back to the original routes predictable and simple convergence there are no micro loops that we're getting with the hop by hop reconvergence through the igp when we're not doing source routing so now that's all traffic engineering that we get through the traffic steering of uh indicating the tree but even if we compare it to just flat bit strings that are not encoding the whole tree we do uh think we get scalability benefits and those come simply from the consideration that this working group and the original protocols we did right pim sparse mode kind of our biggest success"
  },
  {
    "startTime": "01:38:00",
    "text": "is based on the predicate we've got a large network and the multicast delivery is a tree is small so we're only sending to a relatively small number of receivers in a large network and so there is the simple thought example without a good picture consider you have a network with the 2 560 destinations egress pe's and the service providers um you have flat bit strings of 256 bits which is kind of some existing technology and you uh want to send to 10 destinations well if you have flat bit strings you might be unlucky and you send 10 packets because all these 10 bits that you send to are in 10 different bit strings um so your replication efficiency is sent to 10 destination if you're lucky it's one packet if you're unlucky it's 10 packets with flat bit strings and if you use this rbs scheme um in the validation topologies that we used you can get always away with a single packet because you can always encode for any combination of 10 receivers any tree within just you know less than 256 bit of rbs3 so that so even rbs does encode the whole tree it is in our opinion uh even more efficient in many cases than any flat bit string option and of course that example did not even include the overhead of encoding the tree and flat bit strings so so we think that this recursive bit string structure is of all the proposals the best compressed version that gives the best replication efficiency next slide so here again um in a little bit more detail hopefully that can be read it's a little bit too small for me i guess uh here um hopefully it's better on the large screen how do we encode and process so all the length fields that we're using are in bits so that we're efficient if a router has n neighbors"
  },
  {
    "startTime": "01:40:00",
    "text": "then the bit string to be examined on that router has n bits um so in our example we had four routers so we have a fib with for rbs which we see on the right hand side uh which has four bit entries um and uh each entry has the address of the next hop which is what you know in the usual segment routing fashion would be the destination ipv6 address in the outer header being replaced um and then we have another column that says whether that particular neighbor is a leaf or it's an intermediate hop if it's an intermediate hop then it means there is a recursion field which and that's shown here in the middle in the address there is a subtree for that particular neighbor and that is then what's going to be extracted as the address to the neighbor if a neighbor is a leaf then of course that neighbor doesn't need to get any further address but the packet can just be sent to the neighbor without any further rbs address so as far as processing a concerned single flat bit string lookup on every node and then an address rewrite which is adjustment of pointer or extraction of a part of the address and making that the address so we also think this is uh the least amount of complex processing in the forwarding plane of any of the compressed options uh that we have seen next slide so and here again the uh comparison with the segment routing header for ipv6 right so the idea of course is architecturally operationally the same we're just doing replication and for that we're carrying a segment three as opposed to a segment path and yeah so in unicast we had one uncompressed solution and then it just took us eight years to start working on the compression there which is what we're doing right now in 2022 and so hopefully we can for the"
  },
  {
    "startTime": "01:42:02",
    "text": "multicast part skip all the you know bad compressions or uncompressed options and uh directly go to the best possible compression um the forwarding is the same right segment by segment forwarding by swapping the ipv6 destination address from the forwarding information that i showed that's from the fib so that we have compression in the packet just bits for the neighbors and then in the fibs the next top ipv6 addresses and of course yeah we're replicating more than once that's the whole point of the multicast there are tlvs in the srh headers optionally for egress node functionalities we would think that we start saying we have the same set of tlvs but we'll have to work through which of these are applicable for multicast packets equally so that's some tpd work srh also has the programmability uh in the uncompressed version when you have long addresses we haven't seen use cases for these transit top programmability functions so we haven't considered that yet but if that is desirable to have um then we can look into this but right now it's maximum compressed so no programmability on the intermediate hops next slide right so then the next steps and mike was already alluding to this um so assuming that there is a community um across spring um and pim that wants to adopt this um we may need to figure out how to split that work between the working group that kind of understands the multicast technology which would be uh pim um and then six men for anything that relates to the rfc 8200 ipv6 extension header and coding details to make that compliant so maybe there needs to be some type of an architecture document equivalent to rfc 8986 which is"
  },
  {
    "startTime": "01:44:02",
    "text": "the srv6 architecture also for the multicast part of it as an extension to the srv6 architecture and then the extension header maybe as a six-man document i think um as soon as we see a sufficient support for the technology i guess across the working groups we're going to figure that out um and then of course the question is do we want extensibility of the compression mechanisms in terms of not um you know fixating only on one of course as you know uh here me representing rbs i think that's that's great is it sufficient do we want to be future proof by having options for multiple compression algorithm that's i think another important technical question uh that we should maybe look into more simulations of performance across the different mechanisms to make decisions on and i think that's it next slide yeah please show your interest i think pim working groups would be great to get the discussion started robin robin okay uh romeo so uh tourists in fact you know that's the one advantage of the of the srv6 you the incremental deployment based on the existing ipv6 network i'm not sure this this mechanism if the this mechanism takes the incremental deployment into account or not or the all the mechanism needed to"
  },
  {
    "startTime": "01:46:00",
    "text": "upgrade the whole network to support the rbis so i think this may be a challenge for the deployment so especially for the for the existing network right so so the answer is that um it can definitely work incrementally you only need to support rbs on the nodes where you want replication to happen but at that point in time what you need to do is uh to define the fib with the adjacencies of not directly connected next hops which is exactly what you would be doing with the loose source routing in the unicast case as well and that will work perfectly fine but of course you may have more adjacency bits then because you may you may you have just let's say for physical links so that's just four bits in a fully upgraded network but if you go to three or four hops you may need to have more bits there so the performance as far as how well is it compressed um for the incremental update case is is another good um you know performance evaluation that would need to be done okay my second comment is that uh you know that's the this uh in fact the multicast solution may be more complex than the unicast i think this is the good practice of srv6 is to provide some of these the euler solution for the srv6 so i think maybe in the drought maybe more euro situation can be provided or maybe there's a additional this additional euler situation draft accompany this drought"
  },
  {
    "startTime": "01:48:00",
    "text": "for better understanding about this solution yeah so i think right now what were i think also all the other drafts have only started to think about is the basic uh forwarding plane mechanisms and as i said uh um we may even need to split up that type of work between something to go to six men on the encoding side and the architecture in a similar way that we had it in spring um and uh in six men um and uh yeah none of none of this covers the control plane parts of it for example so um this is just the core from from from from from which that work is starting right yeah i think to me it's reasonable to do an architecture document and that's something that can uh move on with without having decided on the exact solution right that's it independent or whatever encoding we end up with yes i think you have the right uh strategy right here on this slide tour list is to take this discussion to pim i think it's the right place um since you are defining a new type of segment right that part would likely need to be discussed in spring kind of like the replication segment is something that's done in spring but we can stig and i can help figure that out if there's as we progress does that make sense okay and we need to move on to the last presentation we're right on time thank you"
  },
  {
    "startTime": "01:50:08",
    "text": "hi hi can you hear me well yes okay thank you uh this is joseon from huawei and i will introduce our work about multicast south routing over ipv6 traffic engineering solution next slide please uh here is the problem statement basically srv6 has already provided a solution for unicast service to indicate it p2p passed through segment least in srh for te scenario and there is no flow status is requested to maintain in the intermediate nodes which is very beneficial for deployment and also there are several srp2mp solutions under discussion for multicast te besides the previous two to presentations one of them is what has already been discussed in pim4 well as our p2mp policy uh solution uh in which uh sr ptmp3 is constructed by sticking a set of replication segments together through sr p2mp policy each replication node which will introduce a replication status in the intermediate nodes and another solution is previous work from juan more which is called srv6 p2mp pass assignment list for p2mp pass is provided to the ingress node and there are two arguments for each seed which is and branches and ncs to indicate the next level of subtree after replication and for this document we will provide a optional solution of multicast p2mp pass indication for multicast te on next slide please"
  },
  {
    "startTime": "01:52:02",
    "text": "uh before going to the detail of our solution i think we we can briefly review what has been done in srv6 in f and sr6 if there is a client package from the ce side in the p side the ingress node will encap the packet with fpv6 header and srh and again srh a second list will indicate the p2p path and in the end point um it will update the segment left by segment uh left minus one and the destination address is replicated uh replaced by the next active seed pointed by the same left which steers the packet to the next indicating node or adjacency in the t pass this is based on the behavior definition for the function of and or and dot x in rc8986 and the in the egress node when the seven left equals to zero uh the packet will be decapitated and forwarded to the ce side so that is the unicast method so what can we do for multicast next slide please this is our first solution we introduce a structural segment list for multicast tree the basic idea is that we we can define new function type which is called antidote replication through second list for specify the nodes which the multicast tree passes through and defines two parameters in each seed which is called the replication number and a pointer to indicate the replication forwarding relationship between the upstream and the downstream nodes so what is solution look like first there will be a second list just like the unicast in the segment list will contain all the seeds according to the indicated nodes in the multicast tree for example in the picture in the right"
  },
  {
    "startTime": "01:54:01",
    "text": "right hand there is an indicated multicast tree and for each node there will be a seed in the seminal list in a mod custom routing header we call it mrh and in each seed there will be three parts as the segment format just like the the unicast sr6 seed there is a locator there's a function and also two arguments one is replication number which could indicate how many packets to replicate in this node and another is a pointer to indicate the second left value of the first child node the basic idea here is that if it is a p2 p pass the the problem is very simple we just we just set the segment left by segment left minus one but if it comes to multicast the next hub downstream node will be a group and we cannot find the next seed only by minus one so we have to indicate how many packets will be replicated and where to find the corresponding seed so we have we we define these two uh arguments and so correspondingly the the behavior is then the packet will be replicated based on the replication number and updates the same on the left and the ipv6 destination address based on the pointer and forwarding the replicated packets to the downstream nodes next slide please uh here is a simple example and and i think i won't go to detail maybe if you are interested you can see the whole pro progress here in different notes next slide please and we can see in the previous solution the the drawback is also very obvious because we have to allocate a seed for each node in the multicast"
  },
  {
    "startTime": "01:56:01",
    "text": "tree the the header expense may be unacceptable when the tree is large so we we introduce some compression method to with local b stream the basic idea is like we we define a local bit screen in each seed which each beat represents a local outgoing port and if the packet is supposed to be replicated and go through that outgoing part the the corresponding uh bit position will be set and with the local bit stream the the multicast the seed for leaf nodes can be saved in assemblies so the the the header expense can be reduced next slide please uh here is a very simple example and you can see only one c that is needed in a tree like this at least uh next slide please uh here are some uh additional thoughts uh actually a new type of ipv6 routine header for multicast which is called mrh is mentioned before is proposed and we think this mrh is requested for different types of encoding p2mp paths maybe including the previous presentations and other possible options and so maybe we think more contributions are needed to make this header reasonable enough and be able to compatible with various encoding forms so and also maybe um corporations with six months will very helpful and here is a very simple comparison between two existing documents which are very similar uh one is recursive subtree"
  },
  {
    "startTime": "01:58:02",
    "text": "and uh for the the former the and another one is the layered replication behavior and the first one will pop the irrelevant segments after replication and the latter keeps all the segment uh just as srv6 does for unicast and same on the left is used to locate the active seed and for the local b stream method the locator could be omitted considering that local bit string is able to indicate the next top episodes prefix besides the output part and this method is also uh introduced in detail in our document if people are interested maybe you can go for it this will compress the the header further and also the different kind of solutions can be combined together to to be used and if the seed is too long and the segment can also be considered to be compressed as as what has been done for srv6 and srh next slide please so the uh we hope more people will be interested in this work because um p2mp passing coding can be complex but uh interesting and with a lot of possible solutions so we think more more work can be done here and for our document comments our feed and feedback will be very welcome and for the concept of of mr6 and based on ipv6 network we will we have already proposed above and if people are interested in this topic maybe not only in pim and relative working google we can also discuss in above okay that's all thank you"
  },
  {
    "startTime": "02:00:06",
    "text": "thank you appreciate you presenting any questions i think we have a quite a lot stig to uh discuss on the list robin has a question yeah okay you uh again so in fact uh these solutions propose this the uh multicast routine header but uh you know i think that's a little different from the from the srh because the eyes are only while rooting header but here because of this the different mechanism that the oddest mechanism needs the new multicast the routine header so the first we think we should think about how to convert this solution the second one we may think about how many types of image we need if more or more types of the mr rooting mrh are necessary so we need to a secret hesitator with the sex mahem so that's my comments on this one thank you tourist yeah just to respond to what robin was saying there so um the the proposals here um are saying that that we could basically just take one code point for uh the routing header um field space and then do a sub different subtypes for for different type of encodings and so on um actually you know the space is is is is is rather large in in terms of eight"
  },
  {
    "startTime": "02:02:00",
    "text": "bits and not many values being used there and for example in unicast we actually have two source routing headers already at least that i remember because the iot space has also done its own one and not only the spring working group and they simply took two different values from that eight bit space so we already got evidence that if there are multiple different options required for different use cases then you may not need to sub multiplex but you just get two different or three or four different code points there it's it doesn't seem to me as if we're running out there okay any other comments before we end up do any other comments dig not from me no great good well i can say that obviously yeah there's a lot to discuss on the mailing list and also how the work should be done forward in the itf and there's this buff and so on so yeah we'll see what happens next but uh yeah we should ideally have ongoing discussions on the mailing lists and not just just wait for the next idea for the next buff for sure get some rest dig feel better and thanks everybody for attending tim thanks everyone see ya all right bye thanks jordan thanks trellis"
  },
  {
    "startTime": "02:04:29",
    "text": "you"
  }
]
