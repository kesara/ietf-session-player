[
  {
    "startTime": "00:00:11",
    "text": "Good morning, Sweden. Morning. You can see on video. Too many of us right now. Yes. Yeah. Don't this right now. I'm actually surprised that, mike is picking me up Because that I'm on the transcript. Wow, impressive. I'll just present from the chair. No. You need to be standing on the. I think x otherwise Yeah."
  },
  {
    "startTime": "00:02:00",
    "text": "Last last of the week though it's always gonna be a little and fairly well attended, but the first two rows were nobody's. So all of the photos of her presenting, it looked like she was presenting to an empty so like, she took all of the photos and just, like, cropped out the chairs for yeah so you can see that. Alright. Let's let's good going. On on. Alright. So Hello, everybody, mostly online. Thank you for joining us. I'm here on and I'm here with with left for attending remotely And this is now for one one six You know twelve applies just because it all this week the twelve agenda for today, we will start with ten minutes on the the recent Sb extension four note five then and the main out of the meeting It will be and going through recent"
  },
  {
    "startTime": "00:04:00",
    "text": "to the the call protocol call and the resource server document and then we will discuss what's next. Has a little bit of status if you haven't been following we had quite a few major changes since the previous meeting and thank you to the authors. So that's the call protocol protocols there was also of the original server documents with which is the next thing we will be working on as we are pushing the call call and to And we would talk about that nine nine at the end of the meeting. I'm seeing here, two, including the right one on the list So Adrian, your next I think the adrian first time you so it can be a little You do need to unmute cell"
  },
  {
    "startTime": "00:06:20",
    "text": "Yeah. I'm not seeing anything in chat. Oh, yes. And Before start Fabian, yes, I would appreciate it if took notes today. I'm I'm doing that. Hey. Can you hear me? Sorry. Yes. Yes. Yes. Right. I'm unfamiliar with the pc Yeah. Put on video to something. Sorry for joining next. Had to jump through a heaps. Darren what what is the process for pushing on once in the slides. Alright. Think you can do it on your loan? Permission or you I have a spoke videos. So miss. Okay. Maybe I need to stop sharing myself. Like you should be able to pause slides control. On a slide deck that it's already shared, I think. So Adrian, why don't I share the slides Sure. Yeah. There's there's not many. You you can just advance through. Let... Let's not let's no waste take Okay."
  },
  {
    "startTime": "00:08:01",
    "text": "No. Let's go. Sure. So so for some context, Hi, I'm adrian I'm from medical Famous. This this map extension was put together by myself and my colleague Em amir. You you can advance the slides. Thank you. So so what this Id to describes is an extension that uses a technology called Sb sp secure payments confirmation as an interaction but fluke an. It's it's really appropriate for use if you're using app for authorizing a payment because Sb specifically a technology for authorizing payments. Sb sp is still evolving. So the this tech will evolve with with the secure payment confirmation back and and really the purpose of today is to share what we've done request comments implementation experience, so anyone is interested in implementing. You can advance them. Briefly secure payment confirmation is a work item out of the web payments working group at w. It's it's an evolution of of trying to use we n for payment authentication and authorization. And basically what it does is it adds some transaction data into the client data that's signed by the authenticator during a web interaction. So it's it's invoked and Api. Invoked by websites through an Api. It has some specific cross origin alliances which are different to regular web then. So if you're using see, you can invoke a relying party credential from a different"
  },
  {
    "startTime": "00:10:00",
    "text": "origin. So that allows a merchant for example at merchant dot com to sign a transaction where line body is, you know, back dot com. There's still a lot of discussion about exactly how that will work. So that's just very high level. It has a a payment and specific user interface. So that where as as much as as possible, the the the Api can't be used to, you know, trick a a user into doing something other than a payment. They'll know you know, when there when the apis in both, they know that there's the context is a payment. So it's to try and avoid sort of drive by tracking and tax and so on. You can unlock the slide. I mean, everyone here is familiar with graph. So so they should be straightforward. What has to happen first though is that the client is able to test that Sb is possible. So firstly, is the user in a browser session. But but then also testing the browser Apis to see that Sp is available. It's currently supported in advanced in Chrome. Which includes edge as far as I'm aware and and brave. So pretty widely supported on the desktop. And I think in Android these days as well. But pretty strong support for the technology from Google. So expected to be available in most common based browsers. The client does a regular grant request from the eighth And when they do this, they will specify As a possible interaction mode. But in an essential prerequisite here as well that they will provide some sort of identity hand or session. So as you can see in the next step, what's required is that the as then"
  },
  {
    "startTime": "00:12:03",
    "text": "you know, based on its policy, maybe determine that Sd c's for the preferred interaction. But it also has to check that it it has the user or what it thinks is the user on the side is has enrolled some product credential before. Or or specifically an Sb credential. So again, there's some discussion about differentiating a payment credit from a regular credential and with regular credential could be reused. For signing a payment. The As returns a response requesting the client to perform my see and the data point data that it provides back are a challenge and candidate credential Ids that can be used. The client would invoke Sb. So in this case, the assumption is the client is able to in invoke a web Api on the end users in the end users browser. It passes the payment details things like description total, the credentials, the challenge. And so on into the Apis or it inputs into the c Api and whatever the response is is returned back see the As to finish the interaction. And then the As will. Know, to determine whether that's appropriate or authentication or not and and the the ground press continues. You can have advance the slide. I've mentioned a little bit of this, but the the pre prerequisite it's obviously the client needs to check that Sb is available. So there are some improvements they api being proposed to make this a little easier Cardiac key at the moment. We detail this in the appendix of our internet draft how this can be done. The client does need to provide some identifies or at station. So"
  },
  {
    "startTime": "00:14:02",
    "text": "This could be a completely anonymous session, but I think that's So so knowing the As url is is not sufficient I need to know the As as well as the identity of the of the end user. And then the client may provide some device data. So one way that a lot of payments is will identify the end user is to be through device data. That is recognizable to the align body so to the bank for the wallet to ever. Or authenticating the user. Because basic recognition is sufficient initially the the user will be fully authenticated ones they've completed. So we're haven't some discussion and Justin has been has been assisting a man I. Think about how best to pass this data in the request. Something like a browser fingerprint or or Or similar. You can advance the slide. These are just examples from the spec. As you can see in the branch request. We are with the start mode, some board start mode the S sp c. That's that's the only addition into grant request. And then the response from the As has all of the details of the Sd how client can invoke the Sb. So there'll be an array of credential Ids. There's binary they those are convert to buffers passed into the into the browser Api, the challenge, which is, you know, you unique challenge generated by the As much the same as with web in. And then a recent addition is a payment instrument details. So some discussion as well exactly how this should work because it may not be the case that this has been identified or"
  },
  {
    "startTime": "00:16:03",
    "text": "or there may be multiple instruments. But this impacts the user interface that's shown to the user. As will be seen on the next page and and the icon be shown property is a property of the Sb sp Api. Where a body can instructor the browser that if it's unable to fit and render the icon that it should automatically fail the authorization. And we can advance the slide. So this is an example of invoking the Api, in the browser. It uses an existing Api called payment request. Where the payment method is set to be secure payment confirmation. This is likely to change as well. Currently where you know, this is sort of experimental work that Chrome I'm doing in the browser using the payment replace Api. It's possible this will switch to using the credentials Api the same as wei vendors does. Again, that's a good have issued discussing all of this. And you can see here most of what came back in the response from the As maps see into into fields in this api. Finally with the the details of the payment at the bottom. You can advance the slide. Thanks. And these are the user interfaces that are currently shown. We've just recently finished a working group, virtual face to face. Some discussion about the second dialogue. The the reason why a dialogue is always shown is privacy reasons. So if the Apis invoked, the usual oi C Ui, it's not for merchant to silently work secure partner payment confirmation. But some discussion about what that second ui should look like. It may actually show the payment details and and request the confirmation rather than"
  },
  {
    "startTime": "00:18:00",
    "text": "simply showing a notification as case there. But as you can see the in the Ui, you see an indicator of which merchant, you know, the the the origin and I think another addition is a a merchant name has been added. To the origin of the merchant the label and and icon. And then the total a lot of discussion about introducing support for recurring payments think will be a very challenging one. But but possibly in scope for future work in the working group. You advance. And then finally, the the on the left, you can see what there is response would look like coming back. To the browser. This is just a a log of the power credential object exactly the same as one would get in in web of. And then the response within that object is what we map into the the response center the wire back to the aes. Just translated basically for encoded and sent back. Can advance. So so... Yeah. I mean, that's it. It's it's not a complicated spec. We will continue to updated as as the Sb c involves One thing that we haven't at this point, which I think is important is some opinionated access token sc that maps more to the data that's in an Sb request. So you would seen the payment details in there. It's obviously important that when an As evaluates heart cannot payment confirmation that the grant that's being requested actually matches what was authorized by the user. So we may put some more specifics either, you know, strongly opinionated or strong requirements."
  },
  {
    "startTime": "00:20:02",
    "text": "About what's in the grant request just so that that there's two map to together cleanly. And then some sort of a general question if if anyone it's using wei fan in the context of Nap weather, it's worth exploring a more generalized interaction but for web and, not paying a specific And then finally, we've done some concept videos of what this looks like with the caveat that our wallet fan as well it uses what a payment pointer, which is a Url. That's sort of a handle for your wallet. So if you watch that video, you'll notice the user types in a Url as a way of identifying themselves and then invoking the As. But but it'll give you an idea of what the the flow looks like for an end user. And that's me. Thank you very much. Comments questions. So I have a question. Why do I need the on you So sorry. Again in the queue. No. No. Good good good For it. That's fine. I'll I'll just jumped in after that. Yeah. What why do we need the on new instead of just adding, like, Well, I mean, I think it is a it is a very Specific interaction mode. It's it's... I don't think it fits in to any of the existing interaction modes. Otherwise, a generalized."
  },
  {
    "startTime": "00:22:02",
    "text": "Well, this is this is my thought is... I think it could be generalized to be a web within general interaction mode. But I'm interested here. I mean, our specific interest is in Sb c. So think we'd need to have input on how folks would use it with Wave thin and not To to come up with instead of data points that map to both. Right? I was gonna make a similar comment. I mean, he asked at the end of the presentation, whether or not this this could be generalized to to a more sort of wider case, and I think it can. There were a lot of specifics in Sp c, a lot of specific details about how things match app like you must identify who the user is. Otherwise, the kinda the the details of the use case don't make sense. Whereas in web, you might not know who the user is yet. So you're just saying to give me who's there. So it's possible that this could be this itself could be a further extension of and as of yet undefined abstract web based interaction type. That said though the the existing interaction types don't really fit with the types of parameters that this that this needs in order to get info back and forth. And this is exactly what the extension point for interaction methods was designed for. You know, there's something different you you want the user... The end user to do? At the client in order to get information to the As the resource owner. This is this this is what this extension point is for. Yeah."
  },
  {
    "startTime": "00:24:05",
    "text": "Well thanks so lot I think it's a very interesting use case. And Personally on the question with web and would be interesting. I think it is clearly but I got a different question and the relationship to ledger first. And then I was wondering a bit the protection again. Fishing for payment. So do you see that or Yeah. There there's there's no relation to intelligent. That is this is, you know, a separate piece of work. I think this within the installation community, we're working on a set of Apis called open payments, which would be resource resource survey Url resource server Apis that are protected by map. And and this has been part of our sort of work and experimenting around how you would authorize that sister to those. So so no direct relation. But but of a spun off out of that work. Protection against the against fishing. Could you expand on what you mean by that? We won't to describe that attack you you have in mind. I'm I'm not exactly sure but the fact of having payment errors that actually if I understood where what what you're doing is is basically it's it's kind of redirection in your resource server, you've got the description for for the payments. And so if it's if it's available as as a dollar url as as your doing okay. Your View, it could be publicly available. And so you could try to bypass that for for in in in some way. I think web in that case is quite interesting. But how do you actually make the"
  },
  {
    "startTime": "00:26:01",
    "text": "the mapping between the actual user and and the key that's the line. I mean, that's that's kind of my question here. It's it's probably not very clear. Because No... It's it's it's it's not specific to this this piece of work. So the the payment point is all the Urls is a wallet address. Is a is a separate piece of work. I just mentioned it because example maybe confusing without the context. But but just to answer the question, so we issue a unique Url to everyone who signs up for a wallet, and it's a it's the idea is that that Url is the entry point to the resource the Apis the... Everything everything you access up those Apis needs to be authorized through a map interaction. So I think we would it it'd be quite challenging to do some redirection there. Without... Unless we're talking about front channel redirection the that's sort of a different consideration. But I mean, happy you take the offline I mean it's not really relevant to this piece of work directly. Okay. Okay. Yeah. But it makes sense, but it means that the app security considerations are quite useful in that in in that specific. Yeah. One finds it's very interesting work? Next is adrian g. So I hope this isn't totally lay in question, but one of the things I'm curious about in a newbie sort of way. When a request is made through the authorization server, that request might need to come with a payment."
  },
  {
    "startTime": "00:28:02",
    "text": "A deposit to pay for the processing. Is this in any way related to that? And can you just give a very high level idea of how this would relate to enhancing the request with a payment component. Or a deposit component. This this itself does not but I think Sb sp may have a place there. So so this extension describes way to use Sb as interaction mode. It's it's I guess possible that one could One could update this to make the interaction mode a request for payment, more of a request for payment. So provide pc the same response data which would allow the client to authorized the payment or authenticate the user but also specify the details of the payment that need to be made on the assumption that the authorization server can actually execute the payment. So the flow I'm thinking about is the user wants to perform an action the client or or at least the client would it would request a grant from the As and the as would determine that that grant needs to be paid for and that Sb is a possible way to get the end users consent and authorization to make the payment and that the payment is coming from the end user. And the As has, the ability to actually you know, make the payment to execute the payment given the user's consent. So that could be one one use case, another could be that the that Sb is done ahead of time and that the the public key credential from an session is passed an initial branch to request to some some sort of a assertion."
  },
  {
    "startTime": "00:30:01",
    "text": "Just as a proof that users consented to make a pain meant for the grant request. But in in both cases, I think this would assume that the purse... The the entity paying for the grant is the end user. Because Ready is a a way of getting authentication and signature the transaction details from the end user. Thank you. Alright. Thank you, Adrian. Thank you. Thanks everyone. Mobile thing. Can give me slide control or think I've requested it. Okay. Alright. Cool. Only got a handful of slides here. So everybody. Justin Richard. And and Fu on as well. We're gonna go through the the changes to both the cord draft and the Rn draft and then close out with and and discuss some hopefully, final pending issues there. Figure out where we wanna go with that. And then close out with lead into to the discussion of where the editors believe the draft is and what to do next. First off, we as is tradition, we put a link to the diff in in the deck here. We've done two revisions since I f one hundred fifteen. A lot of text changes, but not a lot of protocol change"
  },
  {
    "startTime": "00:32:01",
    "text": "says it's been the case for a while. We filled out the ion sections. We clarify a bunch of things to token rotation, things like that. Not really a lot of changes for like, the the bits going over the wire there. I'll get into the actual details here. So One protocol change that is there is that we shifted to s to two fifty six as the default hash mechanism. This builds on top the work that Aaron had done ahead of atf one fifteen. To switch us over to using an existing diana registry for hash algorithms. And Honestly, the only reason that S three had been the default performance was because I picked it. It wasn't really compelling reason and S two fifty six is much much more widely available and gets the drop done. So there's there. We added an extensive amount of tax to define the the ion registry actions. And figured out... And then just laid out. What all of the different need to be for the different parts of the protocol This also helped us. Really nail down what the extension points were. And what how they're intended to work what they're intended to be used for So all of that's in the various Sections. For the key rotation, previously, if you remember we added that ahead of the last meeting, We took a look through all of the actions that that had a presentation of a previous key value. And realized that that was actually not needed in any of those cases. So we remove that"
  },
  {
    "startTime": "00:34:00",
    "text": "because the the previous key material was was already known through other Mac in every single presentation mechanism. So it was redundant and confusing to to repeat it in all of those cases. And also potentially opening a very esoteric security vulnerability if you could lie about the previous key. But we we took it out so that's not there anymore. One of the big textual changes is clarifying some of the differences between what a new token is versus what it rotated token value is. We realize that there's probably still a little bit more work to clean up some of that. But I think get believe that the new text is is a lot more precise about when you would want to do each action. Part of this also boiled down to some of the sections not being adequately tied into the the grant request state diagram that was added within the last year. And so we've been able to to tie those together. And finally, a lot of what we did was respond working group last call comments. So thank you for the handful of folks that read through the document provided those. We have responded to nearly all of them at this point, there's a couple of open questions, which will get you in just a few minutes. But hopefully, there are open questions that we can we can wrap up. Pretty quickly. On the resource server draft, which hadn't seen any input in in in quite a while. We started we had actually went in and filled out to the abstract token model. This is a a description of a data model, not a description of"
  },
  {
    "startTime": "00:36:04",
    "text": "fields inside and access token. So this is not a job replace type of thing, but it's something that would inform the kinds of things that you would wanna store in your system, whether it's stored in the jaw or in a database that then gets spit back in in intros. We also expanded the intros section so that it point now points to bits of the token model and and what have you. Please take a look at that. That's almost a new text, but it shouldn't be any new cons steps in any of that. So please read through those. Also it did the... When I did the Registry for core, I did the same thing for the pieces in the in the R draft. Alright. The token model itself consists of these a hesitate to call them fields, but aspects of the token. So there's the value of the token itself. Some identifier for who issued it. Some identifier for who's supposed to consume it. Some point or two which key. It's tied to at any given point any flags associated with it such as whether it's better or durable, whatnot. Set of access rights associated with the token of validity window when that token can be presented and in the system. Some type of pointer to a resource or set of resource owners that approved access to token? A appointed to the client instance label for the token and the grant request under which this token was issued. Not every token is gonna have every one of these bits. But experience in the off that showed us that at least presenting people with a a model like this will help developers that are setting up their system"
  },
  {
    "startTime": "00:38:00",
    "text": "from the first time not be surprised when they realized I'll wait, I maybe I should have tracked for example, which client I issued this too. Over overtime and not have to sort of perhaps that kind of thing in at a later date. The token model is is therefore for designed to be informative, non norma, but something that can be referenced by other systems that need to depend on this. But before for before moving on, any questions or discussions on on the token model because that is new text not sure if anybody's gotten a chance to read that yet. Okay. So It's mostly these to because the nasdaq aspects it's to the common security why aren't we're making So the layer of I'm I'm honestly, I don't have a good feeling for where that where that where that type of weight would fit? Right. So for example, it's it's longer that all tokens do have value but does the token itself need to remember who issued it? Maybe? I... You know, it's... And and Because this is a this is a data model. I think it's it's a little It it it ends up being a little iffy to, like, where you end up putting this stuff. Some systems. Some of it's gonna be baked into the token model like using a job. Some of it's gonna be"
  },
  {
    "startTime": "00:40:00",
    "text": "stored in the back end system. Like, you're probably not gonna put a parent grant identifier inside job. But, you know, in a lot of cases you probably want. So I think it's a great question though is which of these should be norma and which of them should be tied to very strongly worded security in privacy considerations. Because for example, revealing the identity of the resource owner in the access token is a privacy concern. You don't want every everybody in the system to know that. At all times. You probably want the authorization server to know it in most cases, but there are use cases where the as isn't gonna necessarily know the identity just that somebody said it was okay. This gets you know, it's it it it it gets fuzzy really, really, really fast. And so that's why we've presented it as a non norma model except for except for the token value because all all tokens need to have a value in order to be presented. Beyond that. You. Alright. There are two major time open issues on the core document, when dealing with Token management and one dealing with interaction finished methods. Fabian and I had a couple of discussions about these and we have proposals about how to dispatch each of these. And if working group generally agrees. Then we will do these and and do another revision of the document. So up. The token management endpoint is a less exercise portion of App so far a lot of the implementations that we've"
  },
  {
    "startTime": "00:42:02",
    "text": "seen are more concerned about getting the tokens and using the tokens less about sort of managing the life cycle directly over time. That said, does still define a way to do this. And currently, it's set up where you present the token being managed just as you would present to any other access token. So the access token is its own access token for its own management. And then you always sign that request with the client instances key? Even if it's a bearer token. Problem with this. Which is... So the first is a point that yarn raised in his last call review. And that's the the token could be expired and we actually called this out in the draft. That this is something you might wanna consider if you're if you're doing this. And Adrian actually brought up the fact that the use of middle where to do token processing would get in the way of this pattern as well. So if you have something that is doing your token process to sing on the way in, then it would be rejecting otherwise valid requests. Which is a problem. The main... The main thing here is that semantic, this is a different type of action than accessing a resource server and so using the same semantics. For presenting an access token in this case. It's not as it's not as architectural clean as the rest of the protocol really strive to be. The idea here was that we already have an access token we have a means to present an access token let's just do the same thing we do elsewhere. The problems with that are you know, that you're not actually treating it the same way that you do everywhere else. So the proposed the alternative that's been proposed."
  },
  {
    "startTime": "00:44:01",
    "text": "Is that you pass the token value as a body parameter, So we've already got a precedent for that in the intros call from the Rs how to pass a token value and and potentially other other data, but probably not. For rotation and medication. You pass that to the token management endpoint you still have to sign the call to the token management endpoint. But This is an an interesting proposal has been floated that you could have a secondary token issued to protect the token management endpoint itself. So we already also have precedent for doing this type of special issue access token with the continuation endpoint. It is a special Api controlled tightly by the As. That you are given an access token which does not have optional keep binding it cannot be a bearer token. And you handed both the token in the Uri in in the data structure that is pretty easy to consume and use. We know this is like, at the core of, you know, So doing the same kind of thing for token management is out side the realm of reasonable nest. It's just it's not what's there right now. So You talked about this. And Fabian and we're thinking that This would be a change But we think it's probably actually worth doing because again, this is a less exercise corner of it, and if we don't change it now, then somebody's is going to run into problems with this in the future and better to sort of align it now with the with other parts of the protocol then to then to have coming bite us later. Right. The question about the secondary access token, I I don't know if that should be optional or"
  },
  {
    "startTime": "00:46:02",
    "text": "that should just be mandatory like it is with continuation in point. It would be pretty simple to make mandatory. And if you're not doing... If you're not enabling token management for an individual access token, then you don't need to worry about it. So you know, it's it only affects people that are doing this this specific thing. So with all of that in mind, we think it's probably worth changing this changing this code. It's a norma change, but it would align with other parts of the protocol and we do think it makes sense. So give thoughts feedback on that. So yes, let's make this change. And if we can avoid the optional Let's avoid it. Okay. That makes sense to me. Fabian, Do you agree with that? I know we talked about the optional access token Yeah. I think it makes sense to try to simplify as well yeah. Okay. That makes sense. And in which case, we'll probably a lot of the text from the continuation Api because it's it's gonna be a parallel structure. You've got a Uri in an access token, and we can a lot of that. Already has a lot of the appropriate cutout that have been hash over a lot. So... Okay. Awesome. So we will do that. And we'll get that in in an an extra revision to the group very soon. Alright. The the other issue that got brought up is having multiple finish methods. Currently, the client can send multiple start methods but only a single finish method. And the As responds to that finish method, or it doesn't respond to the finish method."
  },
  {
    "startTime": "00:48:01",
    "text": "Because the always has the final say of what is allowable in the context of a of a request? Now the problem with this is that client might not always be able to guess which methods are okay ahead of time it could be contextual to the grant request. And so even if the client could support multiple different kinds of things. The server might say no and then the client would have to start over. And that's kind of anti to the whole dynamic negotiation that can happen enables. Throughout the protocol. That said, there are security considerations with with Having multiple methods so the proposed alternatives is to allow the client to send multiple methods. Have the As respond to exactly one or zero of those methods. So the as looks at the list in picks one. And in a simple case, the client is still sending only one. We would be using the same type of you know, Jason Poly to to have the same structure in multiple ways if we were to do this. From a security perspective, the As would be forced us to choose exactly one or zero. In its response. The reason for this is that it's sets a... If you respond to multiple finish methods. It's that's a the client up for waiting for things in multiple channels. And there's potential security race conditions. And so this is why we reject at having multiple finished methods when we when we did the whole interaction ref two years ago, whatever that was. The big thing that Aaron Aaron pushed. So that's why there's only one coming back. The proposal is to keep that only one on the way back, but to you allow the client to send more than one on their way in."
  },
  {
    "startTime": "00:50:00",
    "text": "Now, we editor talked about this and our thought was that this could be deferred to an extension. An extension that would define a multi finish mode or something like that. Because this does kind of cut into really core portion, you know, the interactions section is is is fairly core. We've tagged this need tax, the person who proposed it has said that they would be interested in helping provide that, but we wanted to get a feel from you know, the chairs in the group as a whole, because there hasn't been a lot of other conversation about this. Whether this is a feature, we should try to patch in now. Whether we should defer to an extension or just leave a ping. To help on the stand the decision. Can you say a few more words about how this can be added as an attention are the actual extension points that would allow it Yeah. So right now the finish method in the request is defined as an object. With a type an extension could define finish method as an array. For a multiple type. For a or a finish method type that allows multiple fields. Underneath. Two ways you could do it depending on what syntax you wanna do. Bike shedding syntax is always you know, a fun part of stuff like this. The... And and this is part of the problem is that there's really a good parallel in other parts of the coat and in and on parts of back that we could just you know, unlike the last section where we're were like, oh, this looks really close to this other thing. So we can just"
  },
  {
    "startTime": "00:52:01",
    "text": "mostly copy paste that concept. That didn't really exist for this. So we think it would require a bit more hammering to to get it right. That said, the finish methods are intended as an extension point. And so allowing something that means hey, authorization server, choose between these. Would be a potential way to handle this as an extension. So so mean this would be a new finish method. With functional. Yeah. With an array, basically. So we could handle it as an extension. We could try to hammer something in now. I'm a little afraid that you know, because it's a so far, it's it's been a the request is... Has been like, wouldn't it be nice if it did that to me that those those types of things without you know, more sort of hands on deployment always make me a bit nervous. That said if there is if there was a strong call from from an implemented from the working group like, I I think I see a path for how to get this in. And potentially how to get it in without without breaking backwards compatibility. For for people that are doing just single finish methods today. Especially because the client... The the client what the client receives from the as wouldn't actually change. It would still just be a single response. And then that's it. So we could we could try to put it in get a P see how people felt about the text, or we can just say not right now and move on with life."
  },
  {
    "startTime": "00:54:01",
    "text": "We're not hearing any objection from the room lot would say let's defer Okay. Sounds good. And like I said, the person who submitted the issue was was okay with that as well. So Alright. Alright. That's That's that's the editors update. Working group last call is finished on core. We've decided We just decided what to change for token notation. I think that I think that path makes does make sense. And in my opinion and I believe Fabian opinion with that change, it should be ready for It last call. Any inputs on the status maybe left Yeah. I mean, I I think we should try to kinda of stick to w working with past school as closely as possible there. And we... I mean, you did say during your presentation. Nothing that you got there quite a lot of working hooking those comments and do you kinda clear those ways. And Do you feel that there are there were so many of them that this warrants another those Sorry last call. Who should we just sort of wrap this up. Was that question to me or? Yeah. To to to you Yellowstone and empty own, but first of you. In my opinion, I don't think that the changes actually warrant a another another round. Yeah."
  },
  {
    "startTime": "00:56:00",
    "text": "And the token rotation would be the biggest change. Yeah. And that karen, what do you think? I tend to agree with justin here. Yep. We will need to review token rotation. Of course, we will But other other than that, I think it doesn't require a second last call. Yep. I mean, the in... Right. Think in might experience for for groups that have a fairly tight circular contributors. Like pushing it to it teflon called, it's usually a good idea because you kinda get that broader review that people don't pay attention to work anyway. Right? For some reasons. Right? And just get it to Loss call and then be ready to have a longer lost Loss score. Because that might happen. Yeah. We... Got works for me. No. I think we plan to be ready for the comments anyway. So... Yeah. Yeah. Yep. Alright. Cool. We will put in the token rotation change, get a new revision and kick it down the road. So That means we're gonna need a shepherd right up and then eighty review Right? I recall. My question to the details and to left again, do we need an enter interim meeting at all? I It can't hurt given that we're doing token rotations. Right. So maybe schedule something within a month or so to talk about token rotation. Yeah. That's that's fine with me. And we can we can scope it pretty to that and that change that and that'll give Fabian and and eye target to make sure that we got the new tax. Mh."
  },
  {
    "startTime": "00:58:00",
    "text": "Yep. Sounds good. Alright. I think that's a good idea. Alright. I'm gonna unsure. That's that's all I had. Thank you. About? Alright. Right, right. Right. So There are still some There's still some outstanding issues on the Rs draft getting the token model was probably the biggest one and addressed a lot of it addressed a lot of the the holes that made that draft so draft. And I think a lot of what's left in the R draft is know, tightening up a lot of the language and getting more people to actually read through it. In terms of, like, making sure it's like self consistent and understandable and all of that other good stuff. So yeah. I think overall, I I think we should be able to have the Rf drafts ready for working group last call at least by July. By San Francisco. Because because I don't think there's a lot left to be done, but we need to do our due diligence to make sure that we are we're actually hitting all of the points. It is necessarily a much much simpler component than core. I mean, course course huge. It's like two hundred pages right now with all the examples and everything. So yeah, The Rf draft. I think we can get it to working group ready... At least ready for working group last call by summer. If not, in working group last call by Ig ihs summer. If if if the chairs can Like"
  },
  {
    "startTime": "01:00:01",
    "text": "help Help. Capture that momentum. And the question to the any I know it's queuing. So gem digital formerly asked formerly norton formally secure key. Posted their newly newly released open source implementation. Which is now in I forget if that's in the editors copy or if that's in the draft, we just published. I I forget if that made it off the line or not. So there's there's that implementation. I need to do some updates to my java implementation x y z, especially as we're doing the token rotation I wanna make sure that the data structures are implement. As we've been doing every recent step for every change on here. So I need to do that bit. But those are... Those... Those are the ones that I have heard about. Those two changes. Quite possibly. And actually,"
  },
  {
    "startTime": "01:02:03",
    "text": "Adrian, Adrian Family and I just started to station about adapting the conform suite Adrian. I don't know if you wanted to to say more about that. Sure. So so we we did some experimental work. A few months ago to see how easy it would be to adapt confluence confirm week from it was not actually made doing the work. So I can't speak in detail. But that's something we'd like to pick up and continue and actually use internally at Vein as well to as sort of the test suite if you like for for our implementation. So definitely, yeah, we we're interested in contributing to to doing that as well. And Joseph He who was was here but had to in in the room had to duck out earlier. He's actually the lead developer. Of the suite these days. I had a couple of conversations with him this about how any you know, Flavored version would be able to work with their stuff. So if it requires changes upstream so that we can modular things or whatever we need to do. We should be able to do that. We've we've got good connections to to the dev team at o f. Alright. So they're not making publication of our conditional implementation if Yep. Agreed. It's not real if nobody implements it. We we have two implementations. Just to add to that."
  },
  {
    "startTime": "01:04:01",
    "text": "So so we have a internal one written go that we use a and there is open source implementation, written types. That was is part of project name community. It's still pretty un tested, but it's core component of that project. So it'll probably be it it it will certainly continue be continuously maintained for a while. Yeah. Raf is listed in the implementation sections of the draft. We don't have the fin internal one. Listed there yet, but we can they're We we came those proprietary implementations. Yeah. We may open source as aspects of it in future for now that's not a priority. So yeah yeah. Yeah. We Yeah. So verified me the verified me product. Uses an earlier version of in their production systems, but it's an entirely, proprietary carrie stack. So they're not really outside of their their bubble. At the moment. But it it is still listed under the implementations. So unfortunately, yeah. Unfortunately, they wouldn't come to the hack on with that code. But But, yeah. So we can... Adrian if you either wanna submit a poor request or send the information to the list. We'll make sure it gets it gets listed. Alright. Any other comments question"
  },
  {
    "startTime": "01:06:01",
    "text": "just for the notes do... I mean, I I took notes during the session have anything to do to publish or whatever or is it doing that automatically. Oh to publish the notes? Yeah. Yeah. They're they Yeah. It saves automatically. Yeah. That's that's something that the chairs do in the back end. Great. As long as you used to note taking tool Yeah. Yeah. That's that's fine. Yep. You idea. Alright. Thank you all. Thank you. Thank you. Yes. I think we would need to reopen this work group at one point. I mean, if I able get reopen. Yeah. I mean it was also like So about"
  }
]
